// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";
import * as utilities from "../utilities";

/**
 * Provides a EMR Cluster resource. With this you can create, read, and release  EMR Cluster.
 *
 * > **NOTE:** Available in 1.57.0+.
 *
 * ## Example Usage
 * ### 1. Create A Cluster
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const defaultMainVersions = alicloud.emr.getMainVersions({});
 * const defaultInstanceTypes = defaultMainVersions.then(defaultMainVersions => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: [
 *         "MASTER",
 *         "CORE",
 *         "TASK",
 *     ],
 * }));
 * const dataDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[];
 * for (const range = {value: 0}; range.value < (_var.vpc_id == "" ? 1 : 0 == true); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {cidrBlock: _var.vpc_cidr}));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[];
 * for (const range = {value: 0}; range.value < (_var.security_group_id == "" ? 1 : 0 == true); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`defaultSecurityGroup-${range.value}`, {vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id}));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[];
 * for (const range = {value: 0}; range.value < (_var.vswitch_id == "" ? 1 : 0 == true); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: _var.availability_zone == "" ? defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId) : _var.availability_zone,
 *         vswitchName: _var.vswitch_name,
 *         cidrBlock: _var.vswitch_cidr,
 *         vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("defaultRole", {
 *     document: `    {
 *         "Statement": [
 *         {
 *             "Action": "sts:AssumeRole",
 *             "Effect": "Allow",
 *             "Principal": {
 *             "Service": [
 *                 "emr.aliyuncs.com",
 *                 "ecs.aliyuncs.com"
 *             ]
 *             }
 *         }
 *         ],
 *         "Version": "1"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const defaultCluster = new alicloud.emr.Cluster("defaultCluster", {
 *     emrVer: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.emrVersion),
 *     clusterType: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.clusterTypes?[0]),
 *     hostGroups: [
 *         {
 *             hostGroupName: "master_group",
 *             hostGroupType: "MASTER",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "1",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "core_group",
 *             hostGroupType: "CORE",
 *             nodeCount: "3",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "task_group",
 *             hostGroupType: "TASK",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *     ],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId),
 *     securityGroupId: _var.security_group_id == "" ? defaultSecurityGroup.id : _var.security_group_id,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: _var.vswitch_id == "" ? vswitch.id : _var.vswitch_id,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 * });
 * ```
 * ### 2. Scale Up
 * The hosts of EMR Cluster are orginized as host group. Scaling up/down is operating host group.
 *
 * In the case of scaling up cluster, we should add the nodeCount of some host group.
 *
 * > **NOTE:** Scaling up is only applicable to CORE and TASK group. Cost time of scaling up will vary with the number of scaling-up nodes.
 * Scaling down is only applicable to TASK group. If you want to scale down CORE group, please submit tickets or contact EMR support team.
 *
 * As the following case, we scale up the TASK group 2 nodes by increasing host_group.node_count by 2.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const defaultMainVersions = alicloud.emr.getMainVersions({});
 * const defaultInstanceTypes = defaultMainVersions.then(defaultMainVersions => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: [
 *         "MASTER",
 *         "CORE",
 *         "TASK",
 *     ],
 * }));
 * const dataDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[];
 * for (const range = {value: 0}; range.value < (_var.vpc_id == "" ? 1 : 0 == true); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {cidrBlock: _var.vpc_cidr}));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[];
 * for (const range = {value: 0}; range.value < (_var.security_group_id == "" ? 1 : 0 == true); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`defaultSecurityGroup-${range.value}`, {vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id}));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[];
 * for (const range = {value: 0}; range.value < (_var.vswitch_id == "" ? 1 : 0 == true); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: _var.availability_zone == "" ? defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId) : _var.availability_zone,
 *         vswitchName: _var.vswitch_name,
 *         cidrBlock: _var.vswitch_cidr,
 *         vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("defaultRole", {
 *     document: `    {
 *         "Statement": [
 *         {
 *             "Action": "sts:AssumeRole",
 *             "Effect": "Allow",
 *             "Principal": {
 *             "Service": [
 *                 "emr.aliyuncs.com",
 *                 "ecs.aliyuncs.com"
 *             ]
 *             }
 *         }
 *         ],
 *         "Version": "1"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const defaultCluster = new alicloud.emr.Cluster("defaultCluster", {
 *     emrVer: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.emrVersion),
 *     clusterType: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.clusterTypes?[0]),
 *     hostGroups: [
 *         {
 *             hostGroupName: "master_group",
 *             hostGroupType: "MASTER",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "1",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "core_group",
 *             hostGroupType: "CORE",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "task_group",
 *             hostGroupType: "TASK",
 *             nodeCount: "4",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *     ],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId),
 *     securityGroupId: _var.security_group_id == "" ? defaultSecurityGroup.id : _var.security_group_id,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: _var.vswitch_id == "" ? vswitch.id : _var.vswitch_id,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 * });
 * ```
 * ### 3. Scale Down
 *
 * In the case of scaling down a cluster, we need to specified the host group and the instance list.
 *
 * The following is an example. We scale down the cluster by decreasing the node count by 2, and specifying the scale-down instance list.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const defaultMainVersions = alicloud.emr.getMainVersions({});
 * const defaultInstanceTypes = defaultMainVersions.then(defaultMainVersions => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: [
 *         "MASTER",
 *         "CORE",
 *         "TASK",
 *     ],
 * }));
 * const dataDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[];
 * for (const range = {value: 0}; range.value < (_var.vpc_id == "" ? 1 : 0 == true); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {cidrBlock: _var.vpc_cidr}));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[];
 * for (const range = {value: 0}; range.value < (_var.security_group_id == "" ? 1 : 0 == true); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`defaultSecurityGroup-${range.value}`, {vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id}));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[];
 * for (const range = {value: 0}; range.value < (_var.vswitch_id == "" ? 1 : 0 == true); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: _var.availability_zone == "" ? defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId) : _var.availability_zone,
 *         vswitchName: _var.vswitch_name,
 *         cidrBlock: _var.vswitch_cidr,
 *         vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("defaultRole", {
 *     document: `    {
 *         "Statement": [
 *         {
 *             "Action": "sts:AssumeRole",
 *             "Effect": "Allow",
 *             "Principal": {
 *             "Service": [
 *                 "emr.aliyuncs.com",
 *                 "ecs.aliyuncs.com"
 *             ]
 *             }
 *         }
 *         ],
 *         "Version": "1"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const defaultCluster = new alicloud.emr.Cluster("defaultCluster", {
 *     emrVer: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.emrVersion),
 *     clusterType: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.clusterTypes?[0]),
 *     hostGroups: [
 *         {
 *             hostGroupName: "master_group",
 *             hostGroupType: "MASTER",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "1",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "core_group",
 *             hostGroupType: "CORE",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "task_group",
 *             hostGroupType: "TASK",
 *             nodeCount: "2",
 *             instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *         },
 *     ],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId),
 *     securityGroupId: _var.security_group_id == "" ? defaultSecurityGroup.id : _var.security_group_id,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: _var.vswitch_id == "" ? vswitch.id : _var.vswitch_id,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 * });
 * ```
 * ### 4. Create a emr gateway cluster
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const defaultMainVersions = alicloud.emr.getMainVersions({});
 * const defaultInstanceTypes = defaultMainVersions.then(defaultMainVersions => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: ["GATEWAY"],
 * }));
 * const dataDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes]).then(([defaultMainVersions, defaultInstanceTypes, defaultInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: defaultMainVersions.mainVersions?[0]?.clusterTypes?[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultInstanceTypes.types?[0]?.id,
 *     zoneId: defaultInstanceTypes1.types?[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[];
 * for (const range = {value: 0}; range.value < (_var.vpc_id == "" ? 1 : 0 == true); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {cidrBlock: _var.vpc_cidr}));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[];
 * for (const range = {value: 0}; range.value < (_var.security_group_id == "" ? 1 : 0 == true); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`defaultSecurityGroup-${range.value}`, {vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id}));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[];
 * for (const range = {value: 0}; range.value < (_var.vswitch_id == "" ? 1 : 0 == true); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: _var.availability_zone == "" ? defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId) : _var.availability_zone,
 *         vswitchName: _var.vswitch_name,
 *         cidrBlock: _var.vswitch_cidr,
 *         vpcId: _var.vpc_id == "" ? vpc.id : _var.vpc_id,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("defaultRole", {
 *     document: `    {
 *         "Statement": [
 *         {
 *             "Action": "sts:AssumeRole",
 *             "Effect": "Allow",
 *             "Principal": {
 *             "Service": [
 *                 "emr.aliyuncs.com",
 *                 "ecs.aliyuncs.com"
 *             ]
 *             }
 *         }
 *         ],
 *         "Version": "1"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const gateway = new alicloud.emr.Cluster("gateway", {
 *     emrVer: defaultMainVersions.then(defaultMainVersions => defaultMainVersions.mainVersions?[0]?.emrVersion),
 *     clusterType: "GATEWAY",
 *     hostGroups: [{
 *         hostGroupName: "master_group",
 *         hostGroupType: "GATEWAY",
 *         nodeCount: "1",
 *         instanceType: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.id),
 *         diskType: dataDisk.then(dataDisk => dataDisk.types?[0]?.value),
 *         diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?[0]?.min > 160 ? dataDisk1.types?[0]?.min : 160),
 *         diskCount: "1",
 *         sysDiskType: systemDisk.then(systemDisk => systemDisk.types?[0]?.value),
 *         sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?[0]?.min > 160 ? systemDisk1.types?[0]?.min : 160),
 *     }],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultInstanceTypes.then(defaultInstanceTypes => defaultInstanceTypes.types?[0]?.zoneId),
 *     securityGroupId: _var.security_group_id == "" ? defaultSecurityGroup.id : _var.security_group_id,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: _var.vswitch_id == "" ? vswitch.id : _var.vswitch_id,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 *     relatedClusterId: related_cluster_id,
 * });
 * ```
 *
 * ## Import
 *
 * Aliclioud E-MapReduce cluster can be imported using the id e.g.
 *
 * ```sh
 *  $ pulumi import alicloud:emr/cluster:Cluster default C-B47FB8FE96C67XXXX
 * ```
 */
export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'alicloud:emr/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    public readonly bootstrapActions!: pulumi.Output<outputs.emr.ClusterBootstrapAction[] | undefined>;
    /**
     * Charge Type for this group of hosts: PostPaid or PrePaid. If this is not specified, charge type will follow global chargeType value.
     */
    public readonly chargeType!: pulumi.Output<string | undefined>;
    /**
     * EMR Cluster Type, e.g. HADOOP, KAFKA, DRUID, GATEWAY etc. You can find all valid EMR cluster type in emr web console. Supported 'GATEWAY' available in 1.61.0+.
     */
    public readonly clusterType!: pulumi.Output<string>;
    /**
     * Cluster deposit type, HALF_MANAGED or FULL_MANAGED.
     */
    public readonly depositType!: pulumi.Output<string | undefined>;
    /**
     * High security cluster (true) or not. Default value is false.
     */
    public readonly easEnable!: pulumi.Output<boolean | undefined>;
    /**
     * EMR Version, e.g. EMR-3.22.0. You can find the all valid EMR Version in emr web console.
     */
    public readonly emrVer!: pulumi.Output<string>;
    /**
     * High Available for HDFS and YARN. If this is set true, MASTER group must have two nodes.
     */
    public readonly highAvailabilityEnable!: pulumi.Output<boolean | undefined>;
    /**
     * Groups of Host, You can specify MASTER as a group, CORE as a group (just like the above example).
     */
    public readonly hostGroups!: pulumi.Output<outputs.emr.ClusterHostGroup[] | undefined>;
    public readonly isOpenPublicIp!: pulumi.Output<boolean | undefined>;
    /**
     * Ssh key pair.
     */
    public readonly keyPairName!: pulumi.Output<string | undefined>;
    /**
     * Master ssh password.
     */
    public readonly masterPwd!: pulumi.Output<string | undefined>;
    /**
     * bootstrap action name.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Optional software list.
     */
    public readonly optionSoftwareLists!: pulumi.Output<string[] | undefined>;
    /**
     * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
     */
    public readonly period!: pulumi.Output<number | undefined>;
    /**
     * This specify the related cluster id, if this cluster is a Gateway.
     */
    public readonly relatedClusterId!: pulumi.Output<string | undefined>;
    /**
     * Security Group ID for Cluster, you can also specify this key for each host group.
     */
    public readonly securityGroupId!: pulumi.Output<string | undefined>;
    /**
     * If this is set true, we can ssh into cluster. Default value is false.
     */
    public readonly sshEnable!: pulumi.Output<boolean | undefined>;
    /**
     * A mapping of tags to assign to the resource.
     */
    public readonly tags!: pulumi.Output<{[key: string]: any} | undefined>;
    /**
     * Use local metadb. Default is false.
     */
    public readonly useLocalMetadb!: pulumi.Output<boolean | undefined>;
    /**
     * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
     */
    public readonly userDefinedEmrEcsRole!: pulumi.Output<string | undefined>;
    /**
     * Global vswitch id, you can also specify it in host group.
     */
    public readonly vswitchId!: pulumi.Output<string | undefined>;
    /**
     * Zone ID, e.g. cn-huhehaote-a
     */
    public readonly zoneId!: pulumi.Output<string>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["bootstrapActions"] = state ? state.bootstrapActions : undefined;
            resourceInputs["chargeType"] = state ? state.chargeType : undefined;
            resourceInputs["clusterType"] = state ? state.clusterType : undefined;
            resourceInputs["depositType"] = state ? state.depositType : undefined;
            resourceInputs["easEnable"] = state ? state.easEnable : undefined;
            resourceInputs["emrVer"] = state ? state.emrVer : undefined;
            resourceInputs["highAvailabilityEnable"] = state ? state.highAvailabilityEnable : undefined;
            resourceInputs["hostGroups"] = state ? state.hostGroups : undefined;
            resourceInputs["isOpenPublicIp"] = state ? state.isOpenPublicIp : undefined;
            resourceInputs["keyPairName"] = state ? state.keyPairName : undefined;
            resourceInputs["masterPwd"] = state ? state.masterPwd : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["optionSoftwareLists"] = state ? state.optionSoftwareLists : undefined;
            resourceInputs["period"] = state ? state.period : undefined;
            resourceInputs["relatedClusterId"] = state ? state.relatedClusterId : undefined;
            resourceInputs["securityGroupId"] = state ? state.securityGroupId : undefined;
            resourceInputs["sshEnable"] = state ? state.sshEnable : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["useLocalMetadb"] = state ? state.useLocalMetadb : undefined;
            resourceInputs["userDefinedEmrEcsRole"] = state ? state.userDefinedEmrEcsRole : undefined;
            resourceInputs["vswitchId"] = state ? state.vswitchId : undefined;
            resourceInputs["zoneId"] = state ? state.zoneId : undefined;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if ((!args || args.clusterType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'clusterType'");
            }
            if ((!args || args.emrVer === undefined) && !opts.urn) {
                throw new Error("Missing required property 'emrVer'");
            }
            if ((!args || args.zoneId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'zoneId'");
            }
            resourceInputs["bootstrapActions"] = args ? args.bootstrapActions : undefined;
            resourceInputs["chargeType"] = args ? args.chargeType : undefined;
            resourceInputs["clusterType"] = args ? args.clusterType : undefined;
            resourceInputs["depositType"] = args ? args.depositType : undefined;
            resourceInputs["easEnable"] = args ? args.easEnable : undefined;
            resourceInputs["emrVer"] = args ? args.emrVer : undefined;
            resourceInputs["highAvailabilityEnable"] = args ? args.highAvailabilityEnable : undefined;
            resourceInputs["hostGroups"] = args ? args.hostGroups : undefined;
            resourceInputs["isOpenPublicIp"] = args ? args.isOpenPublicIp : undefined;
            resourceInputs["keyPairName"] = args ? args.keyPairName : undefined;
            resourceInputs["masterPwd"] = args ? args.masterPwd : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["optionSoftwareLists"] = args ? args.optionSoftwareLists : undefined;
            resourceInputs["period"] = args ? args.period : undefined;
            resourceInputs["relatedClusterId"] = args ? args.relatedClusterId : undefined;
            resourceInputs["securityGroupId"] = args ? args.securityGroupId : undefined;
            resourceInputs["sshEnable"] = args ? args.sshEnable : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["useLocalMetadb"] = args ? args.useLocalMetadb : undefined;
            resourceInputs["userDefinedEmrEcsRole"] = args ? args.userDefinedEmrEcsRole : undefined;
            resourceInputs["vswitchId"] = args ? args.vswitchId : undefined;
            resourceInputs["zoneId"] = args ? args.zoneId : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    bootstrapActions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterBootstrapAction>[]>;
    /**
     * Charge Type for this group of hosts: PostPaid or PrePaid. If this is not specified, charge type will follow global chargeType value.
     */
    chargeType?: pulumi.Input<string>;
    /**
     * EMR Cluster Type, e.g. HADOOP, KAFKA, DRUID, GATEWAY etc. You can find all valid EMR cluster type in emr web console. Supported 'GATEWAY' available in 1.61.0+.
     */
    clusterType?: pulumi.Input<string>;
    /**
     * Cluster deposit type, HALF_MANAGED or FULL_MANAGED.
     */
    depositType?: pulumi.Input<string>;
    /**
     * High security cluster (true) or not. Default value is false.
     */
    easEnable?: pulumi.Input<boolean>;
    /**
     * EMR Version, e.g. EMR-3.22.0. You can find the all valid EMR Version in emr web console.
     */
    emrVer?: pulumi.Input<string>;
    /**
     * High Available for HDFS and YARN. If this is set true, MASTER group must have two nodes.
     */
    highAvailabilityEnable?: pulumi.Input<boolean>;
    /**
     * Groups of Host, You can specify MASTER as a group, CORE as a group (just like the above example).
     */
    hostGroups?: pulumi.Input<pulumi.Input<inputs.emr.ClusterHostGroup>[]>;
    isOpenPublicIp?: pulumi.Input<boolean>;
    /**
     * Ssh key pair.
     */
    keyPairName?: pulumi.Input<string>;
    /**
     * Master ssh password.
     */
    masterPwd?: pulumi.Input<string>;
    /**
     * bootstrap action name.
     */
    name?: pulumi.Input<string>;
    /**
     * Optional software list.
     */
    optionSoftwareLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
     */
    period?: pulumi.Input<number>;
    /**
     * This specify the related cluster id, if this cluster is a Gateway.
     */
    relatedClusterId?: pulumi.Input<string>;
    /**
     * Security Group ID for Cluster, you can also specify this key for each host group.
     */
    securityGroupId?: pulumi.Input<string>;
    /**
     * If this is set true, we can ssh into cluster. Default value is false.
     */
    sshEnable?: pulumi.Input<boolean>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: any}>;
    /**
     * Use local metadb. Default is false.
     */
    useLocalMetadb?: pulumi.Input<boolean>;
    /**
     * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
     */
    userDefinedEmrEcsRole?: pulumi.Input<string>;
    /**
     * Global vswitch id, you can also specify it in host group.
     */
    vswitchId?: pulumi.Input<string>;
    /**
     * Zone ID, e.g. cn-huhehaote-a
     */
    zoneId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    bootstrapActions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterBootstrapAction>[]>;
    /**
     * Charge Type for this group of hosts: PostPaid or PrePaid. If this is not specified, charge type will follow global chargeType value.
     */
    chargeType?: pulumi.Input<string>;
    /**
     * EMR Cluster Type, e.g. HADOOP, KAFKA, DRUID, GATEWAY etc. You can find all valid EMR cluster type in emr web console. Supported 'GATEWAY' available in 1.61.0+.
     */
    clusterType: pulumi.Input<string>;
    /**
     * Cluster deposit type, HALF_MANAGED or FULL_MANAGED.
     */
    depositType?: pulumi.Input<string>;
    /**
     * High security cluster (true) or not. Default value is false.
     */
    easEnable?: pulumi.Input<boolean>;
    /**
     * EMR Version, e.g. EMR-3.22.0. You can find the all valid EMR Version in emr web console.
     */
    emrVer: pulumi.Input<string>;
    /**
     * High Available for HDFS and YARN. If this is set true, MASTER group must have two nodes.
     */
    highAvailabilityEnable?: pulumi.Input<boolean>;
    /**
     * Groups of Host, You can specify MASTER as a group, CORE as a group (just like the above example).
     */
    hostGroups?: pulumi.Input<pulumi.Input<inputs.emr.ClusterHostGroup>[]>;
    isOpenPublicIp?: pulumi.Input<boolean>;
    /**
     * Ssh key pair.
     */
    keyPairName?: pulumi.Input<string>;
    /**
     * Master ssh password.
     */
    masterPwd?: pulumi.Input<string>;
    /**
     * bootstrap action name.
     */
    name?: pulumi.Input<string>;
    /**
     * Optional software list.
     */
    optionSoftwareLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
     */
    period?: pulumi.Input<number>;
    /**
     * This specify the related cluster id, if this cluster is a Gateway.
     */
    relatedClusterId?: pulumi.Input<string>;
    /**
     * Security Group ID for Cluster, you can also specify this key for each host group.
     */
    securityGroupId?: pulumi.Input<string>;
    /**
     * If this is set true, we can ssh into cluster. Default value is false.
     */
    sshEnable?: pulumi.Input<boolean>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: any}>;
    /**
     * Use local metadb. Default is false.
     */
    useLocalMetadb?: pulumi.Input<boolean>;
    /**
     * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
     */
    userDefinedEmrEcsRole?: pulumi.Input<string>;
    /**
     * Global vswitch id, you can also specify it in host group.
     */
    vswitchId?: pulumi.Input<string>;
    /**
     * Zone ID, e.g. cn-huhehaote-a
     */
    zoneId: pulumi.Input<string>;
}
