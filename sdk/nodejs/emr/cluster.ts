// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Provides a EMR Cluster resource. With this you can create, read, and release  EMR Cluster.
 *
 * > **DEPRECATED:**  This resource has been deprecated from version `1.204.0`. Please use new resource emrv2_cluster.
 *
 * > **NOTE:** Available since v1.57.0.
 *
 * ## Example Usage
 *
 * ### 1. Create A Cluster
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const _default = alicloud.emr.getMainVersions({});
 * const defaultGetInstanceTypes = _default.then(_default => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: [
 *         "MASTER",
 *         "CORE",
 *         "TASK",
 *     ],
 * }));
 * const dataDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[] = [];
 * for (const range = {value: 0}; range.value < (vpcId == "" ? 1 : 0); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {
 *         name: vpcName,
 *         cidrBlock: vpcCidr,
 *     }));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[] = [];
 * for (const range = {value: 0}; range.value < (securityGroupId == "" ? 1 : 0); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`default-${range.value}`, {
 *         name: securityGroupName,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[] = [];
 * for (const range = {value: 0}; range.value < (vswitchId == "" ? 1 : 0); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: availabilityZone == "" ? defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId) : availabilityZone,
 *         vswitchName: vswitchName,
 *         cidrBlock: vswitchCidr,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("default", {
 *     name: ramName,
 *     document: `    {
 *         \\"Statement\\": [
 *         {
 *             \\"Action\\": \\"sts:AssumeRole\\",
 *             \\"Effect\\": \\"Allow\\",
 *             \\"Principal\\": {
 *             \\"Service\\": [
 *                 \\"emr.aliyuncs.com\\",
 *                 \\"ecs.aliyuncs.com\\"
 *             ]
 *             }
 *         }
 *         ],
 *         \\"Version\\": \\"1\\"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const defaultCluster = new alicloud.emr.Cluster("default", {
 *     name: "terraform-create-cluster-test",
 *     emrVer: _default.then(_default => _default.mainVersions?.[0]?.emrVersion),
 *     clusterType: _default.then(_default => _default.mainVersions?.[0]?.clusterTypes?.[0]),
 *     hostGroups: [
 *         {
 *             hostGroupName: "master_group",
 *             hostGroupType: "MASTER",
 *             nodeCount: "2",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "1",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "core_group",
 *             hostGroupType: "CORE",
 *             nodeCount: "3",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "task_group",
 *             hostGroupType: "TASK",
 *             nodeCount: "2",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *     ],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId),
 *     securityGroupId: securityGroupId == "" ? defaultSecurityGroup[0].id : securityGroupId,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: vswitchId == "" ? vswitch[0].id : vswitchId,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 * });
 * ```
 *
 * ### 2. Scale Up
 * The hosts of EMR Cluster are orginized as host group. Scaling up/down is operating host group.
 *
 * In the case of scaling up cluster, we should add the nodeCount of some host group.
 *
 * > **NOTE:** Scaling up is only applicable to CORE and TASK group. Cost time of scaling up will vary with the number of scaling-up nodes.
 * Scaling down is only applicable to TASK group. If you want to scale down CORE group, please submit tickets or contact EMR support team.
 *
 * As the following case, we scale up the TASK group 2 nodes by increasing host_group.node_count by 2.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const _default = alicloud.emr.getMainVersions({});
 * const defaultGetInstanceTypes = _default.then(_default => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: [
 *         "MASTER",
 *         "CORE",
 *         "TASK",
 *     ],
 * }));
 * const dataDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[] = [];
 * for (const range = {value: 0}; range.value < (vpcId == "" ? 1 : 0); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {
 *         name: vpcName,
 *         cidrBlock: vpcCidr,
 *     }));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[] = [];
 * for (const range = {value: 0}; range.value < (securityGroupId == "" ? 1 : 0); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`default-${range.value}`, {
 *         name: securityGroupName,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[] = [];
 * for (const range = {value: 0}; range.value < (vswitchId == "" ? 1 : 0); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: availabilityZone == "" ? defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId) : availabilityZone,
 *         vswitchName: vswitchName,
 *         cidrBlock: vswitchCidr,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("default", {
 *     name: ramName,
 *     document: `    {
 *         \\"Statement\\": [
 *         {
 *             \\"Action\\": \\"sts:AssumeRole\\",
 *             \\"Effect\\": \\"Allow\\",
 *             \\"Principal\\": {
 *             \\"Service\\": [
 *                 \\"emr.aliyuncs.com\\",
 *                 \\"ecs.aliyuncs.com\\"
 *             ]
 *             }
 *         }
 *         ],
 *         \\"Version\\": \\"1\\"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const defaultCluster = new alicloud.emr.Cluster("default", {
 *     name: "terraform-resize-cluster-test",
 *     emrVer: _default.then(_default => _default.mainVersions?.[0]?.emrVersion),
 *     clusterType: _default.then(_default => _default.mainVersions?.[0]?.clusterTypes?.[0]),
 *     hostGroups: [
 *         {
 *             hostGroupName: "master_group",
 *             hostGroupType: "MASTER",
 *             nodeCount: "2",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "1",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "core_group",
 *             hostGroupType: "CORE",
 *             nodeCount: "3",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "task_group",
 *             hostGroupType: "TASK",
 *             nodeCount: "4",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *     ],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId),
 *     securityGroupId: securityGroupId == "" ? defaultSecurityGroup[0].id : securityGroupId,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: vswitchId == "" ? vswitch[0].id : vswitchId,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 * });
 * ```
 *
 * ### 3. Scale Down
 *
 * In the case of scaling down a cluster, we need to specified the host group and the instance list.
 *
 * > **NOTE:** Graceful decommission of hadoop cluster has been supported Available since v1.168.0.
 *
 * The following is an example. We scale down the cluster by decreasing the node count by 2, and specifying the scale-down instance list.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const _default = alicloud.emr.getMainVersions({});
 * const defaultGetInstanceTypes = _default.then(_default => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: [
 *         "MASTER",
 *         "CORE",
 *         "TASK",
 *     ],
 * }));
 * const dataDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[] = [];
 * for (const range = {value: 0}; range.value < (vpcId == "" ? 1 : 0); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {
 *         name: vpcName,
 *         cidrBlock: vpcCidr,
 *     }));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[] = [];
 * for (const range = {value: 0}; range.value < (securityGroupId == "" ? 1 : 0); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`default-${range.value}`, {
 *         name: securityGroupName,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[] = [];
 * for (const range = {value: 0}; range.value < (vswitchId == "" ? 1 : 0); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: availabilityZone == "" ? defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId) : availabilityZone,
 *         vswitchName: vswitchName,
 *         cidrBlock: vswitchCidr,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("default", {
 *     name: ramName,
 *     document: `    {
 *         \\"Statement\\": [
 *         {
 *             \\"Action\\": \\"sts:AssumeRole\\",
 *             \\"Effect\\": \\"Allow\\",
 *             \\"Principal\\": {
 *             \\"Service\\": [
 *                 \\"emr.aliyuncs.com\\",
 *                 \\"ecs.aliyuncs.com\\"
 *             ]
 *             }
 *         }
 *         ],
 *         \\"Version\\": \\"1\\"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const defaultCluster = new alicloud.emr.Cluster("default", {
 *     name: "terraform-resize-cluster-test",
 *     emrVer: _default.then(_default => _default.mainVersions?.[0]?.emrVersion),
 *     clusterType: _default.then(_default => _default.mainVersions?.[0]?.clusterTypes?.[0]),
 *     hostGroups: [
 *         {
 *             hostGroupName: "master_group",
 *             hostGroupType: "MASTER",
 *             nodeCount: "2",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "1",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "core_group",
 *             hostGroupType: "CORE",
 *             nodeCount: "3",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *         {
 *             hostGroupName: "task_group",
 *             hostGroupType: "TASK",
 *             nodeCount: "2",
 *             instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *             diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *             diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *             diskCount: "4",
 *             sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *             sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *         },
 *     ],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId),
 *     securityGroupId: securityGroupId == "" ? defaultSecurityGroup[0].id : securityGroupId,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: vswitchId == "" ? vswitch[0].id : vswitchId,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 * });
 * ```
 *
 * ### 4. Create a emr gateway cluster
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as alicloud from "@pulumi/alicloud";
 *
 * const _default = alicloud.emr.getMainVersions({});
 * const defaultGetInstanceTypes = _default.then(_default => alicloud.emr.getInstanceTypes({
 *     destinationResource: "InstanceType",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     supportLocalStorage: false,
 *     instanceChargeType: "PostPaid",
 *     supportNodeTypes: ["GATEWAY"],
 * }));
 * const dataDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "DataDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const systemDisk = Promise.all([_default, defaultGetInstanceTypes, defaultGetInstanceTypes]).then(([_default, defaultGetInstanceTypes, defaultGetInstanceTypes1]) => alicloud.emr.getDiskTypes({
 *     destinationResource: "SystemDisk",
 *     clusterType: _default.mainVersions?.[0]?.clusterTypes?.[0],
 *     instanceChargeType: "PostPaid",
 *     instanceType: defaultGetInstanceTypes.types?.[0]?.id,
 *     zoneId: defaultGetInstanceTypes1.types?.[0]?.zoneId,
 * }));
 * const vpc: alicloud.vpc.Network[] = [];
 * for (const range = {value: 0}; range.value < (vpcId == "" ? 1 : 0); range.value++) {
 *     vpc.push(new alicloud.vpc.Network(`vpc-${range.value}`, {
 *         name: vpcName,
 *         cidrBlock: vpcCidr,
 *     }));
 * }
 * const defaultSecurityGroup: alicloud.ecs.SecurityGroup[] = [];
 * for (const range = {value: 0}; range.value < (securityGroupId == "" ? 1 : 0); range.value++) {
 *     defaultSecurityGroup.push(new alicloud.ecs.SecurityGroup(`default-${range.value}`, {
 *         name: securityGroupName,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // VSwitch Resource for Module
 * const vswitch: alicloud.vpc.Switch[] = [];
 * for (const range = {value: 0}; range.value < (vswitchId == "" ? 1 : 0); range.value++) {
 *     vswitch.push(new alicloud.vpc.Switch(`vswitch-${range.value}`, {
 *         availabilityZone: availabilityZone == "" ? defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId) : availabilityZone,
 *         vswitchName: vswitchName,
 *         cidrBlock: vswitchCidr,
 *         vpcId: vpcId == "" ? vpc[0].id : vpcId,
 *     }));
 * }
 * // Ram role Resource for Module
 * const defaultRole = new alicloud.ram.Role("default", {
 *     name: ramName,
 *     document: `    {
 *         \\"Statement\\": [
 *         {
 *             \\"Action\\": \\"sts:AssumeRole\\",
 *             \\"Effect\\": \\"Allow\\",
 *             \\"Principal\\": {
 *             \\"Service\\": [
 *                 \\"emr.aliyuncs.com\\",
 *                 \\"ecs.aliyuncs.com\\"
 *             ]
 *             }
 *         }
 *         ],
 *         \\"Version\\": \\"1\\"
 *     }
 * `,
 *     description: "this is a role test.",
 *     force: true,
 * });
 * const gateway = new alicloud.emr.Cluster("gateway", {
 *     name: "terraform-gateway-cluster-test",
 *     emrVer: _default.then(_default => _default.mainVersions?.[0]?.emrVersion),
 *     clusterType: "GATEWAY",
 *     hostGroups: [{
 *         hostGroupName: "master_group",
 *         hostGroupType: "GATEWAY",
 *         nodeCount: "1",
 *         instanceType: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.id),
 *         diskType: dataDisk.then(dataDisk => dataDisk.types?.[0]?.value),
 *         diskCapacity: Promise.all([dataDisk, dataDisk]).then(([dataDisk, dataDisk1]) => dataDisk.types?.[0]?.min > 160 ? dataDisk1.types?.[0]?.min : 160),
 *         diskCount: "1",
 *         sysDiskType: systemDisk.then(systemDisk => systemDisk.types?.[0]?.value),
 *         sysDiskCapacity: Promise.all([systemDisk, systemDisk]).then(([systemDisk, systemDisk1]) => systemDisk.types?.[0]?.min > 160 ? systemDisk1.types?.[0]?.min : 160),
 *     }],
 *     highAvailabilityEnable: true,
 *     zoneId: defaultGetInstanceTypes.then(defaultGetInstanceTypes => defaultGetInstanceTypes.types?.[0]?.zoneId),
 *     securityGroupId: securityGroupId == "" ? defaultSecurityGroup[0].id : securityGroupId,
 *     isOpenPublicIp: true,
 *     chargeType: "PostPaid",
 *     vswitchId: vswitchId == "" ? vswitch[0].id : vswitchId,
 *     userDefinedEmrEcsRole: defaultRole.name,
 *     sshEnable: true,
 *     masterPwd: "ABCtest1234!",
 *     relatedClusterId: relatedClusterId,
 * });
 * ```
 *
 * ## Import
 *
 * Aliclioud E-MapReduce cluster can be imported using the id e.g.
 *
 * ```sh
 * $ pulumi import alicloud:emr/cluster:Cluster default C-B47FB8FE96C67XXXX
 * ```
 */
export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'alicloud:emr/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    /**
     * Boot action parameters.
     */
    declare public readonly bootstrapActions: pulumi.Output<outputs.emr.ClusterBootstrapAction[] | undefined>;
    /**
     * Charge Type for this cluster. Supported value: PostPaid or PrePaid. Default value: PostPaid.
     */
    declare public readonly chargeType: pulumi.Output<string | undefined>;
    /**
     * EMR Cluster Type, e.g. HADOOP, KAFKA, DRUID, GATEWAY etc. You can find all valid EMR cluster type in emr web console. Supported 'GATEWAY' available in 1.61.0+.
     */
    declare public readonly clusterType: pulumi.Output<string>;
    /**
     * The custom configurations of emr-cluster service.
     */
    declare public readonly configs: pulumi.Output<outputs.emr.ClusterConfig[] | undefined>;
    /**
     * Cluster deposit type, HALF_MANAGED or FULL_MANAGED.
     */
    declare public readonly depositType: pulumi.Output<string | undefined>;
    /**
     * High security cluster (true) or not. Default value is false.
     */
    declare public readonly easEnable: pulumi.Output<boolean | undefined>;
    /**
     * EMR Version, e.g. EMR-3.22.0. You can find the all valid EMR Version in emr web console.
     */
    declare public readonly emrVer: pulumi.Output<string>;
    /**
     * High Available for HDFS and YARN. If this is set true, MASTER group must have two nodes.
     */
    declare public readonly highAvailabilityEnable: pulumi.Output<boolean | undefined>;
    /**
     * Groups of Host, You can specify MASTER as a group, CORE as a group (just like the above example).
     */
    declare public readonly hostGroups: pulumi.Output<outputs.emr.ClusterHostGroup[] | undefined>;
    /**
     * Whether the MASTER node has a public IP address enabled. Default value is false.
     */
    declare public readonly isOpenPublicIp: pulumi.Output<boolean | undefined>;
    /**
     * Ssh key pair.
     */
    declare public readonly keyPairName: pulumi.Output<string | undefined>;
    /**
     * Master ssh password.
     */
    declare public readonly masterPwd: pulumi.Output<string | undefined>;
    /**
     * The configuration of emr-cluster service component metadata storage. If meta store type is ’user_rds’, this should be specified.
     */
    declare public readonly metaStoreConf: pulumi.Output<outputs.emr.ClusterMetaStoreConf | undefined>;
    /**
     * The type of emr-cluster service component metadata storage. ’dlf’ or ’local’ or ’user_rds’ .
     */
    declare public readonly metaStoreType: pulumi.Output<string>;
    /**
     * The configurations of emr-cluster service modification after cluster created.
     */
    declare public readonly modifyClusterServiceConfig: pulumi.Output<outputs.emr.ClusterModifyClusterServiceConfig | undefined>;
    /**
     * The name of emr cluster. The name length must be less than 64. Supported characters: chinese character, english character, number, "-", "_".
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Optional software list.
     */
    declare public readonly optionSoftwareLists: pulumi.Output<string[] | undefined>;
    /**
     * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
     */
    declare public readonly period: pulumi.Output<number | undefined>;
    /**
     * This specify the related cluster id, if this cluster is a Gateway.
     */
    declare public readonly relatedClusterId: pulumi.Output<string | undefined>;
    /**
     * The Id of resource group which the emr-cluster belongs.
     */
    declare public readonly resourceGroupId: pulumi.Output<string | undefined>;
    /**
     * Security Group ID for Cluster, you can also specify this key for each host group.
     */
    declare public readonly securityGroupId: pulumi.Output<string | undefined>;
    /**
     * If this is set true, we can ssh into cluster. Default value is false.
     */
    declare public readonly sshEnable: pulumi.Output<boolean | undefined>;
    /**
     * A mapping of tags to assign to the resource.
     */
    declare public readonly tags: pulumi.Output<{[key: string]: string}>;
    /**
     * Use local metadb. Default is false.
     */
    declare public readonly useLocalMetadb: pulumi.Output<boolean | undefined>;
    /**
     * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
     */
    declare public readonly userDefinedEmrEcsRole: pulumi.Output<string | undefined>;
    /**
     * Global vswitch id, you can also specify it in host group.
     */
    declare public readonly vswitchId: pulumi.Output<string | undefined>;
    /**
     * Zone ID, e.g. cn-huhehaote-a
     */
    declare public readonly zoneId: pulumi.Output<string>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["bootstrapActions"] = state?.bootstrapActions;
            resourceInputs["chargeType"] = state?.chargeType;
            resourceInputs["clusterType"] = state?.clusterType;
            resourceInputs["configs"] = state?.configs;
            resourceInputs["depositType"] = state?.depositType;
            resourceInputs["easEnable"] = state?.easEnable;
            resourceInputs["emrVer"] = state?.emrVer;
            resourceInputs["highAvailabilityEnable"] = state?.highAvailabilityEnable;
            resourceInputs["hostGroups"] = state?.hostGroups;
            resourceInputs["isOpenPublicIp"] = state?.isOpenPublicIp;
            resourceInputs["keyPairName"] = state?.keyPairName;
            resourceInputs["masterPwd"] = state?.masterPwd;
            resourceInputs["metaStoreConf"] = state?.metaStoreConf;
            resourceInputs["metaStoreType"] = state?.metaStoreType;
            resourceInputs["modifyClusterServiceConfig"] = state?.modifyClusterServiceConfig;
            resourceInputs["name"] = state?.name;
            resourceInputs["optionSoftwareLists"] = state?.optionSoftwareLists;
            resourceInputs["period"] = state?.period;
            resourceInputs["relatedClusterId"] = state?.relatedClusterId;
            resourceInputs["resourceGroupId"] = state?.resourceGroupId;
            resourceInputs["securityGroupId"] = state?.securityGroupId;
            resourceInputs["sshEnable"] = state?.sshEnable;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["useLocalMetadb"] = state?.useLocalMetadb;
            resourceInputs["userDefinedEmrEcsRole"] = state?.userDefinedEmrEcsRole;
            resourceInputs["vswitchId"] = state?.vswitchId;
            resourceInputs["zoneId"] = state?.zoneId;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if (args?.clusterType === undefined && !opts.urn) {
                throw new Error("Missing required property 'clusterType'");
            }
            if (args?.emrVer === undefined && !opts.urn) {
                throw new Error("Missing required property 'emrVer'");
            }
            if (args?.zoneId === undefined && !opts.urn) {
                throw new Error("Missing required property 'zoneId'");
            }
            resourceInputs["bootstrapActions"] = args?.bootstrapActions;
            resourceInputs["chargeType"] = args?.chargeType;
            resourceInputs["clusterType"] = args?.clusterType;
            resourceInputs["configs"] = args?.configs;
            resourceInputs["depositType"] = args?.depositType;
            resourceInputs["easEnable"] = args?.easEnable;
            resourceInputs["emrVer"] = args?.emrVer;
            resourceInputs["highAvailabilityEnable"] = args?.highAvailabilityEnable;
            resourceInputs["hostGroups"] = args?.hostGroups;
            resourceInputs["isOpenPublicIp"] = args?.isOpenPublicIp;
            resourceInputs["keyPairName"] = args?.keyPairName;
            resourceInputs["masterPwd"] = args?.masterPwd;
            resourceInputs["metaStoreConf"] = args?.metaStoreConf;
            resourceInputs["metaStoreType"] = args?.metaStoreType;
            resourceInputs["modifyClusterServiceConfig"] = args?.modifyClusterServiceConfig;
            resourceInputs["name"] = args?.name;
            resourceInputs["optionSoftwareLists"] = args?.optionSoftwareLists;
            resourceInputs["period"] = args?.period;
            resourceInputs["relatedClusterId"] = args?.relatedClusterId;
            resourceInputs["resourceGroupId"] = args?.resourceGroupId;
            resourceInputs["securityGroupId"] = args?.securityGroupId;
            resourceInputs["sshEnable"] = args?.sshEnable;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["useLocalMetadb"] = args?.useLocalMetadb;
            resourceInputs["userDefinedEmrEcsRole"] = args?.userDefinedEmrEcsRole;
            resourceInputs["vswitchId"] = args?.vswitchId;
            resourceInputs["zoneId"] = args?.zoneId;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    /**
     * Boot action parameters.
     */
    bootstrapActions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterBootstrapAction>[]>;
    /**
     * Charge Type for this cluster. Supported value: PostPaid or PrePaid. Default value: PostPaid.
     */
    chargeType?: pulumi.Input<string>;
    /**
     * EMR Cluster Type, e.g. HADOOP, KAFKA, DRUID, GATEWAY etc. You can find all valid EMR cluster type in emr web console. Supported 'GATEWAY' available in 1.61.0+.
     */
    clusterType?: pulumi.Input<string>;
    /**
     * The custom configurations of emr-cluster service.
     */
    configs?: pulumi.Input<pulumi.Input<inputs.emr.ClusterConfig>[]>;
    /**
     * Cluster deposit type, HALF_MANAGED or FULL_MANAGED.
     */
    depositType?: pulumi.Input<string>;
    /**
     * High security cluster (true) or not. Default value is false.
     */
    easEnable?: pulumi.Input<boolean>;
    /**
     * EMR Version, e.g. EMR-3.22.0. You can find the all valid EMR Version in emr web console.
     */
    emrVer?: pulumi.Input<string>;
    /**
     * High Available for HDFS and YARN. If this is set true, MASTER group must have two nodes.
     */
    highAvailabilityEnable?: pulumi.Input<boolean>;
    /**
     * Groups of Host, You can specify MASTER as a group, CORE as a group (just like the above example).
     */
    hostGroups?: pulumi.Input<pulumi.Input<inputs.emr.ClusterHostGroup>[]>;
    /**
     * Whether the MASTER node has a public IP address enabled. Default value is false.
     */
    isOpenPublicIp?: pulumi.Input<boolean>;
    /**
     * Ssh key pair.
     */
    keyPairName?: pulumi.Input<string>;
    /**
     * Master ssh password.
     */
    masterPwd?: pulumi.Input<string>;
    /**
     * The configuration of emr-cluster service component metadata storage. If meta store type is ’user_rds’, this should be specified.
     */
    metaStoreConf?: pulumi.Input<inputs.emr.ClusterMetaStoreConf>;
    /**
     * The type of emr-cluster service component metadata storage. ’dlf’ or ’local’ or ’user_rds’ .
     */
    metaStoreType?: pulumi.Input<string>;
    /**
     * The configurations of emr-cluster service modification after cluster created.
     */
    modifyClusterServiceConfig?: pulumi.Input<inputs.emr.ClusterModifyClusterServiceConfig>;
    /**
     * The name of emr cluster. The name length must be less than 64. Supported characters: chinese character, english character, number, "-", "_".
     */
    name?: pulumi.Input<string>;
    /**
     * Optional software list.
     */
    optionSoftwareLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
     */
    period?: pulumi.Input<number>;
    /**
     * This specify the related cluster id, if this cluster is a Gateway.
     */
    relatedClusterId?: pulumi.Input<string>;
    /**
     * The Id of resource group which the emr-cluster belongs.
     */
    resourceGroupId?: pulumi.Input<string>;
    /**
     * Security Group ID for Cluster, you can also specify this key for each host group.
     */
    securityGroupId?: pulumi.Input<string>;
    /**
     * If this is set true, we can ssh into cluster. Default value is false.
     */
    sshEnable?: pulumi.Input<boolean>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Use local metadb. Default is false.
     */
    useLocalMetadb?: pulumi.Input<boolean>;
    /**
     * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
     */
    userDefinedEmrEcsRole?: pulumi.Input<string>;
    /**
     * Global vswitch id, you can also specify it in host group.
     */
    vswitchId?: pulumi.Input<string>;
    /**
     * Zone ID, e.g. cn-huhehaote-a
     */
    zoneId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    /**
     * Boot action parameters.
     */
    bootstrapActions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterBootstrapAction>[]>;
    /**
     * Charge Type for this cluster. Supported value: PostPaid or PrePaid. Default value: PostPaid.
     */
    chargeType?: pulumi.Input<string>;
    /**
     * EMR Cluster Type, e.g. HADOOP, KAFKA, DRUID, GATEWAY etc. You can find all valid EMR cluster type in emr web console. Supported 'GATEWAY' available in 1.61.0+.
     */
    clusterType: pulumi.Input<string>;
    /**
     * The custom configurations of emr-cluster service.
     */
    configs?: pulumi.Input<pulumi.Input<inputs.emr.ClusterConfig>[]>;
    /**
     * Cluster deposit type, HALF_MANAGED or FULL_MANAGED.
     */
    depositType?: pulumi.Input<string>;
    /**
     * High security cluster (true) or not. Default value is false.
     */
    easEnable?: pulumi.Input<boolean>;
    /**
     * EMR Version, e.g. EMR-3.22.0. You can find the all valid EMR Version in emr web console.
     */
    emrVer: pulumi.Input<string>;
    /**
     * High Available for HDFS and YARN. If this is set true, MASTER group must have two nodes.
     */
    highAvailabilityEnable?: pulumi.Input<boolean>;
    /**
     * Groups of Host, You can specify MASTER as a group, CORE as a group (just like the above example).
     */
    hostGroups?: pulumi.Input<pulumi.Input<inputs.emr.ClusterHostGroup>[]>;
    /**
     * Whether the MASTER node has a public IP address enabled. Default value is false.
     */
    isOpenPublicIp?: pulumi.Input<boolean>;
    /**
     * Ssh key pair.
     */
    keyPairName?: pulumi.Input<string>;
    /**
     * Master ssh password.
     */
    masterPwd?: pulumi.Input<string>;
    /**
     * The configuration of emr-cluster service component metadata storage. If meta store type is ’user_rds’, this should be specified.
     */
    metaStoreConf?: pulumi.Input<inputs.emr.ClusterMetaStoreConf>;
    /**
     * The type of emr-cluster service component metadata storage. ’dlf’ or ’local’ or ’user_rds’ .
     */
    metaStoreType?: pulumi.Input<string>;
    /**
     * The configurations of emr-cluster service modification after cluster created.
     */
    modifyClusterServiceConfig?: pulumi.Input<inputs.emr.ClusterModifyClusterServiceConfig>;
    /**
     * The name of emr cluster. The name length must be less than 64. Supported characters: chinese character, english character, number, "-", "_".
     */
    name?: pulumi.Input<string>;
    /**
     * Optional software list.
     */
    optionSoftwareLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
     */
    period?: pulumi.Input<number>;
    /**
     * This specify the related cluster id, if this cluster is a Gateway.
     */
    relatedClusterId?: pulumi.Input<string>;
    /**
     * The Id of resource group which the emr-cluster belongs.
     */
    resourceGroupId?: pulumi.Input<string>;
    /**
     * Security Group ID for Cluster, you can also specify this key for each host group.
     */
    securityGroupId?: pulumi.Input<string>;
    /**
     * If this is set true, we can ssh into cluster. Default value is false.
     */
    sshEnable?: pulumi.Input<boolean>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Use local metadb. Default is false.
     */
    useLocalMetadb?: pulumi.Input<boolean>;
    /**
     * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
     */
    userDefinedEmrEcsRole?: pulumi.Input<string>;
    /**
     * Global vswitch id, you can also specify it in host group.
     */
    vswitchId?: pulumi.Input<string>;
    /**
     * Zone ID, e.g. cn-huhehaote-a
     */
    zoneId: pulumi.Input<string>;
}
