"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc = require("grpc");
const log = require("../log");
const debuggable_1 = require("./debuggable");
const rpc_1 = require("./rpc");
const settings_1 = require("./settings");
const gstruct = require("google-protobuf/google/protobuf/struct_pb.js");
const resproto = require("../proto/resource_pb.js");
/**
 * invoke dynamically invokes the function, tok, which is offered by a provider plugin.  The inputs
 * can be a bag of computed values (Ts or Promise<T>s), and the result is a Promise<any> that
 * resolves when the invoke finishes.
 */
function invoke(tok, props, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        log.debug(`Invoking function: tok=${tok}` +
            settings_1.excessiveDebugOutput ? `, props=${JSON.stringify(props)}` : ``);
        opts = opts || {};
        if (!opts.parent) {
            opts.parent = settings_1.getRootResource();
        }
        if (opts.parent && opts.provider === undefined) {
            opts.provider = opts.parent.getProvider(tok);
        }
        // Wait for all values to be available, and then perform the RPC.
        const done = settings_1.rpcKeepAlive();
        try {
            const obj = gstruct.Struct.fromJavaScript(yield rpc_1.serializeProperties(`invoke:${tok}`, props));
            log.debug(`Invoke RPC prepared: tok=${tok}` + settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(obj)}` : ``);
            // Fetch the monitor and make an RPC request.
            const monitor = settings_1.getMonitor();
            let providerRef;
            if (opts.provider !== undefined) {
                const providerURN = yield opts.provider.urn.promise();
                const providerID = (yield opts.provider.id.promise()) || rpc_1.unknownValue;
                providerRef = `${providerURN}::${providerID}`;
            }
            const req = new resproto.InvokeRequest();
            req.setTok(tok);
            req.setArgs(obj);
            req.setProvider(providerRef);
            const resp = yield debuggable_1.debuggablePromise(new Promise((innerResolve, innerReject) => monitor.invoke(req, (err, innerResponse) => {
                log.debug(`Invoke RPC finished: tok=${tok}; err: ${err}, resp: ${innerResponse}`);
                if (err) {
                    // If the monitor is unavailable, it is in the process of shutting down or has already
                    // shut down. Don't emit an error and don't do any more RPCs.
                    if (err.code === grpc.status.UNAVAILABLE) {
                        log.debug("Resource monitor is terminating");
                        waitForDeath();
                    }
                    // If the RPC failed, rethrow the error with a native exception and the message that
                    // the engine provided - it's suitable for user presentation.
                    innerReject(new Error(err.details));
                }
                else {
                    innerResolve(innerResponse);
                }
            })));
            // If there were failures, propagate them.
            const failures = resp.getFailuresList();
            if (failures && failures.length) {
                throw new Error(`Invoke of '${tok}' failed: ${failures[0].reason} (${failures[0].property})`);
            }
            // Finally propagate any other properties that were given to us as outputs.
            return rpc_1.deserializeProperties(resp.getReturn());
        }
        finally {
            done();
        }
    });
}
exports.invoke = invoke;
/**
 * waitForDeath loops forever. See the comments in resource.ts on the function with
 * the same name for an explanation as to why this exists.
 */
function waitForDeath() {
    // tslint:disable-next-line
    while (true) { }
}
