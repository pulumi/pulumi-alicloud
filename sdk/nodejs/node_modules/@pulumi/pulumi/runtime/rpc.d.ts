import { Input, Inputs, Resource } from "../resource";
export declare type OutputResolvers = Record<string, (value: any, isStable: boolean) => void>;
/**
 * transferProperties mutates the 'onto' resource so that it has Promise-valued properties for all
 * the 'props' input/output props.  *Importantly* all these promises are completely unresolved. This
 * is because we don't want anyone to observe the values of these properties until the rpc call to
 * registerResource actually returns.  This is because the registerResource call may actually
 * override input values, and we only want people to see the final value.
 *
 * The result of this call (beyond the stateful changes to 'onto') is the set of Promise resolvers
 * that will be called post-RPC call.  When the registerResource RPC call comes back, the values
 * that the engine actualy produced will be used to resolve all the unresolved promised placed on
 * 'onto'.
 */
export declare function transferProperties(onto: Resource, label: string, props: Inputs): OutputResolvers;
/**
 * serializeResourceProperties walks the props object passed in, awaiting all interior promises besides those for `id`
 * and `urn`, creating a reasonable POJO object that can be remoted over to registerResource.
 */
export declare function serializeResourceProperties(label: string, props: Inputs, dependentResources?: Resource[]): Promise<Record<string, any>>;
/**
 * serializeProperties walks the props object passed in, awaiting all interior promises, creating a reasonable
 * POJO object that can be remoted over to registerResource.
 */
export declare function serializeProperties(label: string, props: Inputs, dependentResources?: Resource[]): Promise<Record<string, any>>;
/**
 * deserializeProperties fetches the raw outputs and deserializes them from a gRPC call result.
 */
export declare function deserializeProperties(outputsStruct: any): any;
/**
 * resolveProperties takes as input a gRPC serialized proto.google.protobuf.Struct and resolves all
 * of the resource's matching properties to the values inside.
 *
 * NOTE: it is imperative that the properties in `allProps` were produced by `deserializeProperties` in order for
 * output properties to work correctly w.r.t. knowns/unknowns: this function assumes that any undefined value in
 * `allProps`represents an unknown value that was returned by an engine operation.
 */
export declare function resolveProperties(res: Resource, resolvers: Record<string, (v: any, isKnown: boolean) => void>, t: string, name: string, allProps: any): void;
/**
 * Unknown values are encoded as a distinguished string value.
 */
export declare const unknownValue = "04da6b54-80e4-46f7-96ec-b56ff0331ba9";
/**
 * specialSigKey is sometimes used to encode type identity inside of a map.  See pkg/resource/properties.go.
 */
export declare const specialSigKey = "4dabf18193072939515e22adb298388d";
/**
 * specialAssetSig is a randomly assigned hash used to identify assets in maps.  See pkg/resource/asset.go.
 */
export declare const specialAssetSig = "c44067f5952c0a294b673a41bacd8c17";
/**
 * specialArchiveSig is a randomly assigned hash used to identify archives in maps.  See pkg/resource/asset.go.
 */
export declare const specialArchiveSig = "0def7320c3a5731c473e5ecbe6d01bc7";
/**
 * serializeProperty serializes properties deeply.  This understands how to wait on any unresolved promises, as
 * appropriate, in addition to translating certain "special" values so that they are ready to go on the wire.
 */
export declare function serializeProperty(ctx: string, prop: Input<any>, dependentResources: Resource[]): Promise<any>;
/**
 * deserializeProperty unpacks some special types, reversing the above process.
 */
export declare function deserializeProperty(prop: any): any;
