// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface GetMscSubContactsContact {
    /**
     * UID.
     */
    accountUid: string;
    /**
     * The first ID of the resource.
     */
    contactId: string;
    /**
     * The User's Contact Name. **Note:** The name must be 2 to 12 characters in length, and can contain uppercase and lowercase letters.
     */
    contactName: string;
    /**
     * The User's Contact Email Address.
     */
    email: string;
    /**
     * The ID of the Contact.
     */
    id: string;
    /**
     * Indicates Whether the BGP Group Is the Account Itself.
     */
    isAccount: boolean;
    /**
     * Whether They Have Expired Or Not.
     */
    isObsolete: boolean;
    /**
     * Email Validation for.
     */
    isVerifiedEmail: boolean;
    /**
     * If the Phone Verification.
     */
    isVerifiedMobile: boolean;
    /**
     * Last Verification Email Transmission Time.
     */
    lastEmailVerificationTimeStamp: string;
    /**
     * The Pieces of Authentication SMS Sending Time.
     */
    lastMobileVerificationTimeStamp: string;
    /**
     * The User's Telephone.
     */
    mobile: string;
    /**
     * The User's Position. Valid values: `CEO`, `Technical Director`, `Maintenance Director`, `Project Director`,`Finance Director` and `Other`.
     */
    position: string;
}

export interface GetMscSubSubscriptionsSubscription {
    /**
     * The channel the Subscription.
     */
    channel: string;
    /**
     * The ids of subscribed contacts.
     */
    contactIds: number[];
    /**
     * The description of the Subscription.
     */
    description: string;
    /**
     * The status of email subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    emailStatus: number;
    /**
     * The ID of the Subscription.
     */
    id: string;
    /**
     * The ID of the Subscription.
     */
    itemId: string;
    /**
     * The name of the Subscription.
     */
    itemName: string;
    /**
     * The status of pmsg subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    pmsgStatus: number;
    /**
     * The status of sms subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    smsStatus: number;
    /**
     * The status of tts subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    ttsStatus: number;
    /**
     * The ids of subscribed webhooks.
     */
    webhookIds: number[];
    /**
     * The status of webhook subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    webhookStatus: number;
}

export interface GetMscSubWebhooksWebhook {
    /**
     * The ID of the Webhook.
     */
    id: string;
    /**
     * The serverUrl of the Subscription.
     */
    serverUrl: string;
    /**
     * The first ID of the resource.
     */
    webhookId: string;
    /**
     * The name of the Webhook. **Note:** The name must be `2` to `12` characters in length, and can contain uppercase and lowercase letters.
     */
    webhookName: string;
}

export interface GetRegionsRegion {
    /**
     * ID of the region.
     */
    id: string;
    /**
     * Name of the region in the local language.
     */
    localName: string;
    regionId: string;
}

export interface GetZonesZone {
    /**
     * Set of supported disk categories.
     */
    availableDiskCategories: string[];
    /**
     * Allowed instance types.
     */
    availableInstanceTypes: string[];
    /**
     * Filter the results by a specific resource type.
     * Valid values: `Instance`, `Disk`, `VSwitch`, `Rds`, `KVStore`, `FunctionCompute`, `Elasticsearch`, `Slb`.
     */
    availableResourceCreations: string[];
    /**
     * ID of the zone.
     */
    id: string;
    /**
     * Name of the zone in the local language.
     */
    localName: string;
    /**
     * A list of zone ids in which the multi zone.
     */
    multiZoneIds: string[];
    /**
     * A list of slb slave zone ids in which the slb master zone.
     */
    slbSlaveZoneIds: string[];
}

export namespace actiontrail {
    export interface GetHistoryDeliveryJobsJob {
        /**
         * The time when the task was created.
         */
        createTime: string;
        /**
         * The time when the task ended.
         */
        endTime: string;
        historyDeliveryJobId: string;
        /**
         * The home region of the trail.
         */
        homeRegion: string;
        /**
         * The ID of the History Delivery Job.
         */
        id: string;
        /**
         * Detail status of delivery job.
         */
        jobStatuses: outputs.actiontrail.GetHistoryDeliveryJobsJobJobStatus[];
        /**
         * The time when the task started.
         */
        startTime: string;
        /**
         * The status of the task. Valid values: `0`, `1`, `2`, `3`. `0`: The task is initializing. `1`: The task is delivering historical events. `2`: The delivery of historical events is complete. `3`: The task fails.
         */
        status: number;
        /**
         * The name of the trail.
         */
        trailName: string;
        /**
         * The time when the task was updated.
         */
        updatedTime: string;
    }

    export interface GetHistoryDeliveryJobsJobJobStatus {
        /**
         * The region of the delivery job.
         */
        region: string;
        /**
         * The status of the task. Valid values: `0`, `1`, `2`, `3`. `0`: The task is initializing. `1`: The task is delivering historical events. `2`: The delivery of historical events is complete. `3`: The task fails.
         */
        status: number;
    }

    export interface GetInstancesInstance {
        /**
         * The config the instance.
         */
        config: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The deploy type of the instance. 0: sharing instance, 1: vpc instance, 2: vpc instance(support ip mapping), 3: eip instance, 4: eip/vpc instance, 5: vpc instance.
         */
        deployType: number;
        /**
         * The disk size of the instance.
         */
        diskSize: number;
        /**
         * The disk type of the instance. 0: efficient cloud disk , 1: SSD.
         */
        diskType: number;
        /**
         * The peak bandwidth of the instance.
         */
        eipMax: number;
        /**
         * The endPoint to access the instance.
         */
        endPoint: string;
        /**
         * The expired time  of the instance.
         */
        expiredTime: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The peak value of io of the instance.
         */
        ioMax: number;
        /**
         * The msg retain of the instance.
         */
        msgRetain: number;
        /**
         * Name of the instance.
         */
        name: string;
        /**
         * The paid type of the instance.
         */
        paidType: string;
        /**
         * The security group of the instance.
         */
        securityGroup: string;
        /**
         * The current status of the instance. -1: unknown status, 0: wait deploy, 1: initializing, 2: preparing, 3 starting, 5: in service, 7: wait upgrade, 8: upgrading, 10: released, 15: freeze, 101: deploy error, 102: upgrade error.
         */
        serviceStatus: number;
        /**
         * The kafka openSource version of the instance.
         */
        serviceVersion: string;
        /**
         * The spec type of the instance.
         */
        specType: string;
        /**
         * The SSL end point of the instance.
         */
        sslEndPoint: string;
        /**
         * The max num of topic can be create of the instance.
         */
        topicQuota: number;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The ID of attaching vswitch to instance.
         */
        vswitchId: string;
        /**
         * The ID of attaching zone to instance.
         */
        zoneId: string;
    }

    export interface GetSaslAclsAcl {
        /**
         * The operation type of the sasl acl.
         */
        aclOperationType: string;
        /**
         * Get results for the specified resource name.
         */
        aclResourceName: string;
        /**
         * The resource pattern type of the sasl acl.
         */
        aclResourcePatternType: string;
        /**
         * Get results for the specified resource type.
         */
        aclResourceType: string;
        /**
         * The host of the sasl acl.
         */
        host: string;
        /**
         * Get results for the specified username.
         */
        username: string;
    }

    export interface GetSaslUsersUser {
        /**
         * The password of the user.
         */
        password: string;
        /**
         * The username of the user.
         */
        username: string;
    }

    export interface GetTopicsTopic {
        /**
         * whether the current topic is kafka compact topic or not.
         */
        compactTopic: boolean;
        /**
         * Time of creation.
         */
        createTime: string;
        /**
         * whether the current topic is kafka local topic or not.
         */
        localTopic: boolean;
        /**
         * Partition number of the topic.
         */
        partitionNum: number;
        /**
         * Remark of the topic.
         */
        remark: string;
        /**
         * The current status code of the topic. There are three values to describe the topic status: 0 stands for the topic is in service, 1 stands for freezing and 2 stands for pause.
         */
        status: number;
        /**
         * The name of the topic.
         */
        topic: string;
    }

    export interface GetTrailsActiontrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        /**
         * The id of the ActionTrail Trail. It is the same as trail name.
         */
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        /**
         * Filter the results by status of the ActionTrail Trail. Valid values: `Disable`, `Enable`, `Fresh`.
         */
        status: string;
        /**
         * The name of the ActionTrail Trail.
         */
        trailName: string;
        /**
         * The regions to which the trail is applied.
         */
        trailRegion: string;
    }

    export interface GetTrailsDeprecatedActiontrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        status: string;
        trailName: string;
        trailRegion: string;
    }

    export interface GetTrailsDeprecatedTrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        status: string;
        trailName: string;
        trailRegion: string;
    }

    export interface GetTrailsTrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        /**
         * The id of the ActionTrail Trail. It is the same as trail name.
         */
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        /**
         * Filter the results by status of the ActionTrail Trail. Valid values: `Disable`, `Enable`, `Fresh`.
         */
        status: string;
        /**
         * The name of the ActionTrail Trail.
         */
        trailName: string;
        /**
         * The regions to which the trail is applied.
         */
        trailRegion: string;
    }

}

export namespace adb {
    export interface GetClustersCluster {
        autoRenewPeriod: number;
        /**
         * Billing method. Value options: `PostPaid` for Pay-As-You-Go and `PrePaid` for subscription.
         */
        chargeType: string;
        commodityCode: string;
        computeResource: string;
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        dbClusterCategory: string;
        dbClusterId: string;
        dbClusterNetworkType: string;
        dbClusterType: string;
        dbClusterVersion: string;
        /**
         * The DBNodeClass of the ADB cluster.
         */
        dbNodeClass: string;
        /**
         * The DBNodeCount of the ADB cluster.
         */
        dbNodeCount: number;
        /**
         * The DBNodeStorage of the ADB cluster.
         */
        dbNodeStorage: number;
        /**
         * The description of the ADB cluster.
         */
        description: string;
        diskType: string;
        dtsJobId: string;
        elasticIoResource: number;
        engine: string;
        engineVersion: string;
        executorCount: string;
        /**
         * Expiration time. Pay-As-You-Go clusters never expire.
         */
        expireTime: string;
        /**
         * The expired of the ADB cluster.
         */
        expired: string;
        /**
         * The ID of the ADB cluster.
         */
        id: string;
        /**
         * The LockMode of the ADB cluster.
         */
        lockMode: string;
        lockReason: string;
        maintainTime: string;
        mode: string;
        /**
         * The DBClusterNetworkType of the ADB cluster.
         */
        networkType: string;
        paymentType: string;
        port: number;
        rdsInstanceId: string;
        /**
         * Region ID the cluster belongs to.
         */
        regionId: string;
        renewalStatus: string;
        resourceGroupId: string;
        securityIps: string[];
        /**
         * The status of the cluster. Valid values: `Preparing`, `Creating`, `Restoring`, `Running`, `Deleting`, `ClassChanging`, `NetAddressCreating`, `NetAddressDeleting`. For more information, see [Cluster status](https://www.alibabacloud.com/help/doc-detail/143075.htm).
         */
        status: string;
        storageResource: string;
        /**
         * A mapping of tags to assign to the resource.
         * - Key: It can be up to 64 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://". It cannot be a null string.
         * - Value: It can be up to 128 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://". It can be a null string.
         */
        tags: {[key: string]: any};
        vpcCloudInstanceId: string;
        /**
         * ID of the VPC the cluster belongs to.
         */
        vpcId: string;
        vswitchId: string;
        /**
         * The ZoneId of the ADB cluster.
         */
        zoneId: string;
    }

    export interface GetDBClustersCluster {
        /**
         * Auto-renewal period of an cluster, in the unit of the month.
         */
        autoRenewPeriod: number;
        /**
         * The payment type of the resource.
         */
        chargeType: string;
        /**
         * The name of the service.
         */
        commodityCode: string;
        /**
         * The specifications of computing resources in elastic mode. The increase of resources can speed up queries. AnalyticDB for MySQL automatically scales computing resources. For more information, see [Specifications](https://www.alibabacloud.com/help/en/doc-detail/144851.htm).
         */
        computeResource: string;
        /**
         * The endpoint of the cluster.
         */
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        /**
         * The db cluster category.
         */
        dbClusterCategory: string;
        /**
         * The db cluster id.
         */
        dbClusterId: string;
        /**
         * The db cluster network type.
         */
        dbClusterNetworkType: string;
        /**
         * The db cluster type.
         */
        dbClusterType: string;
        /**
         * The db cluster version.
         */
        dbClusterVersion: string;
        /**
         * The db node class.
         */
        dbNodeClass: string;
        /**
         * The db node count.
         */
        dbNodeCount: number;
        /**
         * The db node storage.
         */
        dbNodeStorage: number;
        /**
         * The description of DBCluster.
         */
        description: string;
        /**
         * The type of the disk.
         */
        diskType: string;
        /**
         * The ID of the data synchronization task in Data Transmission Service (DTS). This parameter is valid only for analytic instances.
         */
        dtsJobId: string;
        /**
         * The elastic io resource.
         */
        elasticIoResource: number;
        /**
         * The engine of the database.
         */
        engine: string;
        /**
         * The engine version of the database..
         */
        engineVersion: string;
        /**
         * The number of nodes. The node resources are used for data computing in elastic mode.
         */
        executorCount: string;
        /**
         * The time when the cluster expires.
         */
        expireTime: string;
        /**
         * Indicates whether the cluster has expired.
         */
        expired: string;
        /**
         * The ID of the DBCluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The reason why the cluster is locked.
         */
        lockReason: string;
        /**
         * The maintenance window of the cluster.
         */
        maintainTime: string;
        /**
         * The lock mode of the cluster.
         */
        mode: string;
        networkType: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The port that is used to access the cluster.
         */
        port: number;
        /**
         * The ID of the ApsaraDB RDS instance from which data is synchronized to the cluster. This parameter is valid only for analytic instances.
         */
        rdsInstanceId: string;
        regionId: string;
        /**
         * The status of renewal.
         */
        renewalStatus: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * List of IP addresses allowed to access all databases of an cluster.
         */
        securityIps: string[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The specifications of storage resources in elastic mode. The resources are used for data read and write operations. The increase of resources can improve the read and write performance of your cluster. For more information, see [Specifications](https://www.alibabacloud.com/help/en/doc-detail/144851.htm).
         */
        storageResource: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The vpc cloud instance id.
         */
        vpcCloudInstanceId: string;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID  of the resource.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace alb {
    export interface AclAclEntry {
        /**
         * The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
         */
        description?: string;
        /**
         * The IP address for the ACL entry.
         */
        entry?: string;
        /**
         * The state of the ACL. Valid values:`Provisioning`, `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
         */
        status: string;
    }

    export interface GetAclsAcl {
        /**
         * ACL Entries.
         */
        aclEntries: outputs.alb.GetAclsAclAclEntry[];
        /**
         * Access Control Policy ID.
         */
        aclId: string;
        /**
         * The ACL Name.
         */
        aclName: string;
        /**
         * Address Protocol Version.
         */
        addressIpVersion: string;
        /**
         * The ID of the Acl.
         */
        id: string;
        /**
         * Resource Group to Which the Number.
         */
        resourceGroupId: string;
        /**
         * The state of the ACL. Valid values:`Provisioning` , `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
         */
        status: string;
    }

    export interface GetAclsAclAclEntry {
        /**
         * Access Control Entries Note Description Length Is Limited to 1 to 256 Characters, Letters, digital, the Dash (-), a Forward Slash (/), Half a Period (.) and Underscores (_), Support Chinese Characters.
         */
        description: string;
        entry: string;
        /**
         * The state of the ACL. Valid values:`Provisioning` , `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
         */
        status: string;
    }

    export interface GetHealthCheckTemplatesTemplate {
        /**
         * The HTTP status code that indicates a successful health check.
         */
        healthCheckCodes: string[];
        /**
         * The number of the port that is used for health checks.  Valid values: `0` to `65535`.  Default value:` 0`. This default value indicates that the backend server is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * The domain name that is used for health checks. Default value:  `$SERVER_IP`. The domain name must be 1 to 80 characters in length.
         */
        healthCheckHost: string;
        /**
         * The version of the HTTP protocol.  Valid values: `HTTP1.0` and `HTTP1.1`.  Default value: `HTTP1.1`.
         */
        healthCheckHttpVersion: string;
        /**
         * The time interval between two consecutive health checks.  Valid values: `1` to `50`. Unit: seconds.  Default value: `2`.
         */
        healthCheckInterval: number;
        /**
         * The health check method.  Valid values: `GET` and `HEAD`.  Default value: `HEAD`.
         */
        healthCheckMethod: string;
        /**
         * The URL that is used for health checks.  The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: ` _ ; ~ ! ( )* [ ] @ $ ^ : ' , +. The URL must start with a forward slash (/)`.
         */
        healthCheckPath: string;
        /**
         * The protocol that is used for health checks.  Valid values: HTTP and TCP.  Default value: HTTP.
         */
        healthCheckProtocol: string;
        /**
         * The ID of the resource.
         */
        healthCheckTemplateId: string;
        /**
         * The name of the health check template.  The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.
         */
        healthCheckTemplateName: string;
        /**
         * The timeout period of a health check response. If the backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the health check fails.  Valid values: `1` to `300`. Unit: seconds.  Default value: `5`.
         */
        healthCheckTimeout: number;
        /**
         * The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy (from fail to success). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
         */
        healthyThreshold: number;
        /**
         * The ID of the Health Check Template.
         */
        id: string;
        /**
         * The number of times that an healthy backend server must consecutively fail health checks before it is declared unhealthy (from success to fail). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
         */
        unhealthyThreshold: number;
    }

    export interface GetListenersListener {
        /**
         * Indicates whether the access log has a custom header field. Valid values: true and false. Default value: false.
         */
        accessLogRecordCustomizedHeadersEnabled: boolean;
        /**
         * Xtrace Configuration Information.
         */
        accessLogTracingConfigs: outputs.alb.GetListenersListenerAccessLogTracingConfig[];
        /**
         * The configurations of the access control lists (ACLs).
         */
        aclConfigs: outputs.alb.GetListenersListenerAclConfig[];
        /**
         * The Certificate List.
         */
        certificates: outputs.alb.GetListenersListenerCertificate[];
        /**
         * The Default Rule Action List.
         */
        defaultActions: outputs.alb.GetListenersListenerDefaultAction[];
        /**
         * Whether to Enable Gzip Compression, as a Specific File Type on a Compression. Valid Values: `True` Or `False`. Default Value: `True`.
         */
        gzipEnabled: boolean;
        /**
         * Whether to Enable HTTP/2 Features. Valid Values: `True` Or `False`. Default Value: `True`.
         */
        http2Enabled: boolean;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * Specify the Connection Idle Timeout Value: `1` to `60`. Unit: Seconds.
         */
        idleTimeout: number;
        /**
         * Set the IP Address of the Listened Description. Length Is from 2 to 256 Characters.
         */
        listenerDescription: string;
        /**
         * on Behalf of the Resource Level Id of the Resources Property Fields.
         */
        listenerId: string;
        /**
         * The ALB Instance Front-End, and Those of the Ports Used. Value: `1~65535`.
         */
        listenerPort: number;
        /**
         * Snooping Protocols. Valid Values: `HTTP`, `HTTPS` Or `QUIC`.
         */
        listenerProtocol: string;
        /**
         * The ALB Instance Id.
         */
        loadBalancerId: string;
        /**
         * This Request Returned by the Maximum Number of Records.
         */
        maxResults: string;
        /**
         * The Current Call Returns to the Position of the Set to Null Represents the Data Has Been Read to the End of.
         */
        nextToken: string;
        /**
         * Configuration Associated with the QuIC Listening.
         */
        quicConfigs: outputs.alb.GetListenersListenerQuicConfig[];
        /**
         * The Specified Request Timeout Time. Value: `1` to `180`. Unit: Seconds. Default Value: 60. If the Timeout Time Within the Back-End Server Has Not Answered the ALB Will Give up Waiting, the Client Returns the HTTP 504 Error Code.
         */
        requestTimeout: number;
        /**
         * Security Policy.
         */
        securityPolicyId: string;
        /**
         * The association status between the ACL and the listener.  Valid values: `Associating`, `Associated` Or `Dissociating`. `Associating`: The ACL is being associated with the listener. `Associated`: The ACL is associated with the listener. `Dissociating`: The ACL is being disassociated from the listener.
         */
        status: string;
        /**
         * xforwardfor Related Attribute Configuration.
         */
        xforwardedForConfigs: outputs.alb.GetListenersListenerXforwardedForConfig[];
    }

    export interface GetListenersListenerAccessLogTracingConfig {
        /**
         * Xtrace Function. Value: True Or False. Default Value: False.
         */
        tracingEnabled: boolean;
        /**
         * Xtrace Sampling Rate. Value: **1~10000**.
         */
        tracingSample: number;
        /**
         * Xtrace Type Value Is **Zipkin**.
         */
        tracingType: string;
    }

    export interface GetListenersListenerAclConfig {
        /**
         * The ACLs that are associated with the listener.
         */
        aclRelations: outputs.alb.GetListenersListenerAclConfigAclRelation[];
        /**
         * The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
         */
        aclType: string;
    }

    export interface GetListenersListenerAclConfigAclRelation {
        /**
         * Snooping Binding of the Access Policy Group ID List.
         */
        aclId: string;
        /**
         * The association status between the ACL and the listener.  Valid values: `Associating`, `Associated` Or `Dissociating`. `Associating`: The ACL is being associated with the listener. `Associated`: The ACL is associated with the listener. `Dissociating`: The ACL is being disassociated from the listener.
         */
        status: string;
    }

    export interface GetListenersListenerCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
    }

    export interface GetListenersListenerDefaultAction {
        /**
         * The configuration of the forwarding rule action. This parameter is required if the Type parameter is set to FowardGroup.
         */
        forwardGroupConfigs: outputs.alb.GetListenersListenerDefaultActionForwardGroupConfig[];
        /**
         * Action Type. The value is set to ForwardGroup. It indicates that requests are forwarded to multiple vServer groups.
         */
        type: string;
    }

    export interface GetListenersListenerDefaultActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.GetListenersListenerDefaultActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetListenersListenerDefaultActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface GetListenersListenerQuicConfig {
        /**
         * The ID of the QUIC listener to be associated. If QuicUpgradeEnabled is set to true, this parameter is required. Only HTTPS listeners support this parameter.
         */
        quicListenerId: string;
        /**
         * Indicates whether quic upgrade is enabled. Valid values: true and false. Default value: false.
         */
        quicUpgradeEnabled: boolean;
    }

    export interface GetListenersListenerXforwardedForConfig {
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertIssuerdnenabled`, Which Evaluates to True When the Entry into Force of.
         */
        xforwardedforclientcertIssuerdnalias: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
         */
        xforwardedforclientcertIssuerdnenabled: boolean;
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertclientverifyenabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertclientverifyalias: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
         */
        xforwardedforclientcertclientverifyenabled: boolean;
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertfingerprintenabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertfingerprintalias: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
         */
        xforwardedforclientcertfingerprintenabled: boolean;
        /**
         * The name of the custom header. This parameter is valid only if `xforwardedforclientcertsubjectdnenabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertsubjectdnalias: string;
        /**
         * Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
         */
        xforwardedforclientcertsubjectdnenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
         */
        xforwardedforclientsrcportenabled: boolean;
        /**
         * Indicates whether the X-Forwarded-For header field is used to obtain the real IP address of tqhe client. Valid values: true and false. Default value: true.
         */
        xforwardedforenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
         */
        xforwardedforprotoenabled: boolean;
        /**
         * Indicates whether the SLB-ID header field is used to obtain the ID of the ALB instance. Valid values: true and false. Default value: false.
         */
        xforwardedforslbidenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
         */
        xforwardedforslbportenabled: boolean;
    }

    export interface GetLoadBalancersBalancer {
        /**
         * The Access Logging Configuration Structure.
         */
        accessLogConfigs: outputs.alb.GetLoadBalancersBalancerAccessLogConfig[];
        /**
         * The method in which IP addresses are assigned. Valid values:  Fixed: The ALB instance
         * uses a fixed IP address. Dynamic (default): An IP address is dynamically assigned to each zone of the ALB
         * instance.
         */
        addressAllocatedMode: string;
        /**
         * The type of IP address that the ALB instance uses to provide services.
         */
        addressType: string;
        /**
         * The ID of the EIP bandwidth plan which is associated with an ALB instance that uses a
         * public IP address.
         */
        bandwidthPackageId: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * Remove the Protection Configuration.
         */
        deletionProtectionConfigs: outputs.alb.GetLoadBalancersBalancerDeletionProtectionConfig[];
        /**
         * DNS Domain Name.
         */
        dnsName: string;
        /**
         * The ID of the Load Balancer.
         */
        id: string;
        /**
         * The configuration of the billing method.
         */
        loadBalancerBillingConfigs: outputs.alb.GetLoadBalancersBalancerLoadBalancerBillingConfig[];
        /**
         * Load Balancing of the Service Status. Valid Values: `Abnormal` and `Normal`. **NOTE:** Available in 1.142.0+
         */
        loadBalancerBusinessStatus: string;
        /**
         * Load Balancing of the Service Status. Valid Values: `Abnormal` and `Normal`.  **NOTE:** Field 'load_balancer_bussiness_status' has been deprecated from provider version 1.142.0.
         *
         * @deprecated Field 'load_balancer_bussiness_status' has been deprecated from provider version 1.142.0 and it will be remove in the future version. Please use the new parameter 'load_balancer_business_status' instead.
         */
        loadBalancerBussinessStatus: string;
        /**
         * The edition of the ALB instance.
         */
        loadBalancerEdition: string;
        /**
         * The first ID of the resource.
         */
        loadBalancerId: string;
        /**
         * The name of the resource.
         */
        loadBalancerName: string;
        /**
         * The Load Balancing Operations Lock Configuration.
         */
        loadBalancerOperationLocks: outputs.alb.GetLoadBalancersBalancerLoadBalancerOperationLock[];
        /**
         * Modify the Protection Configuration.
         */
        modificationProtectionConfigs: outputs.alb.GetLoadBalancersBalancerModificationProtectionConfig[];
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
         */
        status: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the virtual private cloud (VPC) where the ALB instance is deployed.
         */
        vpcId: string;
        /**
         * The zones and vSwitches. You must specify at least two zones.
         */
        zoneMappings: outputs.alb.GetLoadBalancersBalancerZoneMapping[];
    }

    export interface GetLoadBalancersBalancerAccessLogConfig {
        /**
         * The log service that access logs are shipped to.
         */
        logProject: string;
        /**
         * The logstore that access logs are shipped to.
         */
        logStore: string;
    }

    export interface GetLoadBalancersBalancerDeletionProtectionConfig {
        /**
         * Remove the Protection Status.
         */
        enabled: boolean;
        /**
         * Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm:SSZ.
         */
        enabledTime: string;
    }

    export interface GetLoadBalancersBalancerLoadBalancerBillingConfig {
        /**
         * The billing method of the ALB instance. Valid value: `PayAsYouGo`.
         */
        payType: string;
    }

    export interface GetLoadBalancersBalancerLoadBalancerOperationLock {
        /**
         * The Locking of the Reasons.
         */
        lockReason: string;
        /**
         * The Locking of the Type. Valid Values: `securitylocked`,`relatedresourcelocked`, `financiallocked`, and `residuallocked`.
         */
        lockType: string;
    }

    export interface GetLoadBalancersBalancerModificationProtectionConfig {
        /**
         * The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
         */
        reason: string;
        /**
         * The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
         */
        status: string;
    }

    export interface GetLoadBalancersBalancerZoneMapping {
        loadBalancerAddresses: outputs.alb.GetLoadBalancersBalancerZoneMappingLoadBalancerAddress[];
        /**
         * The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
         */
        vswitchId: string;
        /**
         * The ID of the zone to which the ALB instance belongs.
         */
        zoneId: string;
    }

    export interface GetLoadBalancersBalancerZoneMappingLoadBalancerAddress {
        address: string;
    }

    export interface GetRulesRule {
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * The ID of the listener to which the forwarding rule belongs.
         */
        listenerId: string;
        /**
         * The ID of the Application Load Balancer (ALB) instance to which the forwarding rule belongs.
         */
        loadBalancerId: string;
        /**
         * The priority of the rule. Valid values: 1 to 10000. A smaller value indicates a higher priority.  Note The priority of each rule within the same listener must be unique.
         */
        priority: number;
        /**
         * The actions of the forwarding rules.
         */
        ruleActions: outputs.alb.GetRulesRuleRuleAction[];
        /**
         * The conditions of the forwarding rule.
         */
        ruleConditions: outputs.alb.GetRulesRuleRuleCondition[];
        /**
         * The first ID of the resource.
         */
        ruleId: string;
        /**
         * The name of the forwarding rule. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.
         */
        ruleName: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetRulesRuleRuleAction {
        /**
         * The configuration of the fixed response.
         */
        fixedResponseConfigs: outputs.alb.GetRulesRuleRuleActionFixedResponseConfig[];
        /**
         * The configurations of the destination server groups.
         */
        forwardGroupConfigs: outputs.alb.GetRulesRuleRuleActionForwardGroupConfig[];
        /**
         * The configuration of the inserted header field.
         */
        insertHeaderConfigs: outputs.alb.GetRulesRuleRuleActionInsertHeaderConfig[];
        /**
         * The order of the forwarding rule actions. Valid values:1 to 50000. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
         */
        order: number;
        /**
         * The configuration of the external redirect action.
         */
        redirectConfigs: outputs.alb.GetRulesRuleRuleActionRedirectConfig[];
        /**
         * The redirect action within ALB.
         */
        rewriteConfigs: outputs.alb.GetRulesRuleRuleActionRewriteConfig[];
        /**
         * The type of the forwarding rule.
         */
        type: string;
    }

    export interface GetRulesRuleRuleActionFixedResponseConfig {
        /**
         * The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
         */
        content: string;
        /**
         * The format of the fixed response.  Valid values: text/plain, text/css, text/html, application/javascript, and application/json.
         */
        contentType: string;
        /**
         * The redirect method. Valid values:301, 302, 303, 307, and 308.
         */
        httpCode: string;
    }

    export interface GetRulesRuleRuleActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.GetRulesRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetRulesRuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface GetRulesRuleRuleActionInsertHeaderConfig {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters, asterisks (*), and question marks (?). The value cannot contain spaces or the following special characters: # [ ] { } \ | < > &.
         */
        value: string;
        /**
         * Valid values:  UserDefined: a custom value ReferenceHeader: uses a field of the user request header. SystemDefined: a system value.
         */
        valueType: string;
    }

    export interface GetRulesRuleRuleActionRedirectConfig {
        /**
         * The host name of the destination to which requests are redirected within ALB.  Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host: string;
        /**
         * The redirect method. Valid values:301, 302, 303, 307, and 308.
         */
        httpCode: string;
        /**
         * The path to which requests are to be redirected within ALB.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ”. The path is case-sensitive.  Default value: ${path}. This value can be used only once. You can use it with a valid string.
         */
        path: string;
        /**
         * The port of the destination to which requests are redirected.  Valid values: 1 to 63335.  Default value: ${port}. You cannot use this value together with other characters at the same time.
         */
        port: string;
        /**
         * The protocol of the requests to be redirected.  Valid values: HTTP and HTTPS.  Default value: ${protocol}. You cannot use this value together with other characters at the same time.  Note HTTPS listeners can redirect only HTTPS requests.
         */
        protocol: string;
        /**
         * The query string of the request to be redirected within ALB.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. This value can be used only once. You can use it with a valid string.
         */
        query: string;
    }

    export interface GetRulesRuleRuleActionRewriteConfig {
        /**
         * The host name of the destination to which requests are redirected within ALB.  Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host: string;
        /**
         * The path to which requests are to be redirected within ALB.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ”. The path is case-sensitive.  Default value: ${path}. This value can be used only once. You can use it with a valid string.
         */
        path: string;
        /**
         * The query string of the request to be redirected within ALB.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. This value can be used only once. You can use it with a valid string.
         */
        query: string;
    }

    export interface GetRulesRuleRuleCondition {
        /**
         * The configuration of the cookie.
         */
        cookieConfigs: outputs.alb.GetRulesRuleRuleConditionCookieConfig[];
        /**
         * The configuration of the header field.
         */
        headerConfigs: outputs.alb.GetRulesRuleRuleConditionHeaderConfig[];
        /**
         * The configuration of the host.
         */
        hostConfigs: outputs.alb.GetRulesRuleRuleConditionHostConfig[];
        /**
         * The configuration of the request method.
         */
        methodConfigs: outputs.alb.GetRulesRuleRuleConditionMethodConfig[];
        /**
         * The configuration of the path for the request to be forwarded.
         */
        pathConfigs: outputs.alb.GetRulesRuleRuleConditionPathConfig[];
        /**
         * The configuration of the query string.
         */
        queryStringConfigs: outputs.alb.GetRulesRuleRuleConditionQueryStringConfig[];
        /**
         * The type of the forwarding rule.
         */
        type: string;
    }

    export interface GetRulesRuleRuleConditionCookieConfig {
        /**
         * The path of the request to be forwarded. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ". The value is case-sensitive, and can contain asterisks (*) and question marks (?).
         */
        values: outputs.alb.GetRulesRuleRuleConditionCookieConfigValue[];
    }

    export interface GetRulesRuleRuleConditionCookieConfigValue {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters, asterisks (*), and question marks (?). The value cannot contain spaces or the following special characters: # [ ] { } \ | < > &.
         */
        value: string;
    }

    export interface GetRulesRuleRuleConditionHeaderConfig {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The path of the request to be forwarded. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ". The value is case-sensitive, and can contain asterisks (*) and question marks (?).
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionHostConfig {
        /**
         * The path of the request to be forwarded. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ". The value is case-sensitive, and can contain asterisks (*) and question marks (?).
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionMethodConfig {
        /**
         * The path of the request to be forwarded. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ". The value is case-sensitive, and can contain asterisks (*) and question marks (?).
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionPathConfig {
        /**
         * The path of the request to be forwarded. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ". The value is case-sensitive, and can contain asterisks (*) and question marks (?).
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionQueryStringConfig {
        /**
         * The path of the request to be forwarded. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ". The value is case-sensitive, and can contain asterisks (*) and question marks (?).
         */
        values: outputs.alb.GetRulesRuleRuleConditionQueryStringConfigValue[];
    }

    export interface GetRulesRuleRuleConditionQueryStringConfigValue {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters, asterisks (*), and question marks (?). The value cannot contain spaces or the following special characters: # [ ] { } \ | < > &.
         */
        value: string;
    }

    export interface GetSecurityPoliciesPolicy {
        /**
         * The supported cipher suites, which are determined by the TLS protocol version.
         */
        ciphers: string[];
        /**
         * The ID of the Security Policy.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The first ID of the resource.
         */
        securityPolicyId: string;
        /**
         * The name of the resource. The name must be 2 to 128 characters in length and must start with a letter. It can contain digits, periods (.), underscores (_), and hyphens (-).
         */
        securityPolicyName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The TLS protocol versions that are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
         */
        tlsVersions: string[];
    }

    export interface GetServerGroupsGroup {
        /**
         * The configuration of health checks.
         */
        healthCheckConfigs: outputs.alb.GetServerGroupsGroupHealthCheckConfig[];
        /**
         * The ID of the Server Group.
         */
        id: string;
        /**
         * The server protocol. Valid values: `HTTP` and `HTTPS`. Default value: `HTTP`.
         */
        protocol: string;
        /**
         * The scheduling algorithm. Valid values: `Wrr`, `Wlc` and `Sch`.
         */
        scheduler: string;
        /**
         * The first ID of the res ource.
         */
        serverGroupId: string;
        /**
         * The name of the resource.
         */
        serverGroupName: string;
        /**
         * The backend server.
         */
        servers: outputs.alb.GetServerGroupsGroupServer[];
        /**
         * The status of the resource. Valid values: `Provisioning`, `Available` and `Configuring`.
         */
        status: string;
        /**
         * The configuration of the sticky session.
         */
        stickySessionConfigs: outputs.alb.GetServerGroupsGroupStickySessionConfig[];
        tags: {[key: string]: any};
        /**
         * The ID of the VPC that you want to access.
         */
        vpcId: string;
    }

    export interface GetServerGroupsGroupHealthCheckConfig {
        /**
         * The status code for a successful health check. Multiple status codes can be specified as a list. Valid values: `http2xx`, `http3xx`, `http4xx`, and `http5xx`. Default value: `http2xx`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckCodes: string[];
        /**
         * The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of `0` indicates that a backend server port is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
         */
        healthCheckEnabled: boolean;
        /**
         * The domain name that is used for health checks.
         */
        healthCheckHost: string;
        /**
         * HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckHttpVersion: string;
        /**
         * The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
         */
        healthCheckInterval: number;
        /**
         * Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckMethod: string;
        /**
         * The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckPath: string;
        /**
         * Health check protocol. Valid values: `HTTP` and `TCP`.
         */
        healthCheckProtocol: string;
        /**
         * The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: `1` to `300`. Default value: `5`. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
         */
        healthCheckTimeout: number;
        /**
         * The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: `2` to `10`. Default value: `3`.
         */
        healthyThreshold: number;
        /**
         * The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
         */
        unhealthyThreshold: number;
    }

    export interface GetServerGroupsGroupServer {
        /**
         * The description of the server.
         */
        description: string;
        /**
         * The port that is used by the server. Valid values: `1` to `65535`.
         */
        port: number;
        /**
         * The ID of the ECS instance, ENI instance or ECI instance.
         */
        serverId: string;
        /**
         * The IP address of the ENI instance when it is in the inclusive ENI mode.
         */
        serverIp: string;
        /**
         * The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
         */
        serverType: string;
        /**
         * The status of the resource. Valid values: `Provisioning`, `Available` and `Configuring`.
         */
        status: string;
        /**
         * The weight of the server.  Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no requests are forwarded to the server.
         */
        weight: number;
    }

    export interface GetServerGroupsGroupStickySessionConfig {
        /**
         * the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession` parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
         */
        cookie: string;
        /**
         * The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
         */
        cookieTimeout: number;
        /**
         * Indicates whether sticky session is enabled. Values: `true` and `false`. Default value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
         */
        stickySessionEnabled: boolean;
        /**
         * The method that is used to handle a cookie. Values: `Server` and `Insert`.
         */
        stickySessionType: string;
    }

    export interface GetZonesZone {
        /**
         * The ID of zone.
         */
        id: string;
        /**
         * The local name.
         */
        localName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface ListenerAccessLogTracingConfig {
        /**
         * Xtrace Function. Value: `True` Or `False` . Default Value: `False`.
         */
        tracingEnabled?: boolean;
        /**
         * Xtrace Sampling Rate. Value: `1` to `10000`.
         */
        tracingSample?: number;
        /**
         * Xtrace Type Value Is `Zipkin`.
         */
        tracingType?: string;
    }

    export interface ListenerAclConfig {
        /**
         * The ACLs that are associated with the listener.
         */
        aclRelations?: outputs.alb.ListenerAclConfigAclRelation[];
        /**
         * The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
         */
        aclType?: string;
    }

    export interface ListenerAclConfigAclRelation {
        /**
         * Snooping Binding of the Access Policy Group ID List.
         */
        aclId?: string;
        /**
         * The state of the listener. Valid Values: `Running` Or `Stopped`. Valid values: `Running`: The listener is running. `Stopped`: The listener is stopped.
         */
        status: string;
    }

    export interface ListenerCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId?: string;
    }

    export interface ListenerDefaultAction {
        /**
         * The configurations of the actions. This parameter is required if Type is set to FowardGroup.
         */
        forwardGroupConfig: outputs.alb.ListenerDefaultActionForwardGroupConfig;
        /**
         * Action Type.
         */
        type: string;
    }

    export interface ListenerDefaultActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.ListenerDefaultActionForwardGroupConfigServerGroupTuple[];
    }

    export interface ListenerDefaultActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface ListenerQuicConfig {
        /**
         * There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
         */
        quicListenerId?: string;
        /**
         * Indicates Whether to Enable the QuIC Upgrade.
         */
        quicUpgradeEnabled: boolean;
    }

    export interface ListenerXforwardedForConfig {
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertIssuerdnenabled`, Which Evaluates to True When the Entry into Force of.
         */
        xforwardedforclientcertIssuerdnalias?: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
         */
        xforwardedforclientcertIssuerdnenabled: boolean;
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertclientverifyenabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertclientverifyalias?: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
         */
        xforwardedforclientcertclientverifyenabled: boolean;
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertfingerprintenabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertfingerprintalias?: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
         */
        xforwardedforclientcertfingerprintenabled: boolean;
        /**
         * The name of the custom header. This parameter is valid only if `xforwardedforclientcertsubjectdnenabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertsubjectdnalias?: string;
        /**
         * Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
         */
        xforwardedforclientcertsubjectdnenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
         */
        xforwardedforclientsrcportenabled: boolean;
        /**
         * Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
         */
        xforwardedforenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
         */
        xforwardedforprotoenabled: boolean;
        /**
         * Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id.
         */
        xforwardedforslbidenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
         */
        xforwardedforslbportenabled: boolean;
    }

    export interface LoadBalancerAccessLogConfig {
        /**
         * The log service that access logs are shipped to.
         */
        logProject?: string;
        /**
         * The log service that access logs are shipped to.
         */
        logStore?: string;
    }

    export interface LoadBalancerLoadBalancerBillingConfig {
        /**
         * The billing method of the ALB instance. Valid value: `PayAsYouGo`.
         */
        payType: string;
    }

    export interface LoadBalancerModificationProtectionConfig {
        /**
         * The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
         */
        reason: string;
        /**
         * Specifies whether to enable the configuration read-only mode for the ALB instance. Valid values: `NonProtection` and `ConsoleProtection`.
         */
        status: string;
    }

    export interface LoadBalancerZoneMapping {
        /**
         * The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
         */
        vswitchId: string;
        /**
         * The ID of the zone to which the ALB instance belongs.
         */
        zoneId: string;
    }

    export interface RuleRuleAction {
        /**
         * The configuration of the fixed response. See the following `Block fixedResponseConfig`.
         */
        fixedResponseConfig?: outputs.alb.RuleRuleActionFixedResponseConfig;
        /**
         * The forward response action within ALB. See the following `Block forwardGroupConfig`.
         */
        forwardGroupConfig: outputs.alb.RuleRuleActionForwardGroupConfig;
        /**
         * The configuration of the inserted header field. See the following `Block insertHeaderConfig`.
         */
        insertHeaderConfig?: outputs.alb.RuleRuleActionInsertHeaderConfig;
        /**
         * The order of the forwarding rule actions. Valid values: 1 to 50000. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
         */
        order: number;
        /**
         * The configuration of the external redirect action. See the following `Block redirectConfig`.
         */
        redirectConfig?: outputs.alb.RuleRuleActionRedirectConfig;
        /**
         * The redirect action within ALB. See the following `Block rewriteConfig`.
         */
        rewriteConfig?: outputs.alb.RuleRuleActionRewriteConfig;
        /**
         * The action. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`. **Note:**  The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
         */
        type: string;
    }

    export interface RuleRuleActionFixedResponseConfig {
        /**
         * The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
         */
        content: string;
        /**
         * The format of the fixed response.  Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
         */
        contentType?: string;
        /**
         * The HTTP status code of the response. The code must be an `HTTP_2xx`, `HTTP_4xx` or `HTTP_5xx.x` is a digit.
         */
        httpCode?: string;
    }

    export interface RuleRuleActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.RuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface RuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface RuleRuleActionInsertHeaderConfig {
        /**
         * The name of the inserted header field. The name must be 1 to 40 characters in length, and can contain letters, digits, underscores (_), and hyphens (-). You cannot use the same name in InsertHeader.  Note You cannot use Cookie or Host in the name.
         */
        key?: string;
        /**
         * The content of the inserted header field:  If the ValueType parameter is set to SystemDefined, the following values are used:  ClientSrcPort: the port of the client ClientSrcIp: the IP address of the client Protocol: the protocol used by client requests (HTTP or HTTPS) SLBId: the ID of the ALB instance SLBPort: the listener port of the ALB instance If the ValueType parameter is set to UserDefined: The header value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters whose ASCII value is ch >= 32 && ch < 127, and wildcards such as asterisks (*) and question marks (?). The header value cannot start or end with a space.  If the ValueType parameter is set to ReferenceHeader: The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (_), and hyphens (-). Valid values: `ClientSrcPort`, `ClientSrcIp`, `Protocol`, `SLBId`, `SLBPort`, `UserDefined`.
         */
        value?: string;
        /**
         * Valid values:  UserDefined: a custom value ReferenceHeader: uses a field of the user request header. SystemDefined: a system value.
         */
        valueType?: string;
    }

    export interface RuleRuleActionRedirectConfig {
        /**
         * The host name of the destination to which requests are directed.  The host name must meet the following rules:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host?: string;
        /**
         * The HTTP status code of the response. The code must be an `HTTP_2xx`, `HTTP_4xx` or `HTTP_5xx.x` is a digit.
         */
        httpCode?: string;
        /**
         * The path of the destination to which requests are directed.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?) and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ”. The path is case-sensitive.  Default value: ${path}. You can also reference ${host}, ${protocol}, and ${port}. Each variable can appear at most once. You can use the preceding variables at the same time, or use them with a valid string.
         */
        path?: string;
        /**
         * The port of the destination to which requests are redirected.  Valid values: 1 to 63335.  Default value: ${port}. You cannot use this value together with other characters at the same time.
         */
        port?: number;
        /**
         * The protocol of the requests to be redirected.  Valid values: HTTP and HTTPS.  Default value: ${protocol}. You cannot use this value together with other characters at the same time.  Note HTTPS listeners can redirect only HTTPS requests.
         */
        protocol?: string;
        /**
         * The query string of the request to be redirected.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. You can also reference ${host}, ${protocol}, and ${port}. Each variable can appear at most once. You can use the preceding variables at the same time, or use them together with a valid string.
         */
        query?: string;
    }

    export interface RuleRuleActionRewriteConfig {
        /**
         * The host name of the destination to which requests are directed.  The host name must meet the following rules:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host?: string;
        /**
         * The path of the destination to which requests are directed.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?) and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , ”. The path is case-sensitive.  Default value: ${path}. You can also reference ${host}, ${protocol}, and ${port}. Each variable can appear at most once. You can use the preceding variables at the same time, or use them with a valid string.
         */
        path?: string;
        /**
         * The query string of the request to be redirected.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. You can also reference ${host}, ${protocol}, and ${port}. Each variable can appear at most once. You can use the preceding variables at the same time, or use them together with a valid string.
         */
        query?: string;
    }

    export interface RuleRuleCondition {
        /**
         * The configuration of the cookie. See the following `Block cookieConfig`.
         */
        cookieConfig?: outputs.alb.RuleRuleConditionCookieConfig;
        /**
         * The configuration of the header field. See the following `Block headerConfig`.
         */
        headerConfig?: outputs.alb.RuleRuleConditionHeaderConfig;
        /**
         * The configuration of the host field. See the following `Block hostConfig`.
         */
        hostConfig?: outputs.alb.RuleRuleConditionHostConfig;
        /**
         * The configuration of the request method. See the following `Block methodConfig`.
         */
        methodConfig?: outputs.alb.RuleRuleConditionMethodConfig;
        /**
         * The configuration of the path for the request to be forwarded. See the following `Block pathConfig`.
         */
        pathConfig?: outputs.alb.RuleRuleConditionPathConfig;
        /**
         * The configuration of the query string. See the following `Block queryStringConfig`.
         */
        queryStringConfig?: outputs.alb.RuleRuleConditionQueryStringConfig;
        /**
         * The action. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`. **Note:**  The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
         */
        type: string;
    }

    export interface RuleRuleConditionCookieConfig {
        /**
         * The query string.
         */
        values?: outputs.alb.RuleRuleConditionCookieConfigValue[];
    }

    export interface RuleRuleConditionCookieConfigValue {
        /**
         * The name of the inserted header field. The name must be 1 to 40 characters in length, and can contain letters, digits, underscores (_), and hyphens (-). You cannot use the same name in InsertHeader.  Note You cannot use Cookie or Host in the name.
         */
        key?: string;
        /**
         * The content of the inserted header field:  If the ValueType parameter is set to SystemDefined, the following values are used:  ClientSrcPort: the port of the client ClientSrcIp: the IP address of the client Protocol: the protocol used by client requests (HTTP or HTTPS) SLBId: the ID of the ALB instance SLBPort: the listener port of the ALB instance If the ValueType parameter is set to UserDefined: The header value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters whose ASCII value is ch >= 32 && ch < 127, and wildcards such as asterisks (*) and question marks (?). The header value cannot start or end with a space.  If the ValueType parameter is set to ReferenceHeader: The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (_), and hyphens (-). Valid values: `ClientSrcPort`, `ClientSrcIp`, `Protocol`, `SLBId`, `SLBPort`, `UserDefined`.
         */
        value?: string;
    }

    export interface RuleRuleConditionHeaderConfig {
        /**
         * The name of the inserted header field. The name must be 1 to 40 characters in length, and can contain letters, digits, underscores (_), and hyphens (-). You cannot use the same name in InsertHeader.  Note You cannot use Cookie or Host in the name.
         */
        key?: string;
        /**
         * The query string.
         */
        values?: string[];
    }

    export interface RuleRuleConditionHostConfig {
        /**
         * The query string.
         */
        values?: string[];
    }

    export interface RuleRuleConditionMethodConfig {
        /**
         * The query string.
         */
        values?: string[];
    }

    export interface RuleRuleConditionPathConfig {
        /**
         * The query string.
         */
        values?: string[];
    }

    export interface RuleRuleConditionQueryStringConfig {
        /**
         * The query string.
         */
        values?: outputs.alb.RuleRuleConditionQueryStringConfigValue[];
    }

    export interface RuleRuleConditionQueryStringConfigValue {
        /**
         * The name of the inserted header field. The name must be 1 to 40 characters in length, and can contain letters, digits, underscores (_), and hyphens (-). You cannot use the same name in InsertHeader.  Note You cannot use Cookie or Host in the name.
         */
        key?: string;
        /**
         * The content of the inserted header field:  If the ValueType parameter is set to SystemDefined, the following values are used:  ClientSrcPort: the port of the client ClientSrcIp: the IP address of the client Protocol: the protocol used by client requests (HTTP or HTTPS) SLBId: the ID of the ALB instance SLBPort: the listener port of the ALB instance If the ValueType parameter is set to UserDefined: The header value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters whose ASCII value is ch >= 32 && ch < 127, and wildcards such as asterisks (*) and question marks (?). The header value cannot start or end with a space.  If the ValueType parameter is set to ReferenceHeader: The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (_), and hyphens (-). Valid values: `ClientSrcPort`, `ClientSrcIp`, `Protocol`, `SLBId`, `SLBPort`, `UserDefined`.
         */
        value?: string;
    }

    export interface ServerGroupHealthCheckConfig {
        /**
         * The status code for a successful health check. Multiple status codes can be specified as a
         * list. Valid values: `http2xx`, `http3xx`, `http4xx`, and `http5xx`. Default value: `http2xx`. **NOTE:** This
         * parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckCodes: string[];
        /**
         * The port of the backend server that is used for health checks. Valid values: `0`
         * to `65535`. Default value: `0`. A value of 0 indicates that a backend server port is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * Indicates whether health checks are enabled. Valid values: `true`, `false`. Default
         * value: `true`.
         */
        healthCheckEnabled?: boolean;
        /**
         * The domain name that is used for health checks.
         */
        healthCheckHost: string;
        /**
         * HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`
         * . **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckHttpVersion: string;
        /**
         * The time interval between two consecutive health checks. Unit: seconds. Valid values: `1`
         * to `50`. Default value: `2`.
         */
        healthCheckInterval: number;
        /**
         * Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter
         * exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckMethod: string;
        /**
         * The forwarding rule path of health checks. **NOTE:** This parameter exists if
         * the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckPath: string;
        /**
         * Health check protocol. Valid values: `HTTP` and `TCP`.
         */
        healthCheckProtocol: string;
        /**
         * The timeout period of a health check response. If a backend Elastic Compute Service (ECS)
         * instance does not send an expected response within the specified period of time, the ECS instance is considered
         * unhealthy. Unit: seconds. Valid values: 1 to 300. Default value: 5. **NOTE:** If the value of the `HealthCHeckTimeout`
         * parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter
         * is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
         */
        healthCheckTimeout: number;
        /**
         * The number of health checks that an unhealthy backend server must pass consecutively before it
         * is declared healthy. In this case, the health check state is changed from fail to success. Valid values: 2 to 10.
         * Default value: 3.
         */
        healthyThreshold: number;
        /**
         * The number of consecutive health checks that a healthy backend server must consecutively fail
         * before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid
         * values: `2` to `10`. Default value: `3`.
         */
        unhealthyThreshold: number;
    }

    export interface ServerGroupServer {
        /**
         * The description of the server.
         */
        description?: string;
        /**
         * The port that is used by the server. Valid values: `1` to `65535`.
         */
        port?: number;
        /**
         * The ID of the ECS instance, ENI instance or ECI instance.
         */
        serverId?: string;
        /**
         * The IP address of the ENI instance when it is in the inclusive ENI mode.
         */
        serverIp: string;
        /**
         * The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
         */
        serverType?: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The weight of the server. Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no
         * requests are forwarded to the server.
         */
        weight: number;
    }

    export interface ServerGroupStickySessionConfig {
        /**
         * the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession`
         * parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
         */
        cookie: string;
        /**
         * The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1`
         * to `86400`. Default value: `1000`.
         */
        cookieTimeout: number;
        /**
         * Indicates whether sticky session is enabled. Values: `true` and `false`. Default
         * value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
         */
        stickySessionEnabled?: boolean;
        /**
         * The method that is used to handle a cookie. Values: `Server` and `Insert`.
         */
        stickySessionType: string;
    }
}

export namespace amqp {
    export interface GetBindingsBinding {
        /**
         * X-match Attributes. Valid Values: All: Default Value, All the Message Header of Key-Value Pairs Stored in the Must Match. Any: at Least One Pair of the Message Header of Key-Value Pairs Stored in the Must Match. This Parameter Applies Only to Headers Exchange Other Types of Exchange Is Invalid. Other Types of Exchange Here Can Either Be an Arbitrary Value.
         */
        argument: string;
        /**
         * The Binding Key. The Source of the Binding Exchange Non-Topic Type: Can Only Contain Letters, Lowercase Letters, Numbers, and the Dash (-), the Underscore Character (_), English Periods (.) and the at Sign (@). Length from 1 to 255 Characters. The Source of the Binding Exchange Topic Type: Can Contain Letters, Lowercase Letters, Numbers, and the Dash (-), the Underscore Character (_), English Periods (.) and the at Sign (@). If You Include the Hash (.
         */
        bindingKey: string;
        /**
         * The Target Binding Types.
         */
        bindingType: string;
        /**
         * The Target Queue Or Exchange of the Name.
         */
        destinationName: string;
        /**
         * The ID of the Binding. The value formats as `<instance_id>:<virtual_host_name>:<source_exchange>:<destination_name>`.
         */
        id: string;
        /**
         * Instance Id.
         */
        instanceId: string;
        /**
         * The Source Exchange Name.
         */
        sourceExchange: string;
        /**
         * Virtualhost Name.
         */
        virtualHostName: string;
    }

    export interface GetExchangesExchange {
        /**
         * The attributes.
         */
        attributes: {[key: string]: any};
        /**
         * Indicates whether the Auto Delete attribute is configured.
         */
        autoDeleteState: boolean;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The name of the exchange.
         */
        exchangeName: string;
        /**
         * The type of the exchange.
         */
        exchangeType: string;
        /**
         * The ID of the Exchange. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The name of virtual host where an exchange resides.
         */
        virtualHostName: string;
    }

    export interface GetInstancesInstance {
        /**
         * OrderCreateTime.
         */
        createTime: string;
        /**
         * ExpireTime.
         */
        expireTime: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * THe instance Id.
         */
        instanceId: string;
        /**
         * THe instance name.
         */
        instanceName: string;
        /**
         * The instance type.
         */
        instanceType: string;
        /**
         * The Pay-as-You-Type Values Include: the Subscription of a Pre-Paid.
         */
        paymentType: string;
        /**
         * The private endPoint.
         */
        privateEndPoint: string;
        /**
         * The public dndpoint.
         */
        publicEndpoint: string;
        /**
         * Renewal duration.
         */
        renewalDuration: number;
        /**
         * Auto-Renewal Cycle Unit Values Include: Month: Month. Year: Years.
         */
        renewalDurationUnit: string;
        /**
         * Renew status.
         */
        renewalStatus: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Whether to support eip.
         */
        supportEip: boolean;
    }

    export interface GetQueuesQueue {
        /**
         * The attributes for the Queue.
         */
        attributes: {[key: string]: any};
        /**
         * Specifies whether the Auto Delete attribute is configured.
         */
        autoDeleteState: boolean;
        /**
         * CreateTime.
         */
        createTime: string;
        /**
         * Specifies whether the queue is an exclusive queue.
         */
        exclusiveState: boolean;
        /**
         * The ID of the Queue. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The last consume time.
         */
        lastConsumeTime: string;
        /**
         * The queue name.
         */
        queueName: string;
        /**
         * The name of the virtual host.
         */
        virtualHostName: string;
    }

    export interface GetVirtualHostsHost {
        /**
         * The ID of the Virtual Host.
         */
        id: string;
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * VirtualHostName.
         */
        virtualHostName: string;
    }

}

export namespace apigateway {
    export interface ApiConstantParameter {
        /**
         * The description of Constant parameter.
         */
        description?: string;
        /**
         * System parameter location; values: 'HEAD' and 'QUERY'.
         */
        in: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html).
         */
        name: string;
        /**
         * Constant parameter value.
         */
        value: string;
    }

    export interface ApiFcServiceConfig {
        /**
         * RAM role arn attached to the Function Compute service. This governs both who / what can invoke your Function, as well as what resources our Function has access to. See [User Permissions](https://www.alibabacloud.com/help/doc-detail/52885.htm) for more details.
         */
        arnRole?: string;
        /**
         * The function name of function compute service.
         */
        functionName: string;
        /**
         * The region that the function compute service belongs to.
         */
        region: string;
        /**
         * The service name of function compute service.
         */
        serviceName: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiHttpServiceConfig {
        /**
         * The address of backend service.
         */
        address: string;
        aoneName?: string;
        /**
         * The http method of backend service.
         */
        method: string;
        /**
         * The path of backend service.
         */
        path: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiHttpVpcServiceConfig {
        aoneName?: string;
        /**
         * The http method of backend service.
         */
        method: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html).
         */
        name: string;
        /**
         * The path of backend service.
         */
        path: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiMockServiceConfig {
        aoneName?: string;
        /**
         * The result of the mock service.
         */
        result: string;
    }

    export interface ApiRequestConfig {
        /**
         * The body format of the api, which support the values of 'STREAM' and 'FORM'.
         */
        bodyFormat?: string;
        /**
         * The http method of backend service.
         */
        method: string;
        /**
         * The mode of the parameters between request parameters and service parameters, which support the values of 'MAPPING' and 'PASSTHROUGH'.
         */
        mode: string;
        /**
         * The path of backend service.
         */
        path: string;
        /**
         * The protocol of api which supports values of 'HTTP','HTTPS' or 'HTTP,HTTPS'.
         */
        protocol: string;
    }

    export interface ApiRequestParameter {
        /**
         * The default value of the parameter.
         */
        defaultValue?: string;
        /**
         * The description of Constant parameter.
         */
        description?: string;
        /**
         * System parameter location; values: 'HEAD' and 'QUERY'.
         */
        in: string;
        /**
         * Backend service's parameter location; values: BODY, HEAD, QUERY, and PATH.
         */
        inService: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html).
         */
        name: string;
        /**
         * Backend service's parameter name.
         */
        nameService: string;
        /**
         * Parameter required or not; values: REQUIRED and OPTIONAL.
         */
        required: string;
        /**
         * Parameter type which supports values of 'STRING','INT','BOOLEAN','LONG',"FLOAT" and "DOUBLE".
         */
        type: string;
    }

    export interface ApiSystemParameter {
        /**
         * System parameter location; values: 'HEAD' and 'QUERY'.
         */
        in: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html).
         */
        name: string;
        /**
         * Backend service's parameter name.
         */
        nameService: string;
    }

    export interface GetApisApi {
        /**
         * API description.
         */
        description: string;
        /**
         * ID of the specified group.
         */
        groupId: string;
        /**
         * The group name that the apis belong to.
         */
        groupName: string;
        /**
         * API ID, which is generated by the system and globally unique.
         */
        id: string;
        /**
         * API name.
         */
        name: string;
        /**
         * The ID of the region where the API is located.
         */
        regionId: string;
    }

    export interface GetAppsApp {
        /**
         * App code.
         */
        appCode: string;
        /**
         * Creation time (Greenwich mean time).
         */
        createdTime: string;
        /**
         * App description.
         */
        description: string;
        /**
         * App ID, which is generated by the system and globally unique.
         */
        id: number;
        /**
         * Last modification time (Greenwich mean time).
         */
        modifiedTime: string;
        /**
         * App name.
         */
        name: string;
    }

    export interface GetGroupsGroup {
        /**
         * Billing status.
         * - NORMAL: The API group is normal.
         * - LOCKED: Locked due to outstanding payment.
         */
        billingStatus: string;
        /**
         * Creation time (Greenwich mean time).
         */
        createdTime: string;
        /**
         * API group description.
         */
        description: string;
        /**
         * API group ID, which is generated by the system and globally unique.
         */
        id: string;
        /**
         * Locking in invalid state.
         * - NORMAL: The API group is normal.
         * - LOCKED: Locked due to illegality.
         */
        illegalStatus: string;
        /**
         * Last modification time (Greenwich mean time).
         */
        modifiedTime: string;
        /**
         * API group name.
         */
        name: string;
        /**
         * The ID of the region where the API group is located.
         */
        regionId: string;
        /**
         * Second-level domain name automatically assigned to the API group.
         */
        subDomain: string;
        /**
         * Upper QPS limit of the API group; default value: 500, which can be increased by submitting an application.
         */
        trafficLimit: number;
    }

}

export namespace arms {
    export interface DispatchRuleGroupRule {
        groupId: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupInterval: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupWaitTime: number;
        /**
         * The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
         */
        groupingFields: string[];
        /**
         * The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
         */
        repeatInterval: number;
    }

    export interface DispatchRuleLabelMatchExpressionGrid {
        /**
         * Sets the dispatch rule. See the following `Block labelMatchExpressionGroups`.
         */
        labelMatchExpressionGroups: outputs.arms.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup[];
    }

    export interface DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup {
        /**
         * Sets the dispatch rule. See the following `Block labelMatchExpressions`.
         */
        labelMatchExpressions: outputs.arms.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression[];
    }

    export interface DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression {
        /**
         * The key of the tag of the dispatch rule. Valud values:
         * * _aliyun_arms_userid: user ID
         * * _aliyun_arms_involvedObject_kind: type of the associated object
         * * _aliyun_arms_involvedObject_id: ID of the associated object
         * * _aliyun_arms_involvedObject_name: name of the associated object
         * * _aliyun_arms_alert_name: alert name
         * * _aliyun_arms_alert_rule_id: alert rule ID
         * * _aliyun_arms_alert_type: alert type
         * * _aliyun_arms_alert_level: alert severity
         */
        key: string;
        /**
         * The operator used in the dispatch rule. Valid values: 
         * * eq: equals to.
         * * re: matches a regular expression.
         */
        operator: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface DispatchRuleNotifyRule {
        /**
         * The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
         */
        notifyChannels: string[];
        /**
         * Sets the notification object. See the following `Block notifyObjects`.
         */
        notifyObjects: outputs.arms.DispatchRuleNotifyRuleNotifyObject[];
    }

    export interface DispatchRuleNotifyRuleNotifyObject {
        /**
         * The name of the contact or contact group.
         */
        name: string;
        /**
         * The ID of the contact or contact group.
         */
        notifyObjectId: string;
        /**
         * The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
         */
        notifyType: string;
    }

    export interface GetAlertContactGroupsGroup {
        /**
         * The first ID of the resource.
         */
        alertContactGroupId: string;
        /**
         * The name of the resource.
         */
        alertContactGroupName: string;
        /**
         * contact ids.
         */
        contactIds: string[];
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Alert Contact Group.
         */
        id: string;
    }

    export interface GetAlertContactsContact {
        /**
         * Contact ID.
         */
        alertContactId: string;
        /**
         * The name of the alert contact.
         */
        alertContactName: string;
        /**
         * The Creation Time Timestamp.
         */
        createTime: string;
        /**
         * The webhook URL of the DingTalk chatbot.
         */
        dingRobotWebhookUrl: string;
        /**
         * The email address of the alert contact.
         */
        email: string;
        /**
         * The ID of the Alert Contact.
         */
        id: string;
        /**
         * The mobile number of the alert contact.
         */
        phoneNum: string;
        /**
         * Specifies whether the alert contact receives system notifications.
         */
        systemNoc: boolean;
        /**
         * Webhook Information.
         */
        webhook: string;
    }

    export interface GetDispatchRulesRule {
        /**
         * Dispatch rule ID.
         */
        dispatchRuleId: string;
        /**
         * The name of the dispatch rule.
         */
        dispatchRuleName: string;
        dispatchType: string;
        /**
         * Sets the event group.
         */
        groupRules: outputs.arms.GetDispatchRulesRuleGroupRule[];
        /**
         * The ID of the Dispatch Rule.
         */
        id: string;
        /**
         * Sets the dispatch rule.
         */
        labelMatchExpressionGrids: outputs.arms.GetDispatchRulesRuleLabelMatchExpressionGrid[];
        /**
         * Sets the notification rule.
         */
        notifyRules: outputs.arms.GetDispatchRulesRuleNotifyRule[];
        /**
         * The resource status of Alert Dispatch Rule.
         */
        status: string;
    }

    export interface GetDispatchRulesRuleGroupRule {
        groupId: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupInterval: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupWaitTime: number;
        /**
         * The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
         */
        groupingFields: string[];
        /**
         * The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
         */
        repeatInterval: number;
    }

    export interface GetDispatchRulesRuleLabelMatchExpressionGrid {
        /**
         * Sets the dispatch rule.
         */
        labelMatchExpressionGroups: outputs.arms.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroup[];
    }

    export interface GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroup {
        /**
         * Sets the dispatch rule.
         */
        labelMatchExpressions: outputs.arms.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression[];
    }

    export interface GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression {
        /**
         * The key of the tag of the dispatch rule.
         */
        key: string;
        /**
         * The operator used in the dispatch rule.
         */
        operator: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface GetDispatchRulesRuleNotifyRule {
        /**
         * The notification method.
         */
        notifyChannels: string[];
        /**
         * Sets the notification object.
         */
        notifyObjects: outputs.arms.GetDispatchRulesRuleNotifyRuleNotifyObject[];
    }

    export interface GetDispatchRulesRuleNotifyRuleNotifyObject {
        /**
         * The name of the contact or contact group.
         */
        name: string;
        /**
         * The ID of the contact or contact group.
         */
        notifyObjectId: string;
        /**
         * The type of the alert contact.
         */
        notifyType: string;
    }

    export interface GetPrometheusAlertRulesRule {
        /**
         * The annotations of the alert rule.
         */
        annotations: outputs.arms.GetPrometheusAlertRulesRuleAnnotation[];
        /**
         * The ID of the cluster.
         */
        clusterId: string;
        /**
         * The ID of the notification policy. This parameter is required when the `notifyType` parameter is set to `DISPATCH_RULE`.
         */
        dispatchRuleId: string;
        /**
         * -The duration of the alert.
         */
        duration: string;
        /**
         * The alert rule expression that follows the PromQL syntax..
         */
        expression: string;
        /**
         * The ID of the Prometheus Alert Rule.
         */
        id: string;
        /**
         * -The labels of the resource.
         */
        labels: outputs.arms.GetPrometheusAlertRulesRuleLabel[];
        /**
         * The message of the alert notification.
         */
        message: string;
        /**
         * The method of sending the alert notification. Valid values: `ALERT_MANAGER`, `DISPATCH_RULE`.
         */
        notifyType: string;
        /**
         * The first ID of the resource.
         */
        prometheusAlertRuleId: string;
        /**
         * The name of the resource.
         */
        prometheusAlertRuleName: string;
        /**
         * The status of the resource. Valid values: `0`, `1`.
         * * `1`: open.
         * * `0`: off.
         */
        status: number;
        /**
         * The type of the alert rule.
         */
        type: string;
    }

    export interface GetPrometheusAlertRulesRuleAnnotation {
        /**
         * The name of the label.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface GetPrometheusAlertRulesRuleLabel {
        /**
         * The name of the label.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface PrometheusAlertRuleAnnotation {
        /**
         * The name of the annotation.
         */
        name?: string;
        /**
         * The value of the annotation.
         */
        value?: string;
    }

    export interface PrometheusAlertRuleLabel {
        /**
         * The name of the annotation.
         */
        name?: string;
        /**
         * The value of the annotation.
         */
        value?: string;
    }

}

export namespace bastionhost {
    export interface GetHostAccountsAccount {
        /**
         * Whether to set a new password.
         */
        hasPassword: boolean;
        /**
         * Hosting account ID.
         */
        hostAccountId: string;
        /**
         * Specify the new hosting account's name, support the longest 128 characters.
         */
        hostAccountName: string;
        /**
         * Specifies the database where you want to create your hosting account's host ID.
         */
        hostId: string;
        /**
         * The ID of the Host Account.
         */
        id: string;
        /**
         * Specifies the database where you want to create your hosting account's host bastion host ID of.
         */
        instanceId: string;
        /**
         * The situation where the private keys of the fingerprint information.
         */
        privateKeyFingerprint: string;
        /**
         * Specify the new hosting account of the agreement name. Valid values: USING SSH and RDP.
         */
        protocolName: string;
    }

    export interface GetHostGroupsGroup {
        /**
         * Specify the New Host Group of Notes, Supports up to 500 Characters.
         */
        comment: string;
        /**
         * Host Group ID.
         */
        hostGroupId: string;
        /**
         * Specify the New Host Group Name, Supports up to 128 Characters.
         */
        hostGroupName: string;
        /**
         * The ID of the Host Group.
         */
        id: string;
        /**
         * Specify the New Host Group Where the Bastion Host ID of.
         */
        instanceId: string;
    }

    export interface GetHostsHost {
        /**
         * Specify the new create a host of address types. Valid values: Public: the IP address of a Public network Private: Private network address.
         */
        activeAddressType: string;
        /**
         * Specify a host of notes, supports up to 500 characters.
         */
        comment: string;
        /**
         * The host ID.
         */
        hostId: string;
        /**
         * Specify the new create a host name of the supports up to 128 characters.
         */
        hostName: string;
        /**
         * Specify the new create a host of the private network address, it is possible to use the domain name or IP ADDRESS.
         */
        hostPrivateAddress: string;
        /**
         * Specify the new create a host of the IP address of a public network, it is possible to use the domain name or IP ADDRESS.
         */
        hostPublicAddress: string;
        /**
         * The ID of the Host.
         */
        id: string;
        /**
         * Specify the new create a host where the Bastion host ID of.
         */
        instanceId: string;
        /**
         * Specify the new create the host's operating system. Valid values: Linux Windows.
         */
        osType: string;
        /**
         * The host of the protocol information.
         */
        protocols: outputs.bastionhost.GetHostsHostProtocol[];
        /**
         * Specify the new create a host of source. Valid values: Local: localhost Ecs:ECS instance Rds:RDS exclusive cluster host.
         */
        source: string;
        /**
         * Specify the newly created ECS instance ID or dedicated cluster host ID.
         */
        sourceInstanceId: string;
    }

    export interface GetHostsHostProtocol {
        /**
         * Host fingerprint information, it is possible to uniquely identify a host.
         */
        hostFingerPrint: string;
        /**
         * Host the service port of the RDS.
         */
        port: number;
        /**
         * The host uses the protocol name.
         */
        protocolName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The instance's remark.
         */
        description: string;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's status.
         */
        instanceStatus: string;
        licenseCode: string;
        /**
         * The instance's private domain name.
         */
        privateDomain: string;
        /**
         * The instance's public domain name.
         */
        publicDomain: string;
        /**
         * The instance's public network access configuration.
         */
        publicNetworkAccess: boolean;
        /**
         * The instance's security group configuration.
         */
        securityGroupIds: string[];
        /**
         * A map of tags assigned to the bastionhost instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instance = pulumi.output(alicloud.bastionhost.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *     },
         * }));
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * The instance's vSwitch ID.
         */
        userVswitchId: string;
    }

    export interface GetUserGroupsGroup {
        /**
         * Specify the New Group of Remark Information. Supports up to 500 Characters.
         */
        comment: string;
        /**
         * The ID of the User Group.
         */
        id: string;
        /**
         * Specify the New Group of the Bastion Host of Instance Id.
         */
        instanceId: string;
        /**
         * The User Group ID.
         */
        userGroupId: string;
        /**
         * Specify the New Group Name. Supports up to 128 Characters.
         */
        userGroupName: string;
    }

    export interface GetUsersUser {
        /**
         * Specify the New of the User That Created the Remark Information. Supports up to 500 Characters.
         */
        comment: string;
        /**
         * Specify the New Created the User's Display Name. Supports up to 128 Characters.
         */
        displayName: string;
        /**
         * Specify the New User's Mailbox.
         */
        email: string;
        /**
         * The ID of the User.
         */
        id: string;
        /**
         * You Want to Query the User the Bastion Host ID of.
         */
        instanceId: string;
        /**
         * Specify the New of the User That Created a Different Mobile Phone Number from Your.
         */
        mobile: string;
        /**
         * Specify the New Create User Mobile Phone Number of the International Domain Name. The Default Value Is the CN Value: CN: Mainland China (+86) HK: hong Kong, China (+852) Mo: Macau, China (+853) TW: Taiwan, China (+886) ru: Russian (+7) SG: Singapore (+65) My: malaysia (+60) ID: Indonesia (+62) De: Germany (+49) AU: Australia (+61) US: United States (+1) AE: dubai (+971) JP: Japan (+81) Introducing the Long-Range GB: United Kingdom (+44) in: India (+91) KR: South Korea (+82) Ph: philippines (+63) Ch: Switzerland (+41) Se: Sweden (+46).
         */
        mobileCountryCode: string;
        /**
         * Specify the New of the User That Created the Source. Valid Values: Local: Local User RAM: Ram User.
         */
        source: string;
        /**
         * Specify the Newly Created User Is Uniquely Identified. Indicates That the Parameter Is a Bastion Host Corresponding to the User with the Ram User's Unique Identifier. The Newly Created User Source Grant Permission to a RAM User (That Is, Source Used as a Ram), this Parameter Is Required. You Can Call Access Control of Listusers Interface from the Return Data Userid to Obtain the Parameters.
         */
        sourceUserId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The User ID.
         */
        userId: string;
        /**
         * Specify the New User Name. This Parameter Is Only by Letters, Lowercase Letters, Numbers, and Underscores (_), Supports up to 128 Characters.
         */
        userName: string;
    }

}

export namespace brain {
    export interface GetIndustrialPidLoopsLoop {
        /**
         * The ID of the Pid Loop.
         */
        id: string;
        pidLoopConfiguration: string;
        /**
         * The dcs type of Pid Loop.
         */
        pidLoopDcsType: string;
        pidLoopDesc: string;
        /**
         * The ID of the Pid Loop.
         */
        pidLoopId: string;
        /**
         * Whether is crucial Pid Loop.
         */
        pidLoopIsCrucial: boolean;
        /**
         * The name of Pid Loop.
         */
        pidLoopName: string;
        /**
         * The type of Pid Loop.
         */
        pidLoopType: string;
        /**
         * The pid project id.
         */
        pidProjectId: string;
        /**
         * The status of Pid Loop.
         */
        status: string;
    }

    export interface GetIndustrialPidOrganizationsOrganization {
        /**
         * The ID of the Pid Organization.
         */
        id: string;
        /**
         * The parent organization id.
         */
        parentPidOrganizationId: string;
        /**
         * The organization id.
         */
        pidOrganizationId: string;
        /**
         * The organization level.
         */
        pidOrganizationLevel: number;
        /**
         * The organization name.
         */
        pidOrganizationName: string;
    }

    export interface GetIndustrialPidProjectsProject {
        /**
         * The ID of the Pid Project.
         */
        id: string;
        /**
         * The ID of Pid Organization.
         */
        pidOrganizationId: string;
        /**
         * The description of Pid Project.
         */
        pidProjectDesc: string;
        /**
         * The ID of Pid Project.
         */
        pidProjectId: string;
        /**
         * The name of Pid Project.
         */
        pidProjectName: string;
    }

}

export namespace cas {
    export interface GetCertificatesCertificate {
        /**
         * The cert is buy from aliyun or not.
         */
        buyInAliyun: boolean;
        cert: string;
        certId: string;
        certificateName: string;
        /**
         * The cert's city.
         */
        city: string;
        /**
         * The cert's common name.
         */
        common: string;
        /**
         * The cert's country.
         */
        country: string;
        /**
         * The cert's not valid after time.
         */
        endDate: string;
        /**
         * The cert is expired or not.
         */
        expired: boolean;
        fingerprint: string;
        /**
         * The cert's id.
         */
        id: string;
        /**
         * The cert's .
         */
        issuer: string;
        key: string;
        /**
         * The cert's name.
         *
         * @deprecated Field 'name' has been deprecated from provider version 1.129.0 and it will be remove in the future version. Please use the new attribute 'certificate_name' instead.
         */
        name: string;
        /**
         * The cert's organization.
         */
        orgName: string;
        /**
         * The cert's province.
         */
        province: string;
        /**
         * The cert's subject alternative name.
         */
        sans: string;
        /**
         * The cert's not valid before time.
         */
        startDate: string;
    }

    export interface GetServiceCertificatesCertificate {
        /**
         * The cert is buy from aliyun or not.
         */
        buyInAliyun: boolean;
        /**
         * The cert's Cert.
         */
        cert: string;
        /**
         * The cert's id.
         */
        certId: string;
        /**
         * The cert's name.
         */
        certificateName: string;
        /**
         * The cert's city.
         */
        city: string;
        /**
         * The cert's common name.
         */
        common: string;
        /**
         * The cert's country.
         */
        country: string;
        /**
         * The cert's not valid after time.
         */
        endDate: string;
        /**
         * The cert is expired or not.
         */
        expired: boolean;
        /**
         * The cert's finger.
         */
        fingerprint: string;
        /**
         * The cert's id.
         */
        id: string;
        /**
         * The cert's Issuer.
         */
        issuer: string;
        /**
         * The cert's Keye.
         */
        key: string;
        /**
         * @deprecated Field 'name' has been deprecated from provider version 1.129.0 and it will be remove in the future version. Please use the new attribute 'certificate_name' instead.
         */
        name: string;
        /**
         * The cert's organization.
         */
        orgName: string;
        /**
         * The cert's province.
         */
        province: string;
        /**
         * The cert's subject alternative name.
         */
        sans: string;
        /**
         * The cert's not valid before time.
         */
        startDate: string;
    }

}

export namespace cassandra {
    export interface GetBackupPlansPlan {
        /**
         * Specifies whether to activate the backup plan.
         */
        active: boolean;
        /**
         * The backup cycle. Valid values: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, and Sunday.
         */
        backupPeriod: string;
        /**
         * The start time of the backup task each day. The time is displayed in UTC and denoted by Z.
         */
        backupTime: string;
        /**
         * The ID of the cluster for the backup.
         */
        clusterId: string;
        /**
         * The time when the backup plan was created.
         */
        createTime: string;
        /**
         * The ID of the data center for the backup in the cluster.
         */
        dataCenterId: string;
        /**
         * The ID of the Backup Plan.
         */
        id: string;
        /**
         * The duration for which you want to retain the backup. Valid values: 1 to 30. Unit: days.
         */
        retentionPeriod: number;
    }

    export interface GetClustersCluster {
        /**
         * The ID of the Cassandra cluster.
         */
        clusterId: string;
        /**
         * The name of the Cassandra cluster.
         */
        clusterName: string;
        createdTime: string;
        /**
         * The count of data centers
         */
        dataCenterCount: number;
        /**
         * The expire time of the cluster.
         */
        expireTime: string;
        /**
         * The ID of the Cassandra cluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The major version of the cluster.
         */
        majorVersion: string;
        /**
         * The minor version of the cluster.
         */
        minorVersion: string;
        /**
         * Billing method. Value options are `Subscription` for Pay-As-You-Go and `PayAsYouGo` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Status of the cluster.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetDataCentersCenter {
        /**
         * The cluster id of dataCenters belongs to.
         */
        clusterId: string;
        /**
         * The commodity ID of the Cassandra dataCenter.
         */
        commodityInstance: string;
        createdTime: string;
        /**
         * The id of the Cassandra dataCenter.
         */
        dataCenterId: string;
        /**
         * The name of the Cassandra dataCenter.
         */
        dataCenterName: string;
        /**
         * One node disk size, unit:GB.
         */
        diskSize: number;
        /**
         * Cloud_ssd or cloud_efficiency.
         */
        diskType: string;
        /**
         * The expire time of the dataCenter.
         */
        expireTime: string;
        /**
         * The instance type of the Cassandra dataCenter, eg: cassandra.c.large.
         */
        instanceType: string;
        /**
         * The lock mode of the dataCenter.
         */
        lockMode: string;
        /**
         * The node count of dataCenter.
         */
        nodeCount: number;
        /**
         * Billing method. Value options are `Subscription` for Pay-As-You-Go and `PayAsYouGo` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Status of the dataCenter.
         */
        status: string;
        /**
         * VPC ID the dataCenter belongs to.
         */
        vpcId: string;
        /**
         * VSwitch ID the dataCenter belongs to.
         */
        vswitchId: string;
        /**
         * Zone ID the dataCenter belongs to.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace cddc {
    export interface GetDedicatedHostAccountsAccount {
        /**
         * The name of the Dedicated host account.
         */
        accountName: string;
        /**
         * The ID of the Dedicated host.
         */
        dedicatedHostId: string;
        /**
         * The ID of the Dedicated Host Account. The value formats as `<dedicated_host_id>:<account_name>`.
         */
        id: string;
    }

    export interface GetDedicatedHostGroupsGroup {
        /**
         * The policy that is used to allocate resources in the dedicated cluster. Valid values:`Evenly`,`Intensively`
         */
        allocationPolicy: string;
        /**
         * The Bastion Instance id of the Dedicated Host Group.
         */
        bastionInstanceId: string;
        /**
         * The CPU overcommitment ratio of the dedicated cluster. If you set this parameter to 200, the CPU resources that can be allocated are twice as many as the CPU resources that are provided. This maximizes the CPU utilization. Valid values: 100 to 300. Default value: 200.
         */
        cpuAllocateRation: number;
        /**
         * The CPU Allocated Amount of the Dedicated Host Group.
         */
        cpuAllocatedAmount: number;
        /**
         * The CPU overcommitment ratio of the dedicated cluster.Valid values: 100 to 300. Default value: 200.
         */
        cpuAllocationRatio: number;
        /**
         * The Created Time of the Dedicated Host Group.
         */
        createTime: string;
        /**
         * The Dedicated Host Count Group by Host Type of the Dedicated Host Group.
         */
        dedicatedHostCountGroupByHostTypes: outputs.cddc.GetDedicatedHostGroupsGroupDedicatedHostCountGroupByHostType[];
        /**
         * -The name of the dedicated cluster. The name must be 1 to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-). It must start with a letter.
         */
        dedicatedHostGroupDesc: string;
        /**
         * Dedicated Host Group ID.
         */
        dedicatedHostGroupId: string;
        /**
         * The Deployment Type of the Dedicated Host Group.
         */
        deployType: string;
        /**
         * The storage overcommitment ratio of the dedicated cluster.Valid values: 100 to 300. Default value: 200.
         */
        diskAllocateRation: number;
        /**
         * The Disk Allocated Amount of the Dedicated Host Group.
         */
        diskAllocatedAmount: number;
        /**
         * The Disk Allocation Ratio of the Dedicated Host Group.
         */
        diskAllocationRatio: number;
        /**
         * The DiskUsedAmount of the Dedicated Host Group.
         */
        diskUsedAmount: number;
        /**
         * The DiskUtility of the Dedicated Host Group.
         */
        diskUtility: number;
        /**
         * Database Engine Type.The database engine of the dedicated cluster. Valid values:`Redis`, `SQLServer`, `MySQL`, `PostgreSQL`, `MongoDB`
         */
        engine: string;
        /**
         * The Total Host Number  of the Dedicated Host Group.
         */
        hostNumber: number;
        /**
         * The policy based on which the system handles host failures. Valid values:`Auto`,`Manual`
         */
        hostReplacePolicy: string;
        /**
         * The ID of the Dedicated Host Group.
         */
        id: string;
        /**
         * The Total Instance Number of the Dedicated Host Group.
         */
        instanceNumber: number;
        /**
         * The maximum memory usage of each host in the dedicated cluster.Valid values: 0 to 90. Default value: 90.
         */
        memAllocateRation: number;
        /**
         * The MemAllocatedAmount of the Dedicated Host Group.
         */
        memAllocatedAmount: number;
        /**
         * The Memory Allocation Ratio of the Dedicated Host Group.
         */
        memAllocationRatio: number;
        /**
         * The MemUsedAmount of the Dedicated Host Group.
         */
        memUsedAmount: number;
        /**
         * The Mem Utility of the Dedicated Host Group.
         */
        memUtility: number;
        /**
         * The Text of the Dedicated Host Group.
         */
        text: string;
        /**
         * The virtual private cloud (VPC) ID of the dedicated cluster.
         */
        vpcId: string;
        /**
         * The ZoneIDList of the Dedicated Host Group.
         */
        zoneIdLists: outputs.cddc.GetDedicatedHostGroupsGroupZoneIdList[];
    }

    export interface GetDedicatedHostGroupsGroupDedicatedHostCountGroupByHostType {
        placeHolder: string;
    }

    export interface GetDedicatedHostGroupsGroupZoneIdList {
        /**
         * The ZoneIDList of the Dedicated Host Group.
         */
        zoneIdLists: string[];
    }

    export interface GetDedicatedHostsHost {
        /**
         * Specifies whether instances can be created on the host. Valid values: `1` or `0`. `1`: Instances can be created on the host. `0`: Instances cannot be created on the host.
         */
        allocationStatus: string;
        /**
         * The ID of the bastion host with which the host is associated.
         */
        bastionInstanceId: string;
        /**
         * The numeric value of the CPU over commit ratio of the dedicated cluster.
         */
        cpuAllocationRatio: string;
        /**
         * The number of CPU cores used by the host.
         */
        cpuUsed: string;
        /**
         * The time when the host was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The ID of the dedicated cluster in which the host is created.
         */
        dedicatedHostGroupId: string;
        /**
         * The ID of the host.
         */
        dedicatedHostId: string;
        /**
         * The disk usage in percentage.
         */
        diskAllocationRatio: string;
        /**
         * The Elastic Compute Service (ECS) instance type.
         */
        ecsClassCode: string;
        /**
         * The time when the host expires. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        endTime: string;
        /**
         * The type of the database engine that is used by the host.
         */
        engine: string;
        /**
         * The time when the host expires. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        expiredTime: string;
        /**
         * The instance type of the host.
         */
        hostClass: string;
        /**
         * The number of CPU cores specified for the host. Unit: `core`.
         */
        hostCpu: string;
        /**
         * The memory of the host. Unit: `GB`.
         */
        hostMem: string;
        /**
         * The name of the host.
         */
        hostName: string;
        /**
         * The total storage capacity of the host. Unit: `GB`.
         */
        hostStorage: string;
        /**
         * The storage type of the host.
         */
        hostType: string;
        /**
         * The ID of the Dedicated Host. The value formats as `<dedicated_host_group_id>:<dedicated_host_id>`.
         */
        id: string;
        /**
         * The image type of the host.
         */
        imageCategory: string;
        /**
         * The IP address of the host.
         */
        ipAddress: string;
        /**
         * The memory usage in percentage.
         */
        memAllocationRatio: string;
        /**
         * The amount of memory used by the host. Unit: `GB`.
         */
        memoryUsed: string;
        /**
         * Indicates whether you have the OS permissions on the host. Valid values: `0`: You do not have the OS permissions on the host. `1`: You have the OS permissions on the host.
         */
        openPermission: string;
        /**
         * The state of the host.
         */
        status: string;
        /**
         * The storage usage of the host. Unit: `GB`.
         */
        storageUsed: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the virtual private cloud (VPC) to which the host is connected.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch.
         */
        vswitchId: string;
        /**
         * The zone ID of the host.
         */
        zoneId: string;
    }

    export interface GetHostEcsLevelInfosInfo {
        /**
         * The description of the host ecs level info.
         */
        description: string;
        /**
         * The instance family of the host ecs level info.
         */
        ecsClass: string;
        /**
         * The Elastic Compute Service (ECS) instance type.
         */
        ecsClassCode: string;
        /**
         * The ApsaraDB RDS instance type of the host ecs level info.
         */
        resClassCode: string;
    }

    export interface GetZonesZone {
        /**
         * The ID of the zone.
         */
        id: string;
        /**
         * The ID of the region.
         */
        regionId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

}

export namespace cdn {
    export interface DomainAuthConfig {
        /**
         * Auth type of the auth config. Valid values are  `noAuth`, `typeA`, `typeB` and `typeC`. Default value is `noAuth`.
         */
        authType?: string;
        /**
         * Master authentication key of the auth config. This parameter can have a string of 6 to 32 characters and must contain only alphanumeric characters.
         */
        masterKey: string;
        /**
         * Slave authentication key of the auth config. This parameter can have a string of 6 to 32 characters and must contain only alphanumeric characters.
         */
        slaveKey: string;
        /**
         * Authentication cache time of the auth config. Default value is `1800`. It's value is valid only when the `authType` is `typeB` or `typeC`.
         */
        timeout?: number;
    }

    export interface DomainCacheConfig {
        /**
         * Cache content of the cache config. It's value is a path string when the `cacheType` is `path`. When the `cacheType` is `suffix`, it's value is a string which contains multiple file suffixes separated by commas.
         */
        cacheContent: string;
        cacheId: string;
        /**
         * Cache type of the cache config. Valid values are `suffix` and `path`.
         */
        cacheType: string;
        /**
         * Cache time of the cache config.
         */
        ttl: number;
        /**
         * Weight of the cache config. This parameter's value is between 1 and 99. Default value is `1`. The higher the value, the higher the priority.
         */
        weight?: number;
    }

    export interface DomainCertificateConfig {
        /**
         * The SSL private key. This is required if `serverCertificateStatus` is `on`
         */
        privateKey?: string;
        /**
         * The SSL server certificate string. This is required if `serverCertificateStatus` is `on`
         */
        serverCertificate?: string;
        /**
         * This parameter indicates whether or not enable https. Valid values are `on` and `off`. Default value is `on`.
         */
        serverCertificateStatus?: string;
    }

    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainHttpHeaderConfig {
        headerId: string;
        /**
         * Header key of the http header. Valid values are `Content-Type`, `Cache-Control`, `Content-Disposition`, `Content-Language`，`Expires`, `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods` and `Access-Control-Max-Age`.
         */
        headerKey: string;
        /**
         * Header value of the http header.
         */
        headerValue: string;
    }

    export interface DomainNewCertificateConfig {
        /**
         * The SSL certificate name.
         */
        certName?: string;
        /**
         * The SSL certificate type, can be "upload", "cas" and "free".
         */
        certType?: string;
        /**
         * Set `1` to ignore the repeated verification for certificate name, and cover the information of the origin certificate (with the same name). Set `0` to work the verification.
         */
        forceSet?: string;
        /**
         * The SSL private key. This is required if `serverCertificateStatus` is `on`
         */
        privateKey?: string;
        /**
         * The SSL server certificate string. This is required if `serverCertificateStatus` is `on`
         */
        serverCertificate?: string;
        /**
         * This parameter indicates whether or not enable https. Valid values are `on` and `off`. Default value is `on`.
         */
        serverCertificateStatus?: string;
    }

    export interface DomainNewSource {
        /**
         * The address of source. Valid values can be ip or doaminName. Each item's `content` can not be repeated.
         */
        content: string;
        /**
         * The port of source. Valid values are `443` and `80`. Default value is `80`.
         */
        port?: number;
        /**
         * Priority of the source. Valid values are `0` and `100`. Default value is `20`.
         */
        priority?: number;
        /**
         * The type of the source. Valid values are `ipaddr`, `domain` and `oss`.
         */
        type: string;
        /**
         * Weight of the source. Valid values are from `0` to `100`. Default value is `10`, but if type is `ipaddr`, the value can only be `10`.
         */
        weight?: number;
    }

    export interface DomainPage404Config {
        /**
         * Custom page url of the error page. It must be the full path under the accelerated domain name. It's value must be `http://promotion.alicdn.com/help/oss/error.html` when `pageType` value is `charity` and It can not be set when `pageType` value is `default`.
         */
        customPageUrl?: string;
        errorCode: string;
        /**
         * Page type of the error page. Valid values are `default`, `charity`, `other`. Default value is `default`.
         */
        pageType?: string;
    }

    export interface DomainParameterFilterConfig {
        /**
         * This parameter indicates whether or not the `parameterFilterConfig` is enable. Valid values are `on` and `off`. Default value is `off`.
         */
        enable?: string;
        /**
         * Reserved parameters of `parameterFilterConfig`. It's a list of string and consists of at most 10 items.
         */
        hashKeyArgs: string[];
    }

    export interface DomainReferConfig {
        /**
         * This parameter indicates whether or not to allow empty refer access. Valid values are `on` and `off`. Default value is `on`.
         */
        allowEmpty?: string;
        /**
         * A list of domain names of the refer config.
         */
        referLists: string[];
        /**
         * Refer type of the refer config. Valid values are `block` and `allow`. Default value is `block`.
         */
        referType?: string;
    }

    export interface GetRealTimeLogDeliveriesDelivery {
        /**
         * Real-Time Log Service Domain.
         */
        domain: string;
        /**
         * The ID of the Real Time Log Delivery.
         */
        id: string;
        /**
         * The name of the Logstore that collects log data from Alibaba Cloud Content Delivery Network (CDN) in real time.
         */
        logstore: string;
        /**
         * The name of the Log Service project that is used for real-time log delivery.
         */
        project: string;
        /**
         * The region where the Log Service project is deployed.
         */
        slsRegion: string;
        /**
         * -The status of the real-time log delivery feature. Valid Values: `online` and `offline`.
         */
        status: string;
    }

}

export namespace cen {
    export interface GetBandwidthLimitsLimit {
        /**
         * The bandwidth limit configured for the interconnected regions communication.
         */
        bandwidthLimit: number;
        /**
         * ID of the CEN instance.
         */
        instanceId: string;
        /**
         * ID of local region.
         */
        localRegionId: string;
        /**
         * ID of opposite region.
         */
        oppositeRegionId: string;
        /**
         * Status of the CEN Bandwidth Limit, including "Active" and "Modifying".
         */
        status: string;
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth in Mbps of the CEN bandwidth package.
         */
        bandwidth: number;
        /**
         * The billing method, including `POSTPAY` and `PREPAY`.
         */
        bandwidthPackageChargeType: string;
        /**
         * Status of the CEN Bandwidth Package, including `Normal`, `FinancialLocked` and `SecurityLocked`.
         */
        businessStatus: string;
        /**
         * The ID of the bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The name of the bandwidth package.
         */
        cenBandwidthPackageName: string;
        /**
         * The list of CEN instances that are associated with the bandwidth package.
         */
        cenIds: string[];
        /**
         * Description of the CEN Bandwidth Package.
         */
        description: string;
        expiredTime: string;
        /**
         * Region ID of the interconnected regions.
         */
        geographicRegionAId: string;
        /**
         * Region ID of the interconnected regions.
         */
        geographicRegionBId: string;
        /**
         * The area ID of the cross-area connection.
         */
        geographicSpanId: string;
        /**
         * Indicates whether renewal data is involved.
         */
        hasReservationData: string;
        /**
         * ID of the CEN Bandwidth Package.
         */
        id: string;
        /**
         * ID of a CEN instance.
         */
        instanceId: string;
        /**
         * Indicates whether the bandwidth package is a cross-border bandwidth package.
         */
        isCrossBorder: boolean;
        /**
         * Name of the CEN Bandwidth Package.
         */
        name: string;
        /**
         * The billing method of the bandwidth package.
         */
        paymentType: string;
        /**
         * The expiration time of the temporary upgrade.
         */
        reservationActiveTime: string;
        /**
         * The restored bandwidth after the temporary upgrade.
         */
        reservationBandwidth: string;
        /**
         * The billing method after the configuration change.
         */
        reservationInternetChargeType: string;
        /**
         * The type of the configuration change.
         */
        reservationOrderType: string;
        /**
         * Status of the CEN Bandwidth Package in CEN instance, Valid value: `Idle` and `InUse`.
         */
        status: string;
    }

    export interface GetFlowlogsFlowlog {
        /**
         * The ID of the CEN Instance.
         */
        cenId: string;
        /**
         * The description of flowlog.
         */
        description: string;
        /**
         * ID of the CEN flow log.
         */
        flowLogId: string;
        /**
         * The name of flowlog.
         */
        flowLogName: string;
        /**
         * ID of the CEN flow log.
         */
        id: string;
        /**
         * The name of the log store which is in the  `projectName` SLS project.
         */
        logStoreName: string;
        /**
         * The name of the SLS project.
         */
        projectName: string;
        /**
         * The status of flowlog. Valid values: ["Active", "Inactive"]. Default to "Active".
         */
        status: string;
    }

    export interface GetInstanceAttachmentsAttachment {
        /**
         * The time when the network is associated with the CEN instance.
         */
        childInstanceAttachTime: string;
        /**
         * The ID of the network.
         */
        childInstanceId: string;
        /**
         * The ID of the account to which the network belongs.
         */
        childInstanceOwnerId: number;
        /**
         * The region to which the network to be queried belongs.
         */
        childInstanceRegionId: string;
        /**
         * The type of the associated network. Valid values: `VPC`, `VBR` and `CCN`.
         */
        childInstanceType: string;
        /**
         * The ID of the CEN Instance Attachment.
         */
        id: string;
        /**
         * The ID of the CEN instance.
         */
        instanceId: string;
        /**
         * The status of the Cen Child Instance Attachment. Valid value: `Attaching`, `Attached` and `Aetaching`.
         */
        status: string;
    }

    export interface GetInstancesInstance {
        /**
         * List of CEN Bandwidth Package IDs in the specified CEN instance.
         */
        cenBandwidthPackageIds: string[];
        /**
         * ID of the CEN instance.
         */
        cenId: string;
        /**
         * Name of the CEN instance.
         */
        cenInstanceName: string;
        /**
         * The creation time of the CEN Instance.
         */
        createTime: string;
        /**
         * Description of the CEN instance.
         */
        description: string;
        /**
         * ID of the CEN instance.
         */
        id: string;
        /**
         * Name of the CEN instance.
         */
        name: string;
        /**
         * Indicates the allowed level of CIDR block overlapping.
         */
        protectionLevel: string;
        /**
         * The status of CEN instance. Valid value: `Active`, `Creating` and `Deleting`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetPrivateZonesZone {
        /**
         * The access region. The access region is the region of the cloud resource that accesses the PrivateZone service through CEN.
         */
        accessRegionId: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The service region. The service region is the target region of the PrivateZone service accessed through CEN.
         */
        hostRegionId: string;
        /**
         * The VPC that belongs to the service region.
         */
        hostVpcId: string;
        /**
         * The DNS IP addresses of the PrivateZone service.
         */
        privateZoneDnsServers: string;
        /**
         * The status of the PrivateZone service, including `Creating`, `Active` and `Deleting`.
         */
        status: string;
    }

    export interface GetRegionRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry.
         */
        cidrBlock: string;
        /**
         * ID of the next hop.
         */
        nextHopId: string;
        /**
         * ID of the region where the next hop is located.
         */
        nextHopRegionId: string;
        /**
         * Type of the next hop.
         */
        nextHopType: string;
        /**
         * Type of the route entry.
         */
        type: string;
    }

    export interface GetRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry to query.
         */
        cidrBlock: string;
        /**
         * A list of conflicted Route Entries. Each element contains the following attributes:
         */
        conflicts: outputs.cen.GetRouteEntriesEntryConflict[];
        /**
         * ID of the next hop.
         */
        nextHopId: string;
        /**
         * Type of the next hop, including "Instance", "HaVip" and "RouterInterface".
         */
        nextHopType: string;
        /**
         * Whether to allow the route entry to be published or removed to or from CEN.
         */
        operationalMode: boolean;
        /**
         * The publish status of the route entry in CEN, including "Published" and "NonPublished".
         */
        publishStatus: string;
        /**
         * ID of the route table of the VPC or VBR.
         */
        routeTableId: string;
        /**
         * Type of the route entry, including "System", "Custom" and "BGP".
         */
        routeType: string;
    }

    export interface GetRouteEntriesEntryConflict {
        /**
         * The destination CIDR block of the route entry to query.
         */
        cidrBlock: string;
        /**
         * ID of the CEN instance.
         */
        instanceId: string;
        /**
         * The type of the CEN child instance.
         */
        instanceType: string;
        /**
         * ID of the region where the conflicted route entry is located.
         */
        regionId: string;
        /**
         * Reasons of exceptions.
         */
        status: string;
    }

    export interface GetRouteMapsMap {
        /**
         * A match statement. It indicates the mode in which the as-path attribute is matched.
         */
        asPathMatchMode: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The ID of the region to which the CEN instance belongs.
         */
        cenRegionId: string;
        /**
         * A match statement. It indicates the mode in which the prefix attribute is matched.
         */
        cidrMatchMode: string;
        /**
         * A match statement. It indicates the mode in which the community attribute is matched.
         */
        communityMatchMode: string;
        /**
         * An action statement. It indicates the mode in which the community attribute is operated.
         */
        communityOperateMode: string;
        /**
         * The description of the route map.
         */
        description: string;
        /**
         * A match statement that indicates the list of IDs of the destination instances.
         */
        destinationChildInstanceTypes: string[];
        /**
         * A match statement that indicates the prefix list.
         */
        destinationCidrBlocks: string[];
        /**
         * A match statement that indicates the list of IDs of the destination instances.
         */
        destinationInstanceIds: string[];
        /**
         * Indicates whether to enable the reverse match method of the DestinationInstanceIds match condition.
         */
        destinationInstanceIdsReverseMatch: boolean;
        /**
         * A match statement that indicates the list of IDs of the destination route tables.
         */
        destinationRouteTableIds: string[];
        /**
         * The ID of the route map.
         */
        id: string;
        /**
         * The action that is performed to a route if the route meets all the match conditions.
         */
        mapResult: string;
        /**
         * A match statement that indicates the As path list.
         */
        matchAsns: string[];
        /**
         * A match statement that indicates the community set.
         */
        matchCommunitySets: string[];
        /**
         * The priority of the next route map that is associated with the current route map.
         */
        nextPriority: number;
        /**
         * An action statement that operates the community attribute.
         */
        operateCommunitySets: string[];
        /**
         * An action statement that modifies the preference of the route.
         */
        preference: number;
        /**
         * Indicates AS Path prepending when a regional gateway receives or publishes a route.
         */
        prependAsPaths: string[];
        /**
         * The priority of the route map.
         */
        priority: number;
        /**
         * The ID of the route map.
         */
        routeMapId: string;
        /**
         * A match statement that indicates the list of route types.
         */
        routeTypes: string[];
        /**
         * A match statement that indicates the list of IDs of the source instances.
         */
        sourceChildInstanceTypes: string[];
        /**
         * A match statement that indicates the list of IDs of the source instances.
         */
        sourceInstanceIds: string[];
        /**
         * Indicates whether to enable the reverse match method of the SourceInstanceIds match condition.
         */
        sourceInstanceIdsReverseMatch: boolean;
        /**
         * A match statement that indicates the list of IDs of the source regions.
         */
        sourceRegionIds: string[];
        /**
         * A match statement that indicates the list of IDs of the source route tables.
         */
        sourceRouteTableIds: string[];
        /**
         * The status of the route map, including `Creating`, `Active` and `Deleting`.
         */
        status: string;
        /**
         * The direction in which the route map is applied, including `RegionIn` and `RegionOut`.
         */
        transmitDirection: string;
    }

    export interface GetRouteServicesService {
        /**
         * The region of the network instances that access the cloud services.
         */
        accessRegionId: string;
        /**
         * -(Required, ForceNew) The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The IP address of the cloud service.
         */
        cidrs: string[];
        /**
         * The description of the cloud service.
         */
        description: string;
        /**
         * -(Optional, ForceNew) The domain name or IP address of the cloud service.
         */
        host: string;
        /**
         * The region of the cloud service.
         */
        hostRegionId: string;
        /**
         * The VPC associated with the cloud service.
         */
        hostVpcId: string;
        /**
         * The ID of the route service.
         */
        id: string;
        /**
         * The status of the cloud service. Valid values: `Active`, `Creating` and `Deleting`.
         */
        status: string;
        /**
         * The update interval. Default value: 5. The value cannot be modified.
         */
        updateInterval: string;
    }

    export interface GetTransitRouterPeerAttachmentsAttachment {
        /**
         * Auto publish route enabled.
         */
        autoPublishRouteEnabled: boolean;
        /**
         * The bandwidth of the bandwidth package.
         */
        bandwidth: number;
        /**
         * ID of the CEN bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * ID of the geographic.
         */
        geographicSpanId: string;
        /**
         * The ID of CEN Transit Router peer attachments.
         */
        id: string;
        /**
         * ID of the peer transit router.
         */
        peerTransitRouterId: string;
        /**
         * Owner ID of the peer transit router.
         */
        peerTransitRouterOwnerId: string;
        /**
         * Region ID of the peer transit router.
         */
        peerTransitRouterRegionId: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of CEN Transit Router peer attachment. Valid values `Attached`, `Attaching` and `Detaching`.
         */
        status: string;
        /**
         * The description of CEN Transit Router peer attachments.
         */
        transitRouterAttachmentDescription: string;
        /**
         * The ID of CEN Transit Router peer attachments.
         */
        transitRouterAttachmentId: string;
        /**
         * Name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The ID of transit router.
         */
        transitRouterId: string;
    }

    export interface GetTransitRouterRouteEntriesEntry {
        id: string;
        status: string;
        transitRouterRouteEntryDescription: string;
        /**
         * The target network segment of the route entry.
         */
        transitRouterRouteEntryDestinationCidrBlock: string;
        transitRouterRouteEntryId: string;
        transitRouterRouteEntryName: string;
        /**
         * ID of the next hop.
         */
        transitRouterRouteEntryNextHopId: string;
        /**
         * Type of the next hop.
         */
        transitRouterRouteEntryNextHopType: string;
        /**
         * Type of the route entry.
         */
        transitRouterRouteEntryType: string;
    }

    export interface GetTransitRouterRouteTableAssociationsAssociation {
        id: string;
        /**
         * ID of the transit router route table association.
         */
        resourceId: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the route table, including `Active`, `Associating`, `Dissociating`.
         */
        status: string;
        /**
         * ID of the cen transit router attachment.
         */
        transitRouterAttachmentId: string;
    }

    export interface GetTransitRouterRouteTablePropagationsPropagation {
        id: string;
        /**
         * ID of the transit router route table association.
         */
        resourceId: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the route table, including `Active`, `Enabling`, `Disabling`, `Deleted`.
         */
        status: string;
        /**
         * ID of the cen transit router attachment.
         */
        transitRouterAttachmentId: string;
    }

    export interface GetTransitRouterRouteTablesTable {
        /**
         * ID of resource.
         */
        id: string;
        status: string;
        /**
         * The description of the transit router route table.
         */
        transitRouterRouteTableDescription: string;
        /**
         * ID of the trabsit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * Name of the transit router route table.
         */
        transitRouterRouteTableName: string;
        /**
         * The type of the transit router route table to query. Valid values `Creating`, `Active` and `Deleting`..
         */
        transitRouterRouteTableType: string;
    }

    export interface GetTransitRouterVbrAttachmentsAttachment {
        /**
         * ID of the region where the conflicted VBR is located.
         */
        autoPublishRouteEnabled: boolean;
        id: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the resource. Valid values `Attached`, `Attaching` and `Detaching`.
         */
        status: string;
        transitRouterAttachmentDescription: string;
        /**
         * ID of the transit router VBR attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * Name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * ID of the VBR.
         */
        vbrId: string;
        /**
         * The Owner ID of the VBR.
         */
        vbrOwnerId: string;
    }

    export interface GetTransitRouterVpcAttachmentsAttachment {
        /**
         * The ID of the transit router.
         */
        id: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the resource. Valid values `Attached`, `Attaching` and `Detaching`.
         */
        status: string;
        /**
         * The description of transit router attachment.
         */
        transitRouterAttachmentDescription: string;
        /**
         * ID of the transit router VBR attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * Name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * The Owner ID of the VPC.
         */
        vpcOwnerId: string;
        /**
         * The mappings of zone
         */
        zoneMappings: outputs.cen.GetTransitRouterVpcAttachmentsAttachmentZoneMapping[];
    }

    export interface GetTransitRouterVpcAttachmentsAttachmentZoneMapping {
        /**
         * The VSwitch ID.
         */
        vswitchId: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetTransitRoutersTransitRouter {
        /**
         * The UID of the Aliyun.
         */
        aliUid: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The ID of the resource, It is formatted to `<cen_id>:<transit_router_id>`. **NOTE:** Before 1.151.0, It is formatted to `<transit_router_id>`.
         */
        id: string;
        /**
         * The status of the resource. Valid values `Active`, `Creating`, `Deleting` and `Updating`.
         */
        status: string;
        /**
         * The description of the transit router.
         */
        transitRouterDescription: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The name of the transit router.
         */
        transitRouterName: string;
        /**
         * The Type of the transit router.
         */
        type: string;
        /**
         * The vip of the XGW.
         */
        xgwVip: string;
    }

    export interface GetVbrHealthChecksCheck {
        /**
         * The ID of the Cloud Enterprise Network (CEN) instance.
         */
        cenId: string;
        /**
         * The time interval at which probe packets are sent during the health check.
         */
        healthCheckInterval: number;
        /**
         * The source IP address of the health check.
         */
        healthCheckSourceIp: string;
        /**
         * The destination IP address of the health check.
         */
        healthCheckTargetIp: string;
        /**
         * The number of probe packets that are sent during the health check.
         */
        healthyThreshold: number;
        /**
         * The ID of the CEN VBR Heath Check.
         */
        id: string;
        /**
         * The ID of the VBR instance.
         */
        vbrInstanceId: string;
        /**
         * The ID of the region where the VBR instance is deployed.
         */
        vbrInstanceRegionId: string;
    }

    export interface TransitRouterVpcAttachmentZoneMapping {
        /**
         * The VSwitch id of attachment.
         */
        vswitchId?: string;
        /**
         * The zone Id of VSwitch.
         */
        zoneId?: string;
    }

}

export namespace cfg {
    export interface AggregateCompliancePackConfigRule {
        /**
         * A list of parameter rules.
         */
        configRuleParameters?: outputs.cfg.AggregateCompliancePackConfigRuleConfigRuleParameter[];
        /**
         * The Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface AggregateCompliancePackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName?: string;
        /**
         * The Parameter Value.
         */
        parameterValue?: string;
    }

    export interface AggregateCompliancePackConfigRuleId {
        /**
         * The rule ID of Aggregate Config Rule.
         */
        configRuleId?: string;
    }

    export interface AggregatorAggregatorAccount {
        /**
         * Aggregator account Uid.
         */
        accountId: string;
        /**
         * Aggregator account name.
         */
        accountName: string;
        /**
         * Aggregator account source type. Valid values: `ResourceDirectory`.
         */
        accountType: string;
    }

    export interface CompliancePackConfigRule {
        /**
         * A list of Config Rule Parameters.
         */
        configRuleParameters?: outputs.cfg.CompliancePackConfigRuleConfigRuleParameter[];
        /**
         * The Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface CompliancePackConfigRuleConfigRuleParameter {
        /**
         * The parameter name.
         */
        parameterName?: string;
        /**
         * The parameter value.
         */
        parameterValue?: string;
    }

    export interface CompliancePackConfigRuleId {
        /**
         * The rule ID of Config Rule.
         */
        configRuleId?: string;
    }

    export interface GetAggregateCompliancePacksPack {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        aggregateCompliancePackName: string;
        /**
         * The Aggregate Compliance Package Id.
         * * `aggregateCompliancePackName` -The Aggregate Compliance Package Name.
         */
        aggregatorCompliancePackId: string;
        /**
         * The template ID of the Compliance Package.
         */
        compliancePackTemplateId: string;
        /**
         * A list of The Aggregate Compliance Package Rules.
         */
        configRules: outputs.cfg.GetAggregateCompliancePacksPackConfigRule[];
        /**
         * The description of aggregate compliance pack.
         */
        description: string;
        /**
         * The ID of the Aggregate Compliance Pack.
         */
        id: string;
        /**
         * The Risk Level.
         */
        riskLevel: number;
        /**
         * The status of the resource. Valid values `ACTIVE`, `CREATING`, `INACTIVE`.
         */
        status: string;
    }

    export interface GetAggregateCompliancePacksPackConfigRule {
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.GetAggregateCompliancePacksPackConfigRuleConfigRuleParameter[];
        /**
         * Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface GetAggregateCompliancePacksPackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
        /**
         * Required.
         */
        required: boolean;
    }

    export interface GetAggregateConfigRulesRule {
        /**
         * The Aliyun User ID.
         */
        accountId: string;
        /**
         * The config rule name.
         */
        aggregateConfigRuleName: string;
        /**
         * The ID of aggregator.
         */
        aggregatorId: string;
        /**
         * The ID of Compliance Package.
         */
        compliancePackId: string;
        compliances: outputs.cfg.GetAggregateConfigRulesRuleCompliance[];
        /**
         * The config rule arn.
         */
        configRuleArn: string;
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * The trigger types of config rules.
         */
        configRuleTriggerTypes: string;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Event source of the Config Rule.
         */
        eventSource: string;
        /**
         * The id of the resources to be evaluated against the rule.
         * * `sourceIdentifier`- The identifier of the managed rule or the arn of the custom function.
         * * `sourceOwner`- The source owner of the Config Rule.
         */
        excludeResourceIdsScope: string;
        /**
         * The ID of the Aggregate Config Rule.
         */
        id: string;
        /**
         * The settings of the input parameters for the rule.
         */
        inputParameters: {[key: string]: any};
        /**
         * The frequency of the compliance evaluations.
         */
        maximumExecutionFrequency: string;
        /**
         * The timestamp when the rule was last modified.
         */
        modifiedTimestamp: string;
        /**
         * The scope of resource region ids.
         */
        regionIdsScope: string;
        /**
         * The scope of resource group ids.
         */
        resourceGroupIdsScope: string;
        resourceTypesScopes: string[];
        /**
         * Optional, ForceNew) The Risk Level. Valid values `1`: critical, `2`: warning, `3`: info.
         */
        riskLevel: number;
        sourceIdentifier: string;
        sourceOwner: string;
        /**
         * The state of the config rule, valid values: `ACTIVE`, `DELETING`, `EVALUATING` and `INACTIVE`.
         */
        status: string;
        /**
         * The scope of tay key.
         */
        tagKeyScope: string;
        /**
         * The scope of tay value.
         */
        tagValueScope: string;
    }

    export interface GetAggregateConfigRulesRuleCompliance {
        /**
         * The Compliance Type.
         */
        complianceType: string;
        /**
         * The Count.
         */
        count: number;
    }

    export interface GetAggregatorsAggregator {
        /**
         * Aggregator account uid.
         */
        accountId: string;
        /**
         * Account information in aggregator.
         */
        aggregatorAccounts: outputs.cfg.GetAggregatorsAggregatorAggregatorAccount[];
        /**
         * The id of aggregator.
         */
        aggregatorId: string;
        /**
         * The name of aggregator.
         */
        aggregatorName: string;
        /**
         * The type of aggregator.
         */
        aggregatorType: string;
        /**
         * The description of aggregator.
         */
        description: string;
        /**
         * The id of the aggregator.
         */
        id: string;
        /**
         * The status of the resource. Valid Values:  `0`: creating `1`: normal `2`: deleting.
         */
        status: string;
    }

    export interface GetAggregatorsAggregatorAggregatorAccount {
        /**
         * Aggregator account uid.
         */
        accountId: string;
        /**
         * Aggregator account name.
         */
        accountName: string;
        /**
         * Aggregator account source type.
         */
        accountType: string;
    }

    export interface GetCompliancePacksPack {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * The Compliance Package ID.
         */
        compliancePackId: string;
        /**
         * The Compliance Package Name.
         */
        compliancePackName: string;
        /**
         * The template ID of the Compliance Package.
         */
        compliancePackTemplateId: string;
        /**
         * A list of The Compliance Package Rules.
         */
        configRules: outputs.cfg.GetCompliancePacksPackConfigRule[];
        /**
         * The description of compliance pack.
         */
        description: string;
        /**
         * The ID of the Compliance Pack.
         */
        id: string;
        /**
         * The Ris Level.
         */
        riskLevel: number;
        /**
         * The status of the resource. Valid values `ACTIVE`, `CREATING`.
         */
        status: string;
    }

    export interface GetCompliancePacksPackConfigRule {
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.GetCompliancePacksPackConfigRuleConfigRuleParameter[];
        /**
         * Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface GetCompliancePacksPackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
        /**
         * Required.
         */
        required: boolean;
    }

    export interface GetConfigurationRecordersRecorder {
        accountId: string;
        /**
         * The ID of the Config Configuration Recorder. Value as the `accountId`.
         * * `accountId`- The ID of the Alicloud account.
         */
        id: string;
        /**
         * Enterprise version configuration audit enabled status.
         */
        organizationEnableStatus: string;
        /**
         * The ID of the Enterprise management account.
         */
        organizationMasterId: number;
        /**
         * A list of resource types to be monitored.
         */
        resourceTypes: string[];
        /**
         * Status of resource monitoring.
         */
        status: string;
    }

    export interface GetDeliveryChannelsChannel {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the role assumed by delivery method.
         */
        deliveryChannelAssumeRoleArn: string;
        /**
         * The rule attached to the delivery method. This parameter is applicable only to delivery methods of the Message Service (MNS) type.
         */
        deliveryChannelCondition: string;
        /**
         * The ID of the delivery channel.
         */
        deliveryChannelId: string;
        /**
         * The name of the delivery channel.
         */
        deliveryChannelName: string;
        /**
         * The ARN of the delivery destination.
         */
        deliveryChannelTargetArn: string;
        /**
         * The type of the delivery channel.
         */
        deliveryChannelType: string;
        /**
         * The description of the delivery channel.
         */
        description: string;
        /**
         * The ID of the Config Delivery Channel.
         */
        id: string;
        /**
         * The status of the config delivery channel. Valid values `0`: Disable delivery channel, `1`: Enable delivery channel.
         */
        status: number;
    }

    export interface GetRulesRule {
        accountId: string;
        compliancePackId: string;
        /**
         * The information about the compliance evaluations based on the rule.
         */
        compliances: outputs.cfg.GetRulesRuleCompliance[];
        configRuleArn: string;
        configRuleId: string;
        /**
         * Field `configRuleState` has been deprecated from provider version 1.124.1. New field `status` instead.
         */
        configRuleState: string;
        /**
         * (Available in 1.124.1+) A list of trigger types of config rule.
         */
        configRuleTriggerTypes: string;
        description: string;
        /**
         * Event source of the Config Rule.
         */
        eventSource: string;
        /**
         * (Available in 1.124.1+) The scope of exclude of resource ids.
         */
        excludeResourceIdsScope: string;
        /**
         * The ID of the Config Rule.
         * * `accountId`- The ID of the Alicloud account.
         * * `configRuleArn`- The ARN of the Config Rule.
         * * `configRuleId`- The ID of the Config Rule.
         * * `configRuleState`- The state of the Config Rule.
         * * `description`- The description of the Config Rule.
         * * `inputParameters`- The input parameters of the Config Rule.
         * * `modifiedTimestamp`- the timestamp of the Config Rule modified.
         * * `riskLevel`- The risk level of the Config Rule.
         * * `ruleName`- The name of the Config Rule.
         */
        id: string;
        inputParameters: {[key: string]: any};
        /**
         * (Available in 1.124.1+) The frequency of maximum execution.
         */
        maximumExecutionFrequency: string;
        modifiedTimestamp: string;
        /**
         * (Available in 1.124.1+) The scope of region ids.
         */
        regionIdsScope: string;
        /**
         * (Available in 1.124.1+) The scope of resource group ids.
         */
        resourceGroupIdsScope: string;
        /**
         * (Available in 1.124.1+) The scope of resource types.
         */
        resourceTypesScopes: string[];
        /**
         * The risk level of Config Rule. Valid values: `1`: Critical ,`2`: Warning , `3`: Info.
         */
        riskLevel: number;
        /**
         * The name of config rule.
         */
        ruleName: string;
        /**
         * The types of the resources to be evaluated against the rule.
         */
        scopeComplianceResourceTypes: string[];
        /**
         * Rule trigger mechanism.
         */
        sourceDetailMessageType: string;
        sourceIdentifier: string;
        /**
         * Rule execution cycle. 
         * * `sourceIdentifier`- The identifier of the managed rule or the arn of the custom function.
         * * `sourceOwner`- The source owner of the Config Rule.
         */
        sourceMaximumExecutionFrequency: string;
        sourceOwner: string;
        /**
         * The status of the config rule, valid values: `ACTIVE`, `DELETING`, `EVALUATING` and `INACTIVE`.
         */
        status: string;
        /**
         * (Available in 1.124.1+) The scope of tag key.
         */
        tagKeyScope: string;
        /**
         * (Available in 1.124.1+) The scope of tag value.
         */
        tagValueScope: string;
    }

    export interface GetRulesRuleCompliance {
        /**
         * The compliance evaluation result of the target resources.
         */
        complianceType: string;
        /**
         * The number of resources with the specified compliance evaluation result.
         */
        count: number;
    }

}

export namespace clickhouse {
    export interface DbClusterDbClusterAccessWhiteList {
        /**
         * Whitelist grouping attribute.
         */
        dbClusterIpArrayAttribute?: string;
        /**
         * Whitelist group name.
         */
        dbClusterIpArrayName?: string;
        /**
         * The IP address list under the whitelist group.
         */
        securityIpList?: string;
    }

    export interface GetAccountsAccount {
        /**
         * In Chinese, English letter. May contain Chinese and English characters, lowercase letters, numbers, and underscores (_), the dash (-). Cannot start with http:// and https:// at the beginning. Length is from 2 to 256 characters.
         */
        accountDescription: string;
        /**
         * Account name: lowercase letters, numbers, underscores, lowercase letter; length no more than 16 characters.
         */
        accountName: string;
        /**
         * The Valid Account type: `Normal`, `Super`.
         */
        accountType: string;
        /**
         * The DBCluster id.
         */
        dbClusterId: string;
        /**
         * The ID of the Account. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetBackupPoliciesPolicy {
        /**
         * Data backup days. Valid values: `7` to `730`.
         */
        backupRetentionPeriod: number;
        /**
         * The db cluster id.
         */
        dbClusterId: string;
        /**
         * The ID of the Backup Policy.
         */
        id: string;
        /**
         * DBCluster Backup period.
         */
        preferredBackupPeriods: string[];
        /**
         * Backup Time, UTC time.
         */
        preferredBackupTime: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetDbClustersCluster {
        /**
         * Alibaba Cloud account Id.
         */
        aliUid: string;
        /**
         * The ID of the business process flow.
         */
        bid: string;
        /**
         * Instance family values include: Basic: Basic edition; HighAvailability: high availability edition.
         */
        category: string;
        /**
         * The Commodity Code of the DBCluster.
         */
        commodityCode: string;
        /**
         * Connection string.
         */
        connectionString: string;
        /**
         * The control version of the DBCluster.
         */
        controlVersion: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The db cluster access white list.
         */
        dbClusterAccessWhiteLists: outputs.clickhouse.GetDbClustersClusterDbClusterAccessWhiteList[];
        /**
         * The DBCluster description.
         */
        dbClusterDescription: string;
        dbClusterId: string;
        /**
         * The DBCluster network type.
         */
        dbClusterNetworkType: string;
        /**
         * The DBCluster type.
         */
        dbClusterType: string;
        /**
         * The node class of the DBCluster.
         */
        dbNodeClass: string;
        /**
         * The node count of the DBCluster.
         */
        dbNodeCount: string;
        /**
         * The node storage of the DBCluster.
         */
        dbNodeStorage: string;
        /**
         * Key management service KMS key ID.
         */
        encryptionKey: string;
        /**
         * Currently only supports ECS disk encryption, with a value of CloudDisk, not encrypted when empty.
         */
        encryptionType: string;
        /**
         * The Engine of the DBCluster.
         */
        engine: string;
        /**
         * The engine version of the DBCluster.
         */
        engineVersion: string;
        /**
         * The expiration time of the DBCluster.
         */
        expireTime: string;
        /**
         * The ID of the DBCluster.
         */
        id: string;
        /**
         * If the instance has expired.
         */
        isExpired: string;
        /**
         * The lock mode of the DBCluster.
         */
        lockMode: string;
        /**
         * Lock reason of the DBCluster.
         */
        lockReason: string;
        /**
         * Examples of the maintenance window, in the format of hh:mmZ-hh:mm Z.
         */
        maintainTime: string;
        /**
         * The payment type of the resource. Valid values: `PayAsYouGo`,`Subscription`.
         */
        paymentType: string;
        /**
         * Connection port.
         */
        port: number;
        /**
         * A public IP address for the connection.
         */
        publicConnectionString: string;
        /**
         * Public network port.
         */
        publicPort: string;
        /**
         * Scale state.
         */
        scaleOutStatuses: outputs.clickhouse.GetDbClustersClusterScaleOutStatus[];
        /**
         * The status of the DBCluster. Valid values: `Running`,`Creating`,`Deleting`,`Restarting`,`Preparing`.
         */
        status: string;
        /**
         * Storage type of DBCluster. Valid values: `cloudEssd`, `cloudEfficiency`, `cloudEssdPl2`, `cloudEssdPl3`.
         */
        storageType: string;
        /**
         * Support fallback scheme.
         */
        supportBackup: number;
        /**
         * The system supports http port number.
         */
        supportHttpsPort: boolean;
        /**
         * Supports Mysql, and those of the ports.
         */
        supportMysqlPort: boolean;
        /**
         * Virtual Private Cloud (VPC cloud instance ID.
         */
        vpcCloudInstanceId: string;
        /**
         * The VPC ID of the DBCluster.
         */
        vpcId: string;
        /**
         * The vswitch id of the DBCluster.
         */
        vswitchId: string;
        /**
         * The zone ID of the DBCluster.
         */
        zoneId: string;
    }

    export interface GetDbClustersClusterDbClusterAccessWhiteList {
        /**
         * Whitelist grouping attribute.
         */
        dbClusterIpArrayAttribute: string;
        /**
         * Whitelist group name.
         */
        dbClusterIpArrayName: string;
        /**
         * The IP address list under the whitelist group.
         */
        securityIpList: string;
    }

    export interface GetDbClustersClusterScaleOutStatus {
        /**
         * Process.
         */
        progress: string;
        /**
         * Efficiency.
         */
        ratio: string;
    }

    export interface GetRegionsRegion {
        /**
         * The Region ID.
         */
        regionId: string;
        /**
         * A list of available zone ids in the region_id.
         */
        zoneIds: outputs.clickhouse.GetRegionsRegionZoneId[];
    }

    export interface GetRegionsRegionZoneId {
        /**
         * Whether to support vpc network.
         */
        vpcEnabled: boolean;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

}

export namespace cloudauth {
    export interface GetFaceConfigsConfig {
        /**
         * Scene name.
         */
        bizName: string;
        /**
         * Scene type. **NOTE:** The bizType cannot exceed 32 characters and can only use English letters, numbers and dashes (-).
         */
        bizType: string;
        /**
         * The Update Time.
         */
        gmtUpdated: string;
    }

}

export namespace cloudconnect {
    export interface GetNetworksNetwork {
        /**
         * CidrBlock of the CCN instance.
         */
        cidrBlock: string;
        description: string;
        /**
         * ID of the CCN instance.
         */
        id: string;
        /**
         * IsDefault of the CCN instance.
         */
        isDefault: boolean;
        /**
         * Name of the CCN instance.
         */
        name: string;
    }

}

export namespace cloudfirewall {
    export interface GetControlPoliciesPolicy {
        /**
         * The action that Cloud Firewall performs on the traffic. Valid values: `accept`, `drop`, `log`.
         */
        aclAction: string;
        /**
         * The unique ID of the access control policy.
         */
        aclUuid: string;
        applicationId: string;
        /**
         * The application type that the access control policy supports.If `direction` is `in`, the valid value is `ANY`. If `direction` is `out`, `ANY`, `HTTP`, `HTTPS`, `MQTT`, `Memcache`, `MongoDB`, `MySQL`, `RDP`, `Redis`, `SMTP`, `SMTPS`, `SSH`, `SSL`, `VNC`.
         */
        applicationName: string;
        /**
         * The description of the access control policy.
         */
        description: string;
        /**
         * The destination port defined in the access control policy.
         */
        destPort: string;
        /**
         * The destination port address book defined in the access control policy.
         */
        destPortGroup: string;
        destPortGroupPorts: string[];
        /**
         * The destination port type defined in the access control policy. Valid values: `group`, `port`.
         */
        destPortType: string;
        /**
         * The destination address defined in the access control policy.
         */
        destination: string;
        destinationGroupCidrs: string[];
        destinationGroupType: string;
        /**
         * The destination address type defined in the access control policy.Valid values: If `direction` is `in`, the valid values are `net`, `group`. If `direction` is `out`, the valid values are `net`, `group`, `domain`, `location`.
         */
        destinationType: string;
        /**
         * The direction of traffic to which the access control policy applies. Valid values: `in`, `out`.
         */
        direction: string;
        dnsResult: string;
        dnsResultTime: string;
        hitTimes: string;
        /**
         * The ID of the Control Policy.
         */
        id: string;
        order: number;
        /**
         * The protocol type of traffic to which the access control policy applies. Valid values: If `direction` is `in`, the valid value is `ANY`. If `direction` is `out`, the valid values are `ANY`, `TCP`, `UDP`, `ICMP`.
         */
        proto: string;
        /**
         * Specifies whether the access control policy is enabled. By default, an access control policy is enabled after it is created. Valid values: `true`, `false`.
         */
        release: boolean;
        /**
         * The source address defined in the access control policy.
         */
        source: string;
        sourceGroupCidrs: string[];
        sourceGroupType: string;
        /**
         * The type of the source address book defined in the access control policy. Valid values: If `direction` is to `in`, the valid values are `net`, `group`, `location`. If `direction` is `out`, the valid values are `net`, `group`.
         */
        sourceType: string;
    }

    export interface GetInstancesInstance {
        /**
         * The Creation time of the resource.
         */
        createTime: string;
        /**
         * The end time of the resource..
         */
        endTime: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        instanceId: string;
        /**
         * The payment type of the resource. Valid values: `Subscription`.
         */
        paymentType: string;
        /**
         * Automatic renewal period unit. Valid values: `Month`,`Year`.
         */
        renewalDurationUnit: string;
        /**
         * Automatic renewal status. Valid values: `AutoRenewal`,`ManualRenewal`. Default Value: `ManualRenewal`.
         */
        renewalStatus: string;
        /**
         * The Status of Instance.
         */
        status: string;
    }

}

export namespace cloudsso {
    export interface AccessConfigurationPermissionPolicy {
        /**
         * The Content of Policy.
         */
        permissionPolicyDocument?: string;
        /**
         * The Policy Name of policy. The name of the resource.
         */
        permissionPolicyName: string;
        /**
         * The Policy Type of policy. Valid values: `System`, `Inline`.
         */
        permissionPolicyType: string;
    }

    export interface DirectorySamlIdentityProviderConfiguration {
        /**
         * Base64 encoded IdP metadata document. **NOTE:** If the IdP Metadata has been uploaded, no update will be made if this parameter is not specified, otherwise the update will be made according to the parameter content. If IdP Metadata has not been uploaded, and the parameter `ssoStatus` is `Enabled`, this parameter must be provided. If the IdP Metadata has not been uploaded, and the parameter `ssoStatus` is `Disabled`, this parameter can be omitted, and the IdP Metadata will remain empty.
         */
        encodedMetadataDocument: string;
        /**
         * SAML SSO login enabled status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        ssoStatus: string;
    }

    export interface GetAccessConfigurationsConfiguration {
        /**
         * The AccessConfigurationId of the Access Configuration.
         */
        accessConfigurationId: string;
        /**
         * The AccessConfigurationName of the Access Configuration.
         */
        accessConfigurationName: string;
        /**
         * The Created Time of the Directory.
         */
        createTime: string;
        /**
         * The Description of the Directory.
         */
        description: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The ID of the Access Configuration.
         */
        id: string;
        /**
         * The Policy List.
         */
        permissionPolicies: outputs.cloudsso.GetAccessConfigurationsConfigurationPermissionPolicy[];
        /**
         * The RelayState of the Access Configuration.
         */
        relayState: string;
        /**
         * The SessionDuration of the Access Configuration.
         */
        sessionDuration: number;
        /**
         * The StatusNotifications of the Access Configuration.
         */
        statusNotifications: string[];
    }

    export interface GetAccessConfigurationsConfigurationPermissionPolicy {
        /**
         * The Creation time of policy.
         */
        addTime: string;
        /**
         * The Content of Policy.
         */
        permissionPolicyDocument: string;
        /**
         * The Policy Name of policy.
         */
        permissionPolicyName: string;
        /**
         * The Policy Type of policy. Valid values: `System`, `Inline`.
         */
        permissionPolicyType: string;
    }

    export interface GetDirectoriesDirectory {
        /**
         * Saml identifies the creation time of the provider configuration.
         */
        createTime: string;
        /**
         * The DirectoryId of the CloudSSO directory.
         */
        directoryId: string;
        /**
         * The name of the CloudSSO directory.
         */
        directoryName: string;
        /**
         * The ID of the Directory.
         */
        id: string;
        /**
         * The mfa authentication status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        mfaAuthenticationStatus: string;
        /**
         * The Region of the CloudSSO directory.
         */
        region: string;
        /**
         * The saml identity provider configuration.
         */
        samlIdentityProviderConfigurations: outputs.cloudsso.GetDirectoriesDirectorySamlIdentityProviderConfiguration[];
        /**
         * The scim synchronization status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        scimSynchronizationStatus: string;
        /**
         * Asynchronous Task Information Array.
         */
        tasks: outputs.cloudsso.GetDirectoriesDirectoryTask[];
    }

    export interface GetDirectoriesDirectorySamlIdentityProviderConfiguration {
        /**
         * Saml identifies the creation time of the provider configuration.
         */
        createTime: string;
        /**
         * Base64 encoded IdP metadata document.
         */
        encodedMetadataDocument: string;
        /**
         * SAML IdPEntityID.
         */
        entityId: string;
        /**
         * SAML IdP http-post Binding address.
         */
        loginUrl: string;
        /**
         * SAML SSO login enabled status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        ssoStatus: string;
    }

    export interface GetDirectoriesDirectoryTask {
        /**
         * The ID of Access Configuration.
         */
        accessConfigurationId: string;
        /**
         * The Name of Access Configuration.
         */
        accessConfigurationName: string;
        /**
         * The End Time of Task.
         */
        endTime: string;
        /**
         * the Reason for the Failure of  the task.
         */
        failureReason: string;
        /**
         * The ID of Cloud SSO Identity.
         */
        principalId: string;
        /**
         * The Name of Cloud SSO Identity.
         */
        principalName: string;
        /**
         * The Type of Cloud SSO Identity.
         */
        principalType: string;
        /**
         * The Start Time of Task.
         */
        startTime: string;
        /**
         * The Task Status.
         */
        status: string;
        /**
         * The Id of deploy target.
         */
        targetId: string;
        /**
         * The Name of Deploy Target.
         */
        targetName: string;
        /**
         * The Path in RD of Deploy Target.
         */
        targetPath: string;
        /**
         * The Type of Deploy Target.
         */
        targetType: string;
        /**
         * The ID of the Task.
         */
        taskId: string;
        /**
         * The Type of the Task.
         */
        taskType: string;
    }

    export interface GetGroupsGroup {
        /**
         * The Created Time of the Directory.
         */
        createTime: string;
        /**
         * The Description of the Directory.
         */
        description: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The Group ID of the group.
         */
        groupId: string;
        /**
         * The Name of the group.
         */
        groupName: string;
        /**
         * The ID of the Group.
         */
        id: string;
        /**
         * The Provision Type of the Group. Valid values: `Manual`, `Synchronized`.
         */
        provisionType: string;
    }

    export interface GetScimServerCredentialsCredential {
        /**
         * The CreateTime of the resource.
         */
        createTime: string;
        /**
         * The CredentialId of the resource.
         */
        credentialId: string;
        /**
         * The CredentialSecret of the resource.
         */
        credentialSecret: string;
        /**
         * The CredentialType of the resource.
         */
        credentialType: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The ExpireTime of the resource.
         */
        expireTime: string;
        /**
         * The ID of the SCIM Server Credential.
         */
        id: string;
        /**
         * The Status of the resource. Valid values: `Disabled`, `Enabled`.
         */
        status: string;
    }

    export interface GetUsersUser {
        /**
         * The create time of the user.
         */
        createTime: string;
        /**
         * The description of user.
         */
        description: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The display name of user.
         */
        displayName: string;
        /**
         * The User's Contact Email Address.
         */
        email: string;
        /**
         * The first name of user.
         */
        firstName: string;
        /**
         * The ID of the User.
         */
        id: string;
        /**
         * The last name of user.
         */
        lastName: string;
        /**
         * The List of MFA Device for User.
         */
        mfaDevices: outputs.cloudsso.GetUsersUserMfaDevice[];
        /**
         * ProvisionType.
         */
        provisionType: string;
        /**
         * User status. Valid values: `Enabled` and `Disabled`.
         */
        status: string;
        /**
         * The User ID of the group.
         */
        userId: string;
        /**
         * The name of user.
         */
        userName: string;
    }

    export interface GetUsersUserMfaDevice {
        /**
         * The MFA Device ID.
         */
        deviceId: string;
        /**
         * The MFA Device Name.
         */
        deviceName: string;
        /**
         * The MFA Device Type.
         */
        deviceType: string;
        /**
         * The Effective Time of MFA Device.
         */
        effectiveTime: string;
    }

}

export namespace cloudstoragegateway {
    export interface GetExpressSyncsSync {
        /**
         * The name of the OSS Bucket.
         */
        bucketName: string;
        /**
         * The prefix of the OSS Bucket.
         */
        bucketPrefix: string;
        /**
         * The region of the OSS Bucket.
         */
        bucketRegion: string;
        /**
         * The description of the Express Sync.
         */
        description: string;
        /**
         * The ID of the Express Sync.
         */
        expressSyncId: string;
        /**
         * The name of the Express Sync.
         */
        expressSyncName: string;
        id: string;
        /**
         * The name of the message topic (Topic) corresponding to the Express Sync in the Alibaba Cloud Message Service MNS.
         */
        mnsTopic: string;
    }

    export interface GetGatewayBlockVolumesVolume {
        /**
         * The IP ADDRESS.
         */
        address: string;
        /**
         * The Block volume set mode to cache mode. Value values: `Cache`, `WriteThrough`.
         */
        cacheMode: string;
        /**
         * Whether to enable iSCSI access of CHAP authentication, which currently supports both CHAP inbound authentication.  Default value: `false`.
         */
        chapEnabled: boolean;
        /**
         * The Inbound CHAP user.**NOTE:** When the `chapEnabled` is  `true` is,The `chapInPassword` is valid.
         */
        chapInUser: string;
        /**
         * The Block volume storage allocation unit.  Valid values: `8192`, `16384`, `32768`, `65536`, `131072`. Default value: `32768`. Unit: `Byte`.
         */
        chunkSize: number;
        /**
         * The cache disk ID.
         */
        diskId: string;
        /**
         * The cache disk type.
         */
        diskType: string;
        /**
         * Whether to enable Volume.
         */
        enabled: boolean;
        /**
         * The Block volume name.  The name must be 1 to 32 characters in length, and can contain lowercase letters, numbers.
         */
        gatewayBlockVolumeName: string;
        /**
         * The Gateway ID.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway Block Volume. The value formats as `<gateway_id>:<index_id>`.
         */
        id: string;
        /**
         * The ID of the index.
         */
        indexId: string;
        /**
         * CThe Cache disk to local path. **NOTE:**  When the `cacheMode` is  `Cache` is,The `chapInPassword` is valid.
         */
        localPath: string;
        /**
         * The Lun identifier.
         */
        lunId: number;
        /**
         * The name of the OSS Bucket.
         */
        ossBucketName: string;
        /**
         * Whether to enable SSL access your OSS Buckets. Default value: `true`.
         */
        ossBucketSsl: boolean;
        /**
         * The endpoint of the OSS Bucket.
         */
        ossEndpoint: string;
        /**
         * The Port.
         */
        port: number;
        /**
         * The Protocol.
         */
        protocol: string;
        /**
         * The Volume size.
         */
        size: number;
        /**
         * The Buffer status.
         */
        state: string;
        /**
         * The status of volume.
         */
        status: number;
        /**
         * The target.
         */
        target: string;
        /**
         * The total amount of downloaded data. Unit: `B`.
         */
        totalDownload: number;
        /**
         * The total amount of uploaded data. Unit: `B`.
         */
        totalUpload: number;
        volumeState: number;
    }

    export interface GetGatewayCacheDisksDisk {
        /**
         * The category of eht cache disk.
         */
        cacheDiskCategory: string;
        /**
         * The size of the cache disk.
         */
        cacheDiskSizeInGb: number;
        /**
         * The ID of the cache disk.
         */
        cacheId: string;
        /**
         * The expiration time. Time stamp in seconds (s).
         */
        expiredTime: number;
        /**
         * The ID of the gateway.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway Cache Disk.
         */
        id: string;
        /**
         * Per second of the input output.
         */
        iops: number;
        /**
         * Whether it is used.
         */
        isUsed: boolean;
        /**
         * The cache disk inside the device name.
         */
        localFilePath: string;
        /**
         * A renewal link of the cache disk.
         */
        renewUrl: string;
        /**
         * The status of the resource.
         */
        status: number;
    }

    export interface GetGatewayFileSharesShare {
        /**
         * The set up gateway file share Server Message Block (SMB) protocol, whether to enable Windows ABE, the prime minister, need windowsAcl parameter is set to true in the entry into force of. Default value: `false`. **NOTE:** Gateway version >= 1.0.45 above support.
         */
        accessBasedEnumeration: boolean;
        /**
         * Share the private IP address of the RDS instance.
         */
        address: string;
        /**
         * The set up gateway file share Max upload speed. Unit: `MB/s`, `0` means unlimited. Value range: `0` ~ `1280`. Default value: `0`. **NOTE:** at the same time if you have to limit the maximum write speed, maximum upload speed is no less than the maximum write speed.
         */
        backendLimit: number;
        /**
         * The set up gateway file share Server Message Block (SMB) protocol whether browsable (that is, in the network neighborhood of whether you can find). The parameters in the NFS protocol not valid under. Default value: `true`.
         */
        browsable: boolean;
        /**
         * Multi-Bucket information.
         */
        bucketInfos: string;
        /**
         * Whether there are multiple buckets.
         */
        bucketsStub: boolean;
        /**
         * Direct reading OSS of the gateway file share.
         */
        bypassCacheRead: boolean;
        /**
         * The cache mode of the gateway file share. Value range: Cache: cached mode. Sync: replication mode are available.
         */
        cacheMode: string;
        /**
         * File share is enabled to client-side encryption, the encryption by the use of the KMS key. **NOTE:** note: This KMS key must be the gateway and is in the same Region.
         */
        clientSideCmk: string;
        /**
         * Whether to enabled to client-side encryption of the gateway file share. Default value: `false`. **NOTE:** need to contact us open whitelist before you can the settings, and only supports enhanced more than online gateway, at the same time, server-side encryption and to client-side encryption can not simultaneously configuration.
         */
        clientSideEncryption: boolean;
        /**
         * Whether directio (direct I/O data transfer) is enabled for file share. Default: `false`.
         */
        directIo: boolean;
        /**
         * The ID of the disk.
         */
        diskId: string;
        /**
         * The cache disk type. Valid values: `cloudEfficiency`: Ultra cloud disk. `cloudSsd`:SSD cloud disk.
         */
        diskType: string;
        /**
         * The set up gateway file share maximum download speed. Unit: `MB/s`. `0` means unlimited. Value range: `0` ~ `1280`. **NOTE:** only in copy mode and enable download file data can be set. only when the shared opens the reverse synchronization or acceded to by the speed synchronization Group when, this parameter will not take effect. Gateway version >= 1.3.0 above support.
         */
        downloadLimit: number;
        /**
         * Shared whether the changes take effect.
         */
        enabled: boolean;
        /**
         * Speed synchronization group ID.
         */
        expressSyncId: string;
        /**
         * The set up gateway file share whether to enable Upload optimization, which is suitable for data pure backup migration scenarios. Default value: `false`. **NOTE:** Gateway version >= 1.0.39 above support.
         */
        fastReclaim: boolean;
        /**
         * The set up gateway file share and the maximum write speed. Unit: `MB/s`, `0` means unlimited. Value range: `0` ~ `1280`. Default value: `0`.
         */
        feLimit: number;
        /**
         * Supported by the file system file number.
         */
        fileNumLimit: string;
        /**
         * File system capacity. Unit: `B`.
         */
        fsSizeLimit: string;
        /**
         * The name of the file share. Length from `1` to `255` characters can contain lowercase letters, digits, (.), (_) Or (-), at the same time, must start with a lowercase letter.
         */
        gatewayFileShareName: string;
        /**
         * The ID of the gateway.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway File Share.
         */
        id: string;
        /**
         * Whether to ignore deleted of the gateway file share. After the opening of the Gateway side delete file or delete cloud (OSS) corresponding to the file. Default value: `false`. **NOTE:** Gateway version >= 1.0.40 above support.
         */
        ignoreDelete: boolean;
        /**
         * Whether debris optimization of the gateway file share. Default value: `false`.
         */
        inPlace: boolean;
        /**
         * Cache growth. Unit: `B/s`.
         */
        inRate: string;
        /**
         * The ID of the file share.
         */
        indexId: string;
        /**
         * File share is enabled to client-side encryption, key rotation period of time. Seconds. 0 represents no rotation. Rotation of the value range: `3600` ~ `86400`. Default value: `0`.
         */
        kmsRotatePeriod: number;
        /**
         * The synchronization delay, I.e. gateway local cache sync to Alibaba Cloud Object Storage Service (oss) of the delay time. Unit: `Seconds`. Value range: `5` ~ `120`. Default value: `5`. **NOTE:** Gateway version >= 1.0.40 above support.
         */
        lagPeriod: string;
        /**
         * The cache disk inside the device name.
         */
        localPath: string;
        /**
         * The messages from the queue health types. Valid values: `TopicAndQueueFailure`: A Message Queuing message theme can be accessed during the black hole period. `TopicFailure`: a message theme can be accessed during the black hole period. `MNSFullSyncInit`: full synchronization wait. `MNSFullSyncing`: full synchronization in progress. `QueueFailure`: a message queue can be accessed during the black hole period. `MNSNotEnabled`: Top speed synchronization is not enabled. `MNSHealthy`: sync fine.
         */
        mnsHealth: string;
        /**
         * The set up gateway file share NFS protocol, whether to enable NFS v4 optimization improve Mount Upload efficiency. Default value: `false`. **NOTE:** turns on after I will not support NFS v3 mount the filesystem on a. Gateway version >= 1.2.0 above support.
         */
        nfsV4Optimization: boolean;
        /**
         * Multi-Bucket, removing the Bucket.
         */
        obsoleteBuckets: string;
        /**
         * The name of the Bucket.
         */
        ossBucketName: string;
        /**
         * Whether they are using SSL connect to OSS Bucket.
         */
        ossBucketSsl: boolean;
        /**
         * The set up gateway file share corresponds to the Object Storage SERVICE (OSS), Bucket Endpoint. **NOTE:** distinguish between intranet and internet Endpoint. We recommend that if the OSS Bucket and the gateway is in the same Region is use the RDS intranet IP Endpoint:oss-cn-hangzhou-internal.aliyuncs.com.
         */
        ossEndpoint: string;
        /**
         * The OSS Bucket of type. Valid values: `BucketHealthy`: OSS connectivity. `BucketAccessDenied`: OBJECT STORAGE Service (OSS) access to an exception. `BucketMiscFailure`: OBJECT STORAGE Service (OSS) access to additional exception. `BucketNetworkFailure`: OBJECT STORAGE Service (OSS) access network an exception. `BucketNotExist`: OSS Bucket does not exist. `Nothing returns`: We may not have ever known existed.
         */
        ossHealth: string;
        /**
         * For a cloud-based data is. Unit: `B`.
         */
        ossUsed: string;
        /**
         * Upload speed. Unit: `B/s`.
         */
        outRate: string;
        /**
         * In part mode, the directory path group JSON format.
         */
        partialSyncPaths: string;
        /**
         * The prefix of the OSS.
         */
        pathPrefix: string;
        /**
         * The reverse synchronization time intervals of the gateway file share. Value range: `15` ~ `36000`. **NOTE:** in copy mode + reverse synchronization is enabled Download file data, value range: `3600` ~ `36000`.
         */
        pollingInterval: number;
        /**
         * Share types. Valid values: `SMB`, `NFS`.
         */
        protocol: string;
        /**
         * You can use the metadata space. Unit: `B`.
         */
        remainingMetaSpace: string;
        /**
         * Whether to enable reverse synchronization of the gateway file share. Default value: `false`.
         */
        remoteSync: boolean;
        /**
         * Copy mode, whether to download the file data. Default value: `false`. **NOTE:** only when the shared opens the reverse synchronization or acceded to by the speed synchronization group, this parameter will not take effect.
         */
        remoteSyncDownload: boolean;
        /**
         * The read-only client list. When Protocol NFS is returned when the status is.
         */
        roClientList: string;
        /**
         * The read-only client list. When Protocol for Server Message Block (SMB) to go back to.
         */
        roUserList: string;
        /**
         * Read and write the client list. When Protocol NFS is returned when the status is.
         */
        rwClientList: string;
        /**
         * Read-write user list. When Protocol for Server Message Block (SMB) to go back to.
         */
        rwUserList: string;
        /**
         * File share is enabled server-side encryption, encryption used by the KMS key.
         */
        serverSideCmk: string;
        /**
         * If the OSS Bucket side encryption.
         */
        serverSideEncryption: boolean;
        /**
         * The caching capacity. Unit: `B`.
         */
        size: string;
        /**
         * The set up gateway file share NFS protocol user mapping. Valid values: `none`, `rootSquash`, `allSquash`, `allAnonymous`. Default value: `none`.
         */
        squash: string;
        /**
         * File synchronization types. Valid values: `clean`, `dirty`. `clean`: synchronization is complete. `dirty`: synchronization has not been completed.
         */
        state: string;
        /**
         * Whether to support the archive transparent read.
         */
        supportArchive: boolean;
        /**
         * Full synchronization progress. When the share has been added for a synchronization group, the return parameters are valid, that shared full synchronization progress (0~100). `-2`: indicates that share the Gateway version does not support this feature. `-1`: the share does not occur full synchronization.
         */
        syncProgress: number;
        /**
         * The OSS Bucket to the Gateway total downloads. Unit: `B`.
         */
        totalDownload: string;
        /**
         * The OSS Bucket to the Gateway total Upload amount. Unit: `B`.
         */
        totalUpload: string;
        /**
         * The set up gateway file share whether to enable transmission acceleration needs corresponding OSS Bucket enabled transport acceleration. **NOTE:** Gateway version >= 1.3.0 above support.
         */
        transferAcceleration: boolean;
        /**
         * Used cache. Unit: `B`.
         */
        used: string;
        /**
         * The set up gateway file share Server Message Block (SMB) protocol, whether to enable by Windows access list (requires AD domain) the permissions control. Default value: `false`. **NOTE:** Gateway version >= 1.0.45 above support.
         */
        windowsAcl: boolean;
    }

    export interface GetGatewaySmbUsersUser {
        /**
         * The Gateway ID.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway SMB User.
         */
        id: string;
        /**
         * The username of the Gateway SMB User.
         */
        username: string;
    }

    export interface GetGatewaysGateway {
        /**
         * gateway .
         */
        activatedTime: string;
        buyUrl: string;
        /**
         * gateway category.
         */
        category: string;
        /**
         * gateway created timestamp in second format.
         */
        createTime: string;
        /**
         * gateway description.
         */
        description: string;
        /**
         * gateway ecs instance id.
         */
        ecsInstanceId: string;
        /**
         * gateway expiration status.
         */
        expireStatus: number;
        /**
         * gateway expiration timestamp in second format.
         */
        expiredTime: string;
        /**
         * gateway class.
         */
        gatewayClass: string;
        /**
         * gateway id.
         */
        gatewayId: string;
        /**
         * gateway name.
         */
        gatewayName: string;
        /**
         * gateway version.
         */
        gatewayVersion: string;
        /**
         * The ID of the Gateway.
         */
        id: string;
        /**
         * gateway service ip.
         */
        innerIp: string;
        /**
         * gateway public ip.
         */
        ip: string;
        /**
         * whether subscription gateway is released after expiration or not.
         */
        isReleaseAfterExpiration: boolean;
        /**
         * gateway location.
         */
        location: string;
        /**
         * gateway payment type. The Payment type of gateway. The valid value: `PayAsYouGo`, `Subscription`.
         */
        paymentType: string;
        /**
         * gateway public network bandwidth.
         */
        publicNetworkBandwidth: number;
        renewUrl: string;
        /**
         * gateway status.
         */
        status: string;
        /**
         * storage bundle id.
         */
        storageBundleId: string;
        /**
         * gateway task id.
         */
        taskId: string;
        /**
         * gateway type.
         */
        type: string;
        /**
         * gateway vpc id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetStocksStock {
        /**
         * A list of available gateway class in this Zone ID.
         */
        availableGatewayClasses: string[];
        /**
         * The Zone ID.
         */
        zoneId: string;
    }

    export interface GetStorageBundlesBundle {
        createTime: string;
        description: string;
        id: string;
        location: string;
        storageBundleId: string;
        storageBundleName: string;
    }

}

export namespace cms {
    export interface AlarmEscalationsCritical {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * Critical level alarm statistics method. It must be consistent with that defined for metrics. Valid values: ["Average", "Minimum", "Maximum", "Value", "ErrorCodeMaximum", "Sum", "Count"]. Default to "Average".
         */
        statistics?: string;
        /**
         * Critical level alarm threshold value, which must be a numeric value currently.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmEscalationsInfo {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * Critical level alarm statistics method. It must be consistent with that defined for metrics. Valid values: ["Average", "Minimum", "Maximum", "Value", "ErrorCodeMaximum", "Sum", "Count"]. Default to "Average".
         */
        statistics?: string;
        /**
         * Critical level alarm threshold value, which must be a numeric value currently.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmEscalationsWarn {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * Critical level alarm statistics method. It must be consistent with that defined for metrics. Valid values: ["Average", "Minimum", "Maximum", "Value", "ErrorCodeMaximum", "Sum", "Count"]. Default to "Average".
         */
        statistics?: string;
        /**
         * Critical level alarm threshold value, which must be a numeric value currently.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface DynamicTagGroupMatchExpress {
        /**
         * The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
         */
        tagValue: string;
        /**
         * Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
         */
        tagValueMatchFunction: string;
    }

    export interface GetAlarmContactGroupsGroup {
        /**
         * The name of Alarm Contact Group.
         */
        alarmContactGroupName: string;
        /**
         * The alarm contacts in the alarm group.
         */
        contacts: string[];
        /**
         * The description of the Alarm Group.
         */
        describe: string;
        /**
         * Indicates whether the alarm group subscribes to weekly reports.
         */
        enableSubscribed: boolean;
        /**
         * The ID of the CMS.
         */
        id: string;
    }

    export interface GetAlarmContactsContact {
        /**
         * The name of the alarm contact.
         */
        alarmContactName: string;
        /**
         * The TradeManager ID of the alarm contact.
         */
        channelsAliim: string;
        /**
         * The webhook URL of the DingTalk chatbot.
         */
        channelsDingWebHook: string;
        /**
         * The email address of the alarm contact.
         */
        channelsMail: string;
        /**
         * The phone number of the alarm contact.
         */
        channelsSms: string;
        /**
         * Indicates whether the TradeManager ID is valid.
         */
        channelsStateAliim: string;
        /**
         * Indicates whether the DingTalk chatbot is normal.
         */
        channelsStateDingWebHook: string;
        /**
         * The status of the email address.
         */
        channelsStateMail: string;
        /**
         * The status of the phone number.
         */
        channelsStatusSms: string;
        /**
         * The alert groups to which the alarm contact is added.
         */
        contactGroups: string[];
        /**
         * The description of the alarm contact.
         */
        describe: string;
        /**
         * The ID of the alarm contact.
         */
        id: string;
        lang: string;
    }

    export interface GetDynamicTagGroupsGroup {
        /**
         * The ID of the tag rule.
         */
        dynamicTagRuleId: string;
        /**
         * The ID of the Dynamic Tag Group.
         */
        id: string;
        /**
         * The relationship between conditional expressions. Valid values: `and`, `or`.
         */
        matchExpressFilterRelation: string;
        /**
         * The label generates a matching expression that applies the grouping. See the following `Block matchExpress`.
         */
        matchExpresses: outputs.cms.GetDynamicTagGroupsGroupMatchExpress[];
        /**
         * The status of the resource. Valid values: `RUNNING`, `FINISH`.
         */
        status: string;
        /**
         * The tag key of the tag.
         */
        tagKey: string;
    }

    export interface GetDynamicTagGroupsGroupMatchExpress {
        /**
         * The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
         */
        tagValue: string;
        /**
         * Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
         */
        tagValueMatchFunction: string;
    }

    export interface GetGroupMetricRulesRule {
        /**
         * Alarm contact group.
         */
        contactGroups: string;
        /**
         * The dimensions that specify the resources to be associated with the alert rule.
         */
        dimensions: string;
        /**
         * The time period during which the alert rule is effective.
         */
        effectiveInterval: string;
        /**
         * The subject of the alert notification email.
         */
        emailSubject: string;
        /**
         * Indicates whether the alert rule is enabled.
         */
        enableState: boolean;
        /**
         * Alarm level.
         */
        escalations: outputs.cms.GetGroupMetricRulesRuleEscalation[];
        /**
         * The ID of the application group.
         */
        groupId: string;
        /**
         * The name of the alert rule.
         */
        groupMetricRuleName: string;
        /**
         * The ID of the Group Metric Rule.
         */
        id: string;
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the service.
         */
        namespace: string;
        /**
         * The time period during which the alert rule is ineffective.
         */
        noEffectiveInterval: string;
        /**
         * The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
         */
        period: number;
        /**
         * The resources that are associated with the alert rule.
         */
        resources: string;
        /**
         * The ID of the alert rule.
         */
        ruleId: string;
        /**
         * The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
         */
        silenceTime: number;
        /**
         * The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
         */
        sourceType: string;
        /**
         * The status of Group Metric Rule..
         */
        status: string;
        /**
         * The callback URL.
         */
        webhook: string;
    }

    export interface GetGroupMetricRulesRuleEscalation {
        /**
         * The critical level.
         */
        criticals: outputs.cms.GetGroupMetricRulesRuleEscalationCritical[];
        /**
         * The info level.
         */
        infos: outputs.cms.GetGroupMetricRulesRuleEscalationInfo[];
        /**
         * The warn level.
         */
        warns: outputs.cms.GetGroupMetricRulesRuleEscalationWarn[];
    }

    export interface GetGroupMetricRulesRuleEscalationCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetGroupMetricRulesRuleEscalationInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetGroupMetricRulesRuleEscalationWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetMetricRuleTemplatesTemplate {
        /**
         * The details of alert rules that are generated based on the alert template.
         */
        alertTemplates: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplate[];
        /**
         * The description of the alert template.
         */
        description: string;
        /**
         * GroupId.
         */
        groupId: string;
        /**
         * The ID of the Metric Rule Template.
         */
        id: string;
        /**
         * The name of the alert template.
         */
        metricRuleTemplateName: string;
        /**
         * The version of the alert template.
         */
        restVersion: string;
        /**
         * The ID of the alert template.
         */
        templateId: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplate {
        /**
         * The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iotEdge`, `kvstoreSharding`, `kvstoreSplitrw`, `kvstoreStandard`, `memcache`, `mns`, `mongodb`, `mongodbCluster`, `mongodbSharding`, `mqTopic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
         */
        category: string;
        /**
         * The information about the trigger condition based on the alert level.
         */
        escalations: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalation[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the service.
         */
        namespace: string;
        /**
         * The name of the alert rule.
         */
        ruleName: string;
        selector: string;
        /**
         * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
         */
        webhook: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalation {
        /**
         * The condition for triggering critical-level alerts.
         */
        criticals: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCritical[];
        /**
         * The condition for triggering info-level alerts.
         */
        infos: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfo[];
        /**
         * The condition for triggering warn-level alerts.
         */
        warns: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarn[];
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalationCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level
         * alert is triggered.
         */
        times: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level
         * alert is triggered.
         */
        times: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level
         * alert is triggered.
         */
        times: string;
    }

    export interface GetMonitorGroupInstancesInstance {
        instances: outputs.cms.GetMonitorGroupInstancesInstanceInstance[];
    }

    export interface GetMonitorGroupInstancesInstanceInstance {
        category: string;
        instanceId: string;
        instanceName: string;
        regionId: string;
    }

    export interface GetMonitorGroupsGroup {
        /**
         * The URL of the Kubernetes cluster from which the application group is synchronized.
         */
        bindUrl: string;
        /**
         * The list of  alert groups that receive alert notifications for the application group.
         */
        contactGroups: string[];
        /**
         * The ID of the tag rule.
         */
        dynamicTagRuleId: string;
        /**
         * The time when the application group was created.
         */
        gmtCreate: number;
        /**
         * The time when the application group was modified.
         */
        gmtModified: number;
        /**
         * The ID of the application group.
         */
        groupId: string;
        /**
         * The ID of the Monitor Group.
         */
        id: string;
        /**
         * The name of the application group.
         */
        monitorGroupName: string;
        /**
         * The ID of the Alibaba Cloud service.
         */
        serviceId: string;
        /**
         * A map of tags assigned to the Cms Monitor Group.
         */
        tags: {[key: string]: any};
        /**
         * The alert templates applied to the application group.
         */
        templateIds: string[];
        /**
         * The type of the application group.
         */
        type: string;
    }

    export interface GroupMetricRuleEscalations {
        /**
         * The critical level.
         */
        critical?: outputs.cms.GroupMetricRuleEscalationsCritical;
        /**
         * The info level.
         */
        info?: outputs.cms.GroupMetricRuleEscalationsInfo;
        /**
         * The warn level.
         */
        warn?: outputs.cms.GroupMetricRuleEscalationsWarn;
    }

    export interface GroupMetricRuleEscalationsCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleEscalationsInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleEscalationsWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: number;
    }

    export interface MetricRuleTemplateAlertTemplate {
        /**
         * The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iotEdge`, `kvstoreSharding`, `kvstoreSplitrw`, `kvstoreStandard`, `memcache`, `mns`, `mongodb`, `mongodbCluster`, `mongodbSharding`, `mqTopic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
         */
        category: string;
        /**
         * The information about the trigger condition based on the alert level. See the following `Block escalations`.
         */
        escalations?: outputs.cms.MetricRuleTemplateAlertTemplateEscalations;
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the service.
         */
        namespace: string;
        /**
         * The name of the alert rule.
         */
        ruleName: string;
        /**
         * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
         */
        webhook?: string;
    }

    export interface MetricRuleTemplateAlertTemplateEscalations {
        /**
         * The condition for triggering critical-level alerts. See the following `Block critical`.
         */
        critical?: outputs.cms.MetricRuleTemplateAlertTemplateEscalationsCritical;
        /**
         * The condition for triggering info-level alerts. See the following `Block info`.
         */
        info?: outputs.cms.MetricRuleTemplateAlertTemplateEscalationsInfo;
        /**
         * The condition for triggering warn-level alerts. See the following `Block warn`.
         */
        warn?: outputs.cms.MetricRuleTemplateAlertTemplateEscalationsWarn;
    }

    export interface MetricRuleTemplateAlertTemplateEscalationsCritical {
        /**
         * The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for critical-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for critical-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
         */
        times?: string;
    }

    export interface MetricRuleTemplateAlertTemplateEscalationsInfo {
        /**
         * The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for critical-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for critical-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
         */
        times?: string;
    }

    export interface MetricRuleTemplateAlertTemplateEscalationsWarn {
        /**
         * The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for critical-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for critical-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
         */
        times?: string;
    }

    export interface MonitorGroupInstancesInstance {
        /**
         * The category of instance.
         */
        category: string;
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The region id of instance.
         */
        regionId: string;
    }

    export interface SiteMonitorIspCity {
        city: string;
        isp: string;
    }

}

export namespace config {
    export interface AssumeRole {
        policy?: string;
        roleArn: string;
        sessionExpiration?: number;
        sessionName?: string;
    }

    export interface Endpoints {
        acr?: string;
        actiontrail?: string;
        adb?: string;
        alb?: string;
        alidfs?: string;
        alidns?: string;
        alikafka?: string;
        apigateway?: string;
        arms?: string;
        bastionhost?: string;
        brainIndustrial?: string;
        bssopenapi?: string;
        cas?: string;
        cassandra?: string;
        cbn?: string;
        cddc?: string;
        cdn?: string;
        cds?: string;
        clickhouse?: string;
        cloudauth?: string;
        cloudphone?: string;
        cloudsso?: string;
        cms?: string;
        config?: string;
        cr?: string;
        cs?: string;
        datahub?: string;
        dataworkspublic?: string;
        dbfs?: string;
        dcdn?: string;
        ddosbgp?: string;
        ddoscoo?: string;
        dds?: string;
        devopsrdc?: string;
        dg?: string;
        dm?: string;
        dmsEnterprise?: string;
        dns?: string;
        drds?: string;
        dts?: string;
        eais?: string;
        eci?: string;
        ecs?: string;
        edsuser?: string;
        ehpc?: string;
        eipanycast?: string;
        elasticsearch?: string;
        emr?: string;
        ens?: string;
        ess?: string;
        eventbridge?: string;
        fc?: string;
        fnf?: string;
        ga?: string;
        gaplus?: string;
        gds?: string;
        gpdb?: string;
        gwsecd?: string;
        hbr?: string;
        hcsSgw?: string;
        hitsdb?: string;
        imm?: string;
        imp?: string;
        ims?: string;
        iot?: string;
        kms?: string;
        kvstore?: string;
        location?: string;
        log?: string;
        market?: string;
        maxcompute?: string;
        mhub?: string;
        mns?: string;
        mscopensubscription?: string;
        mse?: string;
        nas?: string;
        ons?: string;
        onsproxy?: string;
        oos?: string;
        opensearch?: string;
        oss?: string;
        ots?: string;
        polardb?: string;
        privatelink?: string;
        pvtz?: string;
        quickbi?: string;
        quotas?: string;
        rKvstore?: string;
        ram?: string;
        rds?: string;
        redisa?: string;
        resourcemanager?: string;
        resourcesharing?: string;
        ros?: string;
        sas?: string;
        scdn?: string;
        sddp?: string;
        serverless?: string;
        servicemesh?: string;
        sgw?: string;
        slb?: string;
        sts?: string;
        swas?: string;
        vod?: string;
        vpc?: string;
        vs?: string;
        waf?: string;
        wafOpenapi?: string;
    }

}

export namespace cr {
    export interface GetChartNamespacesNamespace {
        /**
         * Indicates whether a repository is automatically created when an image is pushed to the namespace.
         */
        autoCreateRepo: boolean;
        /**
         * The ID of the namespace.
         */
        chartNamespaceId: string;
        /**
         * The default repository type. Valid values: `PUBLIC`,`PRIVATE`.
         */
        defaultRepoType: string;
        /**
         * The ID of the Chart Namespace.
         */
        id: string;
        /**
         * The ID of the namespace.
         */
        instanceId: string;
        /**
         * The name of the namespace.
         */
        namespaceName: string;
    }

    export interface GetChartRepositoriesRepository {
        /**
         * The first ID of the resource.
         */
        chartRepositoryId: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Chart Repository.
         */
        id: string;
        /**
         * The ID of the Container Registry instance.
         */
        instanceId: string;
        /**
         * The name of the repository.
         */
        repoName: string;
        /**
         * The namespace to which the repository belongs.
         */
        repoNamespaceName: string;
        /**
         * The type of the repository. Valid values: `PUBLIC`,`PRIVATE`.
         */
        repoType: string;
        /**
         * The summary about the repository.
         */
        summary: string;
    }

    export interface GetEndpointAclPoliciesPolicy {
        /**
         * The description of the entry.
         */
        description: string;
        /**
         * The type of endpoint.
         */
        endpointType: string;
        /**
         * The IP segment that allowed to access.
         */
        entry: string;
        /**
         * The ID of the Endpoint Acl Policy.
         */
        id: string;
        /**
         * The ID of the CR Instance.
         */
        instanceId: string;
    }

    export interface GetNamespacesNamespace {
        /**
         * Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
         */
        autoCreate: boolean;
        /**
         * `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
         */
        defaultVisibility: string;
        /**
         * Name of Container Registry namespace.
         */
        name: string;
    }

    export interface GetReposRepo {
        /**
         * The repository domain list.
         */
        domainList: outputs.cr.GetReposRepoDomainList;
        /**
         * Name of container registry namespace.
         */
        name: string;
        /**
         * Name of container registry namespace where the repositories are located in.
         */
        namespace: string;
        /**
         * `PUBLIC` or `PRIVATE`, repository's visibility.
         */
        repoType: string;
        /**
         * The repository general information.
         */
        summary: string;
        /**
         * A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
         */
        tags: outputs.cr.GetReposRepoTag[];
    }

    export interface GetReposRepoDomainList {
        /**
         * Domain of internal endpoint, only in some regions.
         */
        internal: string;
        /**
         * Domain of public endpoint.
         */
        public: string;
        /**
         * Domain of vpc endpoint.
         */
        vpc: string;
    }

    export interface GetReposRepoTag {
        /**
         * Digest of this image.
         */
        digest: string;
        /**
         * Create time of this image, unix time in nanoseconds.
         */
        imageCreate: number;
        /**
         * Id of this image.
         */
        imageId: string;
        /**
         * Status of this image, in bytes.
         */
        imageSize: number;
        /**
         * Last update time of this image, unix time in nanoseconds.
         */
        imageUpdate: number;
        /**
         * Status of this image.
         */
        status: string;
        /**
         * Tag of this image.
         */
        tag: string;
    }

    export interface RepoDomainList {
        /**
         * Domain of internal endpoint, only in some regions.
         */
        internal: string;
        /**
         * Domain of public endpoint.
         */
        public: string;
        /**
         * Domain of vpc endpoint.
         */
        vpc: string;
    }
}

export namespace cs {
    export interface ApplicationService {
        id: string;
        name: string;
        status: string;
        version: string;
    }

    export interface ClusterNode {
        eip: string;
        id: string;
        name: string;
        privateIp: string;
        status: string;
    }

    export interface EdgeKubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface EdgeKubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface EdgeKubernetesConnections {
        apiServerInternet: string;
        apiServerIntranet: string;
        masterPublicIp: string;
        serviceDomain: string;
    }

    export interface EdgeKubernetesLogConfig {
        project?: string;
        type: string;
    }

    export interface EdgeKubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface EdgeKubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetEdgeKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetEdgeKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetEdgeKubernetesClustersClusterWorkerNode[];
    }

    export interface GetEdgeKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
    }

    export interface GetEdgeKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesAddonsAddon {
        /**
         * The current version of addon, if this field is an empty string, it means that the addon is not installed.
         */
        currentVersion: string;
        /**
         * The name of addon.
         */
        name: string;
        /**
         * The next version of this addon can be upgraded to.
         */
        nextVersion: string;
        /**
         * Whether the addon is a system addon.
         */
        required: boolean;
    }

    export interface GetKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        clusterNetworkType: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The ID of node image.
         */
        imageId: string;
        /**
         * The keypair of ssh login cluster node, you have to create it first.
         */
        keyName: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfigs: outputs.cs.GetKubernetesClustersClusterLogConfig[];
        masterAutoRenew: boolean;
        masterAutoRenewPeriod: number;
        /**
         * The system disk category of master node.
         */
        masterDiskCategory: string;
        /**
         * The system disk size of master node.
         */
        masterDiskSize: number;
        masterInstanceChargeType: string;
        /**
         * The instance type of master node.
         */
        masterInstanceTypes: string[];
        /**
         * List of cluster master nodes. It contains several attributes to `Block Nodes`.
         */
        masterNodes: outputs.cs.GetKubernetesClustersClusterMasterNode[];
        masterPeriod: number;
        masterPeriodUnit: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The network mask used on pods for each node.
         */
        nodeCidrMask: number;
        podCidr: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        serviceCidr: string;
        /**
         * Whether internet load balancer for API Server is created
         */
        slbInternetEnabled: boolean;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitches where the current cluster is located.
         */
        vswitchIds: string[];
        workerAutoRenew: boolean;
        workerAutoRenewPeriod: number;
        /**
         * The data disk size of worker node.
         */
        workerDataDiskCategory: string;
        /**
         * The data disk category of worker node.
         */
        workerDataDiskSize: number;
        /**
         * The system disk category of worker node.
         */
        workerDiskCategory: string;
        /**
         * The system disk size of worker node.
         */
        workerDiskSize: number;
        workerInstanceChargeType: string;
        /**
         * The instance type of worker node.
         */
        workerInstanceTypes: string[];
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetKubernetesClustersClusterWorkerNode[];
        /**
         * The ECS instance node number in the current container cluster.
         */
        workerNumbers: number[];
        workerPeriod: number;
        workerPeriodUnit: string;
    }

    export interface GetKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface GetKubernetesClustersClusterLogConfig {
        /**
         * Log Service project name.
         */
        project: string;
        /**
         * Type of collecting logs.
         */
        type: string;
    }

    export interface GetKubernetesClustersClusterMasterNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesPermissionPermission {
        /**
         * ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
         * * `isRamRole` -Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
         */
        isOwner?: boolean;
        isRamRole?: boolean;
        /**
         * The permission settings to manage ACK clusters.
         */
        resourceId: string;
        /**
         * The authorization type. Valid values `cluster`, `namespace` and `console`.
         */
        resourceType: string;
        /**
         * The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
         */
        roleName: string;
        /**
         * The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
         */
        roleType?: string;
    }

    export interface GetManagedKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        clusterNetworkType: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetManagedKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        imageId: string;
        /**
         * The keypair of ssh login cluster node, you have to create it first.
         */
        keyName: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfigs: outputs.cs.GetManagedKubernetesClustersClusterLogConfig[];
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        podCidr: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        serviceCidr: string;
        slbInternetEnabled: boolean;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitches where the current cluster is located.
         */
        vswitchIds: string[];
        workerAutoRenew: boolean;
        workerAutoRenewPeriod: number;
        workerDataDiskCategory: string;
        workerDataDiskSize: number;
        workerDiskCategory: string;
        workerDiskSize: number;
        workerInstanceChargeType: string;
        workerInstanceTypes: string[];
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetManagedKubernetesClustersClusterWorkerNode[];
        /**
         * The ECS instance node number in the current container cluster.
         */
        workerNumbers: number[];
        workerPeriod: number;
        workerPeriodUnit: string;
    }

    export interface GetManagedKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface GetManagedKubernetesClustersClusterLogConfig {
        /**
         * Log Service project name.
         */
        project: string;
        /**
         * Type of collecting logs.
         */
        type: string;
    }

    export interface GetManagedKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetRegistryEnterpriseInstancesInstance {
        /**
         * The password that was used to log on to the registry.
         */
        authorizationToken: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        id: string;
        /**
         * Name of Container Registry Enterprise Edition instance.
         */
        name: string;
        /**
         * The max number of namespaces that an instance can create.
         */
        namespaceQuota: string;
        /**
         * The number of namespaces already created.
         */
        namespaceUsage: string;
        /**
         * A list of domains for access on internet network.
         */
        publicEndpoints: string[];
        /**
         * Region of Container Registry Enterprise Edition instance.
         */
        region: string;
        /**
         * The max number of repos that an instance can create.
         */
        repoQuota: string;
        /**
         * The number of repos already created.
         */
        repoUsage: string;
        /**
         * Specification of Container Registry Enterprise Edition instance.
         */
        specification: string;
        /**
         * The username that was used to log on to the registry.
         */
        tempUsername: string;
        /**
         * A list of domains for access on vpc network.
         */
        vpcEndpoints: string[];
    }

    export interface GetRegistryEnterpriseNamespacesNamespace {
        /**
         * Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
         */
        autoCreate: boolean;
        /**
         * `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
         */
        defaultVisibility: string;
        /**
         * ID of Container Registry Enterprise Edition namespace.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition namespace.
         */
        name: string;
    }

    export interface GetRegistryEnterpriseReposRepo {
        /**
         * ID of Container Registry Enterprise Edition repository.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition repository.
         */
        name: string;
        /**
         * Name of Container Registry Enterprise Edition namespace where the repositories are located in.
         */
        namespace: string;
        /**
         * `PUBLIC` or `PRIVATE`, repository's visibility.
         */
        repoType: string;
        /**
         * The repository general information.
         */
        summary: string;
        /**
         * A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
         */
        tags: outputs.cs.GetRegistryEnterpriseReposRepoTag[];
    }

    export interface GetRegistryEnterpriseReposRepoTag {
        /**
         * Digest of this image.
         */
        digest: string;
        /**
         * Create time of this image, unix time in nanoseconds.
         */
        imageCreate: string;
        /**
         * Id of this image.
         */
        imageId: string;
        /**
         * Status of this image, in bytes.
         */
        imageSize: number;
        /**
         * Last update time of this image, unix time in nanoseconds.
         */
        imageUpdate: string;
        /**
         * Status of this image.
         */
        status: string;
        /**
         * Tag of this image.
         */
        tag: string;
    }

    export interface GetRegistryEnterpriseSyncRulesRule {
        /**
         * ID of Container Registry Enterprise Edition sync rule.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition local instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition sync rule.
         */
        name: string;
        /**
         * Name of Container Registry Enterprise Edition local namespace.
         */
        namespaceName: string;
        /**
         * Region of Container Registry Enterprise Edition local instance.
         */
        regionId: string;
        /**
         * Name of Container Registry Enterprise Edition local repo.
         */
        repoName: string;
        /**
         * `FROM` or `TO`, the direction of synchronization. `FROM` indicates that the local instance is the source instance. `TO` indicates that the local instance is the target instance to be synchronized.
         */
        syncDirection: string;
        /**
         * `REPO` or `NAMESPACE`,the scope that the synchronization rule applies.
         */
        syncScope: string;
        /**
         * `PASSIVE` or `INITIATIVE`, the policy configured to trigger the synchronization rule.
         */
        syncTrigger: string;
        /**
         * The regular expression used to filter image tags for synchronization in the source repository.
         */
        tagFilter: string;
        /**
         * ID of Container Registry Enterprise Edition target instance.
         */
        targetInstanceId: string;
        /**
         * Name of Container Registry Enterprise Edition target namespace.
         */
        targetNamespaceName: string;
        /**
         * Region of Container Registry Enterprise Edition target instance.
         */
        targetRegionId: string;
        /**
         * Name of Container Registry Enterprise Edition target repo.
         */
        targetRepoName: string;
    }

    export interface GetServerlessKubernetesClustersCluster {
        /**
         * Map of serverless cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetServerlessKubernetesClustersClusterConnections;
        /**
         * Whether the cluster support delete protection.
         */
        deletionProtection: boolean;
        endpointPublicAccessEnabled: boolean;
        /**
         * The ID of the container cluster.
         */
        id: string;
        /**
         * The name of the container cluster.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The ID of security group where the current cluster  is located.
         */
        securityGroupId: string;
        tags: {[key: string]: any};
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitch where the current cluster is located.
         */
        vswitchId: string;
    }

    export interface GetServerlessKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
    }

    export interface KubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface KubernetesAutoscalerNodepool {
        id?: string;
        labels?: string;
        taints?: string;
    }

    export interface KubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface KubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface KubernetesMasterNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface KubernetesPermissionPermission {
        /**
         * The ID of the cluster that you want to manage.
         */
        cluster: string;
        /**
         * Specifies whether to perform a custom authorization. To perform a custom authorization, set `roleName` to a custom cluster role.
         */
        isCustom?: boolean;
        /**
         * Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `isRamRole` must be `true`.
         */
        isRamRole?: boolean;
        /**
         * The namespace to which the permissions are scoped. This parameter is required only if you set roleType to namespace.
         */
        namespace?: string;
        /**
         * Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
         */
        roleName: string;
        /**
         * The authorization type. Valid values `cluster`, `namespace`.
         */
        roleType: string;
    }

    export interface KubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface KubernetesTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface KubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface KubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface ManagedKubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface ManagedKubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface ManagedKubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface ManagedKubernetesMaintenanceWindow {
        /**
         * The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
         */
        duration: string;
        /**
         * Whether to open the maintenance window. The following parameters take effect only `enable = true`.
         */
        enable: boolean;
        /**
         * Initial maintenance time, For example:"03:00:00Z".
         */
        maintenanceTime: string;
        /**
         * Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
         */
        weeklyPeriod: string;
    }

    export interface ManagedKubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface ManagedKubernetesTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface ManagedKubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface ManagedKubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface NodePoolDataDisk {
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values:`cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The name of node pool.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
         */
        size?: number;
        snapshotId?: string;
    }

    export interface NodePoolLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface NodePoolManagement {
        /**
         * Whether automatic repair, Default to `false`.
         */
        autoRepair?: boolean;
        /**
         * Whether auto upgrade, Default to `false`.
         */
        autoUpgrade?: boolean;
        /**
         * Max number of unavailable nodes. Default to `1`.
         */
        maxUnavailable: number;
        /**
         * Number of additional nodes. You have to specify one of surge, surge_percentage.
         */
        surge?: number;
        /**
         * Proportion of additional nodes. You have to specify one of surge, surge_percentage.
         */
        surgePercentage?: number;
    }

    export interface NodePoolScalingConfig {
        /**
         * Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
         */
        eipBandwidth?: number;
        /**
         * EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internetChargeType`, EIP and public network IP can only choose one.
         */
        eipInternetChargeType?: string;
        /**
         * Whether to bind EIP for an instance. Default: `false`.
         */
        isBondEip?: boolean;
        /**
         * Max number of instances in a auto scaling group, its valid value range [0~1000]. `maxSize` has to be greater than `minSize`.
         */
        maxSize: number;
        /**
         * Min number of instances in a auto scaling group, its valid value range [0~1000].
         */
        minSize: number;
        /**
         * Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instanceTypes`.
         */
        type?: string;
    }

    export interface NodePoolSpotPriceLimit {
        /**
         * Spot instance type.
         */
        instanceType?: string;
        /**
         * The maximum hourly price of the spot instance.
         */
        priceLimit?: string;
    }

    export interface NodePoolTaint {
        effect?: string;
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface ServerlessKubernetesAddon {
        /**
         * The ACK add-on configurations.
         */
        config?: string;
        /**
         * Disables the automatic installation of a component. Default is `false`.
         */
        disabled?: boolean;
        /**
         * Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
         */
        name?: string;
    }

    export interface SwarmNode {
        eip: string;
        id: string;
        name: string;
        privateIp: string;
        status: string;
    }

}

export namespace databasefilesystem {
    export interface GetInstancesInstance {
        /**
         * the number of nodes of the Database file system.
         */
        attachNodeNumber: number;
        /**
         * The type of the Database file system. Valid values: `standard`.
         */
        category: string;
        /**
         * The create time of the Database file system.
         */
        createTime: string;
        /**
         * The cluster ID of the Database file system.
         */
        dbfsClusterId: string;
        /**
         * The collection of ECS instances mounted to the Database file system.
         */
        ecsLists: outputs.databasefilesystem.GetInstancesInstanceEcsList[];
        /**
         * Whether to create the Database file system in RAID way. Valid values : `true` anf `false`.
         */
        enableRaid: boolean;
        /**
         * Whether to encrypt the Database file system. Valid values: `true` and `false`.
         */
        encryption: boolean;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the Database File System
         */
        instanceId: string;
        /**
         * The name of the Database file system.
         */
        instanceName: string;
        /**
         * The KMS key ID of the Database file system used. This parameter is valid When `encryption` parameter is set to `true`.
         */
        kmsKeyId: string;
        /**
         * Thr payment type of the Database file system. Valid value: `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * The performance level of the Database file system. Valid values: `PL0`, `PL1`, `PL2`, `PL3`.
         */
        performanceLevel: string;
        /**
         * The number of strip . When `enableRaid` parameter is set to `true` will transfer. This parameter is valid When `enableRaid` parameter is set to `true`.
         */
        raidStripeUnitNumber: string;
        /**
         * The size Of the Database file system. Unit: GiB.
         */
        size: number;
        /**
         * The status of the Database file system.
         */
        status: string;
        /**
         * The Zone ID of the Database file system.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceEcsList {
        /**
         * The ID of the ECS instance.
         */
        ecsId: string;
    }

    export interface InstanceEcsList {
        /**
         * The ID of the ECS instance.
         */
        ecsId?: string;
    }

}

export namespace databasegateway {
    export interface GetGatewaysGateway {
        /**
         * The creation time of Gateway.
         */
        createTime: string;
        /**
         * The description of Gateway.
         */
        gatewayDesc: string;
        gatewayInstances: outputs.databasegateway.GetGatewaysGatewayGatewayInstance[];
        /**
         * The name of the Gateway.
         */
        gatewayName: string;
        /**
         * A host of information.
         */
        hosts: string;
        /**
         * The ID of Gateway.
         */
        id: string;
        /**
         * The Modify time of Gateway.
         */
        modifiedTime: string;
        /**
         * The parent node Id of Gateway.
         */
        parentId: string;
        /**
         * The status of gateway. Valid values: `EXCEPTION`, `NEW`, `RUNNING`, `STOPPED`.
         */
        status: string;
        /**
         * The user's id.
         */
        userId: string;
    }

    export interface GetGatewaysGatewayGatewayInstance {
        /**
         * The connection type of Gateway instance.
         */
        connectEndpointType: string;
        /**
         * The process of version number of Gateway instance.
         */
        currentDaemonVersion: string;
        /**
         * The version of Gateway instance.
         */
        currentVersion: string;
        /**
         * The endpoint address of Gateway instance.
         */
        endPoint: string;
        /**
         * The id of Gateway instance.
         */
        gatewayInstanceId: string;
        /**
         * The status of Gateway instance. Valid values: `EXCEPTION`, `NEW`, `RUNNING`, `STOPPED`.
         */
        gatewayInstanceStatus: string;
        /**
         * The last Updated time stamp of Gateway instance.
         */
        lastUpdateTime: string;
        /**
         * The Local IP ADDRESS of Gateway instance.
         */
        localIp: string;
        /**
         * The prompt information of Gateway instance.
         */
        message: string;
        /**
         * The host of Gateway instance.
         */
        outputIp: string;
    }

}

export namespace dataworks {
    export interface GetFoldersFolder {
        folderId: string;
        /**
         * Folder Path.
         */
        folderPath: string;
        /**
         * The Folder ID.
         */
        id: string;
        /**
         * The ID of the project.
         */
        projectId: string;
    }

}

export namespace dcdn {
    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainSource {
        /**
         * The origin address.
         */
        content: string;
        /**
         * The port number. Valid values: `443` and `80`. Default to `80`.
         */
        port?: number;
        /**
         * The priority of the origin if multiple origins are specified. Default to `20`.
         */
        priority?: string;
        /**
         * The type of the origin. Valid values:
         * `ipaddr`: The origin is configured using an IP address.
         * `domain`: The origin is configured using a domain name.
         * `oss`: The origin is configured using the Internet domain name of an Alibaba Cloud Object Storage Service (OSS) bucket.
         */
        type: string;
        /**
         * The weight of the origin if multiple origins are specified. Default to `10`.
         */
        weight?: string;
    }

    export interface GetDomainsDomain {
        /**
         * Indicates the name of the certificate.
         */
        certName: string;
        /**
         * The canonical name (CNAME) of the accelerated domain.
         */
        cname: string;
        /**
         * The reason that causes the review failure.
         */
        description: string;
        /**
         * The name of the DCDN Domain.
         */
        domainName: string;
        /**
         * The time when the accelerated domain was last modified.
         */
        gmtModified: string;
        /**
         * The ID of the DCDN Domain.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The acceleration region.
         */
        scope: string;
        /**
         * The origin information.
         */
        sources: outputs.dcdn.GetDomainsDomainSource[];
        /**
         * Indicates whether the SSL certificate is enabled.
         */
        sslProtocol: string;
        /**
         * Indicates the public key of the certificate.
         */
        sslPub: string;
        /**
         * The status of DCDN Domain.
         */
        status: string;
    }

    export interface GetDomainsDomainSource {
        /**
         * The origin address.
         */
        content: string;
        /**
         * The status of the origin.
         */
        enabled: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The priority of the origin if multiple origins are specified.
         */
        priority: string;
        /**
         * The type of the origin. Valid values:
         */
        type: string;
        /**
         * The weight of the origin if multiple origins are specified.
         */
        weight: string;
    }

}

export namespace ddos {
    export interface DomainResourceProxyType {
        /**
         * the port number. This field is required and must be an integer.
         */
        proxyPorts?: number[];
        /**
         * the protocol type. This field is required and must be a string. Valid values: `http`, `https`, `websocket`, and `websockets`.
         */
        proxyType?: string;
    }

    export interface GetDdosBgpInstancesInstance {
        /**
         * The instance's elastic defend bandwidth.
         */
        bandwidth: number;
        /**
         * The instance's base defend bandwidth.
         */
        baseBandwidth: number;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's count of ip config.
         */
        ipCount: number;
        /**
         * The instance's IP version.
         */
        ipType: string;
        /**
         * The instance's remark.
         */
        name: string;
        /**
         * A region of instance.
         */
        region: string;
        /**
         * The instance's type.
         */
        type: string;
    }

    export interface GetDdosCooDomainResourcesResource {
        /**
         * The IP addresses in the blacklist for the domain name.
         */
        blackLists: string[];
        /**
         * Whether frequency control guard (CC guard) is enabled. Values: `True`: Opened, `False`: Not enabled.
         */
        ccEnabled: boolean;
        /**
         * Whether custom frequency control guard (CC guard) is enabled. Values: `True`: Opened, `False`: Not enabled.
         */
        ccRuleEnabled: boolean;
        /**
         * The mode of the Frequency Control policy.
         */
        ccTemplate: string;
        /**
         * The name of the certificate.
         */
        certName: string;
        /**
         * The domain name of the website that you want to add to the instance.
         */
        domain: string;
        /**
         * Whether Http2.0 is enabled.
         */
        http2Enable: boolean;
        /**
         * The advanced HTTPS settings.
         */
        httpsExt: string;
        /**
         * The ID of the Domain Resource.
         */
        id: string;
        /**
         * A list ID of instance that you want to associate.
         */
        instanceIds: string[];
        /**
         * The type of backload algorithm.
         */
        policyMode: string;
        /**
         * Whether the website service forwarding rules have been turned on.
         */
        proxyEnabled: boolean;
        /**
         * Protocol type and port number information.
         */
        proxyTypes: outputs.ddos.GetDdosCooDomainResourcesResourceProxyType[];
        /**
         * Server address information of the source station.
         */
        realServers: string[];
        /**
         * Server address type.
         */
        rsType: number;
        /**
         * The type of the cipher suite.
         */
        sslCiphers: string;
        /**
         * The version of the TLS protocol.
         */
        sslProtocols: string;
        /**
         * The IP addresses in the whitelist for the domain name.
         */
        whiteLists: string[];
    }

    export interface GetDdosCooDomainResourcesResourceProxyType {
        /**
         * The forwarding port.
         */
        proxyPorts: number[];
        /**
         * Protocol type.
         */
        proxyType: string;
    }

    export interface GetDdosCooInstancesInstance {
        /**
         * The instance's elastic defend bandwidth.
         */
        bandwidth: number;
        /**
         * The instance's base defend bandwidth.
         */
        baseBandwidth: number;
        /**
         * The creation time of the instance.
         */
        createTime: number;
        /**
         * The debt status of the instance.
         */
        debtStatus: number;
        /**
         * The instance's count of domain retransmission config.
         */
        domainCount: number;
        /**
         * The edition of the instance. The Valid Values : `0`, `1`, `2`, `9`.
         */
        edition: number;
        /**
         * The enabled of the instance. The Valid Values : `0`, `1`.
         */
        enabled: number;
        /**
         * The expiry time of the instance.
         */
        expireTime: number;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The ip mode of the instance. The Valid Values : `fnat`, `v6tov4`.
         */
        ipMode: string;
        /**
         * The ip version of the instance. The Valid Values : `Ipv4`, `Ipv6`.
         */
        ipVersion: string;
        /**
         * The instance's remark.
         */
        name: string;
        /**
         * The instance's count of port retransmission config.
         */
        portCount: number;
        /**
         * The remark of the instance.
         */
        remark: string;
        /**
         * The instance's business bandwidth.
         */
        serviceBandwidth: number;
        /**
         * The status of the instance. The Valid Values : `1`, `2`.
         */
        status: number;
    }

    export interface GetDdosCooPortsPort {
        /**
         * The source station port.
         */
        backendPort: string;
        /**
         * The forwarding port.
         */
        frontendPort: string;
        /**
         * The forwarding protocol.
         */
        frontendProtocol: string;
        /**
         * The ID of the Port.
         */
        id: string;
        /**
         * The Ddoscoo instance ID.
         */
        instanceId: string;
        /**
         * List of source IP addresses.
         */
        realServers: string[];
    }

    export interface SchedulerRuleRule {
        priority?: number;
        regionId?: string;
        status: number;
        type?: string;
        value?: string;
        valueType?: number;
    }
}

export namespace dds {
    export interface GetMongoInstancesInstance {
        availabilityZone: string;
        chargeType: string;
        creationTime: string;
        engine: string;
        engineVersion: string;
        expirationTime: string;
        id: string;
        instanceClass: string;
        instanceType: string;
        lockMode: string;
        mongos: outputs.dds.GetMongoInstancesInstanceMongo[];
        name: string;
        networkType: string;
        regionId: string;
        replication: string;
        shards: outputs.dds.GetMongoInstancesInstanceShard[];
        status: string;
        storage: number;
        tags: {[key: string]: any};
    }

    export interface GetMongoInstancesInstanceMongo {
        class: string;
        description: string;
        nodeId: string;
    }

    export interface GetMongoInstancesInstanceShard {
        class: string;
        description: string;
        nodeId: string;
        storage: number;
    }

}

export namespace dfs {
    export interface GetAccessGroupsGroup {
        /**
         * The length of `description` does not exceed 100 bytes.
         */
        accessGroupId: string;
        /**
         * The Name of Access Group. The length Of `accessGroupName` does not exceed 100 bytes.
         */
        accessGroupName: string;
        /**
         * The CreateTime of Access Group.
         */
        createTime: string;
        /**
         * The Description of Access Group. The length Of `description` does not exceed 100 bytes.
         */
        description: string;
        /**
         * The ID of the Access Group.
         */
        id: string;
        /**
         * The Number of attached mountpoint.
         */
        mountPointCount: number;
        /**
         * The NetworkType of Access Group. Valid values: `VPC`.
         */
        networkType: string;
        /**
         * The Number of access rule.
         */
        ruleCount: number;
    }

    export interface GetAccessRulesRule {
        /**
         * The resource ID of the Access Group.
         */
        accessGroupId: string;
        /**
         * The ID of the Access Rule.
         */
        accessRuleId: string;
        /**
         * The created time of the Access Rule.
         */
        createTime: string;
        /**
         * The description of the Access Rule.
         */
        description: string;
        /**
         * The resource ID of Access Rule.
         */
        id: string;
        /**
         * The NetworkSegment of the Access Rule.
         */
        networkSegment: string;
        /**
         * The priority of the Access Rule.
         */
        priority: number;
        /**
         * RWAccessType of the Access Rule. Valid values: `RDONLY`, `RDWR`.
         */
        rwAccessType: string;
    }

    export interface GetFileSystemsSystem {
        /**
         * The creation time of the File system.
         */
        createTime: string;
        /**
         * The description of the File system.
         */
        description: string;
        /**
         * The ID of the File System.
         */
        fileSystemId: string;
        /**
         * The name of the File system.
         */
        fileSystemName: string;
        /**
         * The ID of the File System.
         */
        id: string;
        /**
         * The number of Mount points.
         */
        mountPointCount: number;
        /**
         * The number of directories.
         */
        numberOfDirectories: number;
        /**
         * The number of files.
         */
        numberOfFiles: number;
        /**
         * The protocol type. Valid values: `HDFS`.
         */
        protocolType: string;
        /**
         * The preset throughput of the File system. Valid values: `1` to `1024`, Unit: MB/s.
         */
        provisionedThroughputInMiBps: number;
        /**
         * The capacity budget of the File system.
         */
        spaceCapacity: number;
        /**
         * Storage package Id.
         */
        storagePackageId: string;
        /**
         * The storage specifications of the File system. Valid values: `PERFORMANCE`, `STANDARD`.
         */
        storageType: string;
        /**
         * The throughput mode of the File system. Valid values: `Provisioned`, `Standard`.
         */
        throughputMode: string;
        /**
         * The used space of the File system.
         */
        usedSpaceSize: number;
        /**
         * The zone ID of the File system.
         */
        zoneId: string;
    }

    export interface GetMountPointsPoint {
        /**
         * The ID of the Access Group.
         */
        accessGroupId: string;
        /**
         * The created time of the Mount Point.
         */
        createTime: string;
        /**
         * The description of the Mount Point.
         */
        description: string;
        /**
         * The ID of the File System.
         */
        fileSystemId: string;
        /**
         * The ID of the Mount Point.
         */
        id: string;
        /**
         * The domain name of the Mount Point.
         */
        mountPointDomain: string;
        /**
         * The ID of the Mount Point.
         */
        mountPointId: string;
        /**
         * The network type of the Mount Point. Valid values: `VPC`.
         */
        networkType: string;
        /**
         * The status of the Mount Point. Valid values: `Active`, `Inactive`.
         */
        status: string;
        /**
         * The ID of the VPC network.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * A list of available configurations of the Zone.
         */
        options: outputs.dfs.GetZonesZoneOption[];
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetZonesZoneOption {
        /**
         * The protocol type. Valid values: `HDFS`.
         */
        protocolType: string;
        /**
         * The storage specifications of the File system. Valid values: `PERFORMANCE`, `STANDARD`.
         */
        storageType: string;
    }

}

export namespace directmail {
    export interface GetDomainsDomain {
        /**
         * Track verification.
         */
        cnameAuthStatus: string;
        /**
         * Indicates whether the CNAME record is successfully verified. Valid values: `0` and `1`. `0`: indicates the verification is successful. `1`: indicates that the verification fails.
         */
        cnameConfirmStatus: string;
        /**
         * The value of the CNAME record.
         */
        cnameRecord: string;
        /**
         * The time when the DNS record was created.
         */
        createTime: string;
        /**
         * The default domain name.
         */
        defaultDomain: string;
        /**
         * The value of the MX record.
         */
        dnsMx: string;
        /**
         * The value of the SPF record.
         */
        dnsSpf: string;
        /**
         * The value of the TXT ownership record.
         */
        dnsTxt: string;
        /**
         * The ID of the domain name.
         */
        domainId: string;
        /**
         * The domain name.
         */
        domainName: string;
        /**
         * The type of the domain.
         */
        domainType: string;
        /**
         * The status of ICP filing. Valid values: `0` and `1`. `0`: indicates that the domain name is not filed. `1`: indicates that the domain name is filed.
         */
        icpStatus: string;
        /**
         * The ID of the Domain.
         */
        id: string;
        /**
         * Indicates whether the MX record is successfully verified. Valid values: `0` and `1`. `0`: indicates the verification is successful. `1`: indicates that the verification fails.
         */
        mxAuthStatus: string;
        /**
         * The MX verification record provided by Alibaba Cloud DNS.
         */
        mxRecord: string;
        /**
         * Indicates whether the SPF record is successfully verified. Valid values: `0` and `1`. `0`: indicates the verification is successful. `1`: indicates that the verification fails.
         */
        spfAuthStatus: string;
        /**
         * The SPF verification record provided by Alibaba Cloud DNS.
         */
        spfRecord: string;
        /**
         * The status of the domain name. Valid values:`0` to `4`. `0`:Available, Passed. `1`: Unavailable, No passed. `2`: Available, cname no passed, icp no passed. `3`: Available, icp no passed. `4`: Available, cname no passed.
         */
        status: string;
        /**
         * The primary domain name.
         */
        tlDomainName: string;
        /**
         * The CNAME verification record provided by Alibaba Cloud DNS.
         */
        tracefRecord: string;
    }

    export interface GetMailAddressesAddress {
        /**
         * The sender address.
         */
        accountName: string;
        /**
         * The creation of the record time.
         */
        createTime: string;
        /**
         * On the quota limit.
         */
        dailyCount: string;
        /**
         * On the quota.
         */
        dailyReqCount: string;
        /**
         * Domain name status. Valid values: `0`, `1`.
         */
        domainStatus: string;
        /**
         * The ID of the Mail Address.
         */
        id: string;
        /**
         * The sender address ID.
         */
        mailAddressId: string;
        /**
         * Monthly quota limit.
         */
        monthCount: string;
        /**
         * Months amount.
         */
        monthReqCount: string;
        /**
         * Return address.
         */
        replyAddress: string;
        /**
         * If using STMP address status.
         */
        replyStatus: string;
        /**
         * Account type.
         */
        sendtype: string;
        /**
         * Account Status. Valid values: `0`, `1`. Freeze: 1, normal: 0.
         */
        status: string;
    }

    export interface GetReceiversReceiverse {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The ID of the Receivers.
         */
        id: string;
        /**
         * -The Receivers Alias.
         */
        receiversAlias: string;
        /**
         * The first ID of the resource.
         */
        receiversId: string;
        /**
         * The name of the resource.
         */
        receiversName: string;
        /**
         * The status of the resource.
         */
        status: number;
    }

    export interface GetTagsTag {
        /**
         * The ID of the tag.
         */
        id: string;
        /**
         * The ID of the tag.
         */
        tagId: string;
        /**
         * The name of the tag.
         */
        tagName: string;
    }

}

export namespace dms {
    export interface GetEnterpriseInstancesInstance {
        /**
         * The name of the data link for the database instance.
         */
        dataLinkName: string;
        /**
         * The logon password of the database instance.
         */
        databasePassword: string;
        /**
         * The logon username of the database instance.
         */
        databaseUser: string;
        /**
         * The ID of the database administrator (DBA) of the database instance.
         */
        dbaId: string;
        /**
         * The nickname of the DBA.
         */
        dbaNickName: string;
        /**
         * Indicates whether the online data description language (DDL) service was enabled for the database instance.
         */
        ddlOnline: number;
        /**
         * The ID of the Elastic Compute Service (ECS) instance to which the database instance belongs.
         */
        ecsInstanceId: string;
        /**
         * The region where the database instance resides.
         */
        ecsRegion: string;
        /**
         * The type of the environment to which the database instance belongs.
         */
        envType: string;
        /**
         * The timeout period for exporting the database instance.
         */
        exportTimeout: number;
        /**
         * The endpoint of the database instance.
         */
        host: string;
        id: string;
        /**
         * The alias of the database instance.
         */
        instanceAlias: string;
        /**
         * The ID of the database instance.
         */
        instanceId: string;
        instanceName: string;
        /**
         * The source of the database instance.
         */
        instanceSource: string;
        /**
         * The ID of the database instance.
         */
        instanceType: string;
        /**
         * The connection port of the database instance.
         */
        port: number;
        /**
         * The timeout period for querying the database instance.
         */
        queryTimeout: number;
        /**
         * The ID of the security rule for the database instance.
         */
        safeRuleId: string;
        /**
         * The system ID (SID) of the database instance.
         */
        sid: string;
        /**
         * Filter the results by status of the DMS Enterprise Instances. Valid values: `NORMAL`, `UNAVAILABLE`, `UNKNOWN`, `DELETED`, `DISABLE`.
         */
        status: string;
        /**
         * Indicates whether cross-database query was enabled for the database instance.
         */
        useDsql: number;
        /**
         * The ID of the Virtual Private Cloud (VPC) to which the database instance belongs.
         */
        vpcId: string;
    }

    export interface GetEnterpriseUsersUser {
        /**
         * The Alibaba Cloud unique ID (UID) of the user.
         */
        id: string;
        /**
         * The DingTalk number or mobile number of the user.
         */
        mobile: string;
        /**
         * The nickname of the user.
         */
        nickName: string;
        /**
         * The Alibaba Cloud unique ID (UID) of the parent account if the user corresponds to a Resource Access Management (RAM) user.
         */
        parentUid: number;
        /**
         * The list ids of the role that the user plays.
         */
        roleIds: number[];
        /**
         * The list names of the role that he user plays.
         */
        roleNames: string[];
        /**
         * The status of the user.
         */
        status: string;
        uid: string;
        /**
         * The ID of the user.
         */
        userId: string;
        /**
         * The nickname of the user.
         */
        userName: string;
    }

}

export namespace dns {
    export interface CustomLineIpSegmentList {
        /**
         * The end IP address of the CIDR block.
         */
        endIp: string;
        /**
         * The start IP address of the CIDR block.
         */
        startIp: string;
    }

    export interface GetAlidnsDomainGroupsGroup {
        /**
         * Number of domain names in the group.
         */
        domainCount: number;
        /**
         * Id of the domain group.
         */
        groupId: string;
        /**
         * The name of the domain group.
         */
        groupName: string;
        /**
         * Id of the instance.
         */
        id: string;
    }

    export interface GetAlidnsDomainsDomain {
        /**
         * Specifies whether the domain is from Alibaba Cloud or not.
         */
        aliDomain: boolean;
        /**
         * List of available TTLs.
         */
        availableTtls: number[];
        /**
         * DNS list of domain names in the resolution system.
         */
        dnsServers: string[];
        /**
         * ID of the domain.
         */
        domainId: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * Domain group ID, if not filled, the default is all groups.
         */
        groupId: string;
        /**
         * Name of group that contains the domain.
         */
        groupName: string;
        /**
         * The Id of resource.
         */
        id: string;
        /**
         * Whether it is in black hole.
         */
        inBlackHole: boolean;
        /**
         * Whether it is cleaning.
         */
        inClean: boolean;
        /**
         * Cloud analysis product ID.
         */
        instanceId: string;
        lineType: string;
        /**
         * Minimum TTL.
         */
        minTtl: number;
        /**
         * Punycode of the Chinese domain.
         */
        punyCode: string;
        /**
         * Tree-like analytical line list.
         */
        recordLineTreeJson: string;
        /**
         * Parse the line data list.
         */
        recordLines: outputs.dns.GetAlidnsDomainsDomainRecordLine[];
        /**
         * Whether it is a regional route.
         */
        regionLines: boolean;
        /**
         * The Id of resource group which the dns belongs.
         */
        remark: string;
        /**
         * The Id of resource group which the dns belongs.
         */
        resourceGroupId: string;
        /**
         * Whether to allow auxiliary dns.
         */
        slaveDns: boolean;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Cloud analysis version code.
         */
        versionCode: string;
        versionName: string;
    }

    export interface GetAlidnsDomainsDomainRecordLine {
        /**
         * The code of the parent line, or empty if there is none.
         */
        fatherCode: string;
        /**
         * Sub-line Code.
         */
        lineCode: string;
        /**
         * Parent line display name.
         */
        lineDisplayName: string;
        /**
         * Sub-line display name.
         */
        lineName: string;
    }

    export interface GetAlidnsInstancesInstance {
        /**
         * DNS security level.
         */
        dnsSecurity: string;
        /**
         * (Available in 1.124.1+) The domain name.
         */
        domain: string;
        /**
         * Number of domain names bound.
         */
        domainNumbers: string;
        /**
         * Id of the instance.
         */
        id: string;
        /**
         * Id of the instance resource.
         */
        instanceId: string;
        /**
         * (Available in 1.124.1+) The payment type of alidns instance.
         */
        paymentType: string;
        /**
         * Paid package version.
         */
        versionCode: string;
        /**
         * Paid package version name.
         */
        versionName: string;
    }

    export interface GetAlidnsRecordsRecord {
        /**
         * The domain name associated to the records.
         */
        domainName: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * ISP line. For checking all resolution lines enumeration please visit [Alibaba Cloud DNS doc](https://www.alibabacloud.com/help/doc-detail/34339.htm)
         */
        line: string;
        /**
         * Indicates whether the record is locked.
         */
        locked: boolean;
        /**
         * Priority of the `MX` record.
         */
        priority: number;
        /**
         * ID of the record.
         */
        recordId: string;
        /**
         * The remark of the domain record.  **NOTE:** Available in 1.144.0+.
         */
        remark: string;
        /**
         * Host record of the domain.
         */
        rr: string;
        /**
         * Record status. Valid values: `ENABLE` and `DISABLE`.
         */
        status: string;
        /**
         * TTL of the record.
         */
        ttl: number;
        /**
         * Record type. Valid values: `A`, `NS`, `MX`, `TXT`, `CNAME`, `SRV`, `AAAA`, `REDIRECT_URL`, `FORWORD_URL` .
         */
        type: string;
        /**
         * Host record value of the domain.
         */
        value: string;
    }

    export interface GetCustomLinesLine {
        /**
         * The Custom line Code.
         */
        code: string;
        /**
         * The first ID of the resource.
         */
        customLineId: string;
        /**
         * Line name.
         */
        customLineName: string;
        /**
         * The Domain name.
         */
        domainName: string;
        /**
         * The ID of the Custom Line.
         */
        id: string;
        /**
         * The IP segment list.
         */
        ipSegmentLists: outputs.dns.GetCustomLinesLineIpSegmentList[];
    }

    export interface GetCustomLinesLineIpSegmentList {
        /**
         * The end IP address of the CIDR block.
         */
        endIp: string;
        /**
         * The start IP address of the CIDR block.
         */
        startIp: string;
    }

    export interface GetDomainGroupsGroup {
        groupId: string;
        groupName: string;
    }

    export interface GetDomainRecordsRecord {
        domainName: string;
        hostRecord: string;
        line: string;
        locked: boolean;
        priority: number;
        recordId: string;
        status: string;
        ttl: number;
        type: string;
        value: string;
    }

    export interface GetDomainsDomain {
        /**
         * Specifies whether the domain is from Alibaba Cloud or not.
         */
        aliDomain: boolean;
        availableTtls: number[];
        /**
         * DNS list of domain names in the resolution system.
         */
        dnsServers: string[];
        /**
         * ID of the domain.
         */
        domainId: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * Domain group ID, if not filled, the default is all groups.
         */
        groupId: string;
        /**
         * Name of group that contains the domain.
         */
        groupName: string;
        /**
         * The Id of resource.
         */
        id: string;
        /**
         * Whether it is in black hole.
         */
        inBlackHole: boolean;
        /**
         * Whether it is cleaning.
         */
        inClean: boolean;
        /**
         * Cloud analysis product ID.
         */
        instanceId: string;
        lineType: string;
        /**
         * Minimum TTL.
         */
        minTtl: number;
        /**
         * Punycode of the Chinese domain.
         */
        punyCode: string;
        /**
         * Tree-like analytical line list.
         */
        recordLineTreeJson: string;
        recordLines: outputs.dns.GetDomainsDomainRecordLine[];
        /**
         * Whether it is a regional route.
         */
        regionLines: boolean;
        /**
         * The Id of resource group which the dns belongs.
         */
        remark: string;
        /**
         * The Id of resource group which the dns belongs.
         */
        resourceGroupId: string;
        /**
         * Whether to allow auxiliary dns.
         */
        slaveDns: boolean;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Cloud analysis version code.
         */
        versionCode: string;
        versionName: string;
    }

    export interface GetDomainsDomainRecordLine {
        fatherCode: string;
        lineCode: string;
        lineDisplayName: string;
        lineName: string;
    }

    export interface GetGroupsGroup {
        /**
         * Id of the group.
         */
        groupId: string;
        /**
         * Name of the group.
         */
        groupName: string;
    }

    export interface GetGtmInstancesInstance {
        /**
         * The alert notification methods.
         */
        alertConfigs: outputs.dns.GetGtmInstancesInstanceAlertConfig[];
        /**
         * The alert group.
         */
        alertGroups: string[];
        /**
         * The access type of the CNAME domain name.
         */
        cnameType: string;
        /**
         * The CreateTime of the Gtm Instance.
         */
        createTime: string;
        /**
         * The ExpireTime of the Gtm Instance.
         */
        expireTime: string;
        /**
         * The ID of the Gtm Instance.
         */
        id: string;
        /**
         * The ID of the Gtm Instance.
         */
        instanceId: string;
        /**
         * The name of the Gtm Instance.
         */
        instanceName: string;
        /**
         * The version of the instance.
         */
        packageEdition: string;
        /**
         * The paymentype of the resource.
         */
        paymentType: string;
        /**
         * The Public Network domain name access method.
         */
        publicCnameMode: string;
        /**
         * The CNAME access domain name.
         */
        publicRr: string;
        /**
         * The website domain name that the user uses on the Internet.
         */
        publicUserDomainName: string;
        /**
         * The domain name that is used to access GTM over the Internet.
         */
        publicZoneName: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The type of the access policy.
         */
        strategyMode: string;
        /**
         * The global time to live.
         */
        ttl: number;
    }

    export interface GetGtmInstancesInstanceAlertConfig {
        /**
         * Whether to configure DingTalk notifications.
         */
        dingtalkNotice: boolean;
        /**
         * Whether to configure mail notification.
         */
        emailNotice: boolean;
        /**
         * The Alarm Event Type.
         */
        noticeType: string;
        /**
         * Whether to configure SMS notification.
         */
        smsNotice: boolean;
    }

    export interface GetInstancesInstance {
        /**
         * DNS security level.
         */
        dnsSecurity: string;
        domain: string;
        /**
         * Number of domain names bound.
         */
        domainNumbers: string;
        /**
         * Id of the instance.
         */
        id: string;
        /**
         * Id of the instance resource.
         */
        instanceId: string;
        paymentType: string;
        /**
         * Paid package version.
         */
        versionCode: string;
        /**
         * Paid package version name.
         */
        versionName: string;
    }

    export interface GetRecordsRecord {
        /**
         * The domain name associated to the records.
         */
        domainName: string;
        /**
         * Host record of the domain.
         */
        hostRecord: string;
        /**
         * ISP line. Valid items are `default`, `telecom`, `unicom`, `mobile`, `oversea`, `edu`, `drpeng`, `btvn`, .etc. For checking all resolution lines enumeration please visit [Alibaba Cloud DNS doc](https://www.alibabacloud.com/help/doc-detail/34339.htm)
         */
        line: string;
        /**
         * Indicates whether the record is locked.
         */
        locked: boolean;
        /**
         * Priority of the `MX` record.
         */
        priority: number;
        /**
         * ID of the record.
         */
        recordId: string;
        /**
         * Record status. Valid items are `ENABLE` and `DISABLE`.
         */
        status: string;
        /**
         * TTL of the record.
         */
        ttl: number;
        /**
         * Record type. Valid items are `A`, `NS`, `MX`, `TXT`, `CNAME`, `SRV`, `AAAA`, `REDIRECT_URL`, `FORWORD_URL` .
         */
        type: string;
        /**
         * Host record value of the domain.
         */
        value: string;
    }

    export interface GetResolutionLinesLine {
        lineCode: string;
        /**
         * Line display name.
         */
        lineDisplayName: string;
        /**
         * Line name.
         */
        lineName: string;
    }

    export interface GtmInstanceAlertConfig {
        /**
         * Whether to configure DingTalk notifications. Valid values: `true`, `false`.
         */
        dingtalkNotice?: boolean;
        /**
         * Whether to configure mail notification. Valid values: `true`, `false`.
         */
        emailNotice?: boolean;
        /**
         * The Alarm Event Type.
         * - `ADDR_ALERT`: Address not available.
         * - `ADDR_RESUME`: Address Recovery available.
         * - `ADDR_POOL_GROUP_UNAVAILABLE`: Address pool collection not available.
         * - `ADDR_POOL_GROUP_AVAILABLE`: Address pool collection recovery available.
         * - `ACCESS_STRATEGY_POOL_GROUP_SWITCH`: Primary/standby address pool switch.
         * - `MONITOR_NODE_IP_CHANGE`: Monitoring node IP address changes.
         */
        noticeType?: string;
        /**
         * Whether to configure SMS notification. Valid values: `true`, `false`.
         */
        smsNotice?: boolean;
    }

}

export namespace drds {
    export interface GetInstancesInstance {
        /**
         * Creation time of the instance.
         */
        createTime: number;
        /**
         * The DRDS instance description.
         */
        description: string;
        /**
         * The ID of the DRDS instance.
         */
        id: string;
        /**
         * `Classic` for public classic network or `VPC` for private network.
         */
        networkType: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * The DRDS Instance type.
         */
        type: string;
        /**
         * The DRDS Instance version.
         */
        version: number;
        /**
         * Zone ID the instance belongs to.
         */
        zoneId: string;
    }

}

export namespace dts {
    export interface GetConsumerChannelsChannel {
        /**
         * The ID of the consumer group.
         */
        consumerGroupId: string;
        /**
         * The name of the consumer group.
         */
        consumerGroupName: string;
        /**
         * The username of the consumer group.
         */
        consumerGroupUserName: string;
        /**
         * The time point when the client consumed the last message in the subscription channel.
         */
        consumptionCheckpoint: string;
        /**
         * The ID of the Consumer Channel.
         */
        id: string;
        /**
         * The message delay time, for the current time data subscription channel in the earliest time of unconsumed messages of the difference, in Unix timestamp format, which is measured in seconds.
         */
        messageDelay: number;
        /**
         * The total number of unconsumed messages.
         */
        unconsumedData: number;
    }

    export interface GetSubscriptionJobsJob {
        /**
         * Subscription start time in Unix timestamp format.
         */
        checkpoint: string;
        /**
         * The creation time of subscription job instance.
         */
        createTime: string;
        /**
         * Subscription object, in the format of JSON strings.
         */
        dbList: string;
        /**
         * The ID of subscription job instance.
         */
        dtsInstanceId: string;
        /**
         * The ID of subscription job instance.
         */
        dtsJobId: string;
        /**
         * The name of subscription job instance.
         */
        dtsJobName: string;
        /**
         * The Expiration Time. Formatting with yyyy-MM-ddTHH:mm:ssZ(UTC time).
         */
        expireTime: string;
        /**
         * The ID of the Subscription Job.
         */
        id: string;
        /**
         * The payment type of the resource. Valid values: `Subscription`, `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * To subscribe to the name of the database.
         */
        sourceEndpointDatabaseName: string;
        /**
         * The source database type value is MySQL or Oracle.
         */
        sourceEndpointEngineName: string;
        /**
         * The ID of source instance. Only when the type of source database instance was RDS MySQL, PolarDB-X 1.0, PolarDB MySQL, this parameter can be available and must be set.
         */
        sourceEndpointInstanceId: string;
        /**
         * The type of source instance. Valid values: `RDS`, `PolarDB`, `DRDS`, `LocalInstance`, `ECS`, `Express`, `CEN`, `dg`.
         */
        sourceEndpointInstanceType: string;
        /**
         * The IP of source endpoint.
         */
        sourceEndpointIp: string;
        /**
         * The SID of Oracle Database. When the source database is self-built Oracle and the Oracle database is a non-RAC instance, this parameter is available and must be passed in.
         */
        sourceEndpointOracleSid: string;
        /**
         * The Alibaba Cloud account ID to which the source instance belongs. This parameter is only available when configuring data subscriptions across Alibaba Cloud accounts and must be passed in.
         */
        sourceEndpointOwnerId: string;
        /**
         * The  port of source database.
         */
        sourceEndpointPort: string;
        /**
         * The region of source database.
         */
        sourceEndpointRegion: string;
        /**
         * Both the authorization roles. When the source instance and configure subscriptions task of the Alibaba Cloud account is not the same as the need to pass the parameter, to specify the source of the authorization roles, to allow configuration subscription task of the Alibaba Cloud account to access the source of the source instance information.
         */
        sourceEndpointRole: string;
        /**
         * The username of source database instance account.
         */
        sourceEndpointUserName: string;
        /**
         * The status of the task. Valid values: `NotStarted`, `Normal`, `Abnormal`. When a task created, it is in this state of `NotStarted`. You can specify this state of `Normal` to start the job, and specify this state of `Abnormal` to stop the job.
         */
        status: string;
        /**
         * Whether to subscribe the DDL type of data. Valid values: `true`, `false`.
         */
        subscriptionDataTypeDdl: boolean;
        /**
         * Whether to subscribe the DML type of data. Valid values: `true`, `false`.
         */
        subscriptionDataTypeDml: boolean;
        /**
         * Network information.
         */
        subscriptionHosts: outputs.dts.GetSubscriptionJobsJobSubscriptionHost[];
        /**
         * The type of subscription instance network. Valid value: `classic`, `vpc`.
         */
        subscriptionInstanceNetworkType: string;
        /**
         * The ID of subscription instance vpc.
         */
        subscriptionInstanceVpcId: string;
        /**
         * The ID of subscription instance vswitch.
         */
        subscriptionInstanceVswitchId: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetSubscriptionJobsJobSubscriptionHost {
        /**
         * Classic network address.
         */
        privateHost: string;
        /**
         * Public network address.
         */
        publicHost: string;
        /**
         * VPC network address.
         */
        vpcHost: string;
    }

    export interface GetSynchronizationJobsJob {
        /**
         * Start time in Unix timestamp format.
         */
        checkpoint: string;
        createTime: string;
        /**
         * Whether to execute DTS supports schema migration, full data migration, or full-data initialization.
         */
        dataInitialization: boolean;
        /**
         * Whether to perform incremental data migration for migration types or synchronization.
         */
        dataSynchronization: boolean;
        /**
         * Migration object, in the format of JSON strings. For detailed definition instructions, please refer to [the description of migration, synchronization or subscription objects](https://help.aliyun.com/document_detail/209545.html).
         */
        dbList: string;
        /**
         * The name of migrate the database.
         */
        destinationEndpointDataBaseName: string;
        /**
         * The type of destination database. Valid values: `ADB20`, `ADB30`, `AS400`, `DATAHUB`, `DB2`, `GREENPLUM`, `KAFKA`, `MONGODB`, `MSSQL`, `MySQL`, `ORACLE`, `PolarDB`, `POLARDBX20`, `POLARDB_O`, `PostgreSQL`.
         */
        destinationEndpointEngineName: string;
        /**
         * The ID of destination instance.
         */
        destinationEndpointInstanceId: string;
        /**
         * The type of destination instance. Valid values: `ads`, `CEN`, `DATAHUB`, `DG`, `ECS`, `EXPRESS`, `GREENPLUM`, `MONGODB`, `OTHER`, `PolarDB`, `POLARDBX20`, `RDS`.
         */
        destinationEndpointInstanceType: string;
        /**
         * The ip of source endpoint.
         */
        destinationEndpointIp: string;
        /**
         * The SID of Oracle database.
         */
        destinationEndpointOracleSid: string;
        /**
         * The port of source endpoint.
         */
        destinationEndpointPort: string;
        /**
         * The region of destination instance.
         */
        destinationEndpointRegion: string;
        /**
         * The username of database account.
         */
        destinationEndpointUserName: string;
        dtsInstanceId: string;
        dtsJobId: string;
        /**
         * The name of synchronization job.
         */
        dtsJobName: string;
        expireTime: string;
        /**
         * The ID of synchronizing instance. It's the ID of resource `alicloud.dts.SynchronizationInstance`.
         */
        id: string;
        /**
         * The name of migrate the database.
         */
        sourceEndpointDatabaseName: string;
        /**
         * The type of source database. Valid values: `AS400`, `DB2`, `DMSPOLARDB`, `HBASE`, `MONGODB`, `MSSQL`, `MySQL`, `ORACLE`, `PolarDB`, `POLARDBX20`, `POLARDB_O`, `POSTGRESQL`, `TERADATA`.
         */
        sourceEndpointEngineName: string;
        /**
         * The ID of source instance.
         */
        sourceEndpointInstanceId: string;
        /**
         * The type of source instance. Valid values: `CEN`, `DG`, `DISTRIBUTED_DMSLOGICDB`, `ECS`, `EXPRESS`, `MONGODB`, `OTHER`, `PolarDB`, `POLARDBX20`, `RDS`.
         */
        sourceEndpointInstanceType: string;
        /**
         * The ip of source endpoint.
         */
        sourceEndpointIp: string;
        /**
         * The SID of Oracle database.
         */
        sourceEndpointOracleSid: string;
        /**
         * The Alibaba Cloud account ID to which the source instance belongs.
         */
        sourceEndpointOwnerId: string;
        /**
         * The port of source endpoint.
         */
        sourceEndpointPort: string;
        /**
         * The region of source instance.
         */
        sourceEndpointRegion: string;
        /**
         * The name of the role configured for the cloud account to which the source instance belongs.
         */
        sourceEndpointRole: string;
        /**
         * The username of database account.
         */
        sourceEndpointUserName: string;
        /**
         * The status of the resource. Valid values: `Synchronizing`, `Suspending`. You can stop the task by specifying `Suspending` and start the task by specifying `Synchronizing`.
         */
        status: string;
        /**
         * Whether to perform a database table structure to migrate or initialization values include:
         */
        structureInitialization: boolean;
        /**
         * Synchronization direction. Valid values: `Forward`, `Reverse`. Only when the property `syncArchitecture` of the `alicloud.dts.SynchronizationInstance` was `bidirectional` this parameter should be passed, otherwise this parameter should not be specified.
         */
        synchronizationDirection: string;
    }

}

export namespace eais {
    export interface GetInstancesInstance {
        /**
         * The ID of the ECS instance to be bound.
         */
        clientInstanceId: string;
        /**
         * The name of the ECS instance bound to the EAIS instance.
         */
        clientInstanceName: string;
        /**
         * The type of the ECS instance bound to the EAIS instance.
         */
        clientInstanceType: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the resource.
         */
        instanceId: string;
        /**
         * The name of the resource.
         */
        instanceName: string;
        /**
         * The type of the resource. Valid values: `eais.ei-a6.4xlarge`, `eais.ei-a6.2xlarge`, `eais.ei-a6.xlarge`, `eais.ei-a6.large`, `eais.ei-a6.medium`.
         */
        instanceType: string;
        /**
         * The status of the resource. Valid values: `Attaching`, `Available`, `Detaching`, `InUse`, `Starting`, `Unavailable`.
         */
        status: string;
        /**
         * The ID of the region to which the EAIS instance belongs.
         */
        zoneId: string;
    }

}

export namespace eci {
    export interface ContainerGroupContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         */
        environmentVars?: outputs.eci.ContainerGroupContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The amount of memory resources allocated to the container.
         */
        memory?: number;
        /**
         * The name of the mounted volume.
         */
        name: string;
        /**
         * The structure of port.
         */
        ports?: outputs.eci.ContainerGroupContainerPort[];
        ready: boolean;
        restartCount: number;
        /**
         * The structure of volumeMounts.
         */
        volumeMounts?: outputs.eci.ContainerGroupContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface ContainerGroupContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters, digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface ContainerGroupContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface ContainerGroupDnsConfig {
        /**
         * The list of DNS server IP addresses.
         */
        nameServers?: string[];
        /**
         * The structure of options.
         */
        options?: outputs.eci.ContainerGroupDnsConfigOption[];
        /**
         * The list of DNS lookup domains.
         */
        searches?: string[];
    }

    export interface ContainerGroupDnsConfigOption {
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupEciSecurityContext {
        sysctls?: outputs.eci.ContainerGroupEciSecurityContextSysctl[];
    }

    export interface ContainerGroupEciSecurityContextSysctl {
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupHostAlias {
        /**
         * Adds a host name.
         */
        hostnames?: string[];
        /**
         * Adds an IP address.
         */
        ip?: string;
    }

    export interface ContainerGroupImageRegistryCredential {
        /**
         * The password used to log on to the image repository. It is required when `imageRegistryCredential` is configured.
         */
        password: string;
        /**
         * The address of the image repository. It is required when `imageRegistryCredential` is configured.
         */
        server: string;
        /**
         * The username used to log on to the image repository. It is required when `imageRegistryCredential` is configured.
         */
        userName: string;
    }

    export interface ContainerGroupInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         */
        environmentVars?: outputs.eci.ContainerGroupInitContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image?: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The amount of memory resources allocated to the container.
         */
        memory?: number;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The structure of port.
         */
        ports?: outputs.eci.ContainerGroupInitContainerPort[];
        ready: boolean;
        restartCount: number;
        /**
         * The structure of volumeMounts.
         */
        volumeMounts?: outputs.eci.ContainerGroupInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface ContainerGroupInitContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters, digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface ContainerGroupInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface ContainerGroupVolume {
        /**
         * ConfigFileVolumeConfigFileToPaths.
         */
        configFileVolumeConfigFileToPaths?: outputs.eci.ContainerGroupVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId?: string;
        /**
         * The system type of DiskVolume.
         */
        diskVolumeFsType?: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver?: string;
        /**
         * The type of the mounted file system. The default value is determined by the script of FlexVolume.
         */
        flexVolumeFsType?: string;
        /**
         * The list of FlexVolume objects. Each object is a key-value pair contained in a JSON string.
         */
        flexVolumeOptions?: string;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath?: string;
        /**
         * The nfs volume read only. Default to `false`.
         */
        nfsVolumeReadOnly?: boolean;
        /**
         * The address of the NFS server.
         */
        nfsVolumeServer?: string;
        /**
         * The type of the volume.
         */
        type?: string;
    }

    export interface ContainerGroupVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content?: string;
        /**
         * The relative file path.
         */
        path?: string;
    }

    export interface GetContainerGroupsGroup {
        /**
         * The id if ContainerGroup.
         */
        containerGroupId: string;
        /**
         * The name of ContainerGroup.
         */
        containerGroupName: string;
        /**
         * A list of containers. Each element contains the following attributes:
         */
        containers: outputs.eci.GetContainerGroupsGroupContainer[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        discount: number;
        /**
         * The DNS settings.
         */
        dnsConfigs: outputs.eci.GetContainerGroupsGroupDnsConfig[];
        /**
         * The security context of the container group.
         */
        eciSecurityContexts: outputs.eci.GetContainerGroupsGroupEciSecurityContext[];
        /**
         * The ID of the ENI instance.
         */
        eniInstanceId: string;
        /**
         * The events of the container group. Maximum: `50`.
         */
        events: outputs.eci.GetContainerGroupsGroupEvent[];
        /**
         * The time when the container group failed to run due to overdue payments. The timestamp follows the UTC and RFC3339 formats.
         */
        expiredTime: string;
        /**
         * The time when the container failed to run tasks. The timestamp follows the UTC and RFC3339 formats.
         */
        failedTime: string;
        /**
         * The mapping between host names and IP addresses for a container in the container group.
         */
        hostAliases: outputs.eci.GetContainerGroupsGroupHostAlias[];
        /**
         * The ID of the Container Group.
         */
        id: string;
        /**
         * A list of init containers. Each element contains the following attributes:
         */
        initContainers: outputs.eci.GetContainerGroupsGroupInitContainer[];
        /**
         * The type of the ECS instance.
         */
        instanceType: string;
        /**
         * The public IP address of the container group.
         */
        internetIp: string;
        /**
         * The internal IP address of the container group.
         */
        intranetIp: string;
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The RAM role that the container group assumes. ECI and ECS share the same RAM role.
         */
        ramRoleName: string;
        /**
         * The ID of the resource group to which the container group belongs. If you have not specified a resource group for the container group, it is added to the default resource group.
         */
        resourceGroupId: string;
        /**
         * The restart policy of the container group.
         */
        restartPolicy: string;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The status of container.
         */
        status: string;
        /**
         * The time when all containers in the container group completed running the specified tasks. The timestamp follows the UTC and RFC 3339 formats. For example, 2018-08-02T15:00:00Z.
         */
        succeededTime: string;
        /**
         * The tags attached to the container group. Each tag is a key-value pair. You can attach up to 20 tags to a container group.
         */
        tags: {[key: string]: any};
        /**
         * The information about the mounted volume. You can mount up to 20 volumes.
         */
        volumes: outputs.eci.GetContainerGroupsGroupVolume[];
        /**
         * The if of vpc.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The IDs of the zones where the container groups are deployed. If this parameter is not set, the system automatically selects the zones. By default, no value is specified.
         */
        zoneId: string;
    }

    export interface GetContainerGroupsGroupContainer {
        /**
         * The arguments passed to the commands.
         */
        args: string[];
        /**
         * The commands run by the container.
         */
        commands: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        /**
         * The environment variables.
         */
        environmentVars: outputs.eci.GetContainerGroupsGroupContainerEnvironmentVar[];
        /**
         * The amount of GPU resources allocated to the container.
         */
        gpu: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The policy for pulling an image.
         */
        imagePullPolicy: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The exposed ports and protocols. Maximum: `100`.
         */
        ports: outputs.eci.GetContainerGroupsGroupContainerPort[];
        /**
         * Indicates whether the container is ready.
         */
        ready: boolean;
        /**
         * The number of times that the container has restarted.
         */
        restartCount: number;
        /**
         * The list of volumes mounted to the container.
         */
        volumeMounts: outputs.eci.GetContainerGroupsGroupContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir: string;
    }

    export interface GetContainerGroupsGroupContainerEnvironmentVar {
        /**
         * The name of the variable.
         */
        key: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port: number;
        /**
         * Valid values: `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface GetContainerGroupsGroupContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * Default value: `false`.
         */
        readOnly: boolean;
    }

    export interface GetContainerGroupsGroupDnsConfig {
        /**
         * The list of DNS server IP addresses.
         */
        nameServers: string[];
        /**
         * The list of objects. Each object is a name-value pair. The value is optional.
         */
        options: outputs.eci.GetContainerGroupsGroupDnsConfigOption[];
        /**
         * The list of DNS lookup domains.
         */
        searches: string[];
    }

    export interface GetContainerGroupsGroupDnsConfigOption {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupEciSecurityContext {
        /**
         * The system information.
         */
        sysctls: outputs.eci.GetContainerGroupsGroupEciSecurityContextSysctl[];
    }

    export interface GetContainerGroupsGroupEciSecurityContextSysctl {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupEvent {
        /**
         * The number of events.
         */
        count: number;
        /**
         * The time when the event started.
         */
        firstTimestamp: string;
        /**
         * The time when the event ended.
         */
        lastTimestamp: string;
        /**
         * The content of the event.
         */
        message: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The name of the event.
         */
        reason: string;
        /**
         * The type of the volume. Currently, the following types of volumes are supported: EmptyDirVolume, NFSVolume, ConfigFileVolume, and FlexVolume.
         */
        type: string;
    }

    export interface GetContainerGroupsGroupHostAlias {
        /**
         * The name of the host.
         */
        hostnames: string[];
        /**
         * The IP address of the container.
         */
        ip: string;
    }

    export interface GetContainerGroupsGroupInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args: string[];
        /**
         * The commands run by the container.
         */
        commands: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        /**
         * The environment variables.
         */
        environmentVars: outputs.eci.GetContainerGroupsGroupInitContainerEnvironmentVar[];
        /**
         * The amount of GPU resources allocated to the container.
         */
        gpu: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The policy for pulling an image.
         */
        imagePullPolicy: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The exposed ports and protocols. Maximum: `100`.
         */
        ports: outputs.eci.GetContainerGroupsGroupInitContainerPort[];
        /**
         * Indicates whether the container is ready.
         */
        ready: boolean;
        /**
         * The number of times that the container has restarted.
         */
        restartCount: number;
        /**
         * The list of volumes mounted to the container.
         */
        volumeMounts: outputs.eci.GetContainerGroupsGroupInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir: string;
    }

    export interface GetContainerGroupsGroupInitContainerEnvironmentVar {
        /**
         * The name of the variable.
         */
        key: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port: number;
        /**
         * Valid values: `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface GetContainerGroupsGroupInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * Default value: `false`.
         */
        readOnly: boolean;
    }

    export interface GetContainerGroupsGroupVolume {
        /**
         * The list of configuration file paths.
         */
        configFileVolumeConfigFileToPaths: outputs.eci.GetContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId: string;
        /**
         * The type of DiskVolume.
         */
        diskVolumeFsType: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver: string;
        /**
         * The type of the mounted file system. The default value is determined by the script of FlexVolume.
         */
        flexVolumeFsType: string;
        /**
         * The list of FlexVolume objects.
         */
        flexVolumeOptions: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath: string;
        /**
         * Default value: `false`.
         */
        nfsVolumeReadOnly: boolean;
        /**
         * The address of the NFS server.
         */
        nfsVolumeServer: string;
        /**
         * The type of the volume. Currently, the following types of volumes are supported: EmptyDirVolume, NFSVolume, ConfigFileVolume, and FlexVolume.
         */
        type: string;
    }

    export interface GetContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content: string;
        /**
         * The relative file path.
         */
        path: string;
    }

    export interface GetImageCachesCach {
        /**
         * The id of container group.
         */
        containerGroupId: string;
        /**
         * Image cache pulls image event information.
         */
        events: outputs.eci.GetImageCachesCachEvent[];
        /**
         * The time of expired.
         */
        expireDateTime: string;
        /**
         * The ID of the ECI Image Cache.
         */
        id: string;
        /**
         * The id of the ECI Image Cache.
         */
        imageCacheId: string;
        /**
         * The name of ECI Image Cache.
         */
        imageCacheName: string;
        /**
         * The list of cached images.
         */
        images: string[];
        /**
         * The progress of ECI Image Cache.
         */
        progress: string;
        /**
         * The id of snapshot.
         */
        snapshotId: string;
        /**
         * The status of ECI Image Cache.
         */
        status: string;
    }

    export interface GetImageCachesCachEvent {
        /**
         * Number of events.
         */
        count: number;
        /**
         * Start time.
         */
        firstTimestamp: string;
        /**
         * End time.
         */
        lastTimestamp: string;
        message: string;
        /**
         * The name of event.
         */
        name: string;
        /**
         * The type of event.
         */
        type: string;
    }

    export interface GetVirtualNodesNode {
        /**
         * The Number of CPU.
         */
        cpu: number;
        /**
         * The creation time of the virtual node.
         */
        createTime: string;
        /**
         * The ENI instance ID.
         */
        eniInstanceId: string;
        /**
         * The event list.
         */
        events: outputs.eci.GetVirtualNodesNodeEvent[];
        /**
         * The ID of the Virtual Node.
         */
        id: string;
        /**
         * The IP address of a public network.
         */
        internetIp: string;
        /**
         * The private IP address of the RDS instance.
         */
        intranetIp: string;
        /**
         * The memory size.
         */
        memory: number;
        /**
         * The ram role.
         */
        ramRoleName: string;
        /**
         * The resource group ID.
         */
        resourceGroupId: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The Status of the virtual node.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Of the virtual node number.
         */
        virtualNodeId: string;
        /**
         * The name of the virtual node.
         */
        virtualNodeName: string;
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone.
         */
        zoneId: string;
    }

    export interface GetVirtualNodesNodeEvent {
        /**
         * The number of occurrences.
         */
        count: number;
        /**
         * The first presentation time stamp.
         */
        firstTimestamp: string;
        /**
         * The most recent time stamp.
         */
        lastTimestamp: string;
        /**
         * The event of the message body.
         */
        message: string;
        /**
         * The name of the event.
         */
        name: string;
        /**
         * The causes of the incident.
         */
        reason: string;
        /**
         * The Event type.
         */
        type: string;
    }

    export interface GetZonesZone {
        /**
         * The endpoint of the region.
         */
        regionEndpoint: string;
        /**
         * The list of available zone ids.
         */
        zoneIds: string[];
    }

    export interface ImageCacheImageRegistryCredential {
        /**
         * The password of the Image Registry.
         */
        password?: string;
        /**
         * The address of Image Registry without `http://` or `https://`.
         */
        server?: string;
        /**
         * The user name of Image Registry.
         */
        userName?: string;
    }

    export interface OpenApiImageCacheImageRegistryCredential {
        password?: string;
        server?: string;
        userName?: string;
    }

    export interface VirtualNodeTaint {
        /**
         * The effect of the taint. Valid values: `NoSchedule`, `NoExecute` and `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The key of the taint.
         */
        key?: string;
        /**
         * The value of the taint.
         */
        value?: string;
    }

}

export namespace ecp {
    export interface GetKeyPairsPair {
        /**
         * The ID of the Key Pair. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The Private Key of the Fingerprint.
         */
        keyPairFingerPrint: string;
        /**
         * The Key Name.
         */
        keyPairName: string;
    }

}

export namespace ecs {
    export interface AutoProvisioningGroupLaunchTemplateConfig {
        instanceType?: string;
        maxPrice: string;
        priority: string;
        vswitchId: string;
        weightedCapacity: string;
    }

    export interface DedicatedHostNetworkAttribute {
        /**
         * The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
         */
        slbUdpTimeout?: number;
        /**
         * The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
         */
        udpTimeout?: number;
    }

    export interface EcsLaunchTemplateDataDisk {
        /**
         * The category of the disk.
         */
        category?: string;
        /**
         * Indicates whether the data disk is released with the instance.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * Encrypted the data in this disk.
         */
        encrypted?: boolean;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as the data disk.
         */
        performanceLevel?: string;
        /**
         * The size of the data disk.
         */
        size?: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface EcsLaunchTemplateNetworkInterfaces {
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp?: string;
        /**
         * The security group ID must be one in the same VPC.
         */
        securityGroupId?: string;
        /**
         * The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
         */
        vswitchId?: string;
    }

    export interface EcsLaunchTemplateSystemDisk {
        /**
         * The category of the disk.
         */
        category: string;
        /**
         * Indicates whether the data disk is released with the instance.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description: string;
        /**
         * The Iops.
         */
        iops?: string;
        /**
         * The name of the data disk.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the data disk.
         */
        performanceLevel?: string;
        /**
         * The size of the data disk.
         */
        size: number;
    }

    export interface GetAutoSnapshotPoliciesPolicy {
        /**
         * The ID of the Auto Snapshot Policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The retention period of the snapshot copied across regions.
         */
        copiedSnapshotsRetentionDays: number;
        /**
         * The number of disks to which the automatic snapshot policy is applied.
         */
        diskNums: number;
        /**
         * Specifies whether to enable the system to automatically copy snapshots across regions.
         */
        enableCrossRegionCopy: boolean;
        /**
         * The ID of the Auto Snapshot Policy.
         */
        id: string;
        /**
         * The snapshot policy name..
         */
        name: string;
        /**
         * The automatic snapshot repetition dates.
         */
        repeatWeekdays: string[];
        /**
         * The snapshot retention time, and the unit of measurement is day.
         */
        retentionDays: number;
        /**
         * The status of Auto Snapshot Policy.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The destination region to which the snapshot is copied.
         */
        targetCopyRegions: string[];
        /**
         * The automatic snapshot creation schedule, and the unit of measurement is hour.
         */
        timePoints: string[];
        /**
         * The number of extended volumes on which this policy is enabled.
         */
        volumeNums: number;
    }

    export interface GetCommandsCommand {
        /**
         * The Base64-encoded content of the command.
         */
        commandContent: string;
        /**
         * The ID of the Command.
         */
        commandId: string;
        /**
         * The description of command.
         */
        description: string;
        /**
         * Specifies whether to use custom parameters in the command to be created.
         */
        enableParameter: boolean;
        /**
         * The ID of the Command.
         */
        id: string;
        /**
         * The name of the command
         */
        name: string;
        /**
         * A list of custom parameter names which are parsed from the command content specified when the command was being created.
         */
        parameterNames: string[];
        /**
         * The timeout period that is specified for the command to be run on ECS instances.
         */
        timeout: number;
        /**
         * The command type.
         */
        type: string;
        /**
         * The execution path of the command in the ECS instance.
         */
        workingDir: string;
    }

    export interface GetDedicatedHostsHost {
        /**
         * The policy used to migrate the instances from the dedicated host when the dedicated host fails or needs to be repaired online.
         */
        actionOnMaintenance: string;
        /**
         * Specifies whether to add the dedicated host to the resource pool for automatic deployment.
         */
        autoPlacement: string;
        /**
         * The automatic release time of the dedicated host.
         */
        autoReleaseTime: string;
        /**
         * (Available in 1.123.1+) A collection of proprietary host performance indicators.
         */
        capacities: outputs.ecs.GetDedicatedHostsHostCapacity[];
        /**
         * A mapping of tags to assign to the resource.
         */
        cores: number;
        /**
         * (Available in 1.123.1+) CPU oversold ratio.
         */
        cpuOverCommitRatio: number;
        /**
         * The ID of ECS Dedicated Host.
         */
        dedicatedHostId: string;
        /**
         * The name of ECS Dedicated Host.
         */
        dedicatedHostName: string;
        /**
         * The type of the dedicated host.
         */
        dedicatedHostType: string;
        /**
         * The description of the dedicated host.
         */
        description: string;
        /**
         * The expiration time of the subscription dedicated host.
         */
        expiredTime: string;
        /**
         * The GPU model.
         */
        gpuSpec: string;
        /**
         * ID of the ECS Dedicated Host.
         */
        id: string;
        /**
         * The machine code of the dedicated host.
         */
        machineId: string;
        /**
         * dedicated host network parameters. contains the following attributes:
         */
        networkAttributes: outputs.ecs.GetDedicatedHostsHostNetworkAttribute[];
        /**
         * The reason why the dedicated host resource is locked.
         */
        operationLocks: outputs.ecs.GetDedicatedHostsHostOperationLock[];
        /**
         * The billing method of the dedicated host.
         */
        paymentType: string;
        /**
         * The number of physical GPUs.
         */
        physicalGpus: number;
        /**
         * The ID of the resource group to which the ECS Dedicated Host belongs.
         */
        resourceGroupId: string;
        /**
         * The unit of the subscription billing method.
         */
        saleCycle: string;
        /**
         * The number of physical CPUs.
         */
        sockets: number;
        /**
         * The status of the ECS Dedicated Host. validate value: `Available`, `Creating`, `PermanentFailure`, `Released`, `UnderAssessment`.
         */
        status: string;
        /**
         * (Available in 1.123.1+) A custom instance type family supported by a dedicated host.
         */
        supportedCustomInstanceTypeFamilies: string[];
        /**
         * (Available in 1.123.1+) ECS instance type family supported by the dedicated host.
         */
        supportedInstanceTypeFamilies: string[];
        /**
         * The list of ECS instance
         */
        supportedInstanceTypesLists: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The zone ID of the ECS Dedicated Host.
         */
        zoneId: string;
    }

    export interface GetDedicatedHostsHostCapacity {
        /**
         * The remaining local disk capacity. Unit: GiB.
         */
        availableLocalStorage: number;
        /**
         * The remaining memory capacity, unit: GiB.
         */
        availableMemory: number;
        /**
         * The number of remaining vCPU cores.
         */
        availableVcpus: number;
        /**
         * The number of available virtual GPUs.
         */
        availableVgpus: number;
        /**
         * Local disk type.
         */
        localStorageCategory: string;
        /**
         * The total capacity of the local disk, in GiB.
         */
        totalLocalStorage: number;
        /**
         * The total memory capacity, unit: GiB.
         */
        totalMemory: number;
        /**
         * The total number of vCPU cores.
         */
        totalVcpus: number;
        /**
         * The total number of virtual GPUs.
         */
        totalVgpus: number;
    }

    export interface GetDedicatedHostsHostNetworkAttribute {
        /**
         * The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds.
         */
        slbUdpTimeout: number;
        /**
         * (Available in 1.123.1+) The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds.
         */
        udpTimeout: number;
    }

    export interface GetDedicatedHostsHostOperationLock {
        /**
         * The reason why the dedicated host resource is locked.
         */
        lockReason: string;
    }

    export interface GetDedicatedHostsOperationLock {
        /**
         * The reason why the dedicated host resource is locked.
         */
        lockReason?: string;
    }

    export interface GetDisksDisk {
        /**
         * Disk attachment time.
         */
        attachedTime: string;
        autoSnapshotPolicyId: string;
        /**
         * Availability zone of the disk.
         */
        availabilityZone: string;
        /**
         * Disk category. Possible values: `cloud` (basic cloud disk), `cloudEfficiency` (ultra cloud disk), `ephemeralSsd` (local SSD cloud disk), `cloudSsd` (SSD cloud disk), and `cloudEssd` (ESSD cloud disk).
         */
        category: string;
        /**
         * Disk creation time.
         */
        creationTime: string;
        deleteAutoSnapshot: boolean;
        deleteWithInstance: boolean;
        /**
         * Disk description.
         */
        description: string;
        /**
         * Disk detachment time.
         */
        detachedTime: string;
        device: string;
        diskId: string;
        diskName: string;
        diskType: string;
        enableAutoSnapshot: boolean;
        enableAutomatedSnapshotPolicy: boolean;
        /**
         * Indicate whether the disk is encrypted or not. Possible values: `on` and `off`.
         */
        encrypted: string;
        expiredTime: string;
        /**
         * ID of the disk.
         */
        id: string;
        /**
         * ID of the image from which the disk is created. It is null unless the disk is created using an image.
         */
        imageId: string;
        /**
         * Filter the results by the specified ECS instance ID.
         */
        instanceId: string;
        iops: number;
        iopsRead: number;
        iopsWrite: number;
        kmsKeyId: string;
        mountInstanceNum: number;
        mountInstances: outputs.ecs.GetDisksDiskMountInstance[];
        /**
         * Disk name.
         */
        name: string;
        operationLocks: outputs.ecs.GetDisksDiskOperationLock[];
        paymentType: string;
        performanceLevel: string;
        portable: boolean;
        productCode: string;
        /**
         * Region ID the disk belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group which the disk belongs.
         */
        resourceGroupId: string;
        /**
         * Disk size in GiB.
         */
        size: number;
        /**
         * Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
         */
        snapshotId: string;
        /**
         * Current status. Possible values: `In_use`, `Available`, `Attaching`, `Detaching`, `Creating` and `ReIniting`.
         */
        status: string;
        /**
         * A map of tags assigned to the disks. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const disksDs = pulumi.output(alicloud.ecs.getDisks({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * Disk type. Possible values: `system` and `data`.
         */
        type: string;
        zoneId: string;
    }

    export interface GetDisksDiskMountInstance {
        /**
         * Disk attachment time.
         */
        attachedTime: string;
        device: string;
        /**
         * Filter the results by the specified ECS instance ID.
         */
        instanceId: string;
    }

    export interface GetDisksDiskOperationLock {
        lockReason: string;
    }

    export interface GetDisksOperationLock {
        lockReason?: string;
    }

    export interface GetEcsDedicatedHostClustersCluster {
        /**
         * The capacity of the dedicated host cluster.
         */
        dedicatedHostClusterCapacities: outputs.ecs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacity[];
        /**
         * The ID of the dedicated host cluster.
         */
        dedicatedHostClusterId: string;
        /**
         * The name of the dedicated host cluster.
         */
        dedicatedHostClusterName: string;
        /**
         * The IDs of dedicated hosts in the dedicated host cluster.
         */
        dedicatedHostIds: string[];
        /**
         * The description of the dedicated host cluster.
         */
        description: string;
        /**
         * The ID of the Dedicated Host Cluster.
         */
        id: string;
        /**
         * The ID of the resource group to which the dedicated host cluster belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The zone ID of the dedicated host cluster.
         */
        zoneId: string;
    }

    export interface GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacity {
        /**
         * The available memory size. Unit: `GiB`.
         */
        availableMemory: number;
        /**
         * The number of available vCPUs.
         */
        availableVcpus: number;
        /**
         * The local storage.
         */
        localStorageCapacities: outputs.ecs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacity[];
        /**
         * The total memory size. Unit: `GiB`.
         */
        totalMemory: number;
        /**
         * The total number of vCPUs.
         */
        totalVcpus: number;
    }

    export interface GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacity {
        /**
         * The available capacity of the local disk. Unit: `GiB`.
         */
        availableDisk: number;
        /**
         * The category of the data disk. Valid values:`cloud`, `cloudEfficiency`, `cloudSsd`, `ephemeralSsd`, `cloudEssd`.
         */
        dataDiskCategory: string;
        /**
         * The total capacity of the local disk. Unit: `GiB`.
         */
        totalDisk: number;
    }

    export interface GetEcsDeploymentSetsSet {
        /**
         * The time when the deployment set was created.
         */
        createTime: string;
        /**
         * The ID of the Deployment Set.
         */
        deploymentSetId: string;
        /**
         * The name of the deployment set.
         */
        deploymentSetName: string;
        /**
         * The description of the deployment set.
         */
        description: string;
        /**
         * The deployment domain.
         */
        domain: string;
        /**
         * The deployment granularity.
         */
        granularity: string;
        /**
         * The ID of the Deployment Set.
         */
        id: string;
        /**
         * The number of instances in the deployment set.
         */
        instanceAmount: number;
        /**
         * The IDs of the instances in the deployment set.
         */
        instanceIds: string[];
        /**
         * The deployment strategy.
         */
        strategy: string;
    }

    export interface GetEcsDisksDisk {
        /**
         * A mount of time.
         */
        attachedTime: string;
        /**
         * Query cloud disks based on the automatic snapshot policy ID.
         */
        autoSnapshotPolicyId: string;
        /**
         * Availability zone of the disk.
         */
        availabilityZone: string;
        /**
         * Disk category.
         */
        category: string;
        /**
         * Disk creation time.
         */
        creationTime: string;
        /**
         * Indicates whether the automatic snapshot is deleted when the disk is released.
         */
        deleteAutoSnapshot: boolean;
        /**
         * Indicates whether the disk is released together with the instance.
         */
        deleteWithInstance: boolean;
        /**
         * Disk description.
         */
        description: string;
        /**
         * Disk detachment time.
         */
        detachedTime: string;
        /**
         * The mount point of the disk.
         */
        device: string;
        /**
         * ID of the disk.
         */
        diskId: string;
        /**
         * The disk name.
         */
        diskName: string;
        /**
         * The disk type.
         */
        diskType: string;
        /**
         * Whether the disk implements an automatic snapshot policy.
         */
        enableAutoSnapshot: boolean;
        /**
         * Whether the disk implements an automatic snapshot policy.
         */
        enableAutomatedSnapshotPolicy: boolean;
        /**
         * Indicate whether the disk is encrypted or not.
         */
        encrypted: string;
        expiredTime: string;
        /**
         * ID of the disk.
         */
        id: string;
        /**
         * ID of the image from which the disk is created. It is null unless the disk is created using an image.
         */
        imageId: string;
        /**
         * The instance ID of the disk mount.
         */
        instanceId: string;
        iops: number;
        iopsRead: number;
        iopsWrite: number;
        /**
         * The kms key id.
         */
        kmsKeyId: string;
        /**
         * Number of instances mounted on shared storage.
         */
        mountInstanceNum: number;
        /**
         * Disk mount instances.
         */
        mountInstances: outputs.ecs.GetEcsDisksDiskMountInstance[];
        /**
         * Disk name.
         */
        name: string;
        operationLocks: outputs.ecs.GetEcsDisksDiskOperationLock[];
        /**
         * Payment method for disk.
         */
        paymentType: string;
        /**
         * Performance levels of ESSD cloud disk.
         */
        performanceLevel: string;
        /**
         * Whether the disk is unmountable.
         */
        portable: boolean;
        /**
         * The product logo of the cloud market.
         */
        productCode: string;
        /**
         * Region ID the disk belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group.
         */
        resourceGroupId: string;
        /**
         * Disk size in GiB.
         */
        size: number;
        /**
         * Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
         */
        snapshotId: string;
        /**
         * Current status.
         */
        status: string;
        /**
         * A map of tags assigned to the disk.
         */
        tags: {[key: string]: any};
        /**
         * Disk type.
         */
        type: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetEcsDisksDiskMountInstance {
        /**
         * A mount of time.
         */
        attachedTime: string;
        /**
         * The mount point of the disk.
         */
        device: string;
        /**
         * The instance ID of the disk mount.
         */
        instanceId: string;
    }

    export interface GetEcsDisksDiskOperationLock {
        lockReason: string;
    }

    export interface GetEcsDisksOperationLock {
        lockReason?: string;
    }

    export interface GetEcsKeyPairsKeyPair {
        /**
         * The finger print of the key pair.
         */
        fingerPrint: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetEcsKeyPairsKeyPairInstance[];
        /**
         * The Key Pair Name.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Resource Group Id.
         */
        resourceGroupId: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsKeyPairsKeyPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * The Key Pair Name.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetEcsKeyPairsPair {
        /**
         * The finger print of the key pair.
         */
        fingerPrint: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetEcsKeyPairsPairInstance[];
        /**
         * The Key Pair Name.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Resource Group Id.
         */
        resourceGroupId: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsKeyPairsPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * The Key Pair Name.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetEcsLaunchTemplatesTemplate {
        /**
         * Instance auto release time.
         */
        autoReleaseTime: string;
        /**
         * CreatedBy.
         */
        createdBy: string;
        /**
         * The list of data disks created with instance.
         */
        dataDisks: outputs.ecs.GetEcsLaunchTemplatesTemplateDataDisk[];
        /**
         * The Default Version Number.
         */
        defaultVersionNumber: number;
        /**
         * The Deployment Set Id.
         */
        deploymentSetId: string;
        /**
         * System disk description.
         */
        description: string;
        /**
         * Whether to enable the instance operating system configuration.
         */
        enableVmOsConfig: boolean;
        /**
         * Instance host name.
         */
        hostName: string;
        /**
         * The ID of the Launch Template.
         */
        id: string;
        /**
         * The Image Id.
         */
        imageId: string;
        /**
         * Mirror source.
         */
        imageOwnerAlias: string;
        /**
         * Internet bandwidth billing method.
         */
        instanceChargeType: string;
        /**
         * The Instance Name.
         */
        instanceName: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Internet bandwidth billing method.
         */
        internetChargeType: string;
        /**
         * The maximum inbound bandwidth from the Internet network, measured in Mbit/s.
         */
        internetMaxBandwidthIn: number;
        /**
         * Maximum outbound bandwidth from the Internet, its unit of measurement is Mbit/s.
         */
        internetMaxBandwidthOut: number;
        /**
         * Whether it is an I/O-optimized instance or not.
         */
        ioOptimized: string;
        /**
         * The name of the key pair.
         */
        keyPairName: string;
        /**
         * The Latest Version Number.
         */
        latestVersionNumber: number;
        /**
         * The ID of the Launch Template.
         */
        launchTemplateId: string;
        /**
         * The Launch Template Name.
         */
        launchTemplateName: string;
        /**
         * The Modified Time.
         */
        modifiedTime: string;
        /**
         * The list of network interfaces created with instance.
         */
        networkInterfaces: outputs.ecs.GetEcsLaunchTemplatesTemplateNetworkInterface[];
        /**
         * Network type of the instance.
         */
        networkType: string;
        /**
         * Whether to use the password preset by the mirror.
         */
        passwordInherit: boolean;
        /**
         * The subscription period of the instance.
         */
        period: number;
        /**
         * The private IP address of the instance.
         */
        privateIpAddress: string;
        /**
         * The RAM role name of the instance.
         */
        ramRoleName: string;
        /**
         * The ID of the resource group to which to assign the instance, Elastic Block Storage (EBS) device, and ENI.
         */
        resourceGroupId: string;
        /**
         * Whether or not to activate the security enhancement feature and install network security software free of charge.
         */
        securityEnhancementStrategy: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The security group IDs.
         */
        securityGroupIds: string[];
        /**
         * The protection period of the preemptible instance.
         */
        spotDuration: string;
        /**
         * Sets the maximum hourly instance price.
         */
        spotPriceLimit: number;
        /**
         * The spot strategy for a Pay-As-You-Go instance.
         */
        spotStrategy: string;
        /**
         * The System Disk.
         */
        systemDisks: outputs.ecs.GetEcsLaunchTemplatesTemplateSystemDisk[];
        /**
         * The template tags.
         */
        templateTags: {[key: string]: any};
        /**
         * The User Data.
         */
        userData: string;
        /**
         * The Version Description.
         */
        versionDescription: string;
        /**
         * VpcId.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone Id.
         */
        zoneId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateDataDisk {
        /**
         * The category of the system disk.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released.
         */
        deleteWithInstance: boolean;
        /**
         * System disk description.
         */
        description: string;
        /**
         * Encrypted the data in this disk.
         */
        encrypted: boolean;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        performanceLevel: string;
        /**
         * Size of the system disk, measured in GB.
         */
        size: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateNetworkInterface {
        /**
         * System disk description.
         */
        description: string;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateSystemDisk {
        /**
         * The category of the system disk.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released.
         */
        deleteWithInstance: boolean;
        /**
         * System disk description.
         */
        description: string;
        /**
         * The Iops.
         */
        iops: string;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        performanceLevel: string;
        /**
         * Size of the system disk, measured in GB.
         */
        size: number;
    }

    export interface GetEcsNetworkInterfacesInterface {
        /**
         * The creation time.
         */
        creationTime: string;
        /**
         * The description of the ENI.
         */
        description: string;
        /**
         * The ID of the Network Interface.
         */
        id: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The MAC address of the ENI.
         */
        mac: string;
        /**
         * The network interface name.
         */
        name: string;
        /**
         * The network interface id.
         */
        networkInterfaceId: string;
        /**
         * The network interface name.
         */
        networkInterfaceName: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIpAddress: string;
        /**
         * The primary private IP address of the ENI.
         */
        privateIp: string;
        privateIpAddresses: string[];
        /**
         * A list of secondary private IP address that is assigned to the ENI.
         */
        privateIps: string[];
        /**
         * Number of network card queues.
         */
        queueNumber: number;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * The security group ids.
         */
        securityGroupIds: string[];
        /**
         * The security groups.
         */
        securityGroups: string[];
        /**
         * The service id.
         */
        serviceId: number;
        /**
         * Whether the user of the elastic network card is a cloud product or a virtual vendor.
         */
        serviceManaged: boolean;
        /**
         * The status of the ENI.
         */
        status: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
        /**
         * The type of the ENI.
         */
        type: string;
        /**
         * The Vpc Id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetEcsSnapshotsSnapshot {
        /**
         * The category of the snapshot.
         */
        category: string;
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The source disk id.
         */
        diskId: string;
        /**
         * Whether the snapshot is encrypted.
         */
        encrypted: boolean;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * Whether snapshot speed availability is enabled.
         */
        instantAccess: boolean;
        /**
         * Specifies the retention period of the instant access feature. After the retention period ends, the snapshot is automatically released.
         */
        instantAccessRetentionDays: number;
        name: string;
        /**
         * The product number inherited from the mirror market.
         */
        productCode: string;
        /**
         * Snapshot creation progress, in percentage.
         */
        progress: string;
        /**
         * Remaining completion time for the snapshot being created.
         */
        remainTime: number;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * Automatic snapshot retention days.
         */
        retentionDays: number;
        /**
         * The snapshot id.
         */
        snapshotId: string;
        /**
         * Snapshot Display Name.
         */
        snapshotName: string;
        /**
         * The serial number of the snapshot.
         */
        snapshotSn: string;
        /**
         * Snapshot creation type.
         */
        snapshotType: string;
        sourceDiskId: string;
        /**
         * Source disk capacity.
         */
        sourceDiskSize: string;
        /**
         * Source disk attributes.
         */
        sourceDiskType: string;
        /**
         * Original disk type.
         */
        sourceStorageType: string;
        /**
         * The status of the snapshot.
         */
        status: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * A resource type that has a reference relationship.
         */
        usage: string;
    }

    export interface GetEipAddressesAddress {
        /**
         * The name of the EIP.
         */
        addressName: string;
        /**
         * The ID of the EIP.
         */
        allocationId: string;
        /**
         * The ID of the region to which the EIP belongs.
         */
        availableRegions: string[];
        /**
         * The maximum bandwidth of the EIP. Unit: Mbit/s.
         */
        bandwidth: string;
        /**
         * The bandwidth value of the EIP bandwidth plan with which the EIP is associated.
         */
        bandwidthPackageBandwidth: string;
        /**
         * The ID of the EIP bandwidth plan.
         */
        bandwidthPackageId: string;
        /**
         * The type of the bandwidth. Only CommonBandwidthPackage (an EIP bandwidth plan) is returned.
         */
        bandwidthPackageType: string;
        /**
         * The time when the EIP was created.
         */
        createTime: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The description of the EIP.
         */
        description: string;
        /**
         * The expiration date. The time follows the ISO 8601 standard and is displayed in UTC. Format: YYYY-MM-DDThh:mmZ.
         */
        expiredTime: string;
        /**
         * Indicates whether renewal data is included. This parameter returns true only when the parameter IncludeReservationData is set to true, and some orders have not taken effect.
         */
        hasReservationData: string;
        /**
         * Indicates whether fine-grained monitoring is enabled for the EIP.
         */
        hdMonitorStatus: string;
        /**
         * The ID of the Address.
         */
        id: string;
        /**
         * The ID of the instance with which the EIP is associated.
         */
        instanceId: string;
        /**
         * The region ID of the associated resource.
         */
        instanceRegionId: string;
        /**
         * The type of the instance with which the EIP is associated.
         */
        instanceType: string;
        /**
         * The metering method of the EIP.
         */
        internetChargeType: string;
        /**
         * The IP address of the EIP.
         */
        ipAddress: string;
        /**
         * The Internet service provider (ISP).
         */
        isp: string;
        /**
         * The details about the locked EIP.
         */
        operationLocks: string[];
        /**
         * The billing method of the EIP.
         */
        paymentType: string;
        /**
         * The time when the renewal takes effect.
         */
        reservationActiveTime: string;
        /**
         * The bandwidth after the renewal takes effect.
         */
        reservationBandwidth: string;
        /**
         * The metering method of the renewal.
         */
        reservationInternetChargeType: string;
        /**
         * The type of the renewal order.
         */
        reservationOrderType: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * Indicates whether level-2 throttling is configured.
         */
        secondLimited: boolean;
        /**
         * The IDs of the contiguous EIPs.
         */
        segmentInstanceId: string;
        /**
         * The status of the EIP.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetEipAddressesEip {
        /**
         * The maximum bandwidth of the EIP. Unit: Mbit/s.
         */
        bandwidth: string;
        creationTime: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The ID of the Address.
         */
        id: string;
        /**
         * The ID of the instance with which the EIP is associated.
         */
        instanceId: string;
        /**
         * The type of the instance with which the EIP is associated.
         */
        instanceType: string;
        /**
         * The metering method of the EIP.
         */
        internetChargeType: string;
        /**
         * The IP address of the EIP.
         */
        ipAddress: string;
        /**
         * The status of the EIP.
         */
        status: string;
    }

    export interface GetEipsAddress {
        addressName: string;
        allocationId: string;
        availableRegions: string[];
        /**
         * EIP internet max bandwidth in Mbps.
         */
        bandwidth: string;
        bandwidthPackageBandwidth: string;
        bandwidthPackageId: string;
        bandwidthPackageType: string;
        createTime: string;
        /**
         * (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
         */
        deletionProtection: boolean;
        description: string;
        expiredTime: string;
        hasReservationData: string;
        hdMonitorStatus: string;
        /**
         * ID of the EIP.
         */
        id: string;
        /**
         * The ID of the instance that is being bound.
         */
        instanceId: string;
        instanceRegionId: string;
        /**
         * The instance type of that the EIP is bound.
         */
        instanceType: string;
        /**
         * EIP internet charge type.
         */
        internetChargeType: string;
        /**
         * Public IP Address of the the EIP.
         */
        ipAddress: string;
        isp: string;
        operationLocks: string[];
        paymentType: string;
        reservationActiveTime: string;
        reservationBandwidth: string;
        reservationInternetChargeType: string;
        reservationOrderType: string;
        /**
         * The Id of resource group which the eips belongs.
         */
        resourceGroupId: string;
        secondLimited: boolean;
        segmentInstanceId: string;
        /**
         * EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetEipsEip {
        /**
         * EIP internet max bandwidth in Mbps.
         */
        bandwidth: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
         */
        deletionProtection: boolean;
        /**
         * ID of the EIP.
         */
        id: string;
        /**
         * The ID of the instance that is being bound.
         */
        instanceId: string;
        /**
         * The instance type of that the EIP is bound.
         */
        instanceType: string;
        /**
         * EIP internet charge type.
         */
        internetChargeType: string;
        /**
         * Public IP Address of the the EIP.
         */
        ipAddress: string;
        /**
         * EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
         */
        status: string;
    }

    export interface GetHpcClustersCluster {
        /**
         * The description of ECS Hpc Cluster.
         */
        description: string;
        /**
         * The ID of the Hpc Cluster.
         */
        hpcClusterId: string;
        /**
         * The ID of the Hpc Cluster.
         */
        id: string;
        /**
         * The name of ECS Hpc Cluster.
         */
        name: string;
    }

    export interface GetImagesImage {
        /**
         * The image architecture. Valid values: `i386` and `x8664`.
         */
        architecture: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the image.
         */
        description: string;
        /**
         * Description of the system with disks and snapshots under the image.
         */
        diskDeviceMappings: outputs.ecs.GetImagesImageDiskDeviceMapping[];
        /**
         * ID of the image.
         */
        id: string;
        /**
         * The ID of the image.
         */
        imageId: string;
        /**
         * Alias of the image owner.
         */
        imageOwnerAlias: string;
        /**
         * Version of the image.
         */
        imageVersion: string;
        isCopied: boolean;
        isSelfShared: string;
        /**
         * Whether the user has subscribed to the terms of service for the image product corresponding to the ProductCode.
         */
        isSubscribed: boolean;
        /**
         * Specifies whether the image can be used on I/O optimized instances.
         */
        isSupportIoOptimized: boolean;
        name: string;
        /**
         * Display Chinese name of the OS.
         */
        osName: string;
        /**
         * Display English name of the OS.
         */
        osNameEn: string;
        /**
         * The operating system type of the image. Valid values: `windows` and `linux`.
         */
        osType: string;
        platform: string;
        /**
         * Product code of the image on the image market.
         */
        productCode: string;
        /**
         * Progress of image creation, presented in percentages.
         */
        progress: string;
        /**
         * Size of the created disk.
         */
        size: number;
        state: string;
        /**
         * The status of the image. The following values are available, Separate multiple parameter values by using commas (,). Default value: `Available`. Valid values: 
         * * `Creating`: The image is being created.
         * * `Waiting`: The image is waiting to be processed.
         * * `Available`: The image is available.
         * * `UnAvailable`: The image is unavailable.
         * * `CreateFailed`: The image failed to be created.
         * * `Deprecated`: The image is discontinued.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * Specifies whether to check the validity of the request without actually making the request. Valid values:                                           
         * * `instance`: The image is already in use and running on an ECS instance.
         * * `none`: The image is not in use.
         */
        usage: string;
    }

    export interface GetImagesImageDiskDeviceMapping {
        /**
         * Device information of the created disk: such as /dev/xvdb.
         */
        device: string;
        /**
         * Size of the created disk.
         */
        size: string;
        /**
         * The ID of the snapshot used to create the custom image.
         */
        snapshotId: string;
    }

    export interface GetInstanceTypeFamiliesFamily {
        /**
         * The generation of the instance type family, Valid values: `ecs-1`, `ecs-2`, `ecs-3` and `ecs-4`. For more information, see [Instance type families](https://www.alibabacloud.com/help/doc-detail/25378.htm).
         */
        generation: string;
        /**
         * ID of the instance type family.
         */
        id: string;
        /**
         * A list of Zone to launch the instance.
         */
        zoneIds: string[];
    }

    export interface GetInstanceTypesInstanceType {
        /**
         * List of availability zones that support the instance type.
         */
        availabilityZones: string[];
        /**
         * The burstable instance attribution:
         */
        burstableInstance: outputs.ecs.GetInstanceTypesInstanceTypeBurstableInstance;
        /**
         * Filter the results to a specific number of cpu cores.
         */
        cpuCoreCount: number;
        /**
         * Filter the result whose network interface number is no more than `eniAmount`.
         */
        eniAmount: number;
        /**
         * The instance type family.
         */
        family: string;
        /**
         * The GPU attribution of an instance type:
         */
        gpu: outputs.ecs.GetInstanceTypesInstanceTypeGpu;
        /**
         * ID of the instance type.
         */
        id: string;
        /**
         * Local storage of an instance type:
         */
        localStorage: outputs.ecs.GetInstanceTypesInstanceTypeLocalStorage;
        /**
         * Filter the results to a specific memory size in GB.
         */
        memorySize: number;
        price: string;
    }

    export interface GetInstanceTypesInstanceTypeBurstableInstance {
        /**
         * The compute performance benchmark CPU credit of a burstable instance.
         */
        baselineCredit: string;
        /**
         * The initial CPU credit of a burstable instance.
         */
        initialCredit: string;
    }

    export interface GetInstanceTypesInstanceTypeGpu {
        /**
         * The number of local storage devices that an instance has been attached to.
         */
        amount: string;
        /**
         * The category of local storage that an instance has been attached to.
         */
        category: string;
    }

    export interface GetInstanceTypesInstanceTypeLocalStorage {
        /**
         * The number of local storage devices that an instance has been attached to.
         */
        amount: string;
        /**
         * The capacity of a local storage in GB.
         */
        capacity: string;
        /**
         * The category of local storage that an instance has been attached to.
         */
        category: string;
    }

    export interface GetInstancesInstance {
        /**
         * Availability zone where instances are located.
         */
        availabilityZone: string;
        /**
         * Instance creation time.
         */
        creationTime: string;
        /**
         * Instance description.
         */
        description: string;
        /**
         * Description of the attached disks.
         */
        diskDeviceMappings: outputs.ecs.GetInstancesInstanceDiskDeviceMapping[];
        /**
         * EIP address the VPC instance is using.
         */
        eip: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The image ID of some ECS instance used.
         */
        imageId: string;
        /**
         * Instance charge type.
         */
        instanceChargeType: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Instance network charge type.
         */
        internetChargeType: string;
        /**
         * Max output bandwidth for internet.
         */
        internetMaxBandwidthOut: number;
        /**
         * Key pair the instance is using.
         */
        keyName: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * Instance private IP address.
         */
        privateIp: string;
        /**
         * Instance public IP address.
         */
        publicIp: string;
        /**
         * The RAM role name which the instance attaches.
         */
        ramRoleName: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group which the instance belongs.
         */
        resourceGroupId: string;
        /**
         * List of security group IDs the instance belongs to.
         */
        securityGroups: string[];
        /**
         * Spot strategy the instance is using.
         */
        spotStrategy: string;
        /**
         * Instance status. Valid values: "Creating", "Starting", "Running", "Stopping" and "Stopped". If undefined, all statuses are considered.
         */
        status: string;
        /**
         * A map of tags assigned to the ECS instances. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = pulumi.output(alicloud.ecs.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * ID of the VPC linked to the instances.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the instances.
         */
        vswitchId: string;
    }

    export interface GetInstancesInstanceDiskDeviceMapping {
        /**
         * Cloud disk category.
         */
        category: string;
        /**
         * Device information of the created disk: such as /dev/xvdb.
         */
        device: string;
        /**
         * Size of the created disk.
         */
        size: number;
        /**
         * Cloud disk type: system disk or data disk.
         */
        type: string;
    }

    export interface GetKeyPairsKeyPair {
        /**
         * A finger print used to retrieve specified key pair.
         */
        fingerPrint: string;
        /**
         * ID of the key pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetKeyPairsKeyPairInstance[];
        /**
         * Name of the key pair.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Id of resource group which the key pair belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetKeyPairsKeyPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * Name of the key pair.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetKeyPairsPair {
        /**
         * A finger print used to retrieve specified key pair.
         */
        fingerPrint: string;
        /**
         * ID of the key pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetKeyPairsPairInstance[];
        /**
         * Name of the key pair.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Id of resource group which the key pair belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetKeyPairsPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * Name of the key pair.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetNetworkInterfacesInterface {
        /**
         * Creation time of the ENI.
         */
        creationTime: string;
        /**
         * Description of the ENI.
         */
        description: string;
        /**
         * ID of the ENI.
         */
        id: string;
        /**
         * ID of the instance that the ENI is attached to.
         */
        instanceId: string;
        /**
         * MAC address of the ENI.
         */
        mac: string;
        /**
         * Name of the ENI.
         */
        name: string;
        networkInterfaceId: string;
        networkInterfaceName: string;
        primaryIpAddress: string;
        /**
         * Primary private IP of the ENI.
         */
        privateIp: string;
        privateIpAddresses: string[];
        /**
         * A list of secondary private IP address that is assigned to the ENI.
         */
        privateIps: string[];
        queueNumber: number;
        /**
         * The Id of resource group.
         */
        resourceGroupId: string;
        securityGroupIds: string[];
        /**
         * A list of security group that the ENI belongs to.
         */
        securityGroups: string[];
        serviceId: number;
        serviceManaged: boolean;
        /**
         * Current status of the ENI.
         */
        status: string;
        /**
         * A map of tags assigned to the ENI.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * ID of the VPC that the ENI belongs to.
         */
        vpcId: string;
        /**
         * ID of the VSwitch that the ENI is linked to.
         */
        vswitchId: string;
        /**
         * ID of the availability zone that the ENI belongs to.
         */
        zoneId: string;
    }

    export interface GetSecurityGroupRulesRule {
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Target IP address segment for egress authorization.
         */
        destCidrIp: string;
        /**
         * Target security group id for ingress authorization.
         */
        destGroupId: string;
        /**
         * Alibaba Cloud account of the target security group.
         */
        destGroupOwnerAccount: string;
        /**
         * Authorization direction. Valid values are: `ingress` or `egress`.
         */
        direction: string;
        /**
         * The IP protocol. Valid values are: `tcp`, `udp`, `icmp`, `gre` and `all`.
         */
        ipProtocol: string;
        /**
         * Refers to the network type. Can be either `internet` or `intranet`. The default value is `internet`.
         */
        nicType: string;
        /**
         * Authorization policy. Can be either `accept` or `drop`. The default value is `accept`.
         */
        policy: string;
        /**
         * The range of port numbers.
         */
        portRange: string;
        /**
         * Rule priority.
         */
        priority: number;
        /**
         * Source IP address segment for ingress authorization.
         */
        sourceCidrIp: string;
        /**
         * Source security group ID for ingress authorization.
         */
        sourceGroupId: string;
        /**
         * Alibaba Cloud account of the source security group.
         */
        sourceGroupOwnerAccount: string;
    }

    export interface GetSecurityGroupsGroup {
        /**
         * Creation time of the security group.
         */
        creationTime: string;
        /**
         * The description of the security group.
         */
        description: string;
        /**
         * The ID of the security group.
         */
        id: string;
        /**
         * Whether to allow inner network access.
         */
        innerAccess: boolean;
        /**
         * The name of the security group.
         */
        name: string;
        /**
         * The Id of resource group which the securityGroup belongs.
         */
        resourceGroupId: string;
        /**
         * The type of the security group.
         */
        securityGroupType: string;
        /**
         * A map of tags assigned to the ECS instances. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedSecurityGroups = pulumi.output(alicloud.ecs.getSecurityGroups({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * Used to retrieve security groups that belong to the specified VPC ID.
         */
        vpcId: string;
    }

    export interface GetSnapshotsSnapshot {
        category: string;
        /**
         * Creation time. Time of creation. It is represented according to ISO8601, and UTC time is used. Format: YYYY-MM-DDThh:mmZ.
         */
        creationTime: string;
        /**
         * Description of the snapshot.
         */
        description: string;
        diskId: string;
        /**
         * Whether the snapshot is encrypted or not.
         */
        encrypted: boolean;
        /**
         * ID of the snapshot.
         */
        id: string;
        instantAccess: boolean;
        instantAccessRetentionDays: number;
        /**
         * Name of the snapshot.
         */
        name: string;
        /**
         * Product code on the image market place.
         */
        productCode: string;
        /**
         * Progress of snapshot creation, presented in percentage.
         */
        progress: string;
        /**
         * The remaining time of a snapshot creation task, in seconds.
         */
        remainTime: number;
        resourceGroupId: string;
        /**
         * The number of days that an automatic snapshot retains in the console for your instance.
         */
        retentionDays: number;
        snapshotId: string;
        snapshotName: string;
        snapshotSn: string;
        snapshotType: string;
        /**
         * Source disk ID, which is retained after the source disk of the snapshot is deleted.
         */
        sourceDiskId: string;
        /**
         * Size of the source disk, measured in GB.
         */
        sourceDiskSize: string;
        /**
         * Source disk attribute. Value range: `System`,`Data`.
         */
        sourceDiskType: string;
        sourceStorageType: string;
        /**
         * The snapshot status. Value range: `progressing`, `accomplished` and `failed`.
         */
        status: string;
        /**
         * A map of tags assigned to the snapshot.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * Whether the snapshots are used to create resources or not. Value range: `image`, `disk`, `imageDisk` and `none`.
         */
        usage: string;
    }

    export interface ImageDiskDeviceMapping {
        /**
         * Specifies the name of a disk in the combined custom image. Value range: /dev/xvda to /dev/xvdz.
         */
        device: string;
        /**
         * Specifies the type of a disk in the combined custom image. If you specify this parameter, you can use a data disk snapshot as the data source of a system disk for creating an image. If it is not specified, the disk type is determined by the corresponding snapshot. Valid values: `system`, `data`,
         */
        diskType: string;
        /**
         * Specifies the size of a disk in the combined custom image, in GiB. Value range: 5 to 2000.
         */
        size: number;
        /**
         * Specifies a snapshot that is used to create a combined custom image.
         */
        snapshotId: string;
    }

    export interface ImageImportDiskDeviceMapping {
        /**
         * The name of disk N in the custom image.
         */
        device: string;
        /**
         * Resolution size. You must ensure that the system disk space ≥ file system space. Ranges: When n = 1, the system disk: 5 ~ 500GiB, When n = 2 ~ 17, that is, data disk: 5 ~ 1000GiB, When temporary is introduced, the system automatically detects the size, which is subject to the detection result.
         */
        diskImageSize?: number;
        /**
         * Image format. Value range: When the `RAW`, `VHD`, `qcow2` is imported into the image, the system automatically detects the image format, whichever comes first.
         */
        format: string;
        /**
         * Save the exported OSS bucket.
         */
        ossBucket?: string;
        /**
         * The file name of your OSS Object.
         */
        ossObject?: string;
    }

    export interface InstanceDataDisk {
        /**
         * The ID of the automatic snapshot policy applied to the system disk.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The category of the disk:
         * - `cloud`: The general cloud disk.
         * - `cloudEfficiency`: The efficiency cloud disk.
         * - `cloudSsd`: The SSD cloud disk.
         * - `cloudEssd`: The ESSD cloud disk.
         * - `ephemeralSsd`: The local SSD disk.
         * Default to `cloudEfficiency`.
         */
        category?: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_essd, cloudSsd disk. If the category of this data disk was ephemeral_ssd, please don't set this param. Default value: `true`.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * -(Optional, Bool, ForceNew) Encrypted the data in this disk. Default value: `false`.
         */
        encrypted?: boolean;
        /**
         * The KMS key ID corresponding to the Nth data disk.
         */
        kmsKeyId?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as data disk:
         * - `PL0`: A single ESSD can deliver up to 10,000 random read/write IOPS.
         * - `PL1`: A single ESSD can deliver up to 50,000 random read/write IOPS.
         * - `PL2`: A single ESSD can deliver up to 100,000 random read/write IOPS.
         * - `PL3`: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
         * Default to `PL1`.
         */
        performanceLevel: string;
        /**
         * The size of the data disk.
         * - cloud：[5, 2000]
         * - cloud_efficiency：[20, 32768]
         * - cloud_ssd：[20, 32768]
         * - cloud_essd：[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface LaunchTemplateDataDisk {
        /**
         * The category of the disk:
         * - cloud: Basic cloud disk.
         * - cloud_efficiency: Ultra cloud disk.
         * - cloud_ssd: SSD cloud Disks.
         * - ephemeral_ssd: local SSD Disks
         * - cloud_essd: ESSD cloud Disks.
         */
        category?: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloudSsd and cloudEssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * -(Optional, Bool) Encrypted the data in this disk.
         */
        encrypted?: boolean;
        /**
         * The name of the data disk.
         */
        name?: string;
        performanceLevel?: string;
        /**
         * The size of the data disk.
         * - cloud：[5, 2000]
         * - cloud_efficiency：[20, 32768]
         * - cloud_ssd：[20, 32768]
         * - cloud_essd：[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size?: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface LaunchTemplateNetworkInterfaces {
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp?: string;
        /**
         * The security group ID must be one in the same VPC.
         */
        securityGroupId?: string;
        /**
         * The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
         */
        vswitchId?: string;
    }

    export interface LaunchTemplateSystemDisk {
        /**
         * The category of the disk:
         * - cloud: Basic cloud disk.
         * - cloud_efficiency: Ultra cloud disk.
         * - cloud_ssd: SSD cloud Disks.
         * - ephemeral_ssd: local SSD Disks
         * - cloud_essd: ESSD cloud Disks.
         */
        category: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloudSsd and cloudEssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description: string;
        iops?: string;
        /**
         * The name of the data disk.
         */
        name: string;
        performanceLevel?: string;
        /**
         * The size of the data disk.
         * - cloud：[5, 2000]
         * - cloud_efficiency：[20, 32768]
         * - cloud_ssd：[20, 32768]
         * - cloud_essd：[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size: number;
    }

}

export namespace edas {
    export interface GetApplicationsApplication {
        /**
         * The ID of the application that you want to deploy.
         */
        appId: string;
        /**
         * The name of your EDAS application. Only letters '-' '_' and numbers are allowed. The length cannot exceed 36 characters.
         */
        appName: string;
        /**
         * The type of the package for the deployment of the application that you want to create. The valid values are: WAR and JAR. We strongly recommend you to set this parameter when creating the application.
         */
        applicationType: string;
        /**
         * The package ID of Enterprise Distributed Application Service (EDAS) Container.
         */
        buildPackageId: number;
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The type of the cluster that you want to create. Valid values: 1: Swarm cluster. 2: ECS cluster. 3: Kubernates cluster.
         */
        clusterType: number;
        /**
         * The ID of the namespace the application belongs to.
         */
        regionId: string;
    }

    export interface GetClustersCluster {
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The name of the cluster.
         */
        clusterName: string;
        /**
         * The type of the cluster, Valid values: 1: Swarm cluster. 2: ECS cluster. 3: Kubernates cluster.
         */
        clusterType: number;
        /**
         * The total number of CPUs in the cluster.
         */
        cpu: number;
        /**
         * The number of used CPUs in the cluster.
         */
        cpuUsed: number;
        /**
         * Cluster's creation time.
         */
        createTime: number;
        /**
         * The total amount of memory in the cluser. Unit: MB.
         */
        mem: number;
        /**
         * The amount of used memory in the cluser. Unit: MB.
         */
        memUsed: number;
        /**
         * The network type of the cluster. Valid values: 1: classic network. 2: VPC.
         */
        networkMode: number;
        /**
         * The number of the Elastic Compute Service (ECS) instances that are deployed to the cluster.
         */
        nodeNum: number;
        /**
         * The ID of the namespace the application belongs to.
         */
        regionId: string;
        /**
         * The time when the cluster was last updated.
         */
        updateTime: number;
        /**
         * The ID of the Virtual Private Cloud (VPC) for the cluster.
         */
        vpcId: string;
    }

    export interface GetDeployGroupsGroup {
        /**
         * ID of the EDAS application.
         */
        appId: string;
        /**
         * The version of the deployment package for the application.
         */
        appVersionId: string;
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The time when the instance group was created.
         */
        createTime: number;
        /**
         * The ID of the instance group.
         */
        groupId: string;
        /**
         * The name of the instance group. The length cannot exceed 64 characters.
         */
        groupName: string;
        /**
         * The type of the instance group. Valid values: 0: Default group. 1: Phased release is disabled for traffic management. 2: Phased release is enabled for traffic management.
         */
        groupType: number;
        /**
         * The version of the deployment package for the instance group that was created.
         */
        packageVersionId: string;
        /**
         * The time when the instance group was updated.
         */
        updateTime: number;
    }

}

export namespace eds {
    export interface EcdPolicyGroupAuthorizeAccessPolicyRule {
        /**
         * The cidrip of authorize access rule.
         */
        cidrIp?: string;
        /**
         * The description of authorize access rule.
         */
        description?: string;
    }

    export interface EcdPolicyGroupAuthorizeSecurityPolicyRule {
        /**
         * The cidrip of authorize access rule.
         */
        cidrIp?: string;
        /**
         * The description of authorize access rule.
         */
        description?: string;
        /**
         * The ip protocol of security rules.
         */
        ipProtocol?: string;
        /**
         * The policy of security rules.
         */
        policy?: string;
        /**
         * The port range of security rules.
         */
        portRange?: string;
        /**
         * The priority of security rules.
         */
        priority?: string;
        /**
         * The type of security rules.
         */
        type?: string;
    }

    export interface GetBundlesBundle {
        /**
         * The bundle id of the bundle.
         */
        bundleId: string;
        /**
         * The name of the bundle.
         */
        bundleName: string;
        /**
         * The bundle type of  the bundle. Valid values: `SYSTEM`,`CUSTOM`.
         */
        bundleType: string;
        /**
         * The description of the bundle.
         */
        description: string;
        /**
         * The desktop type of the bundle.
         */
        desktopType: string;
        /**
         * The desktop type attribute of the bundle.
         */
        desktopTypeAttributes: outputs.eds.GetBundlesBundleDesktopTypeAttribute[];
        /**
         * The disks of the bundle.
         */
        disks: outputs.eds.GetBundlesBundleDisk[];
        /**
         * The ID of the bundle.
         */
        id: string;
        /**
         * The image id attribute of the bundle.
         */
        imageId: string;
        /**
         * The os type attribute of the bundle.
         */
        osType: string;
    }

    export interface GetBundlesBundleDesktopTypeAttribute {
        /**
         * The cpu count attribute of the bundle.
         */
        cpuCount: number;
        /**
         * The gpu count attribute of the bundle.
         */
        gpuCount: string;
        /**
         * The gpu spec attribute of the bundle.
         */
        gpuSpec: string;
        /**
         * The memory size attribute of the bundle.
         */
        memorySize: string;
    }

    export interface GetBundlesBundleDisk {
        /**
         * The disk size attribute of the bundle.
         */
        diskSize: string;
        /**
         * The disk type attribute of the bundle.
         */
        diskType: string;
    }

    export interface GetCommandsCommand {
        /**
         * The Contents of the Script to Base64 Encoded Transmission.
         */
        commandContent: string;
        /**
         * The Script Type. Valid values: `RunBatScript`, `RunPowerShellScript`.
         */
        commandType: string;
        /**
         * The Task of Creation Time.
         */
        createTime: string;
        /**
         * The ID of the Command.
         */
        id: string;
        /**
         * The Implementation of the Target Cloud Desktop Collection.
         */
        invokeDesktops: outputs.eds.GetCommandsCommandInvokeDesktop[];
        /**
         * The invoke id of the Command.
         */
        invokeId: string;
        /**
         * Script Is Executed in the Overall Implementation of the State. Valid values: `Pending`, `Failed`, `PartialFailed`, `Running`, `Stopped`, `Stopping`, `Finished`, `Success`.
         */
        status: string;
    }

    export interface GetCommandsCommandInvokeDesktop {
        /**
         * The desktop id of the Desktop.
         */
        desktopId: string;
        /**
         * Output Field Text Length Exceeds 24 KB of Truncated Discarded Text Length.
         */
        dropped: number;
        /**
         * Command of the Failure Or Perform the Reason for the Failure of the Code.
         */
        errorCode: string;
        /**
         * Command of the Failure Or Perform the Reason for the Failure of the Details.
         */
        errorInfo: string;
        /**
         * Command of the Failure Or Perform the Reason for the Failure of the Details.
         */
        exitCode: string;
        /**
         * The Script Process until the End of Time.
         */
        finishTime: string;
        /**
         * A Single Cloud Desktop Script Progress Status.
         */
        invocationStatus: string;
        /**
         * Script the Output of the Process.
         */
        output: string;
        /**
         * Command in the Desktop Implementation.
         */
        repeats: number;
        /**
         * The Script Process on the Desktop, in the Start Timing of the Execution.
         */
        startTime: string;
        /**
         * If You Use the invocation Indicates That the Call of the Time.
         */
        stopTime: string;
    }

    export interface GetDesktopsDesktop {
        /**
         * The number of CPUs.
         */
        cpu: number;
        /**
         * The creation time of the Desktop.
         */
        createTime: string;
        /**
         * The desktop id of the Desktop.
         */
        desktopId: string;
        /**
         * The desktop name of the Desktop.
         */
        desktopName: string;
        /**
         * The desktop type of the Desktop.
         */
        desktopType: string;
        /**
         * The directory id of the Desktop.
         */
        directoryId: string;
        /**
         * The desktop end user id of the Desktop.
         */
        endUserIds: string[];
        /**
         * The expired time of the Desktop.
         */
        expiredTime: string;
        /**
         * The ID of the Desktop.
         */
        id: string;
        /**
         * The image id of the Desktop.
         */
        imageId: string;
        /**
         * The memory of the Desktop.
         */
        memory: string;
        /**
         * The network interface id of the Desktop.
         */
        networkInterfaceId: string;
        /**
         * The payment type of the Desktop.
         */
        paymentType: string;
        /**
         * The policy group id of the Desktop.
         */
        policyGroupId: string;
        /**
         * The status of the Desktop. Valid values: `Deleted`, `Expired`, `Pending`, `Running`, `Starting`, `Stopped`, `Stopping`.
         */
        status: string;
        /**
         * The system disk size of the Desktop.
         */
        systemDiskSize: number;
    }

    export interface GetImagesImage {
        /**
         * The creation time of the image.
         */
        createTime: string;
        /**
         * The size of data disk of the image.
         */
        dataDiskSize: number;
        /**
         * The description of the image.
         */
        description: string;
        /**
         * The Gpu Category of the image.
         */
        gpuCategory: boolean;
        /**
         * The ID of the Image.
         */
        id: string;
        /**
         * The image id of the image.
         */
        imageId: string;
        /**
         * The image name.
         */
        imageName: string;
        /**
         * The image type of the image. Valid values: `SYSTEM`, `CUSTOM`.
         */
        imageType: string;
        /**
         * The os type of the image.
         */
        osType: string;
        /**
         * The progress of the image.
         */
        progress: string;
        /**
         * The size of the image.
         */
        size: number;
        /**
         * The status of the image. Valid values: `Creating`, `Available`, `CreateFailed`.
         */
        status: string;
    }

    export interface GetNasFileSystemsSystem {
        /**
         * The capacity of nas file system.
         */
        capacity: string;
        /**
         * The create time of nas file system.
         */
        createTime: string;
        /**
         * The description of nas file system.
         */
        description: string;
        /**
         * The filesystem id of nas file system.
         */
        fileSystemId: string;
        /**
         * The type of nas file system.
         */
        fileSystemType: string;
        /**
         * The ID of the Nas File System.
         */
        id: string;
        /**
         * The size of metered.
         */
        meteredSize: string;
        /**
         * The domain of mount target.
         */
        mountTargetDomain: string;
        /**
         * The status of mount target. Valid values: `Pending`, `Active`, `Inactive`,`Deleting`,`Invalid`.
         */
        mountTargetStatus: string;
        /**
         * The name of nas file system.
         */
        nasFileSystemName: string;
        /**
         * The ID of office site.
         */
        officeSiteId: string;
        /**
         * The name of office site.
         */
        officeSiteName: string;
        /**
         * The status of nas file system. Valid values: `Pending`, `Running`, `Stopped`,`Deleting`, `Deleted`, `Invalid`.
         */
        status: string;
        /**
         * The storage type of nas file system.
         */
        storageType: string;
        /**
         * Whether to support Acl.
         */
        supportAcl: boolean;
        /**
         * The zone id of nas file system.
         */
        zoneId: string;
    }

    export interface GetNetworkPackagesPackage {
        /**
         * The bandwidth of package.
         */
        bandwidth: number;
        /**
         * The creation time of network package.
         */
        createTime: string;
        /**
         * The expired time of package.
         */
        expiredTime: string;
        /**
         * The ID of the Network Package.
         */
        id: string;
        /**
         * The internet charge type  of  package.
         */
        internetChargeType: string;
        /**
         * The ID of network package.
         */
        networkPackageId: string;
        /**
         * The ID of office site.
         */
        officeSiteId: string;
        /**
         * The name of office site.
         */
        officeSiteName: string;
        /**
         * The status of network package. Valid values: `Creating`, `InUse`, `Releasing`,`Released`.
         */
        status: string;
    }

    export interface GetPolicyGroupsGroup {
        /**
         * The rule of authorize access rule.
         */
        authorizeAccessPolicyRules: outputs.eds.GetPolicyGroupsGroupAuthorizeAccessPolicyRule[];
        /**
         * The policy rule.
         */
        authorizeSecurityPolicyRules: outputs.eds.GetPolicyGroupsGroupAuthorizeSecurityPolicyRule[];
        /**
         * The clipboard policy.
         */
        clipboard: string;
        /**
         * The list of domain.
         */
        domainList: string;
        /**
         * The count of eds.
         */
        edsCount: number;
        /**
         * The access of html5.
         */
        htmlAccess: string;
        /**
         * The html5 file transfer.
         */
        htmlFileTransfer: string;
        /**
         * The ID of the Policy Group.
         */
        id: string;
        /**
         * Local drive redirect policy.
         */
        localDrive: string;
        /**
         * The policy group id.
         */
        policyGroupId: string;
        /**
         * The name of policy group.
         */
        policyGroupName: string;
        /**
         * The type of policy group.
         */
        policyGroupType: string;
        /**
         * The status of policy.
         */
        status: string;
        /**
         * The usb redirect policy.
         */
        usbRedirect: string;
        /**
         * The quality of visual.sae_ecdsae_nameecd_po
         */
        visualQuality: string;
        /**
         * The watermark policy.
         */
        watermark: string;
        /**
         * The watermark transparency.
         */
        watermarkTransparency: string;
        /**
         * The type of watemark.
         */
        watermarkType: string;
    }

    export interface GetPolicyGroupsGroupAuthorizeAccessPolicyRule {
        /**
         * The cidrip of security rules.
         */
        cidrIp: string;
        /**
         * The description of security rules.
         */
        description: string;
    }

    export interface GetPolicyGroupsGroupAuthorizeSecurityPolicyRule {
        /**
         * The cidrip of security rules.
         */
        cidrIp: string;
        /**
         * The description of security rules.
         */
        description: string;
        /**
         * The ip protocol of security rules.
         */
        ipProtocol: string;
        /**
         * The policy of security rules.
         */
        policy: string;
        /**
         * The port range of security rules.
         */
        portRange: string;
        /**
         * The priority of security rules.
         */
        priority: string;
        /**
         * The type of security rules.
         */
        type: string;
    }

    export interface GetSimpleOfficeSitesSite {
        /**
         * The Internet Bandwidth Peak. It has been deprecated from version 1.142.0 and can be found in the new datasource alicloud_ecd_network_packages.
         *
         * @deprecated Field 'bandwidth' has been deprecated from provider version 1.142.0.
         */
        bandwidth: number;
        /**
         * Cloud Enterprise Network Instance Id.
         */
        cenId: string;
        /**
         * Workspace Corresponds to the Security Office Network of IPv4 Segment.
         */
        cidrBlock: string;
        /**
         * Workspace Creation Time.
         */
        createTime: string;
        /**
         * Security Group ID.
         */
        customSecurityGroupId: string;
        /**
         * Connect to the Cloud Desktop Allows the Use of the Access Mode of. Possible Values: the Internet: Only Allows the Client to Public Cloud Desktop. Virtual Private Cloud (VPC): Only Allows in the Virtual Private Cloud (VPC) in the Client to Connect to the Cloud Desktop. Any: Not by Way of Limitation. Use Client to Connect to the Cloud Desktop When It Is Possible to Choose the Connection.
         */
        desktopAccessType: string;
        /**
         * The Desktop Vpc Endpoint.
         */
        desktopVpcEndpoint: string;
        /**
         * Enterprise Ad Corresponding DNS Address.
         */
        dnsAddresses: string[];
        /**
         * Easy-to-Use DNS Name.
         */
        dnsUserName: string;
        /**
         * Enterprise of Ad Domain Name.
         */
        domainName: string;
        /**
         * Domain of the User Who Will Administer This Target Application Password.
         */
        domainPassword: string;
        /**
         * The Domain Administrator's Username.
         */
        domainUserName: string;
        /**
         * Whether to Use Cloud Desktop User Empowerment of Local Administrator Permissions.
         */
        enableAdminAccess: boolean;
        /**
         * Enable Cross-Desktop Access.
         */
        enableCrossDesktopAccess: boolean;
        /**
         * Whether the Open Internet Access Function.
         *
         * @deprecated Field 'enable_internet_access' has been deprecated from provider version 1.142.0.
         */
        enableInternetAccess: boolean;
        /**
         * NAS File System ID.
         */
        fileSystemIds: string[];
        /**
         * The ID of the Simple Office Site.
         */
        id: string;
        /**
         * Whether to Enable Multi-Factor Authentication MFA.
         */
        mfaEnabled: boolean;
        /**
         * Internet Access ID.
         */
        networkPackageId: string;
        /**
         * The Workspace ID.
         */
        officeSiteId: string;
        /**
         * Workspace Account System Type. Possible Values: Simple: Convenient Account. AD_CONNECTOR: Enterprise Ad Account.
         */
        officeSiteType: string;
        /**
         * The simple office site name.
         */
        simpleOfficeSiteName: string;
        /**
         * Whether to Enable Single Sign-on (SSO) for User-Based SSO.
         */
        ssoEnabled: boolean;
        /**
         * Whether to Enable Single Sign-on (SSO) for User-Based SSO.
         */
        ssoStatus: boolean;
        /**
         * Workspace State. Possible Values: Registering: Registered in the Registered: Registered.
         */
        status: string;
        /**
         * AD Subdomain of the DNS Address.
         */
        subDnsAddresses: string[];
        /**
         * AD Domain DNS Name.
         */
        subDomainName: string;
        /**
         * AD Trust Password.
         */
        trustPassword: string;
        /**
         * Security Office VPC ID.
         */
        vpcId: string;
        /**
         * The vswitch ids.
         */
        vswitchIds: string[];
    }

    export interface GetUsersUser {
        /**
         * The email of the user email.
         */
        email: string;
        /**
         * The Username. The custom setting is composed of lowercase letters, numbers and underscores, and the length is 3~24 characters.
         */
        endUserId: string;
        /**
         * The ID of the user id.
         */
        id: string;
        /**
         * The phone of the mobile phone number.
         */
        phone: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

}

export namespace ehpc {
    export interface GetJobTemplatesTemplate {
        /**
         * Queue Jobs, Is of the Form: 1-10:2.
         */
        arrayRequest: string;
        /**
         * Job Maximum Run Time.
         */
        clockTime: string;
        /**
         * Job Commands.
         */
        commandLine: string;
        /**
         * A Single Compute Node Using the GPU Number.Possible Values: 1~20000.
         */
        gpu: number;
        /**
         * The ID of the Job Template.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        jobTemplateId: string;
        /**
         * A Job Template Name.
         */
        jobTemplateName: string;
        /**
         * A Single Compute Node Maximum Memory.
         */
        mem: string;
        /**
         * Submit a Task Is Required for Computing the Number of Data Nodes to Be. Possible Values: 1~5000 .
         */
        node: number;
        /**
         * Job Commands the Directory.
         */
        packagePath: string;
        /**
         * The Job Priority.Possible Values: 0~9.
         */
        priority: number;
        /**
         * The Job Queue.
         */
        queue: string;
        /**
         * If the Job Is Support for the Re-Run.
         */
        reRunable: boolean;
        /**
         * The name of the user who performed the job.
         */
        runasUser: string;
        /**
         * Error Output Path.
         */
        stderrRedirectPath: string;
        /**
         * Standard Output Path and.
         */
        stdoutRedirectPath: string;
        /**
         * A Single Compute Node Required Number of Tasks. Possible Values: 1~20000 .
         */
        task: number;
        /**
         * A Single Task and the Number of Required Threads.Possible Values: 1~20000.
         */
        thread: number;
        /**
         * The Job of the Environment Variable.
         */
        variables: string;
    }

}

export namespace eipanycast {
    export interface GetAnycastEipAddressesAddress {
        /**
         * Anycast EIP instance account ID.
         */
        aliUid: number;
        /**
         * Anycast EIP instance name.
         */
        anycastEipAddressName: string;
        /**
         * AnycastEip binding information.
         */
        anycastEipBindInfoLists: outputs.eipanycast.GetAnycastEipAddressesAddressAnycastEipBindInfoList[];
        /**
         * Anycast EIP instance ID.
         */
        anycastId: string;
        /**
         * The peak bandwidth of the Anycast EIP instance, in Mbps.
         */
        bandwidth: number;
        /**
         * Anycast EIP instance account BID.
         */
        bid: string;
        /**
         * The business status of the Anycast EIP instance. -`Normal`: Normal state. -`FinancialLocked`: The status of arrears locked.
         */
        businessStatus: string;
        /**
         * Anycast EIP instance description.
         */
        description: string;
        /**
         * The ID of the Anycast Eip Address.
         */
        id: string;
        /**
         * The billing method of Anycast EIP instance. `PayByBandwidth`: refers to the method of billing based on traffic.
         */
        internetChargeType: string;
        /**
         * Anycast EIP instance IP address.
         */
        ipAddress: string;
        /**
         * The payment model of Anycast EIP instance. "PostPaid": Refers to the post-paid mode.
         */
        paymentType: string;
        /**
         * Anycast EIP instance access area. "international": Refers to areas outside of Mainland China.
         */
        serviceLocation: string;
        /**
         * IP status。- `Associating`, `Unassociating`, `Allocated`, `Associated`, `Modifying`, `Releasing`, `Released`.
         */
        status: string;
    }

    export interface GetAnycastEipAddressesAddressAnycastEipBindInfoList {
        /**
         * The bound cloud resource instance ID.
         */
        bindInstanceId: string;
        /**
         * The region ID of the bound cloud resource instance.
         */
        bindInstanceRegionId: string;
        /**
         * Bind the cloud resource instance type.
         */
        bindInstanceType: string;
        /**
         * Binding time.
         */
        bindTime: string;
    }

}

export namespace elasticsearch {
    export interface GetInstancesInstance {
        createdAt: string;
        dataNodeAmount: number;
        dataNodeDiskSize: number;
        dataNodeDiskType: string;
        dataNodeSpec: string;
        description: string;
        id: string;
        instanceChargeType: string;
        status: string;
        tags: {[key: string]: any};
        updatedAt: string;
        version: string;
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace emr {
    export interface ClusterBootstrapAction {
        /**
         * bootstrap action args, e.g. "--a=b".
         */
        arg?: string;
        /**
         * bootstrap action name.
         */
        name?: string;
        /**
         * bootstrap action path, e.g. "oss://bucket/path".
         */
        path?: string;
    }

    export interface ClusterHostGroup {
        /**
         * Auto renew for prepaid, true of false. Default is false.
         */
        autoRenew?: boolean;
        /**
         * Charge Type for this group of hosts: PostPaid or PrePaid. If this is not specified, charge type will follow global chargeType value.
         */
        chargeType?: string;
        /**
         * Data disk capacity.
         */
        diskCapacity?: string;
        /**
         * Data disk count.
         */
        diskCount?: string;
        /**
         * Data disk type. Supported value: cloud,cloud_efficiency,cloud_ssd,local_disk,cloud_essd.
         */
        diskType?: string;
        gpuDriver?: string;
        /**
         * host group name.
         */
        hostGroupName?: string;
        /**
         * host group type, supported value: MASTER, CORE or TASK, supported 'GATEWAY' available in 1.61.0+.
         */
        hostGroupType?: string;
        /**
         * Instance list for cluster scale down. This value follows the json format, e.g. ["instanceId1","instanceId2"]. escape character for " is \".
         */
        instanceList?: string;
        /**
         * Host Ecs instance type.
         */
        instanceType?: string;
        /**
         * Host number in this group.
         */
        nodeCount?: string;
        /**
         * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36.
         */
        period?: number;
        /**
         * System disk capacity.
         */
        sysDiskCapacity?: string;
        /**
         * System disk type. Supported value: cloud,cloud_efficiency,cloud_ssd,cloud_essd.
         */
        sysDiskType?: string;
    }

    export interface GetClustersCluster {
        /**
         * Cluster connection information.
         */
        accessInfos: outputs.emr.GetClustersClusterAccessInfo[];
        /**
         * Whether flexible expansion is allowed.
         */
        autoScalingAllowed: boolean;
        /**
         * Whether to allow expansion by load.
         */
        autoScalingByLoadAllowed: boolean;
        /**
         * Whether to enable elastic expansion.
         */
        autoScalingEnable: boolean;
        /**
         * Whether to allow the use of elastic scaling bidding instances.
         */
        autoScalingSpotWithLimitAllowed: boolean;
        /**
         * List of boot actions.
         */
        bootstrapActionLists: outputs.emr.GetClustersClusterBootstrapActionList[];
        /**
         * The result of the boot operation.
         */
        bootstrapFailed: boolean;
        /**
         * The ID of the associated cluster.
         */
        clusterId: string;
        /**
         * The name of the associated cluster.
         */
        clusterName: string;
        /**
         * Cluster tag, no need to pay attention.
         */
        createResource: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * How to create a cluster.
         */
        createType: string;
        /**
         * The hosting type of the cluster.
         */
        depositType: string;
        /**
         * High security cluster.
         */
        easEnable: boolean;
        /**
         * Timeout time.
         */
        expiredTime: string;
        /**
         * Additional information for Stack.
         */
        extraInfo: string;
        hasUncompletedOrder: boolean;
        /**
         * High availability cluster.
         */
        highAvailabilityEnable: boolean;
        /**
         * List of cluster machine groups.
         */
        hostGroupLists: outputs.emr.GetClustersClusterHostGroupList[];
        /**
         * Machine pool information.
         */
        hostPoolInfos: outputs.emr.GetClustersClusterHostPoolInfo[];
        id: string;
        /**
         * The ID of the image used to create the cluster.
         */
        imageId: string;
        /**
         * Whether to use Hive local Metabase.
         */
        localMetaDb: boolean;
        /**
         * The host type of the cluster. The default is ECS.
         */
        machineType: string;
        /**
         * Metadata type:
         */
        metaStoreType: string;
        /**
         * Cluster network type.
         */
        netType: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The package year and month time of the machine group. The Valid Values : `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `12`, `24`, `36`.
         */
        period: number;
        /**
         * The information of the primary cluster associated with the Gateway.
         */
        relateClusterInfos: outputs.emr.GetClustersClusterRelateClusterInfo[];
        /**
         * Whether to allow disk expansion:
         */
        resizeDiskEnable: boolean;
        /**
         * The time (in seconds) that has been running.
         */
        runningTime: number;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The name of the security group.
         */
        securityGroupName: string;
        /**
         * Service list.
         */
        softwareInfos: outputs.emr.GetClustersClusterSoftwareInfo[];
        /**
         * Cluster startup time.
         */
        startTime: string;
        /**
         * The cluster status.
         */
        status: string;
        /**
         * Cluster stop time.
         */
        stopTime: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Disk type.
         */
        type: string;
        /**
         * The EMR permission name used.
         */
        userDefinedEmrEcsRole: string;
        /**
         * The user ID.
         */
        userId: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetClustersClusterAccessInfo {
        /**
         * Link address information list of ZooKeeper.
         */
        zkLinks: outputs.emr.GetClustersClusterAccessInfoZkLink[];
    }

    export interface GetClustersClusterAccessInfoZkLink {
        /**
         * The access link address of ZooKeeper.
         */
        link: string;
        /**
         * The port of ZooKeeper.
         */
        port: string;
    }

    export interface GetClustersClusterBootstrapActionList {
        /**
         * Parameters of the boot operation.
         */
        arg: string;
        /**
         * The internal name of the service.
         */
        name: string;
        /**
         * Boot operation script path.
         */
        path: string;
    }

    export interface GetClustersClusterHostGroupList {
        /**
         * Bandwidth.
         */
        bandWidth: string;
        /**
         * Payment Type.
         */
        chargeType: string;
        /**
         * The number of CPU cores.
         */
        cpuCore: number;
        /**
         * Data disk capacity.
         */
        diskCapacity: number;
        /**
         * The number of data disks.
         */
        diskCount: number;
        /**
         * System disk type:
         */
        diskType: string;
        /**
         * The current operation type of the machine Group:
         */
        hostGroupChangeType: string;
        /**
         * The ID of the machine group.
         */
        hostGroupId: string;
        /**
         * The name of the machine group.
         */
        hostGroupName: string;
        /**
         * Role of host in cluster:
         */
        hostGroupType: string;
        /**
         * Machine Group instance.
         */
        instanceType: string;
        /**
         * Memory size.
         */
        memoryCapacity: number;
        /**
         * The number of machine group nodes.
         */
        nodeCount: number;
        /**
         * Machine node.
         */
        nodes: outputs.emr.GetClustersClusterHostGroupListNode[];
        /**
         * The package year and month time of the machine group. The Valid Values : `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `12`, `24`, `36`.
         */
        period: string;
    }

    export interface GetClustersClusterHostGroupListNode {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Disk information.
         */
        diskInfos: outputs.emr.GetClustersClusterHostGroupListNodeDiskInfo[];
        /**
         * The timeout of the EMR.
         */
        emrExpiredTime: string;
        /**
         * Timeout time.
         */
        expiredTime: string;
        /**
         * The Intranet IP of the EMR.
         */
        innerIp: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * Public IP address.
         */
        pubIp: string;
        /**
         * The cluster status.
         */
        status: string;
        /**
         * Whether IPV6 is supported.
         */
        supportIpv6: boolean;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetClustersClusterHostGroupListNodeDiskInfo {
        /**
         * The disk name.
         */
        device: string;
        /**
         * The ID of the disk.
         */
        diskId: string;
        /**
         * The disk name.
         */
        diskName: string;
        /**
         * Disk capacity.
         */
        size: number;
        /**
         * Disk type.
         */
        type: string;
    }

    export interface GetClustersClusterHostPoolInfo {
        /**
         * Machine pool ID.
         */
        hpBizId: string;
        /**
         * The name of the machine pool.
         */
        hpName: string;
    }

    export interface GetClustersClusterRelateClusterInfo {
        /**
         * The ID of the associated cluster.
         */
        clusterId: string;
        /**
         * The name of the associated cluster.
         */
        clusterName: string;
        /**
         * Cluster type:
         */
        clusterType: string;
        /**
         * The cluster status.
         */
        status: string;
    }

    export interface GetClustersClusterSoftwareInfo {
        /**
         * Cluster type:
         */
        clusterType: string;
        /**
         * E-MapReduce version number.
         */
        emrVer: string;
        /**
         * Service list.
         */
        softwares: outputs.emr.GetClustersClusterSoftwareInfoSoftware[];
    }

    export interface GetClustersClusterSoftwareInfoSoftware {
        /**
         * The name of the service.
         */
        displayName: string;
        /**
         * The internal name of the service.
         */
        name: string;
        /**
         * Whether it shows.
         */
        onlyDisplay: boolean;
        /**
         * Startup type.
         */
        startTpe: number;
        /**
         * Service version.
         */
        version: string;
    }

    export interface GetDiskTypesType {
        /**
         * The maximum value of the data disk to supported the specific instance type
         */
        max: number;
        /**
         * The mininum value of the data disk to supported the specific instance type
         */
        min: number;
        /**
         * The value of the data disk or system disk
         */
        value: string;
    }

    export interface GetInstanceTypesType {
        /**
         * The ID of the instance type.
         */
        id: string;
        /**
         * Local capacity of the applied ecs instance for emr cluster. Unit: GB.
         */
        localStorageCapacity: number;
        /**
         * The supported resources of specific zoneId.
         */
        zoneId: string;
    }

    export interface GetMainVersionsMainVersion {
        /**
         * A list of cluster types the emr cluster supported. Possible values: `HADOOP`, `ZOOKEEPER`, `KAFKA`, `DRUID`.
         */
        clusterTypes: string[];
        /**
         * The version of the emr cluster instance. Possible values: `EMR-4.0.0`, `EMR-3.23.0`, `EMR-3.22.0`.
         */
        emrVersion: string;
        /**
         * The image id of the emr cluster instance.
         */
        imageId: string;
    }

}

export namespace ens {
    export interface GetKeyPairsPair {
        /**
         * The creation time of the key pair. The date format is in accordance with ISO8601 notation and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.
         */
        createTime: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * Fingerprint of the key pair.
         */
        keyPairFingerPrint: string;
        /**
         * The name of the key pair.
         */
        keyPairName: string;
        /**
         * The version number.
         */
        version: string;
    }

}

export namespace ess {
    export interface GetAlarmsAlarm {
        /**
         * The list of actions to execute when this alarm transition into an ALARM state. Each action is specified as ess scaling rule ari.
         */
        alarmActions: string[];
        /**
         * Defines the application group id defined by CMS which is assigned when you upload custom metric to CMS, only available for custom metirc.
         */
        cloudMonitorGroupId: number;
        /**
         * The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand.
         */
        comparisonOperator: string;
        /**
         * The description for the alarm.
         */
        description: string;
        /**
         * The dimension map for the alarm's associated metric.
         */
        dimensions: {[key: string]: any};
        /**
         * Whether to enable specific ess alarm.
         */
        enable: boolean;
        /**
         * The number of times that needs to satisfies comparison condition before transition into ALARM state.
         */
        evaluationCount: number;
        /**
         * The id of alarm.
         */
        id: string;
        /**
         * The name for the alarm's associated metric. See Block_metricNames_and_dimensions below for details.
         */
        metricName: string;
        /**
         * The type for the alarm's associated metric. Supported value: system, custom. "system" means the metric data is collected by Aliyun Cloud Monitor Service(CMS), "custom" means the metric data is upload to CMS by users. Defaults to system.
         */
        metricType: string;
        /**
         * The name for ess alarm.
         */
        name: string;
        /**
         * The period in seconds over which the specified statistic is applied.
         */
        period: number;
        /**
         * Scaling group id the alarms belong to.
         */
        scalingGroupId: string;
        /**
         * The state of alarm task.
         */
        state: string;
        /**
         * The statistic to apply to the alarm's associated metric.
         */
        statistics: string;
        /**
         * The value against which the specified statistics is compared.
         */
        threshold: string;
    }

    export interface GetLifecycleHooksHook {
        /**
         * Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses.
         */
        defaultResult: string;
        /**
         * Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the defaultResult parameter.
         */
        heartbeatTimeout: number;
        /**
         * ID of the lifecycle hook.
         */
        id: string;
        /**
         * Type of Scaling activity attached to lifecycle hook.
         */
        lifecycleTransition: string;
        /**
         * Name of the lifecycle hook.
         */
        name: string;
        /**
         * The Arn of notification target.
         */
        notificationArn: string;
        /**
         * Additional information that you want to include when Auto Scaling sends a message to the notification target.
         */
        notificationMetadata: string;
        /**
         * Scaling group id the lifecycle hooks belong to.
         */
        scalingGroupId: string;
    }

    export interface GetNotificationsNotification {
        /**
         * ID of the notification.
         */
        id: string;
        /**
         * The Alibaba Cloud Resource Name (ARN) for the notification object.
         */
        notificationArn: string;
        /**
         * The notification types of Auto Scaling events and resource changes.
         */
        notificationTypes: string[];
        /**
         * Scaling group id the notifications belong to.
         */
        scalingGroupId: string;
    }

    export interface GetScalingConfigurationsConfiguration {
        /**
         * Creation time of the scaling configuration.
         */
        creationTime: string;
        /**
         * Performance mode of the t5 burstable instance.
         */
        creditSpecification: string;
        /**
         * Data disks of the scaling configuration.
         */
        dataDisks: outputs.ess.GetScalingConfigurationsConfigurationDataDisk[];
        /**
         * (Optional,Available in 1.143.0+) Hostname of an ECS instance.
         */
        hostName: string;
        /**
         * ID of the scaling rule.
         */
        id: string;
        /**
         * Image ID of the scaling configuration.
         */
        imageId: string;
        /**
         * (Optional,Available in 1.143.0+) InstanceName of an ECS instance.
         */
        instanceName: string;
        /**
         * Resource type of an ECS instance.
         */
        instanceType: string;
        /**
         * Internet charge type of the scaling configuration.
         */
        internetChargeType: string;
        /**
         * Internet max bandwidth in of the scaling configuration.
         */
        internetMaxBandwidthIn: number;
        /**
         * Internet max bandwidth of the scaling configuration.
         */
        internetMaxBandwidthOut: number;
        /**
         * Lifecycle state of the scaling configuration.
         */
        lifecycleState: string;
        /**
         * Name of the scaling configuration.
         */
        name: string;
        /**
         * Scaling group id the scaling configurations belong to.
         */
        scalingGroupId: string;
        /**
         * Security group ID of the scaling configuration.
         */
        securityGroupId: string;
        /**
         * (Optional, Available in 1.151.0+) The maximum price hourly for instance types.
         */
        spotPriceLimits: outputs.ess.GetScalingConfigurationsConfigurationSpotPriceLimit[];
        /**
         * (Optional, Available in 1.151.0+) The spot strategy for a Pay-As-You-Go instance.
         */
        spotStrategy: string;
        /**
         * System disk category of the scaling configuration.
         */
        systemDiskCategory: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        systemDiskPerformanceLevel: string;
        /**
         * System disk size of the scaling configuration.
         */
        systemDiskSize: number;
    }

    export interface GetScalingConfigurationsConfigurationDataDisk {
        /**
         * Category of data disk.
         */
        category?: string;
        /**
         * Delete_with_instance attribute of data disk.
         */
        deleteWithInstance?: boolean;
        /**
         * Device attribute of data disk.
         */
        device?: string;
        /**
         * The performance level of the ESSD used as data disk.
         */
        performanceLevel?: string;
        /**
         * Size of data disk.
         */
        size?: number;
        /**
         * Size of data disk.
         */
        snapshotId?: string;
    }

    export interface GetScalingConfigurationsConfigurationSpotPriceLimit {
        /**
         * Resource type of an ECS instance.
         */
        instanceType?: string;
        /**
         * Price limit hourly of instance type.
         */
        priceLimit?: number;
    }

    export interface GetScalingGroupsGroup {
        /**
         * Number of active instances in scaling group.
         */
        activeCapacity: number;
        activeScalingConfiguration: string;
        /**
         * Default cooldown time of scaling group.
         */
        cooldownTime: number;
        /**
         * Creation time of scaling group.
         */
        creationTime: string;
        /**
         * Db instances id which the ECS instance attached to.
         */
        dbInstanceIds: string[];
        /**
         * ID of the scaling group.
         */
        id: string;
        /**
         * Active launch template ID for scaling group.
         */
        launchTemplateId: string;
        /**
         * Version of active launch template.
         */
        launchTemplateVersion: string;
        /**
         * Lifecycle state of scaling group.
         */
        lifecycleState: string;
        /**
         * Slb instances id which the ECS instance attached to.
         */
        loadBalancerIds: string[];
        /**
         * The maximum number of ECS instances.
         */
        maxSize: number;
        /**
         * The minimum number of ECS instances.
         */
        minSize: number;
        /**
         * Name of the scaling group.
         * * `activeScalingConfiguration` -Active scaling configuration for scaling group.
         */
        name: string;
        /**
         * Number of pending instances in scaling group.
         */
        pendingCapacity: number;
        /**
         * Region ID the scaling group belongs to.
         */
        regionId: string;
        /**
         * Removal policy used to select the ECS instance to remove from the scaling group.
         */
        removalPolicies: string[];
        /**
         * Number of removing instances in scaling group.
         */
        removingCapacity: number;
        /**
         * Number of instances in scaling group.
         */
        totalCapacity: number;
        /**
         * Vswitches id in which the ECS instance launched.
         */
        vswitchIds: string[];
    }

    export interface GetScalingRulesRule {
        /**
         * Adjustment type of the scaling rule.
         */
        adjustmentType: string;
        /**
         * Adjustment value of the scaling rule.
         */
        adjustmentValue: number;
        /**
         * Cooldown time of the scaling rule.
         */
        cooldown: number;
        /**
         * ID of the scaling rule.
         */
        id: string;
        /**
         * Min adjustment magnitude of scaling rule.
         */
        minAdjustmentMagnitude: number;
        /**
         * Name of the scaling rule.
         */
        name: string;
        /**
         * Scaling group id the scaling rules belong to.
         */
        scalingGroupId: string;
        /**
         * Ari of scaling rule.
         */
        scalingRuleAri: string;
        /**
         * Type of scaling rule.
         */
        type: string;
    }

    export interface GetScheduledTasksTask {
        /**
         * Description of the scheduled task.
         */
        description: string;
        /**
         * ID of the scheduled task id.
         */
        id: string;
        /**
         * The time period during which a failed scheduled task is retried.
         */
        launchExpirationTime: number;
        /**
         * The time at which the scheduled task is triggered.
         */
        launchTime: string;
        maxValue: number;
        minValue: number;
        /**
         * Name of the scheduled task name.
         */
        name: string;
        /**
         * Specifies the end time after which the scheduled task is no longer repeated.
         */
        recurrenceEndTime: string;
        /**
         * Specifies the recurrence type of the scheduled task.
         */
        recurrenceType: string;
        /**
         * Specifies how often a scheduled task recurs.
         */
        recurrenceValue: string;
        /**
         * The operation to be performed when a scheduled task is triggered.
         */
        scheduledAction: string;
        taskEnabled: boolean;
    }

    export interface ScalingConfigurationDataDisk {
        autoSnapshotPolicyId?: string;
        category?: string;
        deleteWithInstance?: boolean;
        description?: string;
        /**
         * @deprecated Attribute device has been deprecated on disk attachment resource. Suggest to remove it from your template.
         */
        device?: string;
        encrypted?: boolean;
        kmsKeyId?: string;
        name?: string;
        performanceLevel?: string;
        size?: number;
        snapshotId?: string;
    }

    export interface ScalingConfigurationSpotPriceLimit {
        /**
         * Resource type of an ECS instance.
         */
        instanceType?: string;
        priceLimit?: number;
    }

    export interface ScalingGroupVServerGroupsVserverGroup {
        loadbalancerId: string;
        vserverAttributes: outputs.ess.ScalingGroupVServerGroupsVserverGroupVserverAttribute[];
    }

    export interface ScalingGroupVServerGroupsVserverGroupVserverAttribute {
        port: number;
        vserverGroupId: string;
        weight: number;
    }

    export interface ScalingRuleStepAdjustment {
        metricIntervalLowerBound?: string;
        metricIntervalUpperBound?: string;
        scalingAdjustment?: number;
    }
}

export namespace eventbridge {
    export interface GetEventBusesBus {
        /**
         * The time of this bus was created.
         */
        createTime: string;
        /**
         * The description of event bus.
         */
        description: string;
        /**
         * The name of event bus.
         */
        eventBusName: string;
        /**
         * The ID of the Event Bus. Its value is same as Queue Name.
         */
        id: string;
    }

    export interface GetEventSourcesSource {
        /**
         * The detail describe of event source.
         */
        description: string;
        /**
         * The code name of event source.
         */
        eventSourceName: string;
        /**
         * The config of external data source.
         */
        externalSourceConfig: {[key: string]: any};
        /**
         * The type of external data source.
         */
        externalSourceType: string;
        /**
         * The ID of the Event Source.
         */
        id: string;
        /**
         * Whether to connect to an external data source.
         */
        linkedExternalSource: boolean;
        type: string;
    }

    export interface GetRulesRule {
        /**
         * The description of rule.
         */
        description: string;
        /**
         * The name of event bus.
         */
        eventBusName: string;
        /**
         * The pattern to match interested events.
         */
        filterPattern: string;
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * The name of rule.
         */
        ruleName: string;
        /**
         * Rule status, either Enable or Disable.
         */
        status: string;
        /**
         * The target for rule.
         */
        targets: outputs.eventbridge.GetRulesRuleTarget[];
    }

    export interface GetRulesRuleTarget {
        /**
         * The endpoint.
         */
        endpoint: string;
        /**
         * The id of target.
         */
        targetId: string;
        /**
         * The type of target.
         */
        type: string;
    }

    export interface RuleTarget {
        /**
         * The endpoint of target.
         */
        endpoint: string;
        /**
         * A list of param.
         */
        paramLists: outputs.eventbridge.RuleTargetParamList[];
        /**
         * The ID of target.
         */
        targetId: string;
        /**
         * The type of target. Valid values: `acs.fc.function`, `acs.mns.topic`, `acs.mns.queue`,`http`,`acs.sms`,`acs.mail`,`acs.dingtalk`,`https`, `acs.eventbridge`,`acs.rabbitmq` and `acs.rocketmq`.
         */
        type: string;
    }

    export interface RuleTargetParamList {
        /**
         * The format of param.  Valid values: `ORIGINAL`, `TEMPLATE`, `JSONPATH`, `CONSTANT`.
         */
        form: string;
        /**
         * The resource key of param.  For more information, see [Event target parameters](https://help.aliyun.com/document_detail/185887.htm)
         */
        resourceKey: string;
        /**
         * The template of param.
         */
        template?: string;
        /**
         * The value of param.
         */
        value?: string;
    }

}

export namespace expressconnect {
    export interface GetAccessPointsPoint {
        /**
         * Query to the Access Point Feature Model.
         */
        accessPointFeatureModels: outputs.expressconnect.GetAccessPointsPointAccessPointFeatureModel[];
        /**
         * The Access Point ID.
         */
        accessPointId: string;
        /**
         * Access Point Name.
         */
        accessPointName: string;
        /**
         * The Access Point Is Located an ID.
         */
        attachedRegionNo: string;
        /**
         * The Access Point Description.
         */
        description: string;
        /**
         * The Access Point Belongs to the Operator.
         */
        hostOperator: string;
        /**
         * The ID of the Access Point.
         */
        id: string;
        /**
         * The Location of the Access Point.
         */
        location: string;
        /**
         * The Physical Connection to Which the Access Point State.
         */
        status: string;
        /**
         * The Physical Connection to Which the Network Type.
         */
        type: string;
    }

    export interface GetAccessPointsPointAccessPointFeatureModel {
        /**
         * The Access Point Properties.
         */
        featureKey: string;
        /**
         * The Access Point Characteristic Value.
         */
        featureValue: string;
    }

    export interface GetPhysicalConnectionsConnection {
        /**
         * The Physical Leased Line Access Point ID.
         */
        accessPointId: string;
        /**
         * To Connect a Device Physical Location.
         */
        adLocation: string;
        /**
         * On the Bandwidth of the ECC Service and Physical Connection.
         */
        bandwidth: string;
        /**
         * The Physical Connection to Which the Payment Status: Normal, financiallocked, securitylocked.
         */
        businessStatus: string;
        /**
         * Operators for Physical Connection Circuit Provided Coding.
         */
        circuitCode: string;
        /**
         * The Representative of the Creation Time Resources Attribute Field.
         */
        createTime: string;
        /**
         * The Physical Connection to Which the Description.
         */
        description: string;
        /**
         * The Physical Connection to Which the Activation Time.
         */
        enabledTime: string;
        /**
         * The Expiration Time.
         */
        endTime: string;
        /**
         * HasReservationData.
         */
        hasReservationData: string;
        /**
         * The ID of the Physical Connection.
         */
        id: string;
        /**
         * Provides Access to the Physical Line Operator Value CT: China Telecom, CU: China Unicom, CM: china Mobile, CO: Other Chinese, Equinix:Equinix, Other: Other Overseas.
         */
        lineOperator: string;
        /**
         * Loa State.
         */
        loaStatus: string;
        /**
         * on Behalf of the Pay-as-You-Type of Resource Attribute Field.
         */
        paymentType: string;
        /**
         * and an on-Premises Data Center Location.
         */
        peerLocation: string;
        /**
         * on Behalf of the Resource Level Id of the Resources Property Fields.
         */
        physicalConnectionId: string;
        /**
         * on Behalf of the Resource Name of the Resources-Attribute Field.
         */
        physicalConnectionName: string;
        /**
         * To Connect a Device Port: The Port Number of.
         */
        portNumber: string;
        /**
         * The Physical Leased Line Access Port Type Value 100Base-T: Fast Electrical Ports, 1000Base-T (the Default): gigabit Electrical Ports, 1000Base-LX: Gigabit Singlemode Optical Ports (10Km), 10GBase-T: Gigabit Electrical Port, 10GBase-LR: Gigabit Singlemode Optical Ports (10Km).
         */
        portType: string;
        /**
         * Redundant Physical Connection to Which the ID.
         */
        redundantPhysicalConnectionId: string;
        /**
         * The Renewal of the Entry into Force of the Time.
         */
        reservationActiveTime: string;
        /**
         * Renewal Type.
         */
        reservationInternetChargeType: string;
        /**
         * Renewal Order Type.
         */
        reservationOrderType: string;
        /**
         * The Physical Connection to Which the Specifications.
         */
        spec: string;
        /**
         * Resources on Behalf of a State of the Resource Attribute Field.
         */
        status: string;
        /**
         * Physical Private Line of Type. Default Value: VPC.
         */
        type: string;
    }

    export interface GetVirtualBorderRoutersFilter {
        /**
         * The key of the field to filter by, as defined by
         * [Alibaba Cloud API](https://www.alibabacloud.com/help/en/doc-detail/124791.htm).
         */
        key?: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values?: string[];
    }

    export interface GetVirtualBorderRoutersRouter {
        /**
         * The physical leased line access point ID.
         */
        accessPointId: string;
        /**
         * The first activation time of VBR.
         */
        activationTime: string;
        /**
         * Operators for physical connection circuit provided coding.
         */
        circuitCode: string;
        /**
         * Box Instance Id.
         */
        cloudBoxInstanceId: string;
        /**
         * The representative of the creation time resources attribute field.
         */
        createTime: string;
        /**
         * The description of VBR. Length is from 2 to 256 characters, must start with a letter or the Chinese at the beginning, but not at the http:// Or https:// at the beginning.
         */
        description: string;
        /**
         * Detection time multiplier that recipient allows the sender to send a message of the maximum allowable connections for the number of packets, used to detect whether the link normal. Value: 3~10.
         */
        detectMultiplier: number;
        /**
         * High Speed Migration Service Instance Id.
         */
        eccId: string;
        /**
         * Whether to Enable IPv6.
         */
        enableIpv6: boolean;
        /**
         * The ID of the Virtual Border Router.
         */
        id: string;
        /**
         * Alibaba Cloud-Connected IPv4 address.
         */
        localGatewayIp: string;
        /**
         * Alibaba Cloud-Connected IPv6 Address.
         */
        localIpv6GatewayIp: string;
        /**
         * Configure BFD packet reception interval of values include: 200~1000, unit: ms.
         */
        minRxInterval: number;
        /**
         * Configure BFD packet transmission interval maximum value: 200~1000, unit: ms.
         */
        minTxInterval: number;
        /**
         * The Billing of the Extended Time.
         */
        paymentVbrExpireTime: string;
        /**
         * The Client-Side Interconnection IPv4 Address.
         */
        peerGatewayIp: string;
        /**
         * The Client-Side Interconnection IPv6 Address.
         */
        peerIpv6GatewayIp: string;
        /**
         * Alibaba Cloud-Connected IPv6 with Client-Side Interconnection IPv6 of Subnet Mask.
         */
        peeringIpv6SubnetMask: string;
        /**
         * Alibaba Cloud-Connected IPv4 and Client-Side Interconnection IPv4 of Subnet Mask.
         */
        peeringSubnetMask: string;
        /**
         * Physical Private Line Service Status Value Normal: Normal, financiallocked: If You Lock.
         */
        physicalConnectionBusinessStatus: string;
        /**
         * The ID of the Physical Connection to Which the ID.
         */
        physicalConnectionId: string;
        /**
         * Physical Private Line Where the Account ID.
         */
        physicalConnectionOwnerUid: string;
        /**
         * Physical Private Line State.
         */
        physicalConnectionStatus: string;
        /**
         * The Last from a Terminated State to the Active State of the Time.
         */
        recoveryTime: string;
        /**
         * Route Table ID.
         */
        routeTableId: string;
        /**
         * The VBR state.
         */
        status: string;
        /**
         * The Most Recent Was Aborted by the Time.
         */
        terminationTime: string;
        /**
         * VBR Type.
         */
        type: string;
        /**
         * The VBR ID.
         */
        virtualBorderRouterId: string;
        /**
         * The name of VBR. Length is from 2 to 128 characters, must start with a letter or the Chinese at the beginning can contain numbers, the underscore character (_) and dash (-). But do not start with http:// or https:// at the beginning.
         */
        virtualBorderRouterName: string;
        /**
         * The VLAN ID of the VBR. Value range: 0~2999.
         */
        vlanId: number;
        /**
         * The ID of the Router Interface.
         */
        vlanInterfaceId: string;
    }

}

export namespace fc {
    export interface AliasRoutingConfig {
        /**
         * A map that defines the proportion of events that should be sent to different versions of a Function Compute service.
         */
        additionalVersionWeights?: {[key: string]: number};
    }

    export interface CustomDomainCertConfig {
        /**
         * The name of the certificate, used to distinguish different certificates.
         */
        certName: string;
        /**
         * Certificate data of the HTTPS certificates, follow the 'pem' format.
         */
        certificate: string;
        /**
         * Private key of the HTTPS certificates, follow the 'pem' format.
         */
        privateKey: string;
    }

    export interface CustomDomainRouteConfig {
        /**
         * The name of the Function Compute function that requests are routed to.
         */
        functionName: string;
        /**
         * The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
         */
        methods?: string[];
        /**
         * The path that requests are routed from.
         */
        path: string;
        /**
         * The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service. For detail information about version and alias, please refer to the [developer guide](https://www.alibabacloud.com/help/doc-detail/96464.htm).
         */
        qualifier?: string;
        serviceName: string;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfig {
        /**
         * Configuration block with destination configuration for failed asynchronous invocations. See below for details.
         */
        onFailure?: outputs.fc.FunctionAsyncInvokeConfigDestinationConfigOnFailure;
        /**
         * Configuration block with destination configuration for successful asynchronous invocations. See below for details.
         */
        onSuccess?: outputs.fc.FunctionAsyncInvokeConfigDestinationConfigOnSuccess;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfigOnFailure {
        /**
         * Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
         */
        destination: string;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfigOnSuccess {
        /**
         * Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
         */
        destination: string;
    }

    export interface FunctionCustomContainerConfig {
        /**
         * The args field specifies the arguments passed to the command.
         */
        args?: string;
        /**
         * The entry point of the container, which specifies the actual command run by the container.
         */
        command?: string;
        /**
         * The container image address.
         */
        image: string;
    }

    export interface GetCustomDomainsDomain {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The API version of the Function Compute service.
         */
        apiVersion: string;
        /**
         * The configuration of HTTPS certificate.
         */
        certConfig: outputs.fc.GetCustomDomainsDomainCertConfig;
        /**
         * The created time of the custom domain.
         */
        createdTime: string;
        /**
         * The custom domain name.
         */
        domainName: string;
        /**
         * The custom domain id, same as domain name.
         */
        id: string;
        /**
         * The last modified time of the custom domain.
         */
        lastModifiedTime: string;
        /**
         * The custom domain protocol.
         */
        protocol: string;
        /**
         * The configuration of domain route, mapping the path and Function Compute function.
         */
        routeConfigs: outputs.fc.GetCustomDomainsDomainRouteConfig[];
    }

    export interface GetCustomDomainsDomainCertConfig {
        /**
         * The name of the certificate.
         */
        certName: string;
        /**
         * Certificate data of the HTTPS certificates, follow the 'pem'.
         */
        certificate: string;
    }

    export interface GetCustomDomainsDomainRouteConfig {
        /**
         * The name of the Function Compute function that requests are routed to.
         */
        functionName: string;
        /**
         * The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
         */
        methods: string[];
        /**
         * The path that requests are routed from.
         */
        path: string;
        /**
         * The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service.
         */
        qualifier: string;
        /**
         * The name of the Function Compute service that requests are routed to.
         */
        serviceName: string;
    }

    export interface GetFunctionsFunction {
        /**
         * The port that the function listen to, only valid for [custom runtime](https://www.alibabacloud.com/help/doc-detail/132044.htm) and [custom container runtime](https://www.alibabacloud.com/help/doc-detail/179368.htm).
         */
        caPort: number;
        /**
         * Checksum (crc64) of the function code.
         */
        codeChecksum: string;
        /**
         * Function code size in bytes.
         */
        codeSize: number;
        /**
         * Function creation time.
         */
        creationTime: string;
        /**
         * The configuration for custom container runtime. It contains following attributes:
         */
        customContainerConfig?: outputs.fc.GetFunctionsFunctionCustomContainerConfig;
        /**
         * Function description.
         */
        description: string;
        /**
         * A map that defines environment variables for the function.
         */
        environmentVariables: {[key: string]: any};
        /**
         * Function [entry point](https://www.alibabacloud.com/help/doc-detail/62213.htm) in the code.
         */
        handler: string;
        /**
         * Function ID.
         */
        id: string;
        /**
         * The maximum length of time, in seconds, that the function's initialization should be run for.
         */
        initializationTimeout: number;
        /**
         * The entry point of the function's [initialization](https://www.alibabacloud.com/help/doc-detail/157704.htm).
         */
        initializer: string;
        /**
         * The maximum number of requests can be executed concurrently within the single function instance.
         */
        instanceConcurrency: number;
        /**
         * The instance type of the function.
         */
        instanceType: string;
        /**
         * Function last modification time.
         */
        lastModificationTime: string;
        /**
         * Amount of memory in MB the function can use at runtime.
         */
        memorySize: number;
        /**
         * Function name.
         */
        name: string;
        /**
         * Function runtime. The list of possible values is [available here](https://www.alibabacloud.com/help/doc-detail/52077.htm).
         */
        runtime: string;
        /**
         * Maximum amount of time the function can run in seconds.
         */
        timeout: number;
    }

    export interface GetFunctionsFunctionCustomContainerConfig {
        /**
         * The args field specifies the arguments passed to the command.
         */
        args: string;
        /**
         * The entry point of the container, which specifies the actual command run by the container.
         */
        command: string;
        /**
         * The container image address.
         */
        image: string;
    }

    export interface GetServicesService {
        /**
         * FC service creation time.
         */
        creationTime: string;
        /**
         * FC service description.
         */
        description: string;
        /**
         * FC service ID.
         */
        id: string;
        /**
         * Indicate whether the service can access to internet or not.
         */
        internetAccess: boolean;
        /**
         * FC service last modification time.
         */
        lastModificationTime: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfig: outputs.fc.GetServicesServiceLogConfig;
        /**
         * FC service name.
         */
        name: string;
        /**
         * A list of one element about the nas configuration.
         */
        nasConfig: outputs.fc.GetServicesServiceNasConfig;
        /**
         * FC service role ARN.
         */
        role: string;
        /**
         * A list of one element containing information about accessible VPC resources. It contains the following attributes:
         */
        vpcConfig: outputs.fc.GetServicesServiceVpcConfig;
    }

    export interface GetServicesServiceLogConfig {
        /**
         * Log Service store name.
         */
        logstore: string;
        /**
         * Log Service project name.
         */
        project: string;
    }

    export interface GetServicesServiceNasConfig {
        /**
         * The group id of the NAS file system.
         */
        groupId: number;
        /**
         * The mount points configuration, including following attributes:
         */
        mountPoints: outputs.fc.GetServicesServiceNasConfigMountPoint[];
        /**
         * The user id of the NAS file system.
         */
        userId: number;
    }

    export interface GetServicesServiceNasConfigMountPoint {
        /**
         * The local address where to mount your remote NAS directory.
         */
        mountDir: string;
        /**
         * The address of the remote NAS directory.
         */
        serverAddr: string;
    }

    export interface GetServicesServiceVpcConfig {
        /**
         * Associated security group ID.
         */
        securityGroupId: string;
        /**
         * Associated VPC ID.
         */
        vpcId: string;
        /**
         * Associated VSwitch IDs.
         */
        vswitchIds: string[];
    }

    export interface GetTriggersTrigger {
        /**
         * JSON-encoded trigger configuration. See [Configure triggers and events](https://www.alibabacloud.com/help/doc-detail/70140.htm) for more details.
         */
        config: string;
        /**
         * FC trigger creation time.
         */
        creationTime: string;
        /**
         * FC trigger ID.
         */
        id: string;
        /**
         * RAM role arn attached to the Function Compute trigger. Role used by the event source to call the function. The value format is "acs:ram::$account-id:role/$role-name". See [Create a trigger](https://www.alibabacloud.com/help/doc-detail/53102.htm) for more details.
         */
        invocationRole: string;
        /**
         * FC trigger last modification time.
         */
        lastModificationTime: string;
        /**
         * FC trigger name.
         */
        name: string;
        /**
         * Event source resource address. See [Create a trigger](https://www.alibabacloud.com/help/doc-detail/53102.htm) for more details.
         */
        sourceArn: string;
        /**
         * Type of the trigger. Valid values: `oss`, `log`, `timer`, `http` and `mnsTopic`.
         */
        type: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
    }

    export interface ServiceLogConfig {
        /**
         * The log store name of Alicloud Simple Log Service.
         */
        logstore: string;
        /**
         * The project name of the Alicloud Simple Log Service.
         */
        project: string;
    }

    export interface ServiceNasConfig {
        /**
         * The group id of your NAS file system.
         */
        groupId: number;
        /**
         * Config the NAS mount points, including following attributes:
         */
        mountPoints: outputs.fc.ServiceNasConfigMountPoint[];
        /**
         * The user id of your NAS file system.
         */
        userId: number;
    }

    export interface ServiceNasConfigMountPoint {
        /**
         * The local address where to mount your remote NAS directory.
         */
        mountDir: string;
        /**
         * The address of the remote NAS directory.
         */
        serverAddr: string;
    }

    export interface ServiceVpcConfig {
        /**
         * A security group ID associated with the Function Compute Service.
         */
        securityGroupId: string;
        vpcId: string;
        /**
         * A list of vswitch IDs associated with the Function Compute Service.
         */
        vswitchIds: string[];
    }

}

export namespace fnf {
    export interface GetExecutionsExecution {
        /**
         * The name of the execution.
         */
        executionName: string;
        /**
         * The name of the flow.
         */
        flowName: string;
        /**
         * The ID of the Execution. The value formats as `<flow_name>:<execution_name>`.
         */
        id: string;
        /**
         * The Input information for this execution.
         */
        input: string;
        /**
         * The output of the execution.
         */
        output: string;
        /**
         * The started time of the execution.
         */
        startedTime: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The stopped time of the execution.
         */
        stoppedTime: string;
    }

    export interface GetFlowsFlow {
        /**
         * The definition of the flow. It must comply with the Flow Definition Language (FDL) syntax.
         */
        definition: string;
        /**
         * The description of the flow.
         */
        description: string;
        /**
         * The unique ID of the flow.
         */
        flowId: string;
        /**
         * The ID of the Flow.
         */
        id: string;
        /**
         * The time when the flow was last modified.
         */
        lastModifiedTime: string;
        /**
         * The name of the flow. The name must be unique in an Alibaba Cloud account.
         */
        name: string;
        /**
         * The ARN of the specified RAM role that Serverless Workflow uses to assume the role when Serverless Workflow executes a flow.
         */
        roleArn: string;
        /**
         * The type of the flow. Set the value to `FDL`.
         */
        type: string;
    }

    export interface GetSchedulesSchedule {
        /**
         * The CRON expression of the time-based schedule to be created.
         */
        cronExpression: string;
        /**
         * The description of the time-based schedule to be created.
         */
        description: string;
        /**
         * Specifies whether to enable the time-based schedule you want to create.
         */
        enable: boolean;
        /**
         * The ID of the Schedule.
         */
        id: string;
        /**
         * The time when the time-based schedule was last updated.
         */
        lastModifiedTime: string;
        /**
         * The trigger message of the time-based schedule to be created. It must be in JSON object format.
         */
        payload: string;
        /**
         * The ID of the time-based schedule.
         */
        scheduleId: string;
        /**
         * The name of the time-based schedule to be created.
         */
        scheduleName: string;
    }

}

export namespace ga {
    export interface AclAclEntry {
        /**
         * The IP entry that you want to add to the ACL.
         */
        entry?: string;
        /**
         * The description of the IP entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_).
         */
        entryDescription?: string;
    }

    export interface EndpointGroupEndpointConfiguration {
        /**
         * Indicates whether client IP addresses are reserved. Valid values: `true`: Client IP addresses are reserved, `false`: Client IP addresses are not reserved. Default value is `false`.
         */
        enableClientipPreservation?: boolean;
        /**
         * The IP address or domain name of Endpoint N in the endpoint group.
         */
        endpoint: string;
        /**
         * The type of Endpoint N in the endpoint group. Valid values: `Domain`: a custom domain name, `Ip`: a custom IP address, `PublicIp`: an Alibaba Cloud public IP address, `ECS`: an Alibaba Cloud Elastic Compute Service (ECS) instance, `SLB`: an Alibaba Cloud Server Load Balancer (SLB) instance.
         */
        type: string;
        /**
         * The weight of Endpoint N in the endpoint group. Valid value is 0 to 255.
         */
        weight: number;
    }

    export interface EndpointGroupPortOverrides {
        /**
         * Forwarding port.
         */
        endpointPort?: number;
        /**
         * Listener port.
         */
        listenerPort?: number;
    }

    export interface ForwardingRuleRuleAction {
        /**
         * Forwarding configuration.
         */
        forwardGroupConfig: outputs.ga.ForwardingRuleRuleActionForwardGroupConfig;
        /**
         * Forwarding priority.
         */
        order: number;
        /**
         * Forward action type. Default: forwardgroup.
         */
        ruleActionType: string;
    }

    export interface ForwardingRuleRuleActionForwardGroupConfig {
        /**
         * Terminal node group configuration.
         */
        serverGroupTuples: outputs.ga.ForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface ForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * Terminal node group ID.
         */
        endpointGroupId: string;
    }

    export interface ForwardingRuleRuleCondition {
        /**
         * Domain name configuration information.
         */
        hostConfigs?: outputs.ga.ForwardingRuleRuleConditionHostConfig[];
        /**
         * Path configuration information.
         */
        pathConfig?: outputs.ga.ForwardingRuleRuleConditionPathConfig;
        /**
         * Forwarding condition type. Valid value: `Host`, `Path`.
         */
        ruleConditionType: string;
    }

    export interface ForwardingRuleRuleConditionHostConfig {
        /**
         * The domain name is 3-128 characters long, which can contain letters, numbers, dashes (-) and width period (.), and supports the use of asterisk (*) and width question mark (?) as wildcard characters.
         */
        values?: string[];
    }

    export interface ForwardingRuleRuleConditionPathConfig {
        /**
         * The domain name is 3-128 characters long, which can contain letters, numbers, dashes (-) and width period (.), and supports the use of asterisk (*) and width question mark (?) as wildcard characters.
         */
        values?: string[];
    }

    export interface GetAcceleratorsAccelerator {
        /**
         * The ID of the GA instance to query.
         */
        acceleratorId: string;
        /**
         * The Name of the GA instance.
         */
        acceleratorName: string;
        /**
         * Details of the basic bandwidth package bound to the global acceleration instance.
         */
        basicBandwidthPackages: outputs.ga.GetAcceleratorsAcceleratorBasicBandwidthPackage[];
        /**
         * The cloud enterprise network instance ID bound to the global acceleration instance.
         */
        cenId: string;
        /**
         * Details of the cross-domain acceleration package bound to the global acceleration instance.
         */
        crossDomainBandwidthPackages: outputs.ga.GetAcceleratorsAcceleratorCrossDomainBandwidthPackage[];
        /**
         * DDoS high-defense instance ID that is unbound from the global acceleration instance.
         */
        ddosId: string;
        /**
         * Descriptive information of the global acceleration instance.
         */
        description: string;
        /**
         * CNAME address assigned by Global Acceleration instance.
         */
        dnsName: string;
        /**
         * Time when the global acceleration instance expires.
         */
        expiredTime: number;
        /**
         * The ID of the Accelerator.
         */
        id: string;
        /**
         * The Payment Typethe GA instance.
         */
        paymentType: string;
        /**
         * CNAME of the Global Acceleration Linkage DDoS High Defense Instance.
         */
        secondDnsName: string;
        /**
         * The instance type of the GA instance.
         */
        spec: string;
        /**
         * The status of the GA instance.
         */
        status: string;
    }

    export interface GetAcceleratorsAcceleratorBasicBandwidthPackage {
        /**
         * Bandwidth value of cross-domain acceleration package.
         */
        bandwidth: number;
        /**
         * The bandwidth type of the basic bandwidth package.
         */
        bandwidthType: string;
        /**
         * Instance ID of the cross-domain acceleration package.
         */
        instanceId: string;
    }

    export interface GetAcceleratorsAcceleratorCrossDomainBandwidthPackage {
        /**
         * Bandwidth value of cross-domain acceleration package.
         */
        bandwidth: number;
        /**
         * Instance ID of the cross-domain acceleration package.
         */
        instanceId: string;
    }

    export interface GetAclsAcl {
        /**
         * The entries of the Acl.
         */
        aclEntries: outputs.ga.GetAclsAclAclEntry[];
        /**
         * The  ID of the Acl.
         */
        aclId: string;
        /**
         * The name of the acl.
         */
        aclName: string;
        /**
         * The address ip version.
         */
        addressIpVersion: string;
        /**
         * The ID of the Acl. Its value is same as `aclId`.
         */
        id: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAclsAclAclEntry {
        /**
         * The IP entry that you want to add to the ACL.
         */
        entry: string;
        /**
         * The description of the IP entry.
         */
        entryDescription: string;
    }

    export interface GetAdditionalCertificatesCertificate {
        /**
         * The ID of the GA instance.
         */
        acceleratorId: string;
        /**
         * The Certificate ID.
         */
        certificateId: string;
        /**
         * The domain name specified by the certificate.
         */
        domain: string;
        /**
         * The ID of the Additional Certificate. The value formats as `<accelerator_id>:<listener_id>:<domain>`.
         */
        id: string;
        /**
         * The ID of the listener. Only HTTPS listeners support this parameter.
         */
        listenerId: string;
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth value of bandwidth packet.
         */
        bandwidth: number;
        /**
         * The Resource ID of the bandwidth.
         */
        bandwidthPackageId: string;
        /**
         * The name of the bandwidth packet.
         */
        bandwidthPackageName: string;
        /**
         * The bandwidth type of the bandwidth.
         */
        bandwidthType: string;
        /**
         * Interworking area A of cross domain acceleration package. Only international stations support returning this parameter.
         */
        cbnGeographicRegionIda: string;
        /**
         * Interworking area B of cross domain acceleration package. Only international stations support returning this parameter.
         */
        cbnGeographicRegionIdb: string;
        /**
         * The description of bandwidth package.
         */
        description: string;
        /**
         * Bandwidth package expiration time.
         */
        expiredTime: string;
        /**
         * The ID of the Bandwidth Package.
         */
        id: string;
        /**
         * The payment type of the bandwidth.
         */
        paymentType: string;
        /**
         * The status of the bandwidth plan.
         */
        status: string;
        /**
         * The type of the bandwidth packet. China station only supports return to basic.
         */
        type: string;
    }

    export interface GetEndpointGroupsGroup {
        /**
         * The description of the endpoint group.
         */
        description: string;
        /**
         * The endpointConfigurations of the endpoint group.
         */
        endpointConfigurations: outputs.ga.GetEndpointGroupsGroupEndpointConfiguration[];
        /**
         * The endpointGroupId of the Endpoint Group.
         */
        endpointGroupId: string;
        /**
         * The ID of the region where the endpoint group is deployed.
         */
        endpointGroupRegion: string;
        /**
         * The interval between two consecutive health checks. Unit: seconds.
         */
        healthCheckIntervalSeconds: number;
        /**
         * The path specified as the destination of the targets for health checks.
         */
        healthCheckPath: string;
        /**
         * The port that is used for health checks.
         */
        healthCheckPort: number;
        /**
         * The protocol that is used to connect to the targets for health checks.
         */
        healthCheckProtocol: string;
        /**
         * The ID of the Endpoint Group.
         */
        id: string;
        /**
         * The ID of the listener that is associated with the endpoint group.
         */
        listenerId: string;
        /**
         * The name of the endpoint group.
         */
        name: string;
        /**
         * Mapping between listening port and forwarding port of boarding point.
         */
        portOverrides: outputs.ga.GetEndpointGroupsGroupPortOverride[];
        /**
         * The status of the endpoint group.
         */
        status: string;
        /**
         * The number of consecutive failed heath checks that must occur before the endpoint is deemed unhealthy.
         */
        thresholdCount: number;
        /**
         * The weight of the endpoint group when the corresponding listener is associated with multiple endpoint groups.
         */
        trafficPercentage: number;
    }

    export interface GetEndpointGroupsGroupEndpointConfiguration {
        /**
         * Indicates whether client IP addresses are reserved.
         */
        enableClientipPreservation: boolean;
        /**
         * The IP address or domain name of Endpoint N in the endpoint group.
         */
        endpoint: string;
        /**
         * Probe Port.
         */
        probePort: number;
        /**
         * Probe Protocol.
         */
        probeProtocol: string;
        /**
         * The type of Endpoint N in the endpoint group.
         */
        type: string;
        /**
         * The weight of Endpoint N in the endpoint group.
         */
        weight: number;
    }

    export interface GetEndpointGroupsGroupPortOverride {
        /**
         * Forwarding port.
         */
        endpointPort: number;
        /**
         * Listener port.
         */
        listenerPort: number;
    }

    export interface GetForwardingRulesForwardingRule {
        /**
         * Forwarding Policy ID.
         */
        forwardingRuleId: string;
        /**
         * Forwarding policy name. The length of the name is 2-128 English or Chinese characters.
         */
        forwardingRuleName: string;
        /**
         * Forwarding Policy Status.
         */
        forwardingRuleStatus: string;
        id: string;
        /**
         * The ID of the listener.
         */
        listenerId: string;
        /**
         * Forwarding policy priority.
         */
        priority: number;
        /**
         * The IP protocol used by the GA instance.
         * `order` - Forwarding priority.
         * `ruleActionType` - Forward action type.
         * `forwardGroupConfig` - Forwarding configuration.
         * `serverGroupTuples` - Terminal node group configuration.
         * `endpointGroupId` - Terminal node group ID.
         */
        ruleActions: outputs.ga.GetForwardingRulesForwardingRuleRuleAction[];
        /**
         * Forward action.
         * `ruleConditionType` - Forwarding condition type.
         * `pathConfig` - Path configuration information.
         * `values` - The length of the path is 1-128 characters.
         * `hostConfig` - Domain name configuration information.
         * `values` - The domain name is 3-128 characters long.
         */
        ruleConditions: outputs.ga.GetForwardingRulesForwardingRuleRuleCondition[];
    }

    export interface GetForwardingRulesForwardingRuleRuleAction {
        forwardGroupConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleActionForwardGroupConfig[];
        order: number;
        ruleActionType: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleActionForwardGroupConfig {
        serverGroupTuples: outputs.ga.GetForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
        endpointGroupId: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleCondition {
        hostConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleConditionHostConfig[];
        pathConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleConditionPathConfig[];
        ruleConditionType: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleConditionHostConfig {
        values: string[];
    }

    export interface GetForwardingRulesForwardingRuleRuleConditionPathConfig {
        values: string[];
    }

    export interface GetIpSetsSet {
        /**
         * The ID of an acceleration region.
         */
        accelerateRegionId: string;
        /**
         * The bandwidth allocated to the acceleration region.
         */
        bandwidth: number;
        /**
         * The ID of the Ip Set.
         */
        id: string;
        /**
         * The list of accelerated IP addresses in the acceleration region.
         */
        ipAddressLists: string[];
        /**
         * Accelerated area ID.
         */
        ipSetId: string;
        /**
         * The IP protocol used by the GA instance.
         */
        ipVersion: string;
        /**
         * The status of the acceleration region.
         */
        status: string;
    }

    export interface GetListenersListener {
        /**
         * The certificates of the listener.
         */
        certificates: outputs.ga.GetListenersListenerCertificate[];
        /**
         * The clientAffinity of the listener.
         */
        clientAffinity: string;
        /**
         * The description of the listener.
         */
        description: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The listenerId of the listener.
         */
        listenerId: string;
        /**
         * The name of the listener. The length of the name is 2-128 characters. It starts with uppercase and lowercase letters or Chinese characters. It can contain numbers and underscores and dashes.
         */
        name: string;
        /**
         * The portRanges of the listener.
         */
        portRanges: outputs.ga.GetListenersListenerPortRange[];
        /**
         * Type of network transport protocol monitored.
         */
        protocol: string;
        /**
         * The status of the listener.
         */
        status: string;
    }

    export interface GetListenersListenerCertificate {
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The type of the certificate.
         */
        type: string;
    }

    export interface GetListenersListenerPortRange {
        /**
         * The initial listening port used to receive requests and forward them to terminal nodes.
         */
        fromPort: number;
        /**
         * The end listening port used to receive requests and forward them to terminal nodes.
         */
        toPort: number;
    }

    export interface ListenerCertificate {
        /**
         * The id of the certificate.
         */
        id?: string;
    }

    export interface ListenerPortRange {
        /**
         * The initial listening port used to receive requests and forward them to terminal nodes.
         */
        fromPort: number;
        /**
         * The end listening port used to receive requests and forward them to terminal nodes.
         */
        toPort: number;
    }

}

export namespace gpdb {
    export interface GetAccountsAccount {
        /**
         * The description of the account.
         */
        accountDescription: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The ID of the Account. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The status of the account. Valid values: `Active`, `Creating` and `Deleting`.
         */
        status: string;
    }

    export interface GetInstancesInstance {
        /**
         * Instance availability zone.
         */
        availabilityZone: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        chargeType: string;
        /**
         * The time when you create an instance. The format is YYYY-MM-DDThh:mm:ssZ, such as 2011-05-30T12:11:4Z.
         */
        creationTime: string;
        /**
         * The description of an instance.
         */
        description: string;
        /**
         * Database engine type. Supported option is `gpdb`.
         */
        engine: string;
        /**
         * Database engine version.
         */
        engineVersion: string;
        /**
         * The instance id.
         */
        id: string;
        /**
         * The group type.
         */
        instanceClass: string;
        /**
         * The number of groups.
         */
        instanceGroupCount: string;
        instanceNetworkType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Status of the instance.
         */
        status: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace graphdatabase {
    export interface DbInstanceDbInstanceIpArray {
        /**
         * The default is empty. To distinguish between the different property console does not display a `hidden` label grouping.
         */
        dbInstanceIpArrayAttribute?: string;
        /**
         * IP ADDRESS whitelist group name.
         */
        dbInstanceIpArrayName?: string;
        /**
         * IP ADDRESS whitelist addresses in the IP ADDRESS list, and a maximum of 1000 comma-separated format is as follows: `0.0.0.0/0` and `10.23.12.24`(IP) or `10.23.12.24/24`(CIDR mode, CIDR (Classless Inter-Domain Routing)/24 represents the address prefixes in the length of the range [1,32]).
         */
        securityIps?: string;
    }

    export interface GetDbInstancesInstance {
        /**
         * Virtual Private Cloud (vpc connection such as a VPN connection or leased line domain name).
         */
        connectionString: string;
        /**
         * Creation time, which follows the format of `YYYY-MM-DD 'T'hh:mm:ssZ`, such as `2011-05-30 T12:11:4Z`.
         */
        createTime: string;
        /**
         * The current kernel image version.
         */
        currentMinorVersion: string;
        /**
         * The category of the db instance.
         */
        dbInstanceCategory: string;
        /**
         * For example, instances can be grouped according to Cpu core count.
         */
        dbInstanceCpu: string;
        /**
         * According to the practical example or notes.
         */
        dbInstanceDescription: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * IP ADDRESS whitelist for the instance group list.
         */
        dbInstanceIpArrays: outputs.graphdatabase.GetDbInstancesInstanceDbInstanceIpArray[];
        /**
         * Instance memory, which is measured in MB.
         */
        dbInstanceMemory: string;
        /**
         * The network type of the db instance.
         */
        dbInstanceNetworkType: string;
        /**
         * Disk storage type. Valid values: `cloudEssd`, `cloudSsd`.
         */
        dbInstanceStorageType: string;
        /**
         * The type of the db instance.
         */
        dbInstanceType: string;
        /**
         * The class of the db node.
         */
        dbNodeClass: string;
        /**
         * The count of the db node.
         */
        dbNodeCount: string;
        /**
         * Instance storage space, which is measured in GB.
         */
        dbNodeStorage: string;
        /**
         * Kernel Version. Value range: `1.0` or `1.0-OpenCypher`. `1.0`: represented as gremlin, `1.0-OpenCypher`: said opencypher.
         */
        dbVersion: string;
        /**
         * The instance after it expires time for subscription instance.
         */
        expireTime: string;
        /**
         * The expire status of the db instance.
         */
        expired: string;
        /**
         * The ID of the Db Instance.
         */
        id: string;
        /**
         * The latest kernel image version.
         */
        latestMinorVersion: string;
        /**
         * Instance lock state. Value range: `Unlock`, `ManualLock`, `LockByExpiration`, `LockByRestoration` and `LockByDiskQuota`. `Unlock`: normal. `ManualLock`: the manual trigger lock. `LockByExpiration`: that represents the instance expires automatically lock. `LockByRestoration`: indicates that the instance rollback before auto-lock. `LockByDiskQuota`: that represents the instance space full automatic lock.
         */
        lockMode: string;
        /**
         * An instance is locked the reason.
         */
        lockReason: string;
        /**
         * Instance maintenance time such as `00:00Z-02:00Z`, 0 to 2 points to carry out routine maintenance.
         */
        maintainTime: string;
        /**
         * The master instance ID of the db instance.
         */
        masterDbInstanceId: string;
        /**
         * The paymen type of the resource.
         */
        paymentType: string;
        /**
         * Application Port.
         */
        port: number;
        /**
         * The public connection string ID of the resource.
         */
        publicConnectionString: string;
        /**
         * The public port ID of the resource.
         */
        publicPort: number;
        /**
         * The array of the readonly db instances.
         */
        readOnlyDbInstanceIds: string[];
        /**
         * Instance status. Value range: `Creating`, `Running`, `Deleting`, `Rebooting`, `DBInstanceClassChanging`, `NetAddressCreating` and `NetAddressDeleting`.
         */
        status: string;
        /**
         * The vpc id of the db instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the resource.
         */
        zoneId: string;
    }

    export interface GetDbInstancesInstanceDbInstanceIpArray {
        /**
         * The default is empty. To distinguish between the different property console does not display a `hidden` label grouping.
         */
        dbInstanceIpArrayAttribute?: string;
        /**
         * IP ADDRESS whitelist group name.
         */
        dbInstanceIpArrayName?: string;
        /**
         * IP ADDRESS whitelist addresses in the IP ADDRESS list, and a maximum of 1000 comma-separated format is as follows: `0.0.0.0/0` and `10.23.12.24`(IP) or `10.23.12.24/24`(CIDR mode, CIDR (Classless Inter-Domain Routing)/24 represents the address prefixes in the length of the range [1,32]).
         */
        securityIps?: string;
    }

}

export namespace hbase {
    export interface GetInstanceTypesCoreInstanceType {
        /**
         * Name of the category, single or cluster.
         */
        category: string;
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * The engine name, `singlehbase`, `hbase`, `hbaseue`, `bds`.
         */
        engine: string;
        /**
         * The hbase instance type of create hbase cluster instance.
         */
        instanceType: string;
        /**
         * Max count of the core instance nodes.
         */
        maxCoreCount: number;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
        /**
         * Name of the storage type.
         */
        storageType: string;
        /**
         * The engine version, singlehbase/hbase=1.1/2.0, bds=1.0.
         */
        version: string;
        /**
         * Name of zone id.
         */
        zone: string;
    }

    export interface GetInstanceTypesMasterInstanceType {
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * The hbase instance type of create hbase cluster instance.
         */
        instanceType: string;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
    }

    export interface GetInstanceTypesType {
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
        /**
         * Name of the instance type.
         */
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The Backup Status of the instance.
         */
        backupStatus: string;
        /**
         * Core node disk size, unit:GB.
         */
        coreDiskSize: number;
        /**
         * Cloud_ssd or cloud_efficiency
         */
        coreDiskType: string;
        /**
         * Like hbase.sn1.large, hbase.sn1.large, hbase.n1.2xlarge and so on.
         */
        coreInstanceType: string;
        /**
         * Same with "coreInstanceQuantity"
         */
        coreNodeCount: number;
        /**
         * The created time of the instance.
         */
        createdTime: string;
        /**
         * The switch of delete protection.
         */
        deletionProtection: boolean;
        /**
         * The engine of the instance.
         */
        engine: string;
        /**
         * The engineVersion of the instance.
         */
        engineVersion: string;
        /**
         * The expire time of the instance.
         */
        expireTime: string;
        /**
         * The ID of the HBase instance.
         */
        id: string;
        /**
         * Like hbase.sn1.large, hbase.sn1.large, hbase.n1.2xlarge and so on.
         */
        masterInstanceType: string;
        /**
         * The node count of master
         */
        masterNodeCount: number;
        /**
         * The name of the HBase instance.
         */
        name: string;
        /**
         * Classic network or VPC.
         */
        networkType: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * VPC ID the instance belongs to.
         */
        vpcId: string;
        /**
         * VSwitch ID the instance belongs to.
         */
        vswitchId: string;
        /**
         * Zone ID the instance belongs to.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone. Removed from v1.99.0.
         */
        multiZoneIds: string[];
    }

    export interface InstanceSlbConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

    export interface InstanceUiProxyConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

    export interface InstanceZkConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }
}

export namespace hbr {
    export interface GetBackupJobsFilter {
        /**
         * The key of the field to filter. Valid values: `PlanId`, `VaultId`, `InstanceId`, `Bucket`, `FileSystemId`, `CompleteTime`.
         */
        key?: string;
        /**
         * The operator of the field to filter. Valid values: `EQUAL`, `NOT_EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `BETWEEN`, `IN`.
         */
        operator?: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values?: string[];
    }

    export interface GetBackupJobsJob {
        /**
         * The actual data volume of the backup task (After deduplication) . Unit byte.
         */
        actualBytes: string;
        /**
         * The actual number of items in the backup task. (Currently only file backup is available).
         */
        actualItems: string;
        /**
         * The name of backup job.
         */
        backJobName: string;
        /**
         * The ID of the backup job.
         */
        backupJobId: string;
        /**
         * Backup type. Valid values: `COMPLETE`(full backup).
         */
        backupType: string;
        /**
         * The name of target OSS bucket.
         */
        bucket: string;
        /**
         * The amount of backup data (Incremental). Unit byte.
         */
        bytesDone: string;
        /**
         * The total amount of data sources. Unit byte.
         */
        bytesTotal: string;
        /**
         * The completion time of backup job. UNIX time seconds.
         */
        completeTime: string;
        /**
         * The creation time of backup job. UNIX time seconds.
         */
        createTime: string;
        /**
         * Error message.
         */
        errorMessage: string;
        /**
         * Exclude path. String of Json list. Up to 255 characters. e.g. `"[\"/home/work\"]"`
         */
        exclude: string;
        /**
         * The ID of destination file system.
         */
        fileSystemId: string;
        /**
         * The ID of the backup job.
         */
        id: string;
        /**
         * Include path. String of Json list. Up to 255 characters. e.g. `"[\"/var\"]"`
         */
        include: string;
        /**
         * The ID of target ECS instance.
         */
        instanceId: string;
        /**
         * The number of items restore job recovered.
         */
        itemsDone: string;
        /**
         * The total number of items restore job recovered.
         */
        itemsTotal: string;
        /**
         * File system creation time. UNIX time in seconds.
         */
        nasCreateTime: string;
        /**
         * List of backup path. e.g. `["/home", "/var"]`.
         */
        paths: string[];
        /**
         * The ID of a backup plan.
         */
        planId: string;
        /**
         * The prefix of Oss bucket files.
         */
        prefix: string;
        /**
         * Backup progress. The value is 100%*100.
         */
        progress: string;
        /**
         * The type of data source. Valid Values: `ECS_FILE`, `OSS`, `NAS`, `UDM_DISK`.
         */
        sourceType: string;
        /**
         * The scheduled backup start time. UNIX time seconds.
         */
        startTime: string;
        /**
         * The status of restore job. Valid values: `COMPLETE` , `PARTIAL_COMPLETE`, `FAILED`.
         */
        status: string;
        /**
         * The update time of backup job. UNIX time seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetEcsBackupClientsClient {
        /**
         * The system architecture of client, only the ECS File Backup Client is available. Valid values: `AMD64` , `386`.
         */
        archType: string;
        /**
         * Client protected status. Valid values: `UNPROTECTED`, `PROTECTED`.
         */
        backupStatus: string;
        /**
         * The type of client. Valid values: `ECS_CLIENT` (ECS File Backup Client).
         */
        clientType: string;
        /**
         * The version of client.
         */
        clientVersion: string;
        /**
         * The creation time of client. Unix time in seconds.
         */
        createTime: string;
        /**
         * The data plane access point type. Valid Values: `PUBLIC`, `VPC`, `CLASSIC`.
         */
        dataNetworkType: string;
        /**
         * The data plane proxy settings. Valid Values: `DISABLE`, `USE_CONTROL_PROXY`, `CUSTOM`.
         */
        dataProxySetting: string;
        /**
         * The first ID of the resource.
         */
        ecsBackupClientId: string;
        /**
         * The hostname of ECS instance.
         */
        hostname: string;
        /**
         * The ID of the Ecs Backup Client.
         */
        id: string;
        /**
         * The ID of ECS instance. When the client type is ECS file backup client, it indicates the ID of ECS instance. When the client type is a local file backup client, it is a hardware fingerprint generated based on system information.
         */
        instanceId: string;
        /**
         * The name of ECS instance.
         */
        instanceName: string;
        /**
         * The last heartbeat time of client. Unix Time Seconds.
         */
        lastHeartBeatTime: string;
        /**
         * The latest version of client.
         */
        maxClientVersion: string;
        /**
         * The number of CPU cores used by a single backup task, 0 means no restrictions.
         */
        maxCpuCore: string;
        /**
         * The number of concurrent jobs for a single backup task, 0 means no restrictions.
         */
        maxWorker: string;
        /**
         * The operating system type of client, only the ECS File Backup Client is available. Valid values: `windows`, `linux`.
         */
        osType: string;
        /**
         * Intranet IP address of the instance, only available for ECS file backup client.
         */
        privateIpv4: string;
        /**
         * Custom data plane proxy server host address.
         */
        proxyHost: string;
        /**
         * The password of custom data plane proxy server.
         */
        proxyPassword: string;
        /**
         * Custom data plane proxy server host port.
         */
        proxyPort: string;
        /**
         * The username of custom data plane proxy server.
         */
        proxyUser: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The update time of client. Unix Time Seconds.
         */
        updatedTime: string;
        /**
         * Indicates whether to use the HTTPS protocol. Valid values: `true`, `false`.
         */
        useHttps: boolean;
        /**
         * The ID of Zone.
         */
        zoneId: string;
    }

    export interface GetEcsBackupPlansPlan {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        createTime: string;
        /**
         * The creation time of the backup plan. UNIX time in seconds.
         */
        createdTime: string;
        detail: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of ecs backup plan.
         */
        ecsBackupPlanId: string;
        /**
         * The name of the backup plan.
         */
        ecsBackupPlanName: string;
        /**
         * Exclude path. String of Json list. Up to 255 characters. e.g. `"[\"/home/work\"]"`
         */
        exclude: string;
        /**
         * The ID of ecs backup plan.
         */
        id: string;
        /**
         * Include path. String of Json list. Up to 255 characters. e.g. `"[\"/var\"]"`
         */
        include: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * Windows operating system with application consistency using VSS. eg: {`UseVSS`:false}.
         */
        options: string;
        /**
         * Backup path. e.g. `["/home", "/var"]`
         */
        paths: string[];
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy. Optional format: `I|{startTime}|{interval}`. It means to execute a backup task every `{interval}` starting from `{startTime}`. The backup task for the elapsed time will not be compensated. If the last backup task has not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        /**
         * The type of backup source.
         */
        sourceType: string;
        /**
         * Flow control. The format is: {start}|{end}|{bandwidth}. Use `|` to separate multiple flow control configurations, multiple flow control configurations not allowed to have overlapping times.
         */
        speedLimit: string;
        /**
         * The update time of the backup plan. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of Backup vault.
         */
        vaultId: string;
    }

    export interface GetNasBackupPlansPlan {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        /**
         * File System Creation Time. **Note** The time format of the API adopts the ISO 8601 format, such as `2021-07-09T15:45:30CST`.
         */
        createTime: string;
        createdTime: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The File System ID of Nas.
         */
        fileSystemId: string;
        /**
         * The ID of Nas backup plan.
         */
        id: string;
        /**
         * The ID of Nas backup plan.
         */
        nasBackupPlanId: string;
        /**
         * The name of the resource.
         */
        nasBackupPlanName: string;
        /**
         * Options of nas.
         */
        options: string;
        /**
         * List of backup path. Up to 65536 Characters. e.g.`["/home", "/var"]`
         */
        paths: string[];
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy. Optional format: `I|{startTime}|{interval}`. It means to execute a backup task every `{interval}` starting from `{startTime}`. The backup task for the elapsed time will not be compensated. If the last backup task has not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetOssBackupPlansPlan {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        /**
         * The name of OSS bucket.
         */
        bucket: string;
        /**
         * The creation time of the backup plan. UNIX time in seconds.
         */
        createdTime: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of Oss backup plan.
         */
        id: string;
        /**
         * The ID of Oss backup plan.
         */
        ossBackupPlanId: string;
        /**
         * The name of the backup plan. 1~64 characters, the backup plan name of each data source type in a single warehouse required to be unique.
         */
        ossBackupPlanName: string;
        /**
         * Backup prefix.
         */
        prefix: string;
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy. Optional format: I|{startTime}|{interval}. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        /**
         * The update time of the backup plan. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetRestoreJobsJob {
        /**
         * The actual size of Snapshot.
         */
        actualBytes: string;
        /**
         * The actual number of files.
         */
        actualItems: string;
        /**
         * The size of restore job recovered.
         */
        bytesDone: string;
        /**
         * The total size of restore job recovered.
         */
        bytesTotal: string;
        /**
         * The completion time of restore Job.
         */
        completeTime: string;
        /**
         * The creation time of restore job.
         */
        createTime: string;
        errorFile: string;
        /**
         * The error message of recovery task execution.
         */
        errorMessage: string;
        /**
         * The expiration time of restore job. Unix Time in seconds.
         */
        expireTime: string;
        /**
         * The ID of the restore job.
         */
        id: string;
        /**
         * The number of items restore job recovered.
         */
        itemsDone: string;
        /**
         * The total number of items restore job recovered.
         */
        itemsTotal: string;
        /**
         * Recovery Options.
         */
        options: string;
        parentId: string;
        /**
         * The recovery progress.
         */
        progress: number;
        /**
         * The ID of restore job.
         */
        restoreJobId: string;
        /**
         * The type of recovery destination. Valid Values: `ECS_FILE`, `OSS`, `NAS`.
         */
        restoreType: string;
        /**
         * The hashcode of Snapshot.
         */
        snapshotHash: string;
        /**
         * The ID of Snapshot.
         */
        snapshotId: string;
        /**
         * The type of data source. Valid values: `ECS_FILE`, `NAS`, `OSS`.
         */
        sourceType: string;
        /**
         * The start time of restore job. Unix Time in Seconds.
         */
        startTime: string;
        /**
         * The status of restore job.
         */
        status: string;
        /**
         * The name of target ofo OSS bucket.
         */
        targetBucket: string;
        targetClientId: string;
        /**
         * The creation time of destination file system.
         */
        targetCreateTime: string;
        targetDataSourceId: string;
        /**
         * The ID of destination file system.
         */
        targetFileSystemId: string;
        /**
         * The ID of target ECS instance.
         */
        targetInstanceId: string;
        /**
         * The target file path of ECS instance.
         */
        targetPath: string;
        /**
         * The file prefix of target OSS object.
         */
        targetPrefix: string;
        /**
         * The update Time of restore job. Unix Time in Seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetServerBackupPlansFilter {
        /**
         * The key of the field to filter. Valid values: `planId`, `instanceId`, `planName`.
         */
        key?: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values?: string[];
    }

    export interface GetServerBackupPlansPlan {
        /**
         * The creation time of backup plan.
         */
        createTime: string;
        /**
         * ECS server backup plan details.
         */
        details: outputs.hbr.GetServerBackupPlansPlanDetail[];
        /**
         * Whether to disable the backup task. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of the server backup plan.
         */
        ecsServerBackupPlanId: string;
        /**
         * The name of the backup plan. 1~64 characters, the backup plan name of each data source type in a single warehouse required to be unique.
         */
        ecsServerBackupPlanName: string;
        /**
         * The ID of the server backup plan.
         */
        id: string;
        /**
         * The ID of ECS Instance.
         */
        instanceId: string;
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy.
         */
        schedule: string;
    }

    export interface GetServerBackupPlansPlanDetail {
        /**
         * Whether to turn on application consistency. The application consistency snapshot backs up memory data and ongoing database transactions at the time of snapshot creation to ensure the consistency of application system data and database transactions. By applying consistent snapshots, there is no data damage or loss, so as to avoid log rollback during database startup and ensure that the application is in a consistent startup state. Valid values: `true`, `false`.
         */
        appConsistent: boolean;
        /**
         * Only vaild when DoCopy is true. The destination region ID when replicating to another region. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRegionId: string;
        /**
         * Only vaild when DoCopy is true. The retention days of the destination backup. When not specified, the destination backup will be saved permanently. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRetention: number;
        /**
         * The list of cloud disks to be backed up in the ECS instance. When not specified, a snapshot is executed for all the disks on the ECS instance.
         */
        diskIdLists: string[];
        /**
         * Whether replicate to another region. Valid values: `true`, `false`.
         */
        doCopy: boolean;
        /**
         * Only the Linux system is valid. Whether to use the Linux FsFreeze mechanism to ensure that the file system is read-only consistent before creating a storage snapshot. The default is True. Valid values: `true`, `false`.
         */
        enableFsFreeze: boolean;
        /**
         * Only vaild for the linux system when AppConsistent is true. The application thaw script path (e.g. /tmp/postscript.sh). The postscript.sh script must meet the following conditions: in terms of permissions, only the root user as the owner has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        postScriptPath: string;
        /**
         * Only vaild for the linux system when AppConsistent is true. Apply the freeze script path (e.g. /tmp/prescript.sh). prescript.sh scripts must meet the following conditions: in terms of permissions, only root, as the owner, has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        preScriptPath: string;
        /**
         * Whether to turn on file system consistency. If SnapshotGroup is true, when AppConsistent is true but the relevant conditions are not met or AppConsistent is false, the resulting snapshot will be a file system consistency snapshot. The file system consistency ensures that the file system memory and disk information are synchronized at the time of snapshot creation, and the file system write operation is frozen to make the file system in a consistent state. The file system consistency snapshot can prevent the operating system from performing disk inspection and repair operations such as CHKDSK or fsck after restart. Valid values: `true`, `false`.
         */
        snapshotGroup: boolean;
        /**
         * Only the Linux system is valid, and the IO freeze timeout period. The default is 30 seconds.
         */
        timeoutInSeconds: number;
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The actual data volume of the snapshot. Unit byte.
         */
        actualBytes: string;
        /**
         * The actual number of items in the snapshot. (Currently only file backup is available).
         */
        actualItems: string;
        /**
         * Backup type. Possible values: `COMPLETE` (full backup).
         */
        backupType: string;
        /**
         * The name of OSS bucket.
         */
        bucket: string;
        /**
         * The incremental amount of backup data. Unit byte.
         */
        bytesDone: string;
        /**
         * The total amount of data sources. Unit byte.
         */
        bytesTotal: string;
        /**
         * The ID of ECS backup client.
         */
        clientId: string;
        /**
         * The time when the snapshot completed. UNIX time in seconds.
         */
        completeTime: string;
        /**
         * File System Creation Time of Nas. Unix Time Seconds.
         */
        createTime: string;
        /**
         * Snapshot creation time. UNIX time in seconds.
         */
        createdTime: string;
        errorFile: string;
        /**
         * The ID of NAS File system.
         */
        fileSystemId: string;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * The number of backup items. (Currently only file backup is available).
         */
        itemsDone: string;
        /**
         * The total number of data source items. (Currently only file backup is available).
         */
        itemsTotal: string;
        /**
         * The job ID of backup task.
         */
        jobId: string;
        /**
         * The hashcode of parent backup snapshot.
         */
        parentSnapshotHash: string;
        /**
         * Backup Path.
         */
        path: string;
        /**
         * Backup file prefix.
         */
        prefix: string;
        /**
         * The number of days to keep.
         */
        retention: string;
        /**
         * The hashcode of Snapshot.
         */
        snapshotHash: string;
        /**
         * The ID of the Snapshot.
         */
        snapshotId: string;
        /**
         * Data source type, optional values: `ECS_FILE`, `OSS`, `NAS`.
         */
        sourceType: string;
        /**
         * The start time of the snapshot. UNIX time in seconds.
         */
        startTime: string;
        /**
         * The status of snapshot execution. Possible values: `COMPLETE`, `PARTIAL_COMPLETE`, `FAILED`.
         */
        status: string;
        /**
         * The update time of snapshot. UNIX time in seconds.
         */
        updatedTime: string;
    }

    export interface GetVaultsVault {
        /**
         * The name of the OSS bucket of the Vault.
         */
        bucketName: string;
        /**
         * The amount of backup data. The unit is Byte.
         */
        bytesDone: string;
        /**
         * The creation time of the Vault. UNIX time in seconds.
         */
        createdTime: string;
        /**
         * Whether to enable the deduplication function for the database backup Vault.
         */
        dedup: boolean;
        /**
         * The description of the vault.
         */
        description: string;
        /**
         * The ID of vault.
         */
        id: string;
        /**
         * Index available.
         */
        indexAvailable: boolean;
        /**
         * Index level.
         */
        indexLevel: string;
        /**
         * Index update time.
         */
        indexUpdateTime: string;
        /**
         * The time of the last remote backup synchronization.
         */
        latestReplicationTime: string;
        /**
         * Billing model, possible values:
         */
        paymentType: string;
        /**
         * Whether it is a remote backup warehouse. It's a boolean value.
         */
        replication: boolean;
        /**
         * The region ID to which the remote backup Vault belongs.
         */
        replicationSourceRegionId: string;
        /**
         * The source vault ID of the remote backup Vault.
         */
        replicationSourceVaultId: string;
        /**
         * Warehouse-level data retention days, only valid for archive libraries.
         */
        retention: string;
        /**
         * Whether to enable the backup search function.
         */
        searchEnabled: boolean;
        sourceTypes: string[];
        /**
         * The status of Vault. Valid values: `INITIALIZING`, `CREATED`, `ERROR`, `UNKNOWN`.
         */
        status: string;
        /**
         * Backup vault storage usage. The unit is Byte.
         */
        storageSize: string;
        /**
         * The update time of the Vault. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of vault, same as `id`.
         */
        vaultId: string;
        /**
         * The name of vault.
         */
        vaultName: string;
        /**
         * Error status information of Vault. Only valid for remote backup warehouses. Only the remote backup warehouse is valid.
         */
        vaultStatusMessage: string;
        /**
         * The storage class of vault. Valid values: `STANDARD`.
         */
        vaultStorageClass: string;
        /**
         * The type of Vault. Valid values: `STANDARD`.
         */
        vaultType: string;
    }

    export interface ServerBackupPlanDetail {
        /**
         * Whether to turn on application consistency. The application consistency snapshot backs up memory data and ongoing database transactions at the time of snapshot creation to ensure the consistency of application system data and database transactions. By applying consistent snapshots, there is no data damage or loss, so as to avoid log rollback during database startup and ensure that the application is in a consistent startup state. Valid values: `true`, `false`.
         */
        appConsistent: boolean;
        /**
         * Only vaild when DoCopy is true. The destination region ID when replicating to another region. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRegionId?: string;
        /**
         * Only vaild when DoCopy is true. The retention days of the destination backup. When not specified, the destination backup will be saved permanently. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRetention?: number;
        /**
         * The list of cloud disks to be backed up in the ECS instance. When not specified, a snapshot is executed for all the disks on the ECS instance.
         */
        diskIdLists?: string[];
        /**
         * Whether replicate to another region. Valid values: `true`, `false`.
         */
        doCopy?: boolean;
        /**
         * Only the Linux system is valid. Whether to use the Linux FsFreeze mechanism to ensure that the file system is read-only consistent before creating a storage snapshot. The default is True. Valid values: `true`, `false`.
         */
        enableFsFreeze?: boolean;
        /**
         * Only vaild for the linux system when AppConsistent is true. The application thaw script path (e.g. /tmp/postscript.sh). The postscript.sh script must meet the following conditions: in terms of permissions, only the root user as the owner has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        postScriptPath?: string;
        /**
         * Only vaild for the linux system when AppConsistent is true. Apply the freeze script path (e.g. /tmp/prescript.sh). prescript.sh scripts must meet the following conditions: in terms of permissions, only root, as the owner, has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        preScriptPath?: string;
        /**
         * Whether to turn on file system consistency. If SnapshotGroup is true, when AppConsistent is true but the relevant conditions are not met or AppConsistent is false, the resulting snapshot will be a file system consistency snapshot. The file system consistency ensures that the file system memory and disk information are synchronized at the time of snapshot creation, and the file system write operation is frozen to make the file system in a consistent state. The file system consistency snapshot can prevent the operating system from performing disk inspection and repair operations such as CHKDSK or fsck after restart. Valid values: `true`, `false`.
         */
        snapshotGroup: boolean;
        /**
         * Only the Linux system is valid, and the IO freeze timeout period. The default is 30 seconds.
         */
        timeoutInSeconds?: number;
    }
}

export namespace imm {
    export interface GetProjectsProject {
        /**
         * The billing type. **Note:** This parameter is deprecated from 2021-04-01.
         */
        billingType: string;
        /**
         * The maximum number of requests that can be processed per second. **Note:** This parameter is deprecated from 2021-04-01.
         */
        computeUnit: number;
        /**
         * The creation time of project.
         */
        createTime: string;
        /**
         * The service address of project.
         */
        endpoint: string;
        /**
         * The ID of project.
         */
        id: string;
        /**
         * The modification time of project.
         */
        modifyTime: string;
        /**
         * -The name of project.
         */
        project: string;
        /**
         * The service role authorized to the Intelligent Media Management service to access other cloud resources.
         */
        serviceRole: string;
        /**
         * The type of project.
         */
        type: string;
    }

}

export namespace imp {
    export interface AppTemplateConfigList {
        /**
         * Configuration item key. Valid values:
         */
        key: string;
        /**
         * Configuration item content.
         */
        value: string;
    }

    export interface GetAppTemplatesTemplate {
        /**
         * Apply template creator.
         */
        appTemplateCreator: string;
        /**
         * The first ID of the resource.
         */
        appTemplateId: string;
        /**
         * The name of the resource.
         */
        appTemplateName: string;
        /**
         * List of components.
         */
        componentLists: string[];
        /**
         * List of config.
         */
        configLists: outputs.imp.GetAppTemplatesTemplateConfigList[];
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * The ID of the App Template.
         */
        id: string;
        /**
         * Integration mode (Integrated SDK:paasSDK, Model Room: standardRoom).
         */
        integrationMode: string;
        /**
         * Application Template scenario, e-commerce business, classroom classroom.
         */
        scene: string;
        /**
         * SDK information.
         */
        sdkInfo: string;
        /**
         * Model room information.
         */
        standardRoomInfo: string;
        /**
         * Application template usage status.
         */
        status: string;
    }

    export interface GetAppTemplatesTemplateConfigList {
        /**
         * Config key.
         */
        key: string;
        /**
         * Config Value.
         */
        value: string;
    }

}

export namespace iot {
    export interface GetDeviceGroupsGroup {
        /**
         * The Group CreateTime.
         */
        createTime: string;
        /**
         * The Group Number of activated devices.
         */
        deviceActive: string;
        /**
         * The Group Total number of devices.
         */
        deviceCount: string;
        /**
         * The Group Number of online devices.
         */
        deviceOnline: string;
        /**
         * The Error_Message of the device group.
         */
        errorMessage: string;
        /**
         * The GroupDesc of the device group.
         */
        groupDesc: string;
        /**
         * The GroupId of the device group.
         */
        groupId: string;
        /**
         * The GroupName of the device group.
         */
        groupName: string;
        /**
         * The ID of the device group.
         */
        id: string;
        /**
         * Whether the call is successful.
         */
        success: boolean;
    }

}

export namespace kms {
    export interface GetAliasesAlias {
        /**
         * The unique identifier of the alias.
         */
        aliasName: string;
        /**
         * ID of the alias. The value is same as KMS alias_name.
         */
        id: string;
        /**
         * ID of the key.
         */
        keyId: string;
    }

    export interface GetKeyVersionsVersion {
        /**
         * Date and time when the key version was created (UTC time).
         */
        createTime: string;
        /**
         * (Removed from v1.124.4) It has been removed and using `createTime` instead.
         */
        creationDate: string;
        /**
         * ID of the KMS KeyVersion resource.
         */
        id: string;
        /**
         * The id of kms key.
         */
        keyId: string;
        /**
         * ID of the key version.
         */
        keyVersionId: string;
    }

    export interface GetKeysKey {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the key.
         */
        arn: string;
        automaticRotation: string;
        /**
         * Creation date of key.
         */
        creationDate: string;
        /**
         * The owner of the key.
         * * `automaticRotation` -(Available in 1.123.1+) Specifies whether to enable automatic key rotation.
         * * `keyId` -(Available in 1.123.1+)  ID of the key.
         * * `keySpec` -(Available in 1.123.1+)  The type of the CMK.
         * * `keyUsage` -(Available in 1.123.1+)  The usage of CMK.
         * * `lastRotationDate` -(Available in 1.123.1+)  The date and time the last rotation was performed.
         * * `materialExpireTime` -(Available in 1.123.1+)  The time and date the key material for the CMK expires.
         * * `nextRotationDate` -(Available in 1.123.1+)  The time the next rotation is scheduled for execution.
         * * `origin` -(Available in 1.123.1+)  The source of the key material for the CMK.
         * * `protectionLevel` -(Available in 1.123.1+)  The protection level of the CMK.
         * * `rotationInterval` -(Available in 1.123.1+)  The period of automatic key rotation.
         * * `primaryKeyVersion` -(Available in 1.123.1+)  The ID of the current primary key version of the symmetric CMK.
         */
        creator: string;
        /**
         * Deletion date of key.
         */
        deleteDate: string;
        /**
         * Description of the key.
         */
        description: string;
        /**
         * ID of the key.
         */
        id: string;
        keyId: string;
        keySpec: string;
        keyUsage: string;
        lastRotationDate: string;
        materialExpireTime: string;
        nextRotationDate: string;
        origin: string;
        primaryKeyVersion: string;
        protectionLevel: string;
        rotationInterval: string;
        /**
         * Filter the results by status of the KMS keys. Valid values: `Enabled`, `Disabled`, `PendingDeletion`.
         */
        status: string;
    }

    export interface GetSecretVersionsVersion {
        /**
         * The secret value. Secrets Manager decrypts the stored secret value in ciphertext and returns it. (Returned when `enableDetails` is true).
         */
        secretData: string;
        /**
         * The type of the secret value. (Returned when `enableDetails` is true).
         */
        secretDataType: string;
        /**
         * The name of the secret.
         */
        secretName: string;
        /**
         * The version number of the secret value.
         */
        versionId: string;
        /**
         * Stage labels that mark the secret version.
         */
        versionStages: string[];
    }

    export interface GetSecretsSecret {
        /**
         * (Available in 1.124.0+) A mapping of tags to assign to the resource.
         */
        arn: string;
        /**
         * (Available in 1.124.0+)  The description of the secret.
         */
        description: string;
        /**
         * (Available in 1.124.0+)  The ID of the KMS CMK that is used to encrypt the secret value.
         */
        encryptionKeyId: string;
        /**
         * ID of the Kms Secret. The value is same as KMS secret_name.
         */
        id: string;
        /**
         * Schedule deletion time.
         */
        plannedDeleteTime: string;
        /**
         * (Available in 1.124.0+)  The value of the secret that you want to create.
         */
        secretData: string;
        /**
         * (Available in 1.124.0+)  The type of the secret data value.
         */
        secretDataType: string;
        /**
         * Name of the KMS Secret.
         */
        secretName: string;
        /**
         * (Available in 1.124.0+)  The type of the secret.
         */
        secretType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * (Available in 1.124.0+)  The version number of the initial version.
         */
        versionId: string;
        /**
         * (Available in 1.124.0+)  The stage labels that mark the new secret version.
         */
        versionStages: string[];
    }

}

export namespace kvstore {
    export interface GetAccountsAccount {
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The privilege of account access database.
         */
        accountPrivilege: string;
        /**
         * Privilege type of account.
         */
        accountType: string;
        /**
         * The description of account.
         */
        description: string;
        /**
         * The ID of the Account.
         */
        id: string;
        /**
         * The Id of instance in which account belongs.
         */
        instanceId: string;
        /**
         * The status of account.
         */
        status: string;
    }

    export interface GetConnectionsConnection {
        /**
         * The connection string of the instance.
         */
        connectionString: string;
        /**
         * The network type of the instance.
         */
        dbInstanceNetType: string;
        /**
         * The expiration time of the classic network address.
         */
        expiredTime: string;
        id: string;
        instanceId: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The port number of the instance.
         */
        port: string;
        /**
         * The remaining validity period of the endpoint of the classic network.
         */
        upgradeable: string;
        /**
         * The ID of the VPC where the instance is deployed.
         */
        vpcId: string;
        /**
         * The ID of the instance. It is returned only when the value of the DBInstanceNetType parameter is 2 (indicating VPC).
         */
        vpcInstanceId: string;
        /**
         * The ID of the VSwitch.
         */
        vswitchId: string;
    }

    export interface GetInstanceClassesClass {
        /**
         * KVStore available instance class.
         */
        instanceClass: string;
        price: string;
    }

    export interface GetInstanceEnginesInstanceEngine {
        /**
         * Database type. Options are `Redis`, `Memcache`. Default to `Redis`.
         */
        engine: string;
        /**
         * Database version required by the user. Value options of Redis can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/60873.htm) `EngineVersion`. Value of Memcache should be empty.
         */
        engineVersion: string;
        /**
         * The Zone to launch the KVStore instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstance {
        /**
         * The type of the architecture. Valid values: `cluster`, `standard` and `SplitRW`.
         */
        architectureType: string;
        autoRenew: boolean;
        autoRenewPeriod: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `zoneId` instead.
         */
        availabilityZone: string;
        /**
         * Instance bandwidth limit. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * Capacity of the applied ApsaraDB for the instance. Unit: MB.
         */
        capacity: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `paymentType` instead.
         */
        chargeType: string;
        /**
         * The parameter configuration of the instance.
         */
        config: {[key: string]: any};
        /**
         * Instance connection domain (only Intranet access supported).
         */
        connectionDomain: string;
        /**
         * The connection mode of the instance.
         */
        connectionMode: string;
        /**
         * IIt has been deprecated from provider version 1.101.0 and `maxConnections` instead.
         */
        connections: number;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The name of the instance.
         */
        dbInstanceName: string;
        /**
         * The time when the instance was destroyed.
         */
        destroyTime: string;
        /**
         * Expiration time. Pay-As-You-Go instances are never expire.
         */
        endTime: string;
        /**
         * The engine version. Valid values: `2.8`, `4.0`, `5.0`, `6.0`.
         */
        engineVersion: string;
        /**
         * It has been deprecated from provider version 1.101.0 and `endTime` instead.
         */
        expireTime: string;
        /**
         * Indicates whether there was an order of renewal with configuration change that had not taken effect.
         */
        hasRenewChangeOrder: boolean;
        /**
         * The ID of the instance.
         */
        id: string;
        /**
         * Type of the applied ApsaraDB for Redis instance. For more information, see [Instance type table](https://www.alibabacloud.com/help/doc-detail/61135.htm).
         */
        instanceClass: string;
        instanceReleaseProtection: boolean;
        /**
         * The engine type of the KVStore DBInstance. Options are `Memcache`, and `Redis`. If no value is specified, all types are returned.
         */
        instanceType: string;
        /**
         * Indicates whether the instance is managed by Relational Database Service (RDS).
         */
        isRds: boolean;
        maintainEndTime: string;
        maintainStartTime: string;
        /**
         * Instance connection quantity limit. Unit: count.
         */
        maxConnections: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `dbInstanceName` instead.
         */
        name: string;
        /**
         * The type of the network. Valid values: `CLASSIC`, `VPC`.
         */
        networkType: string;
        /**
         * The node type of the instance.
         */
        nodeType: string;
        /**
         * The type of the package.
         */
        packageType: string;
        /**
         * The payment type. Valid values: `PostPaid`, `PrePaid`.
         */
        paymentType: string;
        /**
         * The service port of the instance.
         */
        port: number;
        /**
         * Private IP address of the instance.
         */
        privateIp: string;
        /**
         * The queries per second (QPS) supported by the instance.
         */
        qps: number;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * The logical ID of the replica instance.
         */
        replacateId: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The name of the instance.
         */
        searchKey: string;
        /**
         * (Optional, Available in 1.128.0+) The ID of the secondary zone to which you want to migrate the ApsaraDB for Redis instance.
         */
        secondaryZoneId: string;
        securityGroupId: string;
        securityIpGroupAttribute: string;
        securityIpGroupName: string;
        securityIps: string[];
        sslEnable: string;
        /**
         * The status of the KVStore DBInstance. Valid values: `Changing`, `CleaningUpExpiredData`, `Creating`, `Flushing`, `HASwitching`, `Inactive`, `MajorVersionUpgrading`, `Migrating`, `NetworkModifying`, `Normal`, `Rebooting`, `SSLModifying`, `Transforming`, `ZoneMigrating`.
         */
        status: string;
        /**
         * Query the instance bound to the tag. The format of the incoming value is `json` string, including `TagKey` and `TagValue`. `TagKey` cannot be null, and `TagValue` can be empty. Format example `{"key1":"value1"}`.
         */
        tags: {[key: string]: any};
        /**
         * The username of the instance.
         */
        userName: string;
        vpcAuthMode: string;
        /**
         * Connection port of the instance.
         */
        vpcCloudInstanceId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Used to retrieve instances belong to specified `vswitch` resources.
         */
        vswitchId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceParameter {
        name: string;
        value: string;
    }
}

export namespace lindorm {
    export interface GetInstancesInstance {
        /**
         * AutoRenew.
         */
        autoRenew: string;
        /**
         * The cold storage capacity of the instance. Unit: GB.
         */
        coldStorage: number;
        /**
         * The creation date of Instance.
         */
        createTime: string;
        /**
         * The deletion protection of instance.
         */
        deletionProection: boolean;
        /**
         * The disk type of instance. Valid values: `capacityCloudStorage`, `cloudEfficiency`, `cloudEssd`, `cloudSsd`.
         */
        diskCategory: string;
        /**
         * The usage of disk.
         */
        diskUsage: string;
        /**
         * The threshold of disk.
         */
        diskWarningThreshold: string;
        /**
         * The type of Instance engine .
         */
        engineType: number;
        /**
         * The expiration time of Instance.
         */
        expiredTime: string;
        /**
         * The count of file engine.
         */
        fileEngineNodeCount: number;
        /**
         * The specification of file engine. Valid values: `lindorm.c.xlarge`.
         */
        fileEngineSpecification: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The storage capacity of the instance. Unit: GB. For example, the value 50 indicates 50 GB.
         */
        instanceStorage: string;
        /**
         * The ip white list of instance.
         */
        ipWhiteLists: string[];
        /**
         * The count of lindorm tunnel service.
         */
        ltsNodeCount: number;
        /**
         * The specification of lindorm tunnel service. Valid values: `lindorm.g.2xlarge`, `lindorm.g.xlarge`.
         */
        ltsNodeSpecification: string;
        /**
         * Instance network type, enumerative.VPC.
         */
        networkType: string;
        /**
         * The billing method. Valid values: `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * The count of phoenix.
         */
        phoenixNodeCount: number;
        /**
         * The specification of phoenix. Valid values: `lindorm.c.2xlarge`, `lindorm.c.4xlarge`, `lindorm.c.8xlarge`, `lindorm.c.xlarge`, `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        phoenixNodeSpecification: string;
        /**
         * The owner id of resource.
         */
        resourceOwnerId: string;
        /**
         * The count of search engine.
         */
        searchEngineNodeCount: number;
        /**
         * The specification of search engine. Valid values: `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        searchEngineSpecification: string;
        /**
         * The service type of Instance, Valid values:  `lindorm`, `serverlessLindorm`, `lindormStandalone`.
         */
        serviceType: string;
        /**
         * The status of Instance, enumerative: Valid values: `ACTIVATION`, `DELETED`, `CREATING`, `CLASS_CHANGING`, `LOCKED`, `INSTANCE_LEVEL_MODIFY`, `NET_MODIFYING`, `RESIZING`, `RESTARTING`, `MINOR_VERSION_TRANSING`.
         */
        status: string;
        /**
         * The count of table engine.
         */
        tableEngineNodeCount: number;
        /**
         * The specification of  table engine. Valid values: `lindorm.c.2xlarge`, `lindorm.c.4xlarge`, `lindorm.c.8xlarge`, `lindorm.c.xlarge`, `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        tableEngineSpecification: string;
        /**
         * The count of time series engine.
         */
        timeSeriesEngineNodeCount: number;
        /**
         * The specification of time series engine. Valid values: `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        timeSeriresEngineSpecification: string;
        /**
         * The ID of the virtual private cloud (VPC) that is connected to the instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

}

export namespace log {
    export interface AlertNotificationList {
        /**
         * Notice content of alarm.
         */
        content: string;
        /**
         * Email address list.
         */
        emailLists?: string[];
        /**
         * SMS sending mobile number.
         */
        mobileLists?: string[];
        /**
         * Request address.
         */
        serviceUri?: string;
        /**
         * Notification type. support Email, SMS, DingTalk, MessageCenter.
         */
        type: string;
    }

    export interface AlertQueryList {
        /**
         * chart title
         */
        chartTitle: string;
        /**
         * end time. example: 20s.
         */
        end: string;
        /**
         * Query logstore
         */
        logstore: string;
        /**
         * query corresponding to chart. example: * AND aliyun.
         */
        query: string;
        /**
         * begin time. example: -60s.
         */
        start: string;
        /**
         * default Custom. No need to configure this parameter.
         */
        timeSpanType?: string;
    }

    export interface EtlEtlSink {
        /**
         * Delivery target logstore access key id.
         */
        accessKeyId?: string;
        /**
         * Delivery target logstore access key secret.
         */
        accessKeySecret?: string;
        /**
         * Delivery target logstore region.
         */
        endpoint: string;
        /**
         * An KMS encrypts access key id used to a log etl job. If the `accessKeyId` is filled in, this field will be ignored.
         */
        kmsEncryptedAccessKeyId?: string;
        /**
         * An KMS encrypts access key secret used to a log etl job. If the `accessKeySecret` is filled in, this field will be ignored.
         */
        kmsEncryptedAccessKeySecret?: string;
        /**
         * Delivery target logstore.
         */
        logstore: string;
        /**
         * Delivery target name.
         */
        name: string;
        /**
         * The project where the target logstore is delivered.
         */
        project: string;
        /**
         * Sts role info under delivery target logstore. `roleArn` and `(access_key_id, access_key_secret)` fill in at most one. If you do not fill in both, then you must fill in `(kms_encrypted_access_key_id, kms_encrypted_access_key_secret, kms_encryption_access_key_id_context, kms_encryption_access_key_secret_context)` to use KMS to get the key pair.
         */
        roleArn?: string;
        /**
         * ETL sinks type, the default value is AliyunLOG.
         */
        type?: string;
    }

    export interface GetProjectsProject {
        /**
         * The description of the project.
         */
        description: string;
        /**
         * The ID of the project.
         */
        id: string;
        /**
         * The last modify time of project.
         */
        lastModifyTime: string;
        /**
         * The owner of project.
         */
        owner: string;
        /**
         * The name of the project.
         */
        projectName: string;
        /**
         * The region of project.
         */
        region: string;
        /**
         * The status of project.
         */
        status: string;
    }

    export interface GetStoresStore {
        /**
         * The ID of the store.
         */
        id: string;
        /**
         * The name of the store.
         */
        storeName: string;
    }

    export interface OssShipperParquetConfig {
        name: string;
        type: string;
    }

    export interface StoreEncryptConf {
        /**
         * enable encryption. Default `false`
         */
        enable?: boolean;
        /**
         * Supported encryption type, only supports `default(AES)`,` m4`
         */
        encryptType?: string;
        /**
         * User bring your own key (BYOK) encryption [Refer to details](https://www.alibabacloud.com/help/zh/doc-detail/187853.htm), the format is as follows:
         */
        userCmkInfo?: outputs.log.StoreEncryptConfUserCmkInfo;
    }

    export interface StoreEncryptConfUserCmkInfo {
        /**
         * role arn.
         */
        arn: string;
        /**
         * User master key id.
         */
        cmkKeyId: string;
        /**
         * Region id where the  user master key id is located.
         */
        regionId: string;
    }

    export interface StoreIndexFieldSearch {
        /**
         * The alias of one field.
         */
        alias?: string;
        /**
         * Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        caseSensitive?: boolean;
        /**
         * Whether to enable field analytics. Default to true.
         */
        enableAnalytics?: boolean;
        /**
         * Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        includeChinese?: boolean;
        /**
         * Use nested index when type is json
         */
        jsonKeys?: outputs.log.StoreIndexFieldSearchJsonKey[];
        /**
         * When using the jsonKeys field, this field is required.
         */
        name: string;
        /**
         * The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
         */
        token?: string;
        /**
         * The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
         */
        type?: string;
    }

    export interface StoreIndexFieldSearchJsonKey {
        /**
         * The alias of one field.
         */
        alias?: string;
        /**
         * Whether to enable statistics. default to true.
         */
        docValue?: boolean;
        /**
         * When using the jsonKeys field, this field is required.
         */
        name: string;
        /**
         * The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
         */
        type?: string;
    }

    export interface StoreIndexFullText {
        /**
         * Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        caseSensitive?: boolean;
        /**
         * Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        includeChinese?: boolean;
        /**
         * The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
         */
        token?: string;
    }

    export interface StoreShard {
        beginKey: string;
        endKey: string;
        /**
         * The ID of the log project. It formats of `<project>:<name>`.
         */
        id: number;
        status: string;
    }

}

export namespace marketplace {
    export interface GetProductProduct {
        /**
         * The code of the product.
         */
        code: string;
        /**
         * The description of the product.
         */
        description: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * A list of one element containing sku attributes of an object. Each element contains the following attributes:
         */
        skuses: outputs.marketplace.GetProductProductSkus[];
    }

    export interface GetProductProductSkus {
        /**
         * The list of custom ECS images, Each element contains the following attributes:
         */
        images: outputs.marketplace.GetProductProductSkusImage[];
        /**
         * The list of package version details of this product sku, Each element contains the following attributes:
         */
        packageVersions: outputs.marketplace.GetProductProductSkusPackageVersion[];
        /**
         * The sku code of this product sku.
         */
        skuCode: string;
        /**
         * The sku name of this product sku.
         */
        skuName: string;
    }

    export interface GetProductProductSkusImage {
        /**
         * The Ecs image id.
         */
        imageId: string;
        /**
         * The Ecs image display name.
         */
        imageName: string;
        /**
         * The Ecs image region.
         */
        regionId: string;
    }

    export interface GetProductProductSkusPackageVersion {
        /**
         * The package name of this product sku package.
         */
        packageName: string;
        /**
         * The package version of this product sku package. Currently, the API products can return package_version, but others can not for ensure.
         */
        packageVersion: string;
    }

    export interface GetProductsProduct {
        /**
         * The Category ID of products. For more information, see [DescribeProducts](https://help.aliyun.com/document_detail/89834.htm).
         */
        categoryId: number;
        /**
         * The code of the product.
         */
        code: string;
        /**
         * The delivery date of the product.
         */
        deliveryDate: string;
        /**
         * The delivery way of the product.
         */
        deliveryWay: string;
        /**
         * The image URL of the product.
         */
        imageUrl: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * The operation system of the product.
         */
        operationSystem: string;
        /**
         * The rating information of the product.
         */
        score: string;
        /**
         * The short description of the product.
         */
        shortDescription: string;
        /**
         * The suggested price of the product.
         */
        suggestedPrice: string;
        /**
         * The supplier id of the product.
         */
        supplierId: number;
        /**
         * The supplier name of the product.
         */
        supplierName: string;
        /**
         * The tags of the product.
         */
        tags: string;
        /**
         * The detail page URL of the product.
         */
        targetUrl: string;
        /**
         * The warranty date of the product.
         */
        warrantyDate: string;
    }

}

export namespace mhub {
    export interface GetAppsApp {
        /**
         * Application AppKey, which uniquely identifies an application when requested by the interface
         */
        appKey: string;
        /**
         * The Name of the App.
         */
        appName: string;
        /**
         * iOS application ID. Required when creating an iOS app. **NOTE:** Either `bundleId` or `packageName` must be set.
         */
        bundleId: string;
        /**
         * The CreateTime of the App.
         */
        createTime: string;
        /**
         * Base64 string of picture.
         */
        encodedIcon: string;
        /**
         * The ID of the App.
         */
        id: string;
        /**
         * The Industry ID of the app. For information about Industry and how to use it, MHUB[Industry](https://help.aliyun.com/document_detail/201638.html).
         */
        industryId: string;
        /**
         * Android App package name.  **NOTE:** Either `bundleId` or `packageName` must be set.
         */
        packageName: string;
        /**
         * The ID of the Product.
         */
        productId: string;
        /**
         * The type of the App. Valid values: `Android` and `iOS`.
         */
        type: string;
    }

    export interface GetProductsProduct {
        /**
         * The ID of the Product.
         */
        id: string;
        /**
         * The ID of the Product.
         */
        productId: string;
        /**
         * The name of the Product.
         */
        productName: string;
    }

}

export namespace mns {
    export interface GetQueuesQueue {
        /**
         * This attribute defines the length of time, in seconds, after which every message sent to the queue is dequeued.
         */
        delaySeconds: number;
        /**
         * The id of the queue, The value is set to `name`.
         */
        id: string;
        /**
         * This indicates the maximum length, in bytes, of any message body sent to the queue.
         */
        maximumMessageSize: number;
        /**
         * Messages are deleted from the queue after a specified length of time, whether they have been activated or not. This attribute defines the viability period, in seconds, for every message in the queue.
         */
        messageRetentionPeriod: number;
        /**
         * The name of the queue
         */
        name: string;
        /**
         * Long polling is measured in seconds. When this attribute is set to 0, long polling is disabled. When it is not set to 0, long polling is enabled and message dequeue requests will be processed only when valid messages are received or when long polling times out.
         */
        pollingWaitSeconds: number;
        /**
         * Dequeued messages change from active (visible) status to inactive (invisible) status. This attribute defines the length of time, in seconds, that messages remain invisible. Messages return to active status after the set period.
         */
        visibilityTimeouts: number;
    }

    export interface GetTopicSubscriptionsSubscription {
        /**
         * Describe the terminal address of the message received in this subscription.
         * * `filterTag`- A string to filter resulting messages of the topic by their message tag.
         */
        endpoint: string;
        filterTag: string;
        /**
         * The ID of the topic subscription. The value is set to `name`.
         */
        id: string;
        /**
         * The name of the subscription.
         * * `topicName`- The topic which The subscription belongs to was named with the name.
         */
        name: string;
        /**
         * The NotifyContentFormat attribute of Subscription. This attribute specifies the content format of the messages pushed to users.
         */
        notifyContentFormat: string;
        /**
         * The NotifyStrategy attribute of Subscription. This attribute specifies the retry strategy when message sending fails.
         */
        notifyStrategy: string;
        /**
         * Two topics on a single account in the same region cannot have the same name. A topic name must start with an English letter or a digit, and can contain English letters, digits, and hyphens, with the length not exceeding 256 characters.
         */
        topicName: string;
    }

    export interface GetTopicsTopic {
        /**
         * The id of the topic. The value is set to `name`.
         */
        id: string;
        /**
         * Whether to enable logging.
         */
        loggingEnabled: boolean;
        /**
         * This indicates the maximum length, in bytes, of any message body sent to the topic.
         */
        maximumMessageSize: number;
        /**
         * The name of the topic.
         */
        name: string;
    }

}

export namespace mongodb {
    export interface GetAccountsAccount {
        /**
         * The description of the account.
         */
        accountDescription: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The role of the account. Valid values: `db`, `cs`, `mongos`, `logic`, `normal`.
         */
        characterType: string;
        /**
         * The ID of the Account. The value formats as `<instance_id>:<account_name>`.
         */
        id: string;
        /**
         * The id of the instance to which the account belongs.
         */
        instanceId: string;
        /**
         * The status of the account. Valid values: `Unavailable`, `Available`.
         */
        status: string;
    }

    export interface GetAuditPoliciesPolicy {
        /**
         * The status of the log audit feature.
         */
        auditStatus: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The ID of the Audit Policy.
         */
        id: string;
    }

    export interface GetInstancesInstance {
        /**
         * Instance availability zone.
         */
        availabilityZone: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        chargeType: string;
        /**
         * Creation time of the instance in RFC3339 format.
         */
        creationTime: string;
        /**
         * Database engine type. Supported option is `MongoDB`.
         */
        engine: string;
        /**
         * Database engine version.
         */
        engineVersion: string;
        /**
         * Expiration time in RFC3339 format. Pay-As-You-Go instances are never expire.
         */
        expirationTime: string;
        /**
         * The ID of the MongoDB instance.
         */
        id: string;
        /**
         * Sizing of the instance to be queried.
         */
        instanceClass: string;
        /**
         * Type of the instance to be queried. If it is set to `sharding`, the sharded cluster instances are listed. If it is set to `replicate`, replica set instances are listed. Default value `replicate`.
         */
        instanceType: string;
        /**
         * Lock status of the instance.
         */
        lockMode: string;
        /**
         * Array composed of Mongos.
         */
        mongos: outputs.mongodb.GetInstancesInstanceMongo[];
        /**
         * The name of the MongoDB instance.
         */
        name: string;
        /**
         * Classic network or VPC.
         */
        networkType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Replication factor corresponds to number of nodes. Optional values are `1` for single node and `3` for three nodes replica set.
         */
        replication: string;
        /**
         * Array composed of shards.
         */
        shards: outputs.mongodb.GetInstancesInstanceShard[];
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * Shard disk.
         */
        storage: number;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetInstancesInstanceMongo {
        /**
         * Shard instance specification.
         */
        class: string;
        /**
         * Shard instance description.
         */
        description: string;
        /**
         * Shard instance ID.
         */
        nodeId: string;
    }

    export interface GetInstancesInstanceShard {
        /**
         * Shard instance specification.
         */
        class: string;
        /**
         * Shard instance description.
         */
        description: string;
        /**
         * Shard instance ID.
         */
        nodeId: string;
        /**
         * Shard disk.
         */
        storage: number;
    }

    export interface GetServerlessInstancesInstance {
        /**
         * The read/write throughput consumed by the instance.
         */
        capacityUnit: number;
        /**
         * The db instance class.
         */
        dbInstanceClass: string;
        /**
         * The db instance description.
         */
        dbInstanceDescription: string;
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The db instance release protection.
         */
        dbInstanceReleaseProtection: boolean;
        /**
         * The db instance storage.
         */
        dbInstanceStorage: number;
        /**
         * The database engine of the instance.
         */
        engine: string;
        /**
         * The database version number. Valid values: `4.2`.
         */
        engineVersion: string;
        /**
         * The time when the subscription instance expires. The time is in the `yyyy-MM-ddTHH:mmZ` format. The time is displayed in UTC.
         */
        expireTime: string;
        /**
         * The ID of the Serverless Instance.
         */
        id: string;
        /**
         * Indicates the type of the instance. Valid values: `0`: physical machine. `1`: ECS. `2`: DOCKER. `18`: k8s new architecture instance.
         */
        kindCode: string;
        /**
         * The locked status of the instance.
         */
        lockMode: string;
        /**
         * The start time of the maintenance window. The time is in the `HH:mmZ` format. The time is displayed in UTC.
         */
        maintainEndTime: string;
        /**
         * The end time of the maintenance window. The time is in the `HH:mmZ` format. The time is displayed in UTC.
         */
        maintainStartTime: string;
        /**
         * Instance maximum connections.
         */
        maxConnections: number;
        /**
         * The maximum IOPS of the instance.
         */
        maxIops: number;
        /**
         * The network type of the instance.
         */
        networkType: string;
        /**
         * The Payment type of the instance.
         */
        paymentType: string;
        /**
         * The access protocol type of the instance. Valid values: `mongodb`, `dynamodb`.
         */
        protocolType: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The security ip list.
         */
        securityIpGroups: outputs.mongodb.GetServerlessInstancesInstanceSecurityIpGroup[];
        /**
         * The status of the instance.
         */
        status: string;
        /**
         * The storage engine used by the instance.
         */
        storageEngine: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * Intranet secret free access mode.
         */
        vpcAuthMode: string;
        /**
         * The ID of the VPC network.
         */
        vpcId: string;
        /**
         * The id of the vswitch.
         */
        vswitchId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

    export interface GetServerlessInstancesInstanceSecurityIpGroup {
        /**
         * The attribute of the IP whitelist. This parameter is empty by default.
         */
        securityIpGroupAttribute: string;
        /**
         * The name of the IP whitelist.
         */
        securityIpGroupName: string;
        /**
         * The IP addresses in the whitelist.
         */
        securityIpList: string;
    }

    export interface GetShardingNetworkPublicAddressesAddress {
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The remaining duration of the classic network address. Unit: `seconds`.
         */
        expiredTime: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The endpoint of the instance.
         */
        networkAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The ID of the `mongos`, `shard`, or `Configserver` node in the sharded cluster instance.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The port number.
         */
        port: string;
        /**
         * The role of the node.
         */
        role: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vSwitch ID of the VPC.
         */
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceReplicaSet {
        /**
         * The connection address of the node.
         */
        connectionDomain: string;
        /**
         * The connection port of the node.
         */
        connectionPort: string;
        /**
         * The network type of the node. Valid values: `Classic`,`VPC`.
         */
        networkType: string;
        /**
         * The role of the node. Valid values: `Primary`,`Secondary`.
         */
        replicaSetRole: string;
        /**
         * VPC instance ID.
         */
        vpcCloudInstanceId: string;
        /**
         * The private network ID of the node.
         */
        vpcId: string;
        /**
         * The virtual switch ID to launch DB instances in one VPC.
         */
        vswitchId: string;
    }

    export interface ServerlessInstanceSecurityIpGroup {
        /**
         * The attribute of the IP whitelist. This parameter is empty by default.
         */
        securityIpGroupAttribute?: string;
        /**
         * The name of the IP whitelist.
         */
        securityIpGroupName?: string;
        /**
         * The IP addresses in the whitelist.
         */
        securityIpList?: string;
    }

    export interface ShardingInstanceConfigServerList {
        /**
         * The connection address of the Config Server node.
         */
        connectString: string;
        /**
         * The max connections of the Config Server node.
         */
        maxConnections: number;
        /**
         * The maximum IOPS of the Config Server node.
         */
        maxIops: number;
        /**
         * -(Required) Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The description of the Config Server node.
         */
        nodeDescription: string;
        /**
         * The ID of the Config Server node.
         */
        nodeId: string;
        /**
         * - Custom storage space; value range: [10, 1,000]
         * - 10-GB increments. Unit: GB.
         */
        nodeStorage: number;
        /**
         * The connection port of the Config Server node.
         */
        port: number;
    }

    export interface ShardingInstanceMongoList {
        /**
         * The connection address of the Config Server node.
         */
        connectString: string;
        /**
         * -(Required) Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The ID of the Config Server node.
         */
        nodeId: string;
        /**
         * The connection port of the Config Server node.
         */
        port: number;
    }

    export interface ShardingInstanceShardList {
        /**
         * -(Required) Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The ID of the Config Server node.
         */
        nodeId: string;
        /**
         * - Custom storage space; value range: [10, 1,000]
         * - 10-GB increments. Unit: GB.
         */
        nodeStorage: number;
        /**
         * The number of read-only nodes in shard node. Valid values: 0 to 5. Default value: 0.
         */
        readonlyReplicas: number;
    }

    export interface ShardingNetworkPublicAddressNetworkAddress {
        /**
         * The remaining duration of the classic network address. Unit: `seconds`.
         */
        expiredTime: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The endpoint of the instance.
         */
        networkAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The ID of the `mongos`, `shard`, or `Configserver` node in the sharded cluster instance.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The port number.
         */
        port: string;
        /**
         * The role of the node.
         */
        role: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vSwitch ID of the VPC.
         */
        vswitchId: string;
    }
}

export namespace mse {
    export interface GetClustersCluster {
        /**
         * The id of acl.
         */
        aclId: string;
        /**
         * The version of app.
         */
        appVersion: string;
        /**
         * ID of the MSE Cluster.
         */
        clusterId: string;
        /**
         * ID of the OOS Executions.
         */
        clusterName: string;
        /**
         * The type of MSE Cluster.
         */
        clusterType: string;
        /**
         * The num of cpu.
         */
        cpu: number;
        /**
         * The health status of MSE Cluster.
         */
        healthStatus: string;
        /**
         * ID of the MSE Cluster.
         */
        id: string;
        /**
         * Time-consuming to create.
         */
        initCostTime: number;
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * ID of the MSE Cluster.
         */
        instanceId: string;
        /**
         * The list of instances.
         */
        instanceModels: outputs.mse.GetClustersClusterInstanceModel[];
        /**
         * The address of public network.
         */
        internetAddress: string;
        /**
         * The domain of public network.
         */
        internetDomain: string;
        /**
         * The port of public network.
         */
        internetPort: string;
        /**
         * The address of private network.
         */
        intranetAddress: string;
        /**
         * The domain of private network.
         */
        intranetDomain: string;
        /**
         * The port of private network.
         */
        intranetPort: string;
        /**
         * The memory size.
         */
        memoryCapacity: number;
        /**
         * The type of payment.
         */
        payInfo: string;
        /**
         * The public network bandwidth.
         */
        pubNetworkFlow: string;
        /**
         * The status of MSE Cluster. Valid: `DESTROY_FAILED`, `DESTROY_ING`, `DESTROY_SUCCESS`, `INIT_FAILED`, `INIT_ING`, `INIT_SUCCESS`, `INIT_TIME_OUT`, `RESTART_FAILED`, `RESTART_ING`, `RESTART_SUCCESS`, `SCALE_FAILED`, `SCALE_ING`, `SCALE_SUCCESS`
         */
        status: string;
    }

    export interface GetClustersClusterInstanceModel {
        /**
         * The health status of MSE Cluster.
         */
        healthStatus: string;
        instanceType: string;
        internetIp: string;
        ip: string;
        podName: string;
        role: string;
        singleTunnelVip: string;
        vip: string;
    }

}

export namespace nas {
    export interface GetAccessGroupsGroup {
        /**
         * The name of access group.
         */
        accessGroupName: string;
        /**
         * Filter results by a specific AccessGroupType.
         */
        accessGroupType: string;
        /**
         * Filter results by a specific Description.
         */
        description: string;
        /**
         * This ID of this AccessGroup. It is formatted to ``<access_group_id>:<file_system_type>``. Before version 1.95.0, the value is `accessGroupName`.
         */
        id: string;
        /**
         * MountTargetCount block of the AccessGroup
         */
        mountTargetCount: number;
        /**
         * RuleCount of the AccessGroup.
         */
        ruleCount: number;
        /**
         * Field `type` has been deprecated from version 1.95.0. Use `accessGroupType` instead.
         */
        type: string;
    }

    export interface GetAccessRulesRule {
        /**
         * AccessRuleId of the AccessRule.
         */
        accessRuleId: string;
        /**
         * Priority of the AccessRule.
         */
        priority: number;
        /**
         * Filter results by a specific RWAccess.
         */
        rwAccess: string;
        /**
         * Filter results by a specific SourceCidrIp.
         */
        sourceCidrIp: string;
        /**
         * Filter results by a specific UserAccess.
         */
        userAccess: string;
    }

    export interface GetFileSystemsSystem {
        /**
         * (Optional, Available in v1.140.0+) The capacity of the file system.
         */
        capacity: number;
        /**
         * Time of creation.
         */
        createTime: string;
        /**
         * Description of the FileSystem.
         */
        description: string;
        /**
         * (Optional, Available in v1.121.2+) Whether the file system is encrypted. 
         * * Valid values:
         * * `0`: The file system is not encrypted.
         * * `1`: The file system is encrypted with a managed secret key.
         * * `2`: User management key.
         */
        encryptType: number;
        /**
         * The type of the file system.
         * Valid values:
         * `standard` (Default),
         * `extreme`.
         */
        fileSystemType: string;
        /**
         * ID of the FileSystem.
         */
        id: string;
        /**
         * (Optional, Available in v1.140.0+) The id of the KMS key.
         */
        kmsKeyId: string;
        /**
         * MeteredSize of the FileSystem.
         */
        meteredSize: number;
        /**
         * The protocol type of the file system.
         * Valid values:
         * `NFS`,
         * `SMB` (Available when the `fileSystemType` is `standard`).
         */
        protocolType: string;
        /**
         * ID of the region where the FileSystem is located.
         */
        regionId: string;
        /**
         * The storage type of the file system.
         * * Valid values:
         */
        storageType: string;
        /**
         * (Optional, Available in v1.140.0+) The id of the zone. Each region consists of multiple isolated locations known as zones. Each zone has an independent power supply and network.
         */
        zoneId: string;
    }

    export interface GetMountTargetsTarget {
        /**
         * Filter results by a specific AccessGroupName.
         */
        accessGroupName: string;
        /**
         * ID of the MountTargetDomain.
         */
        id: string;
        /**
         * Field `mountTargetDomain` has been deprecated from provider version 1.53.0. New field `ids` replaces it.
         */
        mountTargetDomain: string;
        /**
         * Filter results by a specific NetworkType.
         */
        networkType: string;
        /**
         * Filter results by the status of mount target. Valid values: `Active`, `Inactive` and `Pending`.
         */
        status: string;
        /**
         * Field `type` has been deprecated from provider version 1.95.0. New field `networkType` replaces it.
         */
        type: string;
        /**
         * Filter results by a specific VpcId.
         */
        vpcId: string;
        /**
         * Filter results by a specific VSwitchId.
         */
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * A list of instance type information collection
         */
        instanceTypes: outputs.nas.GetZonesZoneInstanceType[];
        /**
         * String to filter results by zone id.
         */
        zoneId: string;
    }

    export interface GetZonesZoneInstanceType {
        /**
         * File transfer protocol type. Valid values:
         */
        protocolType: string;
        /**
         * The storage type of the nas zones. Valid values:
         */
        storageType: string;
    }

}

export namespace oos {
    export interface GetApplicationGroupsGroup {
        /**
         * The name of the Application group.
         */
        applicationGroupName: string;
        /**
         * The name of the Application.
         */
        applicationName: string;
        /**
         * The ID of the cloud monitor group.
         */
        cmsGroupId: string;
        /**
         * The Creation time of the resource.
         */
        createTime: string;
        /**
         * The region ID of the deployment.
         */
        deployRegionId: string;
        /**
         * Application group description information.
         */
        description: string;
        /**
         * The ID of the Application Group. Its value is same as Queue Name.
         */
        id: string;
        /**
         * Label key.
         */
        importTagKey: string;
        /**
         * Label value.
         */
        importTagValue: string;
        /**
         * The Update time of the resource.
         */
        updateTime: string;
    }

    export interface GetApplicationsApplication {
        /**
         * The name of the application.
         */
        applicationName: string;
        /**
         * The Created time of the application.
         */
        createTime: string;
        /**
         * Application group description information.
         */
        description: string;
        /**
         * The ID of the Application. The value is formate as <application_name>.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The Updated time of the application.
         */
        updateTime: string;
    }

    export interface GetExecutionsExecution {
        /**
         * The category of template. Valid: `AlarmTrigger`, `EventTrigger`, `Other` and `TimerTrigger`.
         */
        category: string;
        /**
         * The counters of OOS Execution.
         */
        counters: string;
        /**
         * The time when the execution was created.
         */
        createDate: string;
        /**
         * The time when the execution was ended.
         */
        endDate: string;
        /**
         * The user who execute the template.
         */
        executedBy: string;
        /**
         * ID of the OOS Executions.
         */
        executionId: string;
        /**
         * ID of the OOS Executions.
         */
        id: string;
        /**
         * Whether to include subtasks.
         */
        isParent: boolean;
        /**
         * The mode of OOS Execution. Valid: `Automatic`, `Debug`.
         */
        mode: string;
        /**
         * The outputs of OOS Executions.
         */
        outputs: string;
        /**
         * The parameters required by the template
         */
        parameters: string;
        /**
         * The id of parent OOS Execution.
         */
        parentExecutionId: string;
        /**
         * The role that executes the current template.
         */
        ramRole: string;
        /**
         * The time when the template was started.
         */
        startDate: string;
        /**
         * The Status of OOS Execution. Valid: `Cancelled`, `Failed`, `Queued`, `Running`, `Started`, `Success`, `Waiting`.
         */
        status: string;
        /**
         * The message of status.
         */
        statusMessage: string;
        /**
         * The reason of status.
         */
        statusReason: string;
        /**
         * The id of execution template.
         */
        templateId: string;
        /**
         * The name of execution template.
         */
        templateName: string;
        /**
         * The version of execution template.
         */
        templateVersion: string;
        /**
         * The time when the template was updated.
         */
        updateDate: string;
    }

    export interface GetParametersParameter {
        /**
         * The constraints of the common parameter.
         */
        constraints: string;
        /**
         * The time when the common parameter was created.
         */
        createTime: string;
        /**
         * The user who created the common parameter.
         */
        createdBy: string;
        /**
         * The description of the common parameter.
         */
        description: string;
        /**
         * The ID of the Parameter. Its value is same as `parameterName`.
         */
        id: string;
        /**
         * The ID of the common parameter.
         */
        parameterId: string;
        /**
         * The name of the common parameter.
         */
        parameterName: string;
        /**
         * The version number of the common parameter.
         */
        parameterVersion: number;
        /**
         * The ID of the Resource Group.
         */
        resourceGroupId: string;
        /**
         * The share type of the common parameter.
         */
        shareType: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The data type of the common parameter.
         */
        type: string;
        /**
         * The user who updated the common parameter.
         */
        updatedBy: string;
        /**
         * The time when the common parameter was updated.
         */
        updatedDate: string;
        /**
         * The value of the common parameter.
         */
        value: string;
    }

    export interface GetPatchBaselinesBaseline {
        /**
         * Accept the rules.
         */
        approvalRules: string;
        /**
         * The create time of patch baselines.
         */
        createTime: string;
        /**
         * The user who created the patch baselines.
         */
        createdBy: string;
        /**
         * Patches baseline description information.
         */
        description: string;
        /**
         * The ID of the Patch Baseline. Its value is same as `patchBaselineName`.
         */
        id: string;
        /**
         * Whether it is the default patch baseline.
         */
        isDefault: boolean;
        /**
         * Operating system type.
         */
        operationSystem: string;
        /**
         * Patch baseline ID.
         */
        patchBaselineId: string;
        /**
         * The name of the patch baseline.
         */
        patchBaselineName: string;
        /**
         * Patch baseline sharing type.
         */
        shareType: string;
        /**
         * The user who updated the patch baselines.
         */
        updatedBy: string;
        /**
         * The update time of patch baselines.
         */
        updatedDate: string;
    }

    export interface GetSecretParametersParameter {
        /**
         * The constraints of the encryption parameter.
         */
        constraints: string;
        /**
         * The time when the encryption parameter was created.
         */
        createTime: string;
        /**
         * The user who created the encryption parameter.
         */
        createdBy: string;
        /**
         * The description of the encryption parameter.
         */
        description: string;
        /**
         * The ID of the Secret Parameter.
         */
        id: string;
        /**
         * KeyId of KMS used for encryption.
         */
        keyId: string;
        /**
         * The version number of the encryption parameter.
         */
        parameterVersion: number;
        /**
         * The ID of the Resource Group.
         */
        resourceGroupId: string;
        /**
         * The ID of the encryption parameter.
         */
        secretParameterId: string;
        /**
         * The name of the encryption parameter.
         */
        secretParameterName: string;
        /**
         * The share type of the encryption parameter.
         */
        shareType: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The data type of the encryption parameter.
         */
        type: string;
        /**
         * The user who updated the encryption parameter.
         */
        updatedBy: string;
        /**
         * The time when the encryption parameter was updated.
         */
        updatedDate: string;
    }

    export interface GetStateConfigurationsConfiguration {
        /**
         * The configuration mode.
         */
        configureMode: string;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The ID of the State Configuration.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The schedule expression.
         */
        scheduleExpression: string;
        /**
         * The schedule type.
         */
        scheduleType: string;
        /**
         * The ID of the final state configuration.
         */
        stateConfigurationId: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The target resource.
         */
        targets: string;
        /**
         * The ID of the template.
         */
        templateId: string;
        /**
         * The name of the template.
         */
        templateName: string;
        /**
         * The version of the template.
         */
        templateVersion: string;
        /**
         * The time when the configuration is updated.
         */
        updateTime: string;
    }

    export interface GetTemplatesTemplate {
        /**
         * The category of template.
         */
        category: string;
        /**
         * The creator of the template.
         */
        createdBy: string;
        /**
         * The template whose creation time is less than or equal to the specified time. The format is: YYYY-MM-DDThh:mm::ssZ.
         */
        createdDate: string;
        /**
         * Description of the OOS Template.
         */
        description: string;
        /**
         * Is it triggered successfully.
         */
        hasTrigger: boolean;
        /**
         * ID of the OOS Template. The value is same as template_name.
         */
        id: string;
        /**
         * The sharing type of the template. Valid values: `Private`, `Public`.
         */
        shareType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The format of the template. Valid values: `JSON`, `YAML`.
         */
        templateFormat: string;
        /**
         * ID of the OOS Template resource.
         */
        templateId: string;
        /**
         * Name of the OOS Template.
         */
        templateName: string;
        /**
         * The type of OOS Template.
         */
        templateType: string;
        /**
         * Version of the OOS Template.
         */
        templateVersion: string;
        /**
         * The user who updated the template.
         */
        updatedBy: string;
        /**
         * The time when the template was updated.
         */
        updatedDate: string;
    }

}

export namespace opensearch {
    export interface AppGroupOrder {
        /**
         * Whether to renew automatically. It only takes effect when the parameter paymentType takes the value `Subscription`.
         */
        autoRenew?: boolean;
        /**
         * Order cycle. The minimum value is not less than 0.
         */
        duration?: number;
        /**
         * Order cycle unit. Valid values: `Year` and `Month`.
         */
        pricingCycle?: string;
    }

    export interface AppGroupQuota {
        /**
         * Computing resources. Unit: LCU.
         */
        computeResource: number;
        /**
         * Storage Size. Unit: GB.
         */
        docSize: number;
        /**
         * Search request. Unit: times/second.
         */
        qps?: number;
        /**
         * Specification. Valid values: 
         * * `opensearch.share.junior`: Entry-level.
         * * `opensearch.share.common`: Shared universal.
         * * `opensearch.share.compute`: Shared computing.
         * * `opensearch.share.storage`: Shared storage type.
         * * `opensearch.private.common`: Exclusive universal type.
         * * `opensearch.private.compute`: Exclusive computing type.
         * * `opensearch.private.storage`: Exclusive storage type
         */
        spec: string;
    }

    export interface GetAppGroupsGroup {
        /**
         * The ID of the App Group.
         */
        appGroupId: string;
        /**
         * Application Group Name.
         */
        appGroupName: string;
        /**
         * Billing model. Valid values:`computeResource` and `qps`.
         */
        chargeWay: number;
        /**
         * The commodity code.
         */
        commodityCode: string;
        /**
         * The time of creation.
         */
        createTime: number;
        /**
         * The version of Application Group Name.
         */
        currentVersion: string;
        /**
         * The description of the resource.
         */
        description: string;
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Expiration Time.
         */
        expireOn: string;
        /**
         * Coarse deployment ID.
         */
        firstRankAlgoDeploymentId: number;
        /**
         * Whether the quota status is under approval. Valid status:
         * * `0`: normal
         * * `1`: Approving.
         */
        hasPendingQuotaReviewTask: number;
        id: string;
        /**
         * The Instance ID.
         */
        instanceId: string;
        /**
         * Locked state. Valid status: `Unlock`,`LockByExpiration`,`ManualLock`.
         */
        lockMode: string;
        /**
         * Instance is automatically locked after expiration.
         */
        lockedByExpiration: number;
        /**
         * The billing method of the resource. Valid values: `Subscription` and `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * Refine deployment ID in deployment.
         */
        pendingSecondRankAlgoDeploymentId: number;
        /**
         * Unfinished order number.
         */
        processingOrderId: string;
        /**
         * Whether the production is completed. Valid values:
         * * `0`: producing.
         * * `1`: completed.
         */
        produced: number;
        /**
         * The Project ID.
         */
        projectId: string;
        /**
         * Quota information.
         */
        quotas: outputs.opensearch.GetAppGroupsGroupQuota[];
        /**
         * The Resource Group ID.
         */
        resourceGroupId: string;
        /**
         * Refine deployment ID.
         */
        secondRankAlgoDeploymentId: number;
        /**
         * The status of the resource. Valid values: `producing`,`reviewPending`,`configPending`,`normal`,`frozen`.
         */
        status: string;
        /**
         * The Switched time.
         */
        switchedTime: number;
        /**
         * Application type. Valid Values: `standard`, `enhanced`.
         */
        type: string;
    }

    export interface GetAppGroupsGroupQuota {
        /**
         * Computing resources. Unit: LCU.
         */
        computeResource: string;
        /**
         * Storage Size. Unit: GB.
         */
        docSize: string;
        /**
         * Specification. Valid values:
         * * `opensearch.share.junior`: Entry-level.
         * * `opensearch.share.common`: Shared universal.
         * * `opensearch.share.compute`: Shared computing.
         * * `opensearch.share.storage`: Shared storage type.
         * * `opensearch.private.common`: Exclusive universal type.
         * * `opensearch.private.compute`: Exclusive computing type.
         * * `opensearch.private.storage`: Exclusive storage type
         */
        spec: string;
    }

}

export namespace oss {
    export interface BucketCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders?: string[];
        /**
         * Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies expose header in the response.
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed (documented below).
         */
        abortMultipartUploads?: outputs.oss.BucketLifecycleRuleAbortMultipartUpload[];
        /**
         * Specifies the accelerate status of a bucket.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire (documented below).
         */
        expirations?: outputs.oss.BucketLifecycleRuleExpiration[];
        /**
         * Unique identifier for the rule. If omitted, OSS bucket will assign a unique name.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire (documented below).
         */
        noncurrentVersionExpirations?: outputs.oss.BucketLifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies when noncurrent object versions transitions (documented below).
         */
        noncurrentVersionTransitions?: outputs.oss.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies. Default value is null, the rule applies to all objects in a bucket.
         */
        prefix?: string;
        /**
         * Specifies the time when an object is converted to the IA or archive storage class during a valid life cycle. (documented below).
         */
        transitions?: outputs.oss.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortMultipartUpload {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the date after which you want the corresponding action to take effect. The value obeys ISO8601 format like `2017-03-09`.
         */
        date?: string;
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct OSS to delete expired object delete markers. This cannot be specified with Days, Date or CreatedBeforeDate in a Lifecycle Expiration Policy.
         */
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days: number;
        /**
         * Specifies the storage class that objects that conform to the rule are converted into. The storage class of the objects in a bucket of the IA storage class can be converted into Archive but cannot be converted into Standard. Values: `IA`, `Archive`.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * Specifies the storage class that objects that conform to the rule are converted into. The storage class of the objects in a bucket of the IA storage class can be converted into Archive but cannot be converted into Standard. Values: `IA`, `Archive`.
         */
        storageClass?: string;
    }

    export interface BucketLogging {
        /**
         * The name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketRefererConfig {
        /**
         * Allows referer to be empty. Defaults false.
         */
        allowEmpty: boolean;
        /**
         * The list of referer.
         */
        referers: string[];
    }

    export interface BucketServerSideEncryptionRule {
        /**
         * The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
         */
        kmsMasterKeyId?: string;
        /**
         * The server-side encryption algorithm to use. Possible values: `AES256` and `KMS`.
         */
        sseAlgorithm: string;
    }

    export interface BucketTransferAcceleration {
        /**
         * Specifies the accelerate status of a bucket.
         */
        enabled: boolean;
    }

    export interface BucketVersioning {
        /**
         * Specifies the versioning state of a bucket. Valid values: `Enabled` and `Suspended`.
         */
        status: string;
    }

    export interface BucketWebsite {
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Alicloud OSS returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument: string;
    }

    export interface GetBucketObjectsObject {
        /**
         * Object access control list. Possible values: `default`, `private`, `public-read` and `public-read-write`.
         */
        acl: string;
        /**
         * Caching behavior along the request/reply chain. Read [RFC2616 Cache-Control](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        cacheControl: string;
        /**
         * Presentational information for the object. Read [RFC2616 Content-Disposition](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        contentDisposition: string;
        /**
         * Content encodings that have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read [RFC2616 Content-Encoding](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        contentEncoding: string;
        /**
         * Size of the object in bytes.
         */
        contentLength: string;
        /**
         * MD5 value of the content. Read [MD5](https://www.alibabacloud.com/help/doc-detail/31978.htm) for computing method.
         */
        contentMd5: string;
        /**
         * Standard MIME type describing the format of the object data, e.g. "application/octet-stream".
         */
        contentType: string;
        /**
         * ETag generated for the object (MD5 sum of the object content).
         */
        etag: string;
        /**
         * Expiration date for the the request/response. Read [RFC2616 Expires](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        expires: string;
        /**
         * Object key.
         */
        key: string;
        /**
         * Last modification time of the object.
         */
        lastModificationTime: string;
        /**
         * Server-side encryption of the object in OSS. It can be empty or `AES256`.
         */
        serverSideEncryption: string;
        /**
         * If present, specifies the ID of the Key Management Service(KMS) master encryption key that was used for the object.
         */
        sseKmsKeyId: string;
        /**
         * Object storage type. Possible values: `Standard`, `IA` and `Archive`.
         */
        storageClass: string;
    }

    export interface GetBucketsBucket {
        /**
         * Bucket access control list. Possible values: `private`, `public-read` and `public-read-write`.
         */
        acl: string;
        /**
         * A list of CORS rule configurations. Each element contains the following attributes:
         */
        corsRules: outputs.oss.GetBucketsBucketCorsRule[];
        /**
         * Bucket creation date.
         */
        creationDate: string;
        /**
         * Internet domain name for accessing the bucket from outside.
         */
        extranetEndpoint: string;
        /**
         * Intranet domain name for accessing the bucket from an ECS instance in the same region.
         */
        intranetEndpoint: string;
        /**
         * A list CORS of lifecycle configurations. When Lifecycle is enabled, OSS automatically deletes the objects or transitions the objects (to another storage class) corresponding the lifecycle rules on a regular basis. Each element contains the following attributes:
         */
        lifecycleRules: outputs.oss.GetBucketsBucketLifecycleRule[];
        /**
         * Region of the data center where the bucket is located.
         */
        location: string;
        /**
         * A list of one element containing configuration parameters used for storing access log information. It contains the following attributes:
         */
        logging: outputs.oss.GetBucketsBucketLogging;
        /**
         * Bucket name.
         */
        name: string;
        /**
         * Bucket owner.
         */
        owner: string;
        policy?: string;
        /**
         * Redundancy type. Possible values: `LRS`, and `ZRS`.
         */
        redundancyType: string;
        /**
         * A list of one element containing referer configuration. It contains the following attributes:
         */
        refererConfig: outputs.oss.GetBucketsBucketRefererConfig;
        /**
         * A configuration of default encryption for a bucket. It contains the following attributes:
         */
        serverSideEncryptionRule: outputs.oss.GetBucketsBucketServerSideEncryptionRule;
        /**
         * Object storage type. Possible values: `Standard`, `IA` and `Archive`.
         */
        storageClass: string;
        /**
         * A mapping of tags.
         */
        tags: {[key: string]: any};
        /**
         * If present , the versioning state has been set on the bucket. It contains the following attribute.
         */
        versioning: outputs.oss.GetBucketsBucketVersioning;
        /**
         * A list of one element containing configuration parameters used when the bucket is used as a website. It contains the following attributes:
         */
        website: outputs.oss.GetBucketsBucketWebsite;
    }

    export interface GetBucketsBucketCorsRule {
        /**
         * Control whether the headers specified by Access-Control-Request-Headers in the OPTIONS prefetch command are allowed. Each header specified by Access-Control-Request-Headers must match a value in AllowedHeader. Each rule allows up to one wildcard “*” .
         */
        allowedHeaders: string[];
        /**
         * Specify the allowed methods for cross-domain requests. Possible values: `GET`, `PUT`, `DELETE`, `POST` and `HEAD`.
         */
        allowedMethods: string[];
        /**
         * The origins allowed for cross-domain requests. Multiple elements can be used to specify multiple allowed origins. Each rule allows up to one wildcard "\*". If "\*" is specified, cross-domain requests of all origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specify the response headers allowing users to access from an application (for example, a Javascript XMLHttpRequest object). The wildcard "\*" is not allowed.
         */
        exposeHeaders: string[];
        /**
         * Specify the cache time for the returned result of a browser prefetch (OPTIONS) request to a specific resource.
         */
        maxAgeSeconds: number;
    }

    export interface GetBucketsBucketLifecycleRule {
        /**
         * Indicate whether the rule is enabled or not.
         */
        enabled: boolean;
        /**
         * A list of one element containing expiration attributes of an object. It contains the following attributes:
         */
        expiration: outputs.oss.GetBucketsBucketLifecycleRuleExpiration;
        /**
         * Unique ID of the rule.
         */
        id: string;
        /**
         * Prefix applicable to a rule. Only those objects with a matching prefix can be affected by the rule.
         */
        prefix: string;
    }

    export interface GetBucketsBucketLifecycleRuleExpiration {
        /**
         * Date after which the rule to take effect. The format is like 2017-03-09.
         */
        date?: string;
        /**
         * Indicate the number of days after the last object update until the rules take effect.
         */
        days?: number;
    }

    export interface GetBucketsBucketLogging {
        /**
         * Bucket for storing access logs.
         */
        targetBucket: string;
        /**
         * Prefix of the saved access log file paths.
         */
        targetPrefix: string;
    }

    export interface GetBucketsBucketRefererConfig {
        /**
         * Indicate whether the access request referer field can be empty.
         */
        allowEmpty: boolean;
        /**
         * Referer access whitelist.
         */
        referers: string[];
    }

    export interface GetBucketsBucketServerSideEncryptionRule {
        /**
         * The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
         */
        kmsMasterKeyId: string;
        /**
         * The server-side encryption algorithm to use.
         */
        sseAlgorithm: string;
    }

    export interface GetBucketsBucketVersioning {
        /**
         * A bucket versioning state. Possible values:`Enabled` and `Suspended`.
         */
        status: string;
    }

    export interface GetBucketsBucketWebsite {
        /**
         * Key of the HTML document containing the error page.
         */
        errorDocument: string;
        /**
         * Key of the HTML document containing the home page.
         */
        indexDocument: string;
    }

    export interface GetInstanceAttachmentsAttachment {
        /**
         * The domain of the instance attachment.
         */
        domain: string;
        /**
         * The access endpoint of the instance attachment.
         */
        endpoint: string;
        /**
         * The resource ID, the value is same as "instanceName".
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The region of the instance attachment.
         */
        region: string;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The name of attaching VPC to instance.
         */
        vpcName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The cluster type of the instance. Possible values: `SSD`, `HYBRID`.
         */
        clusterType: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The instance quota which indicating the maximum number of tables.
         */
        entityQuota: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * The network type of the instance. Possible values: `NORMAL`, `VPC`, `VPC_CONSOLE`.
         */
        network: string;
        /**
         * The maximum adjustable read capacity unit of the instance.
         */
        readCapacity: number;
        /**
         * Instance status. Possible values: `Running`, `Disabled`, `Deleting`.
         */
        status: string;
        /**
         * A map of tags assigned to the instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instancesDs = pulumi.output(alicloud.ots.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * The user id of the instance.
         */
        userId: string;
        /**
         * The maximum adjustable write capacity unit of the instance.
         */
        writeCapacity: number;
    }

    export interface GetTablesTable {
        /**
         * ID of the table. The value is `<instance_name>:<table_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The maximum number of versions stored in this table.
         */
        maxVersion: number;
        /**
         * The property of `TableMeta` which indicates the structure information of a table.
         */
        primaryKeys: outputs.oss.GetTablesTablePrimaryKey[];
        /**
         * The table name of the OTS which could not be changed.
         */
        tableName: string;
        /**
         * The retention time of data stored in this table.
         */
        timeToLive: number;
    }

    export interface GetTablesTablePrimaryKey {
        name: string;
        type: string;
    }

}

export namespace ots {
    export interface GetInstanceAttachmentsAttachment {
        /**
         * The domain of the instance attachment.
         */
        domain: string;
        /**
         * The access endpoint of the instance attachment.
         */
        endpoint: string;
        /**
         * The resource ID, the value is same as "instanceName".
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The region of the instance attachment.
         */
        region: string;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The name of attaching VPC to instance.
         */
        vpcName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The cluster type of the instance. Possible values: `SSD`, `HYBRID`.
         */
        clusterType: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The instance quota which indicating the maximum number of tables.
         */
        entityQuota: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * The network type of the instance. Possible values: `NORMAL`, `VPC`, `VPC_CONSOLE`.
         */
        network: string;
        /**
         * The maximum adjustable read capacity unit of the instance.
         */
        readCapacity: number;
        /**
         * Instance status. Possible values: `Running`, `Disabled`, `Deleting`.
         */
        status: string;
        /**
         * A map of tags assigned to the instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instancesDs = pulumi.output(alicloud.ots.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * The user id of the instance.
         */
        userId: string;
        /**
         * The maximum adjustable write capacity unit of the instance.
         */
        writeCapacity: number;
    }

    export interface GetTablesTable {
        /**
         * ID of the table. The value is `<instance_name>:<table_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The maximum number of versions stored in this table.
         */
        maxVersion: number;
        /**
         * The property of `TableMeta` which indicates the structure information of a table.
         */
        primaryKeys: outputs.ots.GetTablesTablePrimaryKey[];
        /**
         * The table name of the OTS which could not be changed.
         */
        tableName: string;
        /**
         * The retention time of data stored in this table.
         */
        timeToLive: number;
    }

    export interface GetTablesTablePrimaryKey {
        name: string;
        type: string;
    }

    export interface TablePrimaryKey {
        /**
         * Name for primary key.
         */
        name: string;
        /**
         * Type for primary key. Only `Integer`, `String` or `Binary` is allowed.
         */
        type: string;
    }

}

export namespace polardb {
    export interface ClusterDbClusterIpArray {
        /**
         * The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit. 
         * > **NOTE:** If the specified whitelist group name does not exist, the whitelist group is created. If the specified whitelist group name exists, the whitelist group is modified. If you do not specify this parameter, the default group is modified. You can create a maximum of 50 IP whitelist groups for a cluster.
         */
        dbClusterIpArrayName?: string;
        /**
         * The method for modifying the IP whitelist. Valid values are `Cover`, `Append`, `Delete`.
         */
        modifyMode?: string;
        /**
         * List of IP addresses allowed to access all databases of an cluster. The list contains up to 1,000 IP addresses, separated by commas. Supported formats include 0.0.0.0/0, 10.23.12.24 (IP), and 10.23.12.24/24 (Classless Inter-Domain Routing (CIDR) mode. /24 represents the length of the prefix in an IP address. The range of the prefix length is [1,32]).
         */
        securityIps?: string[];
    }

    export interface ClusterParameter {
        name: string;
        value: string;
    }

    export interface GetAccountsAccount {
        /**
         * Account description.
         */
        accountDescription: string;
        /**
         * Account lock state, Valid values are `Lock`, `UnLock`.
         */
        accountLockState: string;
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Cluster address type.`Cluster`: the default address of the Cluster.`Primary`: Primary address.`Custom`: Custom cluster addresses.
         */
        accountStatus: string;
        /**
         * Account type, Valid values are `Normal`, `Super`.
         */
        accountType: string;
        /**
         * A list of database privilege. Each element contains the following attributes.
         */
        databasePrivileges: outputs.polardb.GetAccountsAccountDatabasePrivilege[];
    }

    export interface GetAccountsAccountDatabasePrivilege {
        /**
         * Account privilege of database
         */
        accountPrivilege: string;
        /**
         * The account owned database name
         */
        dbName: string;
    }

    export interface GetClustersCluster {
        /**
         * Billing method. Value options: `PostPaid` for Pay-As-You-Go and `PrePaid` for subscription.
         */
        chargeType: string;
        /**
         * The createTime of the db_nodes.
         */
        createTime: string;
        /**
         * The dbNodeClass of the db_nodes.
         */
        dbNodeClass: string;
        /**
         * The DBNodeNumber of the PolarDB cluster.
         */
        dbNodeNumber: number;
        /**
         * The DBNodes of the PolarDB cluster.
         */
        dbNodes: outputs.polardb.GetClustersClusterDbNode[];
        /**
         * Database type. Options are `MySQL`, `Oracle` and `PostgreSQL`. If no value is specified, all types are returned.
         */
        dbType: string;
        /**
         * The DBVersion of the PolarDB cluster.
         */
        dbVersion: string;
        /**
         * The DeleteLock of the PolarDB cluster.
         */
        deleteLock: number;
        /**
         * The description of the PolarDB cluster.
         */
        description: string;
        /**
         * Database type. Options are `MySQL`, `Oracle` and `PostgreSQL`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Expiration time. Pay-As-You-Go clusters never expire.
         */
        expireTime: string;
        /**
         * The expired of the PolarDB cluster.
         */
        expired: string;
        /**
         * The ID of the PolarDB cluster.
         */
        id: string;
        /**
         * The LockMode of the PolarDB cluster.
         */
        lockMode: string;
        /**
         * The DBClusterNetworkType of the PolarDB cluster.
         */
        networkType: string;
        /**
         * The regionId of the db_nodes.
         */
        regionId: string;
        /**
         * status of the cluster.
         */
        status: string;
        /**
         * The StorageUsed of the PolarDB cluster.
         */
        storageUsed: number;
        /**
         * ID of the VPC the cluster belongs to.
         */
        vpcId: string;
        /**
         * The zoneId of the db_nodes.
         */
        zoneId: string;
    }

    export interface GetClustersClusterDbNode {
        /**
         * The createTime of the db_nodes.
         */
        createTime: string;
        /**
         * The dbNodeClass of the db_nodes.
         */
        dbNodeClass: string;
        /**
         * The dbNodeId of the db_nodes.
         */
        dbNodeId: string;
        /**
         * The dbNodeRole of the db_nodes.
         */
        dbNodeRole: string;
        /**
         * The dbNodeStatus of the db_nodes.
         */
        dbNodeStatus: string;
        /**
         * The maxConnections of the db_nodes.
         */
        maxConnections: number;
        /**
         * The maxIops of the db_nodes.
         */
        maxIops: number;
        /**
         * The regionId of the db_nodes.
         */
        regionId: string;
        /**
         * The zoneId of the db_nodes.
         */
        zoneId: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * A list of accounts of database. Each element contains the following attributes.
         */
        accounts: outputs.polardb.GetDatabasesDatabaseAccount[];
        /**
         * The character set name of database.
         */
        characterSetName: string;
        /**
         * Database description.
         */
        dbDescription: string;
        /**
         * Database name.
         */
        dbName: string;
        /**
         * The status of database.
         */
        dbStatus: string;
        /**
         * The engine of database.
         */
        engine: string;
    }

    export interface GetDatabasesDatabaseAccount {
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Account status.
         */
        accountStatus: string;
        /**
         * The privilege status of account.
         */
        privilegeStatus: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * A list of endpoint addresses. Each element contains the following attributes.
         */
        addressItems: outputs.polardb.GetEndpointsEndpointAddressItem[];
        /**
         * Whether the new node is automatically added to the default cluster address.Options are `Enable` and `Disable`.
         */
        autoAddNewNodes: string;
        /**
         * endpoint of the cluster.
         */
        dbEndpointId: string;
        /**
         * The Endpoint configuration. `ConsistLevel`: session consistency level, value:`0`: final consistency,`1`: session consistency;`LoadBalanceStrategy`: load balancing strategy. Based on the automatic scheduling of load, the value is: `load`.
         */
        endpointConfig: string;
        /**
         * Cluster address type.`Cluster`: the default address of the Cluster.`Primary`: Primary address.`Custom`: Custom cluster addresses.
         */
        endpointType: string;
        /**
         * A list of nodes that connect to the address configuration.
         */
        nodes: string;
        /**
         * Read-write mode:`ReadWrite`: readable and writable (automatic read-write separation).`ReadOnly`: ReadOnly.
         */
        readWriteMode: string;
    }

    export interface GetEndpointsEndpointAddressItem {
        /**
         * Connection instance string.
         */
        connectionString: string;
        /**
         * The ip address of connection string.
         */
        ipAddress: string;
        /**
         * IP network type:`Public` or `Private`.
         */
        netType: string;
        /**
         * Intranet connection port.
         */
        port: string;
        /**
         * ID of the VPC the instance belongs to.
         */
        vpcId: string;
        /**
         * ID of the VSwitch the cluster belongs to.
         */
        vswitchId: string;
    }

    export interface GetNodeClassesClass {
        /**
         * A list of PolarDB node classes in the zone.
         */
        supportedEngines: outputs.polardb.GetNodeClassesClassSupportedEngine[];
        /**
         * The Zone to launch the PolarDB cluster.
         */
        zoneId: string;
    }

    export interface GetNodeClassesClassSupportedEngine {
        /**
         * A list of PolarDB node available classes.
         */
        availableResources: outputs.polardb.GetNodeClassesClassSupportedEngineAvailableResource[];
        /**
         * In the zone, the database type supports classes in the following available_resources.
         */
        engine: string;
    }

    export interface GetNodeClassesClassSupportedEngineAvailableResource {
        /**
         * The PolarDB node class type by the user.
         */
        dbNodeClass: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace privatelink {
    export interface GetVpcEndpointConnectionsConnection {
        /**
         * The Bandwidth.
         */
        bandwidth: number;
        /**
         * The ID of the Vpc Endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Vpc Endpoint Connection.
         */
        id: string;
        /**
         * The status of Vpc Endpoint Connection.
         */
        status: string;
    }

    export interface GetVpcEndpointServiceResourcesResource {
        /**
         * The ID of the Vpc Endpoint Service Resource.
         */
        id: string;
        /**
         * The ID of Resource.
         */
        resourceId: string;
        /**
         * The type of Resource.
         */
        resourceType: string;
    }

    export interface GetVpcEndpointServiceUsersUser {
        /**
         * The ID of the Vpc Endpoint Service User.
         */
        id: string;
        /**
         * The Id of Ram User.
         */
        userId: string;
    }

    export interface GetVpcEndpointServicesService {
        /**
         * Whether to automatically accept terminal node connections..
         */
        autoAcceptConnection: boolean;
        /**
         * The connection bandwidth.
         */
        connectBandwidth: number;
        /**
         * The ID of the Vpc Endpoint Service.
         */
        id: string;
        /**
         * The business status of the terminal node service..
         */
        serviceBusinessStatus: string;
        /**
         * The description of the terminal node service.
         */
        serviceDescription: string;
        /**
         * The domain of service.
         */
        serviceDomain: string;
        /**
         * The ID of the Vpc Endpoint Service.
         */
        serviceId: string;
        /**
         * The Status of Vpc Endpoint Service.
         */
        status: string;
        /**
         * The name of Vpc Endpoint Service.
         */
        vpcEndpointServiceName: string;
    }

    export interface GetVpcEndpointZonesZone {
        /**
         * Terminal node network card.
         */
        eniId: string;
        /**
         * IP address of the terminal node network card.
         */
        eniIp: string;
        /**
         * The ID of the Vpc Endpoint Zone.
         */
        id: string;
        /**
         * The Status of Vpc Endpoint Zone..
         */
        status: string;
        /**
         * The VSwitch id.
         */
        vswitchId: string;
        /**
         * The Zone Domain.
         */
        zoneDomain: string;
        /**
         * The Zone Id.
         */
        zoneId: string;
    }

    export interface GetVpcEndpointsEndpoint {
        /**
         * The Bandwidth.
         */
        bandwidth: number;
        /**
         * The status of Connection.
         */
        connectionStatus: string;
        /**
         * The status of Endpoint Business.
         */
        endpointBusinessStatus: string;
        /**
         * The description of Vpc Endpoint.
         */
        endpointDescription: string;
        /**
         * The Endpoint Domain.
         */
        endpointDomain: string;
        /**
         * The ID of the Vpc Endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Vpc Endpoint.
         */
        id: string;
        /**
         * The security group associated with the terminal node network card.
         */
        securityGroupIds: string[];
        /**
         * The terminal node service associated with the terminal node.
         */
        serviceId: string;
        /**
         * The name of the terminal node service associated with the terminal node.
         */
        serviceName: string;
        /**
         * The status of Vpc Endpoint.
         */
        status: string;
        /**
         * The name of Vpc Endpoint.
         */
        vpcEndpointName: string;
        /**
         * The private network to which the terminal node belongs.
         */
        vpcId: string;
    }

}

export namespace pvtz {
    export interface EndpointIpConfig {
        /**
         * The Subnet mask.
         */
        cidrBlock: string;
        /**
         * The IP address within the parameter range of the subnet mask.  It is recommended to use the IP address assigned by the system.
         */
        ip: string;
        /**
         * The Vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone ID.
         */
        zoneId: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The name of the resource.
         */
        endpointName: string;
        id: string;
        /**
         * The Ip Configs.
         */
        ipConfigs: outputs.pvtz.GetEndpointsEndpointIpConfig[];
        /**
         * The ID of the Security Group.
         */
        securityGroupId: string;
        /**
         * The status of the resource. Valid values: `CHANGE_FAILED`, `CHANGE_INIT`, `EXCEPTION`, `FAILED`, `INIT`, `SUCCESS`.
         */
        status: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
        /**
         * The name of the VPC.
         */
        vpcName: string;
        /**
         * The Region of the VPC.
         */
        vpcRegionId: string;
    }

    export interface GetEndpointsEndpointIpConfig {
        /**
         * The Subnet mask.
         */
        cidrBlock: string;
        /**
         * The IP address within the parameter range of the subnet mask. **NOTE:** It is recommended to use the IP address assigned by the system.
         */
        ip: string;
        /**
         * The Vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone ID.
         */
        zoneId: string;
    }

    export interface GetResolverZonesZone {
        /**
         * The status of the Zone.
         */
        status: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetRulesRule {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Endpoint.
         */
        endpointId: string;
        /**
         * The Name of the Endpoint.
         */
        endpointName: string;
        forwardIps: outputs.pvtz.GetRulesRuleForwardIp[];
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        ruleId: string;
        /**
         * The name of the resource.
         */
        ruleName: string;
        /**
         * The type of the rule.
         */
        type: string;
        /**
         * The name of the forwarding zone.
         */
        zoneName: string;
    }

    export interface GetRulesRuleForwardIp {
        ip: string;
        port: number;
    }

    export interface GetZoneRecordsRecord {
        /**
         * ID of the Private Zone Record.
         */
        id: string;
        /**
         * Priority of the Private Zone Record.
         */
        priority: number;
        /**
         * RecordId of the Private Zone Record.
         */
        recordId: string;
        /**
         * Remark of the Private Zone Record.
         */
        remark: string;
        /**
         * Resource record of the Private Zone Record.
         */
        resourceRecord: string;
        /**
         * Rr of the Private Zone Record.
         */
        rr: string;
        /**
         * Resolve record status. Value:
         * - ENABLE: enable resolution.
         * - DISABLE: pause parsing.
         */
        status: string;
        /**
         * Ttl of the Private Zone Record.
         */
        ttl: number;
        /**
         * Type of the Private Zone Record.
         */
        type: string;
        /**
         * Value of the Private Zone Record.
         */
        value: string;
    }

    export interface GetZonesZone {
        /**
         * List of the VPCs is bound to the Private Zone:
         */
        bindVpcs: outputs.pvtz.GetZonesZoneBindVpc[];
        /**
         * Time of create of the Private Zone.
         */
        createTimestamp: number;
        creationTime: string;
        /**
         * ID of the Private Zone.
         */
        id: string;
        /**
         * Whether the Private Zone is ptr.
         */
        isPtr: boolean;
        /**
         * Name of the Private Zone.
         */
        name: string;
        /**
         * The recursive DNS proxy.
         */
        proxyPattern: string;
        /**
         * Count of the Private Zone Record.
         */
        recordCount: number;
        /**
         * Remark of the Private Zone.
         */
        remark: string;
        /**
         * resource_group_id for zone resourceGroupId.
         */
        resourceGroupId: string;
        /**
         * Whether to turn on secondary DNS.
         */
        slaveDns: boolean;
        updateTime: string;
        /**
         * Time of update of the Private Zone.
         */
        updateTimestamp: number;
        /**
         * ZoneId of the Private Zone.
         */
        zoneId: string;
        /**
         * ZoneName of the Private Zone.
         */
        zoneName: string;
    }

    export interface GetZonesZoneBindVpc {
        /**
         * Binding the regionId of VPC.
         */
        regionId: string;
        /**
         * Binding the regionName of VPC.
         */
        regionName: string;
        /**
         * Binding the vpcId of VPC.
         */
        vpcId: string;
        vpcName: string;
    }

    export interface RuleAttachmentVpc {
        /**
         * The region of the vpc. If not set, the current region will instead of.
         */
        regionId: string;
        /**
         * The ID of the VPC.  **NOTE:** The VPC that can be associated with the forwarding rule must belong to the same region as the Endpoint.
         */
        vpcId: string;
    }

    export interface RuleForwardIp {
        /**
         * The ip of the forwarding destination.
         */
        ip: string;
        /**
         * The port of the forwarding destination.
         */
        port: number;
    }

    export interface ZoneAttachmentVpc {
        /**
         * The region of the vpc. If not set, the current region will instead of.
         */
        regionId: string;
        /**
         * The Id of the vpc.
         */
        vpcId: string;
    }

    export interface ZoneUserInfo {
        /**
         * The list of the region IDs.
         */
        regionIds?: string[];
        /**
         * The user ID belonging to the region is used for cross-account synchronization scenarios.
         */
        userId?: string;
    }
}

export namespace quickbi {
    export interface GetUsersUser {
        /**
         * Alibaba Cloud account ID.
         */
        accountId: string;
        /**
         * An Alibaba Cloud account, Alibaba Cloud name.
         */
        accountName: string;
        /**
         * Whether it is the administrator. Valid values: `true` and `false`.
         */
        adminUser: boolean;
        /**
         * Whether this is a permissions administrator. Valid values: `true` and `false`.
         */
        authAdminUser: boolean;
        /**
         * The email of the user.
         */
        email: string;
        /**
         * The ID of the User.
         */
        id: string;
        /**
         * The nickname of the user.
         */
        nickName: string;
        /**
         * The phone number of the user.
         */
        phone: string;
        /**
         * The ID of the User.
         */
        userId: string;
        /**
         * The members of the organization of the type of role separately. Valid values: `Analyst`, `Developer` and `Visitor`.
         */
        userType: string;
    }

}

export namespace quotas {
    export interface ApplicationInfoDimension {
        key?: string;
        value?: string;
    }

    export interface GetApplicationInfosApplication {
        applicationId: string;
        approveValue: string;
        auditReason: string;
        desireValue: number;
        dimensions: outputs.quotas.GetApplicationInfosApplicationDimension[];
        effectiveTime: string;
        expireTime: string;
        id: string;
        noticeType: number;
        productCode: string;
        quotaActionCode: string;
        quotaDescription: string;
        quotaName: string;
        quotaUnit: string;
        reason: string;
        status: string;
    }

    export interface GetApplicationInfosApplicationDimension {
        key: string;
        value: string;
    }

    export interface GetApplicationInfosDimension {
        key?: string;
        value?: string;
    }

    export interface GetQuotaAlarmsAlarm {
        /**
         * The first ID of the resource.
         */
        alarmId: string;
        /**
         * The ID of the Quota Alarm.
         */
        id: string;
        /**
         * The Product Code.
         */
        productCode: string;
        /**
         * The Quota Action Code.
         */
        quotaActionCode: string;
        /**
         * The name of Quota Alarm.
         */
        quotaAlarmName: string;
        /**
         * The Quota Dimensions.
         */
        quotaDimensions: outputs.quotas.GetQuotaAlarmsAlarmQuotaDimension[];
        /**
         * The threshold of Quota Alarm.
         */
        threshold: number;
        /**
         * The threshold percent of Quota Alarm.
         */
        thresholdPercent: number;
        /**
         * The WebHook of Quota Alarm.
         */
        webHook: string;
    }

    export interface GetQuotaAlarmsAlarmQuotaDimension {
        /**
         * The key of quota_dimensions.
         */
        key: string;
        /**
         * The value of quota_dimensions.
         */
        value: string;
    }

    export interface GetQuotaAlarmsQuotaDimension {
        /**
         * The key of quota_dimensions.
         */
        key?: string;
        /**
         * The value of quota_dimensions.
         */
        value?: string;
    }

    export interface GetQuotaApplicationsApplication {
        /**
         * The first ID of the resource.
         */
        applicationId: string;
        /**
         * The approve value.
         */
        approveValue: string;
        /**
         * The audit reason.
         */
        auditReason: string;
        /**
         * The desire value of the quota application.
         */
        desireValue: number;
        /**
         * The quota dimensions.
         */
        dimensions: outputs.quotas.GetQuotaApplicationsApplicationDimension[];
        /**
         * The effective time.
         */
        effectiveTime: string;
        /**
         * The expire time.
         */
        expireTime: string;
        /**
         * The ID of the Application Info.
         */
        id: string;
        /**
         * The notice type.
         */
        noticeType: number;
        /**
         * The product code.
         */
        productCode: string;
        /**
         * The ID of quota action..
         */
        quotaActionCode: string;
        /**
         * The description of the quota.
         */
        quotaDescription: string;
        /**
         * The name of the quota.
         */
        quotaName: string;
        /**
         * The quota unit.
         */
        quotaUnit: string;
        /**
         * The reason of the quota application.
         */
        reason: string;
        /**
         * The status of the quota application.
         */
        status: string;
    }

    export interface GetQuotaApplicationsApplicationDimension {
        /**
         * The key of dimensions.
         */
        key: string;
        /**
         * The value of dimensions.
         */
        value: string;
    }

    export interface GetQuotaApplicationsDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

    export interface GetQuotasDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

    export interface GetQuotasQuota {
        /**
         * Is the quota adjustable.
         */
        adjustable: boolean;
        /**
         * The range of quota adjustment.
         */
        applicableRanges: string[];
        /**
         * The type of quota.
         */
        applicableType: string;
        /**
         * Show used quota.
         */
        consumable: boolean;
        /**
         * The ID of the Quota.
         */
        id: string;
        /**
         * The quota action code.
         */
        quotaActionCode: string;
        /**
         * The quota description.
         */
        quotaDescription: string;
        /**
         * The quota name.
         */
        quotaName: string;
        /**
         * The quota type.
         */
        quotaType: string;
        /**
         * The quota unit.
         */
        quotaUnit: string;
        /**
         * TotalQuota.
         */
        totalQuota: number;
        /**
         * The total of usage.
         */
        totalUsage: number;
        /**
         * The unadjustable detail.
         */
        unadjustableDetail: string;
    }

    export interface QuotaAlarmQuotaDimension {
        /**
         * The Key of quota_dimensions.
         */
        key?: string;
        /**
         * The Value of quota_dimensions.
         */
        value?: string;
    }

    export interface QuotaApplicationDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

}

export namespace ram {
    export interface GetGroupsGroup {
        /**
         * Comments of the group.
         */
        comments: string;
        /**
         * Name of the group.
         */
        name: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * Attachment count of the policy.
         */
        attachmentCount: number;
        /**
         * Creation date of the policy.
         */
        createDate: string;
        /**
         * Default version of the policy.
         */
        defaultVersion: string;
        /**
         * Description of the policy.
         */
        description: string;
        /**
         * Policy document of the policy.
         */
        document: string;
        id: string;
        /**
         * Name of the policy.
         */
        name: string;
        /**
         * Policy document of the policy.
         */
        policyDocument: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Filter results by a specific policy type. Valid values are `Custom` and `System`.
         */
        type: string;
        /**
         * Update date of the policy.
         */
        updateDate: string;
        /**
         * Filter results by a specific user name. Returned policies are attached to the specified user.
         */
        userName: string;
        /**
         * The ID of default policy.
         */
        versionId: string;
    }

    export interface GetRolesRole {
        /**
         * Resource descriptor of the role.
         */
        arn: string;
        /**
         * Authorization strategy of the role. This parameter is deprecated and replaced by `document`.
         */
        assumeRolePolicyDocument: string;
        /**
         * Creation date of the role.
         */
        createDate: string;
        /**
         * Description of the role.
         */
        description: string;
        /**
         * Authorization strategy of the role.
         */
        document: string;
        /**
         * Id of the role.
         */
        id: string;
        /**
         * Name of the role.
         */
        name: string;
        /**
         * Update date of the role.
         */
        updateDate: string;
    }

    export interface GetSamlProvidersProvider {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the IdP.
         */
        arn: string;
        /**
         * The description of SAML Provider.
         */
        description: string;
        /**
         * The encodedsaml metadata document.
         */
        encodedsamlMetadataDocument: string;
        /**
         * The ID of the SAML Provider.
         */
        id: string;
        /**
         * The saml provider name.
         */
        samlProviderName: string;
        /**
         * The update time.
         */
        updateDate: string;
    }

    export interface GetUsersUser {
        /**
         * Creation date of the user.
         */
        createDate: string;
        /**
         * The original id is user name, but it is user id in 1.37.0+.
         */
        id: string;
        /**
         * Last login date of the user. Removed from version 1.79.0.
         */
        lastLoginDate: string;
        /**
         * Name of the user.
         */
        name: string;
    }

    export interface PolicyStatement {
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) List of operations for the `resource`. The format of each item in this list is `${service}:${action_name}`, such as `oss:ListBuckets` and `ecs:Describe*`. The `${service}` can be `ecs`, `oss`, `ots` and so on, the `${action_name}` refers to the name of an api interface which related to the `${service}`.
         */
        actions: string[];
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) This parameter indicates whether or not the `action` is allowed. Valid values are `Allow` and `Deny`.
         */
        effect: string;
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) List of specific objects which will be authorized. The format of each item in this list is `acs:${service}:${region}:${account_id}:${relative_id}`, such as `acs:ecs:*:*:instance/inst-002` and `acs:oss:*:1234567890000:mybucket`. The `${service}` can be `ecs`, `oss`, `ots` and so on, the `${region}` is the region info which can use `*` replace when it is not supplied, the `${account_id}` refers to someone's Alicloud account id or you can use `*` to replace, the `${relative_id}` is the resource description section which related to the `${service}`.
         */
        resources: string[];
    }

}

export namespace rdc {
    export interface GetOrganizationsOrganization {
        /**
         * The ID of the Organization.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        organizationId: string;
        /**
         * Company name.
         */
        organizationName: string;
    }

}

export namespace rds {
    export interface GetAccountsAccount {
        /**
         * Database description.
         */
        accountDescription: string;
        /**
         * Name of database account.
         */
        accountName: string;
        /**
         * Privilege type of account.
         */
        accountType: string;
        /**
         * A list of database permissions the account has.
         */
        databasePrivileges: outputs.rds.GetAccountsAccountDatabasePrivilege[];
        /**
         * The ID of the Account.
         */
        id: string;
        /**
         * Whether the maximum number of databases managed by the account is exceeded.
         */
        privExceeded: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAccountsAccountDatabasePrivilege {
        /**
         * The type of permission for the account.
         */
        accountPrivilege: string;
        /**
         * The specific permissions corresponding to the type of account permissions.
         */
        accountPrivilegeDetail: string;
        /**
         * Database name.
         */
        dbName: string;
    }

    export interface GetInstanceClassesInstanceClass {
        /**
         * DB Instance available class.
         */
        instanceClass: string;
        price: string;
        /**
         * DB Instance available storage range.
         */
        storageRange: outputs.rds.GetInstanceClassesInstanceClassStorageRange;
        /**
         * A list of Zone to launch the DB instance.
         */
        zoneIds: outputs.rds.GetInstanceClassesInstanceClassZoneId[];
    }

    export interface GetInstanceClassesInstanceClassStorageRange {
        /**
         * DB Instance available storage max value.
         */
        max: string;
        /**
         * DB Instance available storage min value.
         */
        min: string;
        /**
         * DB Instance available storage increase step.
         */
        step: string;
    }

    export interface GetInstanceClassesInstanceClassZoneId {
        /**
         * The Zone to launch the DB instance
         */
        id: string;
        /**
         * A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `subZoneIds` will be `["cn-beijing-a", "cn-beijing-b"]`.
         */
        subZoneIds: string[];
    }

    export interface GetInstanceEnginesInstanceEngine {
        /**
         * DB Instance category. the value like [`Basic`, `HighAvailability`, `Finance`, `AlwaysOn`], [detail info](https://www.alibabacloud.com/help/doc-detail/69795.htm).
         */
        category: string;
        /**
         * Database type. Valid values: "MySQL", "SQLServer", "PostgreSQL", "PPAS", "MariaDB". If not set, it will match all of engines.
         */
        engine: string;
        /**
         * Database version required by the user. Value options can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/26228.htm) `EngineVersion`.
         */
        engineVersion: string;
        /**
         * A list of Zone to launch the DB instance.
         */
        zoneIds: outputs.rds.GetInstanceEnginesInstanceEngineZoneId[];
    }

    export interface GetInstanceEnginesInstanceEngineZoneId {
        /**
         * The Zone to launch the DB instance
         */
        id: string;
        /**
         * A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `subZoneIds` will be `["cn-beijing-a", "cn-beijing-b"]`.
         */
        subZoneIds: string[];
    }

    export interface GetInstancesInstance {
        /**
         * (Available in 1.124.1+) The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - cert
         * - perfer
         * - verify-ca
         * - verify-full (supported only when the instance runs PostgreSQL 12 or later)
         */
        acl: string;
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * (Available in 1.124.1+) The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - aliyun: a cloud certificate
         * - custom: a custom certificate
         */
        caType: string;
        /**
         * Billing method. Value options: `Postpaid` for Pay-As-You-Go and `Prepaid` for subscription.
         */
        chargeType: string;
        /**
         * (Available in 1.124.1+) The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        clientCaCert: string;
        clientCaCertExpireTime: string;
        /**
         * (Available in 1.124.1+) The certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        clientCertRevocationList: string;
        /**
         * `Standard` for standard access mode and `Safe` for high security access mode.
         */
        connectionMode: string;
        /**
         * (Available in 1.70.3+) RDS database connection string.
         */
        connectionString: string;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * (Available in 1.124.3+) The creator of the encryption key.
         */
        creator: string;
        /**
         * (Available in 1.70.3+) The storage type of the instance.
         */
        dbInstanceStorageType: string;
        /**
         * `Primary` for primary instance, `Readonly` for read-only instance, `Guard` for disaster recovery instance, and `Temp` for temporary instance.
         */
        dbType: string;
        /**
         * (Available in 1.124.3+) The estimated time when the encryption key will be deleted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        deleteDate: string;
        /**
         * (Available in 1.124.3+) The description of the encryption key.
         */
        description: string;
        /**
         * (Available in 1.124.3+) The ID of the encryption key.
         */
        encryptionKey: string;
        /**
         * (Available in 1.124.3+) The status of the encryption key. Valid values:
         * - Enabled
         * - Disabled
         */
        encryptionKeyStatus: string;
        /**
         * Database type. Options are `MySQL`, `SQLServer`, `PostgreSQL` and `PPAS`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Database version.
         */
        engineVersion: string;
        /**
         * Expiration time. Pay-As-You-Go instances never expire.
         */
        expireTime: string;
        /**
         * If a disaster recovery instance is attached to the current instance, the ID of the disaster recovery instance applies.
         */
        guardInstanceId: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * (Available in 1.70.3+) User-defined DB instance storage space.
         */
        instanceStorage: number;
        /**
         * Sizing of the RDS instance.
         */
        instanceType: string;
        /**
         * (Available in 1.124.3+) The purpose of the encryption key.
         */
        keyUsage: string;
        /**
         * (Available in 1.124.1+) The status of the SSL link. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - success
         * - setting
         * - failed
         */
        lastModifyStatus: string;
        /**
         * ID of the primary instance. If this parameter is not returned, the current instance is a primary instance.
         */
        masterInstanceId: string;
        /**
         * (Available in 1.101.0+) The master zone of the instance.
         */
        masterZone: string;
        /**
         * (Available in 1.124.3+) The time when the encryption key expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        materialExpireTime: string;
        /**
         * (Available in 1.124.1+) The reason why the SSL link stays in the current state. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        modifyStatusReason: string;
        /**
         * The name of the RDS instance.
         */
        name: string;
        /**
         * `Internet` for public network or `Intranet` for private network.
         */
        netType: string;
        /**
         * (Available in 1.124.3+) The source of the encryption key.
         */
        origin: string;
        /**
         * (Available in 1.135.0+) Parameter list.
         */
        parameters: outputs.rds.GetInstancesInstanceParameter[];
        /**
         * (Available in 1.70.3+) RDS database connection port.
         */
        port: string;
        /**
         * A list of IDs of read-only instances attached to the primary instance.
         */
        readonlyInstanceIds: string[];
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * (Available in 1.124.1+) The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - cert
         * - perfer
         * - verify-ca
         * - verify-full (supported only when the instance runs PostgreSQL 12 or later)
         */
        replicationAcl: string;
        /**
         * (Available in 1.124.1+) Indicates whether the server certificate needs to be updated.
         * - Valid values for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server:
         * - No
         * - Yes
         * - Valid values for ApsaraDB RDS for PostgreSQL:
         * - 0: no
         * - 1: yes
         */
        requireUpdate: string;
        /**
         * (Available in 1.124.1+) The server certificate that needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        requireUpdateItem: string;
        /**
         * (Available in 1.124.1+) The reason why the server certificate needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        requireUpdateReason: string;
        /**
         * (Available in 1.124.1+) The URL of the CA that issues the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverCaUrl: string;
        /**
         * (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverCert: string;
        /**
         * (Available in 1.124.1+) The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverKey: string;
        /**
         * (Available in 1.124.1+) The time when the server certificate was created. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. In addition, this parameter is valid only when the CAType parameter is set to aliyun.
         */
        sslCreateTime: string;
        /**
         * (Available in 1.124.1+) Indicates whether SSL encryption is enabled. Valid values:
         * - on: enabled
         * - off: disabled
         */
        sslEnabled: string;
        /**
         * (Available in 1.124.1+) The time when the server certificate expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        sslExpireTime: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * If a temporary instance is attached to the current instance, the ID of the temporary instance applies.
         */
        tempInstanceId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Used to retrieve instances belong to specified `vswitch` resources.
         */
        vswitchId: string;
        /**
         * (Available in 1.101.0+) The region ID of the secondary instance if you create a secondary instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
         */
        zoneIdSlaveA: string;
        /**
         * (Available in 1.101.0+) The region ID of the log instance if you create a log instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
         */
        zoneIdSlaveB: string;
    }

    export interface GetInstancesInstanceParameter {
        /**
         * The value range of the parameter.
         */
        checkingCode: string;
        /**
         * Indicates whether the parameter can be modified. Valid values: true | false
         */
        forceModify: string;
        /**
         * Indicates whether the modified parameter takes effect only after a database restart. Valid values: true | false
         */
        forceRestart: string;
        /**
         * The description of the parameter.
         */
        parameterDescription: string;
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The default value of the parameter.
         */
        parameterValue: string;
    }

    export interface GetRdsBackupsBackup {
        /**
         * The backup download url.
         */
        backupDownloadUrl: string;
        /**
         * BackupEndTime.
         */
        backupEndTime: string;
        /**
         * BackupId.
         */
        backupId: string;
        /**
         * The initiator of the backup task. Value:
         * * **System**: automatically initiated by the System
         * * **User**: manually initiated by the User.
         */
        backupInitiator: string;
        /**
         * The backup intranet download url.
         */
        backupIntranetDownloadUrl: string;
        /**
         * BackupMethod.
         */
        backupMethod: string;
        /**
         * BackupMode.
         */
        backupMode: string;
        /**
         * BackupSize.
         */
        backupSize: string;
        /**
         * BackupStartTime.
         */
        backupStartTime: string;
        /**
         * Backup task status. **NOTE:** This parameter will only be returned when a task is executed. Value:
         * * **NoStart**: Not started
         * * **Checking**: check the backup
         * * **Preparing**: Prepare a backup
         * * **Waiting**: Waiting for backup
         * * **Uploading**: Upload backup
         * * **Finished**: Complete backup
         * * **Failed**: backup Failed
         */
        backupStatus: string;
        /**
         * BackupType.
         */
        backupType: string;
        /**
         * The consistency point of the backup set. The return value is a timestamp. **NOTE:** only MySQL 5.6 returns this parameter, and other versions return 0.
         */
        consistentTime: string;
        /**
         * The backup mode is divided into the normal backup mode (full and incremental recovery is supported) and the replication-only mode (full recovery is supported only). **NOTE:** Only SQL Server returns this parameter. Valid values:
         * * **0**: General Backup Mode
         * * **1**: Copy only mode
         */
        copyOnlyBackup: string;
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The encrypted information of the backup set.
         */
        encryption: string;
        /**
         * HostInstanceID.
         */
        hostInstanceId: string;
        /**
         * The ID of the Backup.
         */
        id: string;
        /**
         * Whether the backup set is available, the value is:
         * * **0**: Not available
         * * **1**: Available.
         */
        isAvail: number;
        /**
         * The backup set status of the database table. **NOTE:** an empty string indicates that the backup set for database table recovery is not enabled. Valid values:
         * * **OK**: normal.
         * * **LARGE**: There are too many tables that cannot be used for database and table recovery.
         * * **EMPTY**: The backup set that failed to be backed up.
         */
        metaStatus: string;
        /**
         * The storage medium for the backup set. Valid values:
         * * **0**: Regular storage
         * * **1**: Archive storage.
         */
        storageClass: string;
        /**
         * StoreStatus.
         */
        storeStatus: string;
    }

    export interface GetRdsParameterGroupsGroup {
        engine: string;
        engineVersion: string;
        forceRestart: number;
        id: string;
        paramCounts: number;
        paramDetails: outputs.rds.GetRdsParameterGroupsGroupParamDetail[];
        parameterGroupDesc: string;
        parameterGroupId: string;
        parameterGroupName: string;
        parameterGroupType: number;
    }

    export interface GetRdsParameterGroupsGroupParamDetail {
        paramName: string;
        paramValue: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceParameter {
        name: string;
        value: string;
    }

    export interface RdsCloneDbInstanceParameter {
        name: string;
        value: string;
    }

    export interface RdsParameterGroupParamDetail {
        /**
         * The name of a parameter.
         */
        paramName: string;
        /**
         * The value of a parameter.
         */
        paramValue: string;
    }

    export interface ReadOnlyInstanceParameter {
        name: string;
        value: string;
    }
}

export namespace resourcemanager {
    export interface GetAccountsAccount {
        accountId: string;
        /**
         * (Available in v1.125.0+) The Alibaba Cloud account name of the member account.
         */
        accountName: string;
        displayName: string;
        /**
         * The ID of the folder.
         */
        folderId: string;
        /**
         * The ID of the resource.
         * * `accountId`- The ID of the account.
         * * `displayName`- The name of the member account.
         */
        id: string;
        /**
         * The way in which the member account joined the resource directory.
         */
        joinMethod: string;
        /**
         * The time when the member account joined the resource directory.
         */
        joinTime: string;
        /**
         * The time when the member account was modified.
         */
        modifyTime: string;
        /**
         * (Available in v1.124.3+) Settlement account ID. If the value is empty, the current account will be used for settlement.
         */
        payerAccountId: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The status of account, valid values: `CreateCancelled`, `CreateExpired`, `CreateFailed`, `CreateSuccess`, `CreateVerifying`, `InviteSuccess`, `PromoteCancelled`, `PromoteExpired`, `PromoteFailed`, `PromoteSuccess`, and `PromoteVerifying`.
         */
        status: string;
        /**
         * The type of the member account.
         */
        type: string;
    }

    export interface GetControlPoliciesPolicy {
        /**
         * The count of policy attachment.
         */
        attachmentCount: number;
        /**
         * The name of policy.
         */
        controlPolicyName: string;
        /**
         * The description of policy.
         */
        description: string;
        /**
         * The effect scope.
         */
        effectScope: string;
        /**
         * The ID of the Control Policy.
         */
        id: string;
        /**
         * The policy document.
         */
        policyDocument: string;
        /**
         * The ID of policy.
         */
        policyId: string;
        /**
         * The type of policy.
         */
        policyType: string;
    }

    export interface GetControlPolicyAttachmentsAttachment {
        /**
         * The attach date.
         */
        attachDate: string;
        /**
         * The description of policy.
         */
        description: string;
        /**
         * The ID of the Control Policy Attachment.
         */
        id: string;
        /**
         * The ID of policy.
         */
        policyId: string;
        /**
         * The name of policy.
         */
        policyName: string;
        /**
         * The type of policy.
         */
        policyType: string;
    }

    export interface GetFoldersFolder {
        folderId: string;
        folderName: string;
        /**
         * The ID of the folder.
         * * `folderId`- The ID of the folder.
         * * `folderName`- The name of the folder.
         * * `parentFolderId`- (Available in v1.114.0+)The ID of the parent folder.
         */
        id: string;
        /**
         * The ID of the parent folder.
         */
        parentFolderId: string;
    }

    export interface GetHandshakesHandshake {
        /**
         * The time when the invitation expires.
         */
        expireTime: string;
        handshakeId: string;
        /**
         * The ID of the resource.
         * * `handshakeId`- The ID of the invitation.
         */
        id: string;
        /**
         * (Available in v1.114.0+) The real name of the invited account.
         */
        invitedAccountRealName: string;
        /**
         * The ID of the master account of the resource directory.
         */
        masterAccountId: string;
        /**
         * The name of the master account of the resource directory.
         */
        masterAccountName: string;
        /**
         * (Available in v1.114.0+) The real name of the master account of the resource directory.
         */
        masterAccountRealName: string;
        /**
         * The time when the invitation was modified.
         */
        modifyTime: string;
        /**
         * The invitation note.
         */
        note: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The status of handshake, valid values: `Accepted`, `Cancelled`, `Declined`, `Deleted`, `Expired` and `Pending`.
         */
        status: string;
        /**
         * The ID or logon email address of the invited account.
         */
        targetEntity: string;
        /**
         * The type of the invited account.
         */
        targetType: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * The number of times the policy is referenced.
         */
        attachmentCount: number;
        /**
         * The default version of the policy.
         */
        defaultVersion: string;
        /**
         * The description of the policy.
         */
        description: string;
        /**
         * The ID of the policy.
         * * `policyName`- The name of the policy.
         * * `policyType`- The type of the policy.
         */
        id: string;
        policyName: string;
        /**
         * The type of the policy. If you do not specify this parameter, the system lists all types of policies. Valid values: `Custom` and `System`.
         */
        policyType: string;
        /**
         * The time when the policy was updated.
         */
        updateDate: string;
    }

    export interface GetPolicyAttachmentsAttachment {
        /**
         * The time when the policy was attached.
         */
        attachDate: string;
        /**
         * The description of the policy.
         */
        description: string;
        /**
         * The ID of the Resource Manager Policy Attachment.
         * * `policyName`- The name of the policy.
         * * `policyType`- The type of the policy.
         * * `principalName`- The name of the object to which the policy is attached.
         * * `principalType`- The type of the object to which the policy is attached.
         */
        id: string;
        /**
         * The name of the policy. The name must be 1 to 128 characters in length and can contain letters, digits, and hyphens (-).
         */
        policyName: string;
        /**
         * The type of the policy. Valid values: `Custom` and `System`.
         */
        policyType: string;
        /**
         * The name of the object to which the policy is attached.
         */
        principalName: string;
        /**
         * The type of the object to which the policy is attached. If you do not specify this parameter, the system lists all types of objects. Valid values: `IMSUser`: RAM user, `IMSGroup`: RAM user group, `ServiceRole`: RAM role.
         */
        principalType: string;
        /**
         * The ID of the resource group or the ID of the Alibaba Cloud account to which the resource group belongs. If you do not specify this parameter, the system lists all policy attachment records under the current account.
         */
        resourceGroupId: string;
    }

    export interface GetPolicyVersionsVersion {
        /**
         * The ID of the resource, the value is `<policy_name>`:`<version_id>`.
         * * `versionId`- The ID of the policy version.
         * * `createDate`- (Removed form v1.114.0)The time when the policy version was created.
         * * `isDefaultVersion`- Indicates whether the policy version is the default version.
         * * `policyDocument`- (Available in v1.114.0+) The policy document of the policy version.
         */
        id: string;
        isDefaultVersion: boolean;
        policyDocument: string;
        versionId: string;
    }

    export interface GetResourceDirectoriesDirectory {
        /**
         * The ID of resource directory.
         * * `masterAccountId`- The ID of the master account.
         * * `masterAccountName`- The name of the master account.
         */
        id: string;
        masterAccountId: string;
        masterAccountName: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The ID of the root folder.
         */
        rootFolderId: string;
        /**
         * (Available in 1.120.0+.) The status of the control policy.
         */
        status: string;
    }

    export interface GetResourceGroupsGroup {
        /**
         * The ID of the Alibaba Cloud account to which the resource group belongs.
         */
        accountId: string;
        /**
         * The display name of the resource group.
         */
        displayName: string;
        /**
         * The ID of the resource group.
         */
        id: string;
        /**
         * The unique identifier of the resource group.
         */
        name: string;
        regionStatuses: outputs.resourcemanager.GetResourceGroupsGroupRegionStatus[];
        /**
         * (Available in v1.114.0+) The unique identifier of the resource group.
         */
        resourceGroupName: string;
        /**
         * The status of the resource group. Possible values:`Creating`,`Deleted`,`Deleting`(Available 1.114.0+) `OK` and `PendingDelete`.
         */
        status: string;
    }

    export interface GetResourceGroupsGroupRegionStatus {
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The status of the resource group. Possible values:`Creating`,`Deleted`,`Deleting`(Available 1.114.0+) `OK` and `PendingDelete`.
         */
        status: string;
    }

    export interface GetResourceSharesShare {
        /**
         * The ID of the Resource Share.
         */
        id: string;
        /**
         * The ID of the resource share.
         */
        resourceShareId: string;
        /**
         * The name of resource share.
         */
        resourceShareName: string;
        /**
         * The owner of resource share.
         */
        resourceShareOwner: string;
        /**
         * The status of resource share.
         */
        status: string;
    }

    export interface GetRolesRole {
        arn: string;
        assumeRolePolicyDocument: string;
        description: string;
        /**
         * The ID of the role.
         * * `roleId`- The ID of the role.
         * * `roleName`- The name of the role.
         * * `arn`- The Alibaba Cloud Resource Name (ARN) of the RAM role.
         * * `createDate`- (Removed form v1.114.0) The time when the RAM role was created.
         * * `updateDate`- The time when the RAM role was updated.
         * * `description`- The description of the RAM role.
         * * `maxSessionDuration`- The maximum session duration of the RAM role.
         * * `assumeRolePolicyDocument`- (Available in v1.114.0+) The assume role policy document.
         */
        id: string;
        maxSessionDuration: number;
        roleId: string;
        roleName: string;
        updateDate: string;
    }

    export interface GetSharedResourcesResource {
        /**
         * The ID of the Shared Resource.
         */
        id: string;
        /**
         * The ID of the shared resource.
         */
        resourceId: string;
        /**
         * The resource share ID of resource manager.
         */
        resourceShareId: string;
        /**
         * The type of shared resource.
         */
        resourceType: string;
        /**
         * The status of shared resource.
         */
        status: string;
    }

    export interface GetSharedTargetsTarget {
        /**
         * The ID of the Shared Target.
         */
        id: string;
        /**
         * The resource shared ID of resource manager.
         */
        resourceShareId: string;
        /**
         * The status of shared target.
         */
        status: string;
        /**
         * The member account ID in resource directory.
         */
        targetId: string;
    }

    export interface ResourceGroupRegionStatus {
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The status of the regional resource group.
         */
        status: string;
    }
}

export namespace rocketmq {
    export interface GetGroupsGroup {
        /**
         * The name of the group.
         */
        groupName: string;
        /**
         * Specify the protocol applicable to the created Group ID. Valid values: `tcp`, `http`. Default to `tcp`.
         */
        groupType: string;
        /**
         * The name of the group.
         */
        id: string;
        /**
         * Indicates whether namespaces are available. Read [Fields in SubscribeInfoDo](https://www.alibabacloud.com/help/doc-detail/29619.html) for further details.
         */
        independentNaming: boolean;
        /**
         * ID of the ONS Instance that owns the groups.
         */
        instanceId: string;
        /**
         * The ID of the group owner, which is the Alibaba Cloud UID.
         */
        owner: string;
        /**
         * Remark of the group.
         */
        remark: string;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
    }

    export interface GetInstancesInstance {
        /**
         * The internal HTTP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternalEndpoint: string;
        /**
         * The public HTTP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternetEndpoint: string;
        /**
         * The public HTTPS endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternetSecureEndpoint: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Indicates whether any namespace is configured for the Message Queue for Apache RocketMQ instance.
         */
        independentNaming: boolean;
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Name of the instance.
         */
        instanceName: string;
        /**
         * The status of the instance. Read [Fields in InstanceVO](https://www.alibabacloud.com/help/doc-detail/106351.html) for further details.
         */
        instanceStatus: number;
        /**
         * The type of the instance. Read [Fields in InstanceVO](https://www.alibabacloud.com/help/doc-detail/106351.html) for further details.
         */
        instanceType: number;
        /**
         * The automatic release time of an Enterprise Platinum Edition instance.
         */
        releaseTime: string;
        /**
         * This attribute is a concise description of instance.
         */
        remark: string;
        /**
         * The status of Ons instance. Valid values: `0` deploying, `2` arrears, `5` running, `7` upgrading.
         */
        status: number;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
        /**
         * The TCP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        tcpEndpoint: string;
    }

    export interface GetTopicsTopic {
        /**
         * The id of the topic.
         */
        id: string;
        /**
         * Indicates whether namespaces are available. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        independentNaming: boolean;
        /**
         * ID of the ONS Instance that owns the topics.
         */
        instanceId: string;
        /**
         * The type of the message. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        messageType: number;
        /**
         * The ID of the topic owner, which is the Alibaba Cloud UID.
         */
        owner: string;
        /**
         * This attribute is used to set the read-write mode for the topic.
         */
        perm: number;
        /**
         * The relation ID. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        relation: number;
        /**
         * The name of the relation, for example, owner, publishable, subscribable, and publishable and subscribable.
         */
        relationName: string;
        /**
         * Remark of the topic.
         */
        remark: string;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
        /**
         * The name of the topic.
         */
        topic: string;
        /**
         * The name of the topic.
         */
        topicName: string;
    }

}

export namespace ros {
    export interface ChangeSetParameter {
        /**
         * The parameter key.
         */
        parameterKey: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface GetChangeSetsSet {
        /**
         * The ID of the change set.
         */
        changeSetId: string;
        /**
         * The name of the change set.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        changeSetName: string;
        /**
         * The type of the change set. Valid values:  CREATE: creates a change set for a new stack. UPDATE: creates a change set for an existing stack. IMPORT: creates a change set for a new stack or an existing stack to import non-ROS-managed resources. If you create a change set for a new stack, ROS creates a stack that has a unique stack ID. The stack is in the REVIEW_IN_PROGRESS state until you execute the change set.  You cannot use the UPDATE type to create a change set for a new stack or the CREATE type to create a change set for an existing stack.
         */
        changeSetType: string;
        /**
         * The description of the change set. The description can be up to 1,024 bytes in length.
         */
        description: string;
        /**
         * Specifies whether to disable rollback on stack creation failure. Default value: false.  Valid values:  true: disables rollback on stack creation failure. false: enables rollback on stack creation failure. Note This parameter takes effect only when ChangeSetType is set to CREATE or IMPORT.
         */
        disableRollback: boolean;
        /**
         * The execution status of change set N. Maximum value of N: 5. Valid values:  UNAVAILABLE AVAILABLE EXECUTE_IN_PROGRESS EXECUTE_COMPLETE EXECUTE_FAILED OBSOLETE.
         */
        executionStatus: string;
        /**
         * The ID of the Change Set.
         */
        id: string;
        /**
         * Parameters.
         */
        parameters: outputs.ros.GetChangeSetsSetParameter[];
        /**
         * The ID of the stack for which you want to create the change set. ROS generates the change set by comparing the stack information with the information that you submit, such as a modified template or different inputs.
         */
        stackId: string;
        /**
         * The name of the stack for which you want to create the change set.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.  Note This parameter takes effect only when ChangeSetType is set to CREATE or IMPORT.
         */
        stackName: string;
        /**
         * The status of the change set.
         */
        status: string;
        /**
         * The structure that contains the template body. The template body must be 1 to 524,288 bytes in length.  If the length of the template body is longer than required, we recommend that you add parameters to the HTTP POST request body to avoid request failures due to excessive length of URLs.  You can specify one of TemplateBody or TemplateURL parameters, but you cannot specify both of them.
         */
        templateBody: string;
        /**
         * Timeout In Minutes.
         */
        timeoutInMinutes: number;
    }

    export interface GetChangeSetsSetParameter {
        /**
         * The parameters.
         */
        parameterKey: string;
        /**
         * The parameters.
         */
        parameterValue: string;
    }

    export interface GetRegionsRegion {
        /**
         * The name of the region.
         */
        localName: string;
        /**
         * The endpoint of the region.
         */
        regionEndpoint: string;
        /**
         * The ID of the region.
         */
        regionId: string;
    }

    export interface GetStackGroupsGroup {
        /**
         * The name of the RAM administrator role assumed by ROS.
         */
        administrationRoleName: string;
        /**
         * The description of the stack group.
         */
        description: string;
        /**
         * The name of the RAM execution role assumed by the administrator role.
         */
        executionRoleName: string;
        /**
         * The ID of the Stack Group.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: outputs.ros.GetStackGroupsGroupParameter[];
        /**
         * The id of Stack Group.
         */
        stackGroupId: string;
        /**
         * The name of the stack group..
         */
        stackGroupName: string;
        /**
         * The status of Stack Group.
         */
        status: string;
        /**
         * The structure that contains the template body.
         */
        templateBody: string;
    }

    export interface GetStackGroupsGroupParameter {
        /**
         * The parameter key.
         */
        parameterKey: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface GetStackInstancesInstance {
        /**
         * The ID of the Stack Instance. The value formats as `<stack_group_name>:<stack_instance_account_id>:<stack_instance_region_id>`.
         */
        id: string;
        /**
         * ParameterOverrides.
         */
        parameterOverrides: outputs.ros.GetStackInstancesInstanceParameterOverride[];
        /**
         * The ID of the stack group.
         */
        stackGroupId: string;
        /**
         * The name of the stack group.
         */
        stackGroupName: string;
        /**
         * The ID of the stack corresponding to the stack instance.
         */
        stackId: string;
        /**
         * The account to which the stack instance belongs.
         */
        stackInstanceAccountId: string;
        /**
         * The region of the stack instance.
         */
        stackInstanceRegionId: string;
        /**
         * The status of the stack instance. Valid values: `CURRENT` or `OUTDATED`. 
         * * `CURRENT`: The stack corresponding to the stack instance is up to date with the stack group.
         * * `OUTDATED`: The stack corresponding to the stack instance is not up to date with the stack group. The `OUTDATED` state has the following possible causes:
         * * When the CreateStackInstances operation is called to create stack instances, the corresponding stacks fail to be created.
         * * When the UpdateStackInstances or UpdateStackGroup operation is called to update stack instances, the corresponding stacks fail to be updated, or only some of the stack instances are updated.
         * * The create or update operation is not complete.
         */
        status: string;
        /**
         * The reason why the stack is in its current state.
         */
        statusReason: string;
    }

    export interface GetStackInstancesInstanceParameterOverride {
        /**
         * The key of override parameter.
         */
        parameterKey: string;
        /**
         * The value of override parameter.
         */
        parameterValue: string;
    }

    export interface GetStacksStack {
        /**
         * Specifies whether to enable deletion protection on the stack.
         */
        deletionProtection: string;
        /**
         * The Description of the Stack.
         */
        description: string;
        /**
         * Specifies whether to disable rollback on stack creation failure..
         */
        disableRollback: boolean;
        /**
         * Drift DetectionTime.
         */
        driftDetectionTime: string;
        /**
         * The ID of the Stack.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: outputs.ros.GetStacksStackParameter[];
        /**
         * Parent Stack Id.
         */
        parentStackId: string;
        /**
         * The RamRoleName.
         */
        ramRoleName: string;
        /**
         * Root Stack Id.
         */
        rootStackId: string;
        /**
         * Stack DriftStatus.
         */
        stackDriftStatus: string;
        /**
         * Stack Id.
         */
        stackId: string;
        /**
         * Stack Name.
         */
        stackName: string;
        /**
         * The structure that contains the stack policy body.
         */
        stackPolicyBody: string;
        /**
         * The status of Stack. Valid Values: `CREATE_COMPLETE`, `CREATE_FAILED`, `CREATE_IN_PROGRESS`, `DELETE_COMPLETE`, `DELETE_FAILED`, `DELETE_IN_PROGRESS`, `ROLLBACK_COMPLETE`, `ROLLBACK_FAILED`, `ROLLBACK_IN_PROGRESS`.
         */
        status: string;
        /**
         * Status Reason.
         */
        statusReason: string;
        /**
         * Query the instance bound to the tag. The format of the incoming value is `json` string, including `TagKey` and `TagValue`. `TagKey` cannot be null, and `TagValue` can be empty. Format example `{"key1":"value1"}`.
         */
        tags: {[key: string]: any};
        /**
         * Template Description.
         */
        templateDescription: string;
        /**
         * Specifies whether to use the values that were passed last time for the parameters that you do not specify in the current request.
         */
        timeoutInMinutes: number;
    }

    export interface GetStacksStackParameter {
        /**
         * The key of parameters.
         */
        parameterKey: string;
        /**
         * The value of parameters.
         */
        parameterValue: string;
    }

    export interface GetTemplateScratchesScratch {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description of the Template Scratch.
         */
        description: string;
        /**
         * The ID of the Template Scratch.
         */
        id: string;
        /**
         * The Logical ID generation strategy of the Template Scratch.
         */
        logicalIdStrategy: string;
        /**
         * Priority parameter.
         */
        preferenceParameters: outputs.ros.GetTemplateScratchesScratchPreferenceParameter[];
        /**
         * Source resource grouping.
         */
        sourceResourceGroups: outputs.ros.GetTemplateScratchesScratchSourceResourceGroup[];
        /**
         * Source resource.
         */
        sourceResources: outputs.ros.GetTemplateScratchesScratchSourceResource[];
        /**
         * The Source label list.
         */
        sourceTags: outputs.ros.GetTemplateScratchesScratchSourceTag[];
        /**
         * A list of resource stacks associated with the resource scene.
         */
        stacks: outputs.ros.GetTemplateScratchesScratchStack[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the Template Scratch.
         */
        templateScratchId: string;
        /**
         * The type of the Template Scratch.
         */
        templateScratchType: string;
    }

    export interface GetTemplateScratchesScratchPreferenceParameter {
        /**
         * Priority parameter key.
         */
        parameterKey: string;
        /**
         * Priority parameter value.
         */
        parameterValue: string;
    }

    export interface GetTemplateScratchesScratchSourceResource {
        /**
         * The ID of the Source Resource.
         */
        resourceId: string;
        /**
         * The type of the Source resource.
         */
        resourceType: string;
    }

    export interface GetTemplateScratchesScratchSourceResourceGroup {
        /**
         * The ID of the Source Resource Group.
         */
        resourceGroupId: string;
        /**
         * Source resource type filter list.
         */
        resourceTypeFilters: string[];
    }

    export interface GetTemplateScratchesScratchSourceTag {
        /**
         * Source label.
         */
        resourceTags: {[key: string]: any};
        /**
         * Source resource type filter list.
         */
        resourceTypeFilters: string[];
    }

    export interface GetTemplateScratchesScratchStack {
        /**
         * The ID of the Resource stack.
         */
        stackId: string;
    }

    export interface GetTemplatesTemplate {
        /**
         * The ID of the change set.
         */
        changeSetId: string;
        /**
         * The description of the template. The description can be up to 256 characters in length.
         */
        description: string;
        /**
         * The ID of the Template.
         */
        id: string;
        /**
         * Share Type.
         */
        shareType: string;
        /**
         * The name of the stack group. The name must be unique in a region.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        stackGroupName: string;
        /**
         * The ID of the stack.
         */
        stackId: string;
        /**
         * Tags.
         */
        tags: {[key: string]: any};
        /**
         * The structure that contains the template body. The template body must be 1 to 524,288 bytes in length.  If the length of the template body is longer than required, we recommend that you add parameters to the HTTP POST request body to avoid request failures due to excessive length of URLs.  You must specify one of the TemplateBody and TemplateURL parameters, but you cannot specify both of them.
         */
        templateBody: string;
        /**
         * The ID of the template.
         */
        templateId: string;
        /**
         * The name of the template.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        templateName: string;
        /**
         * Template Version.
         */
        templateVersion: string;
    }

    export interface StackGroupParameter {
        /**
         * The parameter key.
         */
        parameterKey?: string;
        /**
         * The parameter value.
         */
        parameterValue?: string;
    }

    export interface StackInstanceParameterOverride {
        /**
         * The key of override parameter. If you do not specify the key and value of the parameter, ROS uses the key and value that you specified when you created the stack group.
         */
        parameterKey?: string;
        /**
         * The value of override parameter. If you do not specify the key and value of the parameter, ROS uses the key and value that you specified when you created the stack group.
         */
        parameterValue?: string;
    }

    export interface StackParameter {
        /**
         * The parameter key.
         */
        parameterKey?: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface TemplateScratchPreferenceParameter {
        /**
         * Priority parameter key. For more information about values, see [supplementary instructions for request parameters](https://www.alibabacloud.com/help/zh/doc-detail/358846.html#h2-url-4).
         */
        parameterKey: string;
        /**
         * Priority parameter value. For more information about values, see [supplementary instructions for request parameters](https://www.alibabacloud.com/help/zh/doc-detail/358846.html#h2-url-4).
         */
        parameterValue: string;
    }

    export interface TemplateScratchSourceResource {
        /**
         * The ID of the Source Resource.
         */
        resourceId: string;
        /**
         * The type of the Source resource.
         */
        resourceType: string;
    }

    export interface TemplateScratchSourceResourceGroup {
        /**
         * The ID of the Source Resource Group.
         */
        resourceGroupId: string;
        /**
         * Source resource type filter list. If the resource type list is specified, it means to scan the resources of the specified resource type and in the specified resource group; Otherwise, it means to scan all resources in the specified resource group. **NOTE:** A maximum of `20` resource type filter can be configured.
         */
        resourceTypeFilters?: string[];
    }

    export interface TemplateScratchSourceTag {
        /**
         * Source label. **NOTE:** A maximum of 10 source labels can be configured.
         */
        resourceTags: {[key: string]: any};
        /**
         * Source resource type filter list. If the resource type list is specified, it means to scan the resources of the specified resource type and in the specified resource group; Otherwise, it means to scan all resources in the specified resource group. **NOTE:** A maximum of `20` resource type filter can be configured.
         */
        resourceTypeFilters?: string[];
    }

}

export namespace sae {
    export interface ApplicationInternet {
        /**
         * SSL certificate. `httpsCertId` is required when HTTPS is selected
         */
        httpsCertId?: string;
        /**
         * SLB Port.
         */
        port?: number;
        /**
         * Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
         */
        protocol?: string;
        /**
         * Container port.
         */
        targetPort?: number;
    }

    export interface ApplicationIntranet {
        /**
         * SSL certificate. `httpsCertId` is required when HTTPS is selected
         */
        httpsCertId?: string;
        /**
         * SLB Port.
         */
        port?: number;
        /**
         * Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
         */
        protocol?: string;
        /**
         * Container port.
         */
        targetPort?: number;
    }

    export interface GetApplicationsApplication {
        /**
         * The ARN of the RAM role required when pulling images across accounts.
         */
        acrAssumeRoleArn: string;
        /**
         * Application description information. No more than 1024 characters.
         */
        appDescription: string;
        /**
         * Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
         */
        appName: string;
        /**
         * The first ID of the resource.
         */
        applicationId: string;
        /**
         * Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
         */
        command: string;
        /**
         * Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
         */
        commandArgs: string;
        /**
         * ConfigMap mount description.
         */
        configMapMountDesc: string;
        /**
         * The CPU required for each instance, in millicores, cannot be 0.
         */
        cpu: number;
        /**
         * Indicates That the Application of the Creation Time.
         */
        createTime: string;
        /**
         * Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
         */
        customHostAlias: string;
        /**
         * The operating environment used by the Pandora application.
         */
        edasContainerVersion: string;
        /**
         * The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
         */
        envs: string;
        /**
         * The ID of the Application.
         */
        id: string;
        /**
         * Mirror address. Only Image type applications can configure the mirror address.
         */
        imageUrl: string;
        /**
         * The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
         */
        jarStartArgs: string;
        /**
         * The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
         */
        jarStartOptions: string;
        /**
         * The JDK version that the deployment package depends on. Image type applications are not supported.
         */
        jdk: string;
        /**
         * Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
         */
        liveness: string;
        /**
         * The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
         */
        memory: number;
        /**
         * The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
         */
        minReadyInstances: number;
        /**
         * Mount description.
         */
        mountDesc: string;
        /**
         * Mount point of NAS in application VPC.
         */
        mountHost: string;
        /**
         * SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
         */
        namespaceId: string;
        /**
         * ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
         */
        nasId: string;
        /**
         * OSS AccessKey ID.
         */
        ossAkId: string;
        /**
         * OSS  AccessKey Secret.
         */
        ossAkSecret: string;
        /**
         * OSS mount description information.
         */
        ossMountDescs: string;
        /**
         * Application package type. Support FatJar, War and Image.
         */
        packageType: string;
        /**
         * Deployment package address. Only FatJar or War type applications can configure the deployment package address.
         */
        packageUrl: string;
        /**
         * The version number of the deployment package. Required when the Package Type is War and FatJar.
         */
        packageVersion: string;
        /**
         * The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
         */
        phpArmsConfigLocation: string;
        /**
         * PHP configuration file content.
         */
        phpConfig: string;
        /**
         * PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
         */
        phpConfigLocation: string;
        /**
         * Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
         */
        postStart: string;
        /**
         * Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
         */
        preStop: string;
        /**
         * Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
         */
        readiness: string;
        regionId: string;
        /**
         * Initial number of instances.
         */
        replicas: number;
        repoName: string;
        repoNamespace: string;
        repoOriginType: string;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * SLS  configuration.
         */
        slsConfigs: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
         */
        terminationGracePeriodSeconds: number;
        /**
         * Time zone, the default value is Asia/Shanghai.
         */
        timezone: string;
        /**
         * Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
         */
        tomcatConfig: string;
        /**
         * The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
         */
        warStartOptions: string;
        /**
         * The version of tomcat that the deployment package depends on. Image type applications are not supported.
         */
        webContainer: string;
    }

    export interface GetConfigMapsMap {
        /**
         * The first ID of the resource.
         */
        configMapId: string;
        /**
         * The Creation Time of the ConfigMap.
         */
        createTime: string;
        /**
         * ConfigMap instance data. The value's format is a `json` string
         */
        data: string;
        /**
         * The Description of Config Map.
         */
        description: string;
        /**
         * The ID of the Config Map.
         */
        id: string;
        /**
         * ConfigMap instance name.
         */
        name: string;
        /**
         * The NamespaceId of Config Maps.
         */
        namespaceId: string;
    }

    export interface GetIngressesIngress {
        /**
         * Cert Id.
         */
        certId: string;
        /**
         * Default Rule.
         */
        defaultRule: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The ID of the Ingress.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        ingressId: string;
        /**
         * SLB listening port.
         */
        listenerPort: number;
        /**
         * The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
         */
        namespaceId: string;
        /**
         * SLB ID.
         */
        slbId: string;
    }

    export interface GetInstanceSpecificationsSpecification {
        /**
         * CPU Size, Specifications for Micronucleus.
         */
        cpu: number;
        /**
         * Whether the instance is available. The value description is as follows:
         */
        enable: boolean;
        /**
         * The ID of the Instance Specification.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        instanceSpecificationId: string;
        /**
         * The Memory specifications for the MB.
         */
        memory: number;
        /**
         * The specification configuration name.
         */
        specInfo: string;
        /**
         * The specification configuration version.
         */
        version: number;
    }

    export interface GetNamespacesNamespace {
        /**
         * The ID of the Namespace.
         */
        id: string;
        /**
         * The Description of Namespace.
         */
        namespaceDescription: string;
        /**
         * The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
         */
        namespaceId: string;
        /**
         * The Name of Namespace.
         */
        namespaceName: string;
    }

    export interface IngressDefaultRule {
        /**
         * Target application ID.
         */
        appId?: string;
        /**
         * Target application name.
         */
        appName?: string;
        /**
         * Application backend port.
         */
        containerPort?: number;
    }

    export interface IngressRule {
        /**
         * Target application ID.
         */
        appId: string;
        /**
         * Target application name.
         */
        appName: string;
        /**
         * Application backend port.
         */
        containerPort: number;
        /**
         * Application domain name.
         */
        domain: string;
        /**
         * URL path.
         */
        path: string;
    }

}

export namespace sag {
    export interface GetAclsAcl {
        /**
         * The ID of the ACL. For example "acl-xxx".
         */
        id: string;
        /**
         * The name of the Acl.
         */
        name: string;
    }

}

export namespace scdn {
    export interface DomainCertInfo {
        /**
         * If You Enable HTTPS Here Certificate Name.
         */
        certName?: string;
        /**
         * Certificate Type. Value Range: 
         * * upload: Certificate
         * * cas: Certificate Authority Certificate.
         * * free: Free Certificate.
         */
        certType?: string;
        /**
         * Private Key. Do Not Enable Certificate without Entering a User Name and Configure Certificates Enter Private Key.
         */
        sslPri?: string;
        /**
         * Whether to Enable SSL Certificate. Valid Values: on, off. Valid values: `on`, `off`.
         */
        sslProtocol?: string;
        /**
         * If You Enable HTTPS Here Key.
         */
        sslPub?: string;
    }

    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainSource {
        /**
         * The Back-to-Source Address.
         */
        content: string;
        /**
         * The source status. Valid values: online, offline.
         */
        enabled: string;
        /**
         * Port.
         */
        port: number;
        /**
         * Priority.
         */
        priority: string;
        /**
         * The Origin Server Type. Valid Values: 
         * * ipaddr: IP Source Station
         * * domain: the Domain Name
         * * oss: OSS Bucket as a Source Station.
         */
        type: string;
    }

    export interface GetDomainsDomain {
        /**
         * Certificate Information.
         */
        certInfos: outputs.scdn.GetDomainsDomainCertInfo[];
        /**
         * In Order to Link the CDN Domain Name to Generate a CNAME Domain Name, in the Domain Name Resolution Service Provider at the Acceleration Domain Name CNAME Resolution to the Domain.
         */
        cname: string;
        /**
         * Creation Time.
         */
        createTime: string;
        /**
         * Review the Reason for the Failure Is Displayed.
         */
        description: string;
        /**
         * Your Domain Name.
         */
        domainName: string;
        /**
         * Last Modified Date.
         */
        gmtModified: string;
        /**
         * The ID of the Domain. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The Resource Group ID.
         */
        resourceGroupId: string;
        /**
         * the Origin Server Information.
         */
        sources: outputs.scdn.GetDomainsDomainSource[];
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetDomainsDomainCertInfo {
        /**
         * If You Enable HTTPS Here Certificate Name.
         */
        certName: string;
        /**
         * Certificate Type. Value Range: Upload: Certificate. CAS: Certificate Authority Certificate. Free: Free Certificate.
         */
        certType: string;
        /**
         * Whether to Enable SSL Certificate. Valid Values: on, off.
         */
        sslProtocol: string;
        /**
         * If You Enable HTTPS Here Key.
         */
        sslPub: string;
    }

    export interface GetDomainsDomainSource {
        /**
         * The Back-to-Source Address.
         */
        content: string;
        /**
         * State.
         */
        enabled: string;
        /**
         * Port.
         */
        port: number;
        /**
         * Priority.
         */
        priority: string;
        /**
         * the Origin Server Type. Valid Values: Ipaddr: IP Source Station Domain: the Domain Name, See Extra Domain Quota OSS: OSS Bucket as a Source Station.
         */
        type: string;
    }

}

export namespace sddp {
    export interface GetConfigsConfig {
        /**
         * Abnormal Alarm General Configuration Module by Using the Encoding.Valid values: `accessFailedCnt`, `accessPermissionExprieMaxDays`, `logDatasizeAvgDays`.
         */
        code: string;
        /**
         * Configure the Number.
         */
        configId: string;
        /**
         * Default Value.
         */
        defaultValue: string;
        /**
         * Abnormal Alarm General Description of the Configuration Item.
         */
        description: string;
        /**
         * The ID of the Config.
         */
        id: string;
        /**
         * The Specified Exception Alarm Generic by Using the Value. Code Different Values for This Parameter the Specific Meaning of Different.
         * * `accessFailedCnt`: Value Represents the Non-Authorized Resource Repeatedly Attempts to Access the Threshold.
         * * `accessPermissionExprieMaxDays`: Value Represents the Permissions during Periods of Inactivity Exceeding a Threshold.
         * * `logDatasizeAvgDays`: Value Represents the Date Certain Log Output Is Less than 10 Days before the Average Value of the Threshold.
         */
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * Whether the required RAM authorization is configured.
         */
        authed: boolean;
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The number of instances.
         */
        instanceNum: string;
        /**
         * Whether the authorized MaxCompute (ODPS) assets.
         */
        odpsSet: boolean;
        /**
         * Whether the authorized oss assets.
         */
        ossBucketSet: boolean;
        /**
         * The OSS size of the instance.
         */
        ossSize: string;
        /**
         * The payment type of the resource. Valid values: `Subscription`.
         */
        paymentType: string;
        /**
         * Whether the authorized rds assets.
         */
        rdsSet: boolean;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetRulesRule {
        /**
         * Sensitive Data Identification Rules for the Type of.
         */
        category: number;
        /**
         * Sensitive Data Identification Rules Belongs Type Name.
         */
        categoryName: string;
        /**
         * Sensitive Data Identification Rules the Content.
         */
        content: string;
        /**
         * The Content Classification.
         */
        contentCategory: string;
        /**
         * Sensitive Data Identification Rules the Creation Time of the Number of Milliseconds.
         */
        createTime: string;
        /**
         * Sensitive Data Identification Rules of Type. 0: the Built-in 1: The User-Defined.
         */
        customType: number;
        /**
         * Sensitive Data Identification a Description of the Rule Information.
         */
        description: string;
        /**
         * Sensitive Data Identification Rules, Founder of Account Display Name.
         */
        displayName: string;
        /**
         * Sensitive Data Identification Rules to the Modified Time of the Number of Milliseconds.
         */
        gmtModified: string;
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * Sensitive Data Identification Rules, Founder Of Account Login.
         */
        loginName: string;
        /**
         * The Primary Key.
         */
        majorKey: string;
        /**
         * The name of rule.
         */
        name: string;
        /**
         * Product Code.
         */
        productCode: string;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * Sensitive Data Identification Rules of Risk Level ID. Valid values:1:S1, Weak Risk Level. 2:S2, Medium Risk Level. 3:S3 High Risk Level. 4:S4, the Highest Risk Level.
         */
        riskLevelId: string;
        /**
         * Sensitive Data Identification Rules the Risk Level of. S1: Weak Risk Level S2: Moderate Risk Level S3: High Risk Level S4: the Highest Risk Level.
         */
        riskLevelName: string;
        /**
         * The first ID of the resource.
         */
        ruleId: string;
        /**
         * Triggered the Alarm Conditions.
         */
        statExpress: string;
        /**
         * Sensitive Data Identification Rules Detection State of.
         */
        status: number;
        /**
         * The Target.
         */
        target: string;
        /**
         * The User ID.
         */
        userId: string;
        /**
         * The Level of Risk.
         */
        warnLevel: number;
    }

}

export namespace securitycenter {
    export interface GetGroupsGroup {
        /**
         * GroupFlag, '0' mean default group(created by system), '1' means customer defined group.
         */
        groupFlag: number;
        /**
         * The ID of Group.
         */
        groupId: string;
        /**
         * The name of Group.
         */
        groupName: string;
        /**
         * The ID of the Group(same as the group_id).
         */
        id: string;
    }

}

export namespace servicemesh {
    export interface GetServiceMeshesMesh {
        /**
         * Cluster List.
         */
        clusters: string[];
        /**
         * The created time of the resource.
         */
        createTime: string;
        /**
         * Grid instance version type. Valid values: `Default` and `Pro`. `Default`:the standard. `Pro`:the Pro version.
         */
        edition: string;
        /**
         * The endpoint details.
         */
        endpoints: outputs.servicemesh.GetServiceMeshesMeshEndpoint[];
        /**
         * The Cause of the Error.
         */
        errorMessage: string;
        /**
         * The ID of the Service Mesh.
         */
        id: string;
        /**
         * The configuration of the Load Balancer.
         */
        loadBalancers: outputs.servicemesh.GetServiceMeshesMeshLoadBalancer[];
        /**
         * The configuration of the Service grid.
         */
        meshConfigs: outputs.servicemesh.GetServiceMeshesMeshMeshConfig[];
        /**
         * The configuration of the Service grid network.
         */
        networks: outputs.servicemesh.GetServiceMeshesMeshNetwork[];
        /**
         * The first ID of the resource.
         */
        serviceMeshId: string;
        /**
         * The name of the resource.
         */
        serviceMeshName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The version of the resource.
         */
        version: string;
    }

    export interface GetServiceMeshesMeshEndpoint {
        /**
         * The internal address of the API Server.
         */
        intranetApiServerEndpoint: string;
        /**
         * The internal address of the Istio Pilot.
         */
        intranetPilotEndpoint: string;
        /**
         * The public address of the API Server.
         */
        publicApiServerEndpoint: string;
        /**
         * The public address of the Istio Pilot.
         */
        publicPilotEndpoint: string;
    }

    export interface GetServiceMeshesMeshLoadBalancer {
        /**
         * The IP address of a public network exposed API Server corresponding to the Load Balance.
         */
        apiServerLoadbalancerId: string;
        /**
         * Whether to use the IP address of a public network exposed the API Server.
         */
        apiServerPublicEip: boolean;
        /**
         * Whether to use the IP address of a public network exposure the Istio Pilot.
         */
        pilotPublicEip: boolean;
        /**
         * The IP address of a public network exposure Istio Pilot corresponds to the Load Balance.
         */
        pilotPublicLoadbalancerId: string;
    }

    export interface GetServiceMeshesMeshMeshConfig {
        /**
         * The configuration of the access logging.
         */
        accessLogs: outputs.servicemesh.GetServiceMeshesMeshMeshConfigAccessLog[];
        /**
         * The configuration of the Service grid audit.
         */
        audits: outputs.servicemesh.GetServiceMeshesMeshMeshConfigAudit[];
        /**
         * Whether or not to enable the use of a custom zipkin.
         */
        customizedZipkin: boolean;
        /**
         * Whether to enable service can access the service through the nearest node access.
         */
        enableLocalityLb: boolean;
        /**
         * The IP ADDRESS range.
         */
        includeIpRanges: string;
        /**
         * The configuration of the Kiali.
         */
        kialis: outputs.servicemesh.GetServiceMeshesMeshMeshConfigKiali[];
        /**
         * The open-door policy of agent (OPA) plug-in information.
         */
        opas: outputs.servicemesh.GetServiceMeshesMeshMeshConfigOpa[];
        /**
         * The policy of the Out to the traffic. Valid values: `ALLOW_ANY` and `REGISTRY_ONLY`.
         */
        outboundTrafficPolicy: string;
        /**
         * The configuration of the Link trace sampling.
         */
        pilots: outputs.servicemesh.GetServiceMeshesMeshMeshConfigPilot[];
        /**
         * the configuration of the Prometheus.
         */
        prometheuses: outputs.servicemesh.GetServiceMeshesMeshMeshConfigPrometheus[];
        /**
         * The configuration of the Proxy.
         */
        proxies: outputs.servicemesh.GetServiceMeshesMeshMeshConfigProxy[];
        /**
         * The configuration of the Sidecar injector.
         */
        sidecarInjectors: outputs.servicemesh.GetServiceMeshesMeshMeshConfigSidecarInjector[];
        /**
         * Whether to enable acquisition Prometheus metrics.
         */
        telemetry: boolean;
        /**
         * Whether to enable link trace.
         */
        tracing: boolean;
    }

    export interface GetServiceMeshesMeshMeshConfigAccessLog {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
    }

    export interface GetServiceMeshesMeshMeshConfigAudit {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The Service grid audit that to the project.
         */
        project: string;
    }

    export interface GetServiceMeshesMeshMeshConfigKiali {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The service address of the Kiali.
         */
        url: string;
    }

    export interface GetServiceMeshesMeshMeshConfigOpa {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitCpu: string;
        /**
         * The memory limit  of the Sidecar injector Pods.
         */
        limitMemory: string;
        /**
         * The log level of the OPA proxy container .
         */
        logLevel: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface GetServiceMeshesMeshMeshConfigPilot {
        /**
         * Whether to support the HTTP1.0.
         */
        http10Enabled: boolean;
        /**
         * The  percentage of the Link trace sampling.
         */
        traceSampling: number;
    }

    export interface GetServiceMeshesMeshMeshConfigPrometheus {
        /**
         * The  service addresses of the Prometheus.
         */
        externalUrl: string;
        /**
         * Whether to enable external Prometheus.
         */
        useExternal: boolean;
    }

    export interface GetServiceMeshesMeshMeshConfigProxy {
        /**
         * The domain name of the Cluster.
         */
        clusterDomain: string;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitCpu: string;
        /**
         * The memory limit  of the Sidecar injector Pods.
         */
        limitMemory: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface GetServiceMeshesMeshMeshConfigSidecarInjector {
        /**
         * Whether to enable by Pod Annotations automatic injection Sidecar.
         */
        autoInjectionPolicyEnabled: boolean;
        /**
         * Whether it is the all namespaces you turn on the auto injection capabilities.
         */
        enableNamespacesByDefault: boolean;
        /**
         * The configuration of the CNI
         */
        initCniConfigurations: outputs.servicemesh.GetServiceMeshesMeshMeshConfigSidecarInjectorInitCniConfiguration[];
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitCpu: string;
        /**
         * The memory limit  of the Sidecar injector Pods.
         */
        limitMemory: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
        /**
         * Other automatic injection Sidecar configuration (in YAML format).
         */
        sidecarInjectorWebhookAsYaml: string;
    }

    export interface GetServiceMeshesMeshMeshConfigSidecarInjectorInitCniConfiguration {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The excluded namespace of the CNI.
         */
        excludeNamespaces: string;
    }

    export interface GetServiceMeshesMeshNetwork {
        /**
         * The ID of the Security group
         */
        securityGroupId: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The list of Virtual Switch.
         */
        vswitcheLists: string[];
    }

    export interface ServiceMeshLoadBalancer {
        apiServerLoadbalancerId: string;
        /**
         * Whether to use the IP address of a public network exposed the API Server.
         */
        apiServerPublicEip: boolean;
        /**
         * Whether to use the IP address of a public network exposure the Istio Pilot.
         */
        pilotPublicEip: boolean;
        pilotPublicLoadbalancerId: string;
    }

    export interface ServiceMeshMeshConfig {
        /**
         * The configuration of the access logging.
         */
        accessLog?: outputs.servicemesh.ServiceMeshMeshConfigAccessLog;
        /**
         * The configuration of the audit. See the following `Block audit`.
         */
        audit: outputs.servicemesh.ServiceMeshMeshConfigAudit;
        /**
         * Whether or not to enable the use of a custom zipkin.
         */
        customizedZipkin?: boolean;
        /**
         * The enable locality lb.
         */
        enableLocalityLb: boolean;
        /**
         * The configuration of the Kiali. See the following `Block kiali`.
         */
        kiali: outputs.servicemesh.ServiceMeshMeshConfigKiali;
        /**
         * The open-door policy of agent (OPA) plug-in information. See the following `Block opa`.
         */
        opa: outputs.servicemesh.ServiceMeshMeshConfigOpa;
        /**
         * The policy of the Out to the traffic. Valid values: `ALLOW_ANY` and `REGISTRY_ONLY`.
         */
        outboundTrafficPolicy: string;
        /**
         * The configuration of the Link trace sampling. See the following `Block pilot`.
         */
        pilot: outputs.servicemesh.ServiceMeshMeshConfigPilot;
        /**
         * The configuration of the Proxy. See the following `Block proxy`.
         */
        proxy: outputs.servicemesh.ServiceMeshMeshConfigProxy;
        /**
         * The configuration of the Sidecar injector. See the following `Block sidecarInjector`.
         */
        sidecarInjector: outputs.servicemesh.ServiceMeshMeshConfigSidecarInjector;
        /**
         * Whether to enable acquisition Prometheus metrics (it is recommended that you use [Alibaba Cloud Prometheus monitoring](https://arms.console.aliyun.com/).
         */
        telemetry: boolean;
        /**
         * Whether to enable link trace (you need to have [Alibaba Cloud link tracking service](https://tracing-analysis.console.aliyun.com/).
         */
        tracing: boolean;
    }

    export interface ServiceMeshMeshConfigAccessLog {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
    }

    export interface ServiceMeshMeshConfigAudit {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The Service grid audit that to the project.
         */
        project: string;
    }

    export interface ServiceMeshMeshConfigKiali {
        /**
         * Whether to enable Service grid audit.
         */
        enabled?: boolean;
    }

    export interface ServiceMeshMeshConfigOpa {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The CPU resource  of the limitsOPA proxy container.
         */
        limitCpu: string;
        /**
         * The memory resource limit of the OPA proxy container.
         */
        limitMemory: string;
        /**
         * The log level of the OPA proxy container .
         */
        logLevel: string;
        /**
         * The CPU resource request of the OPA proxy container.
         */
        requestCpu: string;
        /**
         * The memory resource request of the OPA proxy container.
         */
        requestMemory: string;
    }

    export interface ServiceMeshMeshConfigPilot {
        /**
         * Whether to support the HTTP1.0.
         */
        http10Enabled: boolean;
        /**
         * The  percentage of the Link trace sampling.
         */
        traceSampling?: number;
    }

    export interface ServiceMeshMeshConfigProxy {
        /**
         * The CPU resource  of the limitsOPA proxy container.
         */
        limitCpu: string;
        /**
         * The memory resource limit of the OPA proxy container.
         */
        limitMemory: string;
        /**
         * The CPU resource request of the OPA proxy container.
         */
        requestCpu: string;
        /**
         * The memory resource request of the OPA proxy container.
         */
        requestMemory: string;
    }

    export interface ServiceMeshMeshConfigSidecarInjector {
        /**
         * Whether to enable by Pod Annotations automatic injection Sidecar.
         */
        autoInjectionPolicyEnabled: boolean;
        /**
         * Whether it is the all namespaces you turn on the auto injection capabilities.
         */
        enableNamespacesByDefault: boolean;
        /**
         * The CPU resource  of the limitsOPA proxy container.
         */
        limitCpu?: string;
        /**
         * The memory resource limit of the OPA proxy container.
         */
        limitMemory?: string;
        /**
         * The CPU resource request of the OPA proxy container.
         */
        requestCpu?: string;
        /**
         * The memory resource request of the OPA proxy container.
         */
        requestMemory?: string;
    }

    export interface ServiceMeshNetwork {
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The list of Virtual Switch.
         */
        vswitcheList: string;
    }

}

export namespace simpleapplicationserver {
    export interface GetImagesImage {
        /**
         * The description of the image.
         */
        description: string;
        /**
         * The ID of the Instance Image.
         */
        id: string;
        /**
         * The ID of the image.
         */
        imageId: string;
        /**
         * The name of the resource.
         */
        imageName: string;
        /**
         * The type of the image. Valid values: `app`, `custom`, `system`.
         * * `system`: operating system (OS) image.
         * * `app`: application image.
         * * `custom`: custom image.
         */
        imageType: string;
    }

    export interface GetInstancesInstance {
        /**
         * The billing status of the simple application server. Valid values: `Normal`, `Expired` and `Overdue`.
         */
        businessStatus: string;
        /**
         * The time when the simple application server was created.
         */
        createTime: string;
        /**
         * The DDoS protection status. Valid values: `Normal`, `BlackHole`, and `Defense`.
         */
        ddosStatus: string;
        /**
         * The time when the simple application server expires.
         */
        expiredTime: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the simple application server Image.
         */
        imageId: string;
        /**
         * The internal IP address of the simple application server.
         */
        innerIpAddress: string;
        /**
         * The ID of the simple application server.
         */
        instanceId: string;
        /**
         * The name of the resource.
         */
        instanceName: string;
        /**
         * The billing method of the simple application server.
         */
        paymentType: string;
        /**
         * The ID of the simple application server plan.
         */
        planId: string;
        /**
         * The public IP address of the simple application server.
         */
        publicIpAddress: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetServerCustomImagesImage {
        /**
         * The first ID of the resource.
         */
        customImageId: string;
        /**
         * The name of the resource.
         */
        customImageName: string;
        /**
         * Image description information.
         */
        description: string;
        /**
         * The ID of the Custom Image.
         */
        id: string;
        /**
         * The type of operating system used by the Mirror. Valid values: `Linux`, `Windows`.
         */
        platform: string;
    }

    export interface GetServerDisksDisk {
        /**
         * Disk type. Possible values: `ESSD`, `SSD`.
         */
        category: string;
        /**
         * The time when the disk was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The device name of the disk on the simple application server.
         */
        device: string;
        /**
         * The first ID of the resource.
         */
        diskId: string;
        /**
         * The name of the resource.
         */
        diskName: string;
        /**
         * The type of the disk. Possible values: `System`, `Data`.
         */
        diskType: string;
        /**
         * The ID of the Disk.
         */
        id: string;
        /**
         * Alibaba Cloud simple application server instance ID.
         */
        instanceId: string;
        /**
         * The payment type of the resource. Valid values: `PayAsYouGo`, `Subscription`.
         */
        paymentType: string;
        /**
         * The size of the disk. Unit: `GB`.
         */
        size: number;
        /**
         * The status of the disk. Valid values: `ReIniting`, `Creating`, `In_Use`, `Available`, `Attaching`, `Detaching`.
         */
        status: string;
    }

    export interface GetServerFirewallRulesRule {
        /**
         * The ID of the firewall rule.
         */
        firewallRuleId: string;
        /**
         * The ID of the Firewall Rule. The value formats as `<instance_id>:<firewall_rule_id>`.
         */
        id: string;
        /**
         * Alibaba Cloud simple application server instance ID.
         */
        instanceId: string;
        /**
         * The port range of the firewall rule.
         */
        port: string;
        /**
         * The remarks of the firewall rule.
         */
        remark: string;
        /**
         * The transport layer protocol. Valid values: `Tcp`, `Udp`, `TcpAndUdp`.
         */
        ruleProtocol: string;
    }

    export interface GetServerPlansPlan {
        /**
         * The peak bandwidth. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * The number of CPU cores.
         */
        core: number;
        /**
         * The size of the enhanced SSD (ESSD). Unit: GB.
         */
        diskSize: number;
        /**
         * The monthly data transfer quota. Unit: GB.
         */
        flow: number;
        /**
         * The ID of the Instance Plan.
         */
        id: string;
        /**
         * The memory size. Unit: GB.
         */
        memory: number;
        /**
         * The ID of the Instance Plan.
         */
        planId: string;
    }

    export interface GetServerSnapshotsSnapshot {
        /**
         * The time when the snapshot was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The ID of the source disk. This parameter has a value even after the source disk is released.
         */
        diskId: string;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The progress of snapshot creation.
         */
        progress: string;
        /**
         * The remarks of the snapshot.
         */
        remark: string;
        /**
         * The ID of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * A snapshot of the source of a disk type. Possible values: `System`, `Data`.
         */
        sourceDiskType: string;
        /**
         * The status of the snapshots. Valid values: `Progressing`, `Accomplished` and `Failed`.
         */
        status: string;
    }

}

export namespace slb {
    export interface AclEntryList {
        comment?: string;
        entry: string;
    }

    export interface BackendServerBackendServer {
        serverId: string;
        serverIp?: string;
        type?: string;
        weight: number;
    }

    export interface GetAclsAcl {
        /**
         * A list of entry (IP addresses or CIDR blocks).  Each entry contains two sub-fields as `Entry Block` follows.
         */
        entryLists: outputs.slb.GetAclsAclEntryList[];
        /**
         * Acl ID.
         */
        id: string;
        ipVersion: string;
        /**
         * Acl name.
         */
        name: string;
        /**
         * A list of listener are attached by the acl.  Each listener contains four sub-fields as `Listener Block` follows.
         */
        relatedListeners: outputs.slb.GetAclsAclRelatedListener[];
        /**
         * The Id of resource group which acl belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetAclsAclEntryList {
        comment: string;
        entry: string;
    }

    export interface GetAclsAclRelatedListener {
        aclType: string;
        frontendPort: number;
        loadBalancerId: string;
        protocol: string;
    }

    export interface GetApplicationLoadBalancersBalancer {
        /**
         * Service address of the SLBs.
         */
        address: string;
        /**
         * The address ip version. Valid values `ipv4` and `ipv6`.
         */
        addressIpVersion: string;
        /**
         * The address type of the SLB. Valid values `internet` and `intranet`.
         */
        addressType: string;
        /**
         * The auto release time.
         */
        autoReleaseTime: number;
        /**
         * The backend servers of the SLB.
         */
        backendServers: outputs.slb.GetApplicationLoadBalancersBalancerBackendServer[];
        /**
         * The bandwidth of the SLB.
         */
        bandwidth: number;
        /**
         * The create time stamp of the SLB.
         */
        createTimeStamp: number;
        /**
         * Whether the SLB should delete protection.
         */
        deleteProtection: string;
        /**
         * The end time of the SLB.
         */
        endTime: string;
        /**
         * The end time stamp of the SLB.
         */
        endTimeStamp: number;
        /**
         * ID of the SLB.
         */
        id: string;
        /**
         * The internet charge type. Valid values `PayByBandwidth` and `PayByTraffic`.
         */
        internetChargeType: string;
        /**
         * The listener ports and protocal of the SLB.
         */
        listenerPortsAndProtocals: outputs.slb.GetApplicationLoadBalancersBalancerListenerPortsAndProtocal[];
        /**
         * The listener ports and protocol of the SLB.
         */
        listenerPortsAndProtocols: outputs.slb.GetApplicationLoadBalancersBalancerListenerPortsAndProtocol[];
        /**
         * Thd ID of the SLB.
         */
        loadBalancerId: string;
        /**
         * The name of the SLB.
         */
        loadBalancerName: string;
        /**
         * The specification of the SLB.
         */
        loadBalancerSpec: string;
        /**
         * The master zone id of the SLB.
         */
        masterZoneId: string;
        /**
         * The reason of modification protection.
         */
        modificationProtectionReason: string;
        /**
         * The status of modification protection.
         */
        modificationProtectionStatus: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        /**
         * The payment type of SLB. Valid values `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * Region ID the SLB belongs to.
         */
        regionIdAlias: string;
        /**
         * The renewal cyc unit of the SLB.
         */
        renewalCycUnit: string;
        /**
         * The renewal duration of the SLB.
         */
        renewalDuration: number;
        /**
         * The renewal status of the SLB.
         */
        renewalStatus: string;
        /**
         * The Id of resource group which SLB belongs.
         */
        resourceGroupId: string;
        /**
         * The slave zone id of the SLB.
         */
        slaveZoneId: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetApplicationLoadBalancersBalancerBackendServer {
        /**
         * The description of protocol.
         */
        description: string;
        /**
         * The server ID.
         */
        serverId: string;
        /**
         * The type of servers.
         */
        type: string;
        /**
         * The weight of servers.
         */
        weight: number;
    }

    export interface GetApplicationLoadBalancersBalancerListenerPortsAndProtocal {
        /**
         * The listener port.
         */
        listenerPort: number;
        /**
         * The listener protoal.
         */
        listenerProtocal: string;
    }

    export interface GetApplicationLoadBalancersBalancerListenerPortsAndProtocol {
        /**
         * The description of protocol.
         */
        description: string;
        /**
         * The forward port.
         */
        forwardPort: number;
        /**
         * The listener forward.
         */
        listenerForward: string;
        /**
         * The listener port.
         */
        listenerPort: number;
        /**
         * The listener protocol.
         */
        listenerProtocol: string;
    }

    export interface GetApplicationLoadBalancersSlb {
        /**
         * Service address of the SLBs.
         */
        address: string;
        creationTime: string;
        /**
         * ID of the SLB.
         */
        id: string;
        internet: boolean;
        masterAvailabilityZone: string;
        name: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        regionId: string;
        slaveAvailabilityZone: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetAttachmentsSlbAttachment {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetBackendServersBackendServer {
        /**
         * backend server ID.
         */
        id: string;
        /**
         * Type of the backend server.
         */
        serverType: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetCaCertificatesCertificate {
        /**
         * (Available in v1.123.1+) CA certificate ID.
         */
        caCertificateId: string;
        /**
         * (Available in v1.123.1+) CA certificate name.
         */
        caCertificateName: string;
        /**
         * CA certificate common name.
         */
        commonName: string;
        /**
         * CA certificate created timestamp.
         */
        createdTimestamp: number;
        /**
         * CA certificate expired time.
         */
        expiredTime: string;
        /**
         * CA certificate expired timestamp.
         */
        expiredTimestamp: number;
        /**
         * CA certificate fingerprint.
         */
        fingerprint: string;
        /**
         * CA certificate ID.
         */
        id: string;
        /**
         * (Deprecated from v1.123.1) Deprecated and replace by `caCertificateName`.
         */
        name: string;
        /**
         * The Id of resource group which ca certificates belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetDomainExtensionsExtension {
        /**
         * The domain name.
         */
        domain: string;
        /**
         * The ID of the domain extension.
         */
        id: string;
        /**
         * The ID of the certificate used by the domain name.
         */
        serverCertificateId: string;
    }

    export interface GetListenersSlbListener {
        /**
         * Port opened on the backend server to receive requests.
         */
        backendPort: number;
        /**
         * Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
         */
        bandwidth: number;
        /**
         * ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
         */
        caCertificateId: string;
        /**
         * Cookie configured by the backend server. Only available when the stickySessionType is `server`.
         */
        cookie: string;
        /**
         * Cookie timeout in seconds. Only available when the stickySessionType is `insert`.
         */
        cookieTimeout: number;
        /**
         * The description of slb listener.
         */
        description: string;
        /**
         * Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
         */
        enableHttp2: string;
        /**
         * Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
         */
        establishedTimeout: number;
        /**
         * Filter listeners by the specified frontend port.
         */
        frontendPort: number;
        /**
         * Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        gzip: string;
        /**
         * Indicate whether health check is enabled of not. Possible values are `on` and `off`.
         */
        healthCheck: string;
        /**
         * Port used for health check.
         */
        healthCheckConnectPort: number;
        /**
         * Amount of time in seconds to wait for the response for a health check.
         */
        healthCheckConnectTimeout: number;
        /**
         * Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckDomain: string;
        /**
         * HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as "http_2xx,http_3xx". Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckHttpCode: string;
        /**
         * Time interval between two consecutive health checks.
         */
        healthCheckInterval: number;
        /**
         * Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
         */
        healthCheckTimeout: number;
        /**
         * Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
         */
        healthCheckType: string;
        /**
         * URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckUri: string;
        /**
         * Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
         */
        healthyThreshold: number;
        /**
         * Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
         */
        idleTimeout: number;
        /**
         * ID of the active/standby server group.
         */
        masterSlaveServerGroupId: string;
        /**
         * Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
         */
        persistenceTimeout: number;
        /**
         * Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
         */
        protocol: string;
        /**
         * Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
         */
        requestTimeout: number;
        /**
         * Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
         */
        scheduler: string;
        /**
         * Security status. Only available when the protocol is `https`.
         */
        securityStatus: string;
        serverCertificateId: string;
        /**
         * ID of the linked VServer group.
         */
        serverGroupId: string;
        /**
         * ID of the server certificate. Only available when the protocol is `https`.
         */
        sslCertificateId: string;
        /**
         * Listener status.
         */
        status: string;
        /**
         * Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        stickySession: string;
        /**
         * Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and stickySession is `on`.
         */
        stickySessionType: string;
        /**
         * Https listener TLS cipher policy. Valid values are `tlsCipherPolicy10`, `tlsCipherPolicy11`, `tlsCipherPolicy12`, `tlsCipherPolicy12Strict`. Default to `tlsCipherPolicy10`.
         */
        tlsCipherPolicy: string;
        /**
         * Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
         */
        unhealthyThreshold: number;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For" is added or not; it allows the backend server to know about the user's IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedFor: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_SLBID" is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbId: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_SLBIP" is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbIp: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_proto" is added or not; it allows the backend server to know about the user's protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbProto: string;
    }

    export interface GetLoadBalancersBalancer {
        /**
         * Service address of the SLBs.
         */
        address: string;
        addressIpVersion: string;
        addressType: string;
        autoReleaseTime: number;
        backendServers: outputs.slb.GetLoadBalancersBalancerBackendServer[];
        bandwidth: number;
        createTimeStamp: number;
        deleteProtection: string;
        endTime: string;
        endTimeStamp: number;
        /**
         * ID of the SLB.
         */
        id: string;
        internetChargeType: string;
        listenerPortsAndProtocals: outputs.slb.GetLoadBalancersBalancerListenerPortsAndProtocal[];
        listenerPortsAndProtocols: outputs.slb.GetLoadBalancersBalancerListenerPortsAndProtocol[];
        loadBalancerId: string;
        loadBalancerName: string;
        loadBalancerSpec: string;
        masterZoneId: string;
        modificationProtectionReason: string;
        modificationProtectionStatus: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        paymentType: string;
        regionIdAlias: string;
        renewalCycUnit: string;
        renewalDuration: number;
        renewalStatus: string;
        /**
         * The Id of resource group which SLB belongs.
         */
        resourceGroupId: string;
        slaveZoneId: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = pulumi.output(alicloud.slb.getLoadBalancers({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetLoadBalancersBalancerBackendServer {
        description: string;
        serverId: string;
        type: string;
        weight: number;
    }

    export interface GetLoadBalancersBalancerListenerPortsAndProtocal {
        listenerPort: number;
        listenerProtocal: string;
    }

    export interface GetLoadBalancersBalancerListenerPortsAndProtocol {
        description: string;
        forwardPort: number;
        listenerForward: string;
        listenerPort: number;
        listenerProtocol: string;
    }

    export interface GetLoadBalancersSlb {
        /**
         * Service address of the SLBs.
         */
        address: string;
        /**
         * SLB creation time.
         */
        creationTime: string;
        /**
         * ID of the SLB.
         */
        id: string;
        /**
         * SLB addressType: internet if `true`, intranet if `false`. Must be `false` when `networkType` is `vpc`.
         */
        internet: boolean;
        /**
         * Master availability zone of the SLBs.
         */
        masterAvailabilityZone: string;
        /**
         * SLB name.
         */
        name: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        /**
         * Region ID the SLB belongs to.
         */
        regionId: string;
        /**
         * Slave availability zone of the SLBs.
         */
        slaveAvailabilityZone: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = pulumi.output(alicloud.slb.getLoadBalancers({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetMasterSlaveServerGroupsGroup {
        /**
         * master slave server group ID.
         */
        id: string;
        /**
         * master slave server group name.
         */
        name: string;
        /**
         * ECS instances associated to the group. Each element contains the following attributes:
         */
        servers: outputs.slb.GetMasterSlaveServerGroupsGroupServer[];
    }

    export interface GetMasterSlaveServerGroupsGroupServer {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * (Removed from v1.63.0) Determine if the server is executing.
         */
        isBackup: number;
        /**
         * The port used by the master slave server group.
         */
        port: number;
        /**
         * The server type of the attached ECS instance.
         */
        serverType: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetRulesSlbRule {
        /**
         * Domain name in the HTTP request where the rule applies (e.g. "*.aliyun.com").
         */
        domain: string;
        /**
         * Rule ID.
         */
        id: string;
        /**
         * Rule name.
         */
        name: string;
        /**
         * ID of the linked VServer group.
         */
        serverGroupId: string;
        /**
         * Path in the HTTP request where the rule applies (e.g. "/image").
         */
        url: string;
    }

    export interface GetServerCertificatesCertificate {
        /**
         * Id of server certificate issued by alibaba cloud.
         * * `alicloudCertificateName`- Name of server certificate issued by alibaba cloud.
         * * `isAlicloudCertificate`- Is server certificate issued by alibaba cloud or not.
         */
        alicloudCertificateId: string;
        alicloudCertificateName: string;
        /**
         * Server certificate common name.
         */
        commonName: string;
        /**
         * Server certificate created time.
         */
        createdTime: string;
        /**
         * Server certificate created timestamp.
         */
        createdTimestamp: number;
        /**
         * Server certificate expired time.
         */
        expiredTime: string;
        /**
         * Server certificate expired timestamp.
         */
        expiredTimestamp: number;
        /**
         * Server certificate fingerprint.
         */
        fingerprint: string;
        /**
         * Server certificate ID.
         */
        id: string;
        isAlicloudCertificate: boolean;
        /**
         * Server certificate name.
         */
        name: string;
        /**
         * The Id of resource group which the slb server certificates belongs.
         */
        resourceGroupId?: string;
        /**
         * Server certificate subject alternative name list.
         */
        subjectAlternativeNames: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetServerGroupsSlbServerGroup {
        /**
         * VServer group ID.
         */
        id: string;
        /**
         * VServer group name.
         */
        name: string;
        /**
         * ECS instances associated to the group. Each element contains the following attributes:
         */
        servers: outputs.slb.GetServerGroupsSlbServerGroupServer[];
    }

    export interface GetServerGroupsSlbServerGroupServer {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetTlsCipherPoliciesPolicy {
        /**
         * The encryption algorithms supported. It depends on the value of `tlsVersions`.
         */
        ciphers: string[];
        /**
         * The creation time timestamp.
         */
        createTime: string;
        /**
         * The ID of the Tls Cipher Policy.
         */
        id: string;
        /**
         * Array of Relate Listeners.
         */
        relateListeners: outputs.slb.GetTlsCipherPoliciesPolicyRelateListener[];
        /**
         * TLS policy instance state.
         */
        status: string;
        /**
         * The ID of TLS cipher policy.
         */
        tlsCipherPolicyId: string;
        /**
         * TLS policy name. Length is from 2 to 128, or in both the English and Chinese characters must be with an uppercase/lowercase letter or a Chinese character and the beginning, may contain numbers, in dot `.`, underscore `_` or dash `-`.
         */
        tlsCipherPolicyName: string;
        /**
         * The version of TLS protocol.
         */
        tlsVersions: string[];
    }

    export interface GetTlsCipherPoliciesPolicyRelateListener {
        /**
         * The ID of SLB instance.
         */
        loadBalancerId: string;
        /**
         * Listening port. Valid value: 1 to 65535.
         */
        port: number;
        /**
         * Snooping protocols. Valid values: `TCP`, `UDP`, `HTTP`, or `HTTPS`.
         */
        protocol: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of slb slave zone ids in which the slb master zone.
         */
        slbSlaveZoneIds: string[];
    }

    export interface ListenerXForwardedFor {
        retriveClientIp: boolean;
        /**
         * Whether to use the XForwardedFor header to obtain the ID of the SLB instance. Default to false.
         */
        retriveSlbId?: boolean;
        /**
         * Whether to use the XForwardedFor_SLBIP header to obtain the public IP address of the SLB instance. Default to false.
         */
        retriveSlbIp?: boolean;
        /**
         * Whether to use the XForwardedFor_proto header to obtain the protocol used by the listener. Default to false.
         */
        retriveSlbProto?: boolean;
    }

    export interface MasterSlaveServerGroupServer {
        isBackup?: number;
        port: number;
        serverId: string;
        serverType?: string;
        type?: string;
        weight?: number;
    }

    export interface ServerGroupServer {
        port: number;
        serverIds: string[];
        type?: string;
        weight?: number;
    }
}

export namespace tsdb {
    export interface GetInstancesInstance {
        /**
         * Auto renew.
         */
        autoRenew: string;
        /**
         * The cpu core number of instance.
         */
        cpuNumber: string;
        /**
         * The disk type of instance. `cloudSsd` refers to SSD disk, `cloudEfficiency` refers to efficiency disk,cloud_essd refers to ESSD PL1 disk.
         */
        diskCategory: string;
        /**
         * The engine type of instance. Enumerative: `tsdbTsdb` refers to TSDB, `tsdbInfluxdb` refers to TSDB for InfluxDB️.
         */
        engineType: string;
        /**
         * Instance expiration time.
         */
        expiredTime: number;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The alias of the instance.
         */
        instanceAlias: string;
        /**
         * The specification of the instance.
         */
        instanceClass: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The storage capacity of the instance. Unit: GB. For example, the value 50 indicates 50 GB.
         */
        instanceStorage: string;
        /**
         * The memory size of instance.
         */
        memorySize: string;
        /**
         * Instance network type.
         */
        networkType: string;
        /**
         * The billing method. Valid values: `PayAsYouGo` and `Subscription`. The `PayAsYouGo` value indicates the pay-as-you-go method, and the `Subscription` value indicates the subscription method.
         */
        paymentType: string;
        /**
         * Instance status, enumerative: ACTIVATION,DELETED, CREATING,CLASS_CHANGING,LOCKED.
         */
        status: string;
        /**
         * The vpc connection address of instance.
         */
        vpcConnectionAddress: string;
        /**
         * The ID of the virtual private cloud (VPC) that is connected to the instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * The ID of zone.
         */
        id: string;
        /**
         * The local name.
         */
        localName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

}

export namespace videosurveillance {
    export interface GetSystemGroupsGroup {
        /**
         * The App Name of Group.
         */
        app: string;
        /**
         * The space within the device status update of the callback, need to start with http:// or https:// at the beginning.
         */
        callback: string;
        /**
         * The creation time of the Group.
         */
        createTime: string;
        /**
         * The description of the Group.
         */
        description: string;
        /**
         * Whether to open Group.
         */
        enabled: boolean;
        /**
         * Space of national standard ID. **NOTE:** Available only in the national standard access space.
         */
        gbId: string;
        /**
         * Space of national standard signaling server address. **NOTE:** Available only in the national standard access space.
         */
        gbIp: string;
        /**
         * The ID of Group.
         */
        groupId: string;
        /**
         * The name of Group.
         */
        groupName: string;
        /**
         * The ID of the Group.
         */
        id: string;
        /**
         * The use of the access protocol support `gb28181`,`rtmp`(Real Time Messaging Protocol).
         */
        inProtocol: string;
        /**
         * The use of space play Protocol multi-valued separate them with commas (,). Valid values: `flv`,`hls`, `rtmp`(Real Time Messaging Protocol).
         */
        outProtocol: string;
        /**
         * -The domain name of plan streaming used by the group.
         */
        playDomain: string;
        /**
         * The domain name of push streaming used by the group.
         */
        pushDomain: string;
        /**
         * The Device statistics of Group.
         */
        stats: outputs.videosurveillance.GetSystemGroupsGroupStat[];
    }

    export interface GetSystemGroupsGroupStat {
        /**
         * The total number of devices in the group.
         */
        deviceNum: string;
        /**
         * The total number of smart devices in the group.
         */
        iedNum: string;
        /**
         * The total number of cameras in the group.
         */
        ipcNum: string;
        /**
         * The total number of platforms in the group.
         */
        platformNum: string;
    }

}

export namespace vod {
    export interface DomainSource {
        /**
         * The address of the origin server. You can specify an IP address or a domain name.
         */
        sourceContent: string;
        /**
         * The port number. You can specify port 443 or 80. **Default value: 80**. If you specify port 443, Alibaba Cloud CDN communicates with the origin server over HTTPS. You can also customize a port.
         */
        sourcePort: string;
        /**
         * The priority of the origin server if multiple origin servers are specified. Valid values: `20` and `30`. **Default value: 20**. A value of 20 indicates that the origin server is the primary origin server. A value of 30 indicates that the origin server is a secondary origin server.
         */
        sourcePriority: string;
        /**
         * The type of the origin server. Valid values:
         */
        sourceType: string;
    }

    export interface GetDomainsDomain {
        /**
         * The CNAME that is assigned to the domain name for CDN. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name for CDN to the CNAME.
         */
        cname: string;
        /**
         * The description of the domain name for CDN.
         */
        description: string;
        /**
         * The domain name for CDN.
         */
        domainName: string;
        /**
         * The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        gmtCreated: string;
        /**
         * The last time when the domain name for CDN was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        gmtModified: string;
        /**
         * The ID of the Domain. Its value is same as Queue Name.
         */
        id: string;
        /**
         * Indicates whether the domain name for CDN is in a sandbox environment.
         */
        sandBox: string;
        /**
         * The information about the address of the origin server. For more information about the Sources parameter, See the following `Block sources`.
         */
        sources: outputs.vod.GetDomainsDomainSource[];
        /**
         * Indicates whether the Secure Sockets Layer (SSL) certificate is enabled. Valid values: `on`,`off`.
         */
        sslProtocol: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetDomainsDomainSource {
        sourceContent: string;
        sourcePort: string;
        sourcePriority: string;
        sourceType: string;
    }

}

export namespace vpc {
    export interface DhcpOptionsSetAssociateVpc {
        /**
         * The status of the VPC network that is associated with the DHCP options set. Valid values:`InUse` or `Pending`. `InUse`: The VPC network is in use. `Pending`: The VPC network is being configured.
         */
        associateStatus: string;
        /**
         * The ID of the VPC network that is associated with the DHCP options set.
         */
        vpcId?: string;
    }

    export interface GetCommonBandwidthPackagesPackage {
        /**
         * The peak bandwidth of the Internet Shared Bandwidth instance.
         */
        bandwidth: string;
        /**
         * The resource ID of bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * The name of bandwidth package.
         */
        bandwidthPackageName: string;
        /**
         * The business status of the Common Bandwidth Package instance.
         */
        businessStatus: string;
        /**
         * The deletion protection of bandwidth package.
         */
        deletionProtection: boolean;
        /**
         * The description of the Common Bandwidth Package instance.
         */
        description: string;
        /**
         * The expired time of bandwidth package.
         */
        expiredTime: string;
        /**
         * Is has reservation data.
         */
        hasReservationData: boolean;
        /**
         * ID of the Common Bandwidth Package.
         */
        id: string;
        /**
         * The internet charge type of bandwidth package.
         */
        internetChargeType: string;
        /**
         * ISP of the Common Bandwidth Package.
         */
        isp: string;
        /**
         * Name of the Common Bandwidth Package.
         */
        name: string;
        /**
         * The payment type of bandwidth package.
         */
        paymentType: string;
        /**
         * Public ip addresses that in the Common Bandwidth Pakcage.
         */
        publicIpAddresses: outputs.vpc.GetCommonBandwidthPackagesPackagePublicIpAddress[];
        /**
         * The ratio of bandwidth package.
         */
        ratio: number;
        /**
         * The active time of reservation.
         */
        reservationActiveTime: string;
        /**
         * The bandwidth of reservation.
         */
        reservationBandwidth: string;
        /**
         * The charge type of reservation internet.
         */
        reservationInternetChargeType: string;
        /**
         * The type of reservation order.
         */
        reservationOrderType: string;
        /**
         * The Id of resource group which the common bandwidth package belongs.
         */
        resourceGroupId: string;
        /**
         * The service managed.
         */
        serviceManaged: number;
        /**
         * The status of bandwidth package. Valid values: `Available` and `Pending`.
         */
        status: string;
    }

    export interface GetCommonBandwidthPackagesPackagePublicIpAddress {
        allocationId: string;
        bandwidthPackageIpRelationStatus: string;
        ipAddress: string;
    }

    export interface GetDhcpOptionsSetsSet {
        /**
         * AssociateVpcs.
         */
        associateVpcs: outputs.vpc.GetDhcpOptionsSetsSetAssociateVpc[];
        /**
         * The description of the DHCP options set. The description must be 2 to 256
         * characters in length and cannot start with `http://` or `https://`.
         */
        dhcpOptionsSetDescription: string;
        dhcpOptionsSetId: string;
        /**
         * The root domain, for example, example.com. After a DHCP options set is associated with a
         * Virtual Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the
         * ECS instances in the VPC network.
         */
        dhcpOptionsSetName: string;
        /**
         * The root domain, for example, example.com. After a DHCP options set is associated with a Virtual
         * Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the ECS
         * instances in the VPC network.
         */
        domainName: string;
        /**
         * The DNS server IP addresses. Up to four DNS server IP addresses can be specified. IP
         * addresses must be separated with commas (,).
         */
        domainNameServers: string;
        id: string;
        /**
         * The ID of the account to which the DHCP options set belongs.
         */
        ownerId: string;
        /**
         * The status of the DHCP options set. Valid values: `Available`, `InUse` or `Pending`. `Available`: The DHCP options set is available for use. `InUse`: The DHCP options set is in use. `Pending`: The DHCP options set is being configured.
         */
        status: string;
    }

    export interface GetDhcpOptionsSetsSetAssociateVpc {
        /**
         * The status of the VPC network that is associated with the DHCP options set. Valid values:`InUse` or `Pending`. `InUse`: The VPC network is in use. `Pending`: The VPC network is being configured.
         */
        associateStatus: string;
        /**
         * The ID of the VPC network that is associated with the DHCP options set.
         */
        vpcId: string;
    }

    export interface GetEnhancedNatAvailableZonesZone {
        localName: string;
        zoneId: string;
    }

    export interface GetForwardEntriesEntry {
        /**
         * The public IP address.
         */
        externalIp: string;
        /**
         * The public port.
         */
        externalPort: string;
        /**
         * The forward entry ID.
         */
        forwardEntryId: string;
        /**
         * The name of forward entry.
         */
        forwardEntryName: string;
        /**
         * The ID of the Forward Entry.
         */
        id: string;
        /**
         * The private IP address.
         */
        internalIp: string;
        /**
         * The internal port.
         */
        internalPort: string;
        /**
         * The ip protocol. Valid values: `any`,`tcp` and `udp`.
         */
        ipProtocol: string;
        /**
         * The forward entry name.
         */
        name: string;
        /**
         * The status of farward entry. Valid value `Available`, `Deleting` and `Pending`.
         */
        status: string;
    }

    export interface GetHavipsHavip {
        /**
         * EIP bound to HaVip.
         */
        associatedEipAddresses: string[];
        /**
         * An ECS instance that is bound to HaVip.
         */
        associatedInstances: string[];
        /**
         * Dependence of a HaVip instance.
         */
        description: string;
        /**
         * The  ID of the resource.
         */
        havipId: string;
        /**
         * The name of the HaVip instance.
         */
        havipName: string;
        /**
         * The ID of the Ha Vip.
         */
        id: string;
        /**
         * IP address of private network.
         */
        ipAddress: string;
        /**
         * The primary instance ID bound to HaVip.
         */
        masterInstanceId: string;
        /**
         * The status.
         */
        status: string;
        /**
         * The VPC ID to which the HaVip instance belongs.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetIpv6AddressesAddress {
        /**
         * The ID of the instance that is assigned the IPv6 address.
         */
        associatedInstanceId: string;
        /**
         * The type of the instance that is assigned the IPv6 address.
         */
        associatedInstanceType: string;
        /**
         * The time when the IPv6 address was created.
         */
        createTime: string;
        /**
         * The ID of the Ipv6 Address.
         */
        id: string;
        /**
         * The address of the Ipv6 Address.
         */
        ipv6Address: string;
        /**
         * The ID of the IPv6 address.
         */
        ipv6AddressId: string;
        /**
         * The name of the IPv6 address.
         */
        ipv6AddressName: string;
        /**
         * The ID of the IPv6 gateway to which the IPv6 address belongs.
         */
        ipv6GatewayId: string;
        /**
         * The type of communication supported by the IPv6 address. Valid values:`Private` or `Public`. `Private`: communication within the private network. `Public`: communication over the public network
         */
        networkType: string;
        /**
         * The status of the IPv6 address. Valid values:`Pending` or `Available`.
         */
        status: string;
        /**
         * The ID of the VPC to which the IPv6 address belongs.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch to which the IPv6 address belongs.
         */
        vswitchId: string;
    }

    export interface GetIpv6EgressRulesRule {
        /**
         * The description of the egress-only rule.
         */
        description: string;
        /**
         * The ID of the Ipv6 Egress Rule. The value formats as `<ipv6_gateway_id>:<ipv6_egress_rule_id>`.
         */
        id: string;
        /**
         * The ID of the instance to which the egress-only rule is applied.
         */
        instanceId: string;
        /**
         * The type of the instance to which the egress-only rule is applied.
         */
        instanceType: string;
        /**
         * The first ID of the resource.
         */
        ipv6EgressRuleId: string;
        /**
         * The name of the resource.
         */
        ipv6EgressRuleName: string;
        /**
         * The ID of the IPv6 gateway.
         */
        ipv6GatewayId: string;
        /**
         * The status of the resource. Valid values: `Available`, `Pending` and `Deleting`.
         */
        status: string;
    }

    export interface GetIpv6GatewaysGateway {
        /**
         * The status of the IPv6 gateway. Valid values:`Normal`, `FinancialLocked` and `SecurityLocked`. `Normal`: working as expected. `FinancialLocked`: locked due to overdue payments. `SecurityLocked`: locked due to security reasons.
         */
        businessStatus: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description of the IPv6 gateway.
         */
        description: string;
        /**
         * The time when the IPv6 gateway expires.
         */
        expiredTime: string;
        /**
         * The ID of the Ipv6 Gateway.
         */
        id: string;
        /**
         * The metering method of the IPv6 gateway. Valid values: `PayAsYouGo`.
         */
        instanceChargeType: string;
        /**
         * The first ID of the resource.
         */
        ipv6GatewayId: string;
        /**
         * The name of the IPv6 gateway.
         */
        ipv6GatewayName: string;
        /**
         * The specification of the IPv6 gateway. Valid values: `Large`, `Medium` and `Small`. `Small` (default): Free Edition. `Medium`: Enterprise Edition . `Large`: Enhanced Enterprise Edition. The throughput capacity of an IPv6 gateway varies based on the edition. For more information, see [Editions of IPv6 gateways](https://www.alibabacloud.com/help/doc-detail/98926.htm).
         */
        spec: string;
        /**
         * The status of the IPv6 gateway. Valid values: `Available`, `Deleting`, `Pending`.
         */
        status: string;
        /**
         * The ID of the virtual private cloud (VPC) to which the IPv6 gateway belongs.
         */
        vpcId: string;
    }

    export interface GetIpv6InternetBandwidthsBandwidth {
        /**
         * The amount of Internet bandwidth resources of the IPv6 address, Unit: `Mbit/s`.
         */
        bandwidth: number;
        /**
         * The ID of the Ipv6 Internet Bandwidth.
         */
        id: string;
        /**
         * The metering method of the Internet bandwidth resources of the IPv6 gateway.
         */
        internetChargeType: string;
        /**
         * The ID of the IPv6 address.
         */
        ipv6AddressId: string;
        /**
         * The ID of the IPv6 gateway.
         */
        ipv6GatewayId: string;
        /**
         * The ID of the Ipv6 Internet Bandwidth.
         */
        ipv6InternetBandwidthId: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The status of the resource. Valid values: `Normal`, `FinancialLocked` and `SecurityLocked`.
         */
        status: string;
    }

    export interface GetNatGatewaysGateway {
        /**
         * The state of the NAT gateway.
         */
        businessStatus: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The description of the NAT gateway.
         */
        description: string;
        /**
         * Indicates whether the traffic monitoring feature is enabled.
         */
        ecsMetricEnabled: boolean;
        /**
         * The time when the NAT gateway expires.
         */
        expiredTime: string;
        /**
         * The ID of the DNAT table.
         */
        forwardTableIds: string[];
        /**
         * The ID of the NAT gateway.
         */
        id: string;
        /**
         * The metering method of the NAT gateway.
         */
        internetChargeType: string;
        /**
         * The ip address of the bind eip.
         */
        ipLists: string[];
        /**
         * Name of the NAT gateway.
         */
        name: string;
        /**
         * The ID of the NAT gateway.
         */
        natGatewayId: string;
        /**
         * The name of NAT gateway.
         */
        natGatewayName: string;
        /**
         * The nat type of NAT gateway. Valid values `Enhanced` and `Normal`.
         */
        natType: string;
        /**
         * (Available in 1.137.0+) Indicates the type of the created NAT gateway. Valid values `internet` and `intranet`.
         */
        networkType: string;
        /**
         * The payment type of NAT gateway. Valid values `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * The resource group id of NAT gateway.
         */
        resourceGroupId: string;
        /**
         * The ID of the SNAT table that is associated with the NAT gateway.
         */
        snatTableIds: string[];
        /**
         * The specification of the NAT gateway.
         */
        spec: string;
        /**
         * The specification of NAT gateway. Valid values `Middle`, `Large`, `Small` and `XLarge.1`. Default value is `Small`.
         */
        specification: string;
        /**
         * The status of NAT gateway. Valid values `Available`, `Converting`, `Creating`, `Deleting` and `Modifying`.
         */
        status: string;
        /**
         * The tags of NAT gateway.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch to which the NAT gateway belongs.
         */
        vswitchId: string;
    }

    export interface GetNatIpCidrsCidr {
        /**
         * The time when the CIDR block was created.
         */
        createTime: string;
        /**
         * The ID of the Nat Ip Cidr.
         */
        id: string;
        /**
         * Whether it is the default NAT IP ADDRESS. Valid values:`true` or `false`.`true`: is the default NAT IP ADDRESS. `false`: it is not the default NAT IP ADDRESS.
         */
        isDefault: boolean;
        /**
         * The ID of the VPC NAT gateway.
         */
        natGatewayId: string;
        /**
         * The NAT CIDR block to be created. The CIDR block must meet the following conditions: It must be `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`, or one of their subnets. The subnet mask must be `16` to `32` bits in lengths. To use a public CIDR block as the NAT CIDR block, the VPC to which the VPC NAT gateway belongs must be authorized to use public CIDR blocks. For more information, see [Create a VPC NAT gateway](https://www.alibabacloud.com/help/doc-detail/268230.htm).
         */
        natIpCidr: string;
        /**
         * NAT IP ADDRESS range to the description of. Length is from `2` to `256` characters, must start with a letter or the Chinese at the beginning, but not at the` http://` Or `https://` at the beginning.
         */
        natIpCidrDescription: string;
        /**
         * NAT IP ADDRESS instance ID.
         */
        natIpCidrId: string;
        /**
         * NAT IP ADDRESS the name of the root directory. Length is from `2` to `128` characters, must start with a letter or the Chinese at the beginning can contain numbers, half a period (.), underscore (_) and dash (-). But do not start with `http://` or `https://` at the beginning.
         */
        natIpCidrName: string;
        /**
         * The status of the CIDR block of the NAT gateway. If the value is `Available`, the CIDR block is available.
         */
        status: string;
    }

    export interface GetNatIpsIp {
        /**
         * The ID of the Nat Ip.
         */
        id: string;
        /**
         * Indicates whether the BGP Group is the default NAT IP ADDRESS. Valid values: `true`: is the default NAT IP ADDRESS. `false`: it is not the default NAT IP ADDRESS.
         */
        isDefault: boolean;
        /**
         * The ID of the Virtual Private Cloud (VPC) NAT gateway to which the NAT IP address belongs.
         */
        natGatewayId: string;
        /**
         * The NAT IP address that is queried.
         */
        natIp: string;
        /**
         * The CIDR block to which the NAT IP address belongs.
         */
        natIpCidr: string;
        /**
         * The description of the NAT IP address.
         */
        natIpDescription: string;
        /**
         * The ID of the NAT IP address.
         */
        natIpId: string;
        /**
         * The name of the NAT IP address.
         */
        natIpName: string;
        /**
         * The status of the NAT IP address. Valid values: `Available`, `Deleting` and `Creating`.
         */
        status: string;
    }

    export interface GetNetworkAclsAcl {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * Output direction rule information.
         */
        egressAclEntries: outputs.vpc.GetNetworkAclsAclEgressAclEntry[];
        /**
         * The ID of the Network Acl.
         */
        id: string;
        /**
         * Entry direction rule information.
         */
        ingressAclEntries: outputs.vpc.GetNetworkAclsAclIngressAclEntry[];
        /**
         * The first ID of the resource.
         */
        networkAclId: string;
        /**
         * The name of the network ACL.
         */
        networkAclName: string;
        /**
         * The associated resource.
         */
        resources: outputs.vpc.GetNetworkAclsAclResource[];
        /**
         * The state of the network ACL.
         */
        status: string;
        /**
         * The ID of the associated VPC.
         */
        vpcId: string;
    }

    export interface GetNetworkAclsAclEgressAclEntry {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * The destination address segment.
         */
        destinationCidrIp: string;
        /**
         * The name of the entry direction rule entry.
         */
        networkAclEntryName: string;
        /**
         * The authorization policy.
         */
        policy: string;
        /**
         * Source port range.
         */
        port: string;
        /**
         * Transport layer protocol.
         */
        protocol: string;
    }

    export interface GetNetworkAclsAclIngressAclEntry {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * The name of the entry direction rule entry.
         */
        networkAclEntryName: string;
        /**
         * The authorization policy.
         */
        policy: string;
        /**
         * Source port range.
         */
        port: string;
        /**
         * Transport layer protocol.
         */
        protocol: string;
        /**
         * The source address field.
         */
        sourceCidrIp: string;
    }

    export interface GetNetworkAclsAclResource {
        /**
         * The ID of the associated resource.
         */
        resourceId: string;
        /**
         * The type of the associated resource.
         */
        resourceType: string;
        /**
         * The state of the network ACL.
         */
        status: string;
    }

    export interface GetNetworksVpc {
        /**
         * Filter results by a specific CIDR block. For example: "172.16.0.0/12".
         */
        cidrBlock: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the VPC
         */
        description: string;
        /**
         * ID of the VPC.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * Indicate whether the VPC is the default one in the specified region.
         */
        isDefault: boolean;
        /**
         * ID of the region where the VPC is located.
         */
        regionId: string;
        /**
         * The Id of resource group which VPC belongs.
         */
        resourceGroupId: string;
        /**
         * Route table ID of the VRouter.
         */
        routeTableId: string;
        /**
         * The ID of the VRouter.
         */
        routerId: string;
        /**
         * A list of secondary IPv4 CIDR blocks of the VPC.
         */
        secondaryCidrBlocks: string[];
        /**
         * Filter results by a specific status. Valid value are `Pending` and `Available`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * A list of user CIDRs.
         */
        userCidrs: string[];
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * The name of the VPC.
         */
        vpcName: string;
        /**
         * ID of the VRouter.
         */
        vrouterId: string;
        /**
         * List of VSwitch IDs in the specified VPC
         */
        vswitchIds: string[];
    }

    export interface GetRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry.
         */
        cidrBlock: string;
        /**
         * The instance ID of the next hop.
         */
        instanceId: string;
        /**
         * The type of the next hop.
         */
        nextHopType: string;
        /**
         * The ID of the router table to which the route entry belongs.
         */
        routeTableId: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The type of the route entry.
         */
        type: string;
    }

    export interface GetRouteTablesTable {
        /**
         * The description of the route table instance.
         */
        description: string;
        /**
         * ID of the Route Table.
         */
        id: string;
        /**
         * Name of the route table.
         */
        name: string;
        /**
         * The Id of resource group which route tables belongs.
         */
        resourceGroupId: string;
        /**
         * The route table id.
         */
        routeTableId: string;
        /**
         * The route table name.
         */
        routeTableName: string;
        /**
         * The type of route table.
         */
        routeTableType: string;
        /**
         * The router ID.
         */
        routerId: string;
        /**
         * The route type of route table. Valid values: `VRouter` and `VBR`.
         */
        routerType: string;
        /**
         * The status of resource. Valid values: `Available` and `Pending`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Vpc id of the route table.
         */
        vpcId: string;
        /**
         * A list of vswitch id.
         */
        vswitchIds: string[];
    }

    export interface GetRouterInterfacesInterface {
        /**
         * ID of the access point used by the VBR.
         */
        accessPointId: string;
        /**
         * Router interface creation time.
         */
        creationTime: string;
        /**
         * Router interface description.
         */
        description: string;
        /**
         * Source IP address used to perform health check on the physical connection.
         */
        healthCheckSourceIp: string;
        /**
         * Destination IP address used to perform health check on the physical connection.
         */
        healthCheckTargetIp: string;
        /**
         * Router interface ID.
         */
        id: string;
        /**
         * Router interface name.
         */
        name: string;
        /**
         * ID of the peer router interface.
         */
        oppositeInterfaceId: string;
        /**
         * Account ID of the owner of the peer router interface.
         */
        oppositeInterfaceOwnerId: string;
        /**
         * Peer router region ID.
         */
        oppositeRegionId: string;
        /**
         * Peer router ID.
         */
        oppositeRouterId: string;
        /**
         * Router type in the peer region. Possible values: `VRouter` and `VBR`.
         */
        oppositeRouterType: string;
        /**
         * Role of the router interface. Valid values are `InitiatingSide` (connection initiator) and 
         * `AcceptingSide` (connection receiver). The value of this parameter must be `InitiatingSide` if the `routerType` is set to `VBR`.
         */
        role: string;
        /**
         * ID of the VRouter located in the local region.
         */
        routerId: string;
        /**
         * Router type in the local region. Valid values are `VRouter` and `VBR` (physical connection).
         */
        routerType: string;
        /**
         * Specification of the link, such as `Small.1` (10Mb), `Middle.1` (100Mb), `Large.2` (2Gb), ...etc.
         */
        specification: string;
        /**
         * Expected status. Valid values are `Active`, `Inactive` and `Idle`.
         */
        status: string;
        /**
         * ID of the VPC that owns the router in the local region.
         */
        vpcId: string;
    }

    export interface GetSnatEntriesEntry {
        /**
         * The ID of the Snat Entry.
         */
        id: string;
        /**
         * The ID of snat entry.
         */
        snatEntryId: string;
        /**
         * The name of snat entry.
         */
        snatEntryName: string;
        /**
         * The public IP of the Snat Entry.
         */
        snatIp: string;
        /**
         * The source CIDR block of the Snat Entry.
         */
        sourceCidr: string;
        /**
         * The source vswitch ID.
         */
        sourceVswitchId: string;
        /**
         * The status of the Snat Entry. Valid values: `Available`, `Deleting` and `Pending`.
         */
        status: string;
    }

    export interface GetSslVpnClientCertsCert {
        /**
         * The time of creation.
         */
        createTime: string;
        /**
         * The expiration time of the client certificate.
         */
        endTime: number;
        /**
         * ID of the SSL-VPN client certificate.
         */
        id: string;
        /**
         * The name of the SSL-VPN client certificate.
         */
        name: string;
        /**
         * Use the SSL-VPN server ID as the search key.
         */
        sslVpnServerId: string;
        /**
         * The status of the client certificate. valid value:expiring-soon, normal, expired.
         */
        status: string;
    }

    export interface GetSslVpnServersServer {
        /**
         * The encryption algorithm used.
         */
        cipher: string;
        /**
         * The IP address pool of the client.
         */
        clientIpPool: string;
        /**
         * Whether to compress.
         */
        compress: boolean;
        /**
         * The number of current connections.
         */
        connections: number;
        /**
         * The time of creation.
         */
        createTime: string;
        /**
         * The ID of the SSL-VPN server.
         */
        id: string;
        /**
         * The public IP.
         */
        internetIp: string;
        /**
         * The local subnet of the VPN connection.
         */
        localSubnet: string;
        /**
         * The maximum number of connections.
         */
        maxConnections: number;
        /**
         * The name of the SSL-VPN server.
         */
        name: string;
        /**
         * The port used by the SSL-VPN server.
         */
        port: number;
        /**
         * The protocol used by the SSL-VPN server.
         */
        proto: string;
        /**
         * Use the VPN gateway ID as the search key.
         */
        vpnGatewayId: string;
    }

    export interface GetSwitchesVswitch {
        /**
         * The available ip address count of the VSwitch.
         */
        availableIpAddressCount: number;
        /**
         * Filter results by a specific CIDR block. For example: "172.16.0.0/12".
         */
        cidrBlock: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the VSwitch.
         */
        description: string;
        /**
         * ID of the VSwitch.
         */
        id: string;
        /**
         * Indicate whether the VSwitch is created by the system.
         */
        isDefault: boolean;
        /**
         * Name of the VSwitch.
         */
        name: string;
        /**
         * The Id of resource group which VSWitch belongs.
         */
        resourceGroupId: string;
        /**
         * The route table ID of the VSwitch.
         */
        routeTableId: string;
        /**
         * The status of the VSwitch. Valid values: `Available` and `Pending`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC that owns the VSwitch.
         */
        vpcId: string;
        /**
         * ID of the VSwitch.
         */
        vswitchId: string;
        /**
         * The name of the VSwitch.
         */
        vswitchName: string;
        /**
         * The availability zone of the VSwitch.
         */
        zoneId: string;
    }

    export interface GetTrafficMirrorFilterEgressRulesRule {
        /**
         * The destination CIDR block of the outbound traffic.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of the outbound traffic.
         */
        destinationPortRange: string;
        /**
         * The ID of the Traffic Mirror Filter Egress Rule.
         */
        id: string;
        /**
         * The priority of the outbound rule. A smaller value indicates a higher priority. The maximum value is `10`, which indicates that you can configure at most 10 inbound rules for a filter.
         */
        priority: number;
        /**
         * The transport protocol used by outbound traffic that needs to be mirrored. Valid values: `ALL`, `ICMP`, `TCP`, `UDP`.
         */
        protocol: string;
        /**
         * The collection policy of the inbound rule. Valid values: `accept` or `drop`. `accept`: collects network traffic. `drop`: does not collect network traffic.
         */
        ruleAction: string;
        /**
         * The source CIDR block of the outbound traffic.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of the outbound traffic.
         */
        sourcePortRange: string;
        /**
         * The status of the resource. Valid values:`Creating`, `Created`, `Modifying` and `Deleting`.
         */
        status: string;
        /**
         * The ID of the filter associated with the outbound rule.
         */
        trafficMirrorFilterId: string;
        /**
         * The first ID of the resource.
         */
        trafficMirrorFilterRuleId: string;
    }

    export interface GetTrafficMirrorFilterIngressRulesRule {
        /**
         * The destination CIDR block of the inbound traffic.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of the inbound traffic.
         */
        destinationPortRange: string;
        /**
         * The ID of the Traffic Mirror Filter Egress Rule.
         */
        id: string;
        /**
         * The priority of the inbound rule. A smaller value indicates a higher priority. The maximum value is `10`, which indicates that you can configure at most 10 inbound rules for a filter.
         */
        priority: number;
        /**
         * The transport protocol used by inbound traffic that needs to be mirrored. Valid values: `ALL`, `ICMP`, `TCP`, `UDP`.
         */
        protocol: string;
        /**
         * The collection policy of the inbound rule. Valid values: `accept` or `drop`. `accept`: collects network traffic. `drop`: does not collect network traffic.
         */
        ruleAction: string;
        /**
         * The source CIDR block of the inbound traffic.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of the inbound traffic.
         */
        sourcePortRange: string;
        /**
         * The status of the resource. Valid values:`Creating`, `Created`, `Modifying` and `Deleting`.
         */
        status: string;
        /**
         * The ID of the filter associated with the inbound rule.
         */
        trafficMirrorFilterId: string;
        /**
         * The first ID of the resource.
         */
        trafficMirrorFilterRuleId: string;
    }

    export interface GetTrafficMirrorFiltersFilter {
        /**
         * The ID of the Traffic Mirror Filter.
         */
        id: string;
        /**
         * The state of the filter. Valid values:`Creating`, `Created`, `Modifying` and `Deleting`. `Creating`: The filter is being created. `Created`: The filter is created. `Modifying`: The filter is being modified. `Deleting`: The filter is being deleted.
         */
        status: string;
        /**
         * The description of the filter.
         */
        trafficMirrorFilterDescription: string;
        /**
         * The ID of the filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The name of the filter.
         */
        trafficMirrorFilterName: string;
    }

    export interface GetTrafficMirrorSessionsSession {
        /**
         * Indicates whether traffic mirror sessions are enabled. default to `false`.
         */
        enabled: boolean;
        /**
         * The ID of the Traffic Mirror Session.
         */
        id: string;
        /**
         * The maximum transmission unit (MTU).
         */
        packetLength: number;
        /**
         * The priority of the traffic mirror session. A smaller value indicates a higher priority.
         */
        priority: number;
        /**
         * The state of the traffic mirror session. Valid values: `Creating`, `Created`, `Modifying` and `Deleting`.
         */
        status: string;
        /**
         * The ID of the filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The state of the traffic mirror session. Valid values: `Normal` or `FinancialLocked`. `Normal`: working as expected. `FinancialLocked`: locked due to overdue payments.
         */
        trafficMirrorSessionBusinessStatus: string;
        /**
         * The description of the traffic mirror session.
         */
        trafficMirrorSessionDescription: string;
        /**
         * The first ID of the resource.
         */
        trafficMirrorSessionId: string;
        /**
         * The name of the traffic mirror session.
         */
        trafficMirrorSessionName: string;
        /**
         * The ID of the mirror source.
         */
        trafficMirrorSourceIds: string[];
        /**
         * The ID of the mirror destination. You can specify only an ENI or a Server Load Balancer (SLB) instance as a mirror destination.
         */
        trafficMirrorTargetId: string;
        /**
         * The type of the mirror destination. Valid values: `NetworkInterface` or `SLB`. `NetworkInterface`: an ENI. `SLB`: an internal-facing SLB instance
         */
        trafficMirrorTargetType: string;
        /**
         * You can specify VNIs to distinguish different mirrored traffic.
         */
        virtualNetworkId: number;
    }

    export interface GetVpcFlowLogsLog {
        /**
         * The Description of flow log.
         */
        description: string;
        /**
         * The flow log ID.
         */
        flowLogId: string;
        /**
         * The flow log name.
         */
        flowLogName: string;
        /**
         * The ID of the Flow Log.
         */
        id: string;
        /**
         * The log store name.
         */
        logStoreName: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The resource id.
         */
        resourceId: string;
        /**
         * The resource type.
         */
        resourceType: string;
        /**
         * The status of flow log.
         */
        status: string;
        /**
         * The traffic type.
         */
        trafficType: string;
    }

    export interface NetworkAclAttachmentResource {
        /**
         * The resource id that the network acl will associate with.
         */
        resourceId: string;
        /**
         * The resource id that the network acl will associate with. Only support `VSwitch` now.
         */
        resourceType: string;
    }

    export interface NetworkAclEgressAclEntry {
        /**
         * The description of egress entries.
         */
        description?: string;
        /**
         * The destination cidr ip of egress entries.
         */
        destinationCidrIp?: string;
        /**
         * The entry name of egress entries.
         */
        networkAclEntryName?: string;
        /**
         * The policy of egress entries. Valid values `accept` and `drop`.
         */
        policy?: string;
        /**
         * The port of egress entries.
         */
        port?: string;
        /**
         * The protocol of egress entries. Valid values `icmp`,`gre`,`tcp`,`udp`, and `all`.
         */
        protocol?: string;
    }

    export interface NetworkAclEntriesEgress {
        /**
         * The description of the egress entry.
         */
        description: string;
        /**
         * The destination ip of the egress entry.
         */
        destinationCidrIp: string;
        /**
         * The entry type of the egress entry. It must be `custom` or `system`. Default value is `custom`.
         */
        entryType: string;
        /**
         * The name of the egress entry.
         */
        name: string;
        /**
         * The policy of the egress entry. It must be `accept` or `drop`.
         */
        policy: string;
        /**
         * The port of the egress entry.
         */
        port: string;
        /**
         * The protocol of the egress entry.
         */
        protocol: string;
    }

    export interface NetworkAclEntriesIngress {
        /**
         * The description of the egress entry.
         */
        description: string;
        /**
         * The entry type of the egress entry. It must be `custom` or `system`. Default value is `custom`.
         */
        entryType: string;
        /**
         * The name of the egress entry.
         */
        name: string;
        /**
         * The policy of the egress entry. It must be `accept` or `drop`.
         */
        policy: string;
        /**
         * The port of the egress entry.
         */
        port: string;
        /**
         * The protocol of the egress entry.
         */
        protocol: string;
        /**
         * The source ip of the ingress entry.
         */
        sourceCidrIp: string;
    }

    export interface NetworkAclIngressAclEntry {
        /**
         * The description of egress entries.
         */
        description?: string;
        /**
         * The entry name of egress entries.
         */
        networkAclEntryName?: string;
        /**
         * The policy of egress entries. Valid values `accept` and `drop`.
         */
        policy?: string;
        /**
         * The port of egress entries.
         */
        port?: string;
        /**
         * The protocol of egress entries. Valid values `icmp`,`gre`,`tcp`,`udp`, and `all`.
         */
        protocol?: string;
        /**
         * The source cidr ip of ingress entries.
         */
        sourceCidrIp?: string;
    }

    export interface NetworkAclResource {
        /**
         * The ID of the associated resource.
         */
        resourceId?: string;
        /**
         * The type of the associated resource. Valid values `VSwitch`.
         */
        resourceType?: string;
    }

}

export namespace vpn {
    export interface ConnectionIkeConfig {
        /**
         * The authentication algorithm of phase-one negotiation. Valid value: md5 | sha1 | sha256 | sha384 | sha512 |. Default value: sha1
         */
        ikeAuthAlg?: string;
        /**
         * The encryption algorithm of phase-one negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default Valid value: aes
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation. The valid value of n is [0, 86400], the unit is second and the default value is 86400.
         */
        ikeLifetime?: number;
        /**
         * The identification of the VPN gateway.
         */
        ikeLocalId?: string;
        /**
         * The negotiation mode of IKE V1. Valid value: main (main mode) | aggressive (aggressive mode). Default value: main
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation. Valid value: group1 | group2 | group5 | group14 | group24. Default value: group2
         */
        ikePfs?: string;
        /**
         * The identification of the customer gateway.
         */
        ikeRemoteId?: string;
        /**
         * The version of the IKE protocol. Valid value: ikev1 | ikev2. Default value: ikev1
         */
        ikeVersion?: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
    }

    export interface ConnectionIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation. Valid value: md5 | sha1 | sha256 | sha384 | sha512 |. Default value: sha1
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default value: aes
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation. The valid value is [0, 86400], the unit is second and the default value is 86400.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation. Valid value: group1 | group2 | group5 | group14 | group24| disabled. Default value: group2
         */
        ipsecPfs?: string;
    }

    export interface GetConnectionsConnection {
        createTime: string;
        /**
         * Use the VPN customer gateway ID as the search key.
         */
        customerGatewayId: string;
        effectImmediately: boolean;
        /**
         * ID of the VPN connection.
         */
        id: string;
        /**
         * The configurations of phase-one negotiation.
         */
        ikeConfigs?: outputs.vpn.GetConnectionsConnectionIkeConfig[];
        /**
         * The configurations of phase-two negotiation.
         */
        ipsecConfigs?: outputs.vpn.GetConnectionsConnectionIpsecConfig[];
        /**
         * The local subnet of the VPN connection.
         */
        localSubnet: string;
        /**
         * The name of the VPN connection.
         */
        name: string;
        /**
         * The remote subnet of the VPN connection.
         */
        remoteSubnet: string;
        /**
         * The status of the VPN connection, valid value:ike_sa_not_established, ike_sa_established, ipsec_sa_not_established, ipsec_sa_established.
         */
        status: string;
        /**
         * Use the VPN gateway ID as the search key.
         */
        vpnGatewayId: string;
    }

    export interface GetConnectionsConnectionIkeConfig {
        /**
         * The authentication algorithm of phase-one negotiation.
         */
        ikeAuthAlg?: string;
        /**
         * The encryption algorithm of phase-one negotiation.
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation.
         */
        ikeLifetime?: number;
        /**
         * The identification of the VPN gateway.
         */
        ikeLocalId?: string;
        /**
         * The negotiation mode of IKE phase-one.
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation.
         */
        ikePfs?: string;
        /**
         * The identification of the customer gateway.
         */
        ikeRemoteId?: string;
        /**
         * The version of the IKE protocol.
         */
        ikeVersion?: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
    }

    export interface GetConnectionsConnectionIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation.
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation.
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation.
         */
        ipsecPfs?: string;
    }

    export interface GetCustomerGatewaysGateway {
        /**
         * The creation time of the VPN customer gateway.
         */
        createTime: string;
        /**
         * The description of the VPN customer gateway.
         */
        description: string;
        /**
         * ID of the VPN customer gateway .
         */
        id: string;
        /**
         * The ip address of the VPN customer gateway.
         */
        ipAddress: string;
        /**
         * The name of the VPN customer gateway.
         */
        name: string;
    }

    export interface GetGatewaysGateway {
        /**
         * Limit search to specific business status - valid value is "Normal", "FinancialLocked".
         */
        businessStatus: string;
        /**
         * The creation time of the VPN gateway.
         */
        createTime: string;
        /**
         * The description of the VPN
         */
        description: string;
        /**
         * Whether the ipsec function is enabled.
         */
        enableIpsec: string;
        /**
         * Whether the ssl function is enabled.
         */
        enableSsl: string;
        /**
         * The expiration time of the VPN gateway.
         */
        endTime: string;
        /**
         * ID of the VPN.
         */
        id: string;
        /**
         * The charge type of the VPN gateway.
         */
        instanceChargeType: string;
        /**
         * The internet ip of the VPN.
         */
        internetIp: string;
        /**
         * The name of the VPN.
         */
        name: string;
        /**
         * The Specification of the VPN
         */
        specification: string;
        /**
         * Total count of ssl vpn connections.
         */
        sslConnections: number;
        /**
         * Limit search to specific status - valid value is "Init", "Provisioning", "Active", "Updating", "Deleting".
         */
        status: string;
        /**
         * Use the VPC ID as the search key.
         */
        vpcId: string;
    }

}

export namespace waf {
    export interface DomainLogHeader {
        key?: string;
        value?: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Certificate recording ID.
         */
        certificateId: string;
        /**
         * Your certificate name.
         */
        certificateName: string;
        /**
         * Certificate bound to the domain name.
         */
        commonName: string;
        /**
         * The domain that you want to add to WAF.
         */
        domain: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * WAF instance ID.
         */
        instanceId: string;
        isUsing: boolean;
        sans: string[];
    }

    export interface GetDomainsDomain {
        /**
         * The type of the WAF cluster.
         */
        clusterType: string;
        /**
         * The CNAME record assigned by the WAF instance to the specified domain.
         */
        cname: string;
        /**
         * The connection timeout for WAF exclusive clusters. Valid values: `PhysicalCluster` and `VirtualCluster`. Default to `PhysicalCluster`.
         */
        connectionTime: number;
        /**
         * Field `domain` has been deprecated from version 1.94.0. Use `domainName` instead.
         */
        domain: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * List of the HTTP 2.0 ports.
         */
        http2Ports: string[];
        /**
         * List of the HTTP ports.
         */
        httpPorts: string[];
        /**
         * Specifies whether to enable the HTTP back-to-origin feature. After this feature is enabled, the WAF instance can use HTTP to forward HTTPS requests to the origin server.
         */
        httpToUserIp: string;
        /**
         * List of the HTTPS ports.
         */
        httpsPorts: string[];
        /**
         * Specifies whether to redirect HTTP requests as HTTPS requests. Valid values: `On` and `Off`. Default to `Off`.
         */
        httpsRedirect: string;
        /**
         * The ID of domain self ID, value as `domainName`.
         */
        id: string;
        /**
         * Specifies whether to configure a Layer-7 proxy, such as Anti-DDoS Pro or CDN, to filter the inbound traffic before it is forwarded to WAF. Valid values: `On` and "Off". Default to `Off`.
         */
        isAccessProduct: string;
        /**
         * The load balancing algorithm that is used to forward requests to the origin. Valid values: `IpHash` and `RoundRobin`. Default to `IpHash`.
         */
        loadBalancing: string;
        /**
         * The key-value pair that is used to mark the traffic that flows through WAF to the domain. Each item contains two field:
         * * `key`: The key of label.
         * * `value`: The value of label.
         */
        logHeaders: outputs.waf.GetDomainsDomainLogHeader[];
        /**
         * The read timeout of a WAF exclusive cluster. Unit: seconds.
         */
        readTime: number;
        /**
         * The ID of the resource group to which the queried domain belongs in Resource Management.
         */
        resourceGroupId: string;
        /**
         * List of the IP address or domain of the origin server to which the specified domain points.
         */
        sourceIps: string[];
        /**
         * The system data identifier that is used to control optimistic locking.
         */
        version: number;
        /**
         * The timeout period for a WAF exclusive cluster write connection. Unit: seconds.
         */
        writeTime: number;
    }

    export interface GetDomainsDomainLogHeader {
        key: string;
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The timestamp (in seconds) indicating when the WAF instance expires.
         */
        endDate: number;
        /**
         * The ID of the WAF instance.
         */
        id: string;
        /**
         * Indicates whether the WAF instance has overdue payments.
         */
        inDebt: number;
        /**
         * The ID of WAF the instance.
         */
        instanceId: string;
        /**
         * The number of days before the trial period of the WAF instance expires.
         */
        remainDay: number;
        /**
         * The status of WAF instance to filter results. Optional value: `0`: The instance has expired, `1` : The instance has not expired and is working properly.
         */
        status: number;
        subscriptionType: string;
        /**
         * Indicates whether this is a trial instance.
         */
        trial: number;
    }

}

export namespace yundun {
    export interface GetBastionHostInstancesInstance {
        description: string;
        id: string;
        instanceStatus: string;
        licenseCode: string;
        privateDomain: string;
        publicDomain: string;
        publicNetworkAccess: boolean;
        securityGroupIds: string[];
        tags?: {[key: string]: any};
        userVswitchId: string;
    }

    export interface GetDBAuditInstanceInstance {
        description: string;
        id: string;
        instanceStatus: string;
        licenseCode: string;
        privateDomain: string;
        publicDomain: string;
        publicNetworkAccess: boolean;
        tags?: {[key: string]: any};
        userVswitchId: string;
    }

}
