// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetMscSubContactsContact {
    /**
     * UID.
     */
    accountUid: string;
    /**
     * The first ID of the resource.
     */
    contactId: string;
    /**
     * The User's Contact Name. **Note:** The name must be 2 to 12 characters in length, and can contain uppercase and lowercase letters.
     */
    contactName: string;
    /**
     * The User's Contact Email Address.
     */
    email: string;
    /**
     * The ID of the Contact.
     */
    id: string;
    /**
     * Indicates Whether the BGP Group Is the Account Itself.
     */
    isAccount: boolean;
    /**
     * Whether They Have Expired Or Not.
     */
    isObsolete: boolean;
    /**
     * Email Validation for.
     */
    isVerifiedEmail: boolean;
    /**
     * If the Phone Verification.
     */
    isVerifiedMobile: boolean;
    /**
     * Last Verification Email Transmission Time.
     */
    lastEmailVerificationTimeStamp: string;
    /**
     * The Pieces of Authentication SMS Sending Time.
     */
    lastMobileVerificationTimeStamp: string;
    /**
     * The User's Telephone.
     */
    mobile: string;
    /**
     * The User's Position. Valid values: `CEO`, `Technical Director`, `Maintenance Director`, `Project Director`,`Finance Director` and `Other`.
     */
    position: string;
}

export interface GetMscSubSubscriptionsSubscription {
    /**
     * The channel the Subscription.
     */
    channel: string;
    /**
     * The ids of subscribed contacts.
     */
    contactIds: number[];
    /**
     * The description of the Subscription.
     */
    description: string;
    /**
     * The status of email subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    emailStatus: number;
    /**
     * The ID of the Subscription.
     */
    id: string;
    /**
     * The ID of the Subscription.
     */
    itemId: string;
    /**
     * The name of the Subscription.
     */
    itemName: string;
    /**
     * The status of pmsg subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    pmsgStatus: number;
    /**
     * The status of sms subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    smsStatus: number;
    /**
     * The status of tts subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    ttsStatus: number;
    /**
     * The ids of subscribed webhooks.
     */
    webhookIds: number[];
    /**
     * The status of webhook subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
     */
    webhookStatus: number;
}

export interface GetMscSubWebhooksWebhook {
    /**
     * The ID of the Webhook.
     */
    id: string;
    /**
     * The serverUrl of the Subscription.
     */
    serverUrl: string;
    /**
     * The first ID of the resource.
     */
    webhookId: string;
    /**
     * The name of the Webhook. **Note:** The name must be `2` to `12` characters in length, and can contain uppercase and lowercase letters.
     */
    webhookName: string;
}

export interface GetRegionsRegion {
    /**
     * ID of the region.
     */
    id: string;
    /**
     * Name of the region in the local language.
     */
    localName: string;
    regionId: string;
}

export interface GetZonesZone {
    /**
     * Set of supported disk categories.
     */
    availableDiskCategories: string[];
    /**
     * Allowed instance types.
     */
    availableInstanceTypes: string[];
    /**
     * Filter the results by a specific resource type.
     * Valid values: `Instance`, `Disk`, `VSwitch`, `Rds`, `KVStore`, `FunctionCompute`, `Elasticsearch`, `Slb`.
     *
     * > **NOTE:** From version 1.134.0, the `availableResourceCreation` value "Rds" has been deprecated.
     * If you want to fetch the available zones for RDS instance, you can use datasource alicloud_db_zones
     */
    availableResourceCreations: string[];
    /**
     * ID of the zone.
     */
    id: string;
    /**
     * Name of the zone in the local language.
     */
    localName: string;
    /**
     * A list of zone ids in which the multi zone.
     */
    multiZoneIds: string[];
    /**
     * A list of slb slave zone ids in which the slb master zone.
     */
    slbSlaveZoneIds: string[];
}

export namespace actiontrail {
    export interface GetConsumerGroupsGroup {
        /**
         * The name of the consumer group.
         */
        consumerId: string;
        /**
         * The ID of the consumer group, It is formatted to `<instance_id>:<consumer_id>`.
         */
        id: string;
        /**
         * ID of the ALIKAFKA Instance that owns the consumer groups.
         */
        instanceId: string;
        /**
         * The remark of the consumer group.
         */
        remark: string;
        /**
         * A mapping of tags to assign to the consumer group.
         */
        tags?: {[key: string]: any};
    }

    export interface GetHistoryDeliveryJobsJob {
        /**
         * The time when the task was created.
         */
        createTime: string;
        /**
         * The time when the task ended.
         */
        endTime: string;
        historyDeliveryJobId: string;
        /**
         * The home region of the trail.
         */
        homeRegion: string;
        /**
         * The ID of the History Delivery Job.
         */
        id: string;
        /**
         * Detail status of delivery job.
         */
        jobStatuses: outputs.actiontrail.GetHistoryDeliveryJobsJobJobStatus[];
        /**
         * The time when the task started.
         */
        startTime: string;
        /**
         * The status of the task. Valid values: `0`, `1`, `2`, `3`. `0`: The task is initializing. `1`: The task is delivering historical events. `2`: The delivery of historical events is complete. `3`: The task fails.
         */
        status: number;
        /**
         * The name of the trail.
         */
        trailName: string;
        /**
         * The time when the task was updated.
         */
        updatedTime: string;
    }

    export interface GetHistoryDeliveryJobsJobJobStatus {
        /**
         * The region of the delivery job.
         */
        region: string;
        /**
         * The status of the task. Valid values: `0`, `1`, `2`, `3`. `0`: The task is initializing. `1`: The task is delivering historical events. `2`: The delivery of historical events is complete. `3`: The task fails.
         */
        status: number;
    }

    export interface GetInstancesInstance {
        /**
         * The allowed list of the instance.
         */
        allowedLists: outputs.actiontrail.GetInstancesInstanceAllowedList[];
        /**
         * The config the instance.
         */
        config: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The deployed type of the instance.
         */
        deployType: number;
        /**
         * The disk size of the instance.
         */
        diskSize: number;
        /**
         * The disk type of the instance. 0: efficient cloud disk , 1: SSD.
         */
        diskType: number;
        /**
         * The domain point of the instance.
         */
        domainEndpoint: string;
        /**
         * The peak bandwidth of the instance.
         */
        eipMax: number;
        /**
         * The endPoint to access the instance.
         */
        endPoint: string;
        /**
         * The expired time  of the instance.
         */
        expiredTime: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The peak value of io of the instance.
         */
        ioMax: number;
        /**
         * The msg retain of the instance.
         */
        msgRetain: number;
        /**
         * Name of the instance.
         */
        name: string;
        /**
         * The paid type of the instance.
         */
        paidType: string;
        /**
         * (Available in 1.194.0+) The number of partitions.
         */
        partitionNum: number;
        /**
         * The SASL domain point of the instance.
         */
        saslDomainEndpoint: string;
        /**
         * The security group of the instance.
         */
        securityGroup: string;
        /**
         * The current status of the instance. -1: unknown status, 0: wait deploy, 1: initializing, 2: preparing, 3 starting, 5: in service, 7: wait upgrade, 8: upgrading, 10: released, 15: freeze, 101: deploy error, 102: upgrade error.
         */
        serviceStatus: number;
        /**
         * The kafka openSource version of the instance.
         */
        serviceVersion: string;
        /**
         * The spec type of the instance.
         */
        specType: string;
        /**
         * The SSL domain point of the instance.
         */
        sslDomainEndpoint: string;
        /**
         * The SSL end point of the instance.
         */
        sslEndPoint: string;
        /**
         * A mapping of tags to assign to the instance.
         */
        tags?: {[key: string]: any};
        /**
         * The max num of topic can be create of the instance.
         */
        topicQuota: number;
        /**
         * The UpgradeServiceDetailInfo List.
         */
        upgradeServiceDetailInfos: outputs.actiontrail.GetInstancesInstanceUpgradeServiceDetailInfo[];
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The ID of attaching vswitch to instance.
         */
        vswitchId: string;
        /**
         * The ID of attaching zone to instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceAllowedList {
        /**
         * The deployed type of the instance.
         */
        deployType: string;
        /**
         * The internet list of the instance.
         */
        internetLists: outputs.actiontrail.GetInstancesInstanceAllowedListInternetList[];
        /**
         * The vpc list of the instance.
         */
        vpcLists: outputs.actiontrail.GetInstancesInstanceAllowedListVpcList[];
    }

    export interface GetInstancesInstanceAllowedListInternetList {
        /**
         * The allowed ip list of the internet_list.
         */
        allowedIpLists: string[];
        /**
         * The port range of the internet_list.
         */
        portRange: string;
    }

    export interface GetInstancesInstanceAllowedListVpcList {
        /**
         * The allowed ip list of the internet_list.
         */
        allowedIpLists: string[];
        /**
         * The port range of the internet_list.
         */
        portRange: string;
    }

    export interface GetInstancesInstanceUpgradeServiceDetailInfo {
        /**
         * The Current2OpenSourceVersion of the instance.
         */
        current2OpenSourceVersion: string;
    }

    export interface GetSaslAclsAcl {
        /**
         * The operation type of the sasl acl.
         */
        aclOperationType: string;
        /**
         * Get results for the specified resource name.
         */
        aclResourceName: string;
        /**
         * The resource pattern type of the sasl acl.
         */
        aclResourcePatternType: string;
        /**
         * Get results for the specified resource type.
         */
        aclResourceType: string;
        /**
         * The host of the sasl acl.
         */
        host: string;
        /**
         * Get results for the specified username.
         */
        username: string;
    }

    export interface GetSaslUsersUser {
        /**
         * The password of the user.
         */
        password: string;
        /**
         * The username of the user.
         */
        username: string;
    }

    export interface GetTopicsTopic {
        /**
         * whether the current topic is kafka compact topic or not.
         */
        compactTopic: boolean;
        /**
         * Time of creation.
         */
        createTime: string;
        /**
         * The ID of the topic, It is formatted to `<instance_id>:<topic>`.
         */
        id: string;
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * whether the current topic is kafka local topic or not.
         */
        localTopic: boolean;
        /**
         * Partition number of the topic.
         */
        partitionNum: number;
        /**
         * Remark of the topic.
         */
        remark: string;
        /**
         * The current status code of the topic. There are three values to describe the topic status: 0 stands for the topic is in service, 1 stands for freezing and 2 stands for pause.
         */
        status: number;
        /**
         * The statusName of the topic.
         */
        statusName: string;
        /**
         * A mapping of tags to assign to the topic.
         */
        tags?: {[key: string]: any};
        /**
         * A topic to filter results by the topic name.
         */
        topic: string;
    }

    export interface GetTrailsActiontrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        /**
         * The id of the ActionTrail Trail. It is the same as trail name.
         */
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        /**
         * Filter the results by status of the ActionTrail Trail. Valid values: `Disable`, `Enable`, `Fresh`.
         */
        status: string;
        /**
         * The name of the ActionTrail Trail.
         */
        trailName: string;
        /**
         * The regions to which the trail is applied.
         */
        trailRegion: string;
    }

    export interface GetTrailsDeprecatedActiontrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        status: string;
        trailName: string;
        trailRegion: string;
    }

    export interface GetTrailsDeprecatedTrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        status: string;
        trailName: string;
        trailRegion: string;
    }

    export interface GetTrailsTrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        /**
         * The id of the ActionTrail Trail. It is the same as trail name.
         */
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        /**
         * Filter the results by status of the ActionTrail Trail. Valid values: `Disable`, `Enable`, `Fresh`.
         */
        status: string;
        /**
         * The name of the ActionTrail Trail.
         */
        trailName: string;
        /**
         * The regions to which the trail is applied.
         */
        trailRegion: string;
    }

}

export namespace adb {
    export interface GetClustersCluster {
        autoRenewPeriod: number;
        /**
         * Billing method. Value options: `PostPaid` for Pay-As-You-Go and `PrePaid` for subscription.
         */
        chargeType: string;
        commodityCode: string;
        computeResource: string;
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        dbClusterCategory: string;
        dbClusterId: string;
        dbClusterNetworkType: string;
        dbClusterType: string;
        dbClusterVersion: string;
        /**
         * The DBNodeClass of the ADB cluster.
         */
        dbNodeClass: string;
        /**
         * The DBNodeCount of the ADB cluster.
         */
        dbNodeCount: number;
        /**
         * The DBNodeStorage of the ADB cluster.
         */
        dbNodeStorage: number;
        /**
         * The description of the ADB cluster.
         */
        description: string;
        diskType: string;
        dtsJobId: string;
        elasticIoResource: number;
        engine: string;
        engineVersion: string;
        executorCount: string;
        /**
         * Expiration time. Pay-As-You-Go clusters never expire.
         */
        expireTime: string;
        /**
         * The expired of the ADB cluster.
         */
        expired: string;
        /**
         * The ID of the ADB cluster.
         */
        id: string;
        /**
         * The LockMode of the ADB cluster.
         */
        lockMode: string;
        lockReason: string;
        maintainTime: string;
        mode: string;
        /**
         * The DBClusterNetworkType of the ADB cluster.
         */
        networkType: string;
        paymentType: string;
        port: number;
        rdsInstanceId: string;
        /**
         * Region ID the cluster belongs to.
         */
        regionId: string;
        renewalStatus: string;
        resourceGroupId: string;
        securityIps: string[];
        /**
         * The status of the cluster. Valid values: `Preparing`, `Creating`, `Restoring`, `Running`, `Deleting`, `ClassChanging`, `NetAddressCreating`, `NetAddressDeleting`. For more information, see [Cluster status](https://www.alibabacloud.com/help/doc-detail/143075.htm).
         */
        status: string;
        storageResource: string;
        /**
         * A mapping of tags to assign to the resource.
         * - Key: It can be up to 64 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://". It cannot be a null string.
         * - Value: It can be up to 128 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://". It can be a null string.
         */
        tags: {[key: string]: any};
        vpcCloudInstanceId: string;
        /**
         * ID of the VPC the cluster belongs to.
         */
        vpcId: string;
        vswitchId: string;
        /**
         * The ZoneId of the ADB cluster.
         */
        zoneId: string;
    }

    export interface GetDBClusterLakeVersionsVersion {
        /**
         * The name of the service.
         */
        commodityCode: string;
        /**
         * The specifications of computing resources in elastic mode. The increase of resources can speed up queries.
         */
        computeResource: string;
        /**
         * The endpoint of the cluster.
         */
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        /**
         * The ID of the DBCluster.
         */
        dbClusterId: string;
        /**
         * The db cluster version.
         */
        dbClusterVersion: string;
        /**
         * The engine of the database.
         */
        engine: string;
        /**
         * The engine version of the database.
         */
        engineVersion: string;
        /**
         * The time when the cluster expires.
         */
        expireTime: string;
        /**
         * Indicates whether the cluster has expired.
         */
        expired: string;
        /**
         * The ID of the DBCluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The reason why the cluster is locked.
         */
        lockReason: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The port that is used to access the cluster.
         */
        port: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The specifications of storage resources in elastic mode. The resources are used for data read and write operations.
         */
        storageResource: string;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID  of the resource.
         */
        zoneId: string;
    }

    export interface GetDBClustersCluster {
        /**
         * Auto-renewal period of an cluster, in the unit of the month.
         */
        autoRenewPeriod: number;
        /**
         * The payment type of the resource.
         */
        chargeType: string;
        /**
         * The name of the service.
         */
        commodityCode: string;
        /**
         * The specifications of computing resources in elastic mode. The increase of resources can speed up queries. AnalyticDB for MySQL automatically scales computing resources. For more information, see [Specifications](https://www.alibabacloud.com/help/en/doc-detail/144851.htm).
         */
        computeResource: string;
        /**
         * The endpoint of the cluster.
         */
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        /**
         * The db cluster category.
         */
        dbClusterCategory: string;
        /**
         * The db cluster id.
         */
        dbClusterId: string;
        /**
         * The db cluster network type.
         */
        dbClusterNetworkType: string;
        /**
         * The db cluster type.
         */
        dbClusterType: string;
        /**
         * The db cluster version.
         */
        dbClusterVersion: string;
        /**
         * The db node class.
         */
        dbNodeClass: string;
        /**
         * The db node count.
         */
        dbNodeCount: number;
        /**
         * The db node storage.
         */
        dbNodeStorage: number;
        /**
         * The description of DBCluster.
         */
        description: string;
        /**
         * The type of the disk.
         */
        diskType: string;
        /**
         * The ID of the data synchronization task in Data Transmission Service (DTS). This parameter is valid only for analytic instances.
         */
        dtsJobId: string;
        /**
         * The elastic io resource.
         */
        elasticIoResource: number;
        /**
         * The engine of the database.
         */
        engine: string;
        /**
         * The engine version of the database.
         */
        engineVersion: string;
        /**
         * The number of nodes. The node resources are used for data computing in elastic mode.
         */
        executorCount: string;
        /**
         * The time when the cluster expires.
         */
        expireTime: string;
        /**
         * Indicates whether the cluster has expired.
         */
        expired: string;
        /**
         * The ID of the DBCluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The reason why the cluster is locked.
         */
        lockReason: string;
        /**
         * The maintenance window of the cluster.
         */
        maintainTime: string;
        /**
         * The lock mode of the cluster.
         */
        mode: string;
        /**
         * The db cluster network type.
         */
        networkType: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The port that is used to access the cluster.
         */
        port: number;
        /**
         * The ID of the ApsaraDB RDS instance from which data is synchronized to the cluster. This parameter is valid only for analytic instances.
         */
        rdsInstanceId: string;
        /**
         * The region ID  of the resource.
         */
        regionId: string;
        /**
         * The status of renewal.
         */
        renewalStatus: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * List of IP addresses allowed to access all databases of an cluster.
         */
        securityIps: string[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The specifications of storage resources in elastic mode. The resources are used for data read and write operations. The increase of resources can improve the read and write performance of your cluster. For more information, see [Specifications](https://www.alibabacloud.com/help/en/doc-detail/144851.htm).
         */
        storageResource: string;
        /**
         * A map of tags assigned to the cluster.
         */
        tags: {[key: string]: any};
        /**
         * The vpc cloud instance id.
         */
        vpcCloudInstanceId: string;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID  of the resource.
         */
        zoneId: string;
    }

    export interface GetResourceGroupsGroup {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * DBClusterId
         */
        dbClusterId: string;
        /**
         * The name of the resource pool, which cannot exceed 64 bytes in length.
         */
        groupName: string;
        /**
         * Query type, value description:
         * * **etl**: Batch query mode.
         * * **interactive**: interactive Query mode
         * * **default_type**: the default query mode.
         */
        groupType: string;
        /**
         * The `key` of the resource supplied above.The value is formulated as `<db_cluster_id>:<group_name>`.
         */
        id: string;
        /**
         * The number of nodes. The default number of nodes is 0. The number of nodes must be less than or equal to the number of nodes whose resource name is USER_DEFAULT.
         */
        nodeNum: number;
        /**
         * Binding User.
         */
        user: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace alb {
    export interface AScriptExtAttribute {
        /**
         * The key of the extended attribute.
         */
        attributeKey: string;
        /**
         * The value of the extended attribute.
         */
        attributeValue: string;
    }

    export interface AclAclEntry {
        /**
         * The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
         */
        description: string;
        /**
         * The IP address for the ACL entry.
         */
        entry: string;
        /**
         * The status of the ACL entry. Valid values:
         */
        status: string;
    }

    export interface GetAclsAcl {
        /**
         * ACL Entries.
         */
        aclEntries: outputs.alb.GetAclsAclAclEntry[];
        /**
         * Access Control Policy ID.
         */
        aclId: string;
        /**
         * The ACL Name.
         */
        aclName: string;
        /**
         * Address Protocol Version.
         */
        addressIpVersion: string;
        /**
         * The ID of the Acl.
         */
        id: string;
        /**
         * Resource Group to Which the Number.
         */
        resourceGroupId: string;
        /**
         * The state of the ACL. Valid values:`Provisioning` , `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
         */
        status: string;
    }

    export interface GetAclsAclAclEntry {
        /**
         * Access Control Entries Note Description Length Is Limited to 1 to 256 Characters, Letters, digital, the Dash (-), a Forward Slash (/), Half a Period (.) and Underscores (_), Support Chinese Characters.
         */
        description: string;
        entry: string;
        /**
         * The state of the ACL. Valid values:`Provisioning` , `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
         */
        status: string;
    }

    export interface GetAscriptsAscript {
        /**
         * Script identification.
         */
        ascriptId: string;
        /**
         * Script name.
         */
        ascriptName: string;
        /**
         * Whether scripts are enabled.
         */
        enabled: boolean;
        /**
         * Whether extension parameters are enabled.
         */
        extAttributeEnabled: boolean;
        /**
         * Extended attribute list.
         */
        extAttributes: outputs.alb.GetAscriptsAscriptExtAttribute[];
        id: string;
        /**
         * Listener ID of script attribution
         */
        listenerId: string;
        loadBalancerId: string;
        /**
         * Script execution location.
         */
        position: string;
        /**
         * Script content.
         */
        scriptContent: string;
        /**
         * Script status.
         */
        status: string;
    }

    export interface GetAscriptsAscriptExtAttribute {
        /**
         * The key of the extended attribute.
         */
        attributeKey: string;
        /**
         * The value of the extended attribute.
         */
        attributeValue: string;
    }

    export interface GetHealthCheckTemplatesTemplate {
        /**
         * The HTTP status code that indicates a successful health check.
         */
        healthCheckCodes: string[];
        /**
         * The number of the port that is used for health checks.  Valid values: `0` to `65535`.  Default value:` 0`. This default value indicates that the backend server is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * The domain name that is used for health checks. Default value:  `$SERVER_IP`. The domain name must be 1 to 80 characters in length.
         */
        healthCheckHost: string;
        /**
         * The version of the HTTP protocol.  Valid values: `HTTP1.0` and `HTTP1.1`.  Default value: `HTTP1.1`.
         */
        healthCheckHttpVersion: string;
        /**
         * The time interval between two consecutive health checks.  Valid values: `1` to `50`. Unit: seconds.  Default value: `2`.
         */
        healthCheckInterval: number;
        /**
         * The health check method.  Valid values: `GET` and `HEAD`.  Default value: `HEAD`.
         */
        healthCheckMethod: string;
        /**
         * The URL that is used for health checks.  The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: ` _ ; ~ ! ( )* [ ] @ $ ^ : ' , +. The URL must start with a forward slash (/)`.
         */
        healthCheckPath: string;
        /**
         * The protocol that is used for health checks.  Valid values: HTTP and TCP.  Default value: HTTP.
         */
        healthCheckProtocol: string;
        /**
         * The ID of the resource.
         */
        healthCheckTemplateId: string;
        /**
         * The name of the health check template.  The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.
         */
        healthCheckTemplateName: string;
        /**
         * The timeout period of a health check response. If the backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the health check fails.  Valid values: `1` to `300`. Unit: seconds.  Default value: `5`.
         */
        healthCheckTimeout: number;
        /**
         * The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy (from fail to success). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
         */
        healthyThreshold: number;
        /**
         * The ID of the Health Check Template.
         */
        id: string;
        /**
         * The number of times that an healthy backend server must consecutively fail health checks before it is declared unhealthy (from success to fail). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
         */
        unhealthyThreshold: number;
    }

    export interface GetListenersListener {
        /**
         * Indicates whether the access log has a custom header field. Valid values: true and false. Default value: false.
         *
         * > **NOTE:** Only Instances outside the Security Group to Access the Log Switch **accesslogenabled** Open, in Order to Set This Parameter to the **True**.
         */
        accessLogRecordCustomizedHeadersEnabled: boolean;
        /**
         * Xtrace Configuration Information.
         */
        accessLogTracingConfigs: outputs.alb.GetListenersListenerAccessLogTracingConfig[];
        /**
         * The configurations of the access control lists (ACLs).
         */
        aclConfigs: outputs.alb.GetListenersListenerAclConfig[];
        /**
         * The Certificate List.
         */
        certificates: outputs.alb.GetListenersListenerCertificate[];
        /**
         * The Default Rule Action List.
         */
        defaultActions: outputs.alb.GetListenersListenerDefaultAction[];
        /**
         * Whether to Enable Gzip Compression, as a Specific File Type on a Compression. Valid Values: `True` Or `False`. Default Value: `True`.
         */
        gzipEnabled: boolean;
        /**
         * Whether to Enable HTTP/2 Features. Valid Values: `True` Or `False`. Default Value: `True`.
         *
         * > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
         */
        http2Enabled: boolean;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * Specify the Connection Idle Timeout Value: `1` to `60`. Unit: Seconds.
         */
        idleTimeout: number;
        /**
         * Set the IP Address of the Listened Description. Length Is from 2 to 256 Characters.
         */
        listenerDescription: string;
        /**
         * on Behalf of the Resource Level Id of the Resources Property Fields.
         */
        listenerId: string;
        /**
         * The ALB Instance Front-End, and Those of the Ports Used. Value: `1~65535`.
         */
        listenerPort: number;
        /**
         * Snooping Protocols. Valid Values: `HTTP`, `HTTPS` Or `QUIC`.
         */
        listenerProtocol: string;
        /**
         * The ALB Instance Id.
         */
        loadBalancerId: string;
        /**
         * This Request Returned by the Maximum Number of Records.
         */
        maxResults: string;
        /**
         * The Current Call Returns to the Position of the Set to Null Represents the Data Has Been Read to the End of.
         */
        nextToken: string;
        /**
         * Configuration Associated with the QuIC Listening.
         */
        quicConfigs: outputs.alb.GetListenersListenerQuicConfig[];
        /**
         * The Specified Request Timeout Time. Value: `1` to `180`. Unit: Seconds. Default Value: 60. If the Timeout Time Within the Back-End Server Has Not Answered the ALB Will Give up Waiting, the Client Returns the HTTP 504 Error Code.
         */
        requestTimeout: number;
        /**
         * Security Policy.
         *
         * > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
         */
        securityPolicyId: string;
        /**
         * The association status between the ACL and the listener.  Valid values: `Associating`, `Associated` Or `Dissociating`. `Associating`: The ACL is being associated with the listener. `Associated`: The ACL is associated with the listener. `Dissociating`: The ACL is being disassociated from the listener.
         */
        status: string;
        /**
         * xforwardfor Related Attribute Configuration.
         */
        xforwardedForConfigs: outputs.alb.GetListenersListenerXforwardedForConfig[];
    }

    export interface GetListenersListenerAccessLogTracingConfig {
        /**
         * Xtrace Function. Value: True Or False. Default Value: False.
         *
         * > **NOTE:** Only Instances outside the Security Group to Access the Log Switch **accesslogenabled** Open, in Order to Set This Parameter to the **True**.
         */
        tracingEnabled: boolean;
        /**
         * Xtrace Sampling Rate. Value: **1~10000**.
         *
         * > **NOTE:** This attribute is valid when **tracingenabled** is **true**.
         */
        tracingSample: number;
        /**
         * Xtrace Type Value Is **Zipkin**.
         *
         * > **NOTE:** This attribute is valid when **tracingenabled** is **true**.
         */
        tracingType: string;
    }

    export interface GetListenersListenerAclConfig {
        /**
         * The ACLs that are associated with the listener.
         */
        aclRelations: outputs.alb.GetListenersListenerAclConfigAclRelation[];
        /**
         * The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
         */
        aclType: string;
    }

    export interface GetListenersListenerAclConfigAclRelation {
        /**
         * Snooping Binding of the Access Policy Group ID List.
         */
        aclId: string;
        /**
         * The association status between the ACL and the listener.  Valid values: `Associating`, `Associated` Or `Dissociating`. `Associating`: The ACL is being associated with the listener. `Associated`: The ACL is associated with the listener. `Dissociating`: The ACL is being disassociated from the listener.
         */
        status: string;
    }

    export interface GetListenersListenerCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
    }

    export interface GetListenersListenerDefaultAction {
        /**
         * The configuration of the forwarding rule action. This parameter is required if the Type parameter is set to FowardGroup.
         */
        forwardGroupConfigs: outputs.alb.GetListenersListenerDefaultActionForwardGroupConfig[];
        /**
         * Action Type. The value is set to ForwardGroup. It indicates that requests are forwarded to multiple vServer groups.
         */
        type: string;
    }

    export interface GetListenersListenerDefaultActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.GetListenersListenerDefaultActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetListenersListenerDefaultActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface GetListenersListenerQuicConfig {
        /**
         * The ID of the QUIC listener to be associated. If QuicUpgradeEnabled is set to true, this parameter is required. Only HTTPS listeners support this parameter.
         */
        quicListenerId: string;
        /**
         * Indicates whether quic upgrade is enabled. Valid values: true and false. Default value: false.
         */
        quicUpgradeEnabled: boolean;
    }

    export interface GetListenersListenerXforwardedForConfig {
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertIssuerdnenabled`, Which Evaluates to True When the Entry into Force of.
         */
        xforwardedforclientcertIssuerdnalias: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
         */
        xforwardedforclientcertIssuerdnenabled: boolean;
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertclientverifyenabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertclientverifyalias: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
         */
        xforwardedforclientcertclientverifyenabled: boolean;
        /**
         * The Custom Header Field Names Only When `xforwardedforclientcertfingerprintenabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertfingerprintalias: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
         */
        xforwardedforclientcertfingerprintenabled: boolean;
        /**
         * The name of the custom header. This parameter is valid only if `xforwardedforclientcertsubjectdnenabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xforwardedforclientcertsubjectdnalias: string;
        /**
         * Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
         */
        xforwardedforclientcertsubjectdnenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
         */
        xforwardedforclientsrcportenabled: boolean;
        /**
         * Indicates whether the X-Forwarded-For header field is used to obtain the real IP address of tqhe client. Valid values: true and false. Default value: true.
         */
        xforwardedforenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
         */
        xforwardedforprotoenabled: boolean;
        /**
         * Indicates whether the SLB-ID header field is used to obtain the ID of the ALB instance. Valid values: true and false. Default value: false.
         */
        xforwardedforslbidenabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
         */
        xforwardedforslbportenabled: boolean;
    }

    export interface GetLoadBalancersBalancer {
        /**
         * The Access Logging Configuration Structure.
         */
        accessLogConfigs: outputs.alb.GetLoadBalancersBalancerAccessLogConfig[];
        /**
         * The method in which IP addresses are assigned. Valid values:  Fixed: The ALB instance
         * uses a fixed IP address. Dynamic (default): An IP address is dynamically assigned to each zone of the ALB
         * instance.
         */
        addressAllocatedMode: string;
        /**
         * The type of IP address that the ALB instance uses to provide services.
         */
        addressType: string;
        /**
         * The ID of the EIP bandwidth plan which is associated with an ALB instance that uses a
         * public IP address.
         */
        bandwidthPackageId: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * Remove the Protection Configuration.
         */
        deletionProtectionConfigs: outputs.alb.GetLoadBalancersBalancerDeletionProtectionConfig[];
        /**
         * DNS Domain Name.
         */
        dnsName: string;
        /**
         * The ID of the Load Balancer.
         */
        id: string;
        /**
         * The configuration of the billing method.
         */
        loadBalancerBillingConfigs: outputs.alb.GetLoadBalancersBalancerLoadBalancerBillingConfig[];
        /**
         * Load Balancing of the Service Status. Valid Values: `Abnormal` and `Normal`. **NOTE:** Available in 1.142.0+
         */
        loadBalancerBusinessStatus: string;
        /**
         * Load Balancing of the Service Status. Valid Values: `Abnormal` and `Normal`.  **NOTE:** Field 'load_balancer_bussiness_status' has been deprecated from provider version 1.142.0.
         *
         * @deprecated Field 'load_balancer_bussiness_status' has been deprecated from provider version 1.142.0 and it will be removed in the future version. Please use the new parameter 'load_balancer_business_status' instead.
         */
        loadBalancerBussinessStatus: string;
        /**
         * The edition of the ALB instance.
         */
        loadBalancerEdition: string;
        /**
         * The first ID of the resource.
         */
        loadBalancerId: string;
        /**
         * The name of the resource.
         */
        loadBalancerName: string;
        /**
         * The Load Balancing Operations Lock Configuration.
         */
        loadBalancerOperationLocks: outputs.alb.GetLoadBalancersBalancerLoadBalancerOperationLock[];
        /**
         * Modify the Protection Configuration.
         */
        modificationProtectionConfigs: outputs.alb.GetLoadBalancersBalancerModificationProtectionConfig[];
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
         */
        status: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the virtual private cloud (VPC) where the ALB instance is deployed.
         */
        vpcId: string;
        /**
         * The zones and vSwitches. You must specify at least two zones.
         */
        zoneMappings: outputs.alb.GetLoadBalancersBalancerZoneMapping[];
    }

    export interface GetLoadBalancersBalancerAccessLogConfig {
        /**
         * The log service that access logs are shipped to.
         */
        logProject: string;
        /**
         * The logstore that access logs are shipped to.
         */
        logStore: string;
    }

    export interface GetLoadBalancersBalancerDeletionProtectionConfig {
        /**
         * Remove the Protection Status.
         */
        enabled: boolean;
        /**
         * Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm:SSZ.
         */
        enabledTime: string;
    }

    export interface GetLoadBalancersBalancerLoadBalancerBillingConfig {
        /**
         * The billing method of the ALB instance. Valid value: `PayAsYouGo`.
         */
        payType: string;
    }

    export interface GetLoadBalancersBalancerLoadBalancerOperationLock {
        /**
         * The Locking of the Reasons.
         */
        lockReason: string;
        /**
         * The Locking of the Type. Valid Values: `securitylocked`,`relatedresourcelocked`, `financiallocked`, and `residuallocked`.
         */
        lockType: string;
    }

    export interface GetLoadBalancersBalancerModificationProtectionConfig {
        /**
         * The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
         */
        reason: string;
        /**
         * The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
         */
        status: string;
    }

    export interface GetLoadBalancersBalancerZoneMapping {
        loadBalancerAddresses: outputs.alb.GetLoadBalancersBalancerZoneMappingLoadBalancerAddress[];
        /**
         * The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
         */
        vswitchId: string;
        /**
         * The ID of the zone to which the ALB instance belongs.
         */
        zoneId: string;
    }

    export interface GetLoadBalancersBalancerZoneMappingLoadBalancerAddress {
        address: string;
    }

    export interface GetRulesRule {
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * The ID of the listener to which the forwarding rule belongs.
         */
        listenerId: string;
        /**
         * The ID of the Application Load Balancer (ALB) instance to which the forwarding rule belongs.
         */
        loadBalancerId: string;
        /**
         * The priority of the rule. Valid values: 1 to 10000. A smaller value indicates a higher priority.  Note The priority of each rule within the same listener must be unique.
         */
        priority: number;
        /**
         * The actions of the forwarding rules.
         */
        ruleActions: outputs.alb.GetRulesRuleRuleAction[];
        /**
         * The conditions of the forwarding rule.
         */
        ruleConditions: outputs.alb.GetRulesRuleRuleCondition[];
        /**
         * The first ID of the resource.
         */
        ruleId: string;
        /**
         * The name of the forwarding rule. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.
         */
        ruleName: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetRulesRuleRuleAction {
        /**
         * The configuration of the fixed response.
         */
        fixedResponseConfigs: outputs.alb.GetRulesRuleRuleActionFixedResponseConfig[];
        /**
         * The configurations of the destination server groups.
         */
        forwardGroupConfigs: outputs.alb.GetRulesRuleRuleActionForwardGroupConfig[];
        /**
         * The configuration of the inserted header field.
         */
        insertHeaderConfigs: outputs.alb.GetRulesRuleRuleActionInsertHeaderConfig[];
        /**
         * The order of the forwarding rule actions. Valid values:1 to 50000. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
         */
        order: number;
        /**
         * The configuration of the external redirect action.
         */
        redirectConfigs: outputs.alb.GetRulesRuleRuleActionRedirectConfig[];
        /**
         * The redirect action within ALB.
         */
        rewriteConfigs: outputs.alb.GetRulesRuleRuleActionRewriteConfig[];
        /**
         * The Flow speed limit.
         */
        trafficLimitConfigs: outputs.alb.GetRulesRuleRuleActionTrafficLimitConfig[];
        /**
         * The Traffic mirroring.
         */
        trafficMirrorConfigs: outputs.alb.GetRulesRuleRuleActionTrafficMirrorConfig[];
        /**
         * The type of the forwarding rule.
         */
        type: string;
    }

    export interface GetRulesRuleRuleActionFixedResponseConfig {
        /**
         * The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
         */
        content: string;
        /**
         * The format of the fixed response.  Valid values: text/plain, text/css, text/html, application/javascript, and application/json.
         */
        contentType: string;
        /**
         * The redirect method. Valid values:301, 302, 303, 307, and 308.
         */
        httpCode: string;
    }

    export interface GetRulesRuleRuleActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.GetRulesRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetRulesRuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
        /**
         * The Weight of server group.
         */
        weight: number;
    }

    export interface GetRulesRuleRuleActionInsertHeaderConfig {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters, asterisks (*), and question marks (?). The value cannot contain spaces or the following special characters: # [ ] { } \ | < > &.
         */
        value: string;
        /**
         * Valid values:  UserDefined: a custom value ReferenceHeader: uses a field of the user request header. SystemDefined: a system value.
         */
        valueType: string;
    }

    export interface GetRulesRuleRuleActionRedirectConfig {
        /**
         * The host name of the destination to which requests are redirected within ALB.  Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host: string;
        /**
         * The redirect method. Valid values:301, 302, 303, 307, and 308.
         */
        httpCode: string;
        /**
         * The path to which requests are to be redirected within ALB.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive.  Default value: ${path}. This value can be used only once. You can use it with a valid string.
         */
        path: string;
        /**
         * The port of the destination to which requests are redirected.  Valid values: 1 to 63335.  Default value: ${port}. You cannot use this value together with other characters at the same time.
         */
        port: string;
        /**
         * The protocol of the requests to be redirected.  Valid values: HTTP and HTTPS.  Default value: ${protocol}. You cannot use this value together with other characters at the same time.  Note HTTPS listeners can redirect only HTTPS requests.
         */
        protocol: string;
        /**
         * The query string of the request to be redirected within ALB.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. This value can be used only once. You can use it with a valid string.
         */
        query: string;
    }

    export interface GetRulesRuleRuleActionRewriteConfig {
        /**
         * The host name of the destination to which requests are redirected within ALB.  Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host: string;
        /**
         * The path to which requests are to be redirected within ALB.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive.  Default value: ${path}. This value can be used only once. You can use it with a valid string.
         */
        path: string;
        /**
         * The query string of the request to be redirected within ALB.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. This value can be used only once. You can use it with a valid string.
         */
        query: string;
    }

    export interface GetRulesRuleRuleActionTrafficLimitConfig {
        /**
         * The Number of requests per second.
         */
        qps: number;
    }

    export interface GetRulesRuleRuleActionTrafficMirrorConfig {
        /**
         * The Traffic is mirrored to the server group.
         */
        mirrorGroupConfigs: outputs.alb.GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfig[];
        /**
         * The Mirror target type.
         */
        targetType: string;
    }

    export interface GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfig {
        /**
         * The destination server group to which requests are forwarded.
         */
        serverGroupTuples: outputs.alb.GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple[];
    }

    export interface GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface GetRulesRuleRuleCondition {
        /**
         * The configuration of the cookie.
         */
        cookieConfigs: outputs.alb.GetRulesRuleRuleConditionCookieConfig[];
        /**
         * The configuration of the header field.
         */
        headerConfigs: outputs.alb.GetRulesRuleRuleConditionHeaderConfig[];
        /**
         * The configuration of the host.
         */
        hostConfigs: outputs.alb.GetRulesRuleRuleConditionHostConfig[];
        /**
         * The configuration of the request method.
         */
        methodConfigs: outputs.alb.GetRulesRuleRuleConditionMethodConfig[];
        /**
         * The configuration of the path for the request to be forwarded.
         */
        pathConfigs: outputs.alb.GetRulesRuleRuleConditionPathConfig[];
        /**
         * The configuration of the query string.
         */
        queryStringConfigs: outputs.alb.GetRulesRuleRuleConditionQueryStringConfig[];
        /**
         * The Based on source IP traffic matching.
         */
        sourceIpConfigs: outputs.alb.GetRulesRuleRuleConditionSourceIpConfig[];
        /**
         * The type of the forwarding rule.
         */
        type: string;
    }

    export interface GetRulesRuleRuleConditionCookieConfig {
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: outputs.alb.GetRulesRuleRuleConditionCookieConfigValue[];
    }

    export interface GetRulesRuleRuleConditionCookieConfigValue {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters, asterisks (*), and question marks (?). The value cannot contain spaces or the following special characters: # [ ] { } \ | < > &.
         */
        value: string;
    }

    export interface GetRulesRuleRuleConditionHeaderConfig {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionHostConfig {
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionMethodConfig {
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionPathConfig {
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: string[];
    }

    export interface GetRulesRuleRuleConditionQueryStringConfig {
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: outputs.alb.GetRulesRuleRuleConditionQueryStringConfigValue[];
    }

    export interface GetRulesRuleRuleConditionQueryStringConfigValue {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key: string;
        /**
         * The value must be 1 to 128 characters in length, and can contain lowercase letters, printable characters, asterisks (*), and question marks (?). The value cannot contain spaces or the following special characters: # [ ] { } \ | < > &.
         */
        value: string;
    }

    export interface GetRulesRuleRuleConditionSourceIpConfig {
        /**
         * Add one or more IP addresses or IP address segments.
         */
        values: string[];
    }

    export interface GetSecurityPoliciesPolicy {
        /**
         * The supported cipher suites, which are determined by the TLS protocol version.
         */
        ciphers: string[];
        /**
         * The ID of the Security Policy.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The first ID of the resource.
         */
        securityPolicyId: string;
        /**
         * The name of the resource. The name must be 2 to 128 characters in length and must start with a letter. It can contain digits, periods (.), underscores (_), and hyphens (-).
         */
        securityPolicyName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The TLS protocol versions that are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
         */
        tlsVersions: string[];
    }

    export interface GetServerGroupsGroup {
        /**
         * The configuration of health checks.
         */
        healthCheckConfigs: outputs.alb.GetServerGroupsGroupHealthCheckConfig[];
        /**
         * The ID of the Server Group.
         */
        id: string;
        /**
         * The server protocol. Valid values: `HTTP` and `HTTPS`. Default value: `HTTP`.
         */
        protocol: string;
        /**
         * The scheduling algorithm. Valid values: `Wrr`, `Wlc` and `Sch`.
         */
        scheduler: string;
        /**
         * The first ID of the res ource.
         */
        serverGroupId: string;
        /**
         * The name of the resource.
         */
        serverGroupName: string;
        /**
         * The backend server.
         */
        servers: outputs.alb.GetServerGroupsGroupServer[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The configuration of the sticky session.
         */
        stickySessionConfigs: outputs.alb.GetServerGroupsGroupStickySessionConfig[];
        /**
         * A map of tags assigned to the group.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC that you want to access.
         */
        vpcId: string;
    }

    export interface GetServerGroupsGroupHealthCheckConfig {
        /**
         * The status code for a successful health check. Multiple status codes can be specified as a list. Valid values: `http2xx`, `http3xx`, `http4xx`, and `http5xx`. Default value: `http2xx`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckCodes: string[];
        /**
         * The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of `0` indicates that a backend server port is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
         */
        healthCheckEnabled: boolean;
        /**
         * The domain name that is used for health checks.
         */
        healthCheckHost: string;
        /**
         * HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckHttpVersion: string;
        /**
         * The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
         */
        healthCheckInterval: number;
        /**
         * Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckMethod: string;
        /**
         * The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckPath: string;
        /**
         * Health check protocol. Valid values: `HTTP` and `TCP`.
         */
        healthCheckProtocol: string;
        /**
         * The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: `1` to `300`. Default value: `5`. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
         */
        healthCheckTimeout: number;
        /**
         * The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: `2` to `10`. Default value: `3`.
         */
        healthyThreshold: number;
        /**
         * The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
         */
        unhealthyThreshold: number;
    }

    export interface GetServerGroupsGroupServer {
        /**
         * The description of the server.
         */
        description: string;
        /**
         * The port that is used by the server. Valid values: `1` to `65535`.
         */
        port: number;
        /**
         * The ID of the ECS instance, ENI instance or ECI instance.
         */
        serverId: string;
        /**
         * The IP address of the ENI instance when it is in the inclusive ENI mode.
         */
        serverIp: string;
        /**
         * The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
         */
        serverType: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The weight of the server.  Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no requests are forwarded to the server.
         */
        weight: number;
    }

    export interface GetServerGroupsGroupStickySessionConfig {
        /**
         * the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession` parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
         */
        cookie: string;
        /**
         * The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
         */
        cookieTimeout: number;
        /**
         * Indicates whether sticky session is enabled. Values: `true` and `false`. Default value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
         */
        stickySessionEnabled: boolean;
        /**
         * The method that is used to handle a cookie. Values: `Server` and `Insert`.
         */
        stickySessionType: string;
    }

    export interface GetSystemSecurityPoliciesPolicy {
        /**
         * The supported cipher suites, which are determined by the TLS protocol version.
         */
        ciphers: string[];
        /**
         * The ID of the Security Policy.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        securityPolicyId: string;
        /**
         * The TLS protocol versions are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
         */
        tlsVersions: string[];
    }

    export interface GetZonesZone {
        /**
         * The ID of zone.
         */
        id: string;
        /**
         * The local name.
         */
        localName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface ListenerAccessLogTracingConfig {
        /**
         * Xtrace Function. Value: `True` Or `False` . Default Value: `False`.
         *
         * > **NOTE:** Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the `True`.
         */
        tracingEnabled?: boolean;
        /**
         * Xtrace Sampling Rate. Value: `1` to `10000`.
         *
         * > **NOTE:** This attribute is valid when `tracingenabled` is `true`.
         */
        tracingSample?: number;
        /**
         * Xtrace Type Value Is `Zipkin`.
         *
         * > **NOTE:** This attribute is valid when `tracingenabled` is `true`.
         */
        tracingType?: string;
    }

    export interface ListenerAclConfig {
        /**
         * The ACLs that are associated with the listener. See `aclRelations` below for details.
         */
        aclRelations?: outputs.alb.ListenerAclConfigAclRelation[];
        /**
         * The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
         */
        aclType: string;
    }

    export interface ListenerAclConfigAclRelation {
        /**
         * Snooping Binding of the Access Policy Group ID List.
         */
        aclId: string;
        /**
         * The state of the listener. Valid Values: `Running` Or `Stopped`. Valid values: `Running`: The listener is running. `Stopped`: The listener is stopped.
         */
        status: string;
    }

    export interface ListenerCertificates {
        /**
         * The ID of the Certificate.
         */
        certificateId?: string;
    }

    export interface ListenerDefaultAction {
        /**
         * The configurations of the actions. This parameter is required if Type is set to FowardGroup. See `forwardGroupConfig` below for details.
         */
        forwardGroupConfig: outputs.alb.ListenerDefaultActionForwardGroupConfig;
        /**
         * Action Type.
         */
        type: string;
    }

    export interface ListenerDefaultActionForwardGroupConfig {
        /**
         * The destination server group to which requests are forwarded. See `serverGroupTuples` below for details.
         */
        serverGroupTuples: outputs.alb.ListenerDefaultActionForwardGroupConfigServerGroupTuple[];
    }

    export interface ListenerDefaultActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
    }

    export interface ListenerQuicConfig {
        /**
         * There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
         */
        quicListenerId?: string;
        /**
         * Indicates Whether to Enable the QuIC Upgrade.
         *
         * > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
         */
        quicUpgradeEnabled: boolean;
    }

    export interface ListenerXForwardedForConfig {
        /**
         * The Custom Header Field Names Only When `xForwardedForClientCertClientVerifyEnabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xForwardedForClientCertClientVerifyAlias?: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
         */
        xForwardedForClientCertClientVerifyEnabled: boolean;
        /**
         * The Custom Header Field Names Only When `xForwardedForClientCertfingerprintEnabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xForwardedForClientCertFingerPrintAlias?: string;
        /**
         * Indicates Whether the `X-Forwarded-client_cert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
         */
        xForwardedForClientCertFingerPrintEnabled: boolean;
        /**
         * The Custom Header Field Names Only When `xForwardedForClientCertIssuerDnEnabled`, Which Evaluates to True When the Entry into Force of.
         */
        xForwardedForClientCertIssuerDnAlias?: string;
        /**
         * Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
         */
        xForwardedForClientCertIssuerDnEnabled: boolean;
        /**
         * The name of the custom header. This parameter is valid only if `xForwardedForClientCertsubjectdnEnabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
         */
        xForwardedForClientCertSubjectDnAlias?: string;
        /**
         * Specifies whether to use the `X-Forwarded-client_cert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
         */
        xForwardedForClientCertSubjectDnEnabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
         */
        xForwardedForClientSrcPortEnabled: boolean;
        /**
         * Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
         */
        xForwardedForEnabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
         */
        xForwardedForProtoEnabled: boolean;
        /**
         * Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id.
         */
        xForwardedForSlbIdEnabled: boolean;
        /**
         * Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
         */
        xForwardedForSlbPortEnabled: boolean;
    }

    export interface LoadBalancerAccessLogConfig {
        /**
         * The log service that access logs are shipped to.
         */
        logProject?: string;
        /**
         * The log service that access logs are shipped to.
         */
        logStore?: string;
    }

    export interface LoadBalancerLoadBalancerBillingConfig {
        /**
         * The billing method of the ALB instance. Valid value: `PayAsYouGo`.
         */
        payType: string;
    }

    export interface LoadBalancerModificationProtectionConfig {
        /**
         * The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. **Note:** This parameter takes effect only when `status` is set to `ConsoleProtection`.
         */
        reason: string;
        /**
         * Specifies whether to enable the configuration read-only mode for the ALB instance. Valid values: `NonProtection` and `ConsoleProtection`.
         */
        status: string;
    }

    export interface LoadBalancerZoneMapping {
        /**
         * The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
         */
        vswitchId: string;
        /**
         * The ID of the zone to which the ALB instance belongs.
         */
        zoneId: string;
    }

    export interface RuleRuleAction {
        /**
         * Request forwarding based on CORS. See `corsConfig` below for details.
         */
        corsConfig?: outputs.alb.RuleRuleActionCorsConfig;
        /**
         * The configuration of the fixed response. See `fixedResponseConfig` below for details.
         */
        fixedResponseConfig?: outputs.alb.RuleRuleActionFixedResponseConfig;
        /**
         * The forward response action within ALB. See `forwardGroupConfig` below for details.
         */
        forwardGroupConfig: outputs.alb.RuleRuleActionForwardGroupConfig;
        /**
         * The configuration of the inserted header field. See `insertHeaderConfig` below for details.
         */
        insertHeaderConfig?: outputs.alb.RuleRuleActionInsertHeaderConfig;
        /**
         * The order of the forwarding rule actions. Valid values: 1 to 50000. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
         */
        order: number;
        /**
         * The configuration of the external redirect action. See `redirectConfig` below for details.
         */
        redirectConfig?: outputs.alb.RuleRuleActionRedirectConfig;
        /**
         * The redirect action within ALB. See `rewriteConfig` below for details.
         */
        rewriteConfig?: outputs.alb.RuleRuleActionRewriteConfig;
        /**
         * The Flow speed limit. See `trafficLimitConfig` below for details.
         */
        trafficLimitConfig?: outputs.alb.RuleRuleActionTrafficLimitConfig;
        /**
         * The Traffic mirroring. See `trafficMirrorConfig` below for details.
         */
        trafficMirrorConfig?: outputs.alb.RuleRuleActionTrafficMirrorConfig;
        /**
         * The action. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
         * **Note:**  The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
         * **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available in 1.162.0+.
         * **NOTE:** From version 1.205.0+, `type` can be set to `Cors`.
         */
        type: string;
    }

    export interface RuleRuleActionCorsConfig {
        /**
         * Specifies whether credentials can be passed during CORS operations. Valid values: `on`, `off`.
         */
        allowCredentials?: string;
        /**
         * The allowed headers for CORS requests.
         */
        allowHeaders?: string[];
        /**
         * The allowed HTTP methods for CORS requests. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `PATCH`.
         */
        allowMethods?: string[];
        /**
         * The allowed origins of CORS requests.
         */
        allowOrigins?: string[];
        /**
         * The headers that can be exposed.
         */
        exposeHeaders?: string[];
        /**
         * The maximum cache time of preflight requests in the browser. Unit: seconds. Valid values: `-1` to `172800`.
         */
        maxAge?: number;
    }

    export interface RuleRuleActionFixedResponseConfig {
        /**
         * The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
         */
        content: string;
        /**
         * The format of the fixed response.  Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
         */
        contentType?: string;
        /**
         * The redirect method. Valid values:301, 302, 303, 307, and 308.
         */
        httpCode?: string;
    }

    export interface RuleRuleActionForwardGroupConfig {
        /**
         * The configuration of session persistence for server groups. See `serverGroupStickySession` below for details.
         */
        serverGroupStickySession: outputs.alb.RuleRuleActionForwardGroupConfigServerGroupStickySession;
        /**
         * The destination server group to which requests are forwarded. See `serverGroupTuples` below for details.
         */
        serverGroupTuples: outputs.alb.RuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface RuleRuleActionForwardGroupConfigServerGroupStickySession {
        /**
         * Whether to enable session persistence.
         */
        enabled: boolean;
        /**
         * The timeout period. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
         */
        timeout: number;
    }

    export interface RuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId: string;
        /**
         * The Weight of server group. Default value: `100`. **NOTE:** This attribute is required when the number of `serverGroupTuples` is greater than 2.
         */
        weight?: number;
    }

    export interface RuleRuleActionInsertHeaderConfig {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key?: string;
        /**
         * The value of the values list.
         */
        value?: string;
        /**
         * Valid values:  UserDefined: a custom value ReferenceHeader: uses a field of the user request header. SystemDefined: a system value.
         */
        valueType?: string;
    }

    export interface RuleRuleActionRedirectConfig {
        /**
         * The host name of the destination to which requests are redirected within ALB.  Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host?: string;
        /**
         * The redirect method. Valid values:301, 302, 303, 307, and 308.
         */
        httpCode?: string;
        /**
         * The path to which requests are to be redirected within ALB.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive.  Default value: ${path}. This value can be used only once. You can use it with a valid string.
         */
        path?: string;
        /**
         * The port of the destination to which requests are redirected.  Valid values: 1 to 63335.  Default value: ${port}. You cannot use this value together with other characters at the same time.
         */
        port?: string;
        /**
         * The protocol of the requests to be redirected.  Valid values: HTTP and HTTPS.  Default value: ${protocol}. You cannot use this value together with other characters at the same time.  Note HTTPS listeners can redirect only HTTPS requests.
         */
        protocol?: string;
        /**
         * The query string of the request to be redirected within ALB.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. This value can be used only once. You can use it with a valid string.
         */
        query?: string;
    }

    export interface RuleRuleActionRewriteConfig {
        /**
         * The host name of the destination to which requests are redirected within ALB.  Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
         */
        host?: string;
        /**
         * The path to which requests are to be redirected within ALB.  Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive.  Default value: ${path}. This value can be used only once. You can use it with a valid string.
         */
        path?: string;
        /**
         * The query string of the request to be redirected within ALB.  The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \ | < > &.  Default value: ${query}. This value can be used only once. You can use it with a valid string.
         */
        query?: string;
    }

    export interface RuleRuleActionTrafficLimitConfig {
        /**
         * The Number of requests per second. Value range: 1~100000.
         */
        qps?: number;
    }

    export interface RuleRuleActionTrafficMirrorConfig {
        /**
         * The Traffic is mirrored to the server group. See `mirrorGroupConfig` below for details.
         */
        mirrorGroupConfig?: outputs.alb.RuleRuleActionTrafficMirrorConfigMirrorGroupConfig;
        /**
         * The Mirror target type.
         */
        targetType?: string;
    }

    export interface RuleRuleActionTrafficMirrorConfigMirrorGroupConfig {
        /**
         * The destination server group to which requests are forwarded. See `serverGroupTuples` below for details.
         */
        serverGroupTuples?: outputs.alb.RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple[];
    }

    export interface RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple {
        /**
         * The ID of the destination server group to which requests are forwarded.
         */
        serverGroupId?: string;
    }

    export interface RuleRuleCondition {
        /**
         * The configuration of the cookie. See See `cookieConfig` below for details.
         */
        cookieConfig?: outputs.alb.RuleRuleConditionCookieConfig;
        /**
         * The configuration of the header field. See `headerConfig` below for details.
         */
        headerConfig?: outputs.alb.RuleRuleConditionHeaderConfig;
        /**
         * The configuration of the host field. See `hostConfig` below for details.
         */
        hostConfig?: outputs.alb.RuleRuleConditionHostConfig;
        /**
         * The configuration of the request method. See `methodConfig` below for details.
         */
        methodConfig?: outputs.alb.RuleRuleConditionMethodConfig;
        /**
         * The configuration of the path for the request to be forwarded. See `pathConfig` below for details.
         */
        pathConfig?: outputs.alb.RuleRuleConditionPathConfig;
        /**
         * The configuration of the query string. See `queryStringConfig` below for details.
         */
        queryStringConfig?: outputs.alb.RuleRuleConditionQueryStringConfig;
        /**
         * The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `sourceIpConfig` below for details.
         */
        sourceIpConfig?: outputs.alb.RuleRuleConditionSourceIpConfig;
        /**
         * The type of the forwarding rule. Valid values: `Header`, `Host`, `Path`,  `Cookie`, `QueryString`, `Method` and `SourceIp`.
         */
        type: string;
    }

    export interface RuleRuleConditionCookieConfig {
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: outputs.alb.RuleRuleConditionCookieConfigValue[];
    }

    export interface RuleRuleConditionCookieConfigValue {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key?: string;
        /**
         * The value of the values list.
         */
        value?: string;
    }

    export interface RuleRuleConditionHeaderConfig {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key?: string;
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: string[];
    }

    export interface RuleRuleConditionHostConfig {
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: string[];
    }

    export interface RuleRuleConditionMethodConfig {
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: string[];
    }

    export interface RuleRuleConditionPathConfig {
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: string[];
    }

    export interface RuleRuleConditionQueryStringConfig {
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: outputs.alb.RuleRuleConditionQueryStringConfigValue[];
    }

    export interface RuleRuleConditionQueryStringConfigValue {
        /**
         * The key of the header field. The key must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-) and underscores (_). The key does not support Cookie or Host.
         */
        key?: string;
        /**
         * The value of the values list.
         */
        value?: string;
    }

    export interface RuleRuleConditionSourceIpConfig {
        /**
         * The value of the header field. The value must be 1 to 128 characters in length, and can contain lowercase letters, printable ASCII characters whose values are ch >= 32 && ch < 127, asterisks (*), and question marks (?). The value cannot start or end with a space.
         */
        values?: string[];
    }

    export interface ServerGroupHealthCheckConfig {
        /**
         * The status code for a successful health check.  Multiple status codes can be specified as a list. Valid values: `http2xx`, `http3xx`, `http4xx`, and `http5xx`. Default value: `http2xx`. **NOTE:** This
         * parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckCodes: string[];
        /**
         * The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of 0 indicates that a backend server port is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
         */
        healthCheckEnabled?: boolean;
        /**
         * The domain name that is used for health checks.
         */
        healthCheckHost: string;
        /**
         * HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckHttpVersion: string;
        /**
         * The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
         */
        healthCheckInterval: number;
        /**
         * Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckMethod: string;
        /**
         * The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
         */
        healthCheckPath: string;
        /**
         * Health check protocol. Valid values: `HTTP` and `TCP`.
         */
        healthCheckProtocol: string;
        /**
         * The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: 1 to 300. Default value: 5. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
         */
        healthCheckTimeout: number;
        /**
         * The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: 2 to 10. Default value: 3.
         */
        healthyThreshold: number;
        /**
         * The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
         */
        unhealthyThreshold: number;
    }

    export interface ServerGroupServer {
        /**
         * The description of the server.
         */
        description?: string;
        /**
         * The port that is used by the server. Valid values: `1` to `65535`. **Note:** This parameter is required if the `serverType` parameter is set to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to configure this parameter if you set `serverType` to `Fc`.
         */
        port?: number;
        /**
         * Specifies whether to enable the remote IP address feature. You can specify up to 40 servers in each call. **Note:** If `serverType` is set to `Ip`, this parameter is available.
         */
        remoteIpEnabled: boolean;
        /**
         * The ID of the backend server.
         * - If `serverGroupType` is set to `Instance`, set the parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by Ecs, Eni, or Eci.
         * - If `serverGroupType` is set to `Ip`, set the parameter to an IP address specified in the server group.
         * - If `serverGroupType` is set to `Fc`, set the parameter to the Alibaba Cloud Resource Name (ARN) of a function specified in the server group.
         */
        serverId: string;
        /**
         * The IP address of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. **Note:** If `serverGroupType` is set to `Fc`, you do not need to configure parameters, otherwise this attribute is required. If `serverGroupType` is set to `Ip`, the value of this property is the same as the `serverId` value.
         */
        serverIp: string;
        /**
         * The type of the server. The type of the server. Valid values: 
         * - Ecs: an ECS instance.
         * - Eni: an ENI.
         * - Eci: an elastic container instance.
         * - Ip(Available in v1.194.0+): an IP address.
         * - fc(Available in v1.194.0+): a function.
         */
        serverType: string;
        /**
         * The status of the backend server. Valid values:
         */
        status: string;
        /**
         * The weight of the server. Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no
         * requests are forwarded to the server. **Note:** You do not need to set this parameter if you set `serverType` to `Fc`.
         */
        weight: number;
    }

    export interface ServerGroupStickySessionConfig {
        /**
         * the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession`
         * parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
         */
        cookie: string;
        /**
         * The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1`
         * to `86400`. Default value: `1000`.
         */
        cookieTimeout: number;
        /**
         * Indicates whether sticky session is enabled. Values: `true` and `false`. Default
         * value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
         */
        stickySessionEnabled?: boolean;
        /**
         * The method that is used to handle a cookie. Values: `Server` and `Insert`.
         */
        stickySessionType: string;
    }

}

export namespace amqp {
    export interface GetBindingsBinding {
        /**
         * X-match Attributes. Valid Values: All: Default Value, All the Message Header of Key-Value Pairs Stored in the Must Match. Any: at Least One Pair of the Message Header of Key-Value Pairs Stored in the Must Match. This Parameter Applies Only to Headers Exchange Other Types of Exchange Is Invalid. Other Types of Exchange Here Can Either Be an Arbitrary Value.
         */
        argument: string;
        /**
         * The Binding Key. The Source of the Binding Exchange Non-Topic Type: Can Only Contain Letters, Lowercase Letters, Numbers, and the Dash (-), the Underscore Character (_), English Periods (.) and the at Sign (@). Length from 1 to 255 Characters. The Source of the Binding Exchange Topic Type: Can Contain Letters, Lowercase Letters, Numbers, and the Dash (-), the Underscore Character (_), English Periods (.) and the at Sign (@). If You Include the Hash (.
         */
        bindingKey: string;
        /**
         * The Target Binding Types.
         */
        bindingType: string;
        /**
         * The Target Queue Or Exchange of the Name.
         */
        destinationName: string;
        /**
         * The ID of the Binding. The value formats as `<instance_id>:<virtual_host_name>:<source_exchange>:<destination_name>`.
         */
        id: string;
        /**
         * Instance Id.
         */
        instanceId: string;
        /**
         * The Source Exchange Name.
         */
        sourceExchange: string;
        /**
         * Virtualhost Name.
         */
        virtualHostName: string;
    }

    export interface GetExchangesExchange {
        /**
         * The attributes.
         */
        attributes: {[key: string]: any};
        /**
         * Indicates whether the Auto Delete attribute is configured.
         */
        autoDeleteState: boolean;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The name of the exchange.
         */
        exchangeName: string;
        /**
         * The type of the exchange.
         */
        exchangeType: string;
        /**
         * The ID of the Exchange. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The name of virtual host where an exchange resides.
         */
        virtualHostName: string;
    }

    export interface GetInstancesInstance {
        /**
         * OrderCreateTime.
         */
        createTime: string;
        /**
         * ExpireTime.
         */
        expireTime: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * THe instance Id.
         */
        instanceId: string;
        /**
         * THe instance name.
         */
        instanceName: string;
        /**
         * The instance type.
         */
        instanceType: string;
        /**
         * The Pay-as-You-Type Values Include: the Subscription of a Pre-Paid.
         */
        paymentType: string;
        /**
         * The private endPoint.
         */
        privateEndPoint: string;
        /**
         * The public dndpoint.
         */
        publicEndpoint: string;
        /**
         * Renewal duration.
         */
        renewalDuration: number;
        /**
         * Auto-Renewal Cycle Unit Values Include: Month: Month. Year: Years.
         */
        renewalDurationUnit: string;
        /**
         * Renew status.
         */
        renewalStatus: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Whether to support eip.
         */
        supportEip: boolean;
    }

    export interface GetQueuesQueue {
        /**
         * The attributes for the Queue.
         */
        attributes: {[key: string]: any};
        /**
         * Specifies whether the Auto Delete attribute is configured.
         */
        autoDeleteState: boolean;
        /**
         * CreateTime.
         */
        createTime: string;
        /**
         * Specifies whether the queue is an exclusive queue.
         */
        exclusiveState: boolean;
        /**
         * The ID of the Queue. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The last consume time.
         */
        lastConsumeTime: string;
        /**
         * The queue name.
         */
        queueName: string;
        /**
         * The name of the virtual host.
         */
        virtualHostName: string;
    }

    export interface GetStaticAccountsAccount {
        /**
         * Access key.
         */
        accessKey: string;
        /**
         * Create time stamp. Unix timestamp, to millisecond level.
         */
        createTime: string;
        /**
         * The `key` of the resource supplied above.The value is formulated as `<instance_id>:<access_key>`.
         */
        id: string;
        /**
         * InstanceId
         */
        instanceId: string;
        /**
         * The ID of the user's primary account.
         */
        masterUid: string;
        /**
         * Static password.
         */
        password: string;
        /**
         * Static username.
         */
        userName: string;
    }

    export interface GetVirtualHostsHost {
        /**
         * The ID of the Virtual Host.
         */
        id: string;
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * VirtualHostName.
         */
        virtualHostName: string;
    }

}

export namespace apigateway {
    export interface ApiConstantParameter {
        /**
         * The description of the api. Defaults to null.
         */
        description?: string;
        /**
         * Request's parameter location; values: BODY, HEAD, QUERY, and PATH.
         */
        in: string;
        /**
         * The name of the api gateway api. Defaults to null.
         */
        name: string;
        /**
         * Constant parameter value.
         */
        value: string;
    }

    export interface ApiFcServiceConfig {
        /**
         * RAM role arn attached to the Function Compute service. This governs both who / what can invoke your Function, as well as what resources our Function has access to. See [User Permissions](https://www.alibabacloud.com/help/doc-detail/52885.htm) for more details.
         */
        arnRole?: string;
        /**
         * The function name of function compute service.
         */
        functionName: string;
        /**
         * The region that the function compute service belongs to.
         */
        region: string;
        /**
         * The service name of function compute service.
         */
        serviceName: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiHttpServiceConfig {
        /**
         * The address of backend service.
         */
        address: string;
        aoneName?: string;
        /**
         * The method of the api, including 'GET','POST','PUT' etc.
         */
        method: string;
        /**
         * The request path of the api.
         */
        path: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiHttpVpcServiceConfig {
        aoneName?: string;
        /**
         * The method of the api, including 'GET','POST','PUT' etc.
         */
        method: string;
        /**
         * The name of the api gateway api. Defaults to null.
         */
        name: string;
        /**
         * The request path of the api.
         */
        path: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiMockServiceConfig {
        aoneName?: string;
        /**
         * The result of the mock service.
         */
        result: string;
    }

    export interface ApiRequestConfig {
        /**
         * The body format of the api, which support the values of 'STREAM' and 'FORM'.
         */
        bodyFormat?: string;
        /**
         * The method of the api, including 'GET','POST','PUT' etc.
         */
        method: string;
        /**
         * The mode of the parameters between request parameters and service parameters, which support the values of 'MAPPING' and 'PASSTHROUGH'.
         */
        mode: string;
        /**
         * The request path of the api.
         */
        path: string;
        /**
         * The protocol of api which supports values of 'HTTP','HTTPS' or 'HTTP,HTTPS'.
         */
        protocol: string;
    }

    export interface ApiRequestParameter {
        /**
         * The default value of the parameter.
         */
        defaultValue?: string;
        /**
         * The description of the api. Defaults to null.
         */
        description?: string;
        /**
         * Request's parameter location; values: BODY, HEAD, QUERY, and PATH.
         */
        in: string;
        /**
         * Backend service's parameter location; values: BODY, HEAD, QUERY, and PATH.
         */
        inService: string;
        /**
         * The name of the api gateway api. Defaults to null.
         */
        name: string;
        /**
         * Backend service's parameter name.
         */
        nameService: string;
        /**
         * Parameter required or not; values: REQUIRED and OPTIONAL.
         */
        required: string;
        /**
         * Parameter type which supports values of 'STRING','INT','BOOLEAN','LONG',"FLOAT" and "DOUBLE".
         */
        type: string;
    }

    export interface ApiSystemParameter {
        /**
         * Request's parameter location; values: BODY, HEAD, QUERY, and PATH.
         */
        in: string;
        /**
         * The name of the api gateway api. Defaults to null.
         */
        name: string;
        /**
         * Backend service's parameter name.
         */
        nameService: string;
    }

    export interface GetApisApi {
        /**
         * API description.
         */
        description: string;
        /**
         * ID of the specified group.
         */
        groupId: string;
        /**
         * The group name that the apis belong to.
         */
        groupName: string;
        /**
         * API ID, which is generated by the system and globally unique.
         */
        id: string;
        /**
         * API name.
         */
        name: string;
        /**
         * The ID of the region where the API is located.
         */
        regionId: string;
    }

    export interface GetAppsApp {
        /**
         * App code.
         */
        appCode: string;
        /**
         * Creation time (Greenwich mean time).
         */
        createdTime: string;
        /**
         * App description.
         */
        description: string;
        /**
         * App ID, which is generated by the system and globally unique.
         */
        id: number;
        /**
         * Last modification time (Greenwich mean time).
         */
        modifiedTime: string;
        /**
         * App name.
         */
        name: string;
    }

    export interface GetBackendsBackend {
        /**
         * The id of the Backend.
         */
        backendId: string;
        /**
         * The name of the Backend.
         */
        backendName: string;
        /**
         * The type of the Backend.
         */
        backendType: string;
        /**
         * The created time of the Backend.
         */
        createTime: string;
        /**
         * The description of the Backend.
         */
        description: string;
        id: string;
        /**
         * The modified time of the Backend.
         */
        modifiedTime: string;
    }

    export interface GetGroupsGroup {
        /**
         * Billing status.
         * - NORMAL: The API group is normal.
         * - LOCKED: Locked due to outstanding payment.
         */
        billingStatus: string;
        /**
         * Creation time (Greenwich mean time).
         */
        createdTime: string;
        /**
         * API group description.
         */
        description: string;
        /**
         * API group ID, which is generated by the system and globally unique.
         */
        id: string;
        /**
         * Locking in invalid state.
         * - NORMAL: The API group is normal.
         * - LOCKED: Locked due to illegality.
         */
        illegalStatus: string;
        /**
         * Last modification time (Greenwich mean time).
         */
        modifiedTime: string;
        /**
         * API group name.
         */
        name: string;
        /**
         * The ID of the region where the API group is located.
         */
        regionId: string;
        /**
         * Second-level domain name automatically assigned to the API group.
         */
        subDomain: string;
        /**
         * Upper QPS limit of the API group; default value: 500, which can be increased by submitting an application.
         */
        trafficLimit: number;
    }

    export interface GetLogConfigsConfig {
        /**
         * The ID of the Log Config.
         */
        id: string;
        /**
         * The type the of log.
         */
        logType: string;
        /**
         * The region ID of the Log Config.
         */
        regionId: string;
        /**
         * The name of the Log Store.
         */
        slsLogStore: string;
        /**
         * The name of the Project.
         */
        slsProject: string;
    }

    export interface GetModelsModel {
        /**
         * The creation time of the model.
         */
        createTime: string;
        /**
         * The description of the model.
         */
        description: string;
        /**
         * The ID of the api group.
         */
        groupId: string;
        /**
         * The ID of the Api Gateway Model.
         */
        id: string;
        /**
         * The id of the model.
         */
        modelId: string;
        /**
         * The name of the Model.
         */
        modelName: string;
        /**
         * The reference of the model.
         */
        modelRef: string;
        /**
         * The modified time of the model.
         */
        modifiedTime: string;
        /**
         * The schema of the model.
         */
        schema: string;
    }

    export interface GetPluginsPlugin {
        /**
         * The CreateTime of the resource.
         */
        createTime: string;
        /**
         * The description of the plug-in, which cannot exceed 200 characters.
         */
        description: string;
        /**
         * The ID of the Plugin.
         */
        id: string;
        /**
         * The ModifiedTime of the resource.
         */
        modifiedTime: string;
        /**
         * The definition statement of the plug-in. Plug-in definition statements in the JSON and YAML formats are supported.
         */
        pluginData: string;
        /**
         * The first ID of the resource.
         */
        pluginId: string;
        /**
         * The name of the plug-in that you want to create.
         */
        pluginName: string;
        /**
         * The type of the plug-in.
         */
        pluginType: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
    }

}

export namespace arms {
    export interface DispatchRuleGroupRule {
        groupId: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupInterval: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupWaitTime: number;
        /**
         * The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
         */
        groupingFields: string[];
        /**
         * The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
         */
        repeatInterval: number;
    }

    export interface DispatchRuleLabelMatchExpressionGrid {
        /**
         * Sets the dispatch rule. See the following `Block labelMatchExpressionGroups`.
         */
        labelMatchExpressionGroups: outputs.arms.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup[];
    }

    export interface DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup {
        /**
         * Sets the dispatch rule. See the following `Block labelMatchExpressions`.
         */
        labelMatchExpressions: outputs.arms.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression[];
    }

    export interface DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression {
        /**
         * The key of the tag of the dispatch rule. Valud values:
         * * _aliyun_arms_userid: user ID
         * * _aliyun_arms_involvedObject_kind: type of the associated object
         * * _aliyun_arms_involvedObject_id: ID of the associated object
         * * _aliyun_arms_involvedObject_name: name of the associated object
         * * _aliyun_arms_alert_name: alert name
         * * _aliyun_arms_alert_rule_id: alert rule ID
         * * _aliyun_arms_alert_type: alert type
         * * _aliyun_arms_alert_level: alert severity
         */
        key: string;
        /**
         * The operator used in the dispatch rule. Valid values: 
         * * eq: equals to.
         * * re: matches a regular expression.
         */
        operator: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface DispatchRuleNotifyRule {
        /**
         * The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
         */
        notifyChannels: string[];
        /**
         * Sets the notification object. See the following `Block notifyObjects`.
         */
        notifyObjects: outputs.arms.DispatchRuleNotifyRuleNotifyObject[];
    }

    export interface DispatchRuleNotifyRuleNotifyObject {
        /**
         * The name of the contact or contact group.
         */
        name: string;
        /**
         * The ID of the contact or contact group.
         */
        notifyObjectId: string;
        /**
         * The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
         */
        notifyType: string;
    }

    export interface GetAlertContactGroupsGroup {
        /**
         * The first ID of the resource.
         */
        alertContactGroupId: string;
        /**
         * The name of the resource.
         */
        alertContactGroupName: string;
        /**
         * contact ids.
         */
        contactIds: string[];
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Alert Contact Group.
         */
        id: string;
    }

    export interface GetAlertContactsContact {
        /**
         * Contact ID.
         */
        alertContactId: string;
        /**
         * The name of the alert contact.
         */
        alertContactName: string;
        /**
         * The Creation Time Timestamp.
         */
        createTime: string;
        /**
         * The webhook URL of the DingTalk chatbot.
         */
        dingRobotWebhookUrl: string;
        /**
         * The email address of the alert contact.
         */
        email: string;
        /**
         * The ID of the Alert Contact.
         */
        id: string;
        /**
         * The mobile number of the alert contact.
         */
        phoneNum: string;
        /**
         * Specifies whether the alert contact receives system notifications.
         */
        systemNoc: boolean;
        /**
         * Webhook Information.
         */
        webhook: string;
    }

    export interface GetDispatchRulesRule {
        /**
         * Dispatch rule ID.
         */
        dispatchRuleId: string;
        /**
         * The name of the dispatch rule.
         */
        dispatchRuleName: string;
        dispatchType: string;
        /**
         * Sets the event group.
         */
        groupRules: outputs.arms.GetDispatchRulesRuleGroupRule[];
        /**
         * The ID of the Dispatch Rule.
         */
        id: string;
        /**
         * Sets the dispatch rule.
         */
        labelMatchExpressionGrids: outputs.arms.GetDispatchRulesRuleLabelMatchExpressionGrid[];
        /**
         * Sets the notification rule.
         */
        notifyRules: outputs.arms.GetDispatchRulesRuleNotifyRule[];
        /**
         * The resource status of Alert Dispatch Rule.
         */
        status: string;
    }

    export interface GetDispatchRulesRuleGroupRule {
        groupId: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupInterval: number;
        /**
         * The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
         */
        groupWaitTime: number;
        /**
         * The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
         */
        groupingFields: string[];
        /**
         * The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
         */
        repeatInterval: number;
    }

    export interface GetDispatchRulesRuleLabelMatchExpressionGrid {
        /**
         * Sets the dispatch rule.
         */
        labelMatchExpressionGroups: outputs.arms.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroup[];
    }

    export interface GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroup {
        /**
         * Sets the dispatch rule.
         */
        labelMatchExpressions: outputs.arms.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression[];
    }

    export interface GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression {
        /**
         * The key of the tag of the dispatch rule.
         */
        key: string;
        /**
         * The operator used in the dispatch rule.
         */
        operator: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface GetDispatchRulesRuleNotifyRule {
        /**
         * The notification method.
         */
        notifyChannels: string[];
        /**
         * Sets the notification object.
         */
        notifyObjects: outputs.arms.GetDispatchRulesRuleNotifyRuleNotifyObject[];
    }

    export interface GetDispatchRulesRuleNotifyRuleNotifyObject {
        /**
         * The name of the contact or contact group.
         */
        name: string;
        /**
         * The ID of the contact or contact group.
         */
        notifyObjectId: string;
        /**
         * The type of the alert contact.
         */
        notifyType: string;
    }

    export interface GetIntegrationExportersIntegrationExporter {
        /**
         * The ID of the Prometheus instance.
         */
        clusterId: string;
        /**
         * Integration Exporter Type.
         */
        exporterType: string;
        /**
         * The ID of the Integration Exporter. It formats as `<cluster_id>:<integration_type>:<instance_id>`.
         */
        id: string;
        /**
         * The ID of the Integration Exporter instance.
         */
        instanceId: number;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The type of prometheus integration.
         */
        integrationType: string;
        /**
         * Exporter configuration parameter json string.
         */
        param: string;
        /**
         * Monitor the target address.
         */
        target: string;
        /**
         * The version information.
         */
        version: string;
    }

    export interface GetPrometheisPromethei {
        /**
         * The ID of the cluster.
         */
        clusterId: string;
        /**
         * The name of the cluster.
         */
        clusterName: string;
        /**
         * The type of the cluster.
         */
        clusterType: string;
        /**
         * The ID of the Grafana workspace.
         */
        grafanaInstanceId: string;
        /**
         * The ID of the Prometheus.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The child instance json string of the globalView instance.
         */
        subClustersJson: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The ID of the VSwitch.
         */
        vswitchId: string;
    }

    export interface GetPrometheusAlertRulesRule {
        /**
         * The annotations of the alert rule.
         */
        annotations: outputs.arms.GetPrometheusAlertRulesRuleAnnotation[];
        /**
         * The ID of the cluster.
         */
        clusterId: string;
        /**
         * The ID of the notification policy. This parameter is required when the `notifyType` parameter is set to `DISPATCH_RULE`.
         */
        dispatchRuleId: string;
        /**
         * The duration of the alert.
         */
        duration: string;
        /**
         * The alert rule expression that follows the PromQL syntax..
         */
        expression: string;
        /**
         * The ID of the Prometheus Alert Rule.
         */
        id: string;
        /**
         * The labels of the resource.
         */
        labels: outputs.arms.GetPrometheusAlertRulesRuleLabel[];
        /**
         * The message of the alert notification.
         */
        message: string;
        /**
         * The method of sending the alert notification. Valid values: `ALERT_MANAGER`, `DISPATCH_RULE`.
         */
        notifyType: string;
        /**
         * The first ID of the resource.
         */
        prometheusAlertRuleId: string;
        /**
         * The name of the resource.
         */
        prometheusAlertRuleName: string;
        /**
         * The status of the resource. Valid values: `0`, `1`.
         */
        status: number;
        /**
         * The type of the alert rule.
         */
        type: string;
    }

    export interface GetPrometheusAlertRulesRuleAnnotation {
        /**
         * The name of the label.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface GetPrometheusAlertRulesRuleLabel {
        /**
         * The name of the label.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface GetRemoteWritesRemoteWrite {
        /**
         * The ID of the Prometheus instance.
         */
        clusterId: string;
        /**
         * The ID of the Remote Write. It formats as `<cluster_id>:<remote_write_name>`.
         */
        id: string;
        /**
         * The name of the Remote Write configuration item.
         */
        remoteWriteName: string;
        /**
         * The details of the Remote Write configuration item. The value is in the YAML format.
         */
        remoteWriteYaml: string;
    }

    export interface PrometheusAlertRuleAnnotation {
        /**
         * The name of the label.
         */
        name?: string;
        /**
         * The value of the label.
         */
        value?: string;
    }

    export interface PrometheusAlertRuleLabel {
        /**
         * The name of the label.
         */
        name?: string;
        /**
         * The value of the label.
         */
        value?: string;
    }

}

export namespace bastionhost {
    export interface GetHostAccountsAccount {
        /**
         * Whether to set a new password.
         */
        hasPassword: boolean;
        /**
         * Hosting account ID.
         */
        hostAccountId: string;
        /**
         * Specify the new hosting account's name, support the longest 128 characters.
         */
        hostAccountName: string;
        /**
         * Specifies the database where you want to create your hosting account's host ID.
         */
        hostId: string;
        /**
         * The ID of the Host Account.
         */
        id: string;
        /**
         * Specifies the database where you want to create your hosting account's host bastion host ID of.
         */
        instanceId: string;
        /**
         * The situation where the private keys of the fingerprint information.
         */
        privateKeyFingerprint: string;
        /**
         * Specify the new hosting account of the agreement name. Valid values: USING SSH and RDP.
         */
        protocolName: string;
    }

    export interface GetHostGroupsGroup {
        /**
         * Specify the New Host Group of Notes, Supports up to 500 Characters.
         */
        comment: string;
        /**
         * Host Group ID.
         */
        hostGroupId: string;
        /**
         * Specify the New Host Group Name, Supports up to 128 Characters.
         */
        hostGroupName: string;
        /**
         * The ID of the Host Group.
         */
        id: string;
        /**
         * Specify the New Host Group Where the Bastion Host ID of.
         */
        instanceId: string;
    }

    export interface GetHostShareKeysKey {
        /**
         * The first ID of the resource.
         */
        hostShareKeyId: string;
        /**
         * The name of the host shared key.
         */
        hostShareKeyName: string;
        /**
         * The ID of the Host Share Key.
         */
        id: string;
        /**
         * The ID of the Bastion instance.
         */
        instanceId: string;
        /**
         * The fingerprint of the private key.
         */
        privateKeyFingerPrint: string;
    }

    export interface GetHostsHost {
        /**
         * Specify the new create a host of address types. Valid values: Public: the IP address of a Public network Private: Private network address.
         */
        activeAddressType: string;
        /**
         * Specify a host of notes, supports up to 500 characters.
         */
        comment: string;
        /**
         * The host ID.
         */
        hostId: string;
        /**
         * Specify the new create a host name of the supports up to 128 characters.
         */
        hostName: string;
        /**
         * Specify the new create a host of the private network address, it is possible to use the domain name or IP ADDRESS.
         */
        hostPrivateAddress: string;
        /**
         * Specify the new create a host of the IP address of a public network, it is possible to use the domain name or IP ADDRESS.
         */
        hostPublicAddress: string;
        /**
         * The ID of the Host.
         */
        id: string;
        /**
         * Specify the new create a host where the Bastion host ID of.
         */
        instanceId: string;
        /**
         * Specify the new create the host's operating system. Valid values: Linux Windows.
         */
        osType: string;
        /**
         * The host of the protocol information.
         */
        protocols: outputs.bastionhost.GetHostsHostProtocol[];
        /**
         * Specify the new create a host of source. Valid values: Local: localhost Ecs:ECS instance Rds:RDS exclusive cluster host.
         */
        source: string;
        /**
         * Specify the newly created ECS instance ID or dedicated cluster host ID.
         */
        sourceInstanceId: string;
    }

    export interface GetHostsHostProtocol {
        /**
         * Host fingerprint information, it is possible to uniquely identify a host.
         */
        hostFingerPrint: string;
        /**
         * Host the service port of the RDS.
         */
        port: number;
        /**
         * The host uses the protocol name.
         */
        protocolName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The instance's remark.
         */
        description: string;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's status.
         */
        instanceStatus: string;
        licenseCode: string;
        /**
         * The instance's private domain name.
         */
        privateDomain: string;
        /**
         * The instance's public domain name.
         */
        publicDomain: string;
        /**
         * The instance's public network access configuration.
         */
        publicNetworkAccess: boolean;
        /**
         * The instance's security group configuration.
         */
        securityGroupIds: string[];
        /**
         * A map of tags assigned to the bastionhost instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instance = alicloud.bastionhost.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *     },
         * });
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * The instance's vSwitch ID.
         */
        userVswitchId: string;
    }

    export interface GetUserGroupsGroup {
        /**
         * Specify the New Group of Remark Information. Supports up to 500 Characters.
         */
        comment: string;
        /**
         * The ID of the User Group.
         */
        id: string;
        /**
         * Specify the New Group of the Bastion Host of Instance Id.
         */
        instanceId: string;
        /**
         * The User Group ID.
         */
        userGroupId: string;
        /**
         * Specify the New Group Name. Supports up to 128 Characters.
         */
        userGroupName: string;
    }

    export interface GetUsersUser {
        /**
         * Specify the New of the User That Created the Remark Information. Supports up to 500 Characters.
         */
        comment: string;
        /**
         * Specify the New Created the User's Display Name. Supports up to 128 Characters.
         */
        displayName: string;
        /**
         * Specify the New User's Mailbox.
         */
        email: string;
        /**
         * The ID of the User.
         */
        id: string;
        /**
         * You Want to Query the User the Bastion Host ID of.
         */
        instanceId: string;
        /**
         * Specify the New of the User That Created a Different Mobile Phone Number from Your.
         */
        mobile: string;
        /**
         * Specify the New Create User Mobile Phone Number of the International Domain Name. The Default Value Is the CN Value: CN: Mainland China (+86) HK: hong Kong, China (+852) Mo: Macau, China (+853) TW: Taiwan, China (+886) ru: Russian (+7) SG: Singapore (+65) My: malaysia (+60) ID: Indonesia (+62) De: Germany (+49) AU: Australia (+61) US: United States (+1) AE: dubai (+971) JP: Japan (+81) Introducing the Long-Range GB: United Kingdom (+44) in: India (+91) KR: South Korea (+82) Ph: philippines (+63) Ch: Switzerland (+41) Se: Sweden (+46).
         */
        mobileCountryCode: string;
        /**
         * Specify the New of the User That Created the Source. Valid Values: Local: Local User RAM: Ram User.
         */
        source: string;
        /**
         * Specify the Newly Created User Is Uniquely Identified. Indicates That the Parameter Is a Bastion Host Corresponding to the User with the Ram User's Unique Identifier. The Newly Created User Source Grant Permission to a RAM User (That Is, Source Used as a Ram), this Parameter Is Required. You Can Call Access Control of Listusers Interface from the Return Data Userid to Obtain the Parameters.
         */
        sourceUserId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The User ID.
         */
        userId: string;
        /**
         * Specify the New User Name. This Parameter Is Only by Letters, Lowercase Letters, Numbers, and Underscores (_), Supports up to 128 Characters.
         */
        userName: string;
    }

    export interface InstanceAdAuthServer {
        /**
         * The username of the account that is used for the AD server.
         */
        account: string;
        /**
         * The Base distinguished name (DN).
         */
        baseDn: string;
        /**
         * The domain on the AD server.
         */
        domain: string;
        /**
         * The field that is used to indicate the email address of a user on the AD server.
         */
        emailMapping?: string;
        /**
         * The condition that is used to filter users.
         */
        filter?: string;
        /**
         * Specifies whether to support SSL.
         */
        isSsl: boolean;
        /**
         * The field that is used to indicate the mobile phone number of a user on the AD server.
         */
        mobileMapping?: string;
        /**
         * The field that is used to indicate the name of a user on the AD server.
         */
        nameMapping?: string;
        /**
         * The password of the account that is used for the AD server.
         */
        password: string;
        /**
         * The port that is used to access the AD server.
         */
        port: number;
        /**
         * The address of the AD server.
         */
        server: string;
        /**
         * The address of the secondary AD server.
         */
        standbyServer?: string;
    }

    export interface InstanceLdapAuthServer {
        /**
         * The username of the account that is used for the AD server.
         */
        account: string;
        /**
         * The Base distinguished name (DN).
         */
        baseDn: string;
        /**
         * The field that is used to indicate the email address of a user on the AD server.
         */
        emailMapping?: string;
        /**
         * The condition that is used to filter users.
         */
        filter?: string;
        /**
         * Specifies whether to support SSL.
         */
        isSsl?: boolean;
        /**
         * The field that is used to indicate the logon name of a user on the LDAP server.
         */
        loginNameMapping?: string;
        /**
         * The field that is used to indicate the mobile phone number of a user on the AD server.
         */
        mobileMapping?: string;
        /**
         * The field that is used to indicate the name of a user on the AD server.
         */
        nameMapping?: string;
        /**
         * The password of the account that is used for the AD server.
         */
        password: string;
        /**
         * The port that is used to access the AD server.
         */
        port: number;
        /**
         * The address of the AD server.
         */
        server: string;
        /**
         * The address of the secondary AD server.
         */
        standbyServer?: string;
    }

}

export namespace bp {
    export interface GetStudioApplicationsApplication {
        /**
         * The ID of the Application.
         */
        applicationId: string;
        /**
         * The name of the Application.
         */
        applicationName: string;
        /**
         * The creation time of the Application.
         */
        createTime: string;
        /**
         * The ID of the Application.
         */
        id: string;
        /**
         * The image url of the Application.
         */
        imageUrl: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The status of the Application. Valid values: `success`, `release`.
         */
        status: string;
        /**
         * The topo url of the Application.
         */
        topoUrl: string;
    }

    export interface StudioApplicationInstance {
        /**
         * The id of the instance.
         */
        id?: string;
        /**
         * The name of the instance.
         */
        nodeName?: string;
        /**
         * The type of the instance.
         */
        nodeType?: string;
    }

}

export namespace brain {
    export interface GetIndustrialPidLoopsLoop {
        /**
         * The ID of the Pid Loop.
         */
        id: string;
        pidLoopConfiguration: string;
        /**
         * The dcs type of Pid Loop.
         */
        pidLoopDcsType: string;
        pidLoopDesc: string;
        /**
         * The ID of the Pid Loop.
         */
        pidLoopId: string;
        /**
         * Whether is crucial Pid Loop.
         */
        pidLoopIsCrucial: boolean;
        /**
         * The name of Pid Loop.
         */
        pidLoopName: string;
        /**
         * The type of Pid Loop.
         */
        pidLoopType: string;
        /**
         * The pid project id.
         */
        pidProjectId: string;
        /**
         * The status of Pid Loop.
         */
        status: string;
    }

    export interface GetIndustrialPidOrganizationsOrganization {
        /**
         * The ID of the Pid Organization.
         */
        id: string;
        /**
         * The parent organization id.
         */
        parentPidOrganizationId: string;
        /**
         * The organization id.
         */
        pidOrganizationId: string;
        /**
         * The organization level.
         */
        pidOrganizationLevel: number;
        /**
         * The organization name.
         */
        pidOrganizationName: string;
    }

    export interface GetIndustrialPidProjectsProject {
        /**
         * The ID of the Pid Project.
         */
        id: string;
        /**
         * The ID of Pid Organization.
         */
        pidOrganizationId: string;
        /**
         * The description of Pid Project.
         */
        pidProjectDesc: string;
        /**
         * The ID of Pid Project.
         */
        pidProjectId: string;
        /**
         * The name of Pid Project.
         */
        pidProjectName: string;
    }

}

export namespace bss {
    export interface GetOpenApiPricingModulesModule {
        /**
         * Property Code.
         */
        code: string;
        /**
         * A list of Price Module IDs.
         */
        id: string;
        /**
         * Attribute name.
         */
        pricingModuleName: string;
        /**
         * The product code.
         */
        productCode: string;
        /**
         * The product type.
         */
        productType: string;
        /**
         * Subscription type. Value:
         * * Subscription: Prepaid.
         * * PayAsYouGo: postpaid.
         */
        subscriptionType: string;
        /**
         * Attribute unit.
         */
        unit: string;
        /**
         * Property.
         */
        values: outputs.bss.GetOpenApiPricingModulesModuleValue[];
    }

    export interface GetOpenApiPricingModulesModuleValue {
        /**
         * The module Code corresponds to the attribute value.
         */
        name: string;
        /**
         * Module value description information.
         */
        remark: string;
        /**
         * The attribute value type corresponding to the module Code. Value:
         * * single_float: single value type.
         * * range_float: range value type.
         */
        type: string;
        /**
         * The module Code corresponds to the attribute value.
         * > format 1024-1024000 when Type = range_float: 1024 means from 1024 to 1024000, step size 1024.
         */
        value: string;
    }

    export interface GetOpenApiProductsProduct {
        /**
         * The ID of the product. The value is formulated as `<product_code>:<product_type>:<subscription_type>`.
         */
        id: string;
        /**
         * Product code.
         */
        productCode: string;
        /**
         * Product name.
         */
        productName: string;
        /**
         * Type of product.
         */
        productType: string;
        /**
         * Subscription type. Value:
         * * Subscription: Prepaid.
         * * PayAsYouGo: postpaid.
         */
        subscriptionType: string;
    }

}

export namespace cas {
    export interface GetCertificatesCertificate {
        /**
         * The cert is buy from aliyun or not.
         */
        buyInAliyun: boolean;
        cert: string;
        certId: string;
        certificateName: string;
        /**
         * The cert's city.
         */
        city: string;
        /**
         * The cert's common name.
         */
        common: string;
        /**
         * The cert's country.
         */
        country: string;
        /**
         * The cert's not valid after time.
         */
        endDate: string;
        /**
         * The cert is expired or not.
         */
        expired: boolean;
        fingerprint: string;
        /**
         * The cert's id.
         */
        id: string;
        /**
         * The cert's .
         */
        issuer: string;
        key: string;
        /**
         * The cert's name.
         *
         * @deprecated Field 'name' has been deprecated from provider version 1.129.0 and it will be removed in the future version. Please use the new attribute 'certificate_name' instead.
         */
        name: string;
        /**
         * The cert's organization.
         */
        orgName: string;
        /**
         * The cert's province.
         */
        province: string;
        /**
         * The cert's subject alternative name.
         */
        sans: string;
        /**
         * The cert's not valid before time.
         */
        startDate: string;
    }

    export interface GetServiceCertificatesCertificate {
        /**
         * The cert is buy from aliyun or not.
         */
        buyInAliyun: boolean;
        /**
         * The cert's Cert.
         */
        cert: string;
        /**
         * The cert's id.
         */
        certId: string;
        /**
         * The cert's name.
         */
        certificateName: string;
        /**
         * The cert's city.
         */
        city: string;
        /**
         * The cert's common name.
         */
        common: string;
        /**
         * The cert's country.
         */
        country: string;
        /**
         * The cert's not valid after time.
         */
        endDate: string;
        /**
         * The cert is expired or not.
         */
        expired: boolean;
        /**
         * The cert's finger.
         */
        fingerprint: string;
        /**
         * The cert's id.
         */
        id: string;
        /**
         * The cert's Issuer.
         */
        issuer: string;
        /**
         * The cert's Keye.
         */
        key: string;
        /**
         * @deprecated Field 'name' has been deprecated from provider version 1.129.0 and it will be removed in the future version. Please use the new attribute 'certificate_name' instead.
         */
        name: string;
        /**
         * The cert's organization.
         */
        orgName: string;
        /**
         * The cert's province.
         */
        province: string;
        /**
         * The cert's subject alternative name.
         */
        sans: string;
        /**
         * The cert's not valid before time.
         */
        startDate: string;
    }

}

export namespace cassandra {
    export interface GetBackupPlansPlan {
        /**
         * Specifies whether to activate the backup plan.
         */
        active: boolean;
        /**
         * The backup cycle. Valid values: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, and Sunday.
         */
        backupPeriod: string;
        /**
         * The start time of the backup task each day. The time is displayed in UTC and denoted by Z.
         */
        backupTime: string;
        /**
         * The ID of the cluster for the backup.
         */
        clusterId: string;
        /**
         * The time when the backup plan was created.
         */
        createTime: string;
        /**
         * The ID of the data center for the backup in the cluster.
         */
        dataCenterId: string;
        /**
         * The ID of the Backup Plan.
         */
        id: string;
        /**
         * The duration for which you want to retain the backup. Valid values: 1 to 30. Unit: days.
         */
        retentionPeriod: number;
    }

    export interface GetClustersCluster {
        /**
         * The ID of the Cassandra cluster.
         */
        clusterId: string;
        /**
         * The name of the Cassandra cluster.
         */
        clusterName: string;
        createdTime: string;
        /**
         * The count of data centers
         */
        dataCenterCount: number;
        /**
         * The expire time of the cluster.
         */
        expireTime: string;
        /**
         * The ID of the Cassandra cluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The major version of the cluster.
         */
        majorVersion: string;
        /**
         * The minor version of the cluster.
         */
        minorVersion: string;
        /**
         * Billing method. Value options are `Subscription` for Pay-As-You-Go and `PayAsYouGo` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Status of the cluster.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetDataCentersCenter {
        /**
         * The cluster id of dataCenters belongs to.
         */
        clusterId: string;
        /**
         * The commodity ID of the Cassandra dataCenter.
         */
        commodityInstance: string;
        createdTime: string;
        /**
         * The id of the Cassandra dataCenter.
         */
        dataCenterId: string;
        /**
         * The name of the Cassandra dataCenter.
         */
        dataCenterName: string;
        /**
         * One node disk size, unit:GB.
         */
        diskSize: number;
        /**
         * Cloud_ssd or cloud_efficiency.
         */
        diskType: string;
        /**
         * The expire time of the dataCenter.
         */
        expireTime: string;
        /**
         * The instance type of the Cassandra dataCenter, eg: cassandra.c.large.
         */
        instanceType: string;
        /**
         * The lock mode of the dataCenter.
         */
        lockMode: string;
        /**
         * The node count of dataCenter.
         */
        nodeCount: number;
        /**
         * Billing method. Value options are `Subscription` for Pay-As-You-Go and `PayAsYouGo` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Status of the dataCenter.
         */
        status: string;
        /**
         * VPC ID the dataCenter belongs to.
         */
        vpcId: string;
        /**
         * VSwitch ID the dataCenter belongs to.
         */
        vswitchId: string;
        /**
         * Zone ID the dataCenter belongs to.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace cddc {
    export interface GetDedicatedHostAccountsAccount {
        /**
         * The name of the Dedicated host account.
         */
        accountName: string;
        /**
         * The ID of the Dedicated host.
         */
        dedicatedHostId: string;
        /**
         * The ID of the Dedicated Host Account. The value formats as `<dedicated_host_id>:<account_name>`.
         */
        id: string;
    }

    export interface GetDedicatedHostGroupsGroup {
        /**
         * The policy that is used to allocate resources in the dedicated cluster. Valid values:`Evenly`,`Intensively`
         */
        allocationPolicy: string;
        /**
         * The Bastion Instance id of the Dedicated Host Group.
         */
        bastionInstanceId: string;
        /**
         * The CPU overcommitment ratio of the dedicated cluster. If you set this parameter to 200, the CPU resources that can be allocated are twice as many as the CPU resources that are provided. This maximizes the CPU utilization. Valid values: 100 to 300. Default value: 200.
         */
        cpuAllocateRation: number;
        /**
         * The CPU Allocated Amount of the Dedicated Host Group.
         */
        cpuAllocatedAmount: number;
        /**
         * The CPU overcommitment ratio of the dedicated cluster.Valid values: 100 to 300. Default value: 200.
         */
        cpuAllocationRatio: number;
        /**
         * The Created Time of the Dedicated Host Group.
         */
        createTime: string;
        /**
         * The Dedicated Host Count Group by Host Type of the Dedicated Host Group.
         */
        dedicatedHostCountGroupByHostTypes: outputs.cddc.GetDedicatedHostGroupsGroupDedicatedHostCountGroupByHostType[];
        /**
         * The name of the dedicated cluster. The name must be 1 to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-). It must start with a letter.
         */
        dedicatedHostGroupDesc: string;
        /**
         * Dedicated Host Group ID.
         */
        dedicatedHostGroupId: string;
        /**
         * The Deployment Type of the Dedicated Host Group.
         */
        deployType: string;
        /**
         * The storage overcommitment ratio of the dedicated cluster.Valid values: 100 to 300. Default value: 200.
         */
        diskAllocateRation: number;
        /**
         * The Disk Allocated Amount of the Dedicated Host Group.
         */
        diskAllocatedAmount: number;
        /**
         * The Disk Allocation Ratio of the Dedicated Host Group.
         */
        diskAllocationRatio: number;
        /**
         * The DiskUsedAmount of the Dedicated Host Group.
         */
        diskUsedAmount: number;
        /**
         * The DiskUtility of the Dedicated Host Group.
         */
        diskUtility: number;
        /**
         * Database Engine Type.The database engine of the dedicated cluster. Valid values:`Redis`, `SQLServer`, `MySQL`, `PostgreSQL`, `MongoDB`
         */
        engine: string;
        /**
         * The Total Host Number  of the Dedicated Host Group.
         */
        hostNumber: number;
        /**
         * The policy based on which the system handles host failures. Valid values:`Auto`,`Manual`
         */
        hostReplacePolicy: string;
        /**
         * The ID of the Dedicated Host Group.
         */
        id: string;
        /**
         * The Total Instance Number of the Dedicated Host Group.
         */
        instanceNumber: number;
        /**
         * The maximum memory usage of each host in the dedicated cluster.Valid values: 0 to 90. Default value: 90.
         */
        memAllocateRation: number;
        /**
         * The MemAllocatedAmount of the Dedicated Host Group.
         */
        memAllocatedAmount: number;
        /**
         * The Memory Allocation Ratio of the Dedicated Host Group.
         */
        memAllocationRatio: number;
        /**
         * The MemUsedAmount of the Dedicated Host Group.
         */
        memUsedAmount: number;
        /**
         * The Mem Utility of the Dedicated Host Group.
         */
        memUtility: number;
        /**
         * The Text of the Dedicated Host Group.
         */
        text: string;
        /**
         * The virtual private cloud (VPC) ID of the dedicated cluster.
         */
        vpcId: string;
        /**
         * The ZoneIDList of the Dedicated Host Group.
         */
        zoneIdLists: outputs.cddc.GetDedicatedHostGroupsGroupZoneIdList[];
    }

    export interface GetDedicatedHostGroupsGroupDedicatedHostCountGroupByHostType {
        placeHolder: string;
    }

    export interface GetDedicatedHostGroupsGroupZoneIdList {
        /**
         * The ZoneIDList of the Dedicated Host Group.
         */
        zoneIdLists: string[];
    }

    export interface GetDedicatedHostsHost {
        /**
         * Specifies whether instances can be created on the host. Valid values: `1` or `0`. `1`: Instances can be created on the host. `0`: Instances cannot be created on the host.
         */
        allocationStatus: string;
        /**
         * The ID of the bastion host with which the host is associated.
         */
        bastionInstanceId: string;
        /**
         * The numeric value of the CPU over commit ratio of the dedicated cluster.
         */
        cpuAllocationRatio: string;
        /**
         * The number of CPU cores used by the host.
         */
        cpuUsed: string;
        /**
         * The time when the host was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The ID of the dedicated cluster in which the host is created.
         */
        dedicatedHostGroupId: string;
        /**
         * The ID of the host.
         */
        dedicatedHostId: string;
        /**
         * The disk usage in percentage.
         */
        diskAllocationRatio: string;
        /**
         * The Elastic Compute Service (ECS) instance type.
         */
        ecsClassCode: string;
        /**
         * The time when the host expires. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        endTime: string;
        /**
         * The type of the database engine that is used by the host.
         */
        engine: string;
        /**
         * The time when the host expires. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        expiredTime: string;
        /**
         * The instance type of the host.
         */
        hostClass: string;
        /**
         * The number of CPU cores specified for the host. Unit: `core`.
         */
        hostCpu: string;
        /**
         * The memory of the host. Unit: `GB`.
         */
        hostMem: string;
        /**
         * The name of the host.
         */
        hostName: string;
        /**
         * The total storage capacity of the host. Unit: `GB`.
         */
        hostStorage: string;
        /**
         * The storage type of the host.
         */
        hostType: string;
        /**
         * The ID of the Dedicated Host. The value formats as `<dedicated_host_group_id>:<dedicated_host_id>`.
         */
        id: string;
        /**
         * The image type of the host.
         */
        imageCategory: string;
        /**
         * The IP address of the host.
         */
        ipAddress: string;
        /**
         * The memory usage in percentage.
         */
        memAllocationRatio: string;
        /**
         * The amount of memory used by the host. Unit: `GB`.
         */
        memoryUsed: string;
        /**
         * Indicates whether you have the OS permissions on the host. Valid values: `0`: You do not have the OS permissions on the host. `1`: You have the OS permissions on the host.
         */
        openPermission: string;
        /**
         * The state of the host.
         */
        status: string;
        /**
         * The storage usage of the host. Unit: `GB`.
         */
        storageUsed: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the virtual private cloud (VPC) to which the host is connected.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch.
         */
        vswitchId: string;
        /**
         * The zone ID of the host.
         */
        zoneId: string;
    }

    export interface GetHostEcsLevelInfosInfo {
        /**
         * The description of the host ecs level info.
         */
        description: string;
        /**
         * The instance family of the host ecs level info.
         */
        ecsClass: string;
        /**
         * The Elastic Compute Service (ECS) instance type.
         */
        ecsClassCode: string;
        /**
         * The ApsaraDB RDS instance type of the host ecs level info.
         */
        resClassCode: string;
    }

    export interface GetZonesZone {
        /**
         * The ID of the zone.
         */
        id: string;
        /**
         * The ID of the region.
         */
        regionId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

}

export namespace cdn {
    export interface DomainAuthConfig {
        authType?: string;
        masterKey: string;
        slaveKey: string;
        timeout?: number;
    }

    export interface DomainCacheConfig {
        cacheContent: string;
        cacheId: string;
        cacheType: string;
        ttl: number;
        weight?: number;
    }

    export interface DomainCertificateConfig {
        privateKey?: string;
        serverCertificate?: string;
        serverCertificateStatus?: string;
    }

    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainHttpHeaderConfig {
        headerId: string;
        headerKey: string;
        headerValue: string;
    }

    export interface DomainNewCertificateConfig {
        /**
         * The ID of the certificate. It takes effect only when CertType = cas.
         */
        certId: string;
        /**
         * Certificate name, only flyer names are supported.
         */
        certName: string;
        /**
         * The certificate region, which takes effect only when CertType = cas, supports cn-hangzhou (domestic) and ap-southeast-1 (International), and is cn-hangzhou by default.
         */
        certRegion: string;
        /**
         * Certificate type. Value:
         * - **upload**: upload certificate.
         * - **cas**: Cloud Shield certificate.
         * - **free**: free certificate.
         * > If the certificate type is **cas**, **PrivateKey** does not need to pass parameters.
         */
        certType: string;
        forceSet?: string;
        /**
         * The content of the private key. If the certificate is not enabled, you do not need to enter the content of the private key. To configure the certificate, enter the content of the private key.
         */
        privateKey?: string;
        /**
         * The content of the security certificate. If the certificate is not enabled, you do not need to enter the content of the security certificate. Please enter the content of the certificate to configure the certificate.
         */
        serverCertificate: string;
        /**
         * Whether the HTTPS certificate is enabled. Value:
         * - **on**(default): enabled.
         * - **off** : not enabled.
         */
        serverCertificateStatus?: string;
    }

    export interface DomainNewSource {
        /**
         * The address of source. Valid values can be ip or doaminName. Each item's `content` can not be repeated.
         */
        content?: string;
        /**
         * The port of source. Valid values are `443` and `80`. Default value is `80`.
         */
        port?: number;
        /**
         * Priority of the source. Valid values are `0` and `100`. Default value is `20`.
         */
        priority?: number;
        /**
         * The type of the source. Valid values are `ipaddr`, `domain` and `oss`.
         */
        type?: string;
        /**
         * Weight of the source. Valid values are from `0` to `100`. Default value is `10`, but if type is `ipaddr`, the value can only be `10`. .
         */
        weight?: number;
    }

    export interface DomainPage404Config {
        customPageUrl?: string;
        errorCode: string;
        pageType?: string;
    }

    export interface DomainParameterFilterConfig {
        enable?: string;
        hashKeyArgs: string[];
    }

    export interface DomainReferConfig {
        allowEmpty?: string;
        referLists: string[];
        referType?: string;
    }

    export interface GetBlockedRegionsRegion {
        /**
         * The region to which the country belongs.
         */
        continent: string;
        /**
         * National region abbreviation.
         */
        countriesAndRegions: string;
        /**
         * The name of the country and region.
         */
        countriesAndRegionsName: string;
    }

    export interface GetRealTimeLogDeliveriesDelivery {
        /**
         * Real-Time Log Service Domain.
         */
        domain: string;
        /**
         * The ID of the Real Time Log Delivery.
         */
        id: string;
        /**
         * The name of the Logstore that collects log data from Alibaba Cloud Content Delivery Network (CDN) in real time.
         */
        logstore: string;
        /**
         * The name of the Log Service project that is used for real-time log delivery.
         */
        project: string;
        /**
         * The region where the Log Service project is deployed.
         */
        slsRegion: string;
        /**
         * The status of the real-time log delivery feature. Valid Values: `online` and `offline`.
         */
        status: string;
    }

}

export namespace cen {
    export interface GetBandwidthLimitsLimit {
        /**
         * The bandwidth limit configured for the interconnected regions communication.
         */
        bandwidthLimit: number;
        /**
         * ID of the CEN instance.
         */
        instanceId: string;
        /**
         * ID of local region.
         */
        localRegionId: string;
        /**
         * ID of opposite region.
         */
        oppositeRegionId: string;
        /**
         * Status of the CEN Bandwidth Limit, including "Active" and "Modifying".
         */
        status: string;
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth in Mbps of the CEN bandwidth package.
         */
        bandwidth: number;
        /**
         * The billing method, including `POSTPAY` and `PREPAY`.
         */
        bandwidthPackageChargeType: string;
        /**
         * Status of the CEN Bandwidth Package, including `Normal`, `FinancialLocked` and `SecurityLocked`.
         */
        businessStatus: string;
        /**
         * The ID of the bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The name of the bandwidth package.
         */
        cenBandwidthPackageName: string;
        /**
         * The list of CEN instances that are associated with the bandwidth package.
         */
        cenIds: string[];
        /**
         * Description of the CEN Bandwidth Package.
         */
        description: string;
        expiredTime: string;
        /**
         * Region ID of the interconnected regions.
         */
        geographicRegionAId: string;
        /**
         * Region ID of the interconnected regions.
         */
        geographicRegionBId: string;
        /**
         * The area ID of the cross-area connection.
         */
        geographicSpanId: string;
        /**
         * Indicates whether renewal data is involved.
         */
        hasReservationData: string;
        /**
         * ID of the CEN Bandwidth Package.
         */
        id: string;
        /**
         * ID of a CEN instance.
         */
        instanceId: string;
        /**
         * Indicates whether the bandwidth package is a cross-border bandwidth package.
         */
        isCrossBorder: boolean;
        /**
         * Name of the CEN Bandwidth Package.
         */
        name: string;
        /**
         * The billing method of the bandwidth package.
         */
        paymentType: string;
        /**
         * The expiration time of the temporary upgrade.
         */
        reservationActiveTime: string;
        /**
         * The restored bandwidth after the temporary upgrade.
         */
        reservationBandwidth: string;
        /**
         * The billing method after the configuration change.
         */
        reservationInternetChargeType: string;
        /**
         * The type of the configuration change.
         */
        reservationOrderType: string;
        /**
         * Status of the CEN Bandwidth Package in CEN instance, Valid value: `Idle` and `InUse`.
         */
        status: string;
    }

    export interface GetChildInstanceRouteEntryToAttachmentsAttachment {
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The first ID of the resource
         */
        childInstanceRouteTableId: string;
        /**
         * DestinationCidrBlock
         */
        destinationCidrBlock: string;
        /**
         * The ID of the resource. The value is formulated as `<cen_id>:<child_instance_route_table_id>:<transit_router_attachment_id>:<destination_cidr_block>`.
         */
        id: string;
        /**
         * ServiceType
         */
        serviceType: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * TransitRouterAttachmentId
         */
        transitRouterAttachmentId: string;
    }

    export interface GetFlowlogsFlowlog {
        /**
         * The ID of the CEN Instance.
         */
        cenId: string;
        /**
         * The description of flowlog.
         */
        description: string;
        /**
         * ID of the CEN flow log.
         */
        flowLogId: string;
        /**
         * The name of flowlog.
         */
        flowLogName: string;
        /**
         * ID of the CEN flow log.
         */
        id: string;
        /**
         * The name of the log store which is in the  `projectName` SLS project.
         */
        logStoreName: string;
        /**
         * The name of the SLS project.
         */
        projectName: string;
        /**
         * The status of flowlog. Valid values: ["Active", "Inactive"]. Default to "Active".
         */
        status: string;
    }

    export interface GetInstanceAttachmentsAttachment {
        /**
         * The time when the network is associated with the CEN instance.
         */
        childInstanceAttachTime: string;
        /**
         * The ID of the network.
         */
        childInstanceId: string;
        /**
         * The ID of the account to which the network belongs.
         */
        childInstanceOwnerId: number;
        /**
         * The region to which the network to be queried belongs.
         */
        childInstanceRegionId: string;
        /**
         * The type of the associated network. Valid values: `VPC`, `VBR` and `CCN`.
         */
        childInstanceType: string;
        /**
         * The ID of the CEN Instance Attachment.
         */
        id: string;
        /**
         * The ID of the CEN instance.
         */
        instanceId: string;
        /**
         * The status of the Cen Child Instance Attachment. Valid value: `Attaching`, `Attached` and `Aetaching`.
         */
        status: string;
    }

    export interface GetInstancesInstance {
        /**
         * List of CEN Bandwidth Package IDs in the specified CEN instance.
         */
        cenBandwidthPackageIds: string[];
        /**
         * ID of the CEN instance.
         */
        cenId: string;
        /**
         * Name of the CEN instance.
         */
        cenInstanceName: string;
        /**
         * The creation time of the CEN Instance.
         */
        createTime: string;
        /**
         * Description of the CEN instance.
         */
        description: string;
        /**
         * ID of the CEN instance.
         */
        id: string;
        /**
         * Name of the CEN instance.
         */
        name: string;
        /**
         * Indicates the allowed level of CIDR block overlapping.
         */
        protectionLevel: string;
        /**
         * The status of CEN instance. Valid value: `Active`, `Creating` and `Deleting`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetInterRegionTrafficQosPoliciesPolicy {
        /**
         * The ID of the Inter Region Traffic Qos Policy.
         */
        id: string;
        /**
         * The description of the Inter Region Traffic Qos Policy.
         */
        interRegionTrafficQosPolicyDescription: string;
        /**
         * The ID of the Inter Region Traffic Qos Policy.
         */
        interRegionTrafficQosPolicyId: string;
        /**
         * The name of the Inter Region Traffic Qos Policy.
         */
        interRegionTrafficQosPolicyName: string;
        /**
         * The status of the traffic scheduling policy. Valid Value: `Creating`, `Active`, `Modifying`, `Deleting`, `Deleted`.
         */
        status: string;
        /**
         * The ID of the inter-region connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
    }

    export interface GetInterRegionTrafficQosQueuesQueue {
        /**
         * The DSCP value of the traffic packet to be matched in the current queue, ranging from 0 to 63.
         */
        dscps: string[];
        id: string;
        /**
         * The description information of the traffic scheduling policy.
         */
        interRegionTrafficQosQueueDescription: string;
        /**
         * The ID of the resource.
         */
        interRegionTrafficQosQueueId: string;
        /**
         * The name of the traffic scheduling policy.
         */
        interRegionTrafficQosQueueName: string;
        /**
         * The percentage of cross-region bandwidth that the current queue can use.
         */
        remainBandwidthPercent: number;
        /**
         * The status of the traffic scheduling policy. -**Creating**: The function is being created.-**Active**: available.-**Modifying**: is being modified.-**Deleting**: Deleted.-**Deleted**: Deleted.
         */
        status: string;
        /**
         * The ID of the traffic scheduling policy.
         */
        trafficQosPolicyId: string;
    }

    export interface GetPrivateZonesZone {
        /**
         * The access region. The access region is the region of the cloud resource that accesses the PrivateZone service through CEN.
         */
        accessRegionId: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The service region. The service region is the target region of the PrivateZone service accessed through CEN.
         */
        hostRegionId: string;
        /**
         * The VPC that belongs to the service region.
         */
        hostVpcId: string;
        /**
         * The ID of the private zone. It formats as `<cen_id>:<access_region_id>`.
         */
        id: string;
        /**
         * The DNS IP addresses of the PrivateZone service.
         */
        privateZoneDnsServers: string;
        /**
         * The status of the PrivateZone service, including `Creating`, `Active` and `Deleting`.
         */
        status: string;
    }

    export interface GetRegionRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry.
         */
        cidrBlock: string;
        /**
         * ID of the next hop.
         */
        nextHopId: string;
        /**
         * ID of the region where the next hop is located.
         */
        nextHopRegionId: string;
        /**
         * Type of the next hop.
         */
        nextHopType: string;
        /**
         * Type of the route entry.
         */
        type: string;
    }

    export interface GetRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry to query.
         */
        cidrBlock: string;
        /**
         * A list of conflicted Route Entries. Each element contains the following attributes:
         */
        conflicts: outputs.cen.GetRouteEntriesEntryConflict[];
        /**
         * ID of the next hop.
         */
        nextHopId: string;
        /**
         * Type of the next hop, including "Instance", "HaVip" and "RouterInterface".
         */
        nextHopType: string;
        /**
         * Whether to allow the route entry to be published or removed to or from CEN.
         */
        operationalMode: boolean;
        /**
         * The publish status of the route entry in CEN, including "Published" and "NonPublished".
         */
        publishStatus: string;
        /**
         * ID of the route table of the VPC or VBR.
         */
        routeTableId: string;
        /**
         * Type of the route entry, including "System", "Custom" and "BGP".
         */
        routeType: string;
    }

    export interface GetRouteEntriesEntryConflict {
        /**
         * The destination CIDR block of the route entry to query.
         */
        cidrBlock: string;
        /**
         * ID of the CEN instance.
         */
        instanceId: string;
        /**
         * The type of the CEN child instance.
         */
        instanceType: string;
        /**
         * ID of the region where the conflicted route entry is located.
         */
        regionId: string;
        /**
         * Reasons of exceptions.
         */
        status: string;
    }

    export interface GetRouteMapsMap {
        /**
         * A match statement. It indicates the mode in which the as-path attribute is matched.
         */
        asPathMatchMode: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The ID of the region to which the CEN instance belongs.
         */
        cenRegionId: string;
        /**
         * A match statement. It indicates the mode in which the prefix attribute is matched.
         */
        cidrMatchMode: string;
        /**
         * A match statement. It indicates the mode in which the community attribute is matched.
         */
        communityMatchMode: string;
        /**
         * An action statement. It indicates the mode in which the community attribute is operated.
         */
        communityOperateMode: string;
        /**
         * The description of the route map.
         */
        description: string;
        /**
         * A match statement that indicates the list of IDs of the destination instances.
         */
        destinationChildInstanceTypes: string[];
        /**
         * A match statement that indicates the prefix list.
         */
        destinationCidrBlocks: string[];
        /**
         * A match statement that indicates the list of IDs of the destination instances.
         */
        destinationInstanceIds: string[];
        /**
         * Indicates whether to enable the reverse match method of the DestinationInstanceIds match condition.
         */
        destinationInstanceIdsReverseMatch: boolean;
        /**
         * A match statement that indicates the list of IDs of the destination route tables.
         */
        destinationRouteTableIds: string[];
        /**
         * The ID of the route map. It formats as `<cen_id>:<route_map_id>`. Before 1.161.0, it is `routeMapId`.
         */
        id: string;
        /**
         * The action that is performed to a route if the route meets all the match conditions.
         */
        mapResult: string;
        /**
         * A match statement that indicates the As path list.
         */
        matchAsns: string[];
        /**
         * A match statement that indicates the community set.
         */
        matchCommunitySets: string[];
        /**
         * The priority of the next route map that is associated with the current route map.
         */
        nextPriority: number;
        /**
         * An action statement that operates the community attribute.
         */
        operateCommunitySets: string[];
        /**
         * An action statement that modifies the preference of the route.
         */
        preference: number;
        /**
         * Indicates AS Path prepending when a regional gateway receives or publishes a route.
         */
        prependAsPaths: string[];
        /**
         * The priority of the route map.
         */
        priority: number;
        /**
         * The ID of the route map.
         */
        routeMapId: string;
        /**
         * A match statement that indicates the list of route types.
         */
        routeTypes: string[];
        /**
         * A match statement that indicates the list of IDs of the source instances.
         */
        sourceChildInstanceTypes: string[];
        /**
         * A match statement that indicates the list of IDs of the source instances.
         */
        sourceInstanceIds: string[];
        /**
         * Indicates whether to enable the reverse match method of the SourceInstanceIds match condition.
         */
        sourceInstanceIdsReverseMatch: boolean;
        /**
         * A match statement that indicates the list of IDs of the source regions.
         */
        sourceRegionIds: string[];
        /**
         * A match statement that indicates the list of IDs of the source route tables.
         */
        sourceRouteTableIds: string[];
        /**
         * The status of the route map, including `Creating`, `Active` and `Deleting`.
         */
        status: string;
        /**
         * The direction in which the route map is applied, including `RegionIn` and `RegionOut`.
         */
        transmitDirection: string;
    }

    export interface GetRouteServicesService {
        /**
         * The region of the network instances that access the cloud services.
         */
        accessRegionId: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The IP address of the cloud service.
         */
        cidrs: string[];
        /**
         * The description of the cloud service.
         */
        description: string;
        /**
         * The domain name or IP address of the cloud service.
         */
        host: string;
        /**
         * The region of the cloud service.
         */
        hostRegionId: string;
        /**
         * The VPC associated with the cloud service.
         */
        hostVpcId: string;
        /**
         * The ID of the route service.
         */
        id: string;
        /**
         * The status of the cloud service. Valid values: `Active`, `Creating` and `Deleting`.
         */
        status: string;
        /**
         * The update interval. Default value: 5. The value cannot be modified.
         */
        updateInterval: string;
    }

    export interface GetTrafficMarkingPoliciesPolicy {
        /**
         * The description of the Traffic Marking Policy.
         */
        description: string;
        /**
         * The ID of the resource. The value is formatted `<transit_router_id>:<traffic_marking_policy_id>`.
         */
        id: string;
        /**
         * The DSCP(Differentiated Services Code Point) of the Traffic Marking Policy.
         */
        markingDscp: number;
        /**
         * The Priority of the Traffic Marking Policy.
         */
        priority: number;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the Traffic Marking Policy.
         */
        trafficMarkingPolicyId: string;
        /**
         * The name of the Traffic Marking Policy.
         */
        trafficMarkingPolicyName: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
    }

    export interface GetTransitRouteTableAggregationsTransitRouteTableAggregation {
        /**
         * The ID of the Transit Route Table Aggregation. It formats as `<transit_route_table_id>:<transit_route_table_aggregation_cidr>`.
         */
        id: string;
        /**
         * The route type of the aggregate route.
         */
        routeType: string;
        /**
         * The status of Transit Route Table Aggregation. Valid Values: `AllConfigured`, `Configuring`, `ConfigFailed`, `PartialConfigured`, `Deleting`.
         */
        status: string;
        /**
         * The destination CIDR block of the aggregate route.
         */
        transitRouteTableAggregationCidr: string;
        /**
         * The description of the aggregate route.
         */
        transitRouteTableAggregationDescription: string;
        /**
         * The name of the aggregate route.
         */
        transitRouteTableAggregationName: string;
        /**
         * The scope of networks that you want to advertise the aggregate route.
         */
        transitRouteTableAggregationScope: string;
        /**
         * The ID of the route table of the Enterprise Edition transit router.
         */
        transitRouteTableId: string;
    }

    export interface GetTransitRouterAvailableResourcesResource {
        /**
         * The list of primary zones.
         */
        masterZones: string[];
        /**
         * The list of secondary zones.
         */
        slaveZones: string[];
    }

    export interface GetTransitRouterCidrsCidr {
        /**
         * The cidr of the transit router.
         */
        cidr: string;
        /**
         * The description of the transit router.
         */
        description: string;
        /**
         * The type of the transit router cidr.
         */
        family: string;
        /**
         * The ID of the Cen Transit Router Cidr. It formats as `<transit_router_id>:<transit_router_cidr_id>`.
         */
        id: string;
        /**
         * Whether to allow automatically adding Transit Router Cidr in Transit Router Route Table.
         */
        publishCidrRoute: boolean;
        /**
         * The ID of the transit router cidr.
         */
        transitRouterCidrId: string;
        /**
         * The name of the transit router.
         */
        transitRouterCidrName: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
    }

    export interface GetTransitRouterMulticastDomainAssociationsAssociation {
        /**
         * The ID of the Transit Router Multicast Domain Association. It formats as `<transit_router_multicast_domain_id>:<transit_router_attachment_id>:<vswitch_id>`.
         */
        id: string;
        /**
         * The ID of the resource associated with the multicast domain.
         */
        resourceId: string;
        /**
         * The ID of the Alibaba Cloud account to which the resource associated with the multicast domain belongs.
         */
        resourceOwnerId: number;
        /**
         * The type of resource associated with the multicast domain. Valid Value: `VPC`.
         */
        resourceType: string;
        /**
         * The status of the associated resource. Valid Value: `Associated`, `Associating`, `Dissociating`.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the multicast domain.
         */
        transitRouterMulticastDomainId: string;
        /**
         * The ID of the vSwitch.
         */
        vswitchId: string;
    }

    export interface GetTransitRouterMulticastDomainMembersMember {
        /**
         * The IP address of the multicast group to which the multicast member belongs. If the multicast group you specified does not exist in the current multicast domain, the system will automatically create a new multicast group for you in the current multicast domain.
         */
        groupIpAddress: string;
        /**
         * The `key` of the resource supplied above.The value is formulated as `<transit_router_multicast_domain_id>:<group_ip_address>:<network_interface_id>`.
         */
        id: string;
        /**
         * The ID of the ENI.
         */
        networkInterfaceId: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * The ID of the multicast domain to which the multicast member belongs.
         */
        transitRouterMulticastDomainId: string;
        /**
         * The VPC to which the ENI of the multicast member belongs. This field is mandatory for VPCs owned by another accounts.
         */
        vpcId: string;
    }

    export interface GetTransitRouterMulticastDomainPeerMembersMember {
        /**
         * The IP address of the multicast group to which the multicast member belongs. Value range: **224.0.0.1** to **239.255.255.254**.If the multicast group you specified does not exist in the current multicast domain, the system will automatically create a new multicast group for you in the current multicast domain.
         */
        groupIpAddress: string;
        /**
         * The `key` of the resource supplied above.The value is formulated as `<transit_router_multicast_domain_id>:<group_ip_address>:<peer_transit_router_multicast_domain_id>`.
         */
        id: string;
        /**
         * The multicast domain ID of the peer transit router.
         */
        peerTransitRouterMulticastDomainId: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * The ID of the multicast domain to which the multicast member belongs.
         */
        transitRouterMulticastDomainId: string;
    }

    export interface GetTransitRouterMulticastDomainSourcesSource {
        /**
         * The IP address of the multicast group to which the multicast source belongs. Value range: **224.0.0.1** to **239.255.255.254**. If the multicast group you specified does not exist in the current multicast domain, the system will automatically create a new multicast group for you.
         */
        groupIpAddress: string;
        id: string;
        /**
         * ENI ID of the multicast source.
         */
        networkInterfaceId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the multicast domain to which the multicast source belongs.
         */
        transitRouterMulticastDomainId: string;
        /**
         * The VPC to which the ENI of the multicast source belongs. This field is mandatory for VPCs that is owned by another accounts.
         */
        vpcId: string;
    }

    export interface GetTransitRouterMulticastDomainsDomain {
        /**
         * The ID of the Transit Router Multicast Domain.
         */
        id: string;
        /**
         * The status of the multicast domain. Valid Value: `Active`.
         */
        status: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The description of the Transit Router Multicast Domain.
         */
        transitRouterMulticastDomainDescription: string;
        /**
         * The ID of the multicast domain.
         */
        transitRouterMulticastDomainId: string;
        /**
         * The name of the Transit Router Multicast Domain.
         */
        transitRouterMulticastDomainName: string;
    }

    export interface GetTransitRouterPeerAttachmentsAttachment {
        /**
         * Auto publish route enabled.
         */
        autoPublishRouteEnabled: boolean;
        /**
         * The bandwidth of the bandwidth package.
         */
        bandwidth: number;
        /**
         * ID of the CEN bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * ID of the geographic.
         */
        geographicSpanId: string;
        /**
         * The ID of CEN Transit Router peer attachments.
         */
        id: string;
        /**
         * ID of the peer transit router.
         */
        peerTransitRouterId: string;
        /**
         * Owner ID of the peer transit router.
         */
        peerTransitRouterOwnerId: string;
        /**
         * Region ID of the peer transit router.
         */
        peerTransitRouterRegionId: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of CEN Transit Router peer attachment. Valid values `Attached`, `Attaching` and `Detaching`.
         */
        status: string;
        /**
         * The description of CEN Transit Router peer attachments.
         */
        transitRouterAttachmentDescription: string;
        /**
         * The ID of CEN Transit Router peer attachments.
         */
        transitRouterAttachmentId: string;
        /**
         * Name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The ID of transit router.
         */
        transitRouterId: string;
    }

    export interface GetTransitRouterPrefixListAssociationsAssociation {
        /**
         * The ID of the Cen Transit Router Prefix List Association. It formats as `<prefix_list_id>:<transit_router_id>:<transit_router_table_id>:<next_hop>`.
         */
        id: string;
        /**
         * The ID of the next hop connection.
         */
        nextHop: string;
        /**
         * The ID of the network instance associated with the next hop connection.
         */
        nextHopInstanceId: string;
        /**
         * The type of the next hop.
         */
        nextHopType: string;
        /**
         * The ID of the Alibaba Cloud account to which the prefix list belongs.
         */
        ownerUid: number;
        /**
         * The ID of the prefix list.
         */
        prefixListId: string;
        /**
         * The status of the prefix list.
         */
        status: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The ID of the route table of the transit router.
         */
        transitRouterTableId: string;
    }

    export interface GetTransitRouterRouteEntriesEntry {
        id: string;
        status: string;
        transitRouterRouteEntryDescription: string;
        /**
         * The target network segment of the route entry.
         */
        transitRouterRouteEntryDestinationCidrBlock: string;
        transitRouterRouteEntryId: string;
        transitRouterRouteEntryName: string;
        /**
         * ID of the next hop.
         */
        transitRouterRouteEntryNextHopId: string;
        /**
         * Type of the next hop.
         */
        transitRouterRouteEntryNextHopType: string;
        /**
         * Type of the route entry.
         */
        transitRouterRouteEntryType: string;
    }

    export interface GetTransitRouterRouteTableAssociationsAssociation {
        id: string;
        /**
         * ID of the transit router route table association.
         */
        resourceId: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the route table, including `Active`, `Associating`, `Dissociating`.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the route table of the Enterprise Edition transit router.
         */
        transitRouterRouteTableId: string;
    }

    export interface GetTransitRouterRouteTablePropagationsPropagation {
        id: string;
        /**
         * ID of the transit router route table association.
         */
        resourceId: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the route table, including `Active`, `Enabling`, `Disabling`, `Deleted`.
         */
        status: string;
        /**
         * ID of the cen transit router attachment.
         */
        transitRouterAttachmentId: string;
    }

    export interface GetTransitRouterRouteTablesTable {
        /**
         * ID of resource.
         */
        id: string;
        status: string;
        /**
         * The description of the transit router route table.
         */
        transitRouterRouteTableDescription: string;
        /**
         * ID of the trabsit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * Name of the transit router route table.
         */
        transitRouterRouteTableName: string;
        /**
         * The type of the transit router route table to query. Valid values `Creating`, `Active` and `Deleting`..
         */
        transitRouterRouteTableType: string;
    }

    export interface GetTransitRouterVbrAttachmentsAttachment {
        /**
         * ID of the region where the conflicted VBR is located.
         */
        autoPublishRouteEnabled: boolean;
        id: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the resource. Valid values `Attached`, `Attaching` and `Detaching`.
         */
        status: string;
        transitRouterAttachmentDescription: string;
        /**
         * ID of the transit router VBR attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * Name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * ID of the VBR.
         */
        vbrId: string;
        /**
         * The Owner ID of the VBR.
         */
        vbrOwnerId: string;
    }

    export interface GetTransitRouterVpcAttachmentsAttachment {
        /**
         * The ID of the transit router.
         */
        id: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the resource. Valid values `Attached`, `Attaching` and `Detaching`.
         */
        status: string;
        /**
         * The description of transit router attachment.
         */
        transitRouterAttachmentDescription: string;
        /**
         * ID of the transit router VBR attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * Name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * The Owner ID of the VPC.
         */
        vpcOwnerId: string;
        /**
         * The mappings of zone
         */
        zoneMappings: outputs.cen.GetTransitRouterVpcAttachmentsAttachmentZoneMapping[];
    }

    export interface GetTransitRouterVpcAttachmentsAttachmentZoneMapping {
        /**
         * The VSwitch ID.
         */
        vswitchId: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetTransitRouterVpnAttachmentsAttachment {
        /**
         * Whether to allow the forwarding router instance to automatically publish routing entries to IPsec connections.
         */
        autoPublishRouteEnabled: boolean;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        id: string;
        /**
         * Type of the resource.
         */
        resourceType: string;
        /**
         * The status of the transit router attachment.
         */
        status: string;
        /**
         * The description of the VPN connection.
         */
        transitRouterAttachmentDescription: string;
        transitRouterAttachmentId: string;
        /**
         * The name of the VPN connection.
         */
        transitRouterAttachmentName: string;
        /**
         * The ID of the forwarding router instance.
         */
        transitRouterId: string;
        /**
         * The id of the vpn.
         */
        vpnId: string;
        /**
         * The owner id of vpn.
         */
        vpnOwnerId: string;
        /**
         * The list of zone mapping.
         */
        zones: outputs.cen.GetTransitRouterVpnAttachmentsAttachmentZone[];
    }

    export interface GetTransitRouterVpnAttachmentsAttachmentZone {
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface GetTransitRoutersTransitRouter {
        /**
         * The UID of the Aliyun.
         */
        aliUid: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The ID of the resource, It is formatted to `<cen_id>:<transit_router_id>`. **NOTE:** Before 1.151.0, It is formatted to `<transit_router_id>`.
         */
        id: string;
        /**
         * The status of the resource. Valid values `Active`, `Creating`, `Deleting` and `Updating`.
         */
        status: string;
        /**
         * The description of the transit router.
         */
        transitRouterDescription: string;
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The name of the transit router.
         */
        transitRouterName: string;
        /**
         * The Type of the transit router.
         */
        type: string;
        /**
         * The vip of the XGW.
         */
        xgwVip: string;
    }

    export interface GetVbrHealthChecksCheck {
        /**
         * The ID of the Cloud Enterprise Network (CEN) instance.
         */
        cenId: string;
        /**
         * The time interval at which probe packets are sent during the health check.
         */
        healthCheckInterval: number;
        /**
         * The source IP address of the health check.
         */
        healthCheckSourceIp: string;
        /**
         * The destination IP address of the health check.
         */
        healthCheckTargetIp: string;
        /**
         * The number of probe packets that are sent during the health check.
         */
        healthyThreshold: number;
        /**
         * The ID of the CEN VBR Heath Check.
         */
        id: string;
        /**
         * The ID of the VBR instance.
         */
        vbrInstanceId: string;
        /**
         * The ID of the region where the VBR instance is deployed.
         */
        vbrInstanceRegionId: string;
    }

    export interface TransitRouterVpcAttachmentZoneMapping {
        /**
         * The VSwitch id of attachment.
         */
        vswitchId?: string;
        /**
         * The zone Id of VSwitch.
         */
        zoneId?: string;
    }

    export interface TransitRouterVpnAttachmentZone {
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

}

export namespace cfg {
    export interface AggregateCompliancePackConfigRule {
        /**
         * A list of parameter rules.
         */
        configRuleParameters?: outputs.cfg.AggregateCompliancePackConfigRuleConfigRuleParameter[];
        /**
         * The Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface AggregateCompliancePackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName?: string;
        /**
         * The Parameter Value.
         */
        parameterValue?: string;
    }

    export interface AggregateCompliancePackConfigRuleId {
        /**
         * The rule ID of Aggregate Config Rule.
         */
        configRuleId?: string;
    }

    export interface AggregatorAggregatorAccount {
        /**
         * Aggregator account Uid.
         */
        accountId: string;
        /**
         * Aggregator account name.
         */
        accountName: string;
        /**
         * Aggregator account source type. Valid values: `ResourceDirectory`.
         */
        accountType: string;
    }

    export interface CompliancePackConfigRule {
        /**
         * A list of Config Rule Parameters.
         */
        configRuleParameters?: outputs.cfg.CompliancePackConfigRuleConfigRuleParameter[];
        /**
         * The Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface CompliancePackConfigRuleConfigRuleParameter {
        /**
         * The parameter name.
         */
        parameterName?: string;
        /**
         * The parameter value.
         */
        parameterValue?: string;
    }

    export interface CompliancePackConfigRuleId {
        /**
         * The rule ID of Config Rule.
         */
        configRuleId?: string;
    }

    export interface GetAggregateCompliancePacksPack {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * The Aggregate Compliance Package Name.
         */
        aggregateCompliancePackName: string;
        /**
         * The Aggregate Compliance Package Id.
         */
        aggregatorCompliancePackId: string;
        /**
         * The template ID of the Compliance Package.
         */
        compliancePackTemplateId: string;
        /**
         * A list of The Aggregate Compliance Package Rules.
         */
        configRules: outputs.cfg.GetAggregateCompliancePacksPackConfigRule[];
        /**
         * The description of aggregate compliance pack.
         */
        description: string;
        /**
         * The ID of the Aggregate Compliance Pack.
         */
        id: string;
        /**
         * The Risk Level.
         */
        riskLevel: number;
        /**
         * The status of the resource. Valid values `ACTIVE`, `CREATING`, `INACTIVE`.
         */
        status: string;
    }

    export interface GetAggregateCompliancePacksPackConfigRule {
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.GetAggregateCompliancePacksPackConfigRuleConfigRuleParameter[];
        /**
         * Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface GetAggregateCompliancePacksPackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
        /**
         * Required.
         */
        required: boolean;
    }

    export interface GetAggregateConfigRulesRule {
        /**
         * The Aliyun User ID.
         */
        accountId: string;
        /**
         * The config rule name.
         */
        aggregateConfigRuleName: string;
        /**
         * The ID of aggregator.
         */
        aggregatorId: string;
        /**
         * The ID of Compliance Package.
         */
        compliancePackId: string;
        /**
         * The Compliance information.
         */
        compliances: outputs.cfg.GetAggregateConfigRulesRuleCompliance[];
        /**
         * The config rule arn.
         */
        configRuleArn: string;
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * The trigger types of config rules.
         */
        configRuleTriggerTypes: string;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Event source of the Config Rule.
         */
        eventSource: string;
        /**
         * The id of the resources to be evaluated against the rule.
         */
        excludeResourceIdsScope: string;
        /**
         * The ID of the Aggregate Config Rule.
         */
        id: string;
        /**
         * The settings of the input parameters for the rule.
         */
        inputParameters: {[key: string]: any};
        /**
         * The frequency of the compliance evaluations.
         */
        maximumExecutionFrequency: string;
        /**
         * The timestamp when the rule was last modified.
         */
        modifiedTimestamp: string;
        /**
         * The scope of resource region ids.
         */
        regionIdsScope: string;
        /**
         * The scope of resource group ids.
         */
        resourceGroupIdsScope: string;
        resourceTypesScopes: string[];
        /**
         * Optional, ForceNew) The Risk Level. Valid values `1`: critical, `2`: warning, `3`: info.
         */
        riskLevel: number;
        /**
         * The identifier of the managed rule or the arn of the custom function.
         */
        sourceIdentifier: string;
        /**
         * The source owner of the Config Rule.
         */
        sourceOwner: string;
        /**
         * The state of the config rule, valid values: `ACTIVE`, `DELETING`, `EVALUATING` and `INACTIVE`.
         */
        status: string;
        /**
         * The scope of tay key.
         */
        tagKeyScope: string;
        /**
         * The scope of tay value.
         */
        tagValueScope: string;
    }

    export interface GetAggregateConfigRulesRuleCompliance {
        /**
         * The Compliance Type.
         */
        complianceType: string;
        /**
         * The Count.
         */
        count: number;
    }

    export interface GetAggregateDeliveriesDelivery {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * The ID of the Aggregator.
         */
        aggregatorId: string;
        /**
         * Open or close delivery configuration change history.
         */
        configurationItemChangeNotification: boolean;
        /**
         * Open or close timed snapshot of shipping resources.
         */
        configurationSnapshot: boolean;
        /**
         * The Alibaba Cloud Resource Name (ARN) of the role to be assumed by the delivery method.
         */
        deliveryChannelAssumeRoleArn: string;
        /**
         * The rule attached to the delivery method.
         */
        deliveryChannelCondition: string;
        /**
         * The ID of the delivery method.
         */
        deliveryChannelId: string;
        /**
         * The name of the delivery method.
         */
        deliveryChannelName: string;
        /**
         * The ARN of the delivery destination.
         */
        deliveryChannelTargetArn: string;
        /**
         * The type of the delivery method.
         */
        deliveryChannelType: string;
        /**
         * The description of the delivery method.
         */
        description: string;
        /**
         * The ID of the Aggregate Delivery.
         */
        id: string;
        /**
         * Open or close non-compliance events of delivery resources.
         */
        nonCompliantNotification: boolean;
        /**
         * The oss ARN of the delivery channel when the value data oversized limit.
         */
        oversizedDataOssTargetArn: string;
        /**
         * The status of the delivery method. Valid values: `0`: The delivery method is disabled. `1`: The delivery destination is enabled.
         */
        status: number;
    }

    export interface GetAggregatorsAggregator {
        /**
         * Aggregator account uid.
         */
        accountId: string;
        /**
         * Account information in aggregator.
         */
        aggregatorAccounts: outputs.cfg.GetAggregatorsAggregatorAggregatorAccount[];
        /**
         * The id of aggregator.
         */
        aggregatorId: string;
        /**
         * The name of aggregator.
         */
        aggregatorName: string;
        /**
         * The type of aggregator.
         */
        aggregatorType: string;
        /**
         * The description of aggregator.
         */
        description: string;
        /**
         * The id of the aggregator.
         */
        id: string;
        /**
         * The status of the resource. Valid Values:  `0`: creating `1`: normal `2`: deleting.
         */
        status: string;
    }

    export interface GetAggregatorsAggregatorAggregatorAccount {
        /**
         * Aggregator account uid.
         */
        accountId: string;
        /**
         * Aggregator account name.
         */
        accountName: string;
        /**
         * Aggregator account source type.
         */
        accountType: string;
    }

    export interface GetCompliancePacksPack {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * The Compliance Package ID.
         */
        compliancePackId: string;
        /**
         * The Compliance Package Name.
         */
        compliancePackName: string;
        /**
         * The template ID of the Compliance Package.
         */
        compliancePackTemplateId: string;
        /**
         * A list of The Compliance Package Rules.
         */
        configRules: outputs.cfg.GetCompliancePacksPackConfigRule[];
        /**
         * The description of compliance pack.
         */
        description: string;
        /**
         * The ID of the Compliance Pack.
         */
        id: string;
        /**
         * The Ris Level.
         */
        riskLevel: number;
        /**
         * The status of the resource. Valid values `ACTIVE`, `CREATING`.
         */
        status: string;
    }

    export interface GetCompliancePacksPackConfigRule {
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.GetCompliancePacksPackConfigRuleConfigRuleParameter[];
        /**
         * Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface GetCompliancePacksPackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
        /**
         * Required.
         */
        required: boolean;
    }

    export interface GetConfigurationRecordersRecorder {
        /**
         * The ID of the Alicloud account.
         */
        accountId: string;
        /**
         * The ID of the Config Configuration Recorder. Value as the `accountId`.
         */
        id: string;
        /**
         * Enterprise version configuration audit enabled status.
         */
        organizationEnableStatus: string;
        /**
         * The ID of the Enterprise management account.
         */
        organizationMasterId: number;
        /**
         * A list of resource types to be monitored.
         */
        resourceTypes: string[];
        /**
         * Status of resource monitoring.
         */
        status: string;
    }

    export interface GetDeliveriesDelivery {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * Open or close delivery configuration change history.
         */
        configurationItemChangeNotification: boolean;
        /**
         * Open or close timed snapshot of shipping resources.
         */
        configurationSnapshot: boolean;
        /**
         * The Alibaba Cloud Resource Name (ARN) of the role to be assumed by the delivery method.
         */
        deliveryChannelAssumeRoleArn: string;
        /**
         * The rule attached to the delivery method.
         */
        deliveryChannelCondition: string;
        /**
         * The ID of the delivery method.
         */
        deliveryChannelId: string;
        /**
         * The name of the delivery method.
         */
        deliveryChannelName: string;
        /**
         * The ARN of the delivery destination.
         */
        deliveryChannelTargetArn: string;
        /**
         * The type of the delivery method.
         */
        deliveryChannelType: string;
        /**
         * The description of the delivery method.
         */
        description: string;
        /**
         * The ID of the Delivery.
         */
        id: string;
        /**
         * Open or close non-compliance events of delivery resources.
         */
        nonCompliantNotification: boolean;
        /**
         * The oss ARN of the delivery channel when the value data oversized limit.
         */
        oversizedDataOssTargetArn: string;
        /**
         * The status of the delivery method. Valid values: `0`: The delivery method is disabled. `1`: The delivery destination is enabled.
         */
        status: number;
    }

    export interface GetDeliveryChannelsChannel {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the role assumed by delivery method.
         */
        deliveryChannelAssumeRoleArn: string;
        /**
         * The rule attached to the delivery method. This parameter is applicable only to delivery methods of the Message Service (MNS) type.
         */
        deliveryChannelCondition: string;
        /**
         * The ID of the delivery channel.
         */
        deliveryChannelId: string;
        /**
         * The name of the delivery channel.
         */
        deliveryChannelName: string;
        /**
         * The ARN of the delivery destination.
         */
        deliveryChannelTargetArn: string;
        /**
         * The type of the delivery channel.
         */
        deliveryChannelType: string;
        /**
         * The description of the delivery channel.
         */
        description: string;
        /**
         * The ID of the Config Delivery Channel.
         */
        id: string;
        /**
         * The status of the config delivery channel. Valid values `0`: Disable delivery channel, `1`: Enable delivery channel.
         */
        status: number;
    }

    export interface GetRulesRule {
        /**
         * The ID of the Alicloud account.
         */
        accountId: string;
        compliancePackId: string;
        /**
         * The information about the compliance evaluations based on the rule.
         */
        compliances: outputs.cfg.GetRulesRuleCompliance[];
        /**
         * The ARN of the Config Rule.
         */
        configRuleArn: string;
        /**
         * The ID of the Config Rule.
         */
        configRuleId: string;
        /**
         * Field `configRuleState` has been deprecated from provider version 1.124.1. New field `status` instead.
         */
        configRuleState: string;
        /**
         * (Available in 1.124.1+) A list of trigger types of config rule.
         */
        configRuleTriggerTypes: string;
        /**
         * The description of the Config Rule.
         */
        description: string;
        /**
         * Event source of the Config Rule.
         */
        eventSource: string;
        /**
         * (Available in 1.124.1+) The scope of exclude of resource ids.
         */
        excludeResourceIdsScope: string;
        /**
         * The ID of the Config Rule.
         */
        id: string;
        /**
         * The input parameters of the Config Rule.
         */
        inputParameters: {[key: string]: any};
        /**
         * (Available in 1.124.1+) The frequency of maximum execution.
         */
        maximumExecutionFrequency: string;
        /**
         * the timestamp of the Config Rule modified.
         */
        modifiedTimestamp: string;
        /**
         * (Available in 1.124.1+) The scope of region ids.
         */
        regionIdsScope: string;
        /**
         * (Available in 1.124.1+) The scope of resource group ids.
         */
        resourceGroupIdsScope: string;
        /**
         * (Available in 1.124.1+) The scope of resource types.
         */
        resourceTypesScopes: string[];
        /**
         * The risk level of Config Rule. Valid values: `1`: Critical ,`2`: Warning , `3`: Info.
         */
        riskLevel: number;
        /**
         * The name of config rule.
         */
        ruleName: string;
        /**
         * The types of the resources to be evaluated against the rule.
         */
        scopeComplianceResourceTypes: string[];
        /**
         * Rule trigger mechanism.
         */
        sourceDetailMessageType: string;
        /**
         * The identifier of the managed rule or the arn of the custom function.
         */
        sourceIdentifier: string;
        /**
         * Rule execution cycle.
         */
        sourceMaximumExecutionFrequency: string;
        /**
         * The source owner of the Config Rule.
         */
        sourceOwner: string;
        /**
         * The status of the config rule, valid values: `ACTIVE`, `DELETING`, `EVALUATING` and `INACTIVE`.
         */
        status: string;
        /**
         * (Available in 1.124.1+) The scope of tag key.
         */
        tagKeyScope: string;
        /**
         * (Available in 1.124.1+) The scope of tag value.
         */
        tagValueScope: string;
    }

    export interface GetRulesRuleCompliance {
        /**
         * The compliance evaluation result of the target resources.
         */
        complianceType: string;
        /**
         * The number of resources with the specified compliance evaluation result.
         */
        count: number;
    }

    export interface RuleCompliance {
        /**
         * The type of compliance. Valid values: `COMPLIANT`, `NON_COMPLIANT`, `NOT_APPLICABLE`, `INSUFFICIENT_DATA`.
         */
        complianceType: string;
        /**
         * The count of compliance.
         */
        count: number;
    }

}

export namespace chatbot {
    export interface GetAgentsAgent {
        /**
         * The agent id.
         */
        agentId: string;
        /**
         * Service space signature, which is used when PAAS interface specifies the service space.
         */
        agentKey: string;
        /**
         * The name of the agent.
         */
        agentName: string;
        /**
         * ID of the agent.
         */
        id: string;
    }

}

export namespace clickhouse {
    export interface DbClusterDbClusterAccessWhiteList {
        /**
         * Field `dbClusterIpArrayAttribute` has been removed from provider.
         */
        dbClusterIpArrayAttribute?: string;
        /**
         * Whitelist group name.
         */
        dbClusterIpArrayName?: string;
        /**
         * The IP address list under the whitelist group.
         */
        securityIpList?: string;
    }

    export interface GetAccountsAccount {
        /**
         * In Chinese, English letter. May contain Chinese and English characters, lowercase letters, numbers, and underscores (_), the dash (-). Cannot start with http:// and https:// at the beginning. Length is from 2 to 256 characters.
         */
        accountDescription: string;
        /**
         * Account name: lowercase letters, numbers, underscores, lowercase letter; length no more than 16 characters.
         */
        accountName: string;
        /**
         * The Valid Account type: `Normal`, `Super`.
         */
        accountType: string;
        /**
         * The DBCluster id.
         */
        dbClusterId: string;
        /**
         * The ID of the Account. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetBackupPoliciesPolicy {
        /**
         * Data backup days. Valid values: `7` to `730`.
         */
        backupRetentionPeriod: number;
        /**
         * The db cluster id.
         */
        dbClusterId: string;
        /**
         * The ID of the Backup Policy.
         */
        id: string;
        /**
         * DBCluster Backup period.
         */
        preferredBackupPeriods: string[];
        /**
         * Backup Time, UTC time.
         */
        preferredBackupTime: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetDbClustersCluster {
        /**
         * Alibaba Cloud account Id.
         */
        aliUid: string;
        /**
         * The ID of the business process flow.
         */
        bid: string;
        /**
         * Instance family values include: Basic: Basic edition; HighAvailability: high availability edition.
         */
        category: string;
        /**
         * The Commodity Code of the DBCluster.
         */
        commodityCode: string;
        /**
         * Connection string.
         */
        connectionString: string;
        /**
         * The control version of the DBCluster.
         */
        controlVersion: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The db cluster access white list.
         */
        dbClusterAccessWhiteLists: outputs.clickhouse.GetDbClustersClusterDbClusterAccessWhiteList[];
        /**
         * The DBCluster description.
         */
        dbClusterDescription: string;
        dbClusterId: string;
        /**
         * The DBCluster network type.
         */
        dbClusterNetworkType: string;
        /**
         * The DBCluster type.
         */
        dbClusterType: string;
        /**
         * The node class of the DBCluster.
         */
        dbNodeClass: string;
        /**
         * The node count of the DBCluster.
         */
        dbNodeCount: string;
        /**
         * The node storage of the DBCluster.
         */
        dbNodeStorage: string;
        /**
         * Key management service KMS key ID.
         */
        encryptionKey: string;
        /**
         * Currently only supports ECS disk encryption, with a value of CloudDisk, not encrypted when empty.
         */
        encryptionType: string;
        /**
         * The Engine of the DBCluster.
         */
        engine: string;
        /**
         * The engine version of the DBCluster.
         */
        engineVersion: string;
        /**
         * The expiration time of the DBCluster.
         */
        expireTime: string;
        /**
         * The ID of the DBCluster.
         */
        id: string;
        /**
         * If the instance has expired.
         */
        isExpired: string;
        /**
         * The lock mode of the DBCluster.
         */
        lockMode: string;
        /**
         * Lock reason of the DBCluster.
         */
        lockReason: string;
        /**
         * Examples of the maintenance window, in the format of hh:mmZ-hh:mm Z.
         */
        maintainTime: string;
        /**
         * The payment type of the resource. Valid values: `PayAsYouGo`,`Subscription`.
         */
        paymentType: string;
        /**
         * Connection port.
         */
        port: number;
        /**
         * A public IP address for the connection.
         */
        publicConnectionString: string;
        /**
         * Public network port.
         */
        publicPort: string;
        /**
         * Scale state.
         */
        scaleOutStatuses: outputs.clickhouse.GetDbClustersClusterScaleOutStatus[];
        /**
         * The status of the DBCluster. Valid values: `Running`,`Creating`,`Deleting`,`Restarting`,`Preparing`.
         */
        status: string;
        /**
         * Storage type of DBCluster. Valid values: `cloudEssd`, `cloudEfficiency`, `cloudEssdPl2`, `cloudEssdPl3`.
         */
        storageType: string;
        /**
         * Support fallback scheme.
         */
        supportBackup: number;
        /**
         * The system supports http port number.
         */
        supportHttpsPort: boolean;
        /**
         * Supports Mysql, and those of the ports.
         */
        supportMysqlPort: boolean;
        /**
         * Virtual Private Cloud (VPC cloud instance ID.
         */
        vpcCloudInstanceId: string;
        /**
         * The VPC ID of the DBCluster.
         */
        vpcId: string;
        /**
         * The vswitch id of the DBCluster.
         */
        vswitchId: string;
        /**
         * The zone ID of the DBCluster.
         */
        zoneId: string;
    }

    export interface GetDbClustersClusterDbClusterAccessWhiteList {
        /**
         * Field `dbClusterIpArrayAttribute` has been removed from provider.
         */
        dbClusterIpArrayAttribute: string;
        /**
         * Whitelist group name.
         */
        dbClusterIpArrayName: string;
        /**
         * The IP address list under the whitelist group.
         */
        securityIpList: string;
    }

    export interface GetDbClustersClusterScaleOutStatus {
        /**
         * Process.
         */
        progress: string;
        /**
         * Efficiency.
         */
        ratio: string;
    }

    export interface GetRegionsRegion {
        /**
         * The Region ID.
         */
        regionId: string;
        /**
         * A list of available zone ids in the region_id.
         */
        zoneIds: outputs.clickhouse.GetRegionsRegionZoneId[];
    }

    export interface GetRegionsRegionZoneId {
        /**
         * Whether to support vpc network.
         */
        vpcEnabled: boolean;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

}

export namespace cloudauth {
    export interface GetFaceConfigsConfig {
        /**
         * Scene name.
         */
        bizName: string;
        /**
         * Scene type. **NOTE:** The bizType cannot exceed 32 characters and can only use English letters, numbers and dashes (-).
         */
        bizType: string;
        /**
         * The Update Time.
         */
        gmtUpdated: string;
    }

}

export namespace cloudconnect {
    export interface GetNetworksNetwork {
        /**
         * CidrBlock of the CCN instance.
         */
        cidrBlock: string;
        description: string;
        /**
         * ID of the CCN instance.
         */
        id: string;
        /**
         * IsDefault of the CCN instance.
         */
        isDefault: boolean;
        /**
         * Name of the CCN instance.
         */
        name: string;
    }

}

export namespace cloudfirewall {
    export interface AddressBookEcsTag {
        /**
         * The key of ECS tag that to be matched.
         */
        tagKey?: string;
        /**
         * The value of ECS tag that to be matched.
         */
        tagValue?: string;
    }

    export interface FirewallVpcFirewallCenLocalVpc {
        /**
         * The connection ID of the network instance.
         */
        attachmentId: string;
        /**
         * The connection name of the network instance.
         */
        attachmentName: string;
        /**
         * The list of network segments protected by the VPC firewall.
         */
        defendCidrLists: string[];
        /**
         * List of elastic network cards.
         */
        eniLists: outputs.cloudfirewall.FirewallVpcFirewallCenLocalVpcEniList[];
        manualVswitchId: string;
        /**
         * The ID of the VPC instance that created the VPC firewall.
         */
        networkInstanceId: string;
        /**
         * The name of the network instance.
         */
        networkInstanceName: string;
        /**
         * The type of the network instance. Value: **VPC * *.
         */
        networkInstanceType: string;
        /**
         * The UID of the Alibaba Cloud account to which the VPC belongs.
         */
        ownerId: string;
        /**
         * The region ID of the VPC.
         */
        regionNo: string;
        /**
         * Routing mode,. Value:-auto: indicates automatic mode.-manual: indicates manual mode.
         */
        routeMode: string;
        /**
         * Whether routing mode supports manual mode. Value:-**1**: Supported.-**0**: Not supported.
         */
        supportManualMode: string;
        /**
         * The ID of the CEN-TR instance.
         */
        transitRouterId: string;
        /**
         * The version of the cloud enterprise network forwarding router (CEN-TR). Value:-**Basic**: Basic Edition.-**Enterprise**: Enterprise Edition.
         */
        transitRouterType: string;
        /**
         * The VPC network segment list.
         */
        vpcCidrTableLists: outputs.cloudfirewall.FirewallVpcFirewallCenLocalVpcVpcCidrTableList[];
        /**
         * The ID of the VPC instance.
         */
        vpcId: string;
        /**
         * The instance name of the VPC.
         */
        vpcName: string;
    }

    export interface FirewallVpcFirewallCenLocalVpcEniList {
        /**
         * The ID of the instance of the ENI in the VPC.
         */
        eniId: string;
        /**
         * The private IP address of the ENI in the VPC.
         */
        eniPrivateIpAddress: string;
    }

    export interface FirewallVpcFirewallCenLocalVpcVpcCidrTableList {
        /**
         * The list of route entries in the VPC.
         */
        routeEntryLists: outputs.cloudfirewall.FirewallVpcFirewallCenLocalVpcVpcCidrTableListRouteEntryList[];
        /**
         * The ID of the route table of the VPC.
         */
        routeTableId: string;
    }

    export interface FirewallVpcFirewallCenLocalVpcVpcCidrTableListRouteEntryList {
        /**
         * The target network segment of the VPC.
         */
        destinationCidr: string;
        /**
         * The ID of the next hop instance in the VPC.
         */
        nextHopInstanceId: string;
    }

    export interface FirewallVpcFirewallLocalVpc {
        /**
         * The ID of the instance of the Eni in the local VPC.
         */
        eniId: string;
        /**
         * The private IP address of the elastic network card in the local VPC.
         */
        eniPrivateIpAddress: string;
        /**
         * The network segment list of the local VPC.See the following `Block LocalVpcCidrTableList`.
         */
        localVpcCidrTableLists: outputs.cloudfirewall.FirewallVpcFirewallLocalVpcLocalVpcCidrTableList[];
        /**
         * The region ID of the local VPC.
         */
        regionNo: string;
        /**
         * The ID of the router interface in the local VPC.
         */
        routerInterfaceId: string;
        /**
         * The ID of the local VPC instance.
         */
        vpcId: string;
        /**
         * The instance name of the local VPC.
         */
        vpcName: string;
    }

    export interface FirewallVpcFirewallLocalVpcLocalVpcCidrTableList {
        /**
         * The list of route entries of the local VPC.See the following `Block LocalRouteEntryList`.
         */
        localRouteEntryLists: outputs.cloudfirewall.FirewallVpcFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList[];
        /**
         * The ID of the route table of the local VPC.
         */
        localRouteTableId: string;
    }

    export interface FirewallVpcFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList {
        /**
         * The target network segment of the local VPC.
         */
        localDestinationCidr: string;
        /**
         * The ID of the next-hop instance in the local VPC.
         */
        localNextHopInstanceId: string;
    }

    export interface FirewallVpcFirewallPeerVpc {
        /**
         * The ID of the instance of the Eni in the local VPC.
         */
        eniId: string;
        /**
         * The private IP address of the elastic network card in the local VPC.
         */
        eniPrivateIpAddress: string;
        /**
         * The network segment list of the peer VPC.See the following `Block PeerVpcCidrTableList`.
         */
        peerVpcCidrTableLists: outputs.cloudfirewall.FirewallVpcFirewallPeerVpcPeerVpcCidrTableList[];
        /**
         * The region ID of the local VPC.
         */
        regionNo: string;
        /**
         * The ID of the router interface in the local VPC.
         */
        routerInterfaceId: string;
        /**
         * The ID of the local VPC instance.
         */
        vpcId: string;
        /**
         * The instance name of the local VPC.
         */
        vpcName: string;
    }

    export interface FirewallVpcFirewallPeerVpcPeerVpcCidrTableList {
        /**
         * Peer VPC route entry list information.See the following `Block PeerRouteEntryList`.
         */
        peerRouteEntryLists: outputs.cloudfirewall.FirewallVpcFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList[];
        /**
         * The ID of the route table of the peer VPC.
         */
        peerRouteTableId: string;
    }

    export interface FirewallVpcFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList {
        /**
         * The target network segment of the peer VPC.
         */
        peerDestinationCidr: string;
        /**
         * The ID of the next-hop instance in the peer VPC.
         */
        peerNextHopInstanceId: string;
    }

    export interface GetAddressBooksBook {
        /**
         * The addresses in the Address Book.
         */
        addressLists: string[];
        /**
         * Whether you want to automatically add new matching tags of the ECS IP address to the Address Book.
         */
        autoAddTagEcs: number;
        /**
         * The description of the Address Book.
         */
        description: string;
        /**
         * The logical relation among the ECS tags that to be matchedh.
         */
        ecsTags?: outputs.cloudfirewall.GetAddressBooksBookEcsTag[];
        /**
         * The name of the Address Book.
         */
        groupName: string;
        /**
         * The type of the Address Book.
         */
        groupType: string;
        /**
         * The ID of the Address Book.
         */
        groupUuid: string;
        /**
         * The ID of the Address Book.
         */
        id: string;
        /**
         * One or more tags for the relationship between.
         */
        tagRelation: string;
    }

    export interface GetAddressBooksBookEcsTag {
        /**
         * The key of ECS tag that to be matched.
         */
        tagKey?: string;
        /**
         * The value of ECS tag that to be matched.
         */
        tagValue?: string;
    }

    export interface GetControlPoliciesPolicy {
        /**
         * The action that Cloud Firewall performs on the traffic. Valid values: `accept`, `drop`, `log`.
         */
        aclAction: string;
        /**
         * The unique ID of the access control policy.
         */
        aclUuid: string;
        applicationId: string;
        /**
         * The application type that the access control policy supports.If `direction` is `in`, the valid value is `ANY`. If `direction` is `out`, `ANY`, `HTTP`, `HTTPS`, `MQTT`, `Memcache`, `MongoDB`, `MySQL`, `RDP`, `Redis`, `SMTP`, `SMTPS`, `SSH`, `SSL`, `VNC`.
         */
        applicationName: string;
        /**
         * The description of the access control policy.
         */
        description: string;
        /**
         * The destination port defined in the access control policy.
         */
        destPort: string;
        /**
         * The destination port address book defined in the access control policy.
         */
        destPortGroup: string;
        destPortGroupPorts: string[];
        /**
         * The destination port type defined in the access control policy. Valid values: `group`, `port`.
         */
        destPortType: string;
        /**
         * The destination address defined in the access control policy.
         */
        destination: string;
        destinationGroupCidrs: string[];
        destinationGroupType: string;
        /**
         * The destination address type defined in the access control policy.Valid values: If `direction` is `in`, the valid values are `net`, `group`. If `direction` is `out`, the valid values are `net`, `group`, `domain`, `location`.
         */
        destinationType: string;
        /**
         * The direction of traffic to which the access control policy applies. Valid values: `in`, `out`.
         */
        direction: string;
        dnsResult: string;
        dnsResultTime: string;
        hitTimes: string;
        /**
         * The ID of the Control Policy.
         */
        id: string;
        order: number;
        /**
         * The protocol type of traffic to which the access control policy applies. Valid values: If `direction` is `in`, the valid value is `ANY`. If `direction` is `out`, the valid values are `ANY`, `TCP`, `UDP`, `ICMP`.
         */
        proto: string;
        /**
         * Specifies whether the access control policy is enabled. By default, an access control policy is enabled after it is created. Valid values: `true`, `false`.
         */
        release: boolean;
        /**
         * The source address defined in the access control policy.
         */
        source: string;
        sourceGroupCidrs: string[];
        sourceGroupType: string;
        /**
         * The type of the source address book defined in the access control policy. Valid values: If `direction` is to `in`, the valid values are `net`, `group`, `location`. If `direction` is `out`, the valid values are `net`, `group`.
         */
        sourceType: string;
    }

    export interface GetInstanceMembersMember {
        /**
         * When the cloud firewall member account was added.> use second-level timestamp format.
         */
        createTime: number;
        id: string;
        /**
         * Remarks of cloud firewall member accounts.
         */
        memberDesc: string;
        /**
         * The name of the cloud firewall member account.
         */
        memberDisplayName: string;
        /**
         * The UID of the cloud firewall member account.
         */
        memberUid: string;
        /**
         * The last modification time of the cloud firewall member account.> use second-level timestamp format.
         */
        modifyTime: number;
        /**
         * The resource attribute field that represents the resource status.
         */
        status: string;
    }

    export interface GetInstancesInstance {
        /**
         * The Creation time of the resource.
         */
        createTime: string;
        /**
         * The end time of the resource..
         */
        endTime: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        instanceId: string;
        /**
         * The payment type of the resource. Valid values: `Subscription`.
         */
        paymentType: string;
        /**
         * Automatic renewal period unit. Valid values: `Month`,`Year`.
         */
        renewalDurationUnit: string;
        /**
         * Automatic renewal status. Valid values: `AutoRenewal`,`ManualRenewal`. Default Value: `ManualRenewal`.
         */
        renewalStatus: string;
        /**
         * The Status of Instance.
         */
        status: string;
    }

    export interface GetVpcFirewallCensCen {
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * Intercommunication type, value: `expressconnect`: Express Channel `cen`: Cloud Enterprise Network
         */
        connectType: string;
        /**
         * The ID of the CEN instance.
         */
        id: string;
        /**
         * The details of the VPC.
         */
        localVpcs: outputs.cloudfirewall.GetVpcFirewallCensCenLocalVpc[];
        /**
         * The ID of the VPC instance that created the VPC firewall.
         */
        networkInstanceId: string;
        /**
         * Firewall switch status
         */
        status: string;
        /**
         * VPC firewall ID
         */
        vpcFirewallId: string;
        /**
         * The name of the VPC firewall instance.
         */
        vpcFirewallName: string;
    }

    export interface GetVpcFirewallCensCenLocalVpc {
        attachmentId: string;
        attachmentName: string;
        /**
         * The list of network segments protected by the VPC firewall.
         */
        defendCidrLists: string[];
        eniLists: outputs.cloudfirewall.GetVpcFirewallCensCenLocalVpcEniList[];
        manualVswitchId: string;
        /**
         * The ID of the VPC instance that created the VPC firewall.
         */
        networkInstanceId: string;
        /**
         * The name of the network instance.
         */
        networkInstanceName: string;
        /**
         * The type of the network instance. Value: **VPC * *.
         */
        networkInstanceType: string;
        /**
         * The UID of the Alibaba Cloud account to which the VPC belongs.
         */
        ownerId: string;
        /**
         * The region ID of the VPC.
         */
        regionNo: string;
        /**
         * Routing mode,. Value:-auto: indicates automatic mode.-manual: indicates manual mode.
         */
        routeMode: string;
        /**
         * Whether routing mode supports manual mode. Value:-**1**: Supported.-**0**: Not supported.
         */
        supportManualMode: string;
        transitRouterId: string;
        /**
         * The version of the cloud enterprise network forwarding router (CEN-TR). Value:-**Basic**: Basic Edition.-**Enterprise**: Enterprise Edition.
         */
        transitRouterType: string;
        /**
         * The VPC network segment list.
         */
        vpcCidrTableLists: outputs.cloudfirewall.GetVpcFirewallCensCenLocalVpcVpcCidrTableList[];
        /**
         * The ID of the VPC instance.
         */
        vpcId: string;
        /**
         * The instance name of the VPC.
         */
        vpcName: string;
    }

    export interface GetVpcFirewallCensCenLocalVpcEniList {
        eniId: string;
        eniPrivateIpAddress: string;
    }

    export interface GetVpcFirewallCensCenLocalVpcVpcCidrTableList {
        /**
         * The list of route entries in the VPC.
         */
        routeEntryLists: outputs.cloudfirewall.GetVpcFirewallCensCenLocalVpcVpcCidrTableListRouteEntryList[];
        /**
         * The ID of the route table of the VPC.
         */
        routeTableId: string;
    }

    export interface GetVpcFirewallCensCenLocalVpcVpcCidrTableListRouteEntryList {
        /**
         * The target network segment of the VPC.
         */
        destinationCidr: string;
        /**
         * The ID of the next hop instance in the VPC.
         */
        nextHopInstanceId: string;
    }

    export interface GetVpcFirewallControlPoliciesPolicy {
        /**
         * Access control over VPC firewalls are set in the access traffic via Alibaba cloud firewall way (ACT).
         */
        aclAction: string;
        /**
         * Access control over VPC firewalls strategy unique identifier.
         */
        aclUuid: string;
        /**
         * Policy specifies the application ID.
         */
        applicationId: string;
        /**
         * Access control over VPC firewalls policies support the application types.
         */
        applicationName: string;
        /**
         * Access control over VPC firewalls description of the strategy information.
         */
        description: string;
        /**
         * Access control over VPC firewalls strategy access traffic of the destination port.
         */
        destPort: string;
        /**
         * Access control policy in the access traffic of the destination port address book name.
         */
        destPortGroup: string;
        /**
         * Port Address Book port list.
         */
        destPortGroupPorts: string[];
        /**
         * Access control over VPC firewalls strategy access traffic of the destination port type.
         */
        destPortType: string;
        /**
         * Access control over VPC firewalls strategy the destination address in.
         */
        destination: string;
        /**
         * Destination address book defined in the address list.
         */
        destinationGroupCidrs: string[];
        /**
         * The destination address book type in the access control policy. Value: `ip`, `domain`.
         */
        destinationGroupType: string;
        /**
         * Access control over VPC firewalls strategy in the destination address of the type.
         */
        destinationType: string;
        /**
         * Control strategy of hits per second.
         */
        hitTimes: number;
        /**
         * The ID of the Cloud Firewall Vpc Firewall Control Policy.
         */
        id: string;
        /**
         * The UID of the member account of the current Alibaba cloud account.
         */
        memberUid: string;
        /**
         * Access control over VPC firewalls policies will go into effect of priority. The priority value starts from 1, the smaller the priority number, the higher the priority. -1 represents the lowest priority.
         */
        order: number;
        /**
         * Access control over VPC firewalls strategy access traffic of the protocol type.
         */
        proto: string;
        /**
         * The enabled status of the access control policy. The policy is enabled by default after it is created. Value:
         */
        release: boolean;
        /**
         * Access control over VPC firewalls strategy in the source address.
         */
        source: string;
        /**
         * SOURCE address of the address list.
         */
        sourceGroupCidrs: string[];
        /**
         * The source address type in the access control policy. Unique value: **ip**. The IP address book contains one or more IP address segments.
         */
        sourceGroupType: string;
        /**
         * Access control over VPC firewalls policy source address type.
         */
        sourceType: string;
        /**
         * The ID of the VPC firewall instance.
         */
        vpcFirewallId: string;
    }

    export interface GetVpcFirewallsFirewall {
        /**
         * Bandwidth specifications for high-speed channels. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The communication type of the VPC firewall. Valid value: **expressconnect**, which indicates Express Connect.
         */
        connectType: string;
        /**
         * The name of the VPC firewall instance and the value same as `vpcFirewallId`.
         */
        id: string;
        /**
         * The details of the local VPC.
         */
        localVpcs: outputs.cloudfirewall.GetVpcFirewallsFirewallLocalVpc[];
        /**
         * The details of the peer VPC.
         */
        peerVpcs: outputs.cloudfirewall.GetVpcFirewallsFirewallPeerVpc[];
        /**
         * The region is open. Value:-**enable**: is enabled, indicating that VPC firewall can be configured in this region.-**disable**: indicates that VPC firewall cannot be configured in this region.
         */
        regionStatus: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * The ID of the VPC firewall instance.
         */
        vpcFirewallId: string;
        /**
         * The name of the VPC firewall instance.
         */
        vpcFirewallName: string;
    }

    export interface GetVpcFirewallsFirewallLocalVpc {
        eniId: string;
        eniPrivateIpAddress: string;
        /**
         * The network segment list of the local VPC.
         */
        localVpcCidrTableLists: outputs.cloudfirewall.GetVpcFirewallsFirewallLocalVpcLocalVpcCidrTableList[];
        /**
         * The region ID of the peer VPC.
         */
        regionNo: string;
        routerInterfaceId: string;
        /**
         * The ID of the peer VPC instance.
         */
        vpcId: string;
        /**
         * The instance name of the peer VPC.
         */
        vpcName: string;
    }

    export interface GetVpcFirewallsFirewallLocalVpcLocalVpcCidrTableList {
        /**
         * The list of route entries of the local VPC.
         */
        localRouteEntryLists: outputs.cloudfirewall.GetVpcFirewallsFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList[];
        /**
         * The ID of the route table of the local VPC.
         */
        localRouteTableId: string;
    }

    export interface GetVpcFirewallsFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList {
        /**
         * The target network segment of the local VPC.
         */
        localDestinationCidr: string;
        /**
         * The ID of the next-hop instance in the local VPC.
         */
        localNextHopInstanceId: string;
    }

    export interface GetVpcFirewallsFirewallPeerVpc {
        eniId: string;
        eniPrivateIpAddress: string;
        /**
         * The network segment list of the peer VPC.
         */
        peerVpcCidrTableLists: outputs.cloudfirewall.GetVpcFirewallsFirewallPeerVpcPeerVpcCidrTableList[];
        /**
         * The region ID of the peer VPC.
         */
        regionNo: string;
        routerInterfaceId: string;
        /**
         * The ID of the peer VPC instance.
         */
        vpcId: string;
        /**
         * The instance name of the peer VPC.
         */
        vpcName: string;
    }

    export interface GetVpcFirewallsFirewallPeerVpcPeerVpcCidrTableList {
        /**
         * Peer VPC route entry list information.
         */
        peerRouteEntryLists: outputs.cloudfirewall.GetVpcFirewallsFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList[];
        /**
         * The ID of the route table of the peer VPC.
         */
        peerRouteTableId: string;
    }

    export interface GetVpcFirewallsFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList {
        /**
         * The target network segment of the peer VPC.
         */
        peerDestinationCidr: string;
        /**
         * The ID of the next-hop instance in the peer VPC.
         */
        peerNextHopInstanceId: string;
    }

}

export namespace cloudsso {
    export interface AccessConfigurationPermissionPolicy {
        /**
         * The Content of Policy.
         */
        permissionPolicyDocument?: string;
        /**
         * The Policy Name of policy. The name of the resource.
         */
        permissionPolicyName: string;
        /**
         * The Policy Type of policy. Valid values: `System`, `Inline`.
         */
        permissionPolicyType: string;
    }

    export interface DirectorySamlIdentityProviderConfiguration {
        /**
         * Base64 encoded IdP metadata document. **NOTE:** If the IdP Metadata has been uploaded, no update will be made if this parameter is not specified, otherwise the update will be made according to the parameter content. If IdP Metadata has not been uploaded, and the parameter `ssoStatus` is `Enabled`, this parameter must be provided. If the IdP Metadata has not been uploaded, and the parameter `ssoStatus` is `Disabled`, this parameter can be omitted, and the IdP Metadata will remain empty.
         */
        encodedMetadataDocument: string;
        /**
         * SAML SSO login enabled status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         *
         * > **NOTE:** The `samlIdentityProviderConfiguration` will be removed automatically when the resource is deleted, please operate with caution. If there are left more configuration in the directory, please remove them before deleting the directory.
         */
        ssoStatus: string;
    }

    export interface GetAccessAssignmentsAssignment {
        /**
         * Access configuration ID.
         */
        accessConfigurationId: string;
        /**
         * The name of the access configuration.
         */
        accessConfigurationName: string;
        /**
         * Directory ID.
         */
        directoryId: string;
        /**
         * The ID of the Access Assignment.
         */
        id: string;
        /**
         * The ID of the access assignment.
         */
        principalId: string;
        /**
         * Cloud SSO identity name.
         */
        principalName: string;
        /**
         * Create the identity type of the access assignment, which can be a user or a user group.
         */
        principalType: string;
        /**
         * The ID of the target to create the resource range.
         */
        targetId: string;
        /**
         * Task target name.
         */
        targetName: string;
        /**
         * The path name of the task target in the resource directory.
         */
        targetPathName: string;
        /**
         * The type of the resource range target to be accessed. Only a single RD primary account or member account can be specified in the first phase.
         */
        targetType: string;
    }

    export interface GetAccessConfigurationsConfiguration {
        /**
         * The AccessConfigurationId of the Access Configuration.
         */
        accessConfigurationId: string;
        /**
         * The AccessConfigurationName of the Access Configuration.
         */
        accessConfigurationName: string;
        /**
         * The Created Time of the Directory.
         */
        createTime: string;
        /**
         * The Description of the Directory.
         */
        description: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The ID of the Access Configuration.
         */
        id: string;
        /**
         * The Policy List.
         */
        permissionPolicies: outputs.cloudsso.GetAccessConfigurationsConfigurationPermissionPolicy[];
        /**
         * The RelayState of the Access Configuration.
         */
        relayState: string;
        /**
         * The SessionDuration of the Access Configuration.
         */
        sessionDuration: number;
        /**
         * The StatusNotifications of the Access Configuration.
         */
        statusNotifications: string[];
    }

    export interface GetAccessConfigurationsConfigurationPermissionPolicy {
        /**
         * The Creation time of policy.
         */
        addTime: string;
        /**
         * The Content of Policy.
         */
        permissionPolicyDocument: string;
        /**
         * The Policy Name of policy.
         */
        permissionPolicyName: string;
        /**
         * The Policy Type of policy. Valid values: `System`, `Inline`.
         */
        permissionPolicyType: string;
    }

    export interface GetDirectoriesDirectory {
        /**
         * Saml identifies the creation time of the provider configuration.
         */
        createTime: string;
        /**
         * The DirectoryId of the CloudSSO directory.
         */
        directoryId: string;
        /**
         * The name of the CloudSSO directory.
         */
        directoryName: string;
        /**
         * The ID of the Directory.
         */
        id: string;
        /**
         * The mfa authentication status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        mfaAuthenticationStatus: string;
        /**
         * The Region of the CloudSSO directory.
         */
        region: string;
        /**
         * The saml identity provider configuration.
         */
        samlIdentityProviderConfigurations: outputs.cloudsso.GetDirectoriesDirectorySamlIdentityProviderConfiguration[];
        /**
         * The scim synchronization status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        scimSynchronizationStatus: string;
        /**
         * Asynchronous Task Information Array.
         */
        tasks: outputs.cloudsso.GetDirectoriesDirectoryTask[];
    }

    export interface GetDirectoriesDirectorySamlIdentityProviderConfiguration {
        /**
         * Saml identifies the creation time of the provider configuration.
         */
        createTime: string;
        /**
         * Base64 encoded IdP metadata document.
         */
        encodedMetadataDocument: string;
        /**
         * SAML IdPEntityID.
         */
        entityId: string;
        /**
         * SAML IdP http-post Binding address.
         */
        loginUrl: string;
        /**
         * SAML SSO login enabled status. Valid values: `Enabled` or `Disabled`. Default to `Disabled`.
         */
        ssoStatus: string;
    }

    export interface GetDirectoriesDirectoryTask {
        /**
         * The ID of Access Configuration.
         */
        accessConfigurationId: string;
        /**
         * The Name of Access Configuration.
         */
        accessConfigurationName: string;
        /**
         * The End Time of Task.
         */
        endTime: string;
        /**
         * the Reason for the Failure of  the task.
         */
        failureReason: string;
        /**
         * The ID of Cloud SSO Identity.
         */
        principalId: string;
        /**
         * The Name of Cloud SSO Identity.
         */
        principalName: string;
        /**
         * The Type of Cloud SSO Identity.
         */
        principalType: string;
        /**
         * The Start Time of Task.
         */
        startTime: string;
        /**
         * The Task Status.
         */
        status: string;
        /**
         * The Id of deploy target.
         */
        targetId: string;
        /**
         * The Name of Deploy Target.
         */
        targetName: string;
        /**
         * The Path in RD of Deploy Target.
         */
        targetPath: string;
        /**
         * The Type of Deploy Target.
         */
        targetType: string;
        /**
         * The ID of the Task.
         */
        taskId: string;
        /**
         * The Type of the Task.
         */
        taskType: string;
    }

    export interface GetGroupsGroup {
        /**
         * The Created Time of the Directory.
         */
        createTime: string;
        /**
         * The Description of the Directory.
         */
        description: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The Group ID of the group.
         */
        groupId: string;
        /**
         * The Name of the group.
         */
        groupName: string;
        /**
         * The ID of the Group.
         */
        id: string;
        /**
         * The Provision Type of the Group. Valid values: `Manual`, `Synchronized`.
         */
        provisionType: string;
    }

    export interface GetScimServerCredentialsCredential {
        /**
         * The CreateTime of the resource.
         */
        createTime: string;
        /**
         * The CredentialId of the resource.
         */
        credentialId: string;
        /**
         * The CredentialSecret of the resource.
         */
        credentialSecret: string;
        /**
         * The CredentialType of the resource.
         */
        credentialType: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The ExpireTime of the resource.
         */
        expireTime: string;
        /**
         * The ID of the SCIM Server Credential.
         */
        id: string;
        /**
         * The Status of the resource. Valid values: `Disabled`, `Enabled`.
         */
        status: string;
    }

    export interface GetUsersUser {
        /**
         * The create time of the user.
         */
        createTime: string;
        /**
         * The description of user.
         */
        description: string;
        /**
         * The ID of the Directory.
         */
        directoryId: string;
        /**
         * The display name of user.
         */
        displayName: string;
        /**
         * The User's Contact Email Address.
         */
        email: string;
        /**
         * The first name of user.
         */
        firstName: string;
        /**
         * The ID of the User.
         */
        id: string;
        /**
         * The last name of user.
         */
        lastName: string;
        /**
         * The List of MFA Device for User.
         */
        mfaDevices: outputs.cloudsso.GetUsersUserMfaDevice[];
        /**
         * ProvisionType.
         */
        provisionType: string;
        /**
         * User status. Valid values: `Enabled` and `Disabled`.
         */
        status: string;
        /**
         * The User ID of the group.
         */
        userId: string;
        /**
         * The name of user.
         */
        userName: string;
    }

    export interface GetUsersUserMfaDevice {
        /**
         * The MFA Device ID.
         */
        deviceId: string;
        /**
         * The MFA Device Name.
         */
        deviceName: string;
        /**
         * The MFA Device Type.
         */
        deviceType: string;
        /**
         * The Effective Time of MFA Device.
         */
        effectiveTime: string;
    }

}

export namespace cloudstoragegateway {
    export interface GetExpressSyncsSync {
        /**
         * The name of the OSS Bucket.
         */
        bucketName: string;
        /**
         * The prefix of the OSS Bucket.
         */
        bucketPrefix: string;
        /**
         * The region of the OSS Bucket.
         */
        bucketRegion: string;
        /**
         * The description of the Express Sync.
         */
        description: string;
        /**
         * The ID of the Express Sync.
         */
        expressSyncId: string;
        /**
         * The name of the Express Sync.
         */
        expressSyncName: string;
        id: string;
        /**
         * The name of the message topic (Topic) corresponding to the Express Sync in the Alibaba Cloud Message Service MNS.
         */
        mnsTopic: string;
    }

    export interface GetGatewayBlockVolumesVolume {
        /**
         * The IP ADDRESS.
         */
        address: string;
        /**
         * The Block volume set mode to cache mode. Valid values: `Cache`, `WriteThrough`.
         */
        cacheMode: string;
        /**
         * Whether to enable iSCSI access of CHAP authentication, which currently supports both CHAP inbound authentication.  Default value: `false`.
         */
        chapEnabled: boolean;
        /**
         * The Inbound CHAP user.**NOTE:** When the `chapEnabled` is  `true` is,The `chapInPassword` is valid.
         */
        chapInUser: string;
        /**
         * The Block volume storage allocation unit.  Valid values: `8192`, `16384`, `32768`, `65536`, `131072`. Default value: `32768`. Unit: `Byte`.
         */
        chunkSize: number;
        /**
         * The cache disk ID.
         */
        diskId: string;
        /**
         * The cache disk type.
         */
        diskType: string;
        /**
         * Whether to enable Volume.
         */
        enabled: boolean;
        /**
         * The Block volume name.  The name must be 1 to 32 characters in length, and can contain lowercase letters, numbers.
         */
        gatewayBlockVolumeName: string;
        /**
         * The Gateway ID.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway Block Volume. The value formats as `<gateway_id>:<index_id>`.
         */
        id: string;
        /**
         * The ID of the index.
         */
        indexId: string;
        /**
         * CThe Cache disk to local path. **NOTE:**  When the `cacheMode` is  `Cache` is,The `chapInPassword` is valid.
         */
        localPath: string;
        /**
         * The Lun identifier.
         */
        lunId: number;
        /**
         * The name of the OSS Bucket.
         */
        ossBucketName: string;
        /**
         * Whether to enable SSL access your OSS Buckets. Default value: `true`.
         */
        ossBucketSsl: boolean;
        /**
         * The endpoint of the OSS Bucket.
         */
        ossEndpoint: string;
        /**
         * The Port.
         */
        port: number;
        /**
         * The Protocol.
         */
        protocol: string;
        /**
         * The Volume size.
         */
        size: number;
        /**
         * The Buffer status.
         */
        state: string;
        /**
         * The status of volume.
         */
        status: number;
        /**
         * The target.
         */
        target: string;
        /**
         * The total amount of downloaded data. Unit: `B`.
         */
        totalDownload: number;
        /**
         * The total amount of uploaded data. Unit: `B`.
         */
        totalUpload: number;
        volumeState: number;
    }

    export interface GetGatewayCacheDisksDisk {
        /**
         * The category of eht cache disk.
         */
        cacheDiskCategory: string;
        /**
         * The size of the cache disk.
         */
        cacheDiskSizeInGb: number;
        /**
         * The ID of the cache disk.
         */
        cacheId: string;
        /**
         * The expiration time. Time stamp in seconds (s).
         */
        expiredTime: number;
        /**
         * The ID of the gateway.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway Cache Disk.
         */
        id: string;
        /**
         * Per second of the input output.
         */
        iops: number;
        /**
         * Whether it is used.
         */
        isUsed: boolean;
        /**
         * The cache disk inside the device name.
         */
        localFilePath: string;
        /**
         * A renewal link of the cache disk.
         */
        renewUrl: string;
        /**
         * The status of the resource.
         */
        status: number;
    }

    export interface GetGatewayFileSharesShare {
        /**
         * The set up gateway file share Server Message Block (SMB) protocol, whether to enable Windows ABE, the prime minister, need windowsAcl parameter is set to true in the entry into force of. Default value: `false`. **NOTE:** Gateway version >= 1.0.45 above support.
         */
        accessBasedEnumeration: boolean;
        /**
         * Share the private IP address of the RDS instance.
         */
        address: string;
        /**
         * The set up gateway file share Max upload speed. Unit: `MB/s`, `0` means unlimited. Value range: `0` ~ `1280`. Default value: `0`. **NOTE:** at the same time if you have to limit the maximum write speed, maximum upload speed is no less than the maximum write speed.
         */
        backendLimit: number;
        /**
         * The set up gateway file share Server Message Block (SMB) protocol whether browsable (that is, in the network neighborhood of whether you can find). The parameters in the NFS protocol not valid under. Default value: `true`.
         */
        browsable: boolean;
        /**
         * Multi-Bucket information.
         */
        bucketInfos: string;
        /**
         * Whether there are multiple buckets.
         */
        bucketsStub: boolean;
        /**
         * Direct reading OSS of the gateway file share.
         */
        bypassCacheRead: boolean;
        /**
         * The cache mode of the gateway file share. Value range: Cache: cached mode. Sync: replication mode are available.
         */
        cacheMode: string;
        /**
         * File share is enabled to client-side encryption, the encryption by the use of the KMS key. **NOTE:** note: This KMS key must be the gateway and is in the same Region.
         */
        clientSideCmk: string;
        /**
         * Whether to enabled to client-side encryption of the gateway file share. Default value: `false`. **NOTE:** need to contact us open whitelist before you can the settings, and only supports enhanced more than online gateway, at the same time, server-side encryption and to client-side encryption can not simultaneously configuration.
         */
        clientSideEncryption: boolean;
        /**
         * Whether directio (direct I/O data transfer) is enabled for file share. Default: `false`.
         */
        directIo: boolean;
        /**
         * The ID of the disk.
         */
        diskId: string;
        /**
         * The cache disk type. Valid values: `cloudEfficiency`: Ultra cloud disk. `cloudSsd`:SSD cloud disk.
         */
        diskType: string;
        /**
         * The set up gateway file share maximum download speed. Unit: `MB/s`. `0` means unlimited. Value range: `0` ~ `1280`. **NOTE:** only in copy mode and enable download file data can be set. only when the shared opens the reverse synchronization or acceded to by the speed synchronization Group when, this parameter will not take effect. Gateway version >= 1.3.0 above support.
         */
        downloadLimit: number;
        /**
         * Shared whether the changes take effect.
         */
        enabled: boolean;
        /**
         * Speed synchronization group ID.
         */
        expressSyncId: string;
        /**
         * The set up gateway file share whether to enable Upload optimization, which is suitable for data pure backup migration scenarios. Default value: `false`. **NOTE:** Gateway version >= 1.0.39 above support.
         */
        fastReclaim: boolean;
        /**
         * The set up gateway file share and the maximum write speed. Unit: `MB/s`, `0` means unlimited. Value range: `0` ~ `1280`. Default value: `0`.
         */
        feLimit: number;
        /**
         * Supported by the file system file number.
         */
        fileNumLimit: string;
        /**
         * File system capacity. Unit: `B`.
         */
        fsSizeLimit: string;
        /**
         * The name of the file share. Length from `1` to `255` characters can contain lowercase letters, digits, (.), (_) Or (-), at the same time, must start with a lowercase letter.
         */
        gatewayFileShareName: string;
        /**
         * The ID of the gateway.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway File Share.
         */
        id: string;
        /**
         * Whether to ignore deleted of the gateway file share. After the opening of the Gateway side delete file or delete cloud (OSS) corresponding to the file. Default value: `false`. **NOTE:** Gateway version >= 1.0.40 above support.
         */
        ignoreDelete: boolean;
        /**
         * Whether debris optimization of the gateway file share. Default value: `false`.
         */
        inPlace: boolean;
        /**
         * Cache growth. Unit: `B/s`.
         */
        inRate: string;
        /**
         * The ID of the file share.
         */
        indexId: string;
        /**
         * File share is enabled to client-side encryption, key rotation period of time. Seconds. 0 represents no rotation. Rotation of the value range: `3600` ~ `86400`. Default value: `0`.
         */
        kmsRotatePeriod: number;
        /**
         * The synchronization delay, I.e. gateway local cache sync to Alibaba Cloud Object Storage Service (oss) of the delay time. Unit: `Seconds`. Value range: `5` ~ `120`. Default value: `5`. **NOTE:** Gateway version >= 1.0.40 above support.
         */
        lagPeriod: string;
        /**
         * The cache disk inside the device name.
         */
        localPath: string;
        /**
         * The messages from the queue health types. Valid values: `TopicAndQueueFailure`: A Message Queuing message theme can be accessed during the black hole period. `TopicFailure`: a message theme can be accessed during the black hole period. `MNSFullSyncInit`: full synchronization wait. `MNSFullSyncing`: full synchronization in progress. `QueueFailure`: a message queue can be accessed during the black hole period. `MNSNotEnabled`: Top speed synchronization is not enabled. `MNSHealthy`: sync fine.
         */
        mnsHealth: string;
        /**
         * The set up gateway file share NFS protocol, whether to enable NFS v4 optimization improve Mount Upload efficiency. Default value: `false`. **NOTE:** turns on after I will not support NFS v3 mount the filesystem on a. Gateway version >= 1.2.0 above support.
         */
        nfsV4Optimization: boolean;
        /**
         * Multi-Bucket, removing the Bucket.
         */
        obsoleteBuckets: string;
        /**
         * The name of the Bucket.
         */
        ossBucketName: string;
        /**
         * Whether they are using SSL connect to OSS Bucket.
         */
        ossBucketSsl: boolean;
        /**
         * The set up gateway file share corresponds to the Object Storage SERVICE (OSS), Bucket Endpoint. **NOTE:** distinguish between intranet and internet Endpoint. We recommend that if the OSS Bucket and the gateway is in the same Region is use the RDS intranet IP Endpoint:oss-cn-hangzhou-internal.aliyuncs.com.
         */
        ossEndpoint: string;
        /**
         * The OSS Bucket of type. Valid values: `BucketHealthy`: OSS connectivity. `BucketAccessDenied`: OBJECT STORAGE Service (OSS) access to an exception. `BucketMiscFailure`: OBJECT STORAGE Service (OSS) access to additional exception. `BucketNetworkFailure`: OBJECT STORAGE Service (OSS) access network an exception. `BucketNotExist`: OSS Bucket does not exist. `Nothing returns`: We may not have ever known existed.
         */
        ossHealth: string;
        /**
         * For a cloud-based data is. Unit: `B`.
         */
        ossUsed: string;
        /**
         * Upload speed. Unit: `B/s`.
         */
        outRate: string;
        /**
         * In part mode, the directory path group JSON format.
         */
        partialSyncPaths: string;
        /**
         * The prefix of the OSS.
         */
        pathPrefix: string;
        /**
         * The reverse synchronization time intervals of the gateway file share. Value range: `15` ~ `36000`. **NOTE:** in copy mode + reverse synchronization is enabled Download file data, value range: `3600` ~ `36000`.
         */
        pollingInterval: number;
        /**
         * Share types. Valid values: `SMB`, `NFS`.
         */
        protocol: string;
        /**
         * You can use the metadata space. Unit: `B`.
         */
        remainingMetaSpace: string;
        /**
         * Whether to enable reverse synchronization of the gateway file share. Default value: `false`.
         */
        remoteSync: boolean;
        /**
         * Copy mode, whether to download the file data. Default value: `false`. **NOTE:** only when the shared opens the reverse synchronization or acceded to by the speed synchronization group, this parameter will not take effect.
         */
        remoteSyncDownload: boolean;
        /**
         * The read-only client list. When Protocol NFS is returned when the status is.
         */
        roClientList: string;
        /**
         * The read-only client list. When Protocol for Server Message Block (SMB) to go back to.
         */
        roUserList: string;
        /**
         * Read and write the client list. When Protocol NFS is returned when the status is.
         */
        rwClientList: string;
        /**
         * Read-write user list. When Protocol for Server Message Block (SMB) to go back to.
         */
        rwUserList: string;
        /**
         * File share is enabled server-side encryption, encryption used by the KMS key.
         */
        serverSideCmk: string;
        /**
         * If the OSS Bucket side encryption.
         */
        serverSideEncryption: boolean;
        /**
         * The caching capacity. Unit: `B`.
         */
        size: string;
        /**
         * The set up gateway file share NFS protocol user mapping. Valid values: `none`, `rootSquash`, `allSquash`, `allAnonymous`. Default value: `none`.
         */
        squash: string;
        /**
         * File synchronization types. Valid values: `clean`, `dirty`. `clean`: synchronization is complete. `dirty`: synchronization has not been completed.
         */
        state: string;
        /**
         * Whether to support the archive transparent read.
         */
        supportArchive: boolean;
        /**
         * Full synchronization progress. When the share has been added for a synchronization group, the return parameters are valid, that shared full synchronization progress (0~100). `-2`: indicates that share the Gateway version does not support this feature. `-1`: the share does not occur full synchronization.
         */
        syncProgress: number;
        /**
         * The OSS Bucket to the Gateway total downloads. Unit: `B`.
         */
        totalDownload: string;
        /**
         * The OSS Bucket to the Gateway total Upload amount. Unit: `B`.
         */
        totalUpload: string;
        /**
         * The set up gateway file share whether to enable transmission acceleration needs corresponding OSS Bucket enabled transport acceleration. **NOTE:** Gateway version >= 1.3.0 above support.
         */
        transferAcceleration: boolean;
        /**
         * Used cache. Unit: `B`.
         */
        used: string;
        /**
         * The set up gateway file share Server Message Block (SMB) protocol, whether to enable by Windows access list (requires AD domain) the permissions control. Default value: `false`. **NOTE:** Gateway version >= 1.0.45 above support.
         */
        windowsAcl: boolean;
    }

    export interface GetGatewaySmbUsersUser {
        /**
         * The Gateway ID.
         */
        gatewayId: string;
        /**
         * The ID of the Gateway SMB User.
         */
        id: string;
        /**
         * The username of the Gateway SMB User.
         */
        username: string;
    }

    export interface GetGatewaysGateway {
        /**
         * gateway .
         */
        activatedTime: string;
        buyUrl: string;
        /**
         * gateway category.
         */
        category: string;
        /**
         * gateway created timestamp in second format.
         */
        createTime: string;
        /**
         * gateway description.
         */
        description: string;
        /**
         * gateway ecs instance id.
         */
        ecsInstanceId: string;
        /**
         * gateway expiration status.
         */
        expireStatus: number;
        /**
         * gateway expiration timestamp in second format.
         */
        expiredTime: string;
        /**
         * gateway class.
         */
        gatewayClass: string;
        /**
         * gateway id.
         */
        gatewayId: string;
        /**
         * gateway name.
         */
        gatewayName: string;
        /**
         * gateway version.
         */
        gatewayVersion: string;
        /**
         * The ID of the Gateway.
         */
        id: string;
        /**
         * gateway service ip.
         */
        innerIp: string;
        /**
         * gateway public ip.
         */
        ip: string;
        /**
         * whether subscription gateway is released after expiration or not.
         */
        isReleaseAfterExpiration: boolean;
        /**
         * gateway location.
         */
        location: string;
        /**
         * gateway payment type. The Payment type of gateway. The valid value: `PayAsYouGo`, `Subscription`.
         */
        paymentType: string;
        /**
         * gateway public network bandwidth.
         */
        publicNetworkBandwidth: number;
        renewUrl: string;
        /**
         * gateway status.
         */
        status: string;
        /**
         * storage bundle id.
         */
        storageBundleId: string;
        /**
         * gateway task id.
         */
        taskId: string;
        /**
         * gateway type.
         */
        type: string;
        /**
         * gateway vpc id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetStocksStock {
        /**
         * A list of available gateway class in this Zone ID.
         */
        availableGatewayClasses: string[];
        /**
         * The Zone ID.
         */
        zoneId: string;
    }

    export interface GetStorageBundlesBundle {
        createTime: string;
        description: string;
        id: string;
        location: string;
        storageBundleId: string;
        storageBundleName: string;
    }

}

export namespace cms {
    export interface AlarmEscalationsCritical {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * It has been deprecated from provider version 1.94.0 and 'escalations_critical.statistics' instead.
         */
        statistics?: string;
        /**
         * It has been deprecated from provider version 1.94.0 and 'escalations_critical.threshold' instead.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmEscalationsInfo {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * It has been deprecated from provider version 1.94.0 and 'escalations_critical.statistics' instead.
         */
        statistics?: string;
        /**
         * It has been deprecated from provider version 1.94.0 and 'escalations_critical.threshold' instead.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmEscalationsWarn {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * It has been deprecated from provider version 1.94.0 and 'escalations_critical.statistics' instead.
         */
        statistics?: string;
        /**
         * It has been deprecated from provider version 1.94.0 and 'escalations_critical.threshold' instead.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmPrometheus {
        /**
         * The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
         */
        annotations?: {[key: string]: any};
        /**
         * The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
         */
        level?: string;
        /**
         * The PromQL query statement. **Note:** The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
         */
        promQl?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface DynamicTagGroupMatchExpress {
        /**
         * The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
         */
        tagValue: string;
        /**
         * Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
         */
        tagValueMatchFunction: string;
    }

    export interface EventRuleEventPattern {
        /**
         * The type of the event-triggered alert rule. Valid values:
         */
        eventTypeLists?: string[];
        /**
         * The level of the event-triggered alert rule. Valid values:
         */
        levelLists?: string[];
        /**
         * The name of the event-triggered alert rule.
         */
        nameLists?: string[];
        /**
         * The type of the cloud service.
         */
        product: string;
        /**
         * The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
         */
        sqlFilter?: string;
    }

    export interface GetAlarmContactGroupsGroup {
        /**
         * The name of Alarm Contact Group.
         */
        alarmContactGroupName: string;
        /**
         * The alarm contacts in the alarm group.
         */
        contacts: string[];
        /**
         * The description of the Alarm Group.
         */
        describe: string;
        /**
         * Indicates whether the alarm group subscribes to weekly reports.
         */
        enableSubscribed: boolean;
        /**
         * The ID of the CMS.
         */
        id: string;
    }

    export interface GetAlarmContactsContact {
        /**
         * The name of the alarm contact.
         */
        alarmContactName: string;
        /**
         * The TradeManager ID of the alarm contact.
         */
        channelsAliim: string;
        /**
         * The webhook URL of the DingTalk chatbot.
         */
        channelsDingWebHook: string;
        /**
         * The email address of the alarm contact.
         */
        channelsMail: string;
        /**
         * The phone number of the alarm contact.
         */
        channelsSms: string;
        /**
         * Indicates whether the TradeManager ID is valid.
         */
        channelsStateAliim: string;
        /**
         * Indicates whether the DingTalk chatbot is normal.
         */
        channelsStateDingWebHook: string;
        /**
         * The status of the email address.
         */
        channelsStateMail: string;
        /**
         * The status of the phone number.
         */
        channelsStatusSms: string;
        /**
         * The alert groups to which the alarm contact is added.
         */
        contactGroups: string[];
        /**
         * The description of the alarm contact.
         */
        describe: string;
        /**
         * The ID of the alarm contact.
         */
        id: string;
        lang: string;
    }

    export interface GetDynamicTagGroupsGroup {
        /**
         * The ID of the tag rule.
         */
        dynamicTagRuleId: string;
        /**
         * The ID of the Dynamic Tag Group.
         */
        id: string;
        /**
         * The relationship between conditional expressions. Valid values: `and`, `or`.
         */
        matchExpressFilterRelation: string;
        /**
         * The label generates a matching expression that applies the grouping. See the following `Block matchExpress`.
         */
        matchExpresses: outputs.cms.GetDynamicTagGroupsGroupMatchExpress[];
        /**
         * The status of the resource. Valid values: `RUNNING`, `FINISH`.
         */
        status: string;
        /**
         * The tag key of the tag.
         */
        tagKey: string;
    }

    export interface GetDynamicTagGroupsGroupMatchExpress {
        /**
         * The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
         */
        tagValue: string;
        /**
         * Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
         */
        tagValueMatchFunction: string;
    }

    export interface GetEventRulesRule {
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Event mode, used to describe the trigger conditions for this event.
         */
        eventPatterns: outputs.cms.GetEventRulesRuleEventPattern[];
        /**
         * The name of the event rule.
         */
        eventRuleName: string;
        /**
         * The type of event.
         */
        eventType: string;
        /**
         * The ID of the application Group.
         */
        groupId: string;
        /**
         * The ID of the Event Rule. Its value is same as Event Rule Name.
         */
        id: string;
        /**
         * The mute period during which new alerts are not sent even if the trigger conditions are met.
         */
        silenceTime: number;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetEventRulesRuleEventPattern {
        /**
         * The list of event types.
         */
        eventTypeLists: string[];
        /**
         * The filter keyword.
         */
        keywordFilters: outputs.cms.GetEventRulesRuleEventPatternKeywordFilter[];
        /**
         * The list of event levels.
         */
        levelLists: string[];
        /**
         * The list of event names.
         */
        nameLists: string[];
        /**
         * The type of the cloud service.
         */
        product: string;
        /**
         * The SQL condition that is used to filter events.
         */
        sqlFilter: string;
    }

    export interface GetEventRulesRuleEventPatternKeywordFilter {
        /**
         * The keywords that are used to match events.
         */
        keyWords: string[];
        /**
         * The relationship between multiple keywords in a condition.
         */
        relation: string;
    }

    export interface GetGroupMetricRulesRule {
        /**
         * Alarm contact group.
         */
        contactGroups: string;
        /**
         * The dimensions that specify the resources to be associated with the alert rule.
         */
        dimensions: string;
        /**
         * The time period during which the alert rule is effective.
         */
        effectiveInterval: string;
        /**
         * The subject of the alert notification email.
         */
        emailSubject: string;
        /**
         * Indicates whether the alert rule is enabled.
         */
        enableState: boolean;
        /**
         * Alarm level.
         */
        escalations: outputs.cms.GetGroupMetricRulesRuleEscalation[];
        /**
         * The ID of the application group.
         */
        groupId: string;
        /**
         * The name of the alert rule.
         */
        groupMetricRuleName: string;
        /**
         * The ID of the Group Metric Rule.
         */
        id: string;
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the service.
         */
        namespace: string;
        /**
         * The time period during which the alert rule is ineffective.
         */
        noEffectiveInterval: string;
        /**
         * The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
         */
        period: number;
        /**
         * The resources that are associated with the alert rule.
         */
        resources: string;
        /**
         * The ID of the alert rule.
         */
        ruleId: string;
        /**
         * The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
         */
        silenceTime: number;
        /**
         * The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
         */
        sourceType: string;
        /**
         * The status of Group Metric Rule..
         */
        status: string;
        /**
         * The callback URL.
         */
        webhook: string;
    }

    export interface GetGroupMetricRulesRuleEscalation {
        /**
         * The critical level.
         */
        criticals: outputs.cms.GetGroupMetricRulesRuleEscalationCritical[];
        /**
         * The info level.
         */
        infos: outputs.cms.GetGroupMetricRulesRuleEscalationInfo[];
        /**
         * The warn level.
         */
        warns: outputs.cms.GetGroupMetricRulesRuleEscalationWarn[];
    }

    export interface GetGroupMetricRulesRuleEscalationCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetGroupMetricRulesRuleEscalationInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetGroupMetricRulesRuleEscalationWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetHybridMonitorDatasData {
        /**
         * The label of the time dimension.
         */
        labels: outputs.cms.GetHybridMonitorDatasDataLabel[];
        /**
         * The name of the monitoring indicator.
         */
        metricName: string;
        /**
         * The metric values that are collected at different timestamps.
         */
        values: outputs.cms.GetHybridMonitorDatasDataValue[];
    }

    export interface GetHybridMonitorDatasDataLabel {
        /**
         * Label key.
         */
        key: string;
        /**
         * Label value.
         */
        value: string;
    }

    export interface GetHybridMonitorDatasDataValue {
        /**
         * The timestamp that indicates the time when the metric value is collected. Unit: seconds.
         */
        ts: string;
        /**
         * Label value.
         */
        value: string;
    }

    export interface GetHybridMonitorFcTasksTask {
        /**
         * Create the timestamp of the monitoring task. Unit: milliseconds.
         */
        createTime: string;
        /**
         * The ID of the monitoring task.
         */
        hybridMonitorFcTaskId: string;
        /**
         * The ID of the Hybrid Monitor Fc Task. The value formats as `<hybrid_monitor_fc_task_id>:<namespace>`.
         */
        id: string;
        /**
         * The index warehouse where the host belongs.
         */
        namespace: string;
        /**
         * The ID of the member account.
         */
        targetUserId: string;
        /**
         * The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
         */
        yarmConfig: string;
    }

    export interface GetHybridMonitorSlsTasksTask {
        /**
         * The tags of the metric import task.
         */
        attachLabels: outputs.cms.GetHybridMonitorSlsTasksTaskAttachLabel[];
        /**
         * The interval between the cloud monitoring plug-in collecting host monitoring data.
         */
        collectInterval: number;
        /**
         * The address where the cloudmonitor Plug-In collects the monitoring data of the host.
         */
        collectTargetEndpoint: string;
        /**
         * When the cloud monitor Agent collects, the relative path of the collection.
         */
        collectTargetPath: string;
        /**
         * The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, MySQL, and AWS.
         */
        collectTargetType: string;
        /**
         * The timeout period for the cloudmonitor plug-in to collect host monitoring data.
         */
        collectTimout: number;
        /**
         * Create the timestamp of the monitoring task. Unit: milliseconds.
         */
        createTime: string;
        /**
         * Monitoring task description.
         */
        description: string;
        /**
         * Additional information for the instance.
         */
        extraInfo: string;
        /**
         * The ID of the application Group.
         */
        groupId: string;
        /**
         * The ID of the monitoring task.
         */
        hybridMonitorSlsTaskId: string;
        /**
         * The ID of the Hybrid Monitor Sls Task.
         */
        id: string;
        /**
         * A list of instances where monitoring data is collected in batches.
         */
        instances: string[];
        /**
         * The path where on-premises log data is stored. On-premises log data is stored in the specified path of the host where CloudMonitor is deployed.
         */
        logFilePath: string;
        /**
         * Local Log Monitoring and calculation method.
         */
        logProcess: string;
        /**
         * The sample on-premises log.
         */
        logSample: string;
        /**
         * The local log data is divided according to different matching patterns.
         */
        logSplit: string;
        /**
         * The filter condition of the instance of the monitoring task.
         */
        matchExpressRelation: string;
        /**
         * The matching condition of the instance in the application Group.
         */
        matchExpresses: outputs.cms.GetHybridMonitorSlsTasksTaskMatchExpress[];
        /**
         * The namespace to which the host belongs.
         */
        namespace: string;
        /**
         * The network type of the host.
         */
        networkType: string;
        /**
         * The configurations of the logs that are imported from Log Service.
         */
        slsProcess: string;
        /**
         * The configurations of the logs that are imported from Log Service.
         */
        slsProcessConfigs: outputs.cms.GetHybridMonitorSlsTasksTaskSlsProcessConfig[];
        /**
         * The name of the metric import task.
         */
        taskName: string;
        /**
         * Monitoring Task type.
         */
        taskType: string;
        /**
         * The region where the host resides.
         */
        uploadRegion: string;
        yarmConfig: string;
    }

    export interface GetHybridMonitorSlsTasksTaskAttachLabel {
        /**
         * The name of the instance.
         */
        name: string;
        /**
         * The value of the key that is used to filter logs imported from Log Service.
         */
        value: string;
    }

    export interface GetHybridMonitorSlsTasksTaskMatchExpress {
        /**
         * The function that is used to aggregate log data within a statistical period.
         */
        function: string;
        /**
         * The name of the instance.
         */
        name: string;
        /**
         * The value of the key that is used to filter logs imported from Log Service.
         */
        value: string;
    }

    export interface GetHybridMonitorSlsTasksTaskSlsProcessConfig {
        /**
         * The extended field that specifies the result of basic operations that are performed on aggregation results.
         */
        expresses: outputs.cms.GetHybridMonitorSlsTasksTaskSlsProcessConfigExpress[];
        /**
         * The conditions that are used to filter logs imported from Log Service.
         */
        filters: outputs.cms.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilter[];
        /**
         * The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
         */
        groupBies: outputs.cms.GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupBy[];
        /**
         * The method that is used to aggregate logs imported from Log Service.
         */
        statistics: outputs.cms.GetHybridMonitorSlsTasksTaskSlsProcessConfigStatistic[];
    }

    export interface GetHybridMonitorSlsTasksTaskSlsProcessConfigExpress {
        /**
         * The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
         */
        alias: string;
        /**
         * The extended field that specifies the result of basic operations that are performed on aggregation results.
         */
        express: string;
    }

    export interface GetHybridMonitorSlsTasksTaskSlsProcessConfigFilter {
        /**
         * The conditions that are used to filter logs imported from Log Service.
         */
        filters: outputs.cms.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilter[];
        /**
         * The relationship between multiple filter conditions.
         */
        relation: string;
    }

    export interface GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilter {
        /**
         * The method that is used to filter logs imported from Log Service.
         */
        operator: string;
        /**
         * The name of the key that is used to filter logs imported from Log Service.
         */
        slsKeyName: string;
        /**
         * The value of the key that is used to filter logs imported from Log Service.
         */
        value: string;
    }

    export interface GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupBy {
        /**
         * The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
         */
        alias: string;
        /**
         * The name of the key that is used to filter logs imported from Log Service.
         */
        slsKeyName: string;
    }

    export interface GetHybridMonitorSlsTasksTaskSlsProcessConfigStatistic {
        /**
         * The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
         */
        alias: string;
        /**
         * The function that is used to aggregate log data within a statistical period.
         */
        function: string;
        /**
         * The value of the function that is used to aggregate logs imported from Log Service.
         */
        parameterOne: string;
        /**
         * The value of the function that is used to aggregate logs imported from Log Service.
         */
        parameterTwo: string;
        /**
         * The name of the key that is used to filter logs imported from Log Service.
         */
        slsKeyName: string;
    }

    export interface GetMetricRuleBlackListsList {
        /**
         * Cloud service classification. For example, Redis includes kvstore_standard, kvstore_sharding, and kvstore_splitrw.
         */
        category: string;
        /**
         * The timestamp for creating an alert blacklist policy.Unit: milliseconds.
         */
        createTime: string;
        /**
         * The effective time range of the alert blacklist policy.
         */
        effectiveTime: string;
        /**
         * The start timestamp of the alert blacklist policy.Unit: milliseconds.
         */
        enableEndTime: string;
        /**
         * The end timestamp of the alert blacklist policy.Unit: milliseconds.
         */
        enableStartTime: string;
        id: string;
        /**
         * The list of instances of cloud services specified in the alert blacklist policy.
         */
        instances: string[];
        /**
         * The status of the alert blacklist policy. Value:-true: enabled.-false: disabled.
         */
        isEnable: boolean;
        /**
         * The first ID of the resource
         */
        metricRuleBlackListId: string;
        /**
         * The name of the alert blacklist policy.
         */
        metricRuleBlackListName: string;
        /**
         * Monitoring metrics in the instance.
         */
        metrics: outputs.cms.GetMetricRuleBlackListsListMetric[];
        /**
         * The data namespace of the cloud service.
         */
        namespace: string;
        /**
         * The effective range of the alert blacklist policy. Value:-USER: The alert blacklist policy only takes effect in the current Alibaba cloud account.-GROUP: The alert blacklist policy takes effect in the specified application GROUP.
         */
        scopeType: string;
        /**
         * Application Group ID list. The format is JSON Array.> This parameter is displayed only when 'ScopeType' is 'GROUP.
         */
        scopeValues: string[];
    }

    export interface GetMetricRuleBlackListsListMetric {
        /**
         * The name of the monitoring indicator.
         */
        metricName: string;
        /**
         * The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
         */
        resource: string;
    }

    export interface GetMetricRuleTemplatesTemplate {
        /**
         * The details of alert rules that are generated based on the alert template.
         */
        alertTemplates: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplate[];
        /**
         * The description of the alert template.
         */
        description: string;
        /**
         * GroupId.
         */
        groupId: string;
        /**
         * The ID of the Metric Rule Template.
         */
        id: string;
        /**
         * The name of the alert template.
         */
        metricRuleTemplateName: string;
        /**
         * The version of the alert template.
         *
         * > **NOTE:** The version changes with the number of times that the alert template is modified.
         */
        restVersion: string;
        /**
         * The ID of the alert template.
         */
        templateId: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplate {
        /**
         * The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iotEdge`, `kvstoreSharding`, `kvstoreSplitrw`, `kvstoreStandard`, `memcache`, `mns`, `mongodb`, `mongodbCluster`, `mongodbSharding`, `mqTopic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
         */
        category: string;
        /**
         * The information about the trigger condition based on the alert level.
         */
        escalations: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalation[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the service.
         */
        namespace: string;
        /**
         * The name of the alert rule.
         */
        ruleName: string;
        selector: string;
        /**
         * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
         */
        webhook: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalation {
        /**
         * The condition for triggering critical-level alerts.
         */
        criticals: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCritical[];
        /**
         * The condition for triggering info-level alerts.
         */
        infos: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfo[];
        /**
         * The condition for triggering warn-level alerts.
         */
        warns: outputs.cms.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarn[];
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalationCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level
         * alert is triggered.
         */
        times: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level
         * alert is triggered.
         */
        times: string;
    }

    export interface GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level
         * alert is triggered.
         */
        times: string;
    }

    export interface GetMonitorGroupInstancesInstance {
        instances: outputs.cms.GetMonitorGroupInstancesInstanceInstance[];
    }

    export interface GetMonitorGroupInstancesInstanceInstance {
        category: string;
        instanceId: string;
        instanceName: string;
        regionId: string;
    }

    export interface GetMonitorGroupsGroup {
        /**
         * The URL of the Kubernetes cluster from which the application group is synchronized.
         */
        bindUrl: string;
        /**
         * The list of  alert groups that receive alert notifications for the application group.
         */
        contactGroups: string[];
        /**
         * The ID of the tag rule.
         */
        dynamicTagRuleId: string;
        /**
         * The time when the application group was created.
         */
        gmtCreate: number;
        /**
         * The time when the application group was modified.
         */
        gmtModified: number;
        /**
         * The ID of the application group.
         */
        groupId: string;
        /**
         * The ID of the Monitor Group.
         */
        id: string;
        /**
         * The name of the application group.
         */
        monitorGroupName: string;
        /**
         * The ID of the Alibaba Cloud service.
         */
        serviceId: string;
        /**
         * A map of tags assigned to the Cms Monitor Group.
         */
        tags: {[key: string]: any};
        /**
         * The alert templates applied to the application group.
         */
        templateIds: string[];
        /**
         * The type of the application group.
         */
        type: string;
    }

    export interface GetNamespacesNamespace {
        /**
         * Create the timestamp of the indicator warehouse.
         */
        createTime: string;
        /**
         * Description of indicator warehouse.
         */
        description: string;
        /**
         * The ID of the Namespace.
         */
        id: string;
        /**
         * The timestamp of the last modification indicator warehouse.
         */
        modifyTime: string;
        /**
         * Indicator warehouse name.
         */
        namespace: string;
        /**
         * The ID of the Namespace.
         */
        namespaceId: string;
        /**
         * Data storage duration.
         */
        specification: string;
    }

    export interface GetSlsGroupsGroup {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Sls Group. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The Config of the Sls Group.
         */
        slsGroupConfigs: outputs.cms.GetSlsGroupsGroupSlsGroupConfig[];
        /**
         * The Description of the Sls Group.
         */
        slsGroupDescription: string;
        /**
         * The name of the resource.
         */
        slsGroupName: string;
    }

    export interface GetSlsGroupsGroupSlsGroupConfig {
        /**
         * The name of the Log Store.
         */
        slsLogstore: string;
        /**
         * The name of the Project.
         */
        slsProject: string;
        /**
         * The Sls Region.
         */
        slsRegion: string;
        /**
         * The ID of the Sls User.
         */
        slsUserId: string;
    }

    export interface GroupMetricRuleEscalations {
        /**
         * The critical level.
         */
        critical?: outputs.cms.GroupMetricRuleEscalationsCritical;
        /**
         * The info level.
         */
        info?: outputs.cms.GroupMetricRuleEscalationsInfo;
        /**
         * The warn level.
         */
        warn?: outputs.cms.GroupMetricRuleEscalationsWarn;
    }

    export interface GroupMetricRuleEscalationsCritical {
        /**
         * The comparison operator of the threshold for critical-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for critical-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for critical-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleEscalationsInfo {
        /**
         * The comparison operator of the threshold for critical-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for critical-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for critical-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleEscalationsWarn {
        /**
         * The comparison operator of the threshold for critical-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for critical-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for critical-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleTarget {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the resource.
         */
        arn?: string;
        /**
         * The ID of the resource for which alerts are triggered.
         */
        id?: string;
        /**
         * The parameters of the alert callback. The parameters are in the JSON format.
         *
         * > **NOTE:** Currently, the Alibaba Cloud Resource Name (ARN) of the resource. To use, please [submit an application](https://www.alibabacloud.com/help/en/cloudmonitor/latest/describemetricruletargets).
         */
        jsonParams?: string;
        /**
         * The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
         */
        level?: string;
    }

    export interface HybridMonitorSlsTaskAttachLabel {
        /**
         * The tag key of the metric.
         */
        name?: string;
        /**
         * The value of the key that is used to filter logs imported from Log Service.
         */
        value?: string;
    }

    export interface HybridMonitorSlsTaskSlsProcessConfig {
        /**
         * The extended fields that specify the results of basic operations that are performed on aggregation results. See the following `Block express`.
         */
        expresses?: outputs.cms.HybridMonitorSlsTaskSlsProcessConfigExpress[];
        /**
         * The conditions that are used to filter logs imported from Log Service. See the following `Block filter`.
         */
        filter?: outputs.cms.HybridMonitorSlsTaskSlsProcessConfigFilter;
        /**
         * The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. See the following `Block groupBy`.
         */
        groupBies?: outputs.cms.HybridMonitorSlsTaskSlsProcessConfigGroupBy[];
        /**
         * The method that is used to aggregate logs imported from Log Service. See the following `Block statistics`.
         */
        statistics?: outputs.cms.HybridMonitorSlsTaskSlsProcessConfigStatistic[];
    }

    export interface HybridMonitorSlsTaskSlsProcessConfigExpress {
        /**
         * The alias of the aggregation result.
         */
        alias?: string;
        /**
         * The extended fields that specify the results of basic operations that are performed on aggregation results. See the following `Block express`.
         */
        express?: string;
    }

    export interface HybridMonitorSlsTaskSlsProcessConfigFilter {
        /**
         * The conditions that are used to filter logs imported from Log Service. See the following `Block filters`.
         */
        filters?: outputs.cms.HybridMonitorSlsTaskSlsProcessConfigFilterFilter[];
        /**
         * The relationship between multiple filter conditions. Valid values: `and`(default value), `or`.
         */
        relation?: string;
    }

    export interface HybridMonitorSlsTaskSlsProcessConfigFilterFilter {
        /**
         * The method that is used to filter logs imported from Log Service. Valid values: `>`, `>=`, `=`, `<=`, `<`, `!=`, `contain`, `notContain`.
         */
        operator?: string;
        /**
         * The name of the key that is used to aggregate logs imported from Log Service.
         */
        slsKeyName?: string;
        /**
         * The value of the key that is used to filter logs imported from Log Service.
         */
        value?: string;
    }

    export interface HybridMonitorSlsTaskSlsProcessConfigGroupBy {
        /**
         * The alias of the aggregation result.
         */
        alias?: string;
        /**
         * The name of the key that is used to aggregate logs imported from Log Service.
         */
        slsKeyName?: string;
    }

    export interface HybridMonitorSlsTaskSlsProcessConfigStatistic {
        /**
         * The alias of the aggregation result.
         */
        alias?: string;
        /**
         * The function that is used to aggregate log data within a statistical period. Valid values: `count`, `sum`, `avg`, `max`, `min`, `value`, `countps`, `sumps`, `distinct`, `distribution`, `percentile`.
         */
        function?: string;
        /**
         * The value of the function that is used to aggregate logs imported from Log Service.
         * - If you set the `function` parameter to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
         * - If you set the `function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
         */
        parameterOne?: string;
        /**
         * The value of the function that is used to aggregate logs imported from Log Service. **Note:** This parameter is required only if the `function` parameter is set to `distribution`. This parameter specifies the upper limit of the statistical interval.
         */
        parameterTwo?: string;
        /**
         * The name of the key that is used to aggregate logs imported from Log Service.
         */
        slsKeyName?: string;
    }

    export interface MetricRuleBlackListMetric {
        /**
         * The name of the monitoring indicator.
         */
        metricName: string;
        /**
         * The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
         */
        resource?: string;
    }

    export interface MetricRuleTemplateAlertTemplate {
        /**
         * The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iotEdge`, `kvstoreSharding`, `kvstoreSplitrw`, `kvstoreStandard`, `memcache`, `mns`, `mongodb`, `mongodbCluster`, `mongodbSharding`, `mqTopic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
         */
        category: string;
        /**
         * The information about the trigger condition based on the alert level. See the following `Block escalations`.
         */
        escalations?: outputs.cms.MetricRuleTemplateAlertTemplateEscalations;
        /**
         * The name of the metric.
         *
         * > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
         */
        metricName: string;
        /**
         * The namespace of the service.
         *
         * > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
         */
        namespace: string;
        /**
         * The name of the alert rule.
         */
        ruleName: string;
        /**
         * The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
         */
        webhook?: string;
    }

    export interface MetricRuleTemplateAlertTemplateEscalations {
        /**
         * The condition for triggering critical-level alerts. See the following `Block critical`.
         */
        critical?: outputs.cms.MetricRuleTemplateAlertTemplateEscalationsCritical;
        /**
         * The condition for triggering info-level alerts. See the following `Block info`.
         */
        info?: outputs.cms.MetricRuleTemplateAlertTemplateEscalationsInfo;
        /**
         * The condition for triggering warn-level alerts. See the following `Block warn`.
         */
        warn?: outputs.cms.MetricRuleTemplateAlertTemplateEscalationsWarn;
    }

    export interface MetricRuleTemplateAlertTemplateEscalationsCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: string;
    }

    export interface MetricRuleTemplateAlertTemplateEscalationsInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: string;
    }

    export interface MetricRuleTemplateAlertTemplateEscalationsWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: string;
    }

    export interface MonitorGroupInstancesInstance {
        /**
         * The category of instance.
         */
        category: string;
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The region id of instance.
         */
        regionId: string;
    }

    export interface SiteMonitorIspCity {
        /**
         * The ID of the city.
         */
        city: string;
        /**
         * The ID of the carrier.
         */
        isp: string;
    }

    export interface SlsGroupSlsGroupConfig {
        /**
         * The name of the Log Store.
         */
        slsLogstore: string;
        /**
         * The name of the Project.
         */
        slsProject: string;
        /**
         * The Sls Region.
         */
        slsRegion: string;
        /**
         * The ID of the Sls User.
         */
        slsUserId?: string;
    }

}

export namespace compute {
    export interface GetNestServiceInstancesFilter {
        /**
         * The name of the filter. Valid Values: `Name`, `ServiceInstanceName`, `ServiceInstanceId`, `ServiceId`, `Version`, `Status`, `DeployType`, `ServiceType`, `OperationStartTimeBefore`, `OperationStartTimeAfter`, `OperationEndTimeBefore`, `OperationEndTimeAfter`, `OperatedServiceInstanceId`, `OperationServiceInstanceId`, `EnableInstanceOps`.
         */
        name?: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values?: string[];
    }

    export interface GetNestServiceInstancesServiceInstance {
        /**
         * Whether the service instance has the O&M function.
         */
        enableInstanceOps: boolean;
        /**
         * The ID of the Service Instance.
         */
        id: string;
        /**
         * The ID of the imported service instance.
         */
        operatedServiceInstanceId: string;
        /**
         * The end time of O&M.
         */
        operationEndTime: string;
        /**
         * The start time of O&M.
         */
        operationStartTime: string;
        /**
         * The parameters entered by the deployment service instance.
         */
        parameters: string;
        /**
         * The list of imported resources.
         */
        resources: string;
        /**
         * The ID of the Service Instance.
         */
        serviceInstanceId: string;
        /**
         * The name of the Service Instance.
         */
        serviceInstanceName: string;
        /**
         * Service details.
         */
        services: outputs.compute.GetNestServiceInstancesServiceInstanceService[];
        /**
         * The source of the Service Instance.
         */
        source: string;
        /**
         * The status of the Service Instance. Valid Values: `Created`, `Deploying`, `DeployedFailed`, `Deployed`, `Upgrading`, `Deleting`, `Deleted`, `DeletedFailed`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The name of the template.
         */
        templateName: string;
    }

    export interface GetNestServiceInstancesServiceInstanceService {
        /**
         * The type of the deployment.
         */
        deployType: string;
        /**
         * The time of publish.
         */
        publishTime: string;
        /**
         * The id of the service.
         */
        serviceId: string;
        /**
         * Service information.
         */
        serviceInfos: outputs.compute.GetNestServiceInstancesServiceInstanceServiceServiceInfo[];
        /**
         * The type of the service.
         */
        serviceType: string;
        /**
         * The status of the Service Instance. Valid Values: `Created`, `Deploying`, `DeployedFailed`, `Deployed`, `Upgrading`, `Deleting`, `Deleted`, `DeletedFailed`.
         */
        status: string;
        /**
         * The name of the supplier.
         */
        supplierName: string;
        /**
         * The url of the supplier.
         */
        supplierUrl: string;
        /**
         * The version of the service.
         */
        version: string;
        /**
         * The version name of the service.
         */
        versionName: string;
    }

    export interface GetNestServiceInstancesServiceInstanceServiceServiceInfo {
        /**
         * The image of the service.
         */
        image: string;
        /**
         * The locale of the service.
         */
        locale: string;
        /**
         * The name of the filter. Valid Values: `Name`, `ServiceInstanceName`, `ServiceInstanceId`, `ServiceId`, `Version`, `Status`, `DeployType`, `ServiceType`, `OperationStartTimeBefore`, `OperationStartTimeAfter`, `OperationEndTimeBefore`, `OperationEndTimeAfter`, `OperatedServiceInstanceId`, `OperationServiceInstanceId`, `EnableInstanceOps`.
         */
        name: string;
        /**
         * The short description of the service.
         */
        shortDescription: string;
    }

    export interface NestServiceInstanceCommodity {
        /**
         * Length of purchase.
         */
        payPeriod?: number;
        /**
         * Duration unit. Valid values: `Year`, `Month`, `Day`.
         */
        payPeriodUnit?: string;
    }

    export interface NestServiceInstanceOperationMetadata {
        /**
         * The ID of the imported service instance.
         */
        operatedServiceInstanceId?: string;
        /**
         * The end time of O&M.
         */
        operationEndTime?: string;
        /**
         * The start time of O&M.
         */
        operationStartTime?: string;
        /**
         * The list of imported resources.
         */
        resources: string;
    }

}

export namespace config {
    export interface AssumeRole {
        externalId?: string;
        policy?: string;
        roleArn: string;
        sessionExpiration?: number;
        sessionName?: string;
    }

    export interface Endpoints {
        acr?: string;
        actiontrail?: string;
        adb?: string;
        alb?: string;
        alidfs?: string;
        alidns?: string;
        alikafka?: string;
        apigateway?: string;
        arms?: string;
        bastionhost?: string;
        beebot?: string;
        bpstudio?: string;
        brainIndustrial?: string;
        bssopenapi?: string;
        cas?: string;
        cassandra?: string;
        cbn?: string;
        cbs?: string;
        cddc?: string;
        cdn?: string;
        cds?: string;
        clickhouse?: string;
        cloudauth?: string;
        cloudfirewall?: string;
        cloudfw?: string;
        cloudphone?: string;
        cloudsso?: string;
        cms?: string;
        computenest?: string;
        config?: string;
        cr?: string;
        cs?: string;
        das?: string;
        datahub?: string;
        dataworkspublic?: string;
        dbfs?: string;
        dcdn?: string;
        ddosbasic?: string;
        ddosbgp?: string;
        ddoscoo?: string;
        dds?: string;
        devopsrdc?: string;
        dg?: string;
        dm?: string;
        dmsEnterprise?: string;
        dmsenterprise?: string;
        dns?: string;
        drds?: string;
        dts?: string;
        dysms?: string;
        eais?: string;
        ebs?: string;
        eci?: string;
        ecs?: string;
        edas?: string;
        edasschedulerx?: string;
        edsuser?: string;
        eflo?: string;
        ehpc?: string;
        ehs?: string;
        eipanycast?: string;
        elasticsearch?: string;
        emr?: string;
        ens?: string;
        ess?: string;
        eventbridge?: string;
        fc?: string;
        fnf?: string;
        ga?: string;
        gaplus?: string;
        gds?: string;
        gpdb?: string;
        gwsecd?: string;
        hbr?: string;
        hcsSgw?: string;
        hitsdb?: string;
        imm?: string;
        imp?: string;
        ims?: string;
        iot?: string;
        kms?: string;
        kvstore?: string;
        location?: string;
        log?: string;
        market?: string;
        maxcompute?: string;
        mhub?: string;
        mns?: string;
        mscopensubscription?: string;
        mse?: string;
        nas?: string;
        nlb?: string;
        oceanbase?: string;
        ons?: string;
        onsproxy?: string;
        oos?: string;
        opensearch?: string;
        oss?: string;
        ots?: string;
        polardb?: string;
        privatelink?: string;
        pvtz?: string;
        quickbi?: string;
        quotas?: string;
        rKvstore?: string;
        ram?: string;
        rds?: string;
        redisa?: string;
        resourcemanager?: string;
        resourcesharing?: string;
        ros?: string;
        sas?: string;
        scdn?: string;
        sddp?: string;
        serverless?: string;
        servicemesh?: string;
        sgw?: string;
        slb?: string;
        smartag?: string;
        srvcatalog?: string;
        sts?: string;
        swas?: string;
        tag?: string;
        vod?: string;
        vpc?: string;
        vpcpeer?: string;
        vs?: string;
        waf?: string;
        wafOpenapi?: string;
    }

}

export namespace cr {
    export interface ChainChainConfig {
        /**
         * Each node in the delivery chain.
         */
        nodes?: outputs.cr.ChainChainConfigNode[];
        /**
         * Execution sequence relationship between delivery chain nodes.
         */
        routers?: outputs.cr.ChainChainConfigRouter[];
    }

    export interface ChainChainConfigNode {
        /**
         * Whether to enable the delivery chain node. Valid values: `true`, `false`.
         */
        enable?: boolean;
        /**
         * The configuration of delivery chain node.
         */
        nodeConfigs?: outputs.cr.ChainChainConfigNodeNodeConfig[];
        /**
         * The name of node. Valid values: `DOCKER_IMAGE_BUILD`, `DOCKER_IMAGE_PUSH`, `VULNERABILITY_SCANNING`, `ACTIVATE_REPLICATION`, `TRIGGER`, `SNAPSHOT`, `TRIGGER_SNAPSHOT`.
         */
        nodeName?: string;
    }

    export interface ChainChainConfigNodeNodeConfig {
        /**
         * Blocking rules for scanning nodes in delivery chain nodes. **Note:** When `nodeName` is `VULNERABILITY_SCANNING`, the parameters in `denyPolicy` need to be filled in.
         */
        denyPolicies?: outputs.cr.ChainChainConfigNodeNodeConfigDenyPolicy[];
    }

    export interface ChainChainConfigNodeNodeConfigDenyPolicy {
        /**
         * The action of trigger blocking. Valid values: `BLOCK`, `BLOCK_RETAG`, `BLOCK_DELETE_TAG`. While `Block` means block the delivery chain from continuing to execute, `BLOCK_RETAG` means block overwriting push image tag, `BLOCK_DELETE_TAG` means block deletion of mirror tags.
         *
         * > **NOTE:** The `from` and `to` fields are all fixed, and their structure and the value of `nodeName` are fixed. You can refer to the template given in the example for configuration.
         */
        action?: string;
        /**
         * The count of scanning vulnerabilities that triggers blocking.
         */
        issueCount?: string;
        /**
         * The level of scanning vulnerability that triggers blocking. Valid values: `LOW`, `MEDIUM`, `HIGH`, `UNKNOWN`.
         */
        issueLevel?: string;
        /**
         * The logic of trigger blocking. Valid values: `AND`, `OR`.
         */
        logic?: string;
    }

    export interface ChainChainConfigRouter {
        /**
         * Source node.
         */
        froms?: outputs.cr.ChainChainConfigRouterFrom[];
        /**
         * Destination node.
         */
        tos?: outputs.cr.ChainChainConfigRouterTo[];
    }

    export interface ChainChainConfigRouterFrom {
        /**
         * The name of node. Valid values: `DOCKER_IMAGE_BUILD`, `DOCKER_IMAGE_PUSH`, `VULNERABILITY_SCANNING`, `ACTIVATE_REPLICATION`, `TRIGGER`, `SNAPSHOT`, `TRIGGER_SNAPSHOT`.
         */
        nodeName?: string;
    }

    export interface ChainChainConfigRouterTo {
        /**
         * The name of node. Valid values: `DOCKER_IMAGE_BUILD`, `DOCKER_IMAGE_PUSH`, `VULNERABILITY_SCANNING`, `ACTIVATE_REPLICATION`, `TRIGGER`, `SNAPSHOT`, `TRIGGER_SNAPSHOT`.
         */
        nodeName?: string;
    }

    export interface GetChainsChain {
        /**
         * The configuration of delivery chain.
         */
        chainConfigs: outputs.cr.GetChainsChainChainConfig[];
        /**
         * The ID of delivery chain.
         */
        chainId: string;
        /**
         * The name of delivery chain.
         */
        chainName: string;
        /**
         * The creation time of delivery chain.
         */
        createTime: string;
        /**
         * The description of delivery chain.
         */
        description: string;
        /**
         * The resource ID of the delivery chain. The value formats as `<instance_id>:<chain_id>`.
         */
        id: string;
        /**
         * The ID of CR Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * The modification time of delivery chain description.
         */
        modifiedTime: string;
        /**
         * Delivery chain scope ID.
         */
        scopeId: string;
        /**
         * Delivery chain scope type.
         */
        scopeType: string;
    }

    export interface GetChainsChainChainConfig {
        /**
         * Each node in the delivery chain.
         */
        nodes: outputs.cr.GetChainsChainChainConfigNode[];
        /**
         * Execution sequence relationship between delivery chain nodes.
         */
        routers: outputs.cr.GetChainsChainChainConfigRouter[];
    }

    export interface GetChainsChainChainConfigNode {
        /**
         * Whether to enable the delivery chain node. Valid values: `true`, `false`.
         */
        enable: boolean;
        /**
         * The configuration of delivery chain node.
         */
        nodeConfigs: outputs.cr.GetChainsChainChainConfigNodeNodeConfig[];
        /**
         * The name of delivery chain node.
         */
        nodeName: string;
    }

    export interface GetChainsChainChainConfigNodeNodeConfig {
        /**
         * Blocking rules for scanning nodes in delivery chain nodes. **Note:** When `nodeName` is `VULNERABILITY_SCANNING`, the parameters in `denyPolicy` need to be filled in.
         */
        denyPolicies: outputs.cr.GetChainsChainChainConfigNodeNodeConfigDenyPolicy[];
    }

    export interface GetChainsChainChainConfigNodeNodeConfigDenyPolicy {
        /**
         * The action of trigger blocking. Valid values: `BLOCK`, `BLOCK_RETAG`, `BLOCK_DELETE_TAG`. While `Block` means block the delivery chain from continuing to execute, `BLOCK_RETAG` means block overwriting push image tag, `BLOCK_DELETE_TAG` means block deletion of mirror tags.
         */
        action?: string;
        /**
         * The count of scanning vulnerabilities that triggers blocking.
         */
        issueCount: string;
        /**
         * The level of scanning vulnerability that triggers blocking. Valid values: `LOW`, `MEDIUM`, `HIGH`, `UNKNOWN`.
         */
        issueLevel: string;
        /**
         * The logic of trigger blocking. Valid values: `AND`, `OR`.
         */
        logic: string;
    }

    export interface GetChainsChainChainConfigRouter {
        /**
         * Source node.
         */
        froms: outputs.cr.GetChainsChainChainConfigRouterFrom[];
        /**
         * Destination node.
         */
        tos: outputs.cr.GetChainsChainChainConfigRouterTo[];
    }

    export interface GetChainsChainChainConfigRouterFrom {
        /**
         * The name of delivery chain node.
         */
        nodeName: string;
    }

    export interface GetChainsChainChainConfigRouterTo {
        /**
         * The name of delivery chain node.
         */
        nodeName: string;
    }

    export interface GetChartNamespacesNamespace {
        /**
         * Indicates whether a repository is automatically created when an image is pushed to the namespace.
         */
        autoCreateRepo: boolean;
        /**
         * The ID of the namespace.
         */
        chartNamespaceId: string;
        /**
         * The default repository type. Valid values: `PUBLIC`,`PRIVATE`.
         */
        defaultRepoType: string;
        /**
         * The ID of the Chart Namespace.
         */
        id: string;
        /**
         * The ID of the namespace.
         */
        instanceId: string;
        /**
         * The name of the namespace.
         */
        namespaceName: string;
    }

    export interface GetChartRepositoriesRepository {
        /**
         * The first ID of the resource.
         */
        chartRepositoryId: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Chart Repository.
         */
        id: string;
        /**
         * The ID of the Container Registry instance.
         */
        instanceId: string;
        /**
         * The name of the repository.
         */
        repoName: string;
        /**
         * The namespace to which the repository belongs.
         */
        repoNamespaceName: string;
        /**
         * The type of the repository. Valid values: `PUBLIC`,`PRIVATE`.
         */
        repoType: string;
        /**
         * The summary about the repository.
         */
        summary: string;
    }

    export interface GetEndpointAclPoliciesPolicy {
        /**
         * The description of the entry.
         */
        description: string;
        /**
         * The type of endpoint.
         */
        endpointType: string;
        /**
         * The IP segment that allowed to access.
         */
        entry: string;
        /**
         * The ID of the Endpoint Acl Policy.
         */
        id: string;
        /**
         * The ID of the CR Instance.
         */
        instanceId: string;
    }

    export interface GetNamespacesNamespace {
        /**
         * Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
         */
        autoCreate: boolean;
        /**
         * `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
         */
        defaultVisibility: string;
        /**
         * Name of Container Registry namespace.
         */
        name: string;
    }

    export interface GetReposRepo {
        /**
         * The repository domain list.
         */
        domainList: outputs.cr.GetReposRepoDomainList;
        /**
         * Name of container registry namespace.
         */
        name: string;
        /**
         * Name of container registry namespace where the repositories are located in.
         */
        namespace: string;
        /**
         * `PUBLIC` or `PRIVATE`, repository's visibility.
         */
        repoType: string;
        /**
         * The repository general information.
         */
        summary: string;
        /**
         * A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
         */
        tags: outputs.cr.GetReposRepoTag[];
    }

    export interface GetReposRepoDomainList {
        /**
         * Domain of internal endpoint, only in some regions.
         */
        internal: string;
        /**
         * Domain of public endpoint.
         */
        public: string;
        /**
         * Domain of vpc endpoint.
         */
        vpc: string;
    }

    export interface GetReposRepoTag {
        /**
         * Digest of this image.
         */
        digest: string;
        /**
         * Create time of this image, unix time in nanoseconds.
         */
        imageCreate: number;
        /**
         * Id of this image.
         */
        imageId: string;
        /**
         * Status of this image, in bytes.
         */
        imageSize: number;
        /**
         * Last update time of this image, unix time in nanoseconds.
         */
        imageUpdate: number;
        /**
         * Status of this image.
         */
        status: string;
        /**
         * Tag of this image.
         */
        tag: string;
    }

    export interface GetVpcEndpointLinkedVpcsVpcEndpointLinkedVpc {
        /**
         * Indicates whether the default policy is used to access the instance.
         */
        defaultAccess: boolean;
        /**
         * The ID of the Vpc Endpoint Linked Vpc. It formats as `<instance_id>:<vpc_id>:<vswitch_id>:<module_name>`.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * IP address.
         */
        ip: string;
        /**
         * The name of the module that you want to access. Valid Values:
         */
        moduleName: string;
        /**
         * The status of the Vpc Endpoint Linked Vpc. Valid Values: `CREATING`, `RUNNING`.
         */
        status: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch.
         */
        vswitchId: string;
    }

    export interface RepoDomainList {
        /**
         * Domain of internal endpoint, only in some regions.
         */
        internal: string;
        /**
         * Domain of public endpoint.
         */
        public: string;
        /**
         * Domain of vpc endpoint.
         */
        vpc: string;
    }

}

export namespace cs {
    export interface ApplicationService {
        id: string;
        name: string;
        status: string;
        version: string;
    }

    export interface ClusterNode {
        eip: string;
        id: string;
        name: string;
        privateIp: string;
        status: string;
    }

    export interface EdgeKubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface EdgeKubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface EdgeKubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface EdgeKubernetesLogConfig {
        /**
         * Log Service project name, cluster logs will output to this project.
         */
        project?: string;
        /**
         * Type of collecting logs, only `SLS` are supported currently.
         */
        type: string;
    }

    export interface EdgeKubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface EdgeKubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface EdgeKubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetClusterCredentialCertificateAuthority {
        /**
         * The base64 encoded client certificate data required to communicate with your cluster. Add this to the client-certificate-data section of the kube config file for your cluster.
         */
        clientCert: string;
        /**
         * The base64 encoded client key data required to communicate with your cluster. Add this to the client-key-data section of the kube config file for your cluster.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kube config file for your cluster.
         */
        clusterCert: string;
    }

    export interface GetEdgeKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetEdgeKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetEdgeKubernetesClustersClusterWorkerNode[];
    }

    export interface GetEdgeKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
    }

    export interface GetEdgeKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesAddonsAddon {
        /**
         * The current custom configuration of the addon. **Note:** Available in v1.166.0+
         */
        currentConfig: string;
        /**
         * The current version of addon, if this field is an empty string, it means that the addon is not installed.
         */
        currentVersion: string;
        /**
         * The name of addon.
         */
        name: string;
        /**
         * The next version of this addon can be upgraded to.
         */
        nextVersion: string;
        /**
         * Whether the addon is a system addon.
         */
        required: boolean;
    }

    export interface GetKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        clusterNetworkType: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The ID of node image.
         */
        imageId: string;
        /**
         * The keypair of ssh login cluster node, you have to create it first.
         */
        keyName: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfigs: outputs.cs.GetKubernetesClustersClusterLogConfig[];
        masterAutoRenew: boolean;
        masterAutoRenewPeriod: number;
        /**
         * The system disk category of master node.
         */
        masterDiskCategory: string;
        /**
         * The system disk size of master node.
         */
        masterDiskSize: number;
        masterInstanceChargeType: string;
        /**
         * The instance type of master node.
         */
        masterInstanceTypes: string[];
        /**
         * List of cluster master nodes. It contains several attributes to `Block Nodes`.
         */
        masterNodes: outputs.cs.GetKubernetesClustersClusterMasterNode[];
        masterPeriod: number;
        masterPeriodUnit: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The network mask used on pods for each node.
         */
        nodeCidrMask: number;
        podCidr: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        serviceCidr: string;
        /**
         * Whether internet load balancer for API Server is created
         */
        slbInternetEnabled: boolean;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitches where the current cluster is located.
         */
        vswitchIds: string[];
        workerAutoRenew: boolean;
        workerAutoRenewPeriod: number;
        /**
         * The data disk size of worker node.
         */
        workerDataDiskCategory: string;
        /**
         * The data disk category of worker node.
         */
        workerDataDiskSize: number;
        /**
         * The system disk category of worker node.
         */
        workerDiskCategory: string;
        /**
         * The system disk size of worker node.
         */
        workerDiskSize: number;
        workerInstanceChargeType: string;
        /**
         * The instance type of worker node.
         */
        workerInstanceTypes: string[];
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetKubernetesClustersClusterWorkerNode[];
        /**
         * The ECS instance node number in the current container cluster.
         */
        workerNumbers: number[];
        workerPeriod: number;
        workerPeriodUnit: string;
    }

    export interface GetKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface GetKubernetesClustersClusterLogConfig {
        /**
         * Log Service project name.
         */
        project: string;
        /**
         * Type of collecting logs.
         */
        type: string;
    }

    export interface GetKubernetesClustersClusterMasterNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesPermissionPermission {
        /**
         * ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
         */
        isOwner?: boolean;
        /**
         * Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
         */
        isRamRole?: boolean;
        /**
         * The permission settings to manage ACK clusters.
         */
        resourceId: string;
        /**
         * The authorization type. Valid values `cluster`, `namespace` and `console`.
         */
        resourceType: string;
        /**
         * The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
         */
        roleName: string;
        /**
         * The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
         */
        roleType?: string;
    }

    export interface GetKubernetesVersionMetadata {
        /**
         * The list of supported runtime.
         */
        runtimes: outputs.cs.GetKubernetesVersionMetadataRuntime[];
        /**
         * The runtime version.
         */
        version: string;
    }

    export interface GetKubernetesVersionMetadataRuntime {
        /**
         * The runtime name.
         */
        name: string;
        /**
         * The runtime version.
         */
        version: string;
    }

    export interface GetManagedKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        clusterNetworkType: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetManagedKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        imageId: string;
        /**
         * The keypair of ssh login cluster node, you have to create it first.
         */
        keyName: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfigs: outputs.cs.GetManagedKubernetesClustersClusterLogConfig[];
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        podCidr: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        serviceCidr: string;
        slbInternetEnabled: boolean;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitches where the current cluster is located.
         */
        vswitchIds: string[];
        workerAutoRenew: boolean;
        workerAutoRenewPeriod: number;
        workerDataDiskCategory: string;
        workerDataDiskSize: number;
        workerDiskCategory: string;
        workerDiskSize: number;
        workerInstanceChargeType: string;
        workerInstanceTypes: string[];
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetManagedKubernetesClustersClusterWorkerNode[];
        /**
         * The ECS instance node number in the current container cluster.
         */
        workerNumbers: number[];
        workerPeriod: number;
        workerPeriodUnit: string;
    }

    export interface GetManagedKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface GetManagedKubernetesClustersClusterLogConfig {
        /**
         * Log Service project name.
         */
        project: string;
        /**
         * Type of collecting logs.
         */
        type: string;
    }

    export interface GetManagedKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetRegistryEnterpriseInstancesInstance {
        /**
         * The password that was used to log on to the registry.
         */
        authorizationToken: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        id: string;
        /**
         * Name of Container Registry Enterprise Edition instance.
         */
        name: string;
        /**
         * The max number of namespaces that an instance can create.
         */
        namespaceQuota: string;
        /**
         * The number of namespaces already created.
         */
        namespaceUsage: string;
        /**
         * A list of domains for access on internet network.
         */
        publicEndpoints: string[];
        /**
         * Region of Container Registry Enterprise Edition instance.
         */
        region: string;
        /**
         * The max number of repos that an instance can create.
         */
        repoQuota: string;
        /**
         * The number of repos already created.
         */
        repoUsage: string;
        /**
         * Specification of Container Registry Enterprise Edition instance.
         */
        specification: string;
        /**
         * The username that was used to log on to the registry.
         */
        tempUsername: string;
        /**
         * A list of domains for access on vpc network.
         */
        vpcEndpoints: string[];
    }

    export interface GetRegistryEnterpriseNamespacesNamespace {
        /**
         * Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
         */
        autoCreate: boolean;
        /**
         * `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
         */
        defaultVisibility: string;
        /**
         * ID of Container Registry Enterprise Edition namespace. It formats as `<instance_id>:<namespace_name>`. Before 1.161.0, it is a namespace uuid.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition namespace.
         */
        name: string;
        /**
         * Container Registry Enterprise Edition namespace id. It is a uuid.
         */
        namespaceId: string;
        /**
         * Name of Container Registry Enterprise Edition namespace.
         */
        namespaceName: string;
    }

    export interface GetRegistryEnterpriseReposRepo {
        /**
         * ID of Container Registry Enterprise Edition repository.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition repository.
         */
        name: string;
        /**
         * Name of Container Registry Enterprise Edition namespace where the repositories are located in.
         */
        namespace: string;
        /**
         * `PUBLIC` or `PRIVATE`, repository's visibility.
         */
        repoType: string;
        /**
         * The repository general information.
         */
        summary: string;
        /**
         * A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
         */
        tags: outputs.cs.GetRegistryEnterpriseReposRepoTag[];
    }

    export interface GetRegistryEnterpriseReposRepoTag {
        /**
         * Digest of this image.
         */
        digest: string;
        /**
         * Create time of this image, unix time in nanoseconds.
         */
        imageCreate: string;
        /**
         * Id of this image.
         */
        imageId: string;
        /**
         * Status of this image, in bytes.
         */
        imageSize: number;
        /**
         * Last update time of this image, unix time in nanoseconds.
         */
        imageUpdate: string;
        /**
         * Status of this image.
         */
        status: string;
        /**
         * Tag of this image.
         */
        tag: string;
    }

    export interface GetRegistryEnterpriseSyncRulesRule {
        /**
         * ID of Container Registry Enterprise Edition sync rule.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition local instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition sync rule.
         */
        name: string;
        /**
         * Name of Container Registry Enterprise Edition local namespace.
         */
        namespaceName: string;
        /**
         * Region of Container Registry Enterprise Edition local instance.
         */
        regionId: string;
        /**
         * Name of Container Registry Enterprise Edition local repo.
         */
        repoName: string;
        /**
         * `FROM` or `TO`, the direction of synchronization. `FROM` indicates that the local instance is the source instance. `TO` indicates that the local instance is the target instance to be synchronized.
         */
        syncDirection: string;
        /**
         * `REPO` or `NAMESPACE`,the scope that the synchronization rule applies.
         */
        syncScope: string;
        /**
         * `PASSIVE` or `INITIATIVE`, the policy configured to trigger the synchronization rule.
         */
        syncTrigger: string;
        /**
         * The regular expression used to filter image tags for synchronization in the source repository.
         */
        tagFilter: string;
        /**
         * ID of Container Registry Enterprise Edition target instance.
         */
        targetInstanceId: string;
        /**
         * Name of Container Registry Enterprise Edition target namespace.
         */
        targetNamespaceName: string;
        /**
         * Region of Container Registry Enterprise Edition target instance.
         */
        targetRegionId: string;
        /**
         * Name of Container Registry Enterprise Edition target repo.
         */
        targetRepoName: string;
    }

    export interface GetServerlessKubernetesClustersCluster {
        /**
         * Map of serverless cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetServerlessKubernetesClustersClusterConnections;
        /**
         * Whether the cluster support delete protection.
         */
        deletionProtection: boolean;
        endpointPublicAccessEnabled: boolean;
        /**
         * The ID of the container cluster.
         */
        id: string;
        /**
         * The name of the container cluster.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The ID of security group where the current cluster  is located.
         */
        securityGroupId: string;
        tags: {[key: string]: any};
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitch where the current cluster is located.
         */
        vswitchId: string;
    }

    export interface GetServerlessKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
    }

    export interface KubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface KubernetesAutoscalerNodepool {
        id?: string;
        labels?: string;
        taints?: string;
    }

    export interface KubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface KubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface KubernetesMasterNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface KubernetesPermissionPermission {
        /**
         * The ID of the cluster that you want to manage.
         */
        cluster: string;
        /**
         * Specifies whether to perform a custom authorization. To perform a custom authorization, set `roleName` to a custom cluster role.
         */
        isCustom?: boolean;
        /**
         * Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `isRamRole` must be `true`.
         */
        isRamRole?: boolean;
        /**
         * The namespace to which the permissions are scoped. This parameter is required only if you set roleType to namespace.
         */
        namespace?: string;
        /**
         * Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
         */
        roleName: string;
        /**
         * The authorization type. Valid values `cluster`, `namespace`.
         */
        roleType: string;
    }

    export interface KubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface KubernetesTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface KubernetesWorkerDataDisk {
        /**
         * (Optional, Available in 1.120.0+) Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * (Optional, Available in 1.120.0+) Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface KubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface ManagedKubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface ManagedKubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface ManagedKubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface ManagedKubernetesMaintenanceWindow {
        /**
         * The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
         */
        duration: string;
        /**
         * Whether to open the maintenance window. The following parameters take effect only `enable = true`.
         */
        enable: boolean;
        /**
         * Initial maintenance time, For example:"03:00:00Z".
         */
        maintenanceTime: string;
        /**
         * Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
         *
         * for example:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        weeklyPeriod: string;
    }

    export interface ManagedKubernetesRrsaMetadata {
        /**
         * Whether the RRSA feature has been enabled.
         */
        enabled: boolean;
        /**
         * The arn of OIDC provider that was registered in RAM.
         */
        ramOidcProviderArn: string;
        /**
         * The name of OIDC Provider that was registered in RAM.
         */
        ramOidcProviderName: string;
        /**
         * The issuer URL of RRSA OIDC Token.
         */
        rrsaOidcIssuerUrl: string;
    }

    export interface ManagedKubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface ManagedKubernetesTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface ManagedKubernetesWorkerDataDisk {
        /**
         * (Optional, Available in 1.120.0+) Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * (Optional, Available in 1.120.0+) Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface ManagedKubernetesWorkerNode {
        /**
         * (Deprecated from version 1.177.0) ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * (Deprecated from version 1.177.0) The private IP address of node.
         */
        privateIp: string;
    }

    export interface NodePoolDataDisk {
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values:`cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
         */
        encrypted?: string;
        /**
         * The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
         */
        kmsKeyId?: string;
        /**
         * The name of node pool.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
         */
        size?: number;
        snapshotId?: string;
    }

    export interface NodePoolKubeletConfiguration {
        /**
         * Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
         */
        cpuManagerPolicy?: string;
        /**
         * Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `eventRecordQps`. It is only used when `eventRecordQps` is greater than 0. Valid value is `[0-100]`.
         */
        eventBurst?: string;
        /**
         * Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
         */
        eventRecordQps?: string;
        /**
         * Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
         */
        evictionHard?: {[key: string]: any};
        /**
         * Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
         */
        evictionSoft?: {[key: string]: any};
        /**
         * Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
         */
        evictionSoftGracePeriod?: {[key: string]: any};
        /**
         * Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
         */
        kubeApiBurst?: string;
        /**
         * Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
         */
        kubeApiQps?: string;
        /**
         * Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](http://kubernetes.io/docs/user-guide/compute-resources) for more details.
         */
        kubeReserved?: {[key: string]: any};
        /**
         * Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registryPullQps`. Only used if `registryPullQps` is greater than 0. Valid value is `[0-100]`.
         */
        registryBurst?: string;
        /**
         * Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
         */
        registryPullQps?: string;
        /**
         * Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
         */
        serializeImagePulls?: string;
        /**
         * Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](http://kubernetes.io/docs/user-guide/compute-resources) for more details.
         */
        systemReserved?: {[key: string]: any};
    }

    export interface NodePoolLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface NodePoolManagement {
        /**
         * Whether automatic repair, Default to `false`.
         */
        autoRepair?: boolean;
        /**
         * Whether auto upgrade, Default to `false`.
         */
        autoUpgrade?: boolean;
        /**
         * Max number of unavailable nodes. Default to `1`.
         */
        maxUnavailable: number;
        /**
         * Number of additional nodes. You have to specify one of surge, surge_percentage.
         */
        surge?: number;
        /**
         * Proportion of additional nodes. You have to specify one of surge, surge_percentage.
         */
        surgePercentage?: number;
    }

    export interface NodePoolRollingPolicy {
        /**
         * Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used.
         */
        maxParallelism?: number;
    }

    export interface NodePoolRolloutPolicy {
        /**
         * Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used. Please use `maxParallelism` to instead it from provider version 1.185.0.
         */
        maxUnavailable?: number;
    }

    export interface NodePoolScalingConfig {
        /**
         * Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
         */
        eipBandwidth?: number;
        /**
         * EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internetChargeType`, EIP and public network IP can only choose one.
         */
        eipInternetChargeType?: string;
        /**
         * Whether to bind EIP for an instance. Default: `false`.
         */
        isBondEip?: boolean;
        /**
         * Max number of instances in a auto scaling group, its valid value range [0~1000]. `maxSize` has to be greater than `minSize`.
         */
        maxSize: number;
        /**
         * Min number of instances in a auto scaling group, its valid value range [0~1000].
         */
        minSize: number;
        /**
         * Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instanceTypes`.
         */
        type?: string;
    }

    export interface NodePoolSpotPriceLimit {
        /**
         * Spot instance type.
         */
        instanceType?: string;
        /**
         * The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
         */
        priceLimit?: string;
    }

    export interface NodePoolTaint {
        effect?: string;
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface ServerlessKubernetesAddon {
        /**
         * The ACK add-on configurations.
         */
        config?: string;
        /**
         * Disables the automatic installation of a component. Default is `false`.
         *
         * The following example is the definition of addons block, The type of this field is list:
         */
        disabled?: boolean;
        /**
         * Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
         */
        name?: string;
    }

    export interface ServerlessKubernetesRrsaMetadata {
        /**
         * Whether the RRSA feature has been enabled.
         */
        enabled: boolean;
        /**
         * The arn of OIDC provider that was registered in RAM.
         */
        ramOidcProviderArn: string;
        /**
         * The name of OIDC Provider that was registered in RAM.
         */
        ramOidcProviderName: string;
        /**
         * The issuer URL of RRSA OIDC Token.
         */
        rrsaOidcIssuerUrl: string;
    }

    export interface SwarmNode {
        eip: string;
        id: string;
        name: string;
        privateIp: string;
        status: string;
    }

}

export namespace databasefilesystem {
    export interface GetAutoSnapShotPoliciesAutoSnapShotPolicy {
        /**
         * The number of database file systems set by the automatic snapshot policy.
         */
        appliedDbfsNumber: number;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * The ID of the policy.
         */
        id: string;
        /**
         * Last modification time of automatic snapshot policy
         */
        lastModified: string;
        /**
         * Automatic snapshot policy ID
         */
        policyId: string;
        /**
         * Automatic snapshot policy name
         */
        policyName: string;
        /**
         * A collection of automatic snapshots performed on several days of the week.
         */
        repeatWeekdays: string[];
        /**
         * Automatic snapshot retention days
         */
        retentionDays: number;
        /**
         * Automatic snapshot policy status
         */
        status: string;
        /**
         * Automatic snapshot policy status details
         */
        statusDetail: string;
        /**
         * The set of times at which the snapshot is taken on the day the automatic snapshot is executed.
         */
        timePoints: string[];
    }

    export interface GetInstancesInstance {
        /**
         * the number of nodes of the Database file system.
         */
        attachNodeNumber: number;
        /**
         * The type of the Database file system. Valid values: `standard`.
         */
        category: string;
        /**
         * The create time of the Database file system.
         */
        createTime: string;
        /**
         * The cluster ID of the Database file system.
         */
        dbfsClusterId: string;
        /**
         * The collection of ECS instances mounted to the Database file system.
         */
        ecsLists: outputs.databasefilesystem.GetInstancesInstanceEcsList[];
        /**
         * Whether to create the Database file system in RAID way. Valid values : `true` anf `false`.
         */
        enableRaid: boolean;
        /**
         * Whether to encrypt the Database file system. Valid values: `true` and `false`.
         */
        encryption: boolean;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the Database File System
         */
        instanceId: string;
        /**
         * The name of the Database file system.
         */
        instanceName: string;
        /**
         * The KMS key ID of the Database file system used. This parameter is valid When `encryption` parameter is set to `true`.
         */
        kmsKeyId: string;
        /**
         * Thr payment type of the Database file system. Valid value: `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * The performance level of the Database file system. Valid values: `PL0`, `PL1`, `PL2`, `PL3`.
         */
        performanceLevel: string;
        /**
         * The number of strip . When `enableRaid` parameter is set to `true` will transfer. This parameter is valid When `enableRaid` parameter is set to `true`.
         */
        raidStripeUnitNumber: string;
        /**
         * The size Of the Database file system. Unit: GiB.
         */
        size: number;
        /**
         * The status of the Database file system.
         */
        status: string;
        /**
         * The Zone ID of the Database file system.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceEcsList {
        /**
         * The ID of the ECS instance.
         */
        ecsId: string;
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The type of the Snapshot.
         */
        category: string;
        /**
         * The creation time of the snapshot.
         */
        createTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The ID of the database file system.
         */
        instanceId: string;
        /**
         * The last modification time of the snapshot.
         */
        lastModifiedTime: string;
        /**
         * The progress of the snapshot.
         */
        progress: string;
        /**
         * The remaining completion time of the snapshot being created, in seconds.
         */
        remainTime: number;
        /**
         * The retention days of the snapshot.
         */
        retentionDays: number;
        /**
         * The ID of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The creation of the snapshot.
         */
        snapshotType: string;
        /**
         * Source database file system capacity.
         */
        sourceFsSize: number;
        /**
         * The status of the snapshot. Possible values: `progressing`, `accomplished`, `failed`.
         */
        status: string;
    }

    export interface InstanceEcsList {
        /**
         * The ID of the ECS instance.
         */
        ecsId?: string;
    }

}

export namespace databasegateway {
    export interface GetGatewaysGateway {
        /**
         * The creation time of Gateway.
         */
        createTime: string;
        /**
         * The description of Gateway.
         */
        gatewayDesc: string;
        gatewayInstances: outputs.databasegateway.GetGatewaysGatewayGatewayInstance[];
        /**
         * The name of the Gateway.
         */
        gatewayName: string;
        /**
         * A host of information.
         */
        hosts: string;
        /**
         * The ID of Gateway.
         */
        id: string;
        /**
         * The Modify time of Gateway.
         */
        modifiedTime: string;
        /**
         * The parent node Id of Gateway.
         */
        parentId: string;
        /**
         * The status of gateway. Valid values: `EXCEPTION`, `NEW`, `RUNNING`, `STOPPED`.
         */
        status: string;
        /**
         * The user's id.
         */
        userId: string;
    }

    export interface GetGatewaysGatewayGatewayInstance {
        /**
         * The connection type of Gateway instance.
         */
        connectEndpointType: string;
        /**
         * The process of version number of Gateway instance.
         */
        currentDaemonVersion: string;
        /**
         * The version of Gateway instance.
         */
        currentVersion: string;
        /**
         * The endpoint address of Gateway instance.
         */
        endPoint: string;
        /**
         * The id of Gateway instance.
         */
        gatewayInstanceId: string;
        /**
         * The status of Gateway instance. Valid values: `EXCEPTION`, `NEW`, `RUNNING`, `STOPPED`.
         */
        gatewayInstanceStatus: string;
        /**
         * The last Updated time stamp of Gateway instance.
         */
        lastUpdateTime: string;
        /**
         * The Local IP ADDRESS of Gateway instance.
         */
        localIp: string;
        /**
         * The prompt information of Gateway instance.
         */
        message: string;
        /**
         * The host of Gateway instance.
         */
        outputIp: string;
    }

}

export namespace dataworks {
    export interface GetFoldersFolder {
        folderId: string;
        /**
         * Folder Path.
         */
        folderPath: string;
        /**
         * The Folder ID.
         */
        id: string;
        /**
         * The ID of the project.
         */
        projectId: string;
    }

}

export namespace dbs {
    export interface GetBackupPlansPlan {
        /**
         * The ID of the backup gateway.
         */
        backupGatewayId: string;
        /**
         * The Backup method.
         */
        backupMethod: string;
        /**
         * The backup object.
         */
        backupObjects: string;
        /**
         * Full backup cycle.
         */
        backupPeriod: string;
        /**
         * The first ID of the resource.
         */
        backupPlanId: string;
        /**
         * The name of the resource.
         */
        backupPlanName: string;
        /**
         * The retention time of backup data.
         */
        backupRetentionPeriod: number;
        /**
         * The start time of full Backup.
         */
        backupStartTime: string;
        /**
         * Built-in storage type.
         */
        backupStorageType: string;
        /**
         * The UID that is backed up across Alibaba cloud accounts.
         */
        crossAliyunId: string;
        /**
         * The name of the RAM role that is backed up across Alibaba cloud accounts.
         */
        crossRoleName: string;
        /**
         * The database type.
         */
        databaseType: string;
        /**
         * The storage time for conversion to archive cold standby is 365 days by default.
         */
        duplicationArchivePeriod: number;
        /**
         * The storage time is converted to low-frequency access. The default time is 180 days.
         */
        duplicationInfrequentAccessPeriod: number;
        /**
         * Whether to enable incremental log Backup.
         */
        enableBackupLog: boolean;
        /**
         * The ID of the Backup Plan.
         */
        id: string;
        /**
         * The Instance class.
         */
        instanceClass: string;
        /**
         * The OSS Bucket name.
         */
        ossBucketName: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The name of the database.
         */
        sourceEndpointDatabaseName: string;
        /**
         * The ID of the database instance.
         */
        sourceEndpointInstanceId: string;
        /**
         * The location of the database.
         */
        sourceEndpointInstanceType: string;
        /**
         * The region of the database.
         */
        sourceEndpointRegion: string;
        /**
         * The Oracle SID name.
         */
        sourceEndpointSid: string;
        /**
         * The source endpoint username.
         */
        sourceEndpointUserName: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

}

export namespace dcdn {
    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainSource {
        /**
         * The origin address.
         */
        content: string;
        /**
         * The port number. Valid values: `443` and `80`. Default to `80`.
         */
        port?: number;
        /**
         * The priority of the origin if multiple origins are specified. Default to `20`.
         */
        priority?: string;
        /**
         * The type of the origin. Valid values:
         * `ipaddr`: The origin is configured using an IP address.
         * `domain`: The origin is configured using a domain name.
         * `oss`: The origin is configured using the Internet domain name of an Alibaba Cloud Object Storage Service (OSS) bucket.
         */
        type: string;
        /**
         * The weight of the origin if multiple origins are specified. Default to `10`.
         */
        weight?: string;
    }

    export interface ErEnvConf {
        /**
         * The configuration of a presetCanaryAnhui environment. The `Block presetCanaryAnhui` is same as `Block staging`.
         */
        presetCanaryAnhui: outputs.dcdn.ErEnvConfPresetCanaryAnhui;
        /**
         * The configuration of a presetCanaryBeijing environment. The `Block presetCanaryBeijing` is same as `Block staging`.
         */
        presetCanaryBeijing: outputs.dcdn.ErEnvConfPresetCanaryBeijing;
        /**
         * The configuration of a presetCanaryChongqing environment. The `Block presetCanaryChongqing` is same as `Block staging`.
         */
        presetCanaryChongqing: outputs.dcdn.ErEnvConfPresetCanaryChongqing;
        /**
         * The configuration of a presetCanaryFujian environment. The `Block presetCanaryFujian` is same as `Block staging`.
         */
        presetCanaryFujian: outputs.dcdn.ErEnvConfPresetCanaryFujian;
        /**
         * The configuration of a presetCanaryGansu environment. The `Block presetCanaryGansu` is same as `Block staging`.
         */
        presetCanaryGansu: outputs.dcdn.ErEnvConfPresetCanaryGansu;
        /**
         * The configuration of a presetCanaryGuangdong environment. The `Block presetCanaryGuangdong` is same as `Block staging`.
         */
        presetCanaryGuangdong: outputs.dcdn.ErEnvConfPresetCanaryGuangdong;
        /**
         * The configuration of a presetCanaryGuangxi environment. The `Block presetCanaryGuangxi` is same as `Block staging`.
         */
        presetCanaryGuangxi: outputs.dcdn.ErEnvConfPresetCanaryGuangxi;
        /**
         * The configuration of a presetCanaryGuizhou environment. The `Block presetCanaryGuizhou` is same as `Block staging`.
         */
        presetCanaryGuizhou: outputs.dcdn.ErEnvConfPresetCanaryGuizhou;
        /**
         * The configuration of a presetCanaryHainan environment. The `Block presetCanaryHainan` is same as `Block staging`.
         */
        presetCanaryHainan: outputs.dcdn.ErEnvConfPresetCanaryHainan;
        /**
         * The configuration of a presetCanaryHebei environment. The `Block presetCanaryHebei` is same as `Block staging`.
         */
        presetCanaryHebei: outputs.dcdn.ErEnvConfPresetCanaryHebei;
        /**
         * The configuration of a presetCanaryHeilongjiang environment. The `Block presetCanaryHeilongjiang` is same as `Block staging`.
         */
        presetCanaryHeilongjiang: outputs.dcdn.ErEnvConfPresetCanaryHeilongjiang;
        /**
         * The configuration of a presetCanaryHenan environment. The `Block presetCanaryHenan` is same as `Block staging`.
         */
        presetCanaryHenan: outputs.dcdn.ErEnvConfPresetCanaryHenan;
        /**
         * The configuration of a presetCanaryHongKong environment. The `Block presetCanaryHongKong` is same as `Block staging`.
         */
        presetCanaryHongKong: outputs.dcdn.ErEnvConfPresetCanaryHongKong;
        /**
         * The configuration of a presetCanaryHubei environment. The `Block presetCanaryHubei` is same as `Block staging`.
         */
        presetCanaryHubei: outputs.dcdn.ErEnvConfPresetCanaryHubei;
        /**
         * The configuration of a presetCanaryHunan environment. The `Block presetCanaryHunan` is same as `Block staging`.
         */
        presetCanaryHunan: outputs.dcdn.ErEnvConfPresetCanaryHunan;
        /**
         * The configuration of a presetCanaryJiangsu environment. The `Block presetCanaryJiangsu` is same as `Block staging`.
         */
        presetCanaryJiangsu: outputs.dcdn.ErEnvConfPresetCanaryJiangsu;
        /**
         * The configuration of a presetCanaryJiangxi environment. The `Block presetCanaryJiangxi` is same as `Block staging`.
         */
        presetCanaryJiangxi: outputs.dcdn.ErEnvConfPresetCanaryJiangxi;
        /**
         * The configuration of a presetCanaryJilin environment. The `Block presetCanaryJilin` is same as `Block staging`.
         */
        presetCanaryJilin: outputs.dcdn.ErEnvConfPresetCanaryJilin;
        /**
         * The configuration of a presetCanaryLiaoning environment. The `Block presetCanaryLiaoning` is same as `Block staging`.
         */
        presetCanaryLiaoning: outputs.dcdn.ErEnvConfPresetCanaryLiaoning;
        /**
         * The configuration of a presetCanaryMacau environment. The `Block presetCanaryMacau` is same as `Block staging`.
         */
        presetCanaryMacau: outputs.dcdn.ErEnvConfPresetCanaryMacau;
        /**
         * The configuration of a presetCanaryNeimenggu environment. The `Block presetCanaryNeimenggu` is same as `Block staging`.
         */
        presetCanaryNeimenggu: outputs.dcdn.ErEnvConfPresetCanaryNeimenggu;
        /**
         * The configuration of a presetCanaryNingxia environment. The `Block presetCanaryNingxia` is same as `Block staging`.
         */
        presetCanaryNingxia: outputs.dcdn.ErEnvConfPresetCanaryNingxia;
        /**
         * The configuration of a presetCanaryOverseas environment. The `Block presetCanaryOverseas` is same as `Block staging`.
         */
        presetCanaryOverseas: outputs.dcdn.ErEnvConfPresetCanaryOverseas;
        /**
         * The configuration of a presetCanaryQinghai environment. The `Block presetCanaryQinghai` is same as `Block staging`.
         */
        presetCanaryQinghai: outputs.dcdn.ErEnvConfPresetCanaryQinghai;
        /**
         * The configuration of a presetCanaryShaanxi environment. The `Block presetCanaryShaanxi` is same as `Block staging`.
         */
        presetCanaryShaanxi: outputs.dcdn.ErEnvConfPresetCanaryShaanxi;
        /**
         * The configuration of a presetCanaryShandong environment. The `Block presetCanaryShandong` is same as `Block staging`.
         */
        presetCanaryShandong: outputs.dcdn.ErEnvConfPresetCanaryShandong;
        /**
         * The configuration of a presetCanaryShanghai environment. The `Block presetCanaryShanghai` is same as `Block staging`.
         */
        presetCanaryShanghai: outputs.dcdn.ErEnvConfPresetCanaryShanghai;
        /**
         * The configuration of a presetCanaryShanxi environment. The `Block presetCanaryShanxi` is same as `Block staging`.
         */
        presetCanaryShanxi: outputs.dcdn.ErEnvConfPresetCanaryShanxi;
        /**
         * The configuration of a presetCanarySichuan environment. The `Block presetCanarySichuan` is same as `Block staging`.
         */
        presetCanarySichuan: outputs.dcdn.ErEnvConfPresetCanarySichuan;
        /**
         * The configuration of a presetCanaryTaiwan environment. The `Block presetCanaryTaiwan` is same as `Block staging`.
         */
        presetCanaryTaiwan: outputs.dcdn.ErEnvConfPresetCanaryTaiwan;
        /**
         * The configuration of a presetCanaryTianjin environment. The `Block presetCanaryTianjin` is same as `Block staging`.
         */
        presetCanaryTianjin: outputs.dcdn.ErEnvConfPresetCanaryTianjin;
        /**
         * The configuration of a presetCanaryXinjiang environment. The `Block presetCanaryXinjiang` is same as `Block staging`.
         */
        presetCanaryXinjiang: outputs.dcdn.ErEnvConfPresetCanaryXinjiang;
        /**
         * The configuration of a presetCanaryXizang environment. The `Block presetCanaryXizang` is same as `Block staging`.
         */
        presetCanaryXizang: outputs.dcdn.ErEnvConfPresetCanaryXizang;
        /**
         * The configuration of a presetCanaryYunnan environment. The `Block presetCanaryYunnan` is same as `Block staging`.
         */
        presetCanaryYunnan: outputs.dcdn.ErEnvConfPresetCanaryYunnan;
        /**
         * The configuration of a presetCanaryZhejiang environment. The `Block presetCanaryZhejiang` is same as `Block staging`.
         */
        presetCanaryZhejiang: outputs.dcdn.ErEnvConfPresetCanaryZhejiang;
        /**
         * The configuration of a production environment. The `Block production` is same as `Block staging`.
         */
        production: outputs.dcdn.ErEnvConfProduction;
        /**
         * The configuration of a staging environment. See the following `Block staging`.
         */
        staging: outputs.dcdn.ErEnvConfStaging;
    }

    export interface ErEnvConfPresetCanaryAnhui {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryBeijing {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryChongqing {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryFujian {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryGansu {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryGuangdong {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryGuangxi {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryGuizhou {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHainan {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHebei {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHeilongjiang {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHenan {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHongKong {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHubei {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryHunan {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryJiangsu {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryJiangxi {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryJilin {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryLiaoning {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryMacau {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryNeimenggu {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryNingxia {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryOverseas {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryQinghai {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryShaanxi {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryShandong {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryShanghai {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryShanxi {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanarySichuan {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryTaiwan {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryTianjin {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryXinjiang {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryXizang {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryYunnan {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfPresetCanaryZhejiang {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfProduction {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface ErEnvConfStaging {
        /**
         * Allowed DCDN domain names.
         */
        allowedHosts: string[];
        /**
         * The version number of the code.
         */
        codeRev?: string;
        /**
         * The specification of the CPU time slice. Valid values: `5ms`, `50ms`, `100ms`.
         */
        specName: string;
    }

    export interface GetDomainsDomain {
        /**
         * Indicates the name of the certificate.
         */
        certName: string;
        /**
         * The canonical name (CNAME) of the accelerated domain.
         */
        cname: string;
        /**
         * The reason that causes the review failure.
         */
        description: string;
        /**
         * The name of the DCDN Domain.
         */
        domainName: string;
        /**
         * The time when the accelerated domain was last modified.
         */
        gmtModified: string;
        /**
         * The ID of the DCDN Domain.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The acceleration region.
         */
        scope: string;
        /**
         * The origin information.
         */
        sources: outputs.dcdn.GetDomainsDomainSource[];
        /**
         * Indicates whether the SSL certificate is enabled.
         */
        sslProtocol: string;
        /**
         * Indicates the public key of the certificate.
         */
        sslPub: string;
        /**
         * The status of DCDN Domain.
         */
        status: string;
    }

    export interface GetDomainsDomainSource {
        /**
         * The origin address.
         */
        content: string;
        /**
         * The status of the origin.
         */
        enabled: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The priority of the origin if multiple origins are specified.
         */
        priority: string;
        /**
         * The type of the origin. Valid values:
         */
        type: string;
        /**
         * The weight of the origin if multiple origins are specified.
         */
        weight: string;
    }

    export interface GetIpaDomainsDomain {
        /**
         * CertName.
         */
        certName: string;
        /**
         * The CNAME assigned to the domain name.
         */
        cname: string;
        /**
         * The time when the accelerated domain name was created.
         */
        createTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The accelerated domain names.
         */
        domainName: string;
        /**
         * The ID of the Ipa Domain.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The accelerated region.
         */
        scope: string;
        /**
         * The information about the origin server.
         */
        sources: outputs.dcdn.GetIpaDomainsDomainSource[];
        /**
         * Indicates whether the Security Socket Layer (SSL) certificate is enabled.
         */
        sslProtocol: string;
        /**
         * Indicates the public key of the certificate if the HTTPS protocol is enabled.
         */
        sslPub: string;
        /**
         * The status of the accelerated domain name.
         */
        status: string;
    }

    export interface GetIpaDomainsDomainSource {
        /**
         * The address of the origin server.
         */
        content: string;
        /**
         * The custom port.
         */
        port: number;
        /**
         * The priority of the origin server if multiple origin servers are specified.
         */
        priority: string;
        /**
         * The type of the origin server.
         */
        type: string;
        /**
         * The weight of the origin server if multiple origin servers are specified.
         */
        weight: number;
    }

    export interface GetWafDomainsDomain {
        /**
         * The client ip tag.
         */
        clientIpTag: string;
        /**
         * Protection policy type.
         */
        defenseScenes: outputs.dcdn.GetWafDomainsDomainDefenseScene[];
        /**
         * The accelerated domain name.
         */
        domainName: string;
        /**
         * The ID of the Waf Domain.
         */
        id: string;
    }

    export interface GetWafDomainsDomainDefenseScene {
        /**
         * The type of protection policy.
         */
        defenseScene: string;
        /**
         * The protection policy ID.
         */
        policyId: string;
    }

    export interface GetWafPoliciesPolicy {
        /**
         * The first ID of the resource.
         */
        dcdnWafPolicyId: string;
        /**
         * The type of protection policy.
         */
        defenseScene: string;
        /**
         * The number of domain names that use this protection policy.
         */
        domainCount: number;
        /**
         * The time when the protection policy was modified.
         */
        gmtModified: string;
        /**
         * The ID of the Waf Policy.
         */
        id: string;
        /**
         * The name of the protection policy.
         */
        policyName: string;
        /**
         * The type of the protection policy.
         */
        policyType: string;
        /**
         * The number of protection rules in this protection policy.
         */
        ruleCount: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetWafRulesWafRule {
        /**
         * Specifies the action of the rule.
         */
        action: string;
        /**
         * Whether to turn on Frequency Control, on/off
         */
        ccStatus: string;
        /**
         * The blocked regions in the Chinese mainland, separated by commas (,).
         */
        cnRegionList: string;
        /**
         * The trigger condition of the rule.
         */
        conditions: outputs.dcdn.GetWafRulesWafRuleCondition[];
        /**
         * The type of protection policy. The following scenarios are supported:-waf_group:Web basic protection-custom_acl: Custom protection policy-whitelist: whitelist
         */
        defenseScene: string;
        /**
         * The effective range of the frequency control blacklist.
         */
        effect: string;
        /**
         * Revised the time. The date format is based on ISO8601 notation and uses UTC +0 time in the format of yyyy-MM-ddTHH:mm:ssZ.
         */
        gmtModified: string;
        /**
         * The ID of the Waf Rule.
         */
        id: string;
        /**
         * The effective range of the frequency control blacklist.
         */
        otherRegionList: string;
        /**
         * The protection policy ID.
         */
        policyId: string;
        /**
         * The rules of rate limiting.
         */
        rateLimits: outputs.dcdn.GetWafRulesWafRuleRateLimit[];
        /**
         * The regular expression.
         */
        regularRules: string[];
        /**
         * The type of the regular expression. If the value of the tags field contains waf_group, you can specify this field.
         */
        regularTypes: string[];
        /**
         * Filter by IP address.
         */
        remoteAddrs: string[];
        /**
         * The name of the protection rule.
         */
        ruleName: string;
        /**
         * List of protection scenarios
         */
        scenes: string[];
        /**
         * The information about the HTTP status code.
         */
        status: string;
        /**
         * The id of the waf rule group.
         */
        wafGroupIds: string;
        /**
         * The first ID of the resource
         */
        wafRuleId: string;
    }

    export interface GetWafRulesWafRuleCondition {
        /**
         * The match field.
         */
        key: string;
        /**
         * The logical symbol.
         */
        opValue: string;
        /**
         * The subfield of the target field.
         */
        subKey: string;
        /**
         * The match content. Separate multiple values with commas (,).
         */
        values: string;
    }

    export interface GetWafRulesWafRuleRateLimit {
        /**
         * The statistical interval. Valid values: 5 to 1800. Unit: seconds.
         */
        interval: number;
        /**
         * The information about the HTTP status code.
         */
        statuses: outputs.dcdn.GetWafRulesWafRuleRateLimitStatus[];
        /**
         * The subfield of the target field.
         */
        subKey: string;
        /**
         * The statistical field for frequency control.
         */
        target: string;
        /**
         * The trigger threshold of rate limiting. Valid values: 2 to 500000. Unit: requests.
         */
        threshold: number;
        /**
         * The validity period of the blacklist. Valid values: 60 to 86400. Unit: seconds.
         */
        ttl: number;
    }

    export interface GetWafRulesWafRuleRateLimitStatus {
        code: string;
        /**
         * The number of times that the HTTP status code that was returned.
         */
        count: number;
        /**
         * The percentage of HTTP status codes.
         */
        ratio: number;
    }

    export interface IpaDomainSource {
        /**
         * The address of the origin server. You can specify an IP address or a domain name.
         */
        content: string;
        /**
         * The custom port number. Valid values: `0` to `65535`.
         */
        port: number;
        /**
         * The priority of the origin server. Valid values: `20` and `30`. Default value: `20`. A value of 20 specifies that the origin is a primary origin. A value of 30 specifies that the origin is a secondary origin.
         */
        priority: string;
        /**
         * The type of the origin server. Valid values: `ipaddr`, `domain`, `oss`.
         */
        type: string;
        /**
         * The weight of the origin server. You must specify a value that is less than `100`. Default value: `10`.
         */
        weight: number;
    }

    export interface WafRuleCondition {
        /**
         * The match field.
         */
        key: string;
        /**
         * The logical symbol.
         */
        opValue: string;
        /**
         * The match subfield.
         */
        subKey?: string;
        /**
         * The match content. Separate multiple values with commas (,).
         */
        values?: string;
    }

    export interface WafRuleRateLimit {
        /**
         * Statistical duration, 5-1800.
         */
        interval?: number;
        /**
         * The status of the waf rule. Valid values: `on` and `off`. Default value: on.
         */
        status?: outputs.dcdn.WafRuleRateLimitStatus;
        /**
         * The match subfield.
         */
        subKey?: string;
        /**
         * The statistical field for frequency control. Currently, `IP`, `Header`, `Query String Parameter`, `Cookie Name`, `Session` is supported.
         */
        target?: string;
        /**
         * The trigger threshold of rate limiting. Valid values: 2 to 500000. Unit: requests.
         */
        threshold?: number;
        /**
         * The validity period of the blacklist. Valid values: 60 to 86400. Unit: seconds.
         */
        ttl?: number;
    }

    export interface WafRuleRateLimitStatus {
        /**
         * The HTTP status code returned.
         */
        code?: string;
        /**
         * The number of times that the HTTP status code that was returned. Valid values: 2 to 50000. You can configure only one of the `ratio` and `count` fields.
         */
        count?: number;
        /**
         * The percentage of HTTP status codes. Valid values: 1 to 100. You can configure only one of the `ratio` and `count` fields.
         */
        ratio?: number;
    }

}

export namespace ddos {
    export interface DomainResourceProxyType {
        /**
         * the port number. This field is required and must be an integer. **NOTE:** From version 1.206.0, `proxyPorts` can be modified.
         */
        proxyPorts?: number[];
        /**
         * the protocol type. This field is required and must be a string. Valid values: `http`, `https`, `websocket`, and `websockets`.
         */
        proxyType?: string;
    }

    export interface GetDdosBgpInstancesInstance {
        /**
         * The instance's elastic defend bandwidth.
         */
        bandwidth: number;
        /**
         * The instance's base defend bandwidth.
         */
        baseBandwidth: number;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's count of ip config.
         */
        ipCount: number;
        /**
         * The instance's IP version.
         */
        ipType: string;
        /**
         * The instance's remark.
         */
        name: string;
        /**
         * Normal defend bandwidth of the instance. The unit is Gbps.
         */
        normalBandwidth: number;
        /**
         * A region of instance.
         */
        region: string;
        /**
         * The instance's type.
         */
        type: string;
    }

    export interface GetDdosBgpIpsIp {
        /**
         * The ID of the Ip. The value formats as `<instance_id>:<ip>`.
         */
        id: string;
        /**
         * The ID of the native protection enterprise instance to be operated.
         */
        instanceId: string;
        /**
         * The IP address.
         */
        ip: string;
        /**
         * The type of cloud asset to which the IP address belongs.
         */
        product: string;
        /**
         * The current state of the IP address.
         */
        status: string;
    }

    export interface GetDdosCooDomainResourcesResource {
        /**
         * The IP addresses in the blacklist for the domain name.
         */
        blackLists: string[];
        /**
         * Whether frequency control guard (CC guard) is enabled. Values: `True`: Opened, `False`: Not enabled.
         */
        ccEnabled: boolean;
        /**
         * Whether custom frequency control guard (CC guard) is enabled. Values: `True`: Opened, `False`: Not enabled.
         */
        ccRuleEnabled: boolean;
        /**
         * The mode of the Frequency Control policy.
         */
        ccTemplate: string;
        /**
         * The name of the certificate.
         */
        certName: string;
        /**
         * The domain name of the website that you want to add to the instance.
         */
        domain: string;
        /**
         * Whether Http2.0 is enabled.
         */
        http2Enable: boolean;
        /**
         * The advanced HTTPS settings.
         */
        httpsExt: string;
        /**
         * The ID of the Domain Resource.
         */
        id: string;
        /**
         * A list ID of instance that you want to associate.
         */
        instanceIds: string[];
        /**
         * The type of backload algorithm.
         */
        policyMode: string;
        /**
         * Whether the website service forwarding rules have been turned on.
         */
        proxyEnabled: boolean;
        /**
         * Protocol type and port number information.
         */
        proxyTypes: outputs.ddos.GetDdosCooDomainResourcesResourceProxyType[];
        /**
         * Server address information of the source station.
         */
        realServers: string[];
        /**
         * Server address type.
         */
        rsType: number;
        /**
         * The type of the cipher suite.
         */
        sslCiphers: string;
        /**
         * The version of the TLS protocol.
         */
        sslProtocols: string;
        /**
         * The IP addresses in the whitelist for the domain name.
         */
        whiteLists: string[];
    }

    export interface GetDdosCooDomainResourcesResourceProxyType {
        /**
         * The forwarding port.
         */
        proxyPorts: number[];
        /**
         * Protocol type.
         */
        proxyType: string;
    }

    export interface GetDdosCooInstancesInstance {
        /**
         * The instance's elastic defend bandwidth.
         */
        bandwidth: number;
        /**
         * The instance's base defend bandwidth.
         */
        baseBandwidth: number;
        /**
         * The creation time of the instance.
         */
        createTime: number;
        /**
         * The debt status of the instance.
         */
        debtStatus: number;
        /**
         * The instance's count of domain retransmission config.
         */
        domainCount: number;
        /**
         * The edition of the instance. The Valid Values : `0`, `1`, `2`, `9`.
         */
        edition: number;
        /**
         * The enabled of the instance. The Valid Values : `0`, `1`.
         */
        enabled: number;
        /**
         * The expiry time of the instance.
         */
        expireTime: number;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The ip mode of the instance. The Valid Values : `fnat`, `v6tov4`.
         */
        ipMode: string;
        /**
         * The ip version of the instance. The Valid Values : `Ipv4`, `Ipv6`.
         */
        ipVersion: string;
        /**
         * The instance's remark.
         */
        name: string;
        /**
         * The instance's count of port retransmission config.
         */
        portCount: number;
        /**
         * The remark of the instance.
         */
        remark: string;
        /**
         * The instance's business bandwidth.
         */
        serviceBandwidth: number;
        /**
         * The status of the instance. The Valid Values : `1`, `2`.
         */
        status: number;
    }

    export interface GetDdosCooPortsPort {
        /**
         * The source station port.
         */
        backendPort: string;
        /**
         * The forwarding port.
         */
        frontendPort: string;
        /**
         * The forwarding protocol.
         */
        frontendProtocol: string;
        /**
         * The ID of the Port.
         */
        id: string;
        /**
         * The Ddoscoo instance ID.
         */
        instanceId: string;
        /**
         * List of source IP addresses.
         */
        realServers: string[];
    }

    export interface SchedulerRuleRule {
        /**
         * The priority of the rule.
         */
        priority?: number;
        /**
         * The region where the interaction resource that is used in the scheduling rule is deployed. **NOTE:** This parameter is returned only if the RuleType parameter is set to 2.
         */
        regionId?: string;
        /**
         * The status of the scheduling rule.
         */
        status: number;
        /**
         * The address type of the interaction resource. Valid values:
         * `A`: IPv4 address.
         * `CNAME`: CNAME record.
         */
        type?: string;
        /**
         * The address of the interaction resource.
         */
        value?: string;
        /**
         * Required. The type of the linked resource. It is an Integer. Valid values:
         * `1`: The IP address of Anti-DDoS Pro or Anti-DDoS Premium
         * `2`: the IP address of the interaction resource (in the tiered protection scenario)
         * `3`: the IP address used to accelerate access (in the network acceleration scenario)
         * `6` the IP address of the interaction resource (in the cloud service interaction scenario)
         */
        valueType?: number;
    }

}

export namespace dds {
    export interface GetMongoInstancesInstance {
        availabilityZone: string;
        chargeType: string;
        creationTime: string;
        engine: string;
        engineVersion: string;
        expirationTime: string;
        id: string;
        instanceClass: string;
        instanceType: string;
        lockMode: string;
        mongos: outputs.dds.GetMongoInstancesInstanceMongo[];
        name: string;
        networkType: string;
        regionId: string;
        replication: string;
        shards: outputs.dds.GetMongoInstancesInstanceShard[];
        status: string;
        storage: number;
        tags: {[key: string]: any};
    }

    export interface GetMongoInstancesInstanceMongo {
        class: string;
        description: string;
        nodeId: string;
    }

    export interface GetMongoInstancesInstanceShard {
        class: string;
        description: string;
        nodeId: string;
        storage: number;
    }

}

export namespace dfs {
    export interface GetAccessGroupsGroup {
        /**
         * The length of `description` does not exceed 100 bytes.
         */
        accessGroupId: string;
        /**
         * The Name of Access Group. The length Of `accessGroupName` does not exceed 100 bytes.
         */
        accessGroupName: string;
        /**
         * The CreateTime of Access Group.
         */
        createTime: string;
        /**
         * The Description of Access Group. The length Of `description` does not exceed 100 bytes.
         */
        description: string;
        /**
         * The ID of the Access Group.
         */
        id: string;
        /**
         * The Number of attached mountpoint.
         */
        mountPointCount: number;
        /**
         * The NetworkType of Access Group. Valid values: `VPC`.
         */
        networkType: string;
        /**
         * The Number of access rule.
         */
        ruleCount: number;
    }

    export interface GetAccessRulesRule {
        /**
         * The resource ID of the Access Group.
         */
        accessGroupId: string;
        /**
         * The ID of the Access Rule.
         */
        accessRuleId: string;
        /**
         * The created time of the Access Rule.
         */
        createTime: string;
        /**
         * The description of the Access Rule.
         */
        description: string;
        /**
         * The resource ID of Access Rule.
         */
        id: string;
        /**
         * The NetworkSegment of the Access Rule.
         */
        networkSegment: string;
        /**
         * The priority of the Access Rule.
         */
        priority: number;
        /**
         * RWAccessType of the Access Rule. Valid values: `RDONLY`, `RDWR`.
         */
        rwAccessType: string;
    }

    export interface GetFileSystemsSystem {
        /**
         * The creation time of the File system.
         */
        createTime: string;
        /**
         * The description of the File system.
         */
        description: string;
        /**
         * The ID of the File System.
         */
        fileSystemId: string;
        /**
         * The name of the File system.
         */
        fileSystemName: string;
        /**
         * The ID of the File System.
         */
        id: string;
        /**
         * The number of Mount points.
         */
        mountPointCount: number;
        /**
         * The number of directories.
         */
        numberOfDirectories: number;
        /**
         * The number of files.
         */
        numberOfFiles: number;
        /**
         * The protocol type. Valid values: `HDFS`.
         */
        protocolType: string;
        /**
         * The preset throughput of the File system. Valid values: `1` to `1024`, Unit: MB/s.
         */
        provisionedThroughputInMiBps: number;
        /**
         * The capacity budget of the File system.
         */
        spaceCapacity: number;
        /**
         * Storage package Id.
         */
        storagePackageId: string;
        /**
         * The storage specifications of the File system. Valid values: `PERFORMANCE`, `STANDARD`.
         */
        storageType: string;
        /**
         * The throughput mode of the File system. Valid values: `Provisioned`, `Standard`.
         */
        throughputMode: string;
        /**
         * The used space of the File system.
         */
        usedSpaceSize: number;
        /**
         * The zone ID of the File system.
         */
        zoneId: string;
    }

    export interface GetMountPointsPoint {
        /**
         * The ID of the Access Group.
         */
        accessGroupId: string;
        /**
         * The created time of the Mount Point.
         */
        createTime: string;
        /**
         * The description of the Mount Point.
         */
        description: string;
        /**
         * The ID of the File System.
         */
        fileSystemId: string;
        /**
         * The ID of the Mount Point.
         */
        id: string;
        /**
         * The domain name of the Mount Point.
         */
        mountPointDomain: string;
        /**
         * The ID of the Mount Point.
         */
        mountPointId: string;
        /**
         * The network type of the Mount Point. Valid values: `VPC`.
         */
        networkType: string;
        /**
         * The status of the Mount Point. Valid values: `Active`, `Inactive`.
         */
        status: string;
        /**
         * The ID of the VPC network.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * A list of available configurations of the Zone.
         */
        options: outputs.dfs.GetZonesZoneOption[];
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetZonesZoneOption {
        /**
         * The protocol type. Valid values: `HDFS`.
         */
        protocolType: string;
        /**
         * The storage specifications of the File system. Valid values: `PERFORMANCE`, `STANDARD`.
         */
        storageType: string;
    }

}

export namespace directmail {
    export interface GetDomainsDomain {
        /**
         * Track verification.
         */
        cnameAuthStatus: string;
        /**
         * Indicates whether the CNAME record is successfully verified. Valid values: `0` and `1`. `0`: indicates the verification is successful. `1`: indicates that the verification fails.
         */
        cnameConfirmStatus: string;
        /**
         * The value of the CNAME record.
         */
        cnameRecord: string;
        /**
         * The time when the DNS record was created.
         */
        createTime: string;
        /**
         * The default domain name.
         */
        defaultDomain: string;
        /**
         * The value of the MX record.
         */
        dnsMx: string;
        /**
         * The value of the SPF record.
         */
        dnsSpf: string;
        /**
         * The value of the TXT ownership record.
         */
        dnsTxt: string;
        /**
         * The ID of the domain name.
         */
        domainId: string;
        /**
         * The domain name.
         */
        domainName: string;
        /**
         * The type of the domain.
         */
        domainType: string;
        /**
         * The status of ICP filing. Valid values: `0` and `1`. `0`: indicates that the domain name is not filed. `1`: indicates that the domain name is filed.
         */
        icpStatus: string;
        /**
         * The ID of the Domain.
         */
        id: string;
        /**
         * Indicates whether the MX record is successfully verified. Valid values: `0` and `1`. `0`: indicates the verification is successful. `1`: indicates that the verification fails.
         */
        mxAuthStatus: string;
        /**
         * The MX verification record provided by Alibaba Cloud DNS.
         */
        mxRecord: string;
        /**
         * Indicates whether the SPF record is successfully verified. Valid values: `0` and `1`. `0`: indicates the verification is successful. `1`: indicates that the verification fails.
         */
        spfAuthStatus: string;
        /**
         * The SPF verification record provided by Alibaba Cloud DNS.
         */
        spfRecord: string;
        /**
         * The status of the domain name. Valid values:`0` to `4`. `0`:Available, Passed. `1`: Unavailable, No passed. `2`: Available, cname no passed, icp no passed. `3`: Available, icp no passed. `4`: Available, cname no passed.
         */
        status: string;
        /**
         * The primary domain name.
         */
        tlDomainName: string;
        /**
         * The CNAME verification record provided by Alibaba Cloud DNS.
         */
        tracefRecord: string;
    }

    export interface GetMailAddressesAddress {
        /**
         * The sender address.
         */
        accountName: string;
        /**
         * The creation of the record time.
         */
        createTime: string;
        /**
         * On the quota limit.
         */
        dailyCount: string;
        /**
         * On the quota.
         */
        dailyReqCount: string;
        /**
         * Domain name status. Valid values: `0`, `1`.
         */
        domainStatus: string;
        /**
         * The ID of the Mail Address.
         */
        id: string;
        /**
         * The sender address ID.
         */
        mailAddressId: string;
        /**
         * Monthly quota limit.
         */
        monthCount: string;
        /**
         * Months amount.
         */
        monthReqCount: string;
        /**
         * Return address.
         */
        replyAddress: string;
        /**
         * If using STMP address status.
         */
        replyStatus: string;
        /**
         * Account type.
         */
        sendtype: string;
        /**
         * Account Status. Valid values: `0`, `1`. Freeze: 1, normal: 0.
         */
        status: string;
    }

    export interface GetReceiversReceiverse {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The ID of the Receivers.
         */
        id: string;
        /**
         * The Receivers Alias.
         */
        receiversAlias: string;
        /**
         * The first ID of the resource.
         */
        receiversId: string;
        /**
         * The name of the resource.
         */
        receiversName: string;
        /**
         * The status of the resource.
         */
        status: number;
    }

    export interface GetTagsTag {
        /**
         * The ID of the tag.
         */
        id: string;
        /**
         * The ID of the tag.
         */
        tagId: string;
        /**
         * The name of the tag.
         */
        tagName: string;
    }

}

export namespace dms {
    export interface GetEnterpriseDatabasesDatabase {
        /**
         * The name of the Database Directory.> PG Series databases will display the database name.
         */
        catalogName: string;
        /**
         * The ID of the physical library.
         */
        databaseId: string;
        /**
         * Database type.
         */
        dbType: string;
        /**
         * The DBA user ID of the target database.
         */
        dbaId: string;
        /**
         * The DBA nickname of the target Library.
         */
        dbaName: string;
        /**
         * Database encoding.
         */
        encoding: string;
        /**
         * The environment type of the database.
         */
        envType: string;
        /**
         * The database connection address.
         */
        host: string;
        /**
         * The Database ID, same value as `databaseId`.
         */
        id: string;
        /**
         * The instance ID of the target database.
         */
        instanceId: string;
        /**
         * Library Owner User ID list.
         */
        ownerIdLists: string[];
        /**
         * Library Owner nickname list.
         */
        ownerNameLists: string[];
        /**
         * The connection port of the database.
         */
        port: number;
        /**
         * The name of the database.> PG Series databases will display schema names.
         */
        schemaName: string;
        /**
         * Library search name.
         */
        searchName: string;
        /**
         * Database SID.> only Oracle Database Display.
         */
        sid: string;
        /**
         * Library status, value description:-**NORMAL**: NORMAL-**DISABLE**: Disabled-**OFFLINE**: OFFLINE-**NOT_EXIST**: does not exist
         */
        state: string;
    }

    export interface GetEnterpriseInstancesInstance {
        /**
         * The name of the data link for the database instance.
         */
        dataLinkName: string;
        /**
         * The logon password of the database instance.
         */
        databasePassword: string;
        /**
         * The logon username of the database instance.
         */
        databaseUser: string;
        /**
         * The ID of the database administrator (DBA) of the database instance.
         */
        dbaId: string;
        /**
         * The nickname of the DBA.
         */
        dbaNickName: string;
        /**
         * Indicates whether the online data description language (DDL) service was enabled for the database instance.
         */
        ddlOnline: number;
        /**
         * The ID of the Elastic Compute Service (ECS) instance to which the database instance belongs.
         */
        ecsInstanceId: string;
        /**
         * The region where the database instance resides.
         */
        ecsRegion: string;
        /**
         * The type of the environment to which the database instance belongs.
         */
        envType: string;
        /**
         * The timeout period for exporting the database instance.
         */
        exportTimeout: number;
        /**
         * The endpoint of the database instance.
         */
        host: string;
        id: string;
        /**
         * The alias of the database instance.
         */
        instanceAlias: string;
        /**
         * The ID of the database instance.
         */
        instanceId: string;
        instanceName: string;
        /**
         * The source of the database instance.
         */
        instanceSource: string;
        /**
         * The ID of the database instance.
         */
        instanceType: string;
        /**
         * The connection port of the database instance.
         */
        port: number;
        /**
         * The timeout period for querying the database instance.
         */
        queryTimeout: number;
        /**
         * The ID of the security rule for the database instance.
         */
        safeRuleId: string;
        /**
         * The system ID (SID) of the database instance.
         */
        sid: string;
        /**
         * Filter the results by status of the DMS Enterprise Instances. Valid values: `NORMAL`, `UNAVAILABLE`, `UNKNOWN`, `DELETED`, `DISABLE`.
         */
        status: string;
        /**
         * Indicates whether cross-database query was enabled for the database instance.
         */
        useDsql: number;
        /**
         * The ID of the Virtual Private Cloud (VPC) to which the database instance belongs.
         */
        vpcId: string;
    }

    export interface GetEnterpriseLogicDatabasesDatabase {
        /**
         * Logical Library alias.
         */
        alias: string;
        /**
         * Sub-Database ID.
         */
        databaseIds: string[];
        /**
         * Database type.
         */
        dbType: string;
        /**
         * Environment type, return value is as follows:-product: production environment-dev: development environment-pre: Advance Environment-test: test environment-sit:SIT environment-uat:UAT environment-pet: Pressure measurement environment-stag:STAG environment
         */
        envType: string;
        /**
         * Logic Database ID.
         */
        id: string;
        /**
         * Whether it is a logical Library, the return value is true.
         */
        logic: boolean;
        /**
         * The ID of the logical Library.
         */
        logicDatabaseId: string;
        /**
         * The user ID list of the logical library Owner.
         */
        ownerIdLists: string[];
        /**
         * The nickname list of the logical library Owner.
         */
        ownerNameLists: string[];
        /**
         * Logical Library name.
         */
        schemaName: string;
        /**
         * Logical library search name.
         */
        searchName: string;
    }

    export interface GetEnterpriseProxiesProxy {
        /**
         * The ID of the user who enabled the secure access proxy feature.
         */
        creatorId: string;
        /**
         * The nickname of the user who enabled the secure access proxy feature.
         */
        creatorName: string;
        /**
         * The port that was used by HTTPS clients to connect to the database instance.
         */
        httpsPort: number;
        /**
         * The ID of the Proxy.
         */
        id: string;
        /**
         * The ID of the database instance.
         */
        instanceId: string;
        /**
         * Indicates whether the internal endpoint is enabled. Default value: true.
         */
        privateEnable: boolean;
        /**
         * The internal endpoint.
         */
        privateHost: string;
        /**
         * Database protocol connection port number.
         */
        protocolPort: number;
        /**
         * Database protocol type, for example, MYSQL.
         */
        protocolType: string;
        /**
         * The ID of the secure access proxy.
         */
        proxyId: string;
        /**
         * Indicates whether the public endpoint is enabled.
         */
        publicEnable: boolean;
        /**
         * The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled. **Note:** When the public network address is in the **true** state, the returned public network address is a valid address with DNS resolution capability. When the public address is in the **false** state, the returned Public address is an invalid address without DNS resolution.
         */
        publicHost: string;
    }

    export interface GetEnterpriseProxyAccessesAccess {
        /**
         * The authorized account of the security agent.
         */
        accessId: string;
        accessSecret: string;
        createTime: string;
        /**
         * Security Protection authorization ID.
         */
        id: string;
        /**
         * Database account.
         */
        indepAccount: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The source information of the security access agent permission is enabled, and the return value is as follows:**Owner Authorization**: The UID of the owner in parentheses.**Work Order Authorization**: The ticket number in parentheses is the number of the user to apply for permission.
         */
        originInfo: string;
        /**
         * Security Protection authorization ID. After the target user is authorized by the security protection agent, the system automatically generates a security protection authorization ID, which is globally unique.
         */
        proxyAccessId: string;
        /**
         * The ID of the security agent.
         */
        proxyId: string;
        /**
         * The user ID.
         */
        userId: string;
        /**
         * User nickname.
         */
        userName: string;
        /**
         * User UID.
         */
        userUid: string;
    }

    export interface GetEnterpriseUsersUser {
        /**
         * The Alibaba Cloud unique ID (UID) of the user.
         */
        id: string;
        /**
         * The DingTalk number or mobile number of the user.
         */
        mobile: string;
        /**
         * The nickname of the user.
         */
        nickName: string;
        /**
         * The Alibaba Cloud unique ID (UID) of the parent account if the user corresponds to a Resource Access Management (RAM) user.
         */
        parentUid: number;
        /**
         * The list ids of the role that the user plays.
         */
        roleIds: number[];
        /**
         * The list names of the role that he user plays.
         */
        roleNames: string[];
        /**
         * The status of the user.
         */
        status: string;
        uid: string;
        /**
         * The ID of the user.
         */
        userId: string;
        /**
         * The nickname of the user.
         */
        userName: string;
    }

    export interface GetUserTenantsTenant {
        /**
         * The user tenant id.
         */
        id: string;
        /**
         * The status of the user tenant.
         */
        status: string;
        /**
         * The name of the user tenant.
         */
        tenantName: string;
        /**
         * The user tenant id. Same as id.
         */
        tid: string;
    }

}

export namespace dns {
    export interface AccessStrategyDefaultAddrPool {
        /**
         * The ID of the address pool in the primary address pool group.
         */
        addrPoolId: string;
        /**
         * The weight of the address pool in the primary address pool group.
         */
        lbaWeight?: number;
    }

    export interface AccessStrategyFailoverAddrPool {
        /**
         * The ID of the address pool in the secondary address pool group.
         */
        addrPoolId?: string;
        /**
         * The weight of the address pool in the secondary address pool group.
         */
        lbaWeight?: number;
    }

    export interface AccessStrategyLine {
        /**
         * The line code of the source region.
         */
        lineCode?: string;
    }

    export interface AddressPoolAddress {
        /**
         * The address that you want to add to the address pool.
         */
        address: string;
        /**
         * The source region of the address. expressed as a JSON string. The structure is as follows:
         */
        attributeInfo: string;
        /**
         * The weight of the address. **NOTE:** The attribute is valid when the attribute `lbaStrategy` is `RATIO`.
         */
        lbaWeight?: number;
        /**
         * The type of the address. Valid values:`SMART`, `ONLINE` and `OFFLINE`.
         */
        mode: string;
        /**
         * The description of the address.
         */
        remark?: string;
    }

    export interface CustomLineIpSegmentList {
        /**
         * The end IP address of the CIDR block.
         */
        endIp: string;
        /**
         * The start IP address of the CIDR block.
         */
        startIp: string;
    }

    export interface GetAccessStrategiesStrategy {
        /**
         * The primary/secondary switchover policy for address pool groups.
         */
        accessMode: string;
        /**
         * The first ID of the resource.
         */
        accessStrategyId: string;
        /**
         * The time when the access policy was created.
         */
        createTime: string;
        /**
         * The timestamp that indicates when the access policy was created.
         */
        createTimestamp: string;
        /**
         * The type of the primary address pool.
         */
        defaultAddrPoolType: string;
        /**
         * The address pools in the primary address pool group.
         */
        defaultAddrPools: outputs.dns.GetAccessStrategiesStrategyDefaultAddrPool[];
        /**
         * The number of addresses currently available in the primary address pool.
         */
        defaultAvailableAddrNum: number;
        /**
         * Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group.
         */
        defaultLatencyOptimization: string;
        /**
         * The load balancing policy of the primary address pool group.
         */
        defaultLbaStrategy: string;
        /**
         * The maximum number of addresses returned by the primary address pool set.
         */
        defaultMaxReturnAddrNum: number;
        /**
         * The minimum number of available addresses for the primary address pool set.
         */
        defaultMinAvailableAddrNum: number;
        /**
         * The type of the active address pool group.
         */
        effectiveAddrPoolGroupType: string;
        /**
         * The type of the secondary address pool.
         */
        failoverAddrPoolType: string;
        /**
         * The address pools in the secondary address pool group.
         */
        failoverAddrPools: outputs.dns.GetAccessStrategiesStrategyFailoverAddrPool[];
        /**
         * The number of available addresses in the standby address pool.
         */
        failoverAvailableAddrNum: number;
        /**
         * Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group.
         */
        failoverLatencyOptimization: string;
        /**
         * The load balancing policy of the secondary address pool group.
         */
        failoverLbaStrategy: string;
        /**
         * The maximum number of returned addresses in the standby address pool.
         */
        failoverMaxReturnAddrNum: number;
        /**
         * The minimum number of available addresses in the standby address pool.
         */
        failoverMinAvailableAddrNum: number;
        /**
         * The ID of the Access Strategy.
         */
        id: string;
        /**
         * The Id of the associated instance.
         */
        instanceId: string;
        /**
         * List of source regions.
         */
        lines: outputs.dns.GetAccessStrategiesStrategyLine[];
        /**
         * The type of the access policy.
         */
        strategyMode: string;
        /**
         * The name of the access policy.
         */
        strategyName: string;
    }

    export interface GetAccessStrategiesStrategyDefaultAddrPool {
        /**
         * The number of addresses in the address pool.
         */
        addrCount: number;
        /**
         * The ID of the address pool.
         */
        addrPoolId: string;
        /**
         * The weight of the address pool.
         */
        lbaWeight: number;
        /**
         * The name of the address pool.
         */
        name: string;
    }

    export interface GetAccessStrategiesStrategyFailoverAddrPool {
        /**
         * The number of addresses in the address pool.
         */
        addrCount: number;
        /**
         * The ID of the address pool.
         */
        addrPoolId: string;
        /**
         * The weight of the address pool.
         */
        lbaWeight: number;
        /**
         * The name of the address pool.
         */
        name: string;
    }

    export interface GetAccessStrategiesStrategyLine {
        /**
         * The code of the source region group.
         */
        groupCode: string;
        /**
         * The name of the source region group.
         */
        groupName: string;
        /**
         * The line code of the source region.
         */
        lineCode: string;
        /**
         * The line name of the source region.
         */
        lineName: string;
    }

    export interface GetAddressPoolsPool {
        /**
         * The first ID of the resource.
         */
        addressPoolId: string;
        /**
         * The name of the address pool.
         */
        addressPoolName: string;
        /**
         * The address that you want to add to the address pool.
         */
        addresses: outputs.dns.GetAddressPoolsPoolAddress[];
        /**
         * The time when the address pool was created.
         */
        createTime: string;
        /**
         * The timestamp that indicates when the address pool was created.
         */
        createTimestamp: string;
        /**
         * The ID of the Address Pool.
         */
        id: string;
        /**
         * The id of the instance.
         */
        instanceId: string;
        /**
         * The load balancing policy of the address pool.
         */
        lbaStrategy: string;
        /**
         * The ID of the health check task.
         */
        monitorConfigId: string;
        /**
         * Indicates whether health checks are configured.
         */
        monitorStatus: string;
        /**
         * The type of the address pool.
         */
        type: string;
        /**
         * The time when the address pool was updated.
         */
        updateTime: string;
        /**
         * The timestamp that indicates when the address pool was updated.
         */
        updateTimestamp: string;
    }

    export interface GetAddressPoolsPoolAddress {
        /**
         * The address that you want to add to the address pool.
         */
        address: string;
        /**
         * The source region of the address.
         */
        attributeInfo: string;
        /**
         * The weight of the address.
         */
        lbaWeight: number;
        /**
         * The type of the address.
         */
        mode: string;
        /**
         * The description of the address.
         */
        remark: string;
    }

    export interface GetAlidnsDomainGroupsGroup {
        /**
         * Number of domain names in the group.
         */
        domainCount: number;
        /**
         * Id of the domain group.
         */
        groupId: string;
        /**
         * The name of the domain group.
         */
        groupName: string;
        /**
         * Id of the instance.
         */
        id: string;
    }

    export interface GetAlidnsDomainsDomain {
        /**
         * Specifies whether the domain is from Alibaba Cloud or not.
         */
        aliDomain: boolean;
        /**
         * List of available TTLs.
         */
        availableTtls: number[];
        /**
         * DNS list of domain names in the resolution system.
         */
        dnsServers: string[];
        /**
         * ID of the domain.
         */
        domainId: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * Domain group ID, if not filled, the default is all groups.
         */
        groupId: string;
        /**
         * Name of group that contains the domain.
         */
        groupName: string;
        /**
         * The Id of resource.
         */
        id: string;
        /**
         * Whether it is in black hole.
         */
        inBlackHole: boolean;
        /**
         * Whether it is cleaning.
         */
        inClean: boolean;
        /**
         * Cloud analysis product ID.
         */
        instanceId: string;
        lineType: string;
        /**
         * Minimum TTL.
         */
        minTtl: number;
        /**
         * Punycode of the Chinese domain.
         */
        punyCode: string;
        /**
         * Tree-like analytical line list.
         */
        recordLineTreeJson: string;
        /**
         * Parse the line data list.
         */
        recordLines: outputs.dns.GetAlidnsDomainsDomainRecordLine[];
        /**
         * Whether it is a regional route.
         */
        regionLines: boolean;
        /**
         * The Id of resource group which the dns belongs.
         */
        remark: string;
        /**
         * The Id of resource group which the dns belongs.
         */
        resourceGroupId: string;
        /**
         * Whether to allow auxiliary dns.
         */
        slaveDns: boolean;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Cloud analysis version code.
         */
        versionCode: string;
        versionName: string;
    }

    export interface GetAlidnsDomainsDomainRecordLine {
        /**
         * The code of the parent line, or empty if there is none.
         */
        fatherCode: string;
        /**
         * Sub-line Code.
         */
        lineCode: string;
        /**
         * Parent line display name.
         */
        lineDisplayName: string;
        /**
         * Sub-line display name.
         */
        lineName: string;
    }

    export interface GetAlidnsInstancesInstance {
        /**
         * DNS security level.
         */
        dnsSecurity: string;
        /**
         * (Available in 1.124.1+) The domain name.
         */
        domain: string;
        /**
         * Number of domain names bound.
         */
        domainNumbers: string;
        /**
         * Id of the instance.
         */
        id: string;
        /**
         * Id of the instance resource.
         */
        instanceId: string;
        /**
         * (Available in 1.124.1+) The payment type of alidns instance.
         */
        paymentType: string;
        /**
         * Paid package version.
         */
        versionCode: string;
        /**
         * Paid package version name.
         */
        versionName: string;
    }

    export interface GetAlidnsRecordsRecord {
        /**
         * The domain name associated to the records.
         */
        domainName: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * ISP line. For checking all resolution lines enumeration please visit [Alibaba Cloud DNS doc](https://www.alibabacloud.com/help/doc-detail/34339.htm)
         */
        line: string;
        /**
         * Indicates whether the record is locked.
         */
        locked: boolean;
        /**
         * Priority of the `MX` record.
         */
        priority: number;
        /**
         * ID of the record.
         */
        recordId: string;
        /**
         * The remark of the domain record.  **NOTE:** Available in 1.144.0+.
         */
        remark: string;
        /**
         * Host record of the domain.
         */
        rr: string;
        /**
         * Record status. Valid values: `ENABLE` and `DISABLE`.
         */
        status: string;
        /**
         * TTL of the record.
         */
        ttl: number;
        /**
         * Record type. Valid values: `A`, `NS`, `MX`, `TXT`, `CNAME`, `SRV`, `AAAA`, `REDIRECT_URL`, `FORWORD_URL` .
         */
        type: string;
        /**
         * Host record value of the domain.
         */
        value: string;
    }

    export interface GetCustomLinesLine {
        /**
         * The Custom line Code.
         */
        code: string;
        /**
         * The first ID of the resource.
         */
        customLineId: string;
        /**
         * Line name.
         */
        customLineName: string;
        /**
         * The Domain name.
         */
        domainName: string;
        /**
         * The ID of the Custom Line.
         */
        id: string;
        /**
         * The IP segment list.
         */
        ipSegmentLists: outputs.dns.GetCustomLinesLineIpSegmentList[];
    }

    export interface GetCustomLinesLineIpSegmentList {
        /**
         * The end IP address of the CIDR block.
         */
        endIp: string;
        /**
         * The start IP address of the CIDR block.
         */
        startIp: string;
    }

    export interface GetDomainGroupsGroup {
        groupId: string;
        groupName: string;
    }

    export interface GetDomainRecordsRecord {
        domainName: string;
        hostRecord: string;
        line: string;
        locked: boolean;
        priority: number;
        recordId: string;
        status: string;
        ttl: number;
        type: string;
        value: string;
    }

    export interface GetDomainsDomain {
        /**
         * Specifies whether the domain is from Alibaba Cloud or not.
         */
        aliDomain: boolean;
        availableTtls: number[];
        /**
         * DNS list of domain names in the resolution system.
         */
        dnsServers: string[];
        /**
         * ID of the domain.
         */
        domainId: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * Domain group ID, if not filled, the default is all groups.
         */
        groupId: string;
        /**
         * Name of group that contains the domain.
         */
        groupName: string;
        /**
         * The Id of resource.
         */
        id: string;
        /**
         * Whether it is in black hole.
         */
        inBlackHole: boolean;
        /**
         * Whether it is cleaning.
         */
        inClean: boolean;
        /**
         * Cloud analysis product ID.
         */
        instanceId: string;
        lineType: string;
        /**
         * Minimum TTL.
         */
        minTtl: number;
        /**
         * Punycode of the Chinese domain.
         */
        punyCode: string;
        /**
         * Tree-like analytical line list.
         */
        recordLineTreeJson: string;
        recordLines: outputs.dns.GetDomainsDomainRecordLine[];
        /**
         * Whether it is a regional route.
         */
        regionLines: boolean;
        /**
         * The Id of resource group which the dns belongs.
         */
        remark: string;
        /**
         * The Id of resource group which the dns belongs.
         */
        resourceGroupId: string;
        /**
         * Whether to allow auxiliary dns.
         */
        slaveDns: boolean;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Cloud analysis version code.
         */
        versionCode: string;
        versionName: string;
    }

    export interface GetDomainsDomainRecordLine {
        fatherCode: string;
        lineCode: string;
        lineDisplayName: string;
        lineName: string;
    }

    export interface GetGroupsGroup {
        /**
         * Id of the group.
         */
        groupId: string;
        /**
         * Name of the group.
         */
        groupName: string;
    }

    export interface GetGtmInstancesInstance {
        /**
         * The alert notification methods.
         */
        alertConfigs: outputs.dns.GetGtmInstancesInstanceAlertConfig[];
        /**
         * The alert group.
         */
        alertGroups: string[];
        /**
         * The access type of the CNAME domain name.
         */
        cnameType: string;
        /**
         * The CreateTime of the Gtm Instance.
         */
        createTime: string;
        /**
         * The ExpireTime of the Gtm Instance.
         */
        expireTime: string;
        /**
         * The ID of the Gtm Instance.
         */
        id: string;
        /**
         * The ID of the Gtm Instance.
         */
        instanceId: string;
        /**
         * The name of the Gtm Instance.
         */
        instanceName: string;
        /**
         * The version of the instance.
         */
        packageEdition: string;
        /**
         * The paymentype of the resource.
         */
        paymentType: string;
        /**
         * The Public Network domain name access method.
         */
        publicCnameMode: string;
        /**
         * The CNAME access domain name.
         */
        publicRr: string;
        /**
         * The website domain name that the user uses on the Internet.
         */
        publicUserDomainName: string;
        /**
         * The domain name that is used to access GTM over the Internet.
         */
        publicZoneName: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The type of the access policy.
         */
        strategyMode: string;
        /**
         * The global time to live.
         */
        ttl: number;
    }

    export interface GetGtmInstancesInstanceAlertConfig {
        /**
         * Whether to configure DingTalk notifications.
         */
        dingtalkNotice: boolean;
        /**
         * Whether to configure mail notification.
         */
        emailNotice: boolean;
        /**
         * The Alarm Event Type.
         */
        noticeType: string;
        /**
         * Whether to configure SMS notification.
         */
        smsNotice: boolean;
    }

    export interface GetInstancesInstance {
        /**
         * DNS security level.
         */
        dnsSecurity: string;
        domain: string;
        /**
         * Number of domain names bound.
         */
        domainNumbers: string;
        /**
         * Id of the instance.
         */
        id: string;
        /**
         * Id of the instance resource.
         */
        instanceId: string;
        paymentType: string;
        /**
         * Paid package version.
         */
        versionCode: string;
        /**
         * Paid package version name.
         */
        versionName: string;
    }

    export interface GetRecordsRecord {
        /**
         * The domain name associated to the records.
         */
        domainName: string;
        /**
         * Host record of the domain.
         */
        hostRecord: string;
        /**
         * ISP line. Valid items are `default`, `telecom`, `unicom`, `mobile`, `oversea`, `edu`, `drpeng`, `btvn`, .etc. For checking all resolution lines enumeration please visit [Alibaba Cloud DNS doc](https://www.alibabacloud.com/help/doc-detail/34339.htm)
         */
        line: string;
        /**
         * Indicates whether the record is locked.
         */
        locked: boolean;
        /**
         * Priority of the `MX` record.
         */
        priority: number;
        /**
         * ID of the record.
         */
        recordId: string;
        /**
         * Record status. Valid items are `ENABLE` and `DISABLE`.
         */
        status: string;
        /**
         * TTL of the record.
         */
        ttl: number;
        /**
         * Record type. Valid items are `A`, `NS`, `MX`, `TXT`, `CNAME`, `SRV`, `AAAA`, `REDIRECT_URL`, `FORWORD_URL` .
         */
        type: string;
        /**
         * Host record value of the domain.
         */
        value: string;
    }

    export interface GetResolutionLinesLine {
        lineCode: string;
        /**
         * Line display name.
         */
        lineDisplayName: string;
        /**
         * Line name.
         */
        lineName: string;
    }

    export interface GtmInstanceAlertConfig {
        /**
         * Whether to configure DingTalk notifications. Valid values: `true`, `false`.
         */
        dingtalkNotice?: boolean;
        /**
         * Whether to configure mail notification. Valid values: `true`, `false`.
         */
        emailNotice?: boolean;
        /**
         * The Alarm Event Type.
         */
        noticeType?: string;
        /**
         * Whether to configure SMS notification. Valid values: `true`, `false`.
         */
        smsNotice?: boolean;
    }

    export interface MonitorConfigIspCityNode {
        /**
         * The code of the city node to monitor.
         */
        cityCode: string;
        /**
         * The code of the Internet provider service (ISP) node to monitor.
         */
        ispCode: string;
    }

}

export namespace drds {
    export interface GetInstancesInstance {
        /**
         * (Available in 1.196.0+) The connection string of the DRDS instance.
         */
        connectionString: string;
        /**
         * Creation time of the instance.
         */
        createTime: number;
        /**
         * The DRDS instance description.
         */
        description: string;
        /**
         * The ID of the DRDS instance.
         */
        id: string;
        /**
         * `Classic` for public classic network or `VPC` for private network.
         */
        networkType: string;
        /**
         * (Available in 1.196.0+) The connection port of the DRDS instance.
         */
        port: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * The DRDS Instance type.
         */
        type: string;
        /**
         * The DRDS Instance version.
         */
        version: number;
        /**
         * Zone ID the instance belongs to.
         */
        zoneId: string;
    }

}

export namespace dts {
    export interface GetConsumerChannelsChannel {
        /**
         * The ID of the consumer group.
         */
        consumerGroupId: string;
        /**
         * The name of the consumer group.
         */
        consumerGroupName: string;
        /**
         * The username of the consumer group.
         */
        consumerGroupUserName: string;
        /**
         * The time point when the client consumed the last message in the subscription channel.
         */
        consumptionCheckpoint: string;
        /**
         * The ID of the Consumer Channel.
         */
        id: string;
        /**
         * The message delay time, for the current time data subscription channel in the earliest time of unconsumed messages of the difference, in Unix timestamp format, which is measured in seconds.
         */
        messageDelay: number;
        /**
         * The total number of unconsumed messages.
         */
        unconsumedData: number;
    }

    export interface GetInstancesInstance {
        /**
         * Instance creation time
         */
        createTime: string;
        /**
         * The target database engine type.
         */
        destinationEndpointEngineName: string;
        /**
         * The destination instance region.
         */
        destinationRegion: string;
        /**
         * The ID of the subscription instance.
         */
        dtsInstanceId: string;
        /**
         * The ID of the instance.
         */
        id: string;
        /**
         * The type of the migration or synchronization instance.- The specifications of the migration instance: **xxlarge**, **xlarge**, **large**, **medium**, **small**.- The types of synchronization instances: **large**, **medium**, **small**, **micro**.
         */
        instanceClass: string;
        instanceName: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * Resource Group ID
         */
        resourceGroupId: string;
        /**
         * Source instance database engine type.
         */
        sourceEndpointEngineName: string;
        /**
         * The source instance region.
         */
        sourceRegion: string;
        /**
         * Instance status.
         */
        status: string;
        /**
         * The tag value corresponding to the tag key.
         */
        tags?: {[key: string]: any};
        /**
         * The instance type. Valid values: -**MIGRATION**: MIGRATION.-**SYNC**: synchronization.-**SUBSCRIBE**: SUBSCRIBE.
         */
        type: string;
    }

    export interface GetMigrationJobsJob {
        /**
         * Whether or not to execute DTS supports schema migration, full data migration, or full-data initialization.
         */
        dataInitialization: boolean;
        /**
         * Whether to perform incremental data migration for migration types or synchronization values include:
         */
        dataSynchronization: boolean;
        /**
         * The Migration object, in the format of JSON strings.
         */
        dbList: string;
        /**
         * The name of migrate the database.
         */
        destinationEndpointDataBaseName: string;
        /**
         * The type of destination database.
         */
        destinationEndpointEngineName: string;
        /**
         * The ID of destination instance.
         */
        destinationEndpointInstanceId: string;
        /**
         * The type of destination instance.
         */
        destinationEndpointInstanceType: string;
        /**
         * The ip of source endpoint.
         */
        destinationEndpointIp: string;
        /**
         * The SID of Oracle database.
         */
        destinationEndpointOracleSid: string;
        /**
         * The port of source endpoint.
         */
        destinationEndpointPort: string;
        /**
         * The region of destination instance.
         */
        destinationEndpointRegion: string;
        /**
         * The username of database account.
         */
        destinationEndpointUserName: string;
        /**
         * The Migration instance ID. The ID of `alicloud.dts.MigrationInstance`.
         */
        dtsInstanceId: string;
        /**
         * The ID of the Migration Job.
         */
        dtsJobId: string;
        /**
         * The name of synchronization job.
         */
        dtsJobName: string;
        /**
         * The ID of the Migration Job. Its value is same as `dtsJobId`.
         */
        id: string;
        /**
         * The payment type of the Migration Instance.
         */
        paymentType: string;
        /**
         * The name of migrate the database.
         */
        sourceEndpointDatabaseName: string;
        /**
         * The type of source database.
         */
        sourceEndpointEngineName: string;
        /**
         * The ID of source instance.
         */
        sourceEndpointInstanceId: string;
        /**
         * The type of source instance.
         */
        sourceEndpointInstanceType: string;
        /**
         * The ip of source endpoint.
         */
        sourceEndpointIp: string;
        /**
         * The SID of Oracle database.
         */
        sourceEndpointOracleSid: string;
        /**
         * The Alibaba Cloud account ID to which the source instance belongs.
         */
        sourceEndpointOwnerId: string;
        /**
         * The port of source endpoint.
         */
        sourceEndpointPort: string;
        /**
         * The region of source instance.
         */
        sourceEndpointRegion: string;
        /**
         * The name of the role configured for the cloud account to which the source instance belongs.
         */
        sourceEndpointRole: string;
        /**
         * The username of database account.
         */
        sourceEndpointUserName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Whether to perform a database table structure to migrate or initialization.
         */
        structureInitialization: boolean;
    }

    export interface GetSubscriptionJobsJob {
        /**
         * Subscription start time in Unix timestamp format.
         */
        checkpoint: string;
        /**
         * The creation time of subscription job instance.
         */
        createTime: string;
        /**
         * Subscription object, in the format of JSON strings.
         */
        dbList: string;
        /**
         * The ID of subscription job instance.
         */
        dtsInstanceId: string;
        /**
         * The ID of subscription job instance.
         */
        dtsJobId: string;
        /**
         * The name of subscription job instance.
         */
        dtsJobName: string;
        /**
         * The Expiration Time. Formatting with yyyy-MM-ddTHH:mm:ssZ(UTC time).
         */
        expireTime: string;
        /**
         * The ID of the Subscription Job.
         */
        id: string;
        /**
         * The payment type of the resource. Valid values: `Subscription`, `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * To subscribe to the name of the database.
         */
        sourceEndpointDatabaseName: string;
        /**
         * The source database type value is MySQL or Oracle.
         */
        sourceEndpointEngineName: string;
        /**
         * The ID of source instance. Only when the type of source database instance was RDS MySQL, PolarDB-X 1.0, PolarDB MySQL, this parameter can be available and must be set.
         */
        sourceEndpointInstanceId: string;
        /**
         * The type of source instance. Valid values: `RDS`, `PolarDB`, `DRDS`, `LocalInstance`, `ECS`, `Express`, `CEN`, `dg`.
         */
        sourceEndpointInstanceType: string;
        /**
         * The IP of source endpoint.
         */
        sourceEndpointIp: string;
        /**
         * The SID of Oracle Database. When the source database is self-built Oracle and the Oracle database is a non-RAC instance, this parameter is available and must be passed in.
         */
        sourceEndpointOracleSid: string;
        /**
         * The Alibaba Cloud account ID to which the source instance belongs. This parameter is only available when configuring data subscriptions across Alibaba Cloud accounts and must be passed in.
         */
        sourceEndpointOwnerId: string;
        /**
         * The  port of source database.
         */
        sourceEndpointPort: string;
        /**
         * The region of source database.
         */
        sourceEndpointRegion: string;
        /**
         * Both the authorization roles. When the source instance and configure subscriptions task of the Alibaba Cloud account is not the same as the need to pass the parameter, to specify the source of the authorization roles, to allow configuration subscription task of the Alibaba Cloud account to access the source of the source instance information.
         */
        sourceEndpointRole: string;
        /**
         * The username of source database instance account.
         */
        sourceEndpointUserName: string;
        /**
         * The status of the task. Valid values: `NotStarted`, `Normal`, `Abnormal`. When a task created, it is in this state of `NotStarted`. You can specify this state of `Normal` to start the job, and specify this state of `Abnormal` to stop the job.
         */
        status: string;
        /**
         * Whether to subscribe the DDL type of data. Valid values: `true`, `false`.
         */
        subscriptionDataTypeDdl: boolean;
        /**
         * Whether to subscribe the DML type of data. Valid values: `true`, `false`.
         */
        subscriptionDataTypeDml: boolean;
        /**
         * Network information.
         */
        subscriptionHosts: outputs.dts.GetSubscriptionJobsJobSubscriptionHost[];
        /**
         * The type of subscription instance network. Valid value: `classic`, `vpc`.
         */
        subscriptionInstanceNetworkType: string;
        /**
         * The ID of subscription instance vpc.
         */
        subscriptionInstanceVpcId: string;
        /**
         * The ID of subscription instance vswitch.
         */
        subscriptionInstanceVswitchId: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetSubscriptionJobsJobSubscriptionHost {
        /**
         * Classic network address.
         */
        privateHost: string;
        /**
         * Public network address.
         */
        publicHost: string;
        /**
         * VPC network address.
         */
        vpcHost: string;
    }

    export interface GetSynchronizationJobsJob {
        /**
         * Start time in Unix timestamp format.
         */
        checkpoint: string;
        createTime: string;
        /**
         * Whether to execute DTS supports schema migration, full data migration, or full-data initialization.
         */
        dataInitialization: boolean;
        /**
         * Whether to perform incremental data migration for migration types or synchronization.
         */
        dataSynchronization: boolean;
        /**
         * Migration object, in the format of JSON strings. For detailed definition instructions, please refer to [the description of migration, synchronization or subscription objects](https://help.aliyun.com/document_detail/209545.html).
         */
        dbList: string;
        /**
         * The name of migrate the database.
         */
        destinationEndpointDataBaseName: string;
        /**
         * The type of destination database. Valid values: `ADB20`, `ADB30`, `AS400`, `DATAHUB`, `DB2`, `GREENPLUM`, `KAFKA`, `MONGODB`, `MSSQL`, `MySQL`, `ORACLE`, `PolarDB`, `POLARDBX20`, `POLARDB_O`, `PostgreSQL`.
         */
        destinationEndpointEngineName: string;
        /**
         * The ID of destination instance.
         */
        destinationEndpointInstanceId: string;
        /**
         * The type of destination instance. Valid values: `ads`, `CEN`, `DATAHUB`, `DG`, `ECS`, `EXPRESS`, `GREENPLUM`, `MONGODB`, `OTHER`, `PolarDB`, `POLARDBX20`, `RDS`.
         */
        destinationEndpointInstanceType: string;
        /**
         * The ip of source endpoint.
         */
        destinationEndpointIp: string;
        /**
         * The SID of Oracle database.
         */
        destinationEndpointOracleSid: string;
        /**
         * The port of source endpoint.
         */
        destinationEndpointPort: string;
        /**
         * The region of destination instance.
         */
        destinationEndpointRegion: string;
        /**
         * The username of database account.
         */
        destinationEndpointUserName: string;
        dtsInstanceId: string;
        dtsJobId: string;
        /**
         * The name of synchronization job.
         */
        dtsJobName: string;
        expireTime: string;
        /**
         * The ID of synchronizing instance. It's the ID of resource `alicloud.dts.SynchronizationInstance`.
         */
        id: string;
        /**
         * The name of migrate the database.
         */
        sourceEndpointDatabaseName: string;
        /**
         * The type of source database. Valid values: `AS400`, `DB2`, `DMSPOLARDB`, `HBASE`, `MONGODB`, `MSSQL`, `MySQL`, `ORACLE`, `PolarDB`, `POLARDBX20`, `POLARDB_O`, `POSTGRESQL`, `TERADATA`.
         */
        sourceEndpointEngineName: string;
        /**
         * The ID of source instance.
         */
        sourceEndpointInstanceId: string;
        /**
         * The type of source instance. Valid values: `CEN`, `DG`, `DISTRIBUTED_DMSLOGICDB`, `ECS`, `EXPRESS`, `MONGODB`, `OTHER`, `PolarDB`, `POLARDBX20`, `RDS`.
         */
        sourceEndpointInstanceType: string;
        /**
         * The ip of source endpoint.
         */
        sourceEndpointIp: string;
        /**
         * The SID of Oracle database.
         */
        sourceEndpointOracleSid: string;
        /**
         * The Alibaba Cloud account ID to which the source instance belongs.
         */
        sourceEndpointOwnerId: string;
        /**
         * The port of source endpoint.
         */
        sourceEndpointPort: string;
        /**
         * The region of source instance.
         */
        sourceEndpointRegion: string;
        /**
         * The name of the role configured for the cloud account to which the source instance belongs.
         */
        sourceEndpointRole: string;
        /**
         * The username of database account.
         */
        sourceEndpointUserName: string;
        /**
         * The status of the resource. Valid values: `Synchronizing`, `Suspending`. You can stop the task by specifying `Suspending` and start the task by specifying `Synchronizing`.
         */
        status: string;
        /**
         * Whether to perform a database table structure to migrate or initialization values include:
         */
        structureInitialization: boolean;
        /**
         * Synchronization direction. Valid values: `Forward`, `Reverse`. Only when the property `syncArchitecture` of the `alicloud.dts.SynchronizationInstance` was `bidirectional` this parameter should be passed, otherwise this parameter should not be specified.
         */
        synchronizationDirection: string;
    }

}

export namespace eais {
    export interface GetInstancesInstance {
        /**
         * The ID of the ECS instance to be bound.
         */
        clientInstanceId: string;
        /**
         * The name of the ECS instance bound to the EAIS instance.
         */
        clientInstanceName: string;
        /**
         * The type of the ECS instance bound to the EAIS instance.
         */
        clientInstanceType: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the resource.
         */
        instanceId: string;
        /**
         * The name of the resource.
         */
        instanceName: string;
        /**
         * The type of the resource. Valid values: `eais.ei-a6.4xlarge`, `eais.ei-a6.2xlarge`, `eais.ei-a6.xlarge`, `eais.ei-a6.large`, `eais.ei-a6.medium`.
         */
        instanceType: string;
        /**
         * The status of the resource. Valid values: `Attaching`, `Available`, `Detaching`, `InUse`, `Starting`, `Unavailable`.
         */
        status: string;
        /**
         * The ID of the region to which the EAIS instance belongs.
         */
        zoneId: string;
    }

}

export namespace ebs {
    export interface GetDedicatedBlockStorageClustersCluster {
        /**
         * The available capacity of the dedicated block storage cluster. Unit: GiB.
         */
        availableCapacity: string;
        /**
         * The type of cloud disk that can be created by a dedicated block storage cluster.
         */
        category: string;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * The first ID of the resource
         */
        dedicatedBlockStorageClusterId: string;
        /**
         * The name of the resource
         */
        dedicatedBlockStorageClusterName: string;
        /**
         * Capacity to be delivered in GB.
         */
        deliveryCapacity: string;
        /**
         * The description of the dedicated block storage cluster.
         */
        description: string;
        /**
         * The expiration time of the dedicated block storage cluster, in the Unix timestamp format, in seconds.
         */
        expiredTime: string;
        id: string;
        /**
         * Cloud disk performance level, possible values:-PL0.-PL1.-PL2.-PL3.> Only valid in SupportedCategory = cloud_essd.
         */
        performanceLevel: string;
        /**
         * The ID of the resource group
         */
        resourceGroupId: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * This parameter is not supported.
         */
        supportedCategory: string;
        /**
         * The total capacity of the dedicated block storage cluster. Unit: GiB.
         */
        totalCapacity: string;
        /**
         * The dedicated block storage cluster performance type. Possible values:-Standard: Basic type. This type of dedicated block storage cluster can create an ESSD PL0 cloud disk.-Premium: performance type. This type of dedicated block storage cluster can create an ESSD PL1 cloud disk.
         */
        type: string;
        /**
         * The used (created disk) capacity of the current cluster, in GB
         */
        usedCapacity: string;
        /**
         * The zone ID  of the resource
         */
        zoneId: string;
    }

    export interface GetDiskReplicaGroupsGroup {
        /**
         * The description of the consistent replication group.
         */
        description: string;
        /**
         * The ID of the region to which the disaster recovery site belongs.
         */
        destinationRegionId: string;
        /**
         * The ID of the zone to which the disaster recovery site belongs.
         */
        destinationZoneId: string;
        /**
         * Consistent replication group name.
         */
        groupName: string;
        /**
         * The ID of the Disk Replica Group.
         */
        id: string;
        lastRecoverPoint: string;
        /**
         * The initial source region of the replication group.
         */
        primaryRegion: string;
        /**
         * The initial source available area of the replication group.
         */
        primaryZone: string;
        /**
         * The ID of the consistent replication group.
         */
        replicaGroupId: string;
        /**
         * The recovery point objective (RPO) of the replication pair-consistent group.
         */
        rpo: number;
        /**
         * Site information sources for replication pairs and consistent replication groups.
         */
        site: string;
        /**
         * The ID of the region to which the production site belongs.
         */
        sourceRegionId: string;
        /**
         * The ID of the zone to which the production site belongs.
         */
        sourceZoneId: string;
        /**
         * The initial destination region of the replication group.
         */
        standbyRegion: string;
        /**
         * The initial destination zone of the replication group.
         */
        standbyZone: string;
        /**
         * The status of the consistent replication group. Possible values:
         */
        status: string;
    }

    export interface GetDiskReplicaPairsPair {
        /**
         * The bandwidth for asynchronous data replication between cloud disks. The unit is Kbps. Value range:-10240 Kbps: equal to 10 Mbps.-20480 Kbps: equal to 20 Mbps.-51200 Kbps: equal to 50 Mbps.-102400 Kbps: equal to 100 Mbps.Default value: 10240.This parameter cannot be specified when the ChargeType value is POSTPAY. The system value is 0, which indicates that the disk is dynamically allocated according to data write changes during asynchronous replication.
         */
        bandwidth: string;
        /**
         * The description of the asynchronous replication relationship. 2 to 256 English or Chinese characters in length and cannot start with' http:// 'or' https.
         */
        description: string;
        /**
         * The ID of the standby disk.
         */
        destinationDiskId: string;
        /**
         * The ID of the region to which the disaster recovery site belongs.
         */
        destinationRegionId: string;
        /**
         * The ID of the zone to which the disaster recovery site belongs.
         */
        destinationZoneId: string;
        /**
         * The ID of the primary disk.
         */
        diskId: string;
        id: string;
        /**
         * The name of the asynchronous replication relationship. The length must be 2 to 128 characters in length and must start with a letter or Chinese name. It cannot start with http:// or https. It can contain Chinese, English, numbers, half-width colons (:), underscores (_), half-width periods (.), or dashes (-).
         */
        pairName: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The first ID of the resource
         */
        replicaPairId: string;
        /**
         * The ID of the resource group
         */
        resourceGroupId: string;
        /**
         * The RPO value set by the consistency group in seconds. Currently only 900 seconds are supported.
         */
        rpo: string;
        /**
         * The ID of the zone to which the production site belongs.
         */
        sourceZoneId: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetRegionsRegion {
        /**
         * The ID of the region.
         */
        regionId: string;
        /**
         * A list of Ebs Zones.
         */
        zones: outputs.ebs.GetRegionsRegionZone[];
    }

    export interface GetRegionsRegionZone {
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

}

export namespace eci {
    export interface ContainerGroupAcrRegistryInfo {
        /**
         * The domain name of the ACR Enterprise Edition instance. Defaults to all domain names of the corresponding instance. Support specifying individual domain names, multiple separated by half comma.
         */
        domains?: string[];
        /**
         * The ACR enterprise edition example ID.
         */
        instanceId?: string;
        /**
         * The name of the ACR enterprise edition instance.
         */
        instanceName?: string;
        /**
         * The ACR enterprise edition instance belongs to the region.
         */
        regionId?: string;
    }

    export interface ContainerGroupContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container group.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         */
        environmentVars?: outputs.eci.ContainerGroupContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The health check of the container.
         */
        livenessProbes: outputs.eci.ContainerGroupContainerLivenessProbe[];
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory?: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The structure of port.
         */
        ports?: outputs.eci.ContainerGroupContainerPort[];
        /**
         * The health check of the container.
         */
        readinessProbes: outputs.eci.ContainerGroupContainerReadinessProbe[];
        ready: boolean;
        restartCount: number;
        /**
         * The structure of volumeMounts.
         */
        volumeMounts?: outputs.eci.ContainerGroupContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface ContainerGroupContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters, digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupContainerLivenessProbe {
        /**
         * Health check using command line method.
         */
        execs?: outputs.eci.ContainerGroupContainerLivenessProbeExec[];
        /**
         * Threshold for the number of checks that are determined to have failed since the last successful check (must be consecutive failures), default is 3.
         */
        failureThreshold?: number;
        /**
         * Health check using HTTP request method.
         */
        httpGets?: outputs.eci.ContainerGroupContainerLivenessProbeHttpGet[];
        /**
         * Check the time to start execution, calculated from the completion of container startup.
         */
        initialDelaySeconds?: number;
        /**
         * Buffer time for the program to handle operations before closing.
         */
        periodSeconds?: number;
        /**
         * The check count threshold for re-identifying successful checks since the last failed check (must be consecutive successes), default is 1. Current must be 1.
         */
        successThreshold?: number;
        /**
         * Health check using TCP socket method.
         */
        tcpSockets?: outputs.eci.ContainerGroupContainerLivenessProbeTcpSocket[];
        /**
         * Check the timeout, the default is 1 second, the minimum is 1 second.
         */
        timeoutSeconds?: number;
    }

    export interface ContainerGroupContainerLivenessProbeExec {
        /**
         * The commands run by the init container.
         */
        commands?: string[];
    }

    export interface ContainerGroupContainerLivenessProbeHttpGet {
        /**
         * The relative file path.
         */
        path?: string;
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * The protocol type corresponding to the HTTP Get request when using the HTTP request method for health checks. Valid values: `HTTP`, `HTTPS`.
         */
        scheme?: string;
    }

    export interface ContainerGroupContainerLivenessProbeTcpSocket {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
    }

    export interface ContainerGroupContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface ContainerGroupContainerReadinessProbe {
        /**
         * Health check using command line method.
         */
        execs?: outputs.eci.ContainerGroupContainerReadinessProbeExec[];
        /**
         * Threshold for the number of checks that are determined to have failed since the last successful check (must be consecutive failures), default is 3.
         */
        failureThreshold?: number;
        /**
         * Health check using HTTP request method.
         */
        httpGets?: outputs.eci.ContainerGroupContainerReadinessProbeHttpGet[];
        /**
         * Check the time to start execution, calculated from the completion of container startup.
         */
        initialDelaySeconds?: number;
        /**
         * Buffer time for the program to handle operations before closing.
         */
        periodSeconds?: number;
        /**
         * The check count threshold for re-identifying successful checks since the last failed check (must be consecutive successes), default is 1. Current must be 1.
         */
        successThreshold?: number;
        /**
         * Health check using TCP socket method.
         */
        tcpSockets?: outputs.eci.ContainerGroupContainerReadinessProbeTcpSocket[];
        /**
         * Check the timeout, the default is 1 second, the minimum is 1 second.
         */
        timeoutSeconds?: number;
    }

    export interface ContainerGroupContainerReadinessProbeExec {
        /**
         * The commands run by the init container.
         */
        commands?: string[];
    }

    export interface ContainerGroupContainerReadinessProbeHttpGet {
        /**
         * The relative file path.
         */
        path?: string;
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * The protocol type corresponding to the HTTP Get request when using the HTTP request method for health checks. Valid values: `HTTP`, `HTTPS`.
         */
        scheme?: string;
    }

    export interface ContainerGroupContainerReadinessProbeTcpSocket {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
    }

    export interface ContainerGroupContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface ContainerGroupDnsConfig {
        /**
         * The list of DNS server IP addresses.
         */
        nameServers?: string[];
        /**
         * The structure of options.
         */
        options?: outputs.eci.ContainerGroupDnsConfigOption[];
        /**
         * The list of DNS lookup domains.
         */
        searches?: string[];
    }

    export interface ContainerGroupDnsConfigOption {
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupEciSecurityContext {
        /**
         * system.
         */
        sysctls?: outputs.eci.ContainerGroupEciSecurityContextSysctl[];
    }

    export interface ContainerGroupEciSecurityContextSysctl {
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupHostAlias {
        /**
         * Adds a host name.
         */
        hostnames?: string[];
        /**
         * Adds an IP address.
         */
        ip?: string;
    }

    export interface ContainerGroupImageRegistryCredential {
        /**
         * The password used to log on to the image repository. It is required when `imageRegistryCredential` is configured.
         */
        password: string;
        /**
         * The address of the image repository. It is required when `imageRegistryCredential` is configured.
         */
        server: string;
        /**
         * The username used to log on to the image repository. It is required when `imageRegistryCredential` is configured.
         */
        userName: string;
    }

    export interface ContainerGroupInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container group.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         */
        environmentVars?: outputs.eci.ContainerGroupInitContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image?: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory?: number;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * The structure of port.
         */
        ports?: outputs.eci.ContainerGroupInitContainerPort[];
        ready: boolean;
        restartCount: number;
        /**
         * The structure of volumeMounts.
         */
        volumeMounts?: outputs.eci.ContainerGroupInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface ContainerGroupInitContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters, digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface ContainerGroupInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface ContainerGroupVolume {
        /**
         * ConfigFileVolumeConfigFileToPaths.
         */
        configFileVolumeConfigFileToPaths?: outputs.eci.ContainerGroupVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId?: string;
        /**
         * The system type of DiskVolume.
         */
        diskVolumeFsType?: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver?: string;
        /**
         * The type of the mounted file system. The default value is determined by the script of FlexVolume.
         */
        flexVolumeFsType?: string;
        /**
         * The list of FlexVolume objects. Each object is a key-value pair contained in a JSON string.
         */
        flexVolumeOptions?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath?: string;
        /**
         * The nfs volume read only. Default to `false`.
         */
        nfsVolumeReadOnly?: boolean;
        /**
         * The address of the NFS server.
         *
         * > **NOTE:** Every volumes mounted must have name and type attributes.
         */
        nfsVolumeServer?: string;
        /**
         * The type of the volume.
         */
        type?: string;
    }

    export interface ContainerGroupVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content?: string;
        /**
         * The relative file path.
         */
        path?: string;
    }

    export interface GetContainerGroupsGroup {
        /**
         * The id if ContainerGroup.
         */
        containerGroupId: string;
        /**
         * The name of ContainerGroup.
         */
        containerGroupName: string;
        /**
         * A list of containers. Each element contains the following attributes:
         */
        containers: outputs.eci.GetContainerGroupsGroupContainer[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        discount: number;
        /**
         * The DNS settings.
         */
        dnsConfigs: outputs.eci.GetContainerGroupsGroupDnsConfig[];
        /**
         * The security context of the container group.
         */
        eciSecurityContexts: outputs.eci.GetContainerGroupsGroupEciSecurityContext[];
        /**
         * The ID of the ENI instance.
         */
        eniInstanceId: string;
        /**
         * The events of the container group. Maximum: `50`.
         */
        events: outputs.eci.GetContainerGroupsGroupEvent[];
        /**
         * The time when the container group failed to run due to overdue payments. The timestamp follows the UTC and RFC3339 formats.
         */
        expiredTime: string;
        /**
         * The time when the container failed to run tasks. The timestamp follows the UTC and RFC3339 formats.
         */
        failedTime: string;
        /**
         * The mapping between host names and IP addresses for a container in the container group.
         */
        hostAliases: outputs.eci.GetContainerGroupsGroupHostAlias[];
        /**
         * The ID of the Container Group.
         */
        id: string;
        /**
         * A list of init containers. Each element contains the following attributes:
         */
        initContainers: outputs.eci.GetContainerGroupsGroupInitContainer[];
        /**
         * The type of the ECS instance.
         */
        instanceType: string;
        /**
         * The public IP address of the container group.
         */
        internetIp: string;
        /**
         * The internal IP address of the container group.
         */
        intranetIp: string;
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The RAM role that the container group assumes. ECI and ECS share the same RAM role.
         */
        ramRoleName: string;
        /**
         * The ID of the resource group to which the container group belongs. If you have not specified a resource group for the container group, it is added to the default resource group.
         */
        resourceGroupId: string;
        /**
         * The restart policy of the container group.
         */
        restartPolicy: string;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The status of container.
         */
        status: string;
        /**
         * The time when all containers in the container group completed running the specified tasks. The timestamp follows the UTC and RFC 3339 formats. For example, 2018-08-02T15:00:00Z.
         */
        succeededTime: string;
        /**
         * The tags attached to the container group. Each tag is a key-value pair. You can attach up to 20 tags to a container group.
         */
        tags: {[key: string]: any};
        /**
         * The information about the mounted volume. You can mount up to 20 volumes.
         */
        volumes: outputs.eci.GetContainerGroupsGroupVolume[];
        /**
         * The if of vpc.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The IDs of the zones where the container groups are deployed. If this parameter is not set, the system automatically selects the zones. By default, no value is specified.
         */
        zoneId: string;
    }

    export interface GetContainerGroupsGroupContainer {
        /**
         * The arguments passed to the commands.
         */
        args: string[];
        /**
         * The commands run by the container.
         */
        commands: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        /**
         * The environment variables.
         */
        environmentVars: outputs.eci.GetContainerGroupsGroupContainerEnvironmentVar[];
        /**
         * The amount of GPU resources allocated to the container.
         */
        gpu: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The policy for pulling an image.
         */
        imagePullPolicy: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The exposed ports and protocols. Maximum: `100`.
         */
        ports: outputs.eci.GetContainerGroupsGroupContainerPort[];
        /**
         * Indicates whether the container is ready.
         */
        ready: boolean;
        /**
         * The number of times that the container has restarted.
         */
        restartCount: number;
        /**
         * The list of volumes mounted to the container.
         */
        volumeMounts: outputs.eci.GetContainerGroupsGroupContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir: string;
    }

    export interface GetContainerGroupsGroupContainerEnvironmentVar {
        /**
         * The name of the variable.
         */
        key: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port: number;
        /**
         * Valid values: `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface GetContainerGroupsGroupContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * Default value: `false`.
         */
        readOnly: boolean;
    }

    export interface GetContainerGroupsGroupDnsConfig {
        /**
         * The list of DNS server IP addresses.
         */
        nameServers: string[];
        /**
         * The list of objects. Each object is a name-value pair. The value is optional.
         */
        options: outputs.eci.GetContainerGroupsGroupDnsConfigOption[];
        /**
         * The list of DNS lookup domains.
         */
        searches: string[];
    }

    export interface GetContainerGroupsGroupDnsConfigOption {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupEciSecurityContext {
        /**
         * The system information.
         */
        sysctls: outputs.eci.GetContainerGroupsGroupEciSecurityContextSysctl[];
    }

    export interface GetContainerGroupsGroupEciSecurityContextSysctl {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupEvent {
        /**
         * The number of events.
         */
        count: number;
        /**
         * The time when the event started.
         */
        firstTimestamp: string;
        /**
         * The time when the event ended.
         */
        lastTimestamp: string;
        /**
         * The content of the event.
         */
        message: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The name of the event.
         */
        reason: string;
        /**
         * The type of the volume. Currently, the following types of volumes are supported: EmptyDirVolume, NFSVolume, ConfigFileVolume, and FlexVolume.
         */
        type: string;
    }

    export interface GetContainerGroupsGroupHostAlias {
        /**
         * The name of the host.
         */
        hostnames: string[];
        /**
         * The IP address of the container.
         */
        ip: string;
    }

    export interface GetContainerGroupsGroupInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args: string[];
        /**
         * The commands run by the container.
         */
        commands: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        /**
         * The environment variables.
         */
        environmentVars: outputs.eci.GetContainerGroupsGroupInitContainerEnvironmentVar[];
        /**
         * The amount of GPU resources allocated to the container.
         */
        gpu: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The policy for pulling an image.
         */
        imagePullPolicy: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The exposed ports and protocols. Maximum: `100`.
         */
        ports: outputs.eci.GetContainerGroupsGroupInitContainerPort[];
        /**
         * Indicates whether the container is ready.
         */
        ready: boolean;
        /**
         * The number of times that the container has restarted.
         */
        restartCount: number;
        /**
         * The list of volumes mounted to the container.
         */
        volumeMounts: outputs.eci.GetContainerGroupsGroupInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir: string;
    }

    export interface GetContainerGroupsGroupInitContainerEnvironmentVar {
        /**
         * The name of the variable.
         */
        key: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port: number;
        /**
         * Valid values: `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface GetContainerGroupsGroupInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * Default value: `false`.
         */
        readOnly: boolean;
    }

    export interface GetContainerGroupsGroupVolume {
        /**
         * The list of configuration file paths.
         */
        configFileVolumeConfigFileToPaths: outputs.eci.GetContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId: string;
        /**
         * The type of DiskVolume.
         */
        diskVolumeFsType: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver: string;
        /**
         * The type of the mounted file system. The default value is determined by the script of FlexVolume.
         */
        flexVolumeFsType: string;
        /**
         * The list of FlexVolume objects.
         */
        flexVolumeOptions: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath: string;
        /**
         * Default value: `false`.
         */
        nfsVolumeReadOnly: boolean;
        /**
         * The address of the NFS server.
         */
        nfsVolumeServer: string;
        /**
         * The type of the volume. Currently, the following types of volumes are supported: EmptyDirVolume, NFSVolume, ConfigFileVolume, and FlexVolume.
         */
        type: string;
    }

    export interface GetContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content: string;
        /**
         * The relative file path.
         */
        path: string;
    }

    export interface GetImageCachesCach {
        /**
         * The id of container group.
         */
        containerGroupId: string;
        /**
         * Image cache pulls image event information.
         */
        events: outputs.eci.GetImageCachesCachEvent[];
        /**
         * The time of expired.
         */
        expireDateTime: string;
        /**
         * The ID of the ECI Image Cache.
         */
        id: string;
        /**
         * The id of the ECI Image Cache.
         */
        imageCacheId: string;
        /**
         * The name of ECI Image Cache.
         */
        imageCacheName: string;
        /**
         * The list of cached images.
         */
        images: string[];
        /**
         * The progress of ECI Image Cache.
         */
        progress: string;
        /**
         * The id of snapshot.
         */
        snapshotId: string;
        /**
         * The status of ECI Image Cache.
         */
        status: string;
    }

    export interface GetImageCachesCachEvent {
        /**
         * Number of events.
         */
        count: number;
        /**
         * Start time.
         */
        firstTimestamp: string;
        /**
         * End time.
         */
        lastTimestamp: string;
        message: string;
        /**
         * The name of event.
         */
        name: string;
        /**
         * The type of event.
         */
        type: string;
    }

    export interface GetVirtualNodesNode {
        /**
         * The Number of CPU.
         */
        cpu: number;
        /**
         * The creation time of the virtual node.
         */
        createTime: string;
        /**
         * The ENI instance ID.
         */
        eniInstanceId: string;
        /**
         * The event list.
         */
        events: outputs.eci.GetVirtualNodesNodeEvent[];
        /**
         * The ID of the Virtual Node.
         */
        id: string;
        /**
         * The IP address of a public network.
         */
        internetIp: string;
        /**
         * The private IP address of the RDS instance.
         */
        intranetIp: string;
        /**
         * The memory size.
         */
        memory: number;
        /**
         * The ram role.
         */
        ramRoleName: string;
        /**
         * The resource group ID.
         */
        resourceGroupId: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The Status of the virtual node.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Of the virtual node number.
         */
        virtualNodeId: string;
        /**
         * The name of the virtual node.
         */
        virtualNodeName: string;
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone.
         */
        zoneId: string;
    }

    export interface GetVirtualNodesNodeEvent {
        /**
         * The number of occurrences.
         */
        count: number;
        /**
         * The first presentation time stamp.
         */
        firstTimestamp: string;
        /**
         * The most recent time stamp.
         */
        lastTimestamp: string;
        /**
         * The event of the message body.
         */
        message: string;
        /**
         * The name of the event.
         */
        name: string;
        /**
         * The causes of the incident.
         */
        reason: string;
        /**
         * The Event type.
         */
        type: string;
    }

    export interface GetZonesZone {
        /**
         * The endpoint of the region.
         */
        regionEndpoint: string;
        /**
         * The list of available zone ids.
         */
        zoneIds: string[];
    }

    export interface ImageCacheImageRegistryCredential {
        /**
         * The password of the Image Registry.
         */
        password?: string;
        /**
         * The address of Image Registry without `http://` or `https://`.
         */
        server?: string;
        /**
         * The user name of Image Registry.
         */
        userName?: string;
    }

    export interface OpenApiImageCacheImageRegistryCredential {
        password?: string;
        server?: string;
        userName?: string;
    }

    export interface VirtualNodeTaint {
        /**
         * The effect of the taint. Valid values: `NoSchedule`, `NoExecute` and `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The key of the taint.
         */
        key?: string;
        /**
         * The value of the taint.
         */
        value?: string;
    }

}

export namespace ecp {
    export interface GetInstanceTypesInstanceType {
        /**
         * The cpu core count of the current instance type.
         */
        cpuCoreCount: number;
        /**
         * The default resolution of the current instance type.
         */
        defaultResolution: string;
        /**
         * The list of available instance type.
         */
        instanceType: string;
        instanceTypeFamily: string;
        /**
         * The name of the current instance type.
         */
        name: string;
        /**
         * The English name of the current instance type.
         */
        nameEn: string;
    }

    export interface GetInstancesInstance {
        /**
         * Instance Description.
         */
        description: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID Of The Image.
         */
        imageId: string;
        /**
         * InstanceId.
         */
        instanceId: string;
        /**
         * Instance Name.
         */
        instanceName: string;
        /**
         * Instance Type.
         */
        instanceType: string;
        /**
         * The Key Name.
         */
        keyPairName: string;
        /**
         * The payment type.Valid values: `PayAsYouGo`,`Subscription`
         */
        paymentType: string;
        /**
         * Resolution.
         */
        resolution: string;
        /**
         * Security Group ID.
         */
        securityGroupId: string;
        /**
         * Instance Status.
         */
        status: string;
        /**
         * VNC login address.
         */
        vncUrl: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        zoneId: string;
    }

    export interface GetKeyPairsPair {
        /**
         * The ID of the Key Pair. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The Private Key of the Fingerprint.
         */
        keyPairFingerPrint: string;
        /**
         * The Key Name.
         */
        keyPairName: string;
    }

    export interface GetZonesZone {
        /**
         * String to filter results by zone id.
         */
        zoneId: string;
    }

}

export namespace ecs {
    export interface AutoProvisioningGroupLaunchTemplateConfig {
        instanceType?: string;
        maxPrice: string;
        priority: string;
        vswitchId: string;
        weightedCapacity: string;
    }

    export interface DedicatedHostNetworkAttribute {
        /**
         * The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
         */
        slbUdpTimeout?: number;
        /**
         * The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
         */
        udpTimeout?: number;
    }

    export interface EcsInstanceSetDataDisk {
        /**
         * The ID of the automatic snapshot policy applied to the system disk.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The category of the disk. Valid values: `cloudEfficiency`, `cloudSsd`, `cloudEssd`, `cloud`.
         */
        diskCategory: string;
        /**
         * The description of the data disk.
         */
        diskDescription?: string;
        /**
         * The name of the data disk.
         */
        diskName?: string;
        /**
         * The size of the data disk. Unit: GiB.
         * - When `diskCategory` is `cloudEfficiency`, Valid values: `20` to `32768`.
         * - When `diskCategory` is `cloudSsd`, Valid values: `20` to `32768`.
         * - When `diskCategory` is `cloudEssd`, Valid values: `20` to `32768`.
         * - When `diskCategory` is `cloud`, Valid values: `5` to `200`.
         */
        diskSize: number;
        encrypted?: boolean;
        /**
         * The KMS key ID corresponding to the data disk.
         */
        kmsKeyId?: string;
        /**
         * The performance level of the ESSD used as data disk. Valid values: `PL0`, `PL1`, `PL2`, `PL3`.
         */
        performanceLevel: string;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface EcsInstanceSetExcludeInstanceFilter {
        /**
         * The type of the excluded. Valid values: `InstanceId`, `InstanceName`.
         */
        key: string;
        /**
         * The value of the excluded. The identification of the excluded instances. It is a list of instance Ids or names.
         */
        values: string[];
    }

    export interface EcsInstanceSetNetworkInterface {
        /**
         * The description of ENI.
         */
        description?: string;
        /**
         * The name of ENI.
         */
        networkInterfaceName?: string;
        /**
         * The primary private IP address of ENI.
         */
        primaryIpAddress?: string;
        /**
         * The ID of the security group to which to assign secondary ENI.
         */
        securityGroupId: string;
        /**
         * The ID of the vSwitch to which to connect ENI.
         */
        vswitchId?: string;
    }

    export interface EcsLaunchTemplateDataDisk {
        /**
         * The category of the system disk. System disk type. Valid values: `all`, `cloud`, `ephemeralSsd`, `cloudEssd`, `cloudEfficiency`, `cloudSsd`, `localDisk`.
         */
        category?: string;
        /**
         * Specifies whether to release the system disk when the instance is released. Default to `true`.
         */
        deleteWithInstance?: boolean;
        /**
         * Description of instance launch template version 1. It can be [2, 256] characters in length. It cannot start with "http://" or "https://". The default value is null.
         */
        description?: string;
        /**
         * Encrypted the data in this disk.
         */
        encrypted?: boolean;
        /**
         * It has been deprecated from version 1.120.0, and use field `launchTemplateName` instead.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as the system disk. Valid Values: `PL0`, `PL1`, `PL2`, and `PL3`. Default to: `PL0`.
         */
        performanceLevel?: string;
        /**
         * Size of the system disk, measured in GB. Value range: [20, 500].
         */
        size?: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface EcsLaunchTemplateNetworkInterfaces {
        /**
         * Description of instance launch template version 1. It can be [2, 256] characters in length. It cannot start with "http://" or "https://". The default value is null.
         */
        description?: string;
        /**
         * It has been deprecated from version 1.120.0, and use field `launchTemplateName` instead.
         */
        name?: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp?: string;
        /**
         * The security group ID.
         */
        securityGroupId?: string;
        /**
         * When creating a VPC-Connected instance, you must specify its VSwitch ID.
         */
        vswitchId?: string;
    }

    export interface EcsLaunchTemplateSystemDisk {
        /**
         * The category of the system disk. System disk type. Valid values: `all`, `cloud`, `ephemeralSsd`, `cloudEssd`, `cloudEfficiency`, `cloudSsd`, `localDisk`.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released. Default to `true`.
         */
        deleteWithInstance?: boolean;
        /**
         * Description of instance launch template version 1. It can be [2, 256] characters in length. It cannot start with "http://" or "https://". The default value is null.
         */
        description: string;
        /**
         * The Iops.
         */
        iops?: string;
        /**
         * It has been deprecated from version 1.120.0, and use field `launchTemplateName` instead.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk. Valid Values: `PL0`, `PL1`, `PL2`, and `PL3`. Default to: `PL0`.
         */
        performanceLevel?: string;
        /**
         * Size of the system disk, measured in GB. Value range: [20, 500].
         */
        size: number;
    }

    export interface EcsPrefixListEntry {
        /**
         * The CIDR block in entry. This parameter is empty by default.  Take note of the following items:
         * * The total number of entries must not exceed the `maxEntries` value.
         * * CIDR block types are determined by the IP address family. You cannot combine `IPv4` and `IPv6` CIDR blocks in a single entry.
         * * CIDR blocks must be unique across all entries in a prefix list. For example, you cannot specify 192.168.1.0/24 twice in the entries of the prefix list.
         * * IP addresses are supported. The system converts IP addresses into CIDR blocks. For example, if you specify 192.168.1.100, the system converts it into the 192.168.1.100/32 CIDR block.
         * * If an IPv6 CIDR block is used, the system converts it to the zero compression format and changes uppercase letters into lowercase ones. For example, if you specify 2001:0DB8:0000:0000:0000:0000:0000:0000/32, the system converts it into 2001:db8::/32.
         * * For more information about CIDR blocks, see the "What is CIDR block?" section of the [Network FAQ](https://www.alibabacloud.com/help/doc-detail/40637.htm) topic.  * The total number of entries must not exceed the `maxEntries` value.
         */
        cidr?: string;
        /**
         * The description in entry. The description must be 2 to 32 characters in length and cannot start with `http://` or `https://`.
         */
        description?: string;
    }

    export interface GetActivationsActivation {
        /**
         * The ID of the activation code.
         */
        activationId: string;
        /**
         * The time when the activation code was created.
         */
        createTime: string;
        /**
         * The number of instances that have been logged out.
         */
        deregisteredCount: number;
        /**
         * Description of the corresponding activation code.
         */
        description: string;
        /**
         * Indicates whether the activation code is disabled.
         */
        disabled: boolean;
        /**
         * The ID of the Activation.
         */
        id: string;
        /**
         * The maximum number of times the activation code is used to register a managed instance.
         */
        instanceCount: number;
        /**
         * The default prefix of the instance name.
         */
        instanceName: string;
        /**
         * The IP address of the host that allows the activation code to be used.
         */
        ipAddressRange: string;
        /**
         * The number of instances that were registered.
         */
        registeredCount: number;
        /**
         * The validity period of the activation code. Unit: hours.
         */
        timeToLiveInHours: number;
    }

    export interface GetAutoSnapshotPoliciesPolicy {
        /**
         * The ID of the Auto Snapshot Policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The retention period of the snapshot copied across regions.
         */
        copiedSnapshotsRetentionDays: number;
        /**
         * The number of disks to which the automatic snapshot policy is applied.
         */
        diskNums: number;
        /**
         * Specifies whether to enable the system to automatically copy snapshots across regions.
         */
        enableCrossRegionCopy: boolean;
        /**
         * The ID of the Auto Snapshot Policy.
         */
        id: string;
        /**
         * The snapshot policy name..
         */
        name: string;
        /**
         * The automatic snapshot repetition dates.
         */
        repeatWeekdays: string[];
        /**
         * The snapshot retention time, and the unit of measurement is day.
         */
        retentionDays: number;
        /**
         * The status of Auto Snapshot Policy.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The destination region to which the snapshot is copied.
         */
        targetCopyRegions: string[];
        /**
         * The automatic snapshot creation schedule, and the unit of measurement is hour.
         */
        timePoints: string[];
        /**
         * The number of extended volumes on which this policy is enabled.
         */
        volumeNums: number;
    }

    export interface GetCapacityReservationsReservation {
        /**
         * Capacity Reservation id
         */
        capacityReservationId: string;
        /**
         * Capacity reservation service name.
         */
        capacityReservationName: string;
        /**
         * description of the capacity reservation instance
         */
        description: string;
        /**
         * end time of the capacity reservation. the capacity reservation will be  released at the end time automatically if set. otherwise it will last until manually released
         */
        endTime: string;
        /**
         * Release mode of capacity reservation service. Value range:Limited: release at specified time. The EndTime parameter must be specified at the same time.Unlimited: manual release. No time limit.
         */
        endTimeType: string;
        /**
         * The ID of the Capacity Reservation.
         */
        id: string;
        /**
         * The total number of instances that need to be reserved within the capacity reservation
         */
        instanceAmount: string;
        /**
         * Instance type. Currently, you can only set the capacity reservation service for one instance type.
         */
        instanceType: string;
        /**
         * The type of private resource pool generated after the capacity reservation service takes effect. Value range:Open: Open mode.Target: dedicated mode.Default value: Open
         */
        matchCriteria: string;
        /**
         * The payment type of the resource. value range `PostPaid`, `PrePaid`.
         */
        paymentType: string;
        /**
         * platform of the capacity reservation , value range `windows`, `linux`, `all`.
         */
        platform: string;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * time of the capacity reservation which become active
         */
        startTime: string;
        /**
         * The capacity is scheduled to take effect. Possible values:-Now: Effective immediately.-Later: the specified time takes effect.
         */
        startTimeType: string;
        /**
         * The status of the capacity reservation. value range `All`, `Pending`, `Preparing`, `Prepared`, `Active`, `Released`.
         */
        status: string;
        /**
         * The tag of the resource.
         */
        tags?: {[key: string]: any};
        /**
         * This parameter is under test and is not yet open for use.
         */
        timeSlot: string;
        /**
         * The ID of the zone in the region to which the capacity reservation service belongs. Currently, it is only supported to create a capacity reservation service in one zone.
         */
        zoneIds: string[];
    }

    export interface GetCommandsCommand {
        /**
         * The Base64-encoded content of the command.
         */
        commandContent: string;
        /**
         * The ID of the Command.
         */
        commandId: string;
        /**
         * The description of command.
         */
        description: string;
        /**
         * Specifies whether to use custom parameters in the command to be created.
         */
        enableParameter: boolean;
        /**
         * The ID of the Command.
         */
        id: string;
        /**
         * The name of the command
         */
        name: string;
        /**
         * A list of custom parameter names which are parsed from the command content specified when the command was being created.
         */
        parameterNames: string[];
        /**
         * The timeout period that is specified for the command to be run on ECS instances.
         */
        timeout: number;
        /**
         * The command type.
         */
        type: string;
        /**
         * The execution path of the command in the ECS instance.
         */
        workingDir: string;
    }

    export interface GetDedicatedHostsHost {
        /**
         * The policy used to migrate the instances from the dedicated host when the dedicated host fails or needs to be repaired online.
         */
        actionOnMaintenance: string;
        /**
         * Specifies whether to add the dedicated host to the resource pool for automatic deployment.
         */
        autoPlacement: string;
        /**
         * The automatic release time of the dedicated host.
         */
        autoReleaseTime: string;
        /**
         * (Available in 1.123.1+) A collection of proprietary host performance indicators.
         */
        capacities: outputs.ecs.GetDedicatedHostsHostCapacity[];
        /**
         * A mapping of tags to assign to the resource.
         */
        cores: number;
        /**
         * (Available in 1.123.1+) CPU oversold ratio.
         */
        cpuOverCommitRatio: number;
        /**
         * The ID of ECS Dedicated Host.
         */
        dedicatedHostId: string;
        /**
         * The name of ECS Dedicated Host.
         */
        dedicatedHostName: string;
        /**
         * The type of the dedicated host.
         */
        dedicatedHostType: string;
        /**
         * The description of the dedicated host.
         */
        description: string;
        /**
         * The expiration time of the subscription dedicated host.
         */
        expiredTime: string;
        /**
         * The GPU model.
         */
        gpuSpec: string;
        /**
         * ID of the ECS Dedicated Host.
         */
        id: string;
        /**
         * The machine code of the dedicated host.
         */
        machineId: string;
        /**
         * dedicated host network parameters. contains the following attributes:
         */
        networkAttributes: outputs.ecs.GetDedicatedHostsHostNetworkAttribute[];
        /**
         * The reason why the dedicated host resource is locked.
         */
        operationLocks: outputs.ecs.GetDedicatedHostsHostOperationLock[];
        /**
         * The billing method of the dedicated host.
         */
        paymentType: string;
        /**
         * The number of physical GPUs.
         */
        physicalGpus: number;
        /**
         * The ID of the resource group to which the ECS Dedicated Host belongs.
         */
        resourceGroupId: string;
        /**
         * The unit of the subscription billing method.
         */
        saleCycle: string;
        /**
         * The number of physical CPUs.
         */
        sockets: number;
        /**
         * The status of the ECS Dedicated Host. validate value: `Available`, `Creating`, `PermanentFailure`, `Released`, `UnderAssessment`.
         */
        status: string;
        /**
         * (Available in 1.123.1+) A custom instance type family supported by a dedicated host.
         */
        supportedCustomInstanceTypeFamilies: string[];
        /**
         * (Available in 1.123.1+) ECS instance type family supported by the dedicated host.
         */
        supportedInstanceTypeFamilies: string[];
        /**
         * The list of ECS instance
         */
        supportedInstanceTypesLists: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The zone ID of the ECS Dedicated Host.
         */
        zoneId: string;
    }

    export interface GetDedicatedHostsHostCapacity {
        /**
         * The remaining local disk capacity. Unit: GiB.
         */
        availableLocalStorage: number;
        /**
         * The remaining memory capacity, unit: GiB.
         */
        availableMemory: number;
        /**
         * The number of remaining vCPU cores.
         */
        availableVcpus: number;
        /**
         * The number of available virtual GPUs.
         */
        availableVgpus: number;
        /**
         * Local disk type.
         */
        localStorageCategory: string;
        /**
         * The total capacity of the local disk, in GiB.
         */
        totalLocalStorage: number;
        /**
         * The total memory capacity, unit: GiB.
         */
        totalMemory: number;
        /**
         * The total number of vCPU cores.
         */
        totalVcpus: number;
        /**
         * The total number of virtual GPUs.
         */
        totalVgpus: number;
    }

    export interface GetDedicatedHostsHostNetworkAttribute {
        /**
         * The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds.
         */
        slbUdpTimeout: number;
        /**
         * (Available in 1.123.1+) The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds.
         */
        udpTimeout: number;
    }

    export interface GetDedicatedHostsHostOperationLock {
        /**
         * The reason why the dedicated host resource is locked.
         */
        lockReason: string;
    }

    export interface GetDedicatedHostsOperationLock {
        /**
         * The reason why the dedicated host resource is locked.
         */
        lockReason?: string;
    }

    export interface GetDisksDisk {
        /**
         * Disk attachment time.
         */
        attachedTime: string;
        autoSnapshotPolicyId: string;
        /**
         * Availability zone of the disk.
         */
        availabilityZone: string;
        /**
         * Disk category. Possible values: `cloud` (basic cloud disk), `cloudEfficiency` (ultra cloud disk), `ephemeralSsd` (local SSD cloud disk), `cloudSsd` (SSD cloud disk), and `cloudEssd` (ESSD cloud disk).
         */
        category: string;
        /**
         * Disk creation time.
         */
        creationTime: string;
        deleteAutoSnapshot: boolean;
        deleteWithInstance: boolean;
        /**
         * Disk description.
         */
        description: string;
        /**
         * Disk detachment time.
         */
        detachedTime: string;
        device: string;
        diskId: string;
        diskName: string;
        diskType: string;
        enableAutoSnapshot: boolean;
        enableAutomatedSnapshotPolicy: boolean;
        /**
         * Indicate whether the disk is encrypted or not. Possible values: `on` and `off`.
         */
        encrypted: string;
        expiredTime: string;
        /**
         * ID of the disk.
         */
        id: string;
        /**
         * ID of the image from which the disk is created. It is null unless the disk is created using an image.
         */
        imageId: string;
        /**
         * Filter the results by the specified ECS instance ID.
         */
        instanceId: string;
        iops: number;
        iopsRead: number;
        iopsWrite: number;
        kmsKeyId: string;
        mountInstanceNum: number;
        mountInstances: outputs.ecs.GetDisksDiskMountInstance[];
        /**
         * Disk name.
         */
        name: string;
        operationLocks: outputs.ecs.GetDisksDiskOperationLock[];
        paymentType: string;
        performanceLevel: string;
        portable: boolean;
        productCode: string;
        /**
         * Region ID the disk belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group which the disk belongs.
         */
        resourceGroupId: string;
        /**
         * Disk size in GiB.
         */
        size: number;
        /**
         * Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
         */
        snapshotId: string;
        /**
         * Current status. Possible values: `In_use`, `Available`, `Attaching`, `Detaching`, `Creating` and `ReIniting`.
         */
        status: string;
        /**
         * A map of tags assigned to the disks. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const disksDs = alicloud.ecs.getDisks({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags: {[key: string]: any};
        /**
         * Disk type. Possible values: `system` and `data`.
         */
        type: string;
        zoneId: string;
    }

    export interface GetDisksDiskMountInstance {
        /**
         * Disk attachment time.
         */
        attachedTime: string;
        device: string;
        /**
         * Filter the results by the specified ECS instance ID.
         */
        instanceId: string;
    }

    export interface GetDisksDiskOperationLock {
        lockReason: string;
    }

    export interface GetDisksOperationLock {
        lockReason?: string;
    }

    export interface GetEcsDedicatedHostClustersCluster {
        /**
         * The capacity of the dedicated host cluster.
         */
        dedicatedHostClusterCapacities: outputs.ecs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacity[];
        /**
         * The ID of the dedicated host cluster.
         */
        dedicatedHostClusterId: string;
        /**
         * The name of the dedicated host cluster.
         */
        dedicatedHostClusterName: string;
        /**
         * The IDs of dedicated hosts in the dedicated host cluster.
         */
        dedicatedHostIds: string[];
        /**
         * The description of the dedicated host cluster.
         */
        description: string;
        /**
         * The ID of the Dedicated Host Cluster.
         */
        id: string;
        /**
         * The ID of the resource group to which the dedicated host cluster belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The zone ID of the dedicated host cluster.
         */
        zoneId: string;
    }

    export interface GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacity {
        /**
         * The available memory size. Unit: `GiB`.
         */
        availableMemory: number;
        /**
         * The number of available vCPUs.
         */
        availableVcpus: number;
        /**
         * The local storage.
         */
        localStorageCapacities: outputs.ecs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacity[];
        /**
         * The total memory size. Unit: `GiB`.
         */
        totalMemory: number;
        /**
         * The total number of vCPUs.
         */
        totalVcpus: number;
    }

    export interface GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacity {
        /**
         * The available capacity of the local disk. Unit: `GiB`.
         */
        availableDisk: number;
        /**
         * The category of the data disk. Valid values:`cloud`, `cloudEfficiency`, `cloudSsd`, `ephemeralSsd`, `cloudEssd`.
         */
        dataDiskCategory: string;
        /**
         * The total capacity of the local disk. Unit: `GiB`.
         */
        totalDisk: number;
    }

    export interface GetEcsDeploymentSetsSet {
        /**
         * The time when the deployment set was created.
         */
        createTime: string;
        /**
         * The ID of the Deployment Set.
         */
        deploymentSetId: string;
        /**
         * The name of the deployment set.
         */
        deploymentSetName: string;
        /**
         * The description of the deployment set.
         */
        description: string;
        /**
         * The deployment domain.
         */
        domain: string;
        /**
         * The deployment granularity.
         */
        granularity: string;
        /**
         * The ID of the Deployment Set.
         */
        id: string;
        /**
         * The number of instances in the deployment set.
         */
        instanceAmount: number;
        /**
         * The IDs of the instances in the deployment set.
         */
        instanceIds: string[];
        /**
         * The deployment strategy.
         */
        strategy: string;
    }

    export interface GetEcsDisksDisk {
        /**
         * A mount of time.
         */
        attachedTime: string;
        /**
         * Query cloud disks based on the automatic snapshot policy ID.
         */
        autoSnapshotPolicyId: string;
        /**
         * Availability zone of the disk.
         */
        availabilityZone: string;
        /**
         * Disk category.
         */
        category: string;
        /**
         * Disk creation time.
         */
        creationTime: string;
        /**
         * Indicates whether the automatic snapshot is deleted when the disk is released.
         */
        deleteAutoSnapshot: boolean;
        /**
         * Indicates whether the disk is released together with the instance.
         */
        deleteWithInstance: boolean;
        /**
         * Disk description.
         */
        description: string;
        /**
         * Disk detachment time.
         */
        detachedTime: string;
        /**
         * The mount point of the disk.
         */
        device: string;
        /**
         * ID of the disk.
         */
        diskId: string;
        /**
         * The disk name.
         */
        diskName: string;
        /**
         * The disk type.
         */
        diskType: string;
        /**
         * Whether the disk implements an automatic snapshot policy.
         */
        enableAutoSnapshot: boolean;
        /**
         * Whether the disk implements an automatic snapshot policy.
         */
        enableAutomatedSnapshotPolicy: boolean;
        /**
         * Indicate whether the disk is encrypted or not.
         */
        encrypted: string;
        expiredTime: string;
        /**
         * ID of the disk.
         */
        id: string;
        /**
         * ID of the image from which the disk is created. It is null unless the disk is created using an image.
         */
        imageId: string;
        /**
         * The instance ID of the disk mount.
         */
        instanceId: string;
        iops: number;
        iopsRead: number;
        iopsWrite: number;
        /**
         * The kms key id.
         */
        kmsKeyId: string;
        /**
         * Number of instances mounted on shared storage.
         */
        mountInstanceNum: number;
        /**
         * Disk mount instances.
         */
        mountInstances: outputs.ecs.GetEcsDisksDiskMountInstance[];
        /**
         * Disk name.
         */
        name: string;
        operationLocks: outputs.ecs.GetEcsDisksDiskOperationLock[];
        /**
         * Payment method for disk.
         */
        paymentType: string;
        /**
         * Performance levels of ESSD cloud disk.
         */
        performanceLevel: string;
        /**
         * Whether the disk is unmountable.
         */
        portable: boolean;
        /**
         * The product logo of the cloud market.
         */
        productCode: string;
        /**
         * Region ID the disk belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group.
         */
        resourceGroupId: string;
        /**
         * Disk size in GiB.
         */
        size: number;
        /**
         * Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
         */
        snapshotId: string;
        /**
         * Current status.
         */
        status: string;
        /**
         * A map of tags assigned to the disk.
         */
        tags: {[key: string]: any};
        /**
         * Disk type.
         */
        type: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetEcsDisksDiskMountInstance {
        /**
         * A mount of time.
         */
        attachedTime: string;
        /**
         * The mount point of the disk.
         */
        device: string;
        /**
         * The instance ID of the disk mount.
         */
        instanceId: string;
    }

    export interface GetEcsDisksDiskOperationLock {
        lockReason: string;
    }

    export interface GetEcsDisksOperationLock {
        lockReason?: string;
    }

    export interface GetEcsImageComponentsComponent {
        /**
         * The type of the image component.
         */
        componentType: string;
        /**
         * The content of the image component.
         */
        content: string;
        /**
         * The time when the image component was created.
         */
        createTime: string;
        /**
         * The description of the image component.
         */
        description: string;
        /**
         * The ID of the Image Component.
         */
        id: string;
        /**
         * The ID of the image component.
         */
        imageComponentId: string;
        /**
         * The name of the image component.
         */
        imageComponentName: string;
        /**
         * The type of the image component.
         */
        owner: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The operating system type supported by the image component.
         */
        systemType: string;
        /**
         * List of label key-value pairs.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsImagePipelinePipeline {
        /**
         * The IDs of Alibaba Cloud accounts to which the image was shared.
         */
        addAccounts: string[];
        /**
         * The source image.
         */
        baseImage: string;
        /**
         * The type of the source image.
         */
        baseImageType: string;
        /**
         * The content of the image template.
         */
        buildContent: string;
        /**
         * The time when the image template was created.
         */
        creationTime: string;
        /**
         * Indicates whether the intermediate instance was released when the image failed to be created.
         */
        deleteInstanceOnFailure: boolean;
        /**
         * The description of the image template.
         */
        description: string;
        /**
         * The ID of the Image Pipeline.
         */
        id: string;
        /**
         * The name prefix of the created image.
         */
        imageName: string;
        /**
         * The ID of the image template.
         */
        imagePipelineId: string;
        /**
         * The instance type of the intermediate instance.
         */
        instanceType: string;
        /**
         * The size of the outbound public bandwidth for the intermediate instance. Unit: `Mbit/s`.
         */
        internetMaxBandwidthOut: number;
        /**
         * The name of the image template.
         */
        name: string;
        /**
         * The ID of the resource group to which the image template belongs.
         */
        resourceGroupId: string;
        /**
         * The system disk size of the intermediate instance. Unit: `GiB`.
         */
        systemDiskSize: number;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * The IDs of regions to which to distribute the created image.
         */
        toRegionIds: string[];
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetEcsInvocationsInvocation {
        /**
         * The Base64-encoded command content.
         */
        commandContent: string;
        /**
         * The ID of the command.
         */
        commandId: string;
        /**
         * The name of the command.
         */
        commandName: string;
        /**
         * The type of the command.
         */
        commandType: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The schedule on which the recurring execution of the command takes place. For information about the value specifications, see [Cron expression](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/cron-expression).
         */
        frequency: string;
        /**
         * The ID of the Invocation.
         */
        id: string;
        /**
         * The ID of the Invocation.
         */
        invocationId: string;
        /**
         * The execution state on a single instance. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopping`, `Stopped`, `PartialFailed`.
         */
        invocationStatus: string;
        /**
         * Execute target instance set type.
         */
        invokeInstances: outputs.ecs.GetEcsInvocationsInvocationInvokeInstance[];
        /**
         * The overall execution state of the command. **Note:** We recommend that you ignore this parameter and check the value of the `invocationStatus` response parameter for the overall execution state.
         */
        invokeStatus: string;
        /**
         * The custom parameters in the command.
         */
        parameters: string;
        /**
         * Indicates the execution mode of the command.
         */
        repeatMode: string;
        /**
         * Indicates whether the commands are to be automatically run.
         * * `errorCode	` - The code that indicates why the command failed to be sent or run.
         * * `instanceInvokeStatus	` - **Note:** We recommend that you ignore this parameter and check the value of the `invocationStatus` response parameter for the overall execution state.
         */
        timed: boolean;
        /**
         * The username that was used to run the command on the instance.
         */
        username: string;
    }

    export interface GetEcsInvocationsInvocationInvokeInstance {
        /**
         * The start time of the execution.
         */
        creationTime: string;
        /**
         * The size of truncated and discarded text when the value of the Output response parameter exceeds 24 KB in size.
         */
        dropped: number;
        errorCode: string;
        /**
         * Details about the reason why the command failed to be sent or run.
         */
        errorInfo: string;
        /**
         * The exit code of the execution.
         */
        exitCode: number;
        /**
         * The end time of the execution.
         */
        finishTime: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        instanceInvokeStatus: string;
        /**
         * The execution state on a single instance. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopping`, `Stopped`, `PartialFailed`.
         */
        invocationStatus: string;
        /**
         * The output of the command.
         */
        output: string;
        /**
         * The number of times that the command is run on the instance.
         */
        repeats: number;
        /**
         * The time when the command started to be run on the instance.
         */
        startTime: string;
        /**
         * The time when the command stopped being run on the instance. If you call the StopInvocation operation to manually stop the execution, the value is the time when you call the operation.
         */
        stopTime: string;
        /**
         * Indicates whether the commands are to be automatically run.
         * * `errorCode	` - The code that indicates why the command failed to be sent or run.
         * * `instanceInvokeStatus	` - **Note:** We recommend that you ignore this parameter and check the value of the `invocationStatus` response parameter for the overall execution state.
         */
        timed: boolean;
        /**
         * The time when the execution state was updated.
         */
        updateTime: string;
    }

    export interface GetEcsKeyPairsKeyPair {
        /**
         * The finger print of the key pair.
         */
        fingerPrint: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetEcsKeyPairsKeyPairInstance[];
        /**
         * The Key Pair Name.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Resource Group Id.
         */
        resourceGroupId: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsKeyPairsKeyPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * The Key Pair Name.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetEcsKeyPairsPair {
        /**
         * The finger print of the key pair.
         */
        fingerPrint: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetEcsKeyPairsPairInstance[];
        /**
         * The Key Pair Name.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Resource Group Id.
         */
        resourceGroupId: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsKeyPairsPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * The Key Pair Name.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetEcsLaunchTemplatesTemplate {
        /**
         * Instance auto release time.
         */
        autoReleaseTime: string;
        /**
         * CreatedBy.
         */
        createdBy: string;
        /**
         * The list of data disks created with instance.
         */
        dataDisks: outputs.ecs.GetEcsLaunchTemplatesTemplateDataDisk[];
        /**
         * The Default Version Number.
         */
        defaultVersionNumber: number;
        /**
         * The Deployment Set Id.
         */
        deploymentSetId: string;
        /**
         * System disk description.
         */
        description: string;
        /**
         * Whether to enable the instance operating system configuration.
         */
        enableVmOsConfig: boolean;
        /**
         * Instance host name.
         */
        hostName: string;
        /**
         * The ID of the Launch Template.
         */
        id: string;
        /**
         * The Image Id.
         */
        imageId: string;
        /**
         * Mirror source.
         */
        imageOwnerAlias: string;
        /**
         * Internet bandwidth billing method.
         */
        instanceChargeType: string;
        /**
         * The Instance Name.
         */
        instanceName: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Internet bandwidth billing method.
         */
        internetChargeType: string;
        /**
         * The maximum inbound bandwidth from the Internet network, measured in Mbit/s.
         */
        internetMaxBandwidthIn: number;
        /**
         * Maximum outbound bandwidth from the Internet, its unit of measurement is Mbit/s.
         */
        internetMaxBandwidthOut: number;
        /**
         * Whether it is an I/O-optimized instance or not.
         */
        ioOptimized: string;
        /**
         * The name of the key pair.
         */
        keyPairName: string;
        /**
         * The Latest Version Number.
         */
        latestVersionNumber: number;
        /**
         * The ID of the Launch Template.
         */
        launchTemplateId: string;
        /**
         * The Launch Template Name.
         */
        launchTemplateName: string;
        /**
         * The Modified Time.
         */
        modifiedTime: string;
        /**
         * The list of network interfaces created with instance.
         */
        networkInterfaces: outputs.ecs.GetEcsLaunchTemplatesTemplateNetworkInterface[];
        /**
         * Network type of the instance.
         */
        networkType: string;
        /**
         * Whether to use the password preset by the mirror.
         */
        passwordInherit: boolean;
        /**
         * The subscription period of the instance.
         */
        period: number;
        /**
         * The private IP address of the instance.
         */
        privateIpAddress: string;
        /**
         * The RAM role name of the instance.
         */
        ramRoleName: string;
        /**
         * The ID of the resource group to which to assign the instance, Elastic Block Storage (EBS) device, and ENI.
         */
        resourceGroupId: string;
        /**
         * Whether or not to activate the security enhancement feature and install network security software free of charge.
         */
        securityEnhancementStrategy: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The security group IDs.
         */
        securityGroupIds: string[];
        /**
         * The protection period of the preemptible instance.
         */
        spotDuration: string;
        /**
         * Sets the maximum hourly instance price.
         */
        spotPriceLimit: number;
        /**
         * The spot strategy for a Pay-As-You-Go instance.
         */
        spotStrategy: string;
        /**
         * The System Disk.
         */
        systemDisks: outputs.ecs.GetEcsLaunchTemplatesTemplateSystemDisk[];
        /**
         * The template tags.
         */
        templateTags: {[key: string]: any};
        /**
         * The User Data.
         */
        userData: string;
        /**
         * The Version Description.
         */
        versionDescription: string;
        /**
         * VpcId.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone Id.
         */
        zoneId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateDataDisk {
        /**
         * The category of the system disk.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released.
         */
        deleteWithInstance: boolean;
        /**
         * System disk description.
         */
        description: string;
        /**
         * Encrypted the data in this disk.
         */
        encrypted: boolean;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        performanceLevel: string;
        /**
         * Size of the system disk, measured in GB.
         */
        size: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateNetworkInterface {
        /**
         * System disk description.
         */
        description: string;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateSystemDisk {
        /**
         * The category of the system disk.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released.
         */
        deleteWithInstance: boolean;
        /**
         * System disk description.
         */
        description: string;
        /**
         * The Iops.
         */
        iops: string;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        performanceLevel: string;
        /**
         * Size of the system disk, measured in GB.
         */
        size: number;
    }

    export interface GetEcsNetworkInterfacePermissionsPermission {
        /**
         * Alibaba Cloud Partner (Certified ISV) account ID or individual user ID.
         */
        accountId: string;
        /**
         * The ID of the Network Interface Permission.
         */
        id: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ID of the Network Interface Permissions.
         */
        networkInterfacePermissionId: string;
        /**
         * The permissions of the Network Interface.
         */
        permission: string;
        /**
         * Alibaba Cloud service name.
         */
        serviceName: string;
        /**
         * The Status of the Network Interface Permissions.
         */
        status: string;
    }

    export interface GetEcsNetworkInterfacesInterface {
        /**
         * The EIP associated with the secondary private IP address of the ENI.  **NOTE:** Available in v1.163.0+.
         */
        associatedPublicIps: outputs.ecs.GetEcsNetworkInterfacesInterfaceAssociatedPublicIp[];
        /**
         * The creation time.
         */
        creationTime: string;
        /**
         * The description of the ENI.
         */
        description: string;
        /**
         * The ID of the Network Interface.
         */
        id: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The MAC address of the ENI.
         */
        mac: string;
        /**
         * The network interface name.
         */
        name: string;
        /**
         * The network interface id.
         */
        networkInterfaceId: string;
        /**
         * The network interface name.
         */
        networkInterfaceName: string;
        /**
         * The communication mode of the elastic network card.
         */
        networkInterfaceTrafficMode: string;
        /**
         * The ID of the account to which the ENIC belongs.
         */
        ownerId: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIpAddress: string;
        /**
         * The primary private IP address of the ENI.
         */
        privateIp: string;
        privateIpAddresses: string[];
        /**
         * A list of secondary private IP address that is assigned to the ENI.
         */
        privateIps: string[];
        /**
         * Number of network card queues.
         */
        queueNumber: number;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * The security group ids.
         */
        securityGroupIds: string[];
        /**
         * The security groups.
         */
        securityGroups: string[];
        /**
         * The service id.
         */
        serviceId: number;
        /**
         * Whether the user of the elastic network card is a cloud product or a virtual vendor.
         */
        serviceManaged: boolean;
        /**
         * The status of the ENI.
         */
        status: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
        /**
         * The type of the ENI.
         */
        type: string;
        /**
         * The Vpc Id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetEcsNetworkInterfacesInterfaceAssociatedPublicIp {
        /**
         * The EIP of the ENI.
         */
        publicIpAddress: string;
    }

    export interface GetEcsPrefixListsList {
        /**
         * The address family of the prefix list. Valid values:`IPv4`,`IPv6`.
         */
        addressFamily: string;
        /**
         * The amount of associated resources.
         */
        associationCount: number;
        /**
         * The time when the prefix list was created.
         */
        createTime: string;
        /**
         * The description of the prefix list.
         */
        description: string;
        entries: outputs.ecs.GetEcsPrefixListsListEntry[];
        /**
         * The ID of the prefix list.
         */
        id: string;
        /**
         * The maximum number of entries that the prefix list supports.
         */
        maxEntries: number;
        /**
         * The ID of the prefix list.
         */
        prefixListId: string;
        /**
         * The name of the prefix list.
         */
        prefixListName: string;
    }

    export interface GetEcsPrefixListsListEntry {
        cidr: string;
        /**
         * The description of the prefix list.
         */
        description: string;
    }

    export interface GetEcsSnapshotGroupsGroup {
        /**
         * The description of the snapshot-consistent group.
         */
        description: string;
        /**
         * The ID of the Snapshot Group.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The ID of the resource group to which the snapshot consistency group belongs.
         */
        resourceGroupId: string;
        /**
         * The first ID of the resource.
         */
        snapshotGroupId: string;
        /**
         * The name of the snapshot-consistent group.
         */
        snapshotGroupName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * List of label key-value pairs.
         */
        tags?: {[key: string]: any};
    }

    export interface GetEcsSnapshotsSnapshot {
        /**
         * The category of the snapshot.
         */
        category: string;
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The source disk id.
         */
        diskId: string;
        /**
         * Whether the snapshot is encrypted.
         */
        encrypted: boolean;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * Whether snapshot speed availability is enabled.
         */
        instantAccess: boolean;
        /**
         * Specifies the retention period of the instant access feature. After the retention period ends, the snapshot is automatically released.
         */
        instantAccessRetentionDays: number;
        name: string;
        /**
         * The product number inherited from the mirror market.
         */
        productCode: string;
        /**
         * Snapshot creation progress, in percentage.
         */
        progress: string;
        /**
         * Remaining completion time for the snapshot being created.
         */
        remainTime: number;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * Automatic snapshot retention days.
         */
        retentionDays: number;
        /**
         * The snapshot id.
         */
        snapshotId: string;
        /**
         * Snapshot Display Name.
         */
        snapshotName: string;
        /**
         * The serial number of the snapshot.
         */
        snapshotSn: string;
        /**
         * Snapshot creation type.
         */
        snapshotType: string;
        sourceDiskId: string;
        /**
         * Source disk capacity.
         */
        sourceDiskSize: string;
        /**
         * Source disk attributes.
         */
        sourceDiskType: string;
        /**
         * Original disk type.
         */
        sourceStorageType: string;
        /**
         * The status of the snapshot.
         */
        status: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * A resource type that has a reference relationship.
         */
        usage: string;
    }

    export interface GetEcsStorageCapacityUnitsUnit {
        /**
         * When the AllocationType value is Shared, this parameter indicates the allocation status of Storage Capacity Unit. Valid values: `allocated`, `Ignored`.
         */
        allocationStatus: string;
        /**
         * The capacity of the Storage Capacity Unit.
         */
        capacity: number;
        /**
         * The time when the Storage Capacity Unit was created.
         */
        createTime: string;
        /**
         * The description of the Storage Capacity Unit.
         */
        description: string;
        /**
         * The time when the Storage Capacity Unit expires.
         */
        expiredTime: string;
        /**
         * The ID of the Storage Capacity Unit.
         */
        id: string;
        /**
         * The effective time of the Storage Capacity Unit.
         */
        startTime: string;
        /**
         * The status of Storage Capacity Unit.
         */
        status: string;
        /**
         * The ID of Storage Capacity Unit.
         */
        storageCapacityUnitId: string;
        /**
         * The name of the Storage Capacity Unit.
         */
        storageCapacityUnitName: string;
    }

    export interface GetEipAddressesAddress {
        /**
         * The name of the EIP.
         */
        addressName: string;
        /**
         * The ID of the EIP.
         */
        allocationId: string;
        /**
         * The ID of the region to which the EIP belongs.
         */
        availableRegions: string[];
        /**
         * The maximum bandwidth of the EIP. Unit: Mbit/s.
         */
        bandwidth: string;
        /**
         * The bandwidth value of the EIP bandwidth plan with which the EIP is associated.
         */
        bandwidthPackageBandwidth: string;
        /**
         * The ID of the EIP bandwidth plan.
         */
        bandwidthPackageId: string;
        /**
         * The type of the bandwidth. Only CommonBandwidthPackage (an EIP bandwidth plan) is returned.
         */
        bandwidthPackageType: string;
        /**
         * The time when the EIP was created.
         */
        createTime: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The description of the EIP.
         */
        description: string;
        /**
         * The expiration date. The time follows the ISO 8601 standard and is displayed in UTC. Format: YYYY-MM-DDThh:mmZ.
         */
        expiredTime: string;
        /**
         * Indicates whether renewal data is included. This parameter returns true only when the parameter IncludeReservationData is set to true, and some orders have not taken effect.
         */
        hasReservationData: string;
        /**
         * Indicates whether fine-grained monitoring is enabled for the EIP.
         */
        hdMonitorStatus: string;
        /**
         * The ID of the Address.
         */
        id: string;
        /**
         * The ID of the instance with which the EIP is associated.
         */
        instanceId: string;
        /**
         * The region ID of the associated resource.
         */
        instanceRegionId: string;
        /**
         * The type of the instance with which the EIP is associated.
         */
        instanceType: string;
        /**
         * The metering method of the EIP.
         */
        internetChargeType: string;
        /**
         * The IP address of the EIP.
         */
        ipAddress: string;
        /**
         * The Internet service provider (ISP).
         */
        isp: string;
        /**
         * The details about the locked EIP.
         */
        operationLocks: string[];
        /**
         * The billing method of the EIP.
         */
        paymentType: string;
        /**
         * The time when the renewal takes effect.
         */
        reservationActiveTime: string;
        /**
         * The bandwidth after the renewal takes effect.
         */
        reservationBandwidth: string;
        /**
         * The metering method of the renewal.
         */
        reservationInternetChargeType: string;
        /**
         * The type of the renewal order.
         */
        reservationOrderType: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * Indicates whether level-2 throttling is configured.
         */
        secondLimited: boolean;
        /**
         * The IDs of the contiguous EIPs.
         */
        segmentInstanceId: string;
        /**
         * The status of the EIP.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetEipAddressesEip {
        /**
         * The maximum bandwidth of the EIP. Unit: Mbit/s.
         */
        bandwidth: string;
        creationTime: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The ID of the Address.
         */
        id: string;
        /**
         * The ID of the instance with which the EIP is associated.
         */
        instanceId: string;
        /**
         * The type of the instance with which the EIP is associated.
         */
        instanceType: string;
        /**
         * The metering method of the EIP.
         */
        internetChargeType: string;
        /**
         * The IP address of the EIP.
         */
        ipAddress: string;
        /**
         * The status of the EIP.
         */
        status: string;
    }

    export interface GetEipsAddress {
        addressName: string;
        allocationId: string;
        availableRegions: string[];
        /**
         * EIP internet max bandwidth in Mbps.
         */
        bandwidth: string;
        bandwidthPackageBandwidth: string;
        bandwidthPackageId: string;
        bandwidthPackageType: string;
        createTime: string;
        /**
         * (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
         */
        deletionProtection: boolean;
        description: string;
        expiredTime: string;
        hasReservationData: string;
        hdMonitorStatus: string;
        /**
         * ID of the EIP.
         */
        id: string;
        /**
         * The ID of the instance that is being bound.
         */
        instanceId: string;
        instanceRegionId: string;
        /**
         * The instance type of that the EIP is bound.
         */
        instanceType: string;
        /**
         * EIP internet charge type.
         */
        internetChargeType: string;
        /**
         * Public IP Address of the the EIP.
         */
        ipAddress: string;
        isp: string;
        operationLocks: string[];
        paymentType: string;
        reservationActiveTime: string;
        reservationBandwidth: string;
        reservationInternetChargeType: string;
        reservationOrderType: string;
        /**
         * The Id of resource group which the eips belongs.
         */
        resourceGroupId: string;
        secondLimited: boolean;
        segmentInstanceId: string;
        /**
         * EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetEipsEip {
        /**
         * EIP internet max bandwidth in Mbps.
         */
        bandwidth: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
         */
        deletionProtection: boolean;
        /**
         * ID of the EIP.
         */
        id: string;
        /**
         * The ID of the instance that is being bound.
         */
        instanceId: string;
        /**
         * The instance type of that the EIP is bound.
         */
        instanceType: string;
        /**
         * EIP internet charge type.
         */
        internetChargeType: string;
        /**
         * Public IP Address of the the EIP.
         */
        ipAddress: string;
        /**
         * EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
         */
        status: string;
    }

    export interface GetElasticityAssurancesAssurance {
        /**
         * Details of resource allocation.
         */
        allocatedResources: outputs.ecs.GetElasticityAssurancesAssuranceAllocatedResource[];
        /**
         * Description of flexible guarantee service.
         */
        description: string;
        /**
         * The first ID of the resource
         */
        elasticityAssuranceId: string;
        /**
         * Flexible guarantee service failure time.
         */
        endTime: string;
        /**
         * ID of flexible guarantee service.
         */
        id: string;
        /**
         * The billing method of the instance. Possible value: PostPaid. Currently, only pay-as-you-go is supported.
         */
        instanceChargeType: string;
        /**
         * The ID of the elasticity assurance.
         */
        privatePoolOptionsId: string;
        /**
         * The matching mode of flexible guarantee service. Possible values:-Open: flexible guarantee service for Open mode.-Target: specifies the flexible guarantee service of the mode.
         */
        privatePoolOptionsMatchCriteria: string;
        /**
         * The name of the elasticity assurance.
         */
        privatePoolOptionsName: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * Flexible guarantee service effective time.
         */
        startTime: string;
        /**
         * Flexible guarantee effective way. Possible values:-Now: Effective immediately.-Later: the specified time takes effect.
         */
        startTimeType: string;
        /**
         * The status of flexible guarantee services. Possible values: `All`, `Preparing`, `Prepared`, `Active`, `Released`.
         */
        status: string;
        /**
         * The tag key-value pair information bound by the elastic guarantee service.
         */
        tags?: {[key: string]: any};
        /**
         * The total number of flexible guarantee services.
         */
        totalAssuranceTimes: string;
        /**
         * This parameter is not yet available.
         */
        usedAssuranceTimes: number;
    }

    export interface GetElasticityAssurancesAssuranceAllocatedResource {
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * The total number of instances that need to be reserved within an instance type.
         */
        totalAmount: number;
        /**
         * The number of instances that have been used.
         */
        usedAmount: number;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetHpcClustersCluster {
        /**
         * The description of ECS Hpc Cluster.
         */
        description: string;
        /**
         * The ID of the Hpc Cluster.
         */
        hpcClusterId: string;
        /**
         * The ID of the Hpc Cluster.
         */
        id: string;
        /**
         * The name of ECS Hpc Cluster.
         */
        name: string;
    }

    export interface GetImagesImage {
        /**
         * The image architecture. Valid values: `i386` and `x8664`.
         */
        architecture: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the image.
         */
        description: string;
        /**
         * Description of the system with disks and snapshots under the image.
         */
        diskDeviceMappings: outputs.ecs.GetImagesImageDiskDeviceMapping[];
        /**
         * ID of the image.
         */
        id: string;
        /**
         * The ID of the image.
         */
        imageId: string;
        /**
         * Alias of the image owner.
         */
        imageOwnerAlias: string;
        /**
         * Version of the image.
         */
        imageVersion: string;
        isCopied: boolean;
        isSelfShared: string;
        /**
         * Whether the user has subscribed to the terms of service for the image product corresponding to the ProductCode.
         */
        isSubscribed: boolean;
        /**
         * Specifies whether the image can be used on I/O optimized instances.
         */
        isSupportIoOptimized: boolean;
        name: string;
        /**
         * Display Chinese name of the OS.
         */
        osName: string;
        /**
         * Display English name of the OS.
         */
        osNameEn: string;
        /**
         * The operating system type of the image. Valid values: `windows` and `linux`.
         */
        osType: string;
        platform: string;
        /**
         * Product code of the image on the image market.
         */
        productCode: string;
        /**
         * Progress of image creation, presented in percentages.
         */
        progress: string;
        /**
         * Size of the created disk.
         */
        size: number;
        state: string;
        /**
         * The status of the image. The following values are available, Separate multiple parameter values by using commas (,). Default value: `Available`. Valid values:
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * Specifies whether to check the validity of the request without actually making the request. Valid values:
         */
        usage: string;
    }

    export interface GetImagesImageDiskDeviceMapping {
        /**
         * Device information of the created disk: such as /dev/xvdb.
         */
        device: string;
        /**
         * Size of the created disk.
         */
        size: string;
        /**
         * The ID of the snapshot used to create the custom image.
         */
        snapshotId: string;
    }

    export interface GetInstanceTypeFamiliesFamily {
        /**
         * The generation of the instance type family, Valid values: `ecs-1`, `ecs-2`, `ecs-3`, `ecs-4`, `ecs-5`, `ecs-6`. For more information, see [Instance type families](https://www.alibabacloud.com/help/doc-detail/25378.htm).
         */
        generation: string;
        /**
         * ID of the instance type family.
         */
        id: string;
        /**
         * A list of Zone to launch the instance.
         */
        zoneIds: string[];
    }

    export interface GetInstanceTypesInstanceType {
        /**
         * List of availability zones that support the instance type.
         */
        availabilityZones: string[];
        /**
         * The burstable instance attribution:
         * - initial_credit: The initial CPU credit of a burstable instance.
         * - baseline_credit:  The compute performance benchmark CPU credit of a burstable instance.
         */
        burstableInstance: outputs.ecs.GetInstanceTypesInstanceTypeBurstableInstance;
        /**
         * Filter the results to a specific number of cpu cores.
         */
        cpuCoreCount: number;
        /**
         * Filter the result whose network interface number is no more than `eniAmount`.
         */
        eniAmount: number;
        /**
         * The instance type family.
         */
        family: string;
        /**
         * The GPU attribution of an instance type:
         * - amount: The amount of GPU of an instance type.
         * - category: The category of GPU of an instance type.
         */
        gpu: outputs.ecs.GetInstanceTypesInstanceTypeGpu;
        /**
         * ID of the instance type.
         */
        id: string;
        /**
         * Local storage of an instance type:
         * - capacity: The capacity of a local storage in GB.
         * - amount:  The number of local storage devices that an instance has been attached to.
         * - category: The category of local storage that an instance has been attached to.
         */
        localStorage: outputs.ecs.GetInstanceTypesInstanceTypeLocalStorage;
        /**
         * Filter the results to a specific memory size in GB.
         */
        memorySize: number;
        /**
         * Indicates whether the cloud disk can be attached by using the nonvolatile memory express (NVMe) protocol. Valid values:
         * - required: The cloud disk can be attached by using the NVMe protocol.
         * - unsupported: The cloud disk cannot be attached by using the NVMe protocol.
         */
        nvmeSupport: string;
        price: string;
    }

    export interface GetInstanceTypesInstanceTypeBurstableInstance {
        baselineCredit: string;
        initialCredit: string;
    }

    export interface GetInstanceTypesInstanceTypeGpu {
        amount: string;
        category: string;
    }

    export interface GetInstanceTypesInstanceTypeLocalStorage {
        amount: string;
        capacity: string;
        category: string;
    }

    export interface GetInstancesInstance {
        /**
         * Availability zone where instances are located.
         */
        availabilityZone: string;
        /**
         * Instance creation time.
         */
        creationTime: string;
        /**
         * Instance description.
         */
        description: string;
        /**
         * Description of the attached disks.
         */
        diskDeviceMappings: outputs.ecs.GetInstancesInstanceDiskDeviceMapping[];
        /**
         * EIP address the VPC instance is using.
         */
        eip: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The image ID of some ECS instance used.
         */
        imageId: string;
        /**
         * Instance charge type.
         */
        instanceChargeType: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Instance network charge type.
         */
        internetChargeType: string;
        /**
         * Max output bandwidth for internet.
         */
        internetMaxBandwidthOut: number;
        /**
         * Key pair the instance is using.
         */
        keyName: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * Instance private IP address.
         */
        privateIp: string;
        /**
         * Instance public IP address.
         */
        publicIp: string;
        /**
         * The RAM role name which the instance attaches.
         */
        ramRoleName: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * The ID of resource group which the instance belongs.
         */
        resourceGroupId: string;
        /**
         * List of security group IDs the instance belongs to.
         */
        securityGroups: string[];
        /**
         * Spot strategy the instance is using.
         */
        spotStrategy: string;
        /**
         * Instance status. Valid values: "Creating", "Starting", "Running", "Stopping" and "Stopped". If undefined, all statuses are considered.
         */
        status: string;
        /**
         * A map of tags assigned to the ECS instances. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = alicloud.ecs.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * ID of the VPC linked to the instances.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the instances.
         */
        vswitchId: string;
    }

    export interface GetInstancesInstanceDiskDeviceMapping {
        /**
         * Cloud disk category.
         */
        category: string;
        /**
         * Device information of the created disk: such as /dev/xvdb.
         */
        device: string;
        /**
         * The ID of the Disk.
         */
        diskId: string;
        /**
         * The name of the Disk.
         */
        diskName: string;
        /**
         * Size of the created disk.
         */
        size: number;
        /**
         * Cloud disk type: system disk or data disk.
         */
        type: string;
    }

    export interface GetKeyPairsKeyPair {
        /**
         * A finger print used to retrieve specified key pair.
         */
        fingerPrint: string;
        /**
         * ID of the key pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetKeyPairsKeyPairInstance[];
        /**
         * Name of the key pair.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Id of resource group which the key pair belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetKeyPairsKeyPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * Name of the key pair.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetKeyPairsPair {
        /**
         * A finger print used to retrieve specified key pair.
         */
        fingerPrint: string;
        /**
         * ID of the key pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetKeyPairsPairInstance[];
        /**
         * Name of the key pair.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Id of resource group which the key pair belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetKeyPairsPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * Name of the key pair.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetNetworkInterfacesInterface {
        associatedPublicIps: outputs.ecs.GetNetworkInterfacesInterfaceAssociatedPublicIp[];
        /**
         * Creation time of the ENI.
         */
        creationTime: string;
        /**
         * Description of the ENI.
         */
        description: string;
        /**
         * ID of the ENI.
         */
        id: string;
        /**
         * ID of the instance that the ENI is attached to.
         */
        instanceId: string;
        /**
         * MAC address of the ENI.
         */
        mac: string;
        /**
         * Name of the ENI.
         */
        name: string;
        networkInterfaceId: string;
        networkInterfaceName: string;
        networkInterfaceTrafficMode: string;
        ownerId: string;
        primaryIpAddress: string;
        /**
         * Primary private IP of the ENI.
         */
        privateIp: string;
        privateIpAddresses: string[];
        /**
         * A list of secondary private IP address that is assigned to the ENI.
         */
        privateIps: string[];
        queueNumber: number;
        /**
         * The Id of resource group.
         */
        resourceGroupId: string;
        securityGroupIds: string[];
        /**
         * A list of security group that the ENI belongs to.
         */
        securityGroups: string[];
        serviceId: number;
        serviceManaged: boolean;
        /**
         * Current status of the ENI.
         */
        status: string;
        /**
         * A map of tags assigned to the ENI.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * ID of the VPC that the ENI belongs to.
         */
        vpcId: string;
        /**
         * ID of the VSwitch that the ENI is linked to.
         */
        vswitchId: string;
        /**
         * ID of the availability zone that the ENI belongs to.
         */
        zoneId: string;
    }

    export interface GetNetworkInterfacesInterfaceAssociatedPublicIp {
        publicIpAddress: string;
    }

    export interface GetSecurityGroupRulesRule {
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Target IP address segment for egress authorization.
         */
        destCidrIp: string;
        /**
         * Target security group id for ingress authorization.
         */
        destGroupId: string;
        /**
         * Alibaba Cloud account of the target security group.
         */
        destGroupOwnerAccount: string;
        /**
         * Authorization direction. Valid values are: `ingress` or `egress`.
         */
        direction: string;
        /**
         * The IP protocol. Valid values are: `tcp`, `udp`, `icmp`, `gre` and `all`.
         */
        ipProtocol: string;
        /**
         * Refers to the network type. Can be either `internet` or `intranet`. The default value is `internet`.
         */
        nicType: string;
        /**
         * Authorization policy. Can be either `accept` or `drop`. The default value is `accept`.
         */
        policy: string;
        /**
         * The range of port numbers.
         */
        portRange: string;
        /**
         * Rule priority.
         */
        priority: number;
        /**
         * Source IP address segment for ingress authorization.
         */
        sourceCidrIp: string;
        /**
         * Source security group ID for ingress authorization.
         */
        sourceGroupId: string;
        /**
         * Alibaba Cloud account of the source security group.
         */
        sourceGroupOwnerAccount: string;
    }

    export interface GetSecurityGroupsGroup {
        /**
         * Creation time of the security group.
         */
        creationTime: string;
        /**
         * The description of the security group.
         */
        description: string;
        /**
         * The ID of the security group.
         */
        id: string;
        /**
         * Whether to allow inner network access.
         */
        innerAccess: boolean;
        /**
         * The name of the security group.
         */
        name: string;
        /**
         * The Id of resource group which the securityGroup belongs.
         */
        resourceGroupId: string;
        /**
         * The type of the security group.
         */
        securityGroupType: string;
        /**
         * A map of tags assigned to the ECS instances. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedSecurityGroups = alicloud.ecs.getSecurityGroups({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * Used to retrieve security groups that belong to the specified VPC ID.
         */
        vpcId: string;
    }

    export interface GetSnapshotsSnapshot {
        category: string;
        /**
         * Creation time. Time of creation. It is represented according to ISO8601, and UTC time is used. Format: YYYY-MM-DDThh:mmZ.
         */
        creationTime: string;
        /**
         * Description of the snapshot.
         */
        description: string;
        diskId: string;
        /**
         * Whether the snapshot is encrypted or not.
         */
        encrypted: boolean;
        /**
         * ID of the snapshot.
         */
        id: string;
        instantAccess: boolean;
        instantAccessRetentionDays: number;
        /**
         * Name of the snapshot.
         */
        name: string;
        /**
         * Product code on the image market place.
         */
        productCode: string;
        /**
         * Progress of snapshot creation, presented in percentage.
         */
        progress: string;
        /**
         * The remaining time of a snapshot creation task, in seconds.
         */
        remainTime: number;
        resourceGroupId: string;
        /**
         * The number of days that an automatic snapshot retains in the console for your instance.
         */
        retentionDays: number;
        snapshotId: string;
        snapshotName: string;
        snapshotSn: string;
        snapshotType: string;
        /**
         * Source disk ID, which is retained after the source disk of the snapshot is deleted.
         */
        sourceDiskId: string;
        /**
         * Size of the source disk, measured in GB.
         */
        sourceDiskSize: string;
        /**
         * Source disk attribute. Value range: `System`,`Data`.
         */
        sourceDiskType: string;
        sourceStorageType: string;
        /**
         * The snapshot status. Value range: `progressing`, `accomplished` and `failed`.
         */
        status: string;
        /**
         * A map of tags assigned to the snapshot.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * Whether the snapshots are used to create resources or not. Value range: `image`, `disk`, `imageDisk` and `none`.
         */
        usage: string;
    }

    export interface ImageDiskDeviceMapping {
        /**
         * Specifies the name of a disk in the combined custom image. Value range: /dev/xvda to /dev/xvdz.
         */
        device: string;
        /**
         * Specifies the type of a disk in the combined custom image. If you specify this parameter, you can use a data disk snapshot as the data source of a system disk for creating an image. If it is not specified, the disk type is determined by the corresponding snapshot. Valid values: `system`, `data`,
         */
        diskType: string;
        /**
         * Specifies the size of a disk in the combined custom image, in GiB. Value range: 5 to 2000.
         */
        size: number;
        /**
         * Specifies a snapshot that is used to create a combined custom image.
         */
        snapshotId: string;
    }

    export interface ImageImportDiskDeviceMapping {
        /**
         * The name of disk N in the custom image.
         */
        device: string;
        /**
         * Resolution size. You must ensure that the system disk space  file system space. Ranges: When n = 1, the system disk: 5 ~ 500GiB, When n = 2 ~ 17, that is, data disk: 5 ~ 1000GiB, When temporary is introduced, the system automatically detects the size, which is subject to the detection result.
         */
        diskImageSize?: number;
        /**
         * Image format. Value range: When the `RAW`, `VHD`, `qcow2` is imported into the image, the system automatically detects the image format, whichever comes first.
         */
        format: string;
        /**
         * Save the exported OSS bucket.
         */
        ossBucket?: string;
        /**
         * The file name of your OSS Object.
         *
         * > **NOTE:** The diskDeviceMapping is a list and it's first item will be used to system disk and other items are used to data disks.
         */
        ossObject?: string;
    }

    export interface InstanceDataDisk {
        /**
         * The ID of the automatic snapshot policy applied to the system disk.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The category of the disk:
         */
        category?: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_essd, cloudSsd disk. If the category of this data disk was ephemeral_ssd, please don't set this param. Default value: `true`.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * The mount point of the data disk.
         */
        device?: string;
        /**
         * Encrypted the data in this disk. Default value: `false`.
         */
        encrypted?: boolean;
        /**
         * The KMS key ID corresponding to the Nth data disk.
         */
        kmsKeyId?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as data disk:
         */
        performanceLevel: string;
        /**
         * The size of the data disk.
         * - cloud[5, 2000]
         * - cloud_efficiency[20, 32768]
         * - cloud_ssd[20, 32768]
         * - cloud_essd[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface InstanceMaintenanceTime {
        /**
         * The end time of maintenance. The time must be on the hour at exactly 0 minute and 0 second. The `startTime` and `endTime` parameters must be specified at the same time. The `endTime` value must be 1 to 23 hours later than the `startTime` value. Specify the time in the HH:mm:ss format. The time must be in UTC+8.
         */
        endTime?: string;
        /**
         * The start time of maintenance. The time must be on the hour at exactly 0 minute and 0 second. The `startTime` and `endTime` parameters must be specified at the same time. The `endTime` value must be 1 to 23 hours later than the `startTime` value. Specify the time in the HH:mm:ss format. The time must be in UTC+8.
         */
        startTime?: string;
    }

    export interface LaunchTemplateDataDisk {
        /**
         * The category of the disk:
         * - cloud: Basic cloud disk.
         * - cloud_efficiency: Ultra cloud disk.
         * - cloud_ssd: SSD cloud Disks.
         * - ephemeral_ssd: local SSD Disks
         * - cloud_essd: ESSD cloud Disks.
         *
         * Default to `cloudEfficiency`.
         */
        category?: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloudSsd and cloudEssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
         *
         * Default to true
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * Encrypted the data in this disk.
         *
         * Default to false
         */
        encrypted?: boolean;
        /**
         * The name of the data disk.
         */
        name?: string;
        performanceLevel?: string;
        /**
         * The size of the data disk.
         * - cloud[5, 2000]
         * - cloud_efficiency[20, 32768]
         * - cloud_ssd[20, 32768]
         * - cloud_essd[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size?: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface LaunchTemplateNetworkInterfaces {
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp?: string;
        /**
         * The security group ID must be one in the same VPC.
         */
        securityGroupId?: string;
        /**
         * The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
         */
        vswitchId?: string;
    }

    export interface LaunchTemplateSystemDisk {
        /**
         * The category of the disk:
         * - cloud: Basic cloud disk.
         * - cloud_efficiency: Ultra cloud disk.
         * - cloud_ssd: SSD cloud Disks.
         * - ephemeral_ssd: local SSD Disks
         * - cloud_essd: ESSD cloud Disks.
         *
         * Default to `cloudEfficiency`.
         */
        category: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloudSsd and cloudEssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
         *
         * Default to true
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description: string;
        iops?: string;
        /**
         * The name of the data disk.
         */
        name: string;
        performanceLevel?: string;
        /**
         * The size of the data disk.
         * - cloud[5, 2000]
         * - cloud_efficiency[20, 32768]
         * - cloud_ssd[20, 32768]
         * - cloud_essd[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size: number;
    }

    export interface ReservedInstanceOperationLock {
        /**
         * The reason why the reserved instance was locked.
         */
        lockReason: string;
    }

}

export namespace edas {
    export interface GetApplicationsApplication {
        /**
         * The ID of the application that you want to deploy.
         */
        appId: string;
        /**
         * The name of your EDAS application. Only letters '-' '_' and numbers are allowed. The length cannot exceed 36 characters.
         */
        appName: string;
        /**
         * The type of the package for the deployment of the application that you want to create. The valid values are: WAR and JAR. We strongly recommend you to set this parameter when creating the application.
         */
        applicationType: string;
        /**
         * The package ID of Enterprise Distributed Application Service (EDAS) Container.
         */
        buildPackageId: number;
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The type of the cluster that you want to create. Valid values: 1: Swarm cluster. 2: ECS cluster. 3: Kubernates cluster.
         */
        clusterType: number;
        /**
         * The ID of the namespace the application belongs to.
         */
        regionId: string;
    }

    export interface GetClustersCluster {
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The name of the cluster.
         */
        clusterName: string;
        /**
         * The type of the cluster, Valid values: 1: Swarm cluster. 2: ECS cluster. 3: Kubernates cluster.
         */
        clusterType: number;
        /**
         * The total number of CPUs in the cluster.
         */
        cpu: number;
        /**
         * The number of used CPUs in the cluster.
         */
        cpuUsed: number;
        /**
         * Cluster's creation time.
         */
        createTime: number;
        /**
         * The total amount of memory in the cluser. Unit: MB.
         */
        mem: number;
        /**
         * The amount of used memory in the cluser. Unit: MB.
         */
        memUsed: number;
        /**
         * The network type of the cluster. Valid values: 1: classic network. 2: VPC.
         */
        networkMode: number;
        /**
         * The number of the Elastic Compute Service (ECS) instances that are deployed to the cluster.
         */
        nodeNum: number;
        /**
         * The ID of the namespace the application belongs to.
         */
        regionId: string;
        /**
         * The time when the cluster was last updated.
         */
        updateTime: number;
        /**
         * The ID of the Virtual Private Cloud (VPC) for the cluster.
         */
        vpcId: string;
    }

    export interface GetDeployGroupsGroup {
        /**
         * ID of the EDAS application.
         */
        appId: string;
        /**
         * The version of the deployment package for the application.
         */
        appVersionId: string;
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The time when the instance group was created.
         */
        createTime: number;
        /**
         * The ID of the instance group.
         */
        groupId: string;
        /**
         * The name of the instance group. The length cannot exceed 64 characters.
         */
        groupName: string;
        /**
         * The type of the instance group. Valid values: 0: Default group. 1: Phased release is disabled for traffic management. 2: Phased release is enabled for traffic management.
         */
        groupType: number;
        /**
         * The version of the deployment package for the instance group that was created.
         */
        packageVersionId: string;
        /**
         * The time when the instance group was updated.
         */
        updateTime: number;
    }

    export interface GetNamespacesNamespace {
        /**
         * The ID of the physical region to which the namespace belongs.
         */
        belongRegion: string;
        /**
         * Indicates whether remote debugging is allowed in this region.
         */
        debugEnable: boolean;
        /**
         * The description of the namespace.
         */
        description: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The unique ID of the namespace generated by Enterprise Distributed Application Service (EDAS).
         */
        namespaceId: string;
        /**
         * The ID of the namespace. **Note:** The ID cannot be changed after the namespace is created. The ID is in the format of `Physical region ID:Logical region identifier`.
         */
        namespaceLogicalId: string;
        /**
         * The name of the namespace.
         */
        namespaceName: string;
        /**
         * The ID of the Alibaba Cloud account to which the namespace belongs.
         */
        userId: string;
    }

    export interface K8sSlbAttachmentSlbConfig {
        /**
         * The name of this SLB configuration, empty for auto-generated by EDAS server.
         */
        name: string;
        /**
         * The port configuration for SLB instance, which is supported for multiple configurations. See `portMappings` below.
         */
        portMappings: outputs.edas.K8sSlbAttachmentSlbConfigPortMapping[];
        /**
         * The scheduler policy of SLB configuration, values can be 'rr'(round-robin) or 'wrr'(weighted round-robin).
         */
        scheduler: string;
        /**
         * The ID of your SLB instance, if value is empty which means EDAS will purchase an SLB instance with 'specification' field.
         */
        slbId: string;
        /**
         * The instance specification of SLB, values can be found [here](https://www.alibabacloud.com/help/en/server-load-balancer/latest/createloadbalancer-2#t4182.html), empty for 'slb.s1.small'.
         */
        specification?: string;
        /**
         * The type of SLB instance, values can be 'internet' or 'intranet'.
         */
        type: string;
    }

    export interface K8sSlbAttachmentSlbConfigPortMapping {
        /**
         * The ID of your tls certification, this is used for 'HTTPS' protocol only.
         */
        certId?: string;
        /**
         * The protocol of SLB instance configuration, values can be 'TCP', 'HTTP' or 'HTTPS'.
         */
        loadbalancerProtocol: string;
        /**
         * The backend k8s service configuration for SLB instance, which is supported for multiple configurations. See `servicePort` below.
         */
        servicePort: outputs.edas.K8sSlbAttachmentSlbConfigPortMappingServicePort;
    }

    export interface K8sSlbAttachmentSlbConfigPortMappingServicePort {
        /**
         * The port of k8s service, values should be within range [1, 65535].
         */
        port: number;
        /**
         * The protocol of k8s service, values can be 'TCP' or 'UDP'.
         */
        protocol: string;
        /**
         * The port of k8s pod, values should be within range [1, 65535].
         */
        targetPort: number;
    }

}

export namespace eds {
    export interface CustomPropertyPropertyValue {
        /**
         * The value of an attribute.
         */
        propertyValue?: string;
        /**
         * The value of an attribute id.
         */
        propertyValueId: string;
    }

    export interface EcdPolicyGroupAuthorizeAccessPolicyRule {
        /**
         * The cidrip of authorize access rule.
         */
        cidrIp?: string;
        /**
         * The description of authorize access rule.
         */
        description?: string;
    }

    export interface EcdPolicyGroupAuthorizeSecurityPolicyRule {
        /**
         * The cidrip of security rules.
         */
        cidrIp?: string;
        /**
         * The description of security rules.
         */
        description?: string;
        /**
         * The ip protocol of security rules.
         */
        ipProtocol?: string;
        /**
         * The policy of security rules.
         */
        policy?: string;
        /**
         * The port range of security rules.
         */
        portRange?: string;
        /**
         * The priority of security rules.
         */
        priority?: string;
        /**
         * The type of security rules.
         */
        type?: string;
    }

    export interface GetAdConnectorDirectoriesDirectory {
        /**
         * The ID of the ad connector directory.
         */
        adConnectorDirectoryId: string;
        /**
         * The AD connectors.
         */
        adConnectors: outputs.eds.GetAdConnectorDirectoriesDirectoryAdConnector[];
        /**
         * The CreateTime of resource.
         */
        createTime: string;
        /**
         * The ID of the security group.
         */
        customSecurityGroupId: string;
        /**
         * The name of directory.
         */
        directoryName: string;
        /**
         * The name of the domain.
         */
        directoryType: string;
        /**
         * The address of DNSAddress.
         */
        dnsAddresses: string[];
        /**
         * The username of DNS.
         */
        dnsUserName: string;
        /**
         * The name of the domain.
         */
        domainName: string;
        /**
         * domain admin user name.
         */
        domainUserName: string;
        /**
         * Whether to grant local administrator rights to users who use cloud desktops.
         */
        enableAdminAccess: boolean;
        /**
         * The ID of the Ad Connector Directory.
         */
        id: string;
        /**
         * Whether MFA authentication is enabled. After all AD users in this directory log on to the cloud desktop, enter the correct password and then enter the dynamic verification code generated by the MFA device.
         */
        mfaEnabled: boolean;
        /**
         * The status of directory.
         */
        status: string;
        /**
         * The Enterprise already has the DNS address of the AD subdomain.
         */
        subDnsAddresses: string[];
        /**
         * The Enterprise already has a fully qualified domain name (FQDN) of an AD subdomain, with both a host name and a domain name.
         */
        subDomainName: string;
        /**
         * The trust password.
         */
        trustPassword: string;
        /**
         * The ID of the vpc.
         */
        vpcId: string;
        /**
         * List of VSwitch IDs in the directory.
         */
        vswitchIds: string[];
    }

    export interface GetAdConnectorDirectoriesDirectoryAdConnector {
        /**
         * The address of AD connector.
         */
        adConnectorAddress: string;
        /**
         * The status of connector.
         */
        connectorStatus: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The AD Connector specifications.
         */
        specification: string;
        /**
         * The AD Connector control trust password.
         */
        trustKey: string;
        /**
         * The ID of VSwitch.
         */
        vswitchId: string;
    }

    export interface GetAdConnectorOfficeSitesSite {
        /**
         * The Name of the ad connector office site.
         */
        adConnectorOfficeSiteName: string;
        /**
         * AD Connector Collection of Information.
         */
        adConnectors: outputs.eds.GetAdConnectorOfficeSitesSiteAdConnector[];
        /**
         * The Internet Bandwidth Peak. Possible Values: 0~200. If This Field Is Set to 0, Indicates That There Is No Open Internet Access.
         */
        bandwidth: number;
        /**
         * Cloud Enterprise Network Instance Id.
         */
        cenId: string;
        /**
         * Workspace Corresponds to the Security Office Network of IPv4 Segment.
         */
        cidrBlock: string;
        /**
         * Workspace Creation Time.
         */
        createTime: string;
        /**
         * Security Group ID.
         */
        customSecurityGroupId: string;
        /**
         * The method that is used to connect the client to cloud desktops.
         */
        desktopAccessType: string;
        /**
         * The endpoint that is used to connect to cloud desktops over a VPC.
         */
        desktopVpcEndpoint: string;
        /**
         * Enterprise Ad Corresponding DNS Address.
         */
        dnsAddresses: string[];
        /**
         * The Easy-to-Use DNS Name.
         */
        dnsUserName: string;
        /**
         * Enterprise of Ad Domain Name.
         */
        domainName: string;
        /**
         * The Domain Administrator's Username.
         */
        domainUserName: string;
        /**
         * Whether to Use Cloud Desktop User Empowerment of Local Administrator Permissions.
         */
        enableAdminAccess: boolean;
        /**
         * Indicates whether the desktop communication feature is enabled for cloud desktops in the same workspace. After the feature is enabled, the cloud desktops in the same workspace can access each other.
         */
        enableCrossDesktopAccess: boolean;
        /**
         * Whether the Open Internet Access Function.
         */
        enableInternetAccess: boolean;
        /**
         * NAS File System ID.
         */
        fileSystemIds: string[];
        /**
         * The ID of the Ad Connector Office Site.
         */
        id: string;
        /**
         * Registered Log Information.
         */
        logs: outputs.eds.GetAdConnectorOfficeSitesSiteLog[];
        /**
         * Whether to Enable Multi-Factor Authentication MFA.
         */
        mfaEnabled: boolean;
        /**
         * The ID of the Internet Access.
         */
        networkPackageId: string;
        /**
         * The ID of the Workspace.
         */
        officeSiteId: string;
        /**
         * Workspace Account System Type. Possible Values: Simple: Convenient Account. AD_CONNECTOR: Enterprise Ad Account.
         */
        officeSiteType: string;
        /**
         * Whether to Enable Single Sign-on (SSO) for User-Based SSO.
         */
        ssoEnabled: boolean;
        /**
         * The workspace status.
         */
        status: string;
        /**
         * Sub-Domain DNS Address.
         */
        subDomainDnsAddresses: string[];
        /**
         * The AD Domain DNS Name.
         */
        subDomainName: string;
        /**
         * The AD Trust Password.
         */
        trustPassword: string;
        /**
         * Security Office VPC ID.
         */
        vpcId: string;
        /**
         * The vswitch ids.
         */
        vswitchIds: string[];
    }

    export interface GetAdConnectorOfficeSitesSiteAdConnector {
        /**
         * AD Connector across Zones, Its Connection Addresses.
         */
        adConnectorAddress: string;
        /**
         * AD Connector of the State. Possible Values: Creating: in the Creation of. Connecting: Connection. Requires the User to Your Own Ad Configured on the Domain to Which. Running: Run. Expired: If You Are out-of-Date. CONNECT_ERROR: Connection Error.
         */
        connectorStatus: string;
        /**
         * AD Connector Mount of the Card ID.
         */
        networkInterfaceId: string;
        /**
         * AD Connector in the Network Corresponding to the ID of the VSwitch in.
         */
        vswitchId: string;
    }

    export interface GetAdConnectorOfficeSitesSiteLog {
        /**
         * Log Level. Possible Values: Info: Information Error: Error Warn: Warning.
         */
        level: string;
        /**
         * The Log Details.
         */
        message: string;
        /**
         * Log Information Corresponding to the Step.
         */
        step: string;
        /**
         * Log Print Time.
         */
        timeStamp: string;
    }

    export interface GetBundlesBundle {
        /**
         * The bundle id of the bundle.
         */
        bundleId: string;
        /**
         * The name of the bundle.
         */
        bundleName: string;
        /**
         * The bundle type of  the bundle. Valid values: `SYSTEM`,`CUSTOM`.
         */
        bundleType: string;
        /**
         * The description of the bundle.
         */
        description: string;
        /**
         * The desktop type of the bundle.
         */
        desktopType: string;
        /**
         * The desktop type attribute of the bundle.
         */
        desktopTypeAttributes: outputs.eds.GetBundlesBundleDesktopTypeAttribute[];
        /**
         * The disks of the bundle.
         */
        disks: outputs.eds.GetBundlesBundleDisk[];
        /**
         * The ID of the bundle.
         */
        id: string;
        /**
         * The image id attribute of the bundle.
         */
        imageId: string;
        /**
         * The os type attribute of the bundle.
         */
        osType: string;
    }

    export interface GetBundlesBundleDesktopTypeAttribute {
        /**
         * The cpu count attribute of the bundle.
         */
        cpuCount: number;
        /**
         * The gpu count attribute of the bundle.
         */
        gpuCount: string;
        /**
         * The gpu spec attribute of the bundle.
         */
        gpuSpec: string;
        /**
         * The memory size attribute of the bundle.
         */
        memorySize: string;
    }

    export interface GetBundlesBundleDisk {
        /**
         * The disk size attribute of the bundle.
         */
        diskSize: string;
        /**
         * The disk type attribute of the bundle.
         */
        diskType: string;
    }

    export interface GetCommandsCommand {
        /**
         * The Contents of the Script to Base64 Encoded Transmission.
         */
        commandContent: string;
        /**
         * The Script Type. Valid values: `RunBatScript`, `RunPowerShellScript`.
         */
        commandType: string;
        /**
         * The Task of Creation Time.
         */
        createTime: string;
        /**
         * The ID of the Command.
         */
        id: string;
        /**
         * The Implementation of the Target Cloud Desktop Collection.
         */
        invokeDesktops: outputs.eds.GetCommandsCommandInvokeDesktop[];
        /**
         * The invoke id of the Command.
         */
        invokeId: string;
        /**
         * Script Is Executed in the Overall Implementation of the State. Valid values: `Pending`, `Failed`, `PartialFailed`, `Running`, `Stopped`, `Stopping`, `Finished`, `Success`.
         */
        status: string;
    }

    export interface GetCommandsCommandInvokeDesktop {
        /**
         * The desktop id of the Desktop.
         */
        desktopId: string;
        /**
         * Output Field Text Length Exceeds 24 KB of Truncated Discarded Text Length.
         */
        dropped: number;
        /**
         * Command of the Failure Or Perform the Reason for the Failure of the Code.
         */
        errorCode: string;
        /**
         * Command of the Failure Or Perform the Reason for the Failure of the Details.
         */
        errorInfo: string;
        /**
         * Command of the Failure Or Perform the Reason for the Failure of the Details.
         */
        exitCode: string;
        /**
         * The Script Process until the End of Time.
         */
        finishTime: string;
        /**
         * A Single Cloud Desktop Script Progress Status.
         */
        invocationStatus: string;
        /**
         * Script the Output of the Process.
         */
        output: string;
        /**
         * Command in the Desktop Implementation.
         */
        repeats: number;
        /**
         * The Script Process on the Desktop, in the Start Timing of the Execution.
         */
        startTime: string;
        /**
         * If You Use the invocation Indicates That the Call of the Time.
         */
        stopTime: string;
    }

    export interface GetCustomPropertiesProperty {
        /**
         * The first ID of the resource.
         */
        customPropertyId: string;
        /**
         * The ID of the Custom Property.
         */
        id: string;
        /**
         * The Custom attribute key.
         */
        propertyKey: string;
        /**
         * Custom attribute sets the value of.
         */
        propertyValues: outputs.eds.GetCustomPropertiesPropertyPropertyValue[];
    }

    export interface GetCustomPropertiesPropertyPropertyValue {
        /**
         * The value of an attribute.
         */
        propertyValue: string;
        /**
         * The value of an attribute id.
         */
        propertyValueId: string;
    }

    export interface GetDesktopTypesType {
        /**
         * The CPU cores.
         */
        cpuCount: string;
        /**
         * The size of the data disk. Unit: GiB.
         */
        dataDiskSize: string;
        /**
         * Specification ID.
         */
        desktopTypeId: string;
        /**
         * The GPU cores.
         */
        gpuCount: number;
        /**
         * The GPU video memory.
         */
        gpuSpec: string;
        /**
         * The ID of the Desktop Type.
         */
        id: string;
        /**
         * The Specification family.
         */
        instanceTypeFamily: string;
        /**
         * The Memory size. Unit: MiB.
         */
        memorySize: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The size of the system disk. Unit: GiB.
         */
        systemDiskSize: string;
    }

    export interface GetDesktopsDesktop {
        /**
         * The number of CPUs.
         */
        cpu: number;
        /**
         * The creation time of the Desktop.
         */
        createTime: string;
        /**
         * The desktop id of the Desktop.
         */
        desktopId: string;
        /**
         * The desktop name of the Desktop.
         */
        desktopName: string;
        /**
         * The desktop type of the Desktop.
         */
        desktopType: string;
        /**
         * The directory id of the Desktop.
         */
        directoryId: string;
        /**
         * The desktop end user id of the Desktop.
         */
        endUserIds: string[];
        /**
         * The expired time of the Desktop.
         */
        expiredTime: string;
        /**
         * The ID of the Desktop.
         */
        id: string;
        /**
         * The image id of the Desktop.
         */
        imageId: string;
        /**
         * The memory of the Desktop.
         */
        memory: string;
        /**
         * The network interface id of the Desktop.
         */
        networkInterfaceId: string;
        /**
         * The payment type of the Desktop.
         */
        paymentType: string;
        /**
         * The policy group id of the Desktop.
         */
        policyGroupId: string;
        /**
         * The status of the Desktop. Valid values: `Deleted`, `Expired`, `Pending`, `Running`, `Starting`, `Stopped`, `Stopping`.
         */
        status: string;
        /**
         * The system disk size of the Desktop.
         */
        systemDiskSize: number;
    }

    export interface GetImagesImage {
        /**
         * The creation time of the image.
         */
        createTime: string;
        /**
         * The size of data disk of the image.
         */
        dataDiskSize: number;
        /**
         * The description of the image.
         */
        description: string;
        /**
         * The Gpu Category of the image.
         */
        gpuCategory: boolean;
        /**
         * The ID of the Image.
         */
        id: string;
        /**
         * The image id of the image.
         */
        imageId: string;
        /**
         * The image name.
         */
        imageName: string;
        /**
         * The image type of the image. Valid values: `SYSTEM`, `CUSTOM`.
         */
        imageType: string;
        /**
         * The os type of the image.
         */
        osType: string;
        /**
         * The progress of the image.
         */
        progress: string;
        /**
         * The size of the image.
         */
        size: number;
        /**
         * The status of the image. Valid values: `Creating`, `Available`, `CreateFailed`.
         */
        status: string;
    }

    export interface GetNasFileSystemsSystem {
        /**
         * The capacity of nas file system.
         */
        capacity: string;
        /**
         * The create time of nas file system.
         */
        createTime: string;
        /**
         * The description of nas file system.
         */
        description: string;
        /**
         * The filesystem id of nas file system.
         */
        fileSystemId: string;
        /**
         * The type of nas file system.
         */
        fileSystemType: string;
        /**
         * The ID of the Nas File System.
         */
        id: string;
        /**
         * The size of metered.
         */
        meteredSize: string;
        /**
         * The domain of mount target.
         */
        mountTargetDomain: string;
        /**
         * The status of mount target. Valid values: `Pending`, `Active`, `Inactive`,`Deleting`,`Invalid`.
         */
        mountTargetStatus: string;
        /**
         * The name of nas file system.
         */
        nasFileSystemName: string;
        /**
         * The ID of office site.
         */
        officeSiteId: string;
        /**
         * The name of office site.
         */
        officeSiteName: string;
        /**
         * The status of nas file system. Valid values: `Pending`, `Running`, `Stopped`,`Deleting`, `Deleted`, `Invalid`.
         */
        status: string;
        /**
         * The storage type of nas file system.
         */
        storageType: string;
        /**
         * Whether to support Acl.
         */
        supportAcl: boolean;
        /**
         * The zone id of nas file system.
         */
        zoneId: string;
    }

    export interface GetNetworkPackagesPackage {
        /**
         * The bandwidth of package.
         */
        bandwidth: number;
        /**
         * The creation time of network package.
         */
        createTime: string;
        /**
         * The public IP address list of the network packet.
         */
        eipAddresses: string[];
        /**
         * The expired time of package.
         */
        expiredTime: string;
        /**
         * The ID of the Network Package.
         */
        id: string;
        /**
         * The internet charge type  of  package.
         */
        internetChargeType: string;
        /**
         * The ID of network package.
         */
        networkPackageId: string;
        /**
         * The ID of office site.
         */
        officeSiteId: string;
        /**
         * The name of office site.
         */
        officeSiteName: string;
        /**
         * The status of network package. Valid values: `Creating`, `InUse`, `Releasing`,`Released`.
         */
        status: string;
    }

    export interface GetPolicyGroupsGroup {
        /**
         * The rule of authorize access rule.
         */
        authorizeAccessPolicyRules: outputs.eds.GetPolicyGroupsGroupAuthorizeAccessPolicyRule[];
        /**
         * The policy rule.
         */
        authorizeSecurityPolicyRules: outputs.eds.GetPolicyGroupsGroupAuthorizeSecurityPolicyRule[];
        /**
         * Whether to enable local camera redirection. Valid values: `on`, `off`.
         */
        cameraRedirect: string;
        /**
         * The clipboard policy.
         */
        clipboard: string;
        /**
         * The list of domain.
         */
        domainList: string;
        /**
         * The count of eds.
         */
        edsCount: number;
        /**
         * The access of html5.
         */
        htmlAccess: string;
        /**
         * The html5 file transfer.
         */
        htmlFileTransfer: string;
        /**
         * The ID of the Policy Group.
         */
        id: string;
        /**
         * Local drive redirect policy.
         */
        localDrive: string;
        /**
         * The policy group id.
         */
        policyGroupId: string;
        /**
         * The name of policy group.
         */
        policyGroupName: string;
        /**
         * The type of policy group.
         */
        policyGroupType: string;
        /**
         * Whether to enable screen recording. Valid values: `off`, `alltime`, `period`.
         */
        recording: string;
        /**
         * The end time of recording.
         */
        recordingEndTime: string;
        /**
         * The fps of recording. Valid values: `2`, `5`, `10`, `15`.
         */
        recordingFps: number;
        /**
         * The start time of recording.
         */
        recordingStartTime: string;
        /**
         * The status of policy.
         */
        status: string;
        /**
         * The usb redirect policy.
         */
        usbRedirect: string;
        /**
         * The quality of visual.sae_ecdsae_nameecd_po
         */
        visualQuality: string;
        /**
         * The watermark policy.
         */
        watermark: string;
        /**
         * The watermark transparency.
         */
        watermarkTransparency: string;
        /**
         * The type of watemark.
         */
        watermarkType: string;
    }

    export interface GetPolicyGroupsGroupAuthorizeAccessPolicyRule {
        /**
         * The cidrip of security rules.
         */
        cidrIp: string;
        /**
         * The description of security rules.
         */
        description: string;
    }

    export interface GetPolicyGroupsGroupAuthorizeSecurityPolicyRule {
        /**
         * The cidrip of security rules.
         */
        cidrIp: string;
        /**
         * The description of security rules.
         */
        description: string;
        /**
         * The ip protocol of security rules.
         */
        ipProtocol: string;
        /**
         * The policy of security rules.
         */
        policy: string;
        /**
         * The port range of security rules.
         */
        portRange: string;
        /**
         * The priority of security rules.
         */
        priority: string;
        /**
         * The type of security rules.
         */
        type: string;
    }

    export interface GetRamDirectoriesDirectory {
        /**
         * The AD connectors.
         */
        adConnectors: outputs.eds.GetRamDirectoriesDirectoryAdConnector[];
        /**
         * The CreateTime of resource.
         */
        createTime: string;
        /**
         * The id of the custom security group.
         */
        customSecurityGroupId: string;
        /**
         * The desktop access type.
         */
        desktopAccessType: string;
        /**
         * The desktop vpc endpoint.
         */
        desktopVpcEndpoint: string;
        /**
         * The directory type.
         */
        directoryType: string;
        /**
         * The address of DNSAddress.
         */
        dnsAddresses: string[];
        /**
         * The username of DNS.
         */
        dnsUserName: string;
        /**
         * The name of the domain.
         */
        domainName: string;
        /**
         * The domain password.
         */
        domainPassword: string;
        /**
         * The username of the domain.
         */
        domainUserName: string;
        /**
         * Whether to enable admin access.
         */
        enableAdminAccess: boolean;
        /**
         * Whether to enable cross desktop access.
         */
        enableCrossDesktopAccess: boolean;
        /**
         * Whether enable internet access.
         */
        enableInternetAccess: boolean;
        /**
         * The ids of filesystem.
         */
        fileSystemIds: string[];
        /**
         * The ID of the Ram Directory.
         */
        id: string;
        /**
         * The register log information.
         */
        logs: outputs.eds.GetRamDirectoriesDirectoryLog[];
        /**
         * Whether to enable MFA.
         */
        mfaEnabled: boolean;
        /**
         * The ID of ram directory.
         */
        ramDirectoryId: string;
        /**
         * The name of directory.
         */
        ramDirectoryName: string;
        /**
         * Whether to enable SSO.
         */
        ssoEnabled: boolean;
        /**
         * The status of directory.
         */
        status: string;
        /**
         * The address of sub DNS.
         */
        subDnsAddresses: string[];
        /**
         * The Name of the sub-domain.
         */
        subDomainName: string;
        /**
         * The trust password.
         */
        trustPassword: string;
        /**
         * The ID of the vpc.
         */
        vpcId: string;
        /**
         * List of VSwitch IDs in the directory.
         */
        vswitchIds: string[];
    }

    export interface GetRamDirectoriesDirectoryAdConnector {
        /**
         * The address of AD connector.
         */
        adConnectorAddress: string;
        /**
         * The status of connector.
         */
        connectorStatus: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ID of VSwitch.
         */
        vswitchId: string;
    }

    export interface GetRamDirectoriesDirectoryLog {
        /**
         * The level of log.
         */
        level: string;
        /**
         * The message of log.
         */
        message: string;
        /**
         * The step of log.
         */
        step: string;
        /**
         * The time stamp of log.
         */
        timeStamp: string;
    }

    export interface GetSimpleOfficeSitesSite {
        /**
         * The Internet Bandwidth Peak. It has been deprecated from version 1.142.0 and can be found in the new datasource alicloud_ecd_network_packages.
         *
         * @deprecated Field 'bandwidth' has been deprecated from provider version 1.142.0.
         */
        bandwidth: number;
        /**
         * Cloud Enterprise Network Instance Id.
         */
        cenId: string;
        /**
         * Workspace Corresponds to the Security Office Network of IPv4 Segment.
         */
        cidrBlock: string;
        /**
         * Workspace Creation Time.
         */
        createTime: string;
        /**
         * Security Group ID.
         */
        customSecurityGroupId: string;
        /**
         * Connect to the Cloud Desktop Allows the Use of the Access Mode of. Possible Values: the Internet: Only Allows the Client to Public Cloud Desktop. Virtual Private Cloud (VPC): Only Allows in the Virtual Private Cloud (VPC) in the Client to Connect to the Cloud Desktop. Any: Not by Way of Limitation. Use Client to Connect to the Cloud Desktop When It Is Possible to Choose the Connection.
         */
        desktopAccessType: string;
        /**
         * The Desktop Vpc Endpoint.
         */
        desktopVpcEndpoint: string;
        /**
         * Enterprise Ad Corresponding DNS Address.
         */
        dnsAddresses: string[];
        /**
         * Easy-to-Use DNS Name.
         */
        dnsUserName: string;
        /**
         * Enterprise of Ad Domain Name.
         */
        domainName: string;
        /**
         * Domain of the User Who Will Administer This Target Application Password.
         */
        domainPassword: string;
        /**
         * The Domain Administrator's Username.
         */
        domainUserName: string;
        /**
         * Whether to Use Cloud Desktop User Empowerment of Local Administrator Permissions.
         */
        enableAdminAccess: boolean;
        /**
         * Enable Cross-Desktop Access.
         */
        enableCrossDesktopAccess: boolean;
        /**
         * Whether the Open Internet Access Function.
         *
         * @deprecated Field 'enable_internet_access' has been deprecated from provider version 1.142.0.
         */
        enableInternetAccess: boolean;
        /**
         * NAS File System ID.
         */
        fileSystemIds: string[];
        /**
         * The ID of the Simple Office Site.
         */
        id: string;
        /**
         * Whether to Enable Multi-Factor Authentication MFA.
         */
        mfaEnabled: boolean;
        /**
         * Internet Access ID.
         */
        networkPackageId: string;
        /**
         * The Workspace ID.
         */
        officeSiteId: string;
        /**
         * Workspace Account System Type. Possible Values: Simple: Convenient Account. AD_CONNECTOR: Enterprise Ad Account.
         */
        officeSiteType: string;
        /**
         * The simple office site name.
         */
        simpleOfficeSiteName: string;
        /**
         * Whether to Enable Single Sign-on (SSO) for User-Based SSO.
         */
        ssoEnabled: boolean;
        /**
         * Whether to Enable Single Sign-on (SSO) for User-Based SSO.
         */
        ssoStatus: boolean;
        /**
         * Workspace State. Possible Values: Registering: Registered in the Registered: Registered.
         */
        status: string;
        /**
         * AD Subdomain of the DNS Address.
         */
        subDnsAddresses: string[];
        /**
         * AD Domain DNS Name.
         */
        subDomainName: string;
        /**
         * AD Trust Password.
         */
        trustPassword: string;
        /**
         * Security Office VPC ID.
         */
        vpcId: string;
        /**
         * The vswitch ids.
         */
        vswitchIds: string[];
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The time when the snapshot was created.
         */
        createTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The ID of the cloud desktop to which the snapshot belongs.
         */
        desktopId: string;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The progress of creating the snapshot.
         */
        progress: string;
        /**
         * The remaining time that is required to create the snapshot. Unit: seconds.
         */
        remainTime: number;
        /**
         * The ID of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The type of the snapshot.
         */
        snapshotType: string;
        /**
         * The capacity of the source disk. Unit: GiB.
         */
        sourceDiskSize: string;
        /**
         * The type of the source disk.
         */
        sourceDiskType: string;
        /**
         * The status of the snapshot.
         */
        status: string;
    }

    export interface GetUsersUser {
        /**
         * The email of the user email.
         */
        email: string;
        /**
         * The Username. The custom setting is composed of lowercase letters, numbers and underscores, and the length is 3~24 characters.
         */
        endUserId: string;
        /**
         * The ID of the user id.
         */
        id: string;
        /**
         * The phone of the mobile phone number.
         */
        phone: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetZonesZone {
        /**
         * String to filter results by zone id.
         */
        zoneId: string;
    }

}

export namespace eflo {
    export interface GetSubnetsSubnet {
        /**
         * Network segment
         */
        cidr: string;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * Modification time
         */
        gmtModified: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * Error message
         */
        message: string;
        /**
         * Resource Group ID.
         */
        resourceGroupId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Primary key ID.
         */
        subnetId: string;
        /**
         * The Subnet name.
         */
        subnetName: string;
        /**
         * Eflo subnet usage type, optional value: 
         * - General type is not filled in
         * - OOB:OOB type
         * - LB: LB type
         */
        type: string;
        /**
         * The Eflo VPD ID.
         */
        vpdId: string;
        /**
         * The zone ID of the resource.
         */
        zoneId: string;
    }

    export interface GetVpdsVpd {
        /**
         * CIDR network segment
         */
        cidr: string;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * Modification time
         */
        gmtModified: string;
        /**
         * The id of the vpd.
         */
        id: string;
        /**
         * The Resource group id
         */
        resourceGroupId: string;
        /**
         * The Vpd status. Valid values: `Available`, `Not Available`, `Executing`, `Deleting`,
         */
        status: string;
        /**
         * The id of the vpd.
         */
        vpdId: string;
        /**
         * The Name of the VPD.
         */
        vpdName: string;
    }

}

export namespace ehpc {
    export interface ClusterAdditionalVolume {
        /**
         * The queue to which the compute nodes are added.
         */
        jobQueue?: string;
        /**
         * The local directory on which the additional file system is mounted.
         */
        localDirectory?: string;
        /**
         * The type of the cluster. Valid value: `PublicCloud`.
         */
        location?: string;
        /**
         * The remote directory to which the file system is mounted.
         */
        remoteDirectory?: string;
        /**
         * The roles. See the following `Block roles`.
         */
        roles?: outputs.ehpc.ClusterAdditionalVolumeRole[];
        /**
         * The ID of the file system. If you leave the parameter empty, a Performance NAS file system is created by default.
         */
        volumeId?: string;
        /**
         * The mount options of the file system.
         */
        volumeMountOption?: string;
        /**
         * The mount target of the file system. Take note of the following information:
         * - If you do not specify the VolumeId parameter, you can leave the VolumeMountpoint parameter empty. A mount target is created by default.
         * - If you specify the VolumeId parameter, the VolumeMountpoint parameter is required.
         */
        volumeMountpoint?: string;
        /**
         * The type of the protocol that is used by the file system. Valid values: `NFS`, `SMB`. Default value: `NFS`.
         */
        volumeProtocol?: string;
        /**
         * The type of the shared storage. Only Apsara File Storage NAS file systems are supported.
         */
        volumeType?: string;
    }

    export interface ClusterAdditionalVolumeRole {
        /**
         * The type of the nodes to which the additional file system is attached.
         */
        name?: string;
    }

    export interface ClusterApplication {
        /**
         * The tag of the software.
         */
        tag?: string;
    }

    export interface ClusterPostInstallScript {
        /**
         * The parameter that is used to run the script after the cluster is created.
         */
        args?: string;
        /**
         * The URL that is used to download the script after the cluster is created.
         */
        url?: string;
    }

    export interface GetClustersCluster {
        /**
         * The server type of the account.
         */
        accountType: string;
        applications: outputs.ehpc.GetClustersClusterApplication[];
        /**
         * The version number of the client used by the cluster.
         */
        clientVersion: string;
        /**
         * The id of E-HPC Cluster.
         */
        clusterId: string;
        /**
         * The name of E-HPC cluster.
         */
        clusterName: string;
        /**
         * The number of compute nodes in the cluster.
         */
        computeCount: number;
        /**
         * Cluster compute node specifications.
         */
        computeInstanceType: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * Cluster deployment mode. Possible values:
         * - Standard: separate deployment of account nodes, scheduling nodes, login nodes, and compute nodes.
         * - Advanced:HA mode deployment.
         * - Simple: the account node and the scheduling node are deployed on one node, and the login node and the compute node are deployed separately.
         * - Tiny: account nodes, scheduling nodes, and login nodes are deployed on one node, and compute nodes are deployed separately.
         * - OneBox: account node, scheduling node, login node and compute node are deployed on one node.
         */
        deployMode: string;
        /**
         * The description of E-HPC cluster.
         */
        description: string;
        /**
         * Whether to turn on high availability. > If high availability is enabled, each control role in the cluster will use two primary and secondary instances.
         */
        haEnable: boolean;
        /**
         * The ID of the Cluster.
         */
        id: string;
        /**
         * The ID of the Image.
         */
        imageId: string;
        /**
         * The type of the image.
         */
        imageOwnerAlias: string;
        /**
         * The number of cluster login nodes. Only configuration 1 is supported.
         */
        loginCount: number;
        /**
         * Cluster login node specifications.
         */
        loginInstanceType: string;
        managerCount: number;
        /**
         * The instance type of manager nodes.
         */
        managerInstanceType: string;
        /**
         * The image tag of the operating system.
         */
        osTag: string;
        postInstallScripts: outputs.ehpc.GetClustersClusterPostInstallScript[];
        /**
         * Mount the remote directory of the shared storage.
         */
        remoteDirectory: string;
        /**
         * The SccCluster ID used by the cluster. If the cluster is not an SCC model, it is empty.
         */
        sccClusterId: string;
        /**
         * Dispatch server type.
         */
        schedulerType: string;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the NAS instance. Currently, you cannot automatically create an Alibaba Cloud NAS instance.
         */
        volumeId: string;
        /**
         * The mount target of the file system. Mount targets cannot be automatically created for NAS file systems.
         */
        volumeMountpoint: string;
        /**
         * The type of the protocol that is used by the file system.
         */
        volumeProtocol: string;
        /**
         * The type of the network shared storage. Valid value: NAS.
         */
        volumeType: string;
        /**
         * The ID of the VPC network.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        zoneId: string;
    }

    export interface GetClustersClusterApplication {
        tag: string;
    }

    export interface GetClustersClusterPostInstallScript {
        args: string;
        url: string;
    }

    export interface GetJobTemplatesTemplate {
        /**
         * Queue Jobs, Is of the Form: 1-10:2.
         */
        arrayRequest: string;
        /**
         * Job Maximum Run Time.
         */
        clockTime: string;
        /**
         * Job Commands.
         */
        commandLine: string;
        /**
         * A Single Compute Node Using the GPU Number.Possible Values: 1~20000.
         */
        gpu: number;
        /**
         * The ID of the Job Template.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        jobTemplateId: string;
        /**
         * A Job Template Name.
         */
        jobTemplateName: string;
        /**
         * A Single Compute Node Maximum Memory.
         */
        mem: string;
        /**
         * Submit a Task Is Required for Computing the Number of Data Nodes to Be. Possible Values: 1~5000 .
         */
        node: number;
        /**
         * Job Commands the Directory.
         */
        packagePath: string;
        /**
         * The Job Priority.Possible Values: 0~9.
         */
        priority: number;
        /**
         * The Job Queue.
         */
        queue: string;
        /**
         * If the Job Is Support for the Re-Run.
         */
        reRunable: boolean;
        /**
         * The name of the user who performed the job.
         */
        runasUser: string;
        /**
         * Error Output Path.
         */
        stderrRedirectPath: string;
        /**
         * Standard Output Path and.
         */
        stdoutRedirectPath: string;
        /**
         * A Single Compute Node Required Number of Tasks. Possible Values: 1~20000 .
         */
        task: number;
        /**
         * A Single Task and the Number of Required Threads.Possible Values: 1~20000.
         */
        thread: number;
        /**
         * The Job of the Environment Variable.
         */
        variables: string;
    }

}

export namespace eipanycast {
    export interface GetAnycastEipAddressesAddress {
        /**
         * Anycast EIP instance account ID.
         */
        aliUid: number;
        /**
         * Anycast EIP instance name.
         */
        anycastEipAddressName: string;
        /**
         * AnycastEip binding information.
         */
        anycastEipBindInfoLists: outputs.eipanycast.GetAnycastEipAddressesAddressAnycastEipBindInfoList[];
        /**
         * Anycast EIP instance ID.
         */
        anycastId: string;
        /**
         * The peak bandwidth of the Anycast EIP instance, in Mbps.
         */
        bandwidth: number;
        /**
         * Anycast EIP instance account BID.
         */
        bid: string;
        /**
         * The business status of the Anycast EIP instance. -`Normal`: Normal state. -`FinancialLocked`: The status of arrears locked.
         */
        businessStatus: string;
        /**
         * Anycast EIP instance description.
         */
        description: string;
        /**
         * The ID of the Anycast Eip Address.
         */
        id: string;
        /**
         * The billing method of Anycast EIP instance. `PayByBandwidth`: refers to the method of billing based on traffic.
         */
        internetChargeType: string;
        /**
         * Anycast EIP instance IP address.
         */
        ipAddress: string;
        /**
         * The payment model of Anycast EIP instance. "PostPaid": Refers to the post-paid mode.
         */
        paymentType: string;
        /**
         * Anycast EIP instance access area. "international": Refers to areas outside of Mainland China.
         */
        serviceLocation: string;
        /**
         * IP status- `Associating`, `Unassociating`, `Allocated`, `Associated`, `Modifying`, `Releasing`, `Released`.
         */
        status: string;
    }

    export interface GetAnycastEipAddressesAddressAnycastEipBindInfoList {
        /**
         * The bound cloud resource instance ID.
         */
        bindInstanceId: string;
        /**
         * The region ID of the bound cloud resource instance.
         */
        bindInstanceRegionId: string;
        /**
         * Bind the cloud resource instance type.
         */
        bindInstanceType: string;
        /**
         * Binding time.
         */
        bindTime: string;
    }

}

export namespace elasticsearch {
    export interface GetInstancesInstance {
        createdAt: string;
        dataNodeAmount: number;
        dataNodeDiskSize: number;
        dataNodeDiskType: string;
        dataNodeSpec: string;
        description: string;
        id: string;
        instanceChargeType: string;
        status: string;
        tags: {[key: string]: any};
        updatedAt: string;
        version: string;
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

}

export namespace emr {
    export interface ClusterBootstrapAction {
        /**
         * bootstrap action args, e.g. "--a=b".
         */
        arg?: string;
        /**
         * bootstrap action execution fail strategy, FAILED_BLOCKED or FAILED_CONTINUE . Default value: "FAILED_BLOCKED
         */
        executionFailStrategy?: string;
        /**
         * bootstrap action execution moment, BEFORE_INSTALL or AFTER_STARTED . Default value: "BEFORE_INSTALL".
         */
        executionMoment?: string;
        /**
         * bootstrap action execution target, you can specify the host group name, e.g. "coreGroup". If this is not specified, the bootstrap action execution target is whole cluster.
         */
        executionTarget?: string;
        /**
         * The name of emr cluster. The name length must be less than 64. Supported characters: chinese character, english character, number, "-", "_".
         */
        name?: string;
        /**
         * bootstrap action path, e.g. "oss://bucket/path".
         */
        path?: string;
    }

    export interface ClusterConfig {
        /**
         * Custom configuration service config key, e.g. dfs.replication.
         */
        configKey: string;
        /**
         * Custom configuration service config value, e.g. 3.
         */
        configValue: string;
        /**
         * Custom configuration service file name, e.g. hdfs-site.
         */
        fileName: string;
        /**
         * Custom configuration service name, e.g. HDFS.
         */
        serviceName: string;
    }

    export interface ClusterHostGroup {
        /**
         * Auto renew for prepaid, true or false . Default value: false.
         */
        autoRenew?: boolean;
        /**
         * Charge Type for this cluster. Supported value: PostPaid or PrePaid. Default value: PostPaid.
         */
        chargeType?: string;
        /**
         * Graceful decommission timeout, unit: seconds.
         */
        decommissionTimeout: number;
        /**
         * Data disk capacity.
         */
        diskCapacity?: string;
        /**
         * Data disk count.
         */
        diskCount?: string;
        /**
         * Data disk type. Supported value: cloud,cloud_efficiency,cloud_ssd,local_disk,cloud_essd.
         */
        diskType?: string;
        /**
         * Enable hadoop cluster of task node graceful decommission, true or false . Default value: false.
         */
        enableGracefulDecommission: boolean;
        gpuDriver?: string;
        /**
         * host group name.
         */
        hostGroupName?: string;
        /**
         * host group type, supported value: MASTER, CORE or TASK, supported 'GATEWAY' available in 1.61.0+.
         */
        hostGroupType?: string;
        /**
         * Instance list for cluster scale down. This value follows the json format, e.g. ["instanceId1","instanceId2"]. escape character for " is \".
         */
        instanceList?: string;
        /**
         * Host Ecs instance type.
         */
        instanceType?: string;
        /**
         * Host number in this group.
         */
        nodeCount?: string;
        /**
         * If charge type is PrePaid, this should be specified, unit is month. Supported value: 123456789122436.
         */
        period: number;
        /**
         * System disk capacity.
         */
        sysDiskCapacity?: string;
        /**
         * System disk type. Supported value: cloud,cloud_efficiency,cloud_ssd,cloud_essd.
         */
        sysDiskType?: string;
    }

    export interface ClusterMetaStoreConf {
        /**
         * Custom rds database password.
         */
        dbPassword: string;
        /**
         * Custom rds database connection url.
         */
        dbUrl: string;
        /**
         * Custom rds database user name.
         */
        dbUserName: string;
    }

    export interface ClusterModifyClusterServiceConfig {
        /**
         * Cluster service configuration modification comment, e.g. "Modify tez configuration".
         */
        comment?: string;
        /**
         * Cluster service configuration modification params, e.g. {"hdfs-site":{"dfs.replication":"3"}}.
         */
        configParams: string;
        /**
         * Cluster service configuration modification type.
         */
        configType?: string;
        /**
         * Cluster service configuration modification custom params, e.g. {"tez-site":{"key":{"Value":"value"}}}.
         */
        customConfigParams?: string;
        /**
         * Cluster service configuration modification related gateway cluster id list.
         */
        gatewayClusterIdLists?: string[];
        /**
         * Cluster service configuration modification node group id, e.g. G-XXX.
         */
        groupId?: string;
        /**
         * Cluster service configuration modification host instance id, e.g. i-bp146tnrkq4tcxxxxx.
         */
        hostInstanceId?: string;
        /**
         * Cluster service configuration modification refresh host config, true or false.
         */
        refreshHostConfig?: boolean;
        /**
         * Custom configuration service name, e.g. HDFS.
         */
        serviceName: string;
    }

    export interface GetClustersCluster {
        /**
         * Cluster connection information.
         */
        accessInfos: outputs.emr.GetClustersClusterAccessInfo[];
        /**
         * Whether flexible expansion is allowed.
         */
        autoScalingAllowed: boolean;
        /**
         * Whether to allow expansion by load.
         */
        autoScalingByLoadAllowed: boolean;
        /**
         * Whether to enable elastic expansion.
         */
        autoScalingEnable: boolean;
        /**
         * Whether to allow the use of elastic scaling bidding instances.
         */
        autoScalingSpotWithLimitAllowed: boolean;
        /**
         * List of boot actions.
         */
        bootstrapActionLists: outputs.emr.GetClustersClusterBootstrapActionList[];
        /**
         * The result of the boot operation.
         */
        bootstrapFailed: boolean;
        /**
         * The ID of the associated cluster.
         */
        clusterId: string;
        /**
         * The name of the associated cluster.
         */
        clusterName: string;
        /**
         * Cluster tag, no need to pay attention.
         */
        createResource: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * How to create a cluster.
         */
        createType: string;
        /**
         * The hosting type of the cluster.
         */
        depositType: string;
        /**
         * High security cluster.
         */
        easEnable: boolean;
        /**
         * Timeout time.
         */
        expiredTime: string;
        /**
         * Additional information for Stack.
         */
        extraInfo: string;
        hasUncompletedOrder: boolean;
        /**
         * High availability cluster.
         */
        highAvailabilityEnable: boolean;
        /**
         * List of cluster machine groups.
         */
        hostGroupLists: outputs.emr.GetClustersClusterHostGroupList[];
        /**
         * Machine pool information.
         */
        hostPoolInfos: outputs.emr.GetClustersClusterHostPoolInfo[];
        id: string;
        /**
         * The ID of the image used to create the cluster.
         */
        imageId: string;
        /**
         * Whether to use Hive local Metabase.
         */
        localMetaDb: boolean;
        /**
         * The host type of the cluster. The default is ECS.
         */
        machineType: string;
        /**
         * Metadata type:
         */
        metaStoreType: string;
        /**
         * Cluster network type.
         */
        netType: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The package year and month time of the machine group. The Valid Values : `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `12`, `24`, `36`.
         */
        period: number;
        /**
         * The information of the primary cluster associated with the Gateway.
         */
        relateClusterInfos: outputs.emr.GetClustersClusterRelateClusterInfo[];
        /**
         * Whether to allow disk expansion:
         */
        resizeDiskEnable: boolean;
        /**
         * The time (in seconds) that has been running.
         */
        runningTime: number;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The name of the security group.
         */
        securityGroupName: string;
        /**
         * Service list.
         */
        softwareInfos: outputs.emr.GetClustersClusterSoftwareInfo[];
        /**
         * Cluster startup time.
         */
        startTime: string;
        /**
         * The cluster status.
         */
        status: string;
        /**
         * Cluster stop time.
         */
        stopTime: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Disk type.
         */
        type: string;
        /**
         * The EMR permission name used.
         */
        userDefinedEmrEcsRole: string;
        /**
         * The user ID.
         */
        userId: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetClustersClusterAccessInfo {
        /**
         * Link address information list of ZooKeeper.
         */
        zkLinks: outputs.emr.GetClustersClusterAccessInfoZkLink[];
    }

    export interface GetClustersClusterAccessInfoZkLink {
        /**
         * The access link address of ZooKeeper.
         */
        link: string;
        /**
         * The port of ZooKeeper.
         */
        port: string;
    }

    export interface GetClustersClusterBootstrapActionList {
        /**
         * Parameters of the boot operation.
         */
        arg: string;
        /**
         * The internal name of the service.
         */
        name: string;
        /**
         * Boot operation script path.
         */
        path: string;
    }

    export interface GetClustersClusterHostGroupList {
        /**
         * Bandwidth.
         */
        bandWidth: string;
        /**
         * Payment Type.
         */
        chargeType: string;
        /**
         * The number of CPU cores.
         */
        cpuCore: number;
        /**
         * Data disk capacity.
         */
        diskCapacity: number;
        /**
         * The number of data disks.
         */
        diskCount: number;
        /**
         * System disk type:
         */
        diskType: string;
        /**
         * The current operation type of the machine Group:
         */
        hostGroupChangeType: string;
        /**
         * The ID of the machine group.
         */
        hostGroupId: string;
        /**
         * The name of the machine group.
         */
        hostGroupName: string;
        /**
         * Role of host in cluster:
         */
        hostGroupType: string;
        /**
         * Machine Group instance.
         */
        instanceType: string;
        /**
         * Memory size.
         */
        memoryCapacity: number;
        /**
         * The number of machine group nodes.
         */
        nodeCount: number;
        /**
         * Machine node.
         */
        nodes: outputs.emr.GetClustersClusterHostGroupListNode[];
        /**
         * The package year and month time of the machine group. The Valid Values : `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `12`, `24`, `36`.
         */
        period: string;
    }

    export interface GetClustersClusterHostGroupListNode {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Disk information.
         */
        diskInfos: outputs.emr.GetClustersClusterHostGroupListNodeDiskInfo[];
        /**
         * The timeout of the EMR.
         */
        emrExpiredTime: string;
        /**
         * Timeout time.
         */
        expiredTime: string;
        /**
         * The Intranet IP of the EMR.
         */
        innerIp: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * Public IP address.
         */
        pubIp: string;
        /**
         * The cluster status.
         */
        status: string;
        /**
         * Whether IPV6 is supported.
         */
        supportIpv6: boolean;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetClustersClusterHostGroupListNodeDiskInfo {
        /**
         * The disk name.
         */
        device: string;
        /**
         * The ID of the disk.
         */
        diskId: string;
        /**
         * The disk name.
         */
        diskName: string;
        /**
         * Disk capacity.
         */
        size: number;
        /**
         * Disk type.
         */
        type: string;
    }

    export interface GetClustersClusterHostPoolInfo {
        /**
         * Machine pool ID.
         */
        hpBizId: string;
        /**
         * The name of the machine pool.
         */
        hpName: string;
    }

    export interface GetClustersClusterRelateClusterInfo {
        /**
         * The ID of the associated cluster.
         */
        clusterId: string;
        /**
         * The name of the associated cluster.
         */
        clusterName: string;
        /**
         * Cluster type:
         */
        clusterType: string;
        /**
         * The cluster status.
         */
        status: string;
    }

    export interface GetClustersClusterSoftwareInfo {
        /**
         * Cluster type:
         */
        clusterType: string;
        /**
         * E-MapReduce version number.
         */
        emrVer: string;
        /**
         * Service list.
         */
        softwares: outputs.emr.GetClustersClusterSoftwareInfoSoftware[];
    }

    export interface GetClustersClusterSoftwareInfoSoftware {
        /**
         * The name of the service.
         */
        displayName: string;
        /**
         * The internal name of the service.
         */
        name: string;
        /**
         * Whether it shows.
         */
        onlyDisplay: boolean;
        /**
         * Startup type.
         */
        startTpe: number;
        /**
         * Service version.
         */
        version: string;
    }

    export interface GetDiskTypesType {
        /**
         * The maximum value of the data disk to supported the specific instance type
         */
        max: number;
        /**
         * The mininum value of the data disk to supported the specific instance type
         */
        min: number;
        /**
         * The value of the data disk or system disk
         */
        value: string;
    }

    export interface GetInstanceTypesType {
        /**
         * The ID of the instance type.
         */
        id: string;
        /**
         * Local capacity of the applied ecs instance for emr cluster. Unit: GB.
         */
        localStorageCapacity: number;
        /**
         * The supported resources of specific zoneId.
         */
        zoneId: string;
    }

    export interface GetMainVersionsMainVersion {
        /**
         * A list of cluster types the emr cluster supported. Possible values: `HADOOP`, `ZOOKEEPER`, `KAFKA`, `DRUID`.
         */
        clusterTypes: string[];
        /**
         * The version of the emr cluster instance. Possible values: `EMR-4.0.0`, `EMR-3.23.0`, `EMR-3.22.0`.
         */
        emrVersion: string;
        /**
         * The image id of the emr cluster instance.
         */
        imageId: string;
    }

}

export namespace emrv2 {
    export interface ClusterApplicationConfig {
        /**
         * The application name of EMR cluster which has installed.
         */
        applicationName: string;
        /**
         * The configuration description of application installed.
         */
        configDescription?: string;
        /**
         * The configuration file name of application installed.
         */
        configFileName: string;
        /**
         * The configuration item key of application installed.
         */
        configItemKey: string;
        /**
         * The configuration item value of application installed.
         */
        configItemValue: string;
        /**
         * The configuration scope of emr cluster. Supported value: CLUSTER or NODEGROUP.
         */
        configScope?: string;
        /**
         * The configuration effected which node group id of emr cluster.
         */
        nodeGroupId?: string;
        /**
         * The configuration effected which node group name of emr cluster.
         */
        nodeGroupName?: string;
    }

    export interface ClusterBootstrapScript {
        /**
         * The bootstrap scripts execution fail strategy, FAILED_BLOCKED or FAILED_CONTINUE .
         */
        executionFailStrategy: string;
        /**
         * The bootstrap scripts execution moment, BEFORE_INSTALL or AFTER_STARTED .
         */
        executionMoment: string;
        /**
         * The bootstrap scripts execution target.
         */
        nodeSelector: outputs.emrv2.ClusterBootstrapScriptNodeSelector;
        /**
         * The bootstrap scripts priority.
         */
        priority?: number;
        /**
         * The bootstrap script args, e.g. "--a=b".
         */
        scriptArgs: string;
        /**
         * The bootstrap script name.
         */
        scriptName: string;
        /**
         * The bootstrap script path, e.g. "oss://bucket/path".
         */
        scriptPath: string;
    }

    export interface ClusterBootstrapScriptNodeSelector {
        /**
         * The configuration effected which node group id of emr cluster.
         */
        nodeGroupId?: string;
        /**
         * The configuration effected which node group name of emr cluster.
         */
        nodeGroupName?: string;
        /**
         * The bootstrap scripts execution target node group types.
         */
        nodeGroupTypes?: string[];
        /**
         * The bootstrap scripts execution target node names.
         */
        nodeNames?: string[];
        /**
         * The bootstrap scripts execution target node select type. Supported value: NODE, NODEGROUP or CLUSTER.
         */
        nodeSelectType: string;
    }

    export interface ClusterNodeAttribute {
        /**
         * Whether to enable data disk encryption.
         */
        dataDiskEncrypted: boolean;
        /**
         * The kms key id used to encrypt the data disk. It takes effect when dataDiskEncrypted is true.
         */
        dataDiskKmsKeyId: string;
        /**
         * The name of the key pair.
         */
        keyPairName: string;
        /**
         * Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
         */
        ramRole: string;
        /**
         * Security Group ID for Cluster.
         */
        securityGroupId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Zone ID, e.g. cn-hangzhou-i
         */
        zoneId: string;
    }

    export interface ClusterNodeGroup {
        /**
         * Additional security Group IDS for Cluster, you can also specify this key for each node group.
         */
        additionalSecurityGroupIds?: string[];
        /**
         * The detail cost optimized configuration of emr cluster.
         */
        costOptimizedConfig?: outputs.emrv2.ClusterNodeGroupCostOptimizedConfig;
        /**
         * Host Ecs data disks information in this node group.
         */
        dataDisks: outputs.emrv2.ClusterNodeGroupDataDisk[];
        /**
         * Enable emr cluster of task node graceful decommission, true or false .
         */
        gracefulShutdown: boolean;
        /**
         * Host Ecs instance types.
         */
        instanceTypes: string[];
        /**
         * Host Ecs number in this node group.
         */
        nodeCount: number;
        /**
         * The configuration effected which node group name of emr cluster.
         */
        nodeGroupName: string;
        /**
         * The node group type of emr cluster, supported value: MASTER, CORE or TASK.
         */
        nodeGroupType: string;
        /**
         * Payment Type for this cluster. Supported value: PayAsYouGo or Subscription.
         */
        paymentType: string;
        /**
         * The spot bid prices of a PayAsYouGo instance.
         */
        spotBidPrices?: outputs.emrv2.ClusterNodeGroupSpotBidPrice[];
        /**
         * Whether to replace spot instances with newly created spot/onDemand instance when receive a spot recycling message.
         */
        spotInstanceRemedy: boolean;
        /**
         * The detail configuration of subscription payment type.
         */
        subscriptionConfig?: outputs.emrv2.ClusterNodeGroupSubscriptionConfig;
        /**
         * Host Ecs system disk information in this node group.
         */
        systemDisk: outputs.emrv2.ClusterNodeGroupSystemDisk;
        /**
         * Global vSwitch ids, you can also specify it in node group.
         */
        vswitchIds?: string[];
        /**
         * Whether the node has a public IP address enabled.
         */
        withPublicIp: boolean;
    }

    export interface ClusterNodeGroupCostOptimizedConfig {
        /**
         * The cost optimized configuration which on demand based capacity.
         */
        onDemandBaseCapacity: number;
        /**
         * The cost optimized configuration which on demand percentage above based capacity.
         */
        onDemandPercentageAboveBaseCapacity: number;
        /**
         * The cost optimized configuration with spot instance pools.
         */
        spotInstancePools: number;
    }

    export interface ClusterNodeGroupDataDisk {
        /**
         * The type of the data disk. Valid values: `cloudEfficiency` and `cloudEssd`.
         */
        category: string;
        /**
         * The count of a data disk.
         */
        count: number;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity.
         */
        performanceLevel: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size: number;
    }

    export interface ClusterNodeGroupSpotBidPrice {
        /**
         * The spot bid price of a PayAsYouGo instance.
         */
        bidPrice: number;
        /**
         * Host Ecs instance type.
         */
        instanceType: string;
    }

    export interface ClusterNodeGroupSubscriptionConfig {
        /**
         * Auto renew for prepaid, true or false . Default value: false.
         */
        autoRenew?: boolean;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: 12345678912243648.
         */
        autoRenewDuration?: number;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: Month or Year.
         */
        autoRenewDurationUnit?: string;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: 12345678912243648.
         */
        paymentDuration: number;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: Month or Year.
         */
        paymentDurationUnit: string;
    }

    export interface ClusterNodeGroupSystemDisk {
        /**
         * The type of the data disk. Valid values: `cloudEfficiency` and `cloudEssd`.
         */
        category: string;
        /**
         * The count of a data disk.
         */
        count: number;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity.
         */
        performanceLevel: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size: number;
    }

    export interface ClusterSubscriptionConfig {
        /**
         * Auto renew for prepaid, true or false . Default value: false.
         */
        autoRenew?: boolean;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: 12345678912243648.
         */
        autoRenewDuration?: number;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: Month or Year.
         */
        autoRenewDurationUnit?: string;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: 12345678912243648.
         */
        paymentDuration: number;
        /**
         * If paymentType is Subscription, this should be specified. Supported value: Month or Year.
         */
        paymentDurationUnit: string;
    }

    export interface GetClustersCluster {
        /**
         * The first ID of the resource.
         */
        clusterId: string;
        /**
         * The name of the emr cluster.
         */
        clusterName: string;
        /**
         * The state of the emr cluster.
         */
        clusterState: string;
        /**
         * The type of the emr cluster.
         */
        clusterType: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ecs default role belongs to this emr cluster.
         */
        emrDefaultRole: string;
        /**
         * The end time of the resource.
         */
        endTime: string;
        /**
         * The expire time of the resource.
         */
        expireTime: string;
        /**
         * The payment type of the emr cluster.
         */
        paymentType: string;
        /**
         * The ready time of the resource.
         */
        readyTime: string;
        /**
         * The release version of the resource.
         */
        releaseVersion: string;
        /**
         * The resource group id of the resource.
         */
        resourceGroupId: string;
        /**
         * The cluster state change reason.
         */
        stateChangeReason: {[key: string]: any};
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: outputs.emrv2.GetClustersClusterTag[];
    }

    export interface GetClustersClusterTag {
        key: string;
        value: string;
    }

}

export namespace ens {
    export interface GetKeyPairsPair {
        /**
         * The creation time of the key pair. The date format is in accordance with ISO8601 notation and uses UTC time. The format is yyyy-MM-ddTHH:mm:ssZ.
         */
        createTime: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * Fingerprint of the key pair.
         */
        keyPairFingerPrint: string;
        /**
         * The name of the key pair.
         */
        keyPairName: string;
        /**
         * The version number.
         */
        version: string;
    }

}

export namespace ess {
    export interface EciScalingConfigurationAcrRegistryInfo {
        /**
         * Endpoint of Container Registry Enterprise Edition instance. By default, all endpoints of the Container Registry Enterprise Edition instance are displayed. It is required
         * when `acrRegistryInfo` is configured.
         */
        domains?: string[];
        /**
         * The ID of Container Registry Enterprise Edition instance. It is required
         * when `acrRegistryInfo` is configured.
         */
        instanceId?: string;
        /**
         * The name of Container Registry Enterprise Edition instance. It is required when `acrRegistryInfo` is
         * configured.
         */
        instanceName?: string;
        /**
         * The region ID of Container Registry Enterprise Edition instance. It is required
         * when `acrRegistryInfo` is configured.
         */
        regionId?: string;
    }

    export interface EciScalingConfigurationContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         * See `environmentVars` below for details.
         */
        environmentVars?: outputs.ess.EciScalingConfigurationContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image?: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * Commands that you want to run in containers when you use the CLI to perform liveness probes.
         */
        livenessProbeExecCommands?: string[];
        /**
         * The minimum number of consecutive failures for the liveness probe to be considered failed after having been successful. Default value: 3.
         */
        livenessProbeFailureThreshold?: number;
        /**
         * The path to which HTTP GET requests are sent when you use HTTP requests to perform liveness probes.
         */
        livenessProbeHttpGetPath?: string;
        /**
         * The port to which HTTP GET requests are sent when you use HTTP requests to perform liveness probes.
         */
        livenessProbeHttpGetPort?: number;
        /**
         * The protocol type of HTTP GET requests when you use HTTP requests for liveness probes.Valid values:HTTP and HTTPS.
         */
        livenessProbeHttpGetScheme?: string;
        /**
         * The number of seconds after container has started before liveness probes are initiated.
         */
        livenessProbeInitialDelaySeconds?: number;
        /**
         * The interval at which the liveness probe is performed. Unit: seconds. Default value: 10. Minimum value: 1.
         */
        livenessProbePeriodSeconds?: number;
        /**
         * The minimum number of consecutive successes for the liveness probe to be considered successful after having failed. Default value: 1. Set the value to 1.
         */
        livenessProbeSuccessThreshold?: number;
        /**
         * The port detected by TCP sockets when you use TCP sockets to perform liveness probes.
         */
        livenessProbeTcpSocketPort?: number;
        /**
         * The timeout period for the liveness probe. Unit: seconds. Default value: 1. Minimum value: 1.
         */
        livenessProbeTimeoutSeconds?: number;
        /**
         * The amount of memory resources allocated to the container.
         */
        memory?: number;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The structure of port. See `ports` below for details.
         */
        ports?: outputs.ess.EciScalingConfigurationContainerPort[];
        /**
         * Commands that you want to run in containers when you use the CLI to perform readiness probes.
         */
        readinessProbeExecCommands?: string[];
        /**
         * The minimum number of consecutive failures for the readiness probe to be considered failed after having been successful. Default value: 3.
         */
        readinessProbeFailureThreshold?: number;
        /**
         * The path to which HTTP GET requests are sent when you use HTTP requests to perform readiness probes.
         */
        readinessProbeHttpGetPath?: string;
        /**
         * The port to which HTTP GET requests are sent when you use HTTP requests to perform readiness probes.
         */
        readinessProbeHttpGetPort?: number;
        /**
         * The protocol type of HTTP GET requests when you use HTTP requests for readiness probes. Valid values: HTTP and HTTPS.
         */
        readinessProbeHttpGetScheme?: string;
        /**
         * The number of seconds after container N has started before readiness probes are initiated.
         */
        readinessProbeInitialDelaySeconds?: number;
        /**
         * The interval at which the readiness probe is performed. Unit: seconds. Default value: 10. Minimum value: 1.
         */
        readinessProbePeriodSeconds?: number;
        /**
         * The minimum number of consecutive successes for the readiness probe to be considered successful after having failed. Default value: 1. Set the value to 1.
         */
        readinessProbeSuccessThreshold?: number;
        /**
         * The port detected by Transmission Control Protocol (TCP) sockets when you use TCP sockets to perform readiness probes.
         */
        readinessProbeTcpSocketPort?: number;
        /**
         * The timeout period for the readiness probe. Unit: seconds. Default value: 1. Minimum value: 1.
         */
        readinessProbeTimeoutSeconds?: number;
        /**
         * The structure of volumeMounts. 
         * See `volumeMounts` below for details.
         */
        volumeMounts?: outputs.ess.EciScalingConfigurationContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface EciScalingConfigurationContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters,
         * digits, and underscores (_). It cannot start with a digit.
         * digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface EciScalingConfigurationContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface EciScalingConfigurationContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the
         * data in the volume.
         * data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface EciScalingConfigurationHostAlias {
        /**
         * Adds a host name.
         */
        hostnames?: string[];
        /**
         * Adds an IP address.
         */
        ip?: string;
    }

    export interface EciScalingConfigurationImageRegistryCredential {
        /**
         * The password used to log on to the image repository. It is required
         * when `imageRegistryCredential` is configured.
         */
        password?: string;
        /**
         * The address of the image repository. It is required when `imageRegistryCredential` is
         * configured.
         */
        server?: string;
        /**
         * The username used to log on to the image repository. It is required
         * when `imageRegistryCredential` is configured.
         */
        username?: string;
    }

    export interface EciScalingConfigurationInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu?: number;
        /**
         * The structure of environmentVars. 
         * See `environmentVars` below for details.
         */
        environmentVars?: outputs.ess.EciScalingConfigurationInitContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image?: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The amount of memory resources allocated to the container.
         */
        memory?: number;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The structure of port. See `ports` below for details.
         */
        ports?: outputs.ess.EciScalingConfigurationInitContainerPort[];
        /**
         * The structure of volumeMounts. See `volumeMounts` below for details.
         */
        volumeMounts?: outputs.ess.EciScalingConfigurationInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface EciScalingConfigurationInitContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters,
         * digits, and underscores (_). It cannot start with a digit.
         * digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface EciScalingConfigurationInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface EciScalingConfigurationInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the
         * data in the volume.
         * data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface EciScalingConfigurationVolume {
        /**
         * ConfigFileVolumeConfigFileToPaths.
         * See `configFileVolumeConfigFileToPaths` below for details.
         */
        configFileVolumeConfigFileToPaths?: outputs.ess.EciScalingConfigurationVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId?: string;
        /**
         * The disk size of DiskVolume.
         */
        diskVolumeDiskSize?: number;
        /**
         * The system type of DiskVolume.
         */
        diskVolumeFsType?: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver?: string;
        /**
         * The type of the mounted file system. The default value is determined by the script
         * of FlexVolume.
         */
        flexVolumeFsType?: string;
        /**
         * The list of FlexVolume objects. Each object is a key-value pair contained in a JSON
         * string.
         */
        flexVolumeOptions?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath?: string;
        /**
         * The nfs volume read only. Default to `false`.
         */
        nfsVolumeReadOnly?: boolean;
        /**
         * The address of the NFS server.
         *
         * > **NOTE:** Every volume mounted must have a name and type attributes.
         */
        nfsVolumeServer?: string;
        /**
         * The type of the volume.
         */
        type?: string;
    }

    export interface EciScalingConfigurationVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content?: string;
        /**
         * The relative file path.
         */
        path?: string;
    }

    export interface GetAlarmsAlarm {
        /**
         * The list of actions to execute when this alarm transition into an ALARM state. Each action is specified as ess scaling rule ari.
         */
        alarmActions: string[];
        /**
         * Defines the application group id defined by CMS which is assigned when you upload custom metric to CMS, only available for custom metirc.
         */
        cloudMonitorGroupId: number;
        /**
         * The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand.
         */
        comparisonOperator: string;
        /**
         * The description for the alarm.
         */
        description: string;
        /**
         * The dimension map for the alarm's associated metric.
         */
        dimensions: {[key: string]: any};
        /**
         * Whether to enable specific ess alarm.
         */
        enable: boolean;
        /**
         * The number of times that needs to satisfies comparison condition before transition into ALARM state.
         */
        evaluationCount: number;
        /**
         * The id of alarm.
         */
        id: string;
        /**
         * The name for the alarm's associated metric. See Block_metricNames_and_dimensions below for details.
         */
        metricName: string;
        /**
         * The type for the alarm's associated metric. Supported value: system, custom. "system" means the metric data is collected by Aliyun Cloud Monitor Service(CMS), "custom" means the metric data is upload to CMS by users. Defaults to system.
         */
        metricType: string;
        /**
         * The name for ess alarm.
         */
        name: string;
        /**
         * The period in seconds over which the specified statistic is applied.
         */
        period: number;
        /**
         * Scaling group id the alarms belong to.
         */
        scalingGroupId: string;
        /**
         * The state of alarm task.
         */
        state: string;
        /**
         * The statistic to apply to the alarm's associated metric.
         */
        statistics: string;
        /**
         * The value against which the specified statistics is compared.
         */
        threshold: string;
    }

    export interface GetLifecycleHooksHook {
        /**
         * Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses.
         */
        defaultResult: string;
        /**
         * Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the defaultResult parameter.
         */
        heartbeatTimeout: number;
        /**
         * ID of the lifecycle hook.
         */
        id: string;
        /**
         * Type of Scaling activity attached to lifecycle hook.
         */
        lifecycleTransition: string;
        /**
         * Name of the lifecycle hook.
         */
        name: string;
        /**
         * The Arn of notification target.
         */
        notificationArn: string;
        /**
         * Additional information that you want to include when Auto Scaling sends a message to the notification target.
         */
        notificationMetadata: string;
        /**
         * Scaling group id the lifecycle hooks belong to.
         */
        scalingGroupId: string;
    }

    export interface GetNotificationsNotification {
        /**
         * ID of the notification.
         */
        id: string;
        /**
         * The Alibaba Cloud Resource Name (ARN) for the notification object.
         */
        notificationArn: string;
        /**
         * The notification types of Auto Scaling events and resource changes.
         */
        notificationTypes: string[];
        /**
         * Scaling group id the notifications belong to.
         */
        scalingGroupId: string;
    }

    export interface GetScalingConfigurationsConfiguration {
        /**
         * Creation time of the scaling configuration.
         */
        creationTime: string;
        /**
         * Performance mode of the t5 burstable instance.
         */
        creditSpecification: string;
        /**
         * Data disks of the scaling configuration.
         */
        dataDisks: outputs.ess.GetScalingConfigurationsConfigurationDataDisk[];
        /**
         * (Optional,Available in 1.143.0+) Hostname of an ECS instance.
         */
        hostName: string;
        /**
         * ID of the scaling rule.
         */
        id: string;
        /**
         * Image ID of the scaling configuration.
         */
        imageId: string;
        /**
         * (Optional,Available in 1.143.0+) InstanceName of an ECS instance.
         */
        instanceName: string;
        /**
         * Resource type of an ECS instance.
         */
        instanceType: string;
        /**
         * Internet charge type of the scaling configuration.
         */
        internetChargeType: string;
        /**
         * Internet max bandwidth in of the scaling configuration.
         */
        internetMaxBandwidthIn: number;
        /**
         * Internet max bandwidth of the scaling configuration.
         */
        internetMaxBandwidthOut: number;
        /**
         * Lifecycle state of the scaling configuration.
         */
        lifecycleState: string;
        /**
         * Name of the scaling configuration.
         */
        name: string;
        /**
         * Scaling group id the scaling configurations belong to.
         */
        scalingGroupId: string;
        /**
         * Security group ID of the scaling configuration.
         */
        securityGroupId: string;
        /**
         * (Optional, Available in 1.151.0+) The maximum price hourly for instance types.
         */
        spotPriceLimits: outputs.ess.GetScalingConfigurationsConfigurationSpotPriceLimit[];
        /**
         * (Optional, Available in 1.151.0+) The spot strategy for a Pay-As-You-Go instance.
         */
        spotStrategy: string;
        /**
         * System disk category of the scaling configuration.
         */
        systemDiskCategory: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        systemDiskPerformanceLevel: string;
        /**
         * System disk size of the scaling configuration.
         */
        systemDiskSize: number;
    }

    export interface GetScalingConfigurationsConfigurationDataDisk {
        /**
         * Category of data disk.
         */
        category: string;
        /**
         * Delete_with_instance attribute of data disk.
         */
        deleteWithInstance: boolean;
        /**
         * Device attribute of data disk.
         */
        device: string;
        /**
         * The performance level of the ESSD used as data disk.
         */
        performanceLevel: string;
        /**
         * Size of data disk.
         */
        size: number;
        /**
         * Size of data disk.
         */
        snapshotId: string;
    }

    export interface GetScalingConfigurationsConfigurationSpotPriceLimit {
        /**
         * Resource type of an ECS instance.
         */
        instanceType: string;
        /**
         * Price limit hourly of instance type.
         */
        priceLimit: number;
    }

    export interface GetScalingGroupsGroup {
        /**
         * Number of active instances in scaling group.
         */
        activeCapacity: number;
        /**
         * Active scaling configuration for scaling group.
         */
        activeScalingConfiguration: string;
        /**
         * Default cooldown time of scaling group.
         */
        cooldownTime: number;
        /**
         * Creation time of scaling group.
         */
        creationTime: string;
        /**
         * Db instances id which the ECS instance attached to.
         */
        dbInstanceIds: string[];
        /**
         * Whether the scaling group deletion protection is enabled.
         */
        groupDeletionProtection: boolean;
        /**
         * The health check method of the scaling group.
         */
        healthCheckType: string;
        /**
         * ID of the scaling group.
         */
        id: string;
        /**
         * Active launch template ID for scaling group.
         */
        launchTemplateId: string;
        /**
         * Version of active launch template.
         */
        launchTemplateVersion: string;
        /**
         * Lifecycle state of scaling group.
         */
        lifecycleState: string;
        /**
         * Slb instances id which the ECS instance attached to.
         */
        loadBalancerIds: string[];
        /**
         * The maximum number of ECS instances.
         */
        maxSize: number;
        /**
         * The minimum number of ECS instances.
         */
        minSize: number;
        /**
         * The modification time.
         */
        modificationTime: string;
        /**
         * Name of the scaling group.
         */
        name: string;
        /**
         * Number of pending instances in scaling group.
         */
        pendingCapacity: number;
        /**
         * Region ID the scaling group belongs to.
         */
        regionId: string;
        /**
         * Removal policy used to select the ECS instance to remove from the scaling group.
         */
        removalPolicies: string[];
        /**
         * Number of removing instances in scaling group.
         */
        removingCapacity: number;
        /**
         * The Process in suspension.
         */
        suspendedProcesses: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * Number of instances in scaling group.
         */
        totalCapacity: number;
        /**
         * The number of all ECS instances in the scaling group.
         */
        totalInstanceCount: number;
        /**
         * The ID of the VPC to which the scaling group belongs.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch to which the scaling group belongs.
         */
        vswitchId: string;
        /**
         * Vswitches id in which the ECS instance launched.
         */
        vswitchIds: string[];
    }

    export interface GetScalingRulesRule {
        /**
         * Adjustment type of the scaling rule.
         */
        adjustmentType: string;
        /**
         * Adjustment value of the scaling rule.
         */
        adjustmentValue: number;
        /**
         * Cooldown time of the scaling rule.
         */
        cooldown: number;
        /**
         * ID of the scaling rule.
         */
        id: string;
        /**
         * Min adjustment magnitude of scaling rule.
         */
        minAdjustmentMagnitude: number;
        /**
         * Name of the scaling rule.
         */
        name: string;
        /**
         * Scaling group id the scaling rules belong to.
         */
        scalingGroupId: string;
        /**
         * Ari of scaling rule.
         */
        scalingRuleAri: string;
        /**
         * Type of scaling rule.
         */
        type: string;
    }

    export interface GetScheduledTasksTask {
        /**
         * Description of the scheduled task.
         */
        description: string;
        /**
         * ID of the scheduled task id.
         */
        id: string;
        /**
         * The time period during which a failed scheduled task is retried.
         */
        launchExpirationTime: number;
        /**
         * The time at which the scheduled task is triggered.
         */
        launchTime: string;
        maxValue: number;
        minValue: number;
        /**
         * Name of the scheduled task name.
         */
        name: string;
        /**
         * Specifies the end time after which the scheduled task is no longer repeated.
         */
        recurrenceEndTime: string;
        /**
         * Specifies the recurrence type of the scheduled task.
         */
        recurrenceType: string;
        /**
         * Specifies how often a scheduled task recurs.
         */
        recurrenceValue: string;
        /**
         * The operation to be performed when a scheduled task is triggered.
         */
        scheduledAction: string;
        taskEnabled: boolean;
    }

    export interface ScalingConfigurationDataDisk {
        /**
         * The id of auto snapshot policy for data disk.
         */
        autoSnapshotPolicyId?: string;
        /**
         * Category of data disk. The parameter value options are `ephemeralSsd`, `cloudEfficiency`, `cloudSsd` and `cloud`.
         */
        category?: string;
        /**
         * Whether to delete data disks attached on ecs when release ecs instance. Optional value: `true` or `false`, default to `true`.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of data disk N. Valid values of N: 1 to 16. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
         */
        description?: string;
        /**
         * The mount point of data disk N. Valid values of N: 1 to 16. If this parameter is not specified, the system automatically allocates a mount point to created ECS instances. The name of the mount point ranges from /dev/xvdb to /dev/xvdz in alphabetical order.
         *
         * @deprecated Attribute device has been deprecated on disk attachment resource. Suggest to remove it from your template.
         */
        device?: string;
        /**
         * Specifies whether data disk N is to be encrypted. Valid values of N: 1 to 16. Valid values: `true`: encrypted, `false`: not encrypted. Default value: `false`.
         */
        encrypted?: boolean;
        /**
         * The CMK ID for data disk N. Valid values of N: 1 to 16.
         */
        kmsKeyId?: string;
        /**
         * The name of data disk N. Valid values of N: 1 to 16. It must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (_), and hyphens (-). Default value: null.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as data disk.
         */
        performanceLevel?: string;
        /**
         * Size of data disk, in GB. The value ranges [5,2000] for a cloud disk, [5,1024] for an ephemeral disk, [5,800] for an ephemeralSsd disk, [20,32768] for cloud_efficiency, cloud_ssd, cloudEssd disk.
         */
        size?: number;
        /**
         * Snapshot used for creating the data disk. If this parameter is specified, the size parameter is neglected, and the size of the created disk is the size of the snapshot.
         */
        snapshotId?: string;
    }

    export interface ScalingConfigurationInstancePatternInfo {
        /**
         * The number of vCPUs that are specified for an instance type in instancePatternInfo.
         */
        cores?: number;
        /**
         * The instance family level in instancePatternInfo.
         */
        instanceFamilyLevel?: string;
        /**
         * The maximum hourly price for a pay-as-you-go instance or a preemptible instance in instancePatternInfo.
         */
        maxPrice?: number;
        /**
         * The memory size that is specified for an instance type in instancePatternInfo.
         */
        memory?: number;
    }

    export interface ScalingConfigurationSpotPriceLimit {
        /**
         * Resource type of an ECS instance.
         */
        instanceType?: string;
        /**
         * Price limit hourly of instance type, 2 decimals is allowed at most.
         */
        priceLimit?: number;
    }

    export interface ScalingGroupVServerGroupsVserverGroup {
        /**
         * Loadbalancer server ID of VServer Group.
         */
        loadbalancerId: string;
        /**
         * A list of VServer Group attributes. See `vserverAttributes` below.
         */
        vserverAttributes: outputs.ess.ScalingGroupVServerGroupsVserverGroupVserverAttribute[];
    }

    export interface ScalingGroupVServerGroupsVserverGroupVserverAttribute {
        /**
         * The port will be used for VServer Group backend server.
         */
        port: number;
        /**
         * ID of VServer Group.
         */
        vserverGroupId: string;
        /**
         * The weight of an ECS instance attached to the VServer Group.
         */
        weight: number;
    }

    export interface ScalingRuleStepAdjustment {
        /**
         * The lower bound of step.
         */
        metricIntervalLowerBound?: string;
        /**
         * The upper bound of step.
         */
        metricIntervalUpperBound?: string;
        /**
         * The adjust value of step.
         */
        scalingAdjustment?: number;
    }

}

export namespace eventbridge {
    export interface GetEventBusesBus {
        /**
         * The time of this bus was created.
         */
        createTime: string;
        /**
         * The description of event bus.
         */
        description: string;
        /**
         * The name of event bus.
         */
        eventBusName: string;
        /**
         * The ID of the Event Bus. Its value is same as Queue Name.
         */
        id: string;
    }

    export interface GetEventSourcesSource {
        /**
         * The detail describe of event source.
         */
        description: string;
        /**
         * The code name of event source.
         */
        eventSourceName: string;
        /**
         * The config of external data source.
         */
        externalSourceConfig: {[key: string]: any};
        /**
         * The type of external data source.
         */
        externalSourceType: string;
        /**
         * The ID of the Event Source.
         */
        id: string;
        /**
         * Whether to connect to an external data source.
         */
        linkedExternalSource: boolean;
        type: string;
    }

    export interface GetRulesRule {
        /**
         * The description of rule.
         */
        description: string;
        /**
         * The name of event bus.
         */
        eventBusName: string;
        /**
         * The pattern to match interested events.
         */
        filterPattern: string;
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * The name of rule.
         */
        ruleName: string;
        /**
         * Rule status, either Enable or Disable.
         */
        status: string;
        /**
         * The target for rule.
         */
        targets: outputs.eventbridge.GetRulesRuleTarget[];
    }

    export interface GetRulesRuleTarget {
        /**
         * The endpoint.
         */
        endpoint: string;
        /**
         * The id of target.
         */
        targetId: string;
        /**
         * The type of target.
         */
        type: string;
    }

    export interface RuleTarget {
        /**
         * Dead letter queue. Events that are not processed or exceed the number of retries will be written to the dead letter. Support message service MNS and message queue RocketMQ. See the following `Block deadLetterQueue`.
         */
        deadLetterQueue?: outputs.eventbridge.RuleTargetDeadLetterQueue;
        /**
         * The endpoint of target.
         */
        endpoint: string;
        /**
         * A list of param. See the following `Block paramList`.
         */
        paramLists: outputs.eventbridge.RuleTargetParamList[];
        /**
         * The retry policy that is used to push the event. Valid values:
         */
        pushRetryStrategy: string;
        /**
         * The ID of target.
         */
        targetId: string;
        /**
         * The type of target. Valid values: `acs.fc.function`, `acs.mns.topic`, `acs.mns.queue`,`http`,`acs.sms`,`acs.mail`,`acs.dingtalk`,`https`, `acs.eventbridge`,`acs.rabbitmq` and `acs.rocketmq`.
         */
        type: string;
    }

    export interface RuleTargetDeadLetterQueue {
        /**
         * The srn of the dead letter queue.
         */
        arn?: string;
    }

    export interface RuleTargetParamList {
        /**
         * The format of param.  Valid values: `ORIGINAL`, `TEMPLATE`, `JSONPATH`, `CONSTANT`.
         */
        form: string;
        /**
         * The resource key of param.  For more information, see [Event target parameters](https://help.aliyun.com/document_detail/185887.htm)
         */
        resourceKey: string;
        /**
         * The template of param.
         *
         * > **NOTE:** There exists a potential diff error that the backend service will return a default param as following:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         * In order to fix the diff, from version 1.160.0,
         * this resource has removed the param which `resourceKey = "IsBase64Encode"` and `value = "false"`.
         * If you want to set `resourceKey = "IsBase64Encode"`, please avoid to set `value = "false"`.
         */
        template?: string;
        /**
         * The value of param.
         */
        value?: string;
    }

}

export namespace expressconnect {
    export interface GetAccessPointsPoint {
        /**
         * Query to the Access Point Feature Model.
         */
        accessPointFeatureModels: outputs.expressconnect.GetAccessPointsPointAccessPointFeatureModel[];
        /**
         * The Access Point ID.
         */
        accessPointId: string;
        /**
         * Access Point Name.
         */
        accessPointName: string;
        /**
         * The Access Point Is Located an ID.
         */
        attachedRegionNo: string;
        /**
         * The Access Point Description.
         */
        description: string;
        /**
         * The Access Point Belongs to the Operator.
         */
        hostOperator: string;
        /**
         * The ID of the Access Point.
         */
        id: string;
        /**
         * The Location of the Access Point.
         */
        location: string;
        /**
         * The Physical Connection to Which the Access Point State.
         */
        status: string;
        /**
         * The Physical Connection to Which the Network Type.
         */
        type: string;
    }

    export interface GetAccessPointsPointAccessPointFeatureModel {
        /**
         * The Access Point Properties.
         */
        featureKey: string;
        /**
         * The Access Point Characteristic Value.
         */
        featureValue: string;
    }

    export interface GetGrantRuleToCensCen {
        /**
         * The ID of the authorized CEN instance.
         */
        cenId: string;
        /**
         * The user ID (UID) of the Alibaba Cloud account to which the CEN instance belongs.
         */
        cenOwnerId: number;
        /**
         * The time when the instance was created.
         */
        createTime: string;
        /**
         * The ID of the Grant Rule To Cen. It formats as `<cen_id>:<cen_owner_id>:<instance_id>`.
         */
        id: string;
    }

    export interface GetPhysicalConnectionsConnection {
        /**
         * The Physical Leased Line Access Point ID.
         */
        accessPointId: string;
        /**
         * To Connect a Device Physical Location.
         */
        adLocation: string;
        /**
         * On the Bandwidth of the ECC Service and Physical Connection.
         */
        bandwidth: string;
        /**
         * The Physical Connection to Which the Payment Status: Normal, financiallocked, securitylocked.
         */
        businessStatus: string;
        /**
         * Operators for Physical Connection Circuit Provided Coding.
         */
        circuitCode: string;
        /**
         * The Representative of the Creation Time Resources Attribute Field.
         */
        createTime: string;
        /**
         * The Physical Connection to Which the Description.
         */
        description: string;
        /**
         * The Physical Connection to Which the Activation Time.
         */
        enabledTime: string;
        /**
         * The Expiration Time.
         */
        endTime: string;
        /**
         * HasReservationData.
         */
        hasReservationData: string;
        /**
         * The ID of the Physical Connection.
         */
        id: string;
        /**
         * Provides Access to the Physical Line Operator Value CT: China Telecom, CU: China Unicom, CM: china Mobile, CO: Other Chinese, Equinix:Equinix, Other: Other Overseas.
         */
        lineOperator: string;
        /**
         * Loa State.
         */
        loaStatus: string;
        /**
         * on Behalf of the Pay-as-You-Type of Resource Attribute Field.
         */
        paymentType: string;
        /**
         * and an on-Premises Data Center Location.
         */
        peerLocation: string;
        /**
         * on Behalf of the Resource Level Id of the Resources Property Fields.
         */
        physicalConnectionId: string;
        /**
         * on Behalf of the Resource Name of the Resources-Attribute Field.
         */
        physicalConnectionName: string;
        /**
         * To Connect a Device Port: The Port Number of.
         */
        portNumber: string;
        /**
         * The Physical Leased Line Access Port Type Value 100Base-T: Fast Electrical Ports, 1000Base-T (the Default): gigabit Electrical Ports, 1000Base-LX: Gigabit Singlemode Optical Ports (10Km), 10GBase-T: Gigabit Electrical Port, 10GBase-LR: Gigabit Singlemode Optical Ports (10Km).
         */
        portType: string;
        /**
         * Redundant Physical Connection to Which the ID.
         */
        redundantPhysicalConnectionId: string;
        /**
         * The Renewal of the Entry into Force of the Time.
         */
        reservationActiveTime: string;
        /**
         * Renewal Type.
         */
        reservationInternetChargeType: string;
        /**
         * Renewal Order Type.
         */
        reservationOrderType: string;
        /**
         * The Physical Connection to Which the Specifications.
         */
        spec: string;
        /**
         * Resources on Behalf of a State of the Resource Attribute Field.
         */
        status: string;
        /**
         * Physical Private Line of Type. Default Value: VPC.
         */
        type: string;
    }

    export interface GetRouterInterfacesFilter {
        key?: string;
        values?: string[];
    }

    export interface GetRouterInterfacesInterface {
        /**
         * The access point ID to which the VBR belongs.
         */
        accessPointId: string;
        /**
         * The bandwidth of the resource.
         */
        bandwidth: number;
        /**
         * The businessStatus of the resource. Valid Values: `Normal`, `FinancialLocked`, `SecurityLocked`.
         */
        businessStatus: string;
        /**
         * The connected time of the resource.
         */
        connectedTime: string;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * The cross border of the resource.
         */
        crossBorder: boolean;
        /**
         * The description of the router interface.
         */
        description: string;
        /**
         * The end time of the resource.
         */
        endTime: string;
        /**
         * The has reservation data of the resource.
         */
        hasReservationData: string;
        /**
         * The hc rate of the resource.
         */
        hcRate: number;
        /**
         * The hc threshold of the resource.
         */
        hcThreshold: string;
        /**
         * The health check source IP address, must be an unused IP within the local VPC.
         */
        healthCheckSourceIp: string;
        /**
         * The IP address for health screening purposes.
         */
        healthCheckTargetIp: string;
        id: string;
        /**
         * The Access point ID to which the other end belongs.
         */
        oppositeAccessPointId: string;
        /**
         * The opposite bandwidth of the router on the other side.
         */
        oppositeBandwidth: number;
        /**
         * The opposite interface business status of the router on the other side. Valid Values: `Normal`, `FinancialLocked`, `SecurityLocked`.
         */
        oppositeInterfaceBusinessStatus: string;
        /**
         * The Interface ID of the router at the other end.
         */
        oppositeInterfaceId: string;
        /**
         * The AliCloud account ID of the owner of the router interface on the other end.
         */
        oppositeInterfaceOwnerId: string;
        /**
         * The opposite interface spec of the router on the other side. Valid Values: `Mini.2`, `Mini.5`, `Mini.5`, `Small.2`, `Small.5`, `Middle.1`, `Middle.2`, `Middle.5`, `Large.1`, `Large.2`, `Large.5`, `XLarge.1`, `Negative`.
         */
        oppositeInterfaceSpec: string;
        /**
         * The opposite interface status of the router on the other side. Valid Values: `Idle`, `AcceptingConnecting`, `Connecting`, `Activating`, `Active`, `Modifying`, `Deactivating`, `Inactive`, `Deleting`.
         */
        oppositeInterfaceStatus: string;
        /**
         * The geographical ID of the location of the receiving end of the connection.
         */
        oppositeRegionId: string;
        /**
         * The id of the router at the other end.
         */
        oppositeRouterId: string;
        /**
         * The opposite router type of the router on the other side. Valid Values: `VRouter`, `VBR`.
         */
        oppositeRouterType: string;
        /**
         * The opposite vpc instance id of the router on the other side.
         */
        oppositeVpcInstanceId: string;
        /**
         * The payment methods for router interfaces. Valid Values: `PrePaid`, `PostPaid`.
         */
        paymentType: string;
        /**
         * The reservation active time of the resource.
         */
        reservationActiveTime: string;
        /**
         * The reservation bandwidth of the resource.
         */
        reservationBandwidth: string;
        /**
         * The reservation internet charge type of the resource.
         */
        reservationInternetChargeType: string;
        /**
         * The reservation order type of the resource.
         */
        reservationOrderType: string;
        /**
         * The role of the router interface. Valid Values: `InitiatingSide`, `AcceptingSide`.
         */
        role: string;
        /**
         * The router id associated with the router interface.
         */
        routerId: string;
        /**
         * The first ID of the resource.
         */
        routerInterfaceId: string;
        /**
         * The name of the resource.
         */
        routerInterfaceName: string;
        /**
         * The type of router associated with the router interface. Valid Values: `VRouter`, `VBR`.
         */
        routerType: string;
        /**
         * The specification of the router interface. Valid Values: `Mini.2`, `Mini.5`, `Mini.5`, `Small.2`, `Small.5`, `Middle.1`, `Middle.2`, `Middle.5`, `Large.1`, `Large.2`, `Large.5`, `XLarge.1`, `Negative`.
         */
        spec: string;
        /**
         * The status of the resource. Valid Values: `Idle`, `AcceptingConnecting`, `Connecting`, `Activating`, `Active`, `Modifying`, `Deactivating`, `Inactive`, `Deleting`.
         */
        status: string;
        /**
         * The vpc instance id of the resource.
         */
        vpcInstanceId: string;
    }

    export interface GetVbrPconnAssociationsAssociation {
        /**
         * The circuit code provided by the operator for the physical connection.
         */
        circuitCode: string;
        /**
         * Whether IPv6 is enabled.
         */
        enableIpv6: boolean;
        /**
         * The ID of the Vbr Pconn Association.
         */
        id: string;
        /**
         * The Alibaba cloud IP address of the VBR instance.
         */
        localGatewayIp: string;
        /**
         * The IPv6 address on the Alibaba Cloud side of the VBR instance.
         */
        localIpv6GatewayIp: string;
        /**
         * The client IP address of the VBR instance.
         */
        peerGatewayIp: string;
        /**
         * The IPv6 address of the client side of the VBR instance.
         */
        peerIpv6GatewayIp: string;
        /**
         * The subnet mask of the Alibaba Cloud side and the client side of the VBR instance.Two IPv6 addresses must be in the same subnet.
         */
        peeringIpv6SubnetMask: string;
        /**
         * The subnet mask of the Alibaba Cloud side and the client side of the VBR instance.The two IP addresses must be in the same subnet.
         */
        peeringSubnetMask: string;
        /**
         * The ID of the leased line instance.
         */
        physicalConnectionId: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * The ID of the VBR instance.
         */
        vbrId: string;
        /**
         * VLAN ID of the VBR.
         */
        vlanId: number;
    }

    export interface GetVirtualBorderRoutersFilter {
        /**
         * The key of the field to filter by, as defined by
         * [Alibaba Cloud API](https://www.alibabacloud.com/help/en/doc-detail/124791.htm).
         */
        key?: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values?: string[];
    }

    export interface GetVirtualBorderRoutersRouter {
        /**
         * The physical leased line access point ID.
         */
        accessPointId: string;
        /**
         * The first activation time of VBR.
         */
        activationTime: string;
        /**
         * Operators for physical connection circuit provided coding.
         */
        circuitCode: string;
        /**
         * Box Instance Id.
         */
        cloudBoxInstanceId: string;
        /**
         * The representative of the creation time resources attribute field.
         */
        createTime: string;
        /**
         * The description of VBR. Length is from 2 to 256 characters, must start with a letter or the Chinese at the beginning, but not at the http:// Or https:// at the beginning.
         */
        description: string;
        /**
         * Detection time multiplier that recipient allows the sender to send a message of the maximum allowable connections for the number of packets, used to detect whether the link normal. Value: 3~10.
         */
        detectMultiplier: number;
        /**
         * High Speed Migration Service Instance Id.
         */
        eccId: string;
        /**
         * Whether to Enable IPv6.
         */
        enableIpv6: boolean;
        /**
         * The ID of the Virtual Border Router.
         */
        id: string;
        /**
         * Alibaba Cloud-Connected IPv4 address.
         */
        localGatewayIp: string;
        /**
         * Alibaba Cloud-Connected IPv6 Address.
         */
        localIpv6GatewayIp: string;
        /**
         * Configure BFD packet reception interval of values include: 200~1000, unit: ms.
         */
        minRxInterval: number;
        /**
         * Configure BFD packet transmission interval maximum value: 200~1000, unit: ms.
         */
        minTxInterval: number;
        /**
         * The Billing of the Extended Time.
         */
        paymentVbrExpireTime: string;
        /**
         * The Client-Side Interconnection IPv4 Address.
         */
        peerGatewayIp: string;
        /**
         * The Client-Side Interconnection IPv6 Address.
         */
        peerIpv6GatewayIp: string;
        /**
         * Alibaba Cloud-Connected IPv6 with Client-Side Interconnection IPv6 of Subnet Mask.
         */
        peeringIpv6SubnetMask: string;
        /**
         * Alibaba Cloud-Connected IPv4 and Client-Side Interconnection IPv4 of Subnet Mask.
         */
        peeringSubnetMask: string;
        /**
         * Physical Private Line Service Status Value Normal: Normal, financiallocked: If You Lock.
         */
        physicalConnectionBusinessStatus: string;
        /**
         * The ID of the Physical Connection to Which the ID.
         */
        physicalConnectionId: string;
        /**
         * Physical Private Line Where the Account ID.
         */
        physicalConnectionOwnerUid: string;
        /**
         * Physical Private Line State.
         */
        physicalConnectionStatus: string;
        /**
         * The Last from a Terminated State to the Active State of the Time.
         */
        recoveryTime: string;
        /**
         * Route Table ID.
         */
        routeTableId: string;
        /**
         * The VBR state.
         */
        status: string;
        /**
         * The Most Recent Was Aborted by the Time.
         */
        terminationTime: string;
        /**
         * VBR Type.
         */
        type: string;
        /**
         * The VBR ID.
         */
        virtualBorderRouterId: string;
        /**
         * The name of VBR. Length is from 2 to 128 characters, must start with a letter or the Chinese at the beginning can contain numbers, the underscore character (_) and dash (-). But do not start with http:// or https:// at the beginning.
         */
        virtualBorderRouterName: string;
        /**
         * The VLAN ID of the VBR. Value range: 0~2999.
         */
        vlanId: number;
        /**
         * The ID of the Router Interface.
         */
        vlanInterfaceId: string;
    }

    export interface GetVirtualPhysicalConnectionsConnection {
        /**
         * The ID of the access point of the physical connection.
         */
        accessPointId: string;
        /**
         * The physical location where the physical connection access device is located.
         */
        adLocation: string;
        /**
         * The bandwidth of the physical connection. Unit: Mbps.
         */
        bandwidth: string;
        /**
         * The commercial status of the physical line. Value:
         * - **Normal**: activated.
         * - **Financialized**: Arrears locked.
         * - **SecurityLocked**: locked for security reasons.
         */
        businessStatus: string;
        /**
         * The circuit code provided by the operator for the physical connection.
         */
        circuitCode: string;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * The description of the physical connection.
         */
        description: string;
        /**
         * The opening time of the physical connection.
         */
        enabledTime: string;
        /**
         * The expiration time of the shared line.Time is expressed according to ISO8601 standard and UTC time is used. The format is: YYYY-MM-DDThh:mm:ssZ.
         */
        endTime: string;
        /**
         * The estimated bandwidth value of the shared line. The expected bandwidth value will not take effect until the payment is completed.Unit: **M** indicates Mbps,**G** indicates Gbps.
         */
        expectSpec: string;
        /**
         * The ID of the Virtual Physical Connection.
         */
        id: string;
        /**
         * Operators that provide access to physical lines. Value:-**CT**: China Telecom.-**CU**: China Unicom.-**CM**: China Mobile.-**CO**: China Other.-**Equinix**:Equinix.-**Other**: Other abroad.
         */
        lineOperator: string;
        /**
         * The state of LOA. Value:-**Applying**:LOA application.-**Accept**:LOA application passed.-**Available**:LOA is Available.-**Rejected**:LOA application Rejected.-**Completing**: The dedicated line is under construction.-**Complete**: The construction of the dedicated line is completed.-**Deleted**:LOA has been Deleted.
         */
        loaStatus: string;
        /**
         * The payment method of shared dedicated line. Value:-**PayByPhysicalConnectionOwner**: indicates that the owner of the physical line associated with the shared line pays.-**PayByVirtualPhysicalConnectionOwner**: indicates that the owner of the shared line pays.
         */
        orderMode: string;
        /**
         * The ID of the Alibaba Cloud account (primary account) to which the physical connection belongs.
         */
        parentPhysicalConnectionAliUid: string;
        /**
         * The ID of the instance of the physical connection.
         */
        parentPhysicalConnectionId: string;
        /**
         * The geographic location of the local data center.
         */
        peerLocation: string;
        /**
         * The port number of the physical connection device.
         */
        portNumber: string;
        /**
         * Physical connection port type. Value:-**100Base-T**: 100 megabytes port.-**1000Base-T**: Gigabit port.-**1000Base-LX**: Gigabit single mode optical port (10km).-**10GBase-T**: 10 Gigabit port.-**10GBase-LR**: 10 Gigabit single mode optical port (10km).-**40GBase-LR**: 40 megabytes single-mode optical port.-**100GBase-LR**: 100,000 megabytes single-mode optical port.
         */
        portType: string;
        /**
         * The ID of the redundant physical connection.
         */
        redundantPhysicalConnectionId: string;
        /**
         * The resource group id
         */
        resourceGroupId: string;
        /**
         * The bandwidth value of the shared line.Unit: **M** indicates Mbps,**G** indicates Gbps.
         */
        spec: string;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * The ID of the hosted connection
         */
        virtualPhysicalConnectionId: string;
        /**
         * The name of the physical connection.
         */
        virtualPhysicalConnectionName: string;
        /**
         * The business status of the shared line. Value:
         * - **Confirmed**: The shared line has been Confirmed to receive.
         * - **UnConfirmed**: The shared line has not been confirmed to be received.
         * - **Deleted**: The shared line has been Deleted.
         */
        virtualPhysicalConnectionStatus: string;
        /**
         * The VLAN ID of the shared leased line.
         */
        vlanId: number;
        /**
         * The ID of the Alibaba Cloud account (primary account) of the owner of the shared line.
         */
        vpconnAliUid: string;
    }

}

export namespace fc {
    export interface AliasRoutingConfig {
        /**
         * A map that defines the proportion of events that should be sent to different versions of a Function Compute service.
         */
        additionalVersionWeights?: {[key: string]: number};
    }

    export interface CustomDomainCertConfig {
        /**
         * The name of the certificate, used to distinguish different certificates.
         */
        certName: string;
        /**
         * Certificate data of the HTTPS certificates, follow the 'pem' format.
         */
        certificate: string;
        /**
         * Private key of the HTTPS certificates, follow the 'pem' format.
         */
        privateKey: string;
    }

    export interface CustomDomainRouteConfig {
        /**
         * The name of the Function Compute function that requests are routed to.
         */
        functionName: string;
        /**
         * The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
         */
        methods?: string[];
        /**
         * The path that requests are routed from.
         */
        path: string;
        /**
         * The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service. For detail information about version and alias, please refer to the [developer guide](https://www.alibabacloud.com/help/doc-detail/96464.htm).
         */
        qualifier?: string;
        /**
         * The name of the Function Compute service that requests are routed to.
         */
        serviceName: string;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfig {
        /**
         * Configuration block with destination configuration for failed asynchronous invocations. See `onFailure` below.
         */
        onFailure?: outputs.fc.FunctionAsyncInvokeConfigDestinationConfigOnFailure;
        /**
         * Configuration block with destination configuration for successful asynchronous invocations. See `onSuccess` below.
         */
        onSuccess?: outputs.fc.FunctionAsyncInvokeConfigDestinationConfigOnSuccess;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfigOnFailure {
        /**
         * Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
         */
        destination: string;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfigOnSuccess {
        /**
         * Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
         */
        destination: string;
    }

    export interface FunctionCustomContainerConfig {
        /**
         * The args field specifies the arguments passed to the command.
         */
        args?: string;
        /**
         * The entry point of the container, which specifies the actual command run by the container.
         */
        command?: string;
        /**
         * The container image address.
         */
        image: string;
    }

    export interface GetCustomDomainsDomain {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The API version of the Function Compute service.
         */
        apiVersion: string;
        /**
         * The configuration of HTTPS certificate.
         */
        certConfig: outputs.fc.GetCustomDomainsDomainCertConfig;
        /**
         * The created time of the custom domain.
         */
        createdTime: string;
        /**
         * The custom domain name.
         */
        domainName: string;
        /**
         * The custom domain id, same as domain name.
         */
        id: string;
        /**
         * The last modified time of the custom domain.
         */
        lastModifiedTime: string;
        /**
         * The custom domain protocol.
         */
        protocol: string;
        /**
         * The configuration of domain route, mapping the path and Function Compute function.
         */
        routeConfigs: outputs.fc.GetCustomDomainsDomainRouteConfig[];
    }

    export interface GetCustomDomainsDomainCertConfig {
        /**
         * The name of the certificate.
         */
        certName: string;
        /**
         * Certificate data of the HTTPS certificates, follow the 'pem'.
         */
        certificate: string;
    }

    export interface GetCustomDomainsDomainRouteConfig {
        /**
         * The name of the Function Compute function that requests are routed to.
         */
        functionName: string;
        /**
         * The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
         */
        methods: string[];
        /**
         * The path that requests are routed from.
         */
        path: string;
        /**
         * The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service.
         */
        qualifier: string;
        /**
         * The name of the Function Compute service that requests are routed to.
         */
        serviceName: string;
    }

    export interface GetFunctionsFunction {
        /**
         * The port that the function listen to, only valid for [custom runtime](https://www.alibabacloud.com/help/doc-detail/132044.htm) and [custom container runtime](https://www.alibabacloud.com/help/doc-detail/179368.htm).
         */
        caPort: number;
        /**
         * Checksum (crc64) of the function code.
         */
        codeChecksum: string;
        /**
         * Function code size in bytes.
         */
        codeSize: number;
        /**
         * Function creation time.
         */
        creationTime: string;
        /**
         * The configuration for custom container runtime. It contains following attributes:
         */
        customContainerConfig?: outputs.fc.GetFunctionsFunctionCustomContainerConfig;
        /**
         * Function description.
         */
        description: string;
        /**
         * A map that defines environment variables for the function.
         */
        environmentVariables: {[key: string]: any};
        /**
         * Function [entry point](https://www.alibabacloud.com/help/doc-detail/62213.htm) in the code.
         */
        handler: string;
        /**
         * Function ID.
         */
        id: string;
        /**
         * The maximum length of time, in seconds, that the function's initialization should be run for.
         */
        initializationTimeout: number;
        /**
         * The entry point of the function's [initialization](https://www.alibabacloud.com/help/doc-detail/157704.htm).
         */
        initializer: string;
        /**
         * The maximum number of requests can be executed concurrently within the single function instance.
         */
        instanceConcurrency: number;
        /**
         * The instance type of the function.
         */
        instanceType: string;
        /**
         * Function last modification time.
         */
        lastModificationTime: string;
        /**
         * Amount of memory in MB the function can use at runtime.
         */
        memorySize: number;
        /**
         * Function name.
         */
        name: string;
        /**
         * Function runtime. The list of possible values is [available here](https://www.alibabacloud.com/help/doc-detail/52077.htm).
         */
        runtime: string;
        /**
         * Maximum amount of time the function can run in seconds.
         */
        timeout: number;
    }

    export interface GetFunctionsFunctionCustomContainerConfig {
        /**
         * The args field specifies the arguments passed to the command.
         */
        args: string;
        /**
         * The entry point of the container, which specifies the actual command run by the container.
         */
        command: string;
        /**
         * The container image address.
         */
        image: string;
    }

    export interface GetServicesService {
        /**
         * FC service creation time.
         */
        creationTime: string;
        /**
         * FC service description.
         */
        description: string;
        /**
         * FC service ID.
         */
        id: string;
        /**
         * Indicate whether the service can access to internet or not.
         */
        internetAccess: boolean;
        /**
         * FC service last modification time.
         */
        lastModificationTime: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfig: outputs.fc.GetServicesServiceLogConfig;
        /**
         * FC service name.
         */
        name: string;
        /**
         * A list of one element about the nas configuration.
         */
        nasConfig: outputs.fc.GetServicesServiceNasConfig;
        /**
         * FC service role ARN.
         */
        role: string;
        /**
         * A list of one element containing information about accessible VPC resources. It contains the following attributes:
         */
        vpcConfig: outputs.fc.GetServicesServiceVpcConfig;
    }

    export interface GetServicesServiceLogConfig {
        /**
         * Log Service store name.
         */
        logstore: string;
        /**
         * Log Service project name.
         */
        project: string;
    }

    export interface GetServicesServiceNasConfig {
        /**
         * The group id of the NAS file system.
         */
        groupId: number;
        /**
         * The mount points configuration, including following attributes:
         */
        mountPoints: outputs.fc.GetServicesServiceNasConfigMountPoint[];
        /**
         * The user id of the NAS file system.
         */
        userId: number;
    }

    export interface GetServicesServiceNasConfigMountPoint {
        /**
         * The local address where to mount your remote NAS directory.
         */
        mountDir: string;
        /**
         * The address of the remote NAS directory.
         */
        serverAddr: string;
    }

    export interface GetServicesServiceVpcConfig {
        /**
         * Associated security group ID.
         */
        securityGroupId: string;
        /**
         * Associated VPC ID.
         */
        vpcId: string;
        /**
         * Associated VSwitch IDs.
         */
        vswitchIds: string[];
    }

    export interface GetTriggersTrigger {
        /**
         * JSON-encoded trigger configuration. See [Configure triggers and events](https://www.alibabacloud.com/help/doc-detail/70140.htm) for more details.
         */
        config: string;
        /**
         * FC trigger creation time.
         */
        creationTime: string;
        /**
         * FC trigger ID.
         */
        id: string;
        /**
         * RAM role arn attached to the Function Compute trigger. Role used by the event source to call the function. The value format is "acs:ram::$account-id:role/$role-name". See [Create a trigger](https://www.alibabacloud.com/help/doc-detail/53102.htm) for more details.
         */
        invocationRole: string;
        /**
         * FC trigger last modification time.
         */
        lastModificationTime: string;
        /**
         * FC trigger name.
         */
        name: string;
        /**
         * Event source resource address. See [Create a trigger](https://www.alibabacloud.com/help/doc-detail/53102.htm) for more details.
         */
        sourceArn: string;
        /**
         * Type of the trigger. Valid values: `oss`, `log`, `timer`, `http`, `mnsTopic`, `cdnEvents` and `eventbridge`.
         */
        type: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
    }

    export interface ServiceLogConfig {
        /**
         * Enable instance level metrics.
         */
        enableInstanceMetrics?: boolean;
        /**
         * Enable request level metrics.
         */
        enableRequestMetrics?: boolean;
        /**
         * The log store name of Alicloud Simple Log Service.
         */
        logstore: string;
        /**
         * The project name of the Alicloud Simple Log Service.
         */
        project: string;
    }

    export interface ServiceNasConfig {
        /**
         * The group id of your NAS file system.
         */
        groupId: number;
        /**
         * Config the NAS mount points.See `mountPoints` below.
         */
        mountPoints: outputs.fc.ServiceNasConfigMountPoint[];
        /**
         * The user id of your NAS file system.
         */
        userId: number;
    }

    export interface ServiceNasConfigMountPoint {
        /**
         * The local address where to mount your remote NAS directory.
         */
        mountDir: string;
        /**
         * The address of the remote NAS directory.
         */
        serverAddr: string;
    }

    export interface ServiceTracingConfig {
        /**
         * Tracing parameters, which type is map[string]string. When the protocol type is Jaeger, the key is "endpoint" and the value is your tracing intranet endpoint. For example endpoint: http://tracing-analysis-dc-hz.aliyuncs.com/adapt_xxx/api/traces.
         */
        params: {[key: string]: any};
        /**
         * Tracing protocol type. Currently, only Jaeger is supported.
         */
        type: string;
    }

    export interface ServiceVpcConfig {
        /**
         * A security group ID associated with the Function Compute Service.
         */
        securityGroupId: string;
        /**
         * A vpc ID associated with the Function Compute Service.
         */
        vpcId: string;
        /**
         * A list of vswitch IDs associated with the Function Compute Service.
         */
        vswitchIds: string[];
    }

}

export namespace fnf {
    export interface GetExecutionsExecution {
        /**
         * The name of the execution.
         */
        executionName: string;
        /**
         * The name of the flow.
         */
        flowName: string;
        /**
         * The ID of the Execution. The value formats as `<flow_name>:<execution_name>`.
         */
        id: string;
        /**
         * The Input information for this execution.
         */
        input: string;
        /**
         * The output of the execution.
         */
        output: string;
        /**
         * The started time of the execution.
         */
        startedTime: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The stopped time of the execution.
         */
        stoppedTime: string;
    }

    export interface GetFlowsFlow {
        /**
         * The definition of the flow. It must comply with the Flow Definition Language (FDL) syntax.
         */
        definition: string;
        /**
         * The description of the flow.
         */
        description: string;
        /**
         * The unique ID of the flow.
         */
        flowId: string;
        /**
         * The ID of the Flow.
         */
        id: string;
        /**
         * The time when the flow was last modified.
         */
        lastModifiedTime: string;
        /**
         * The name of the flow. The name must be unique in an Alibaba Cloud account.
         */
        name: string;
        /**
         * The ARN of the specified RAM role that Serverless Workflow uses to assume the role when Serverless Workflow executes a flow.
         */
        roleArn: string;
        /**
         * The type of the flow. Set the value to `FDL`.
         */
        type: string;
    }

    export interface GetSchedulesSchedule {
        /**
         * The CRON expression of the time-based schedule to be created.
         */
        cronExpression: string;
        /**
         * The description of the time-based schedule to be created.
         */
        description: string;
        /**
         * Specifies whether to enable the time-based schedule you want to create.
         */
        enable: boolean;
        /**
         * The ID of the Schedule.
         */
        id: string;
        /**
         * The time when the time-based schedule was last updated.
         */
        lastModifiedTime: string;
        /**
         * The trigger message of the time-based schedule to be created. It must be in JSON object format.
         */
        payload: string;
        /**
         * The ID of the time-based schedule.
         */
        scheduleId: string;
        /**
         * The name of the time-based schedule to be created.
         */
        scheduleName: string;
    }

}

export namespace ga {
    export interface AclAclEntry {
        /**
         * The IP address(192.168.XX.XX) or CIDR(10.0.XX.XX/24) block that you want to add to the network ACL.
         */
        entry: string;
        /**
         * The description of the IP entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_).
         */
        entryDescription: string;
    }

    export interface CustomRoutingEndpointTrafficPolicyPortRange {
        /**
         * The start port of the port range of the traffic destination. The specified port must fall within the port range of the specified endpoint group.
         */
        fromPort?: number;
        /**
         * The end port of the port range of the traffic destination. The specified port must fall within the port range of the specified endpoint group.
         */
        toPort?: number;
    }

    export interface EndpointGroupEndpointConfiguration {
        /**
         * Indicates whether client IP addresses are reserved. Default Value: `false`. Valid values:
         */
        enableClientipPreservation: boolean;
        /**
         * Specifies whether to preserve client IP addresses by using the ProxyProtocol module. Default Value: `false`. Valid values:
         */
        enableProxyProtocol?: boolean;
        /**
         * The IP address or domain name of Endpoint N in the endpoint group.
         */
        endpoint: string;
        /**
         * The type of Endpoint N in the endpoint group. Valid values:
         */
        type: string;
        /**
         * The weight of Endpoint N in the endpoint group. Valid values: `0` to `255`.
         * > **NOTE:** If the weight of a terminal node is set to 0, global acceleration will terminate the distribution of traffic to the terminal node. Please be careful.
         */
        weight: number;
    }

    export interface EndpointGroupPortOverrides {
        /**
         * Forwarding port.
         */
        endpointPort?: number;
        /**
         * Listener port.
         */
        listenerPort?: number;
    }

    export interface ForwardingRuleRuleAction {
        /**
         * Forwarding configuration. See `forwardGroupConfig` below.
         * > **NOTE:** From version 1.207.0, We recommend that you do not use `forwardGroupConfig`, and we recommend that you use the `ruleActionType` and `ruleActionValue` to configure forwarding actions.
         */
        forwardGroupConfig?: outputs.ga.ForwardingRuleRuleActionForwardGroupConfig;
        /**
         * Forwarding priority.
         */
        order: number;
        /**
         * Forward action type.
         */
        ruleActionType: string;
        /**
         * The value of the forwarding action type. For more information, see [How to use it](https://www.alibabacloud.com/help/en/global-accelerator/latest/api-doc-ga-2019-11-20-api-doc-createforwardingrules).
         */
        ruleActionValue?: string;
    }

    export interface ForwardingRuleRuleActionForwardGroupConfig {
        /**
         * The information about the endpoint group. See `serverGroupTuples` below.
         */
        serverGroupTuples: outputs.ga.ForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface ForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * The ID of the endpoint group.
         */
        endpointGroupId: string;
    }

    export interface ForwardingRuleRuleCondition {
        /**
         * The configuration of the domain name. See `hostConfig` below.
         */
        hostConfigs?: outputs.ga.ForwardingRuleRuleConditionHostConfig[];
        /**
         * The configuration of the path. See `pathConfig` below.
         */
        pathConfig?: outputs.ga.ForwardingRuleRuleConditionPathConfig;
        /**
         * The type of the forwarding conditions. Valid values: `Host`, `Path`.
         */
        ruleConditionType: string;
    }

    export interface ForwardingRuleRuleConditionHostConfig {
        /**
         * The length of the path is 1-128 characters. It must start with a forward slash (/), and can only contain letters, numbers, dollar sign ($), dash (-), and underscores (_) , half width full stop (.), plus sign (+), forward slash (/), and (&), wavy line (~), at (@), half width colon (:), apostrophe ('). It supports asterisk (*) and half width question mark (?) as wildcards.
         */
        values?: string[];
    }

    export interface ForwardingRuleRuleConditionPathConfig {
        /**
         * The length of the path is 1-128 characters. It must start with a forward slash (/), and can only contain letters, numbers, dollar sign ($), dash (-), and underscores (_) , half width full stop (.), plus sign (+), forward slash (/), and (&), wavy line (~), at (@), half width colon (:), apostrophe ('). It supports asterisk (*) and half width question mark (?) as wildcards.
         */
        values?: string[];
    }

    export interface GetAcceleratorSpareIpAttachmentsAttachment {
        /**
         * The ID of the global acceleration instance.
         */
        acceleratorId: string;
        /**
         * The ID of the Accelerator Spare Ip Attachment.
         */
        id: string;
        /**
         * The standby IP address of CNAME. When the acceleration area is abnormal, the traffic is switched to the standby IP address.
         */
        spareIp: string;
        /**
         * The status of the standby CNAME IP address. Valid values: `active`, `inuse`.
         */
        status: string;
    }

    export interface GetAcceleratorsAccelerator {
        /**
         * The ID of the GA instance to query.
         */
        acceleratorId: string;
        /**
         * The Name of the GA instance.
         */
        acceleratorName: string;
        /**
         * Details of the basic bandwidth package bound to the global acceleration instance.
         */
        basicBandwidthPackages: outputs.ga.GetAcceleratorsAcceleratorBasicBandwidthPackage[];
        /**
         * The cloud enterprise network instance ID bound to the global acceleration instance.
         */
        cenId: string;
        /**
         * Details of the cross-domain acceleration package bound to the global acceleration instance.
         */
        crossDomainBandwidthPackages: outputs.ga.GetAcceleratorsAcceleratorCrossDomainBandwidthPackage[];
        /**
         * DDoS high-defense instance ID that is unbound from the global acceleration instance.
         */
        ddosId: string;
        /**
         * Descriptive information of the global acceleration instance.
         */
        description: string;
        /**
         * CNAME address assigned by Global Acceleration instance.
         */
        dnsName: string;
        /**
         * Time when the global acceleration instance expires.
         */
        expiredTime: number;
        /**
         * The ID of the Accelerator.
         */
        id: string;
        /**
         * The Payment Typethe GA instance.
         */
        paymentType: string;
        /**
         * CNAME of the Global Acceleration Linkage DDoS High Defense Instance.
         */
        secondDnsName: string;
        /**
         * The instance type of the GA instance.
         */
        spec: string;
        /**
         * The status of the GA instance.
         */
        status: string;
    }

    export interface GetAcceleratorsAcceleratorBasicBandwidthPackage {
        /**
         * Bandwidth value of cross-domain acceleration package.
         */
        bandwidth: number;
        /**
         * The bandwidth type of the basic bandwidth package.
         */
        bandwidthType: string;
        /**
         * Instance ID of the cross-domain acceleration package.
         */
        instanceId: string;
    }

    export interface GetAcceleratorsAcceleratorCrossDomainBandwidthPackage {
        /**
         * Bandwidth value of cross-domain acceleration package.
         */
        bandwidth: number;
        /**
         * Instance ID of the cross-domain acceleration package.
         */
        instanceId: string;
    }

    export interface GetAclsAcl {
        /**
         * The entries of the Acl.
         */
        aclEntries: outputs.ga.GetAclsAclAclEntry[];
        /**
         * The  ID of the Acl.
         */
        aclId: string;
        /**
         * The name of the acl.
         */
        aclName: string;
        /**
         * The address ip version.
         */
        addressIpVersion: string;
        /**
         * The ID of the Acl. Its value is same as `aclId`.
         */
        id: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAclsAclAclEntry {
        /**
         * The IP entry that you want to add to the ACL.
         */
        entry: string;
        /**
         * The description of the IP entry.
         */
        entryDescription: string;
    }

    export interface GetAdditionalCertificatesCertificate {
        /**
         * The ID of the GA instance.
         */
        acceleratorId: string;
        /**
         * The Certificate ID.
         */
        certificateId: string;
        /**
         * The domain name specified by the certificate.
         */
        domain: string;
        /**
         * The ID of the Additional Certificate. The value formats as `<accelerator_id>:<listener_id>:<domain>`.
         */
        id: string;
        /**
         * The ID of the listener. Only HTTPS listeners support this parameter.
         */
        listenerId: string;
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth value of bandwidth packet.
         */
        bandwidth: number;
        /**
         * The Resource ID of the bandwidth.
         */
        bandwidthPackageId: string;
        /**
         * The name of the bandwidth packet.
         */
        bandwidthPackageName: string;
        /**
         * The bandwidth type of the bandwidth.
         */
        bandwidthType: string;
        /**
         * Interworking area A of cross domain acceleration package. Only international stations support returning this parameter.
         */
        cbnGeographicRegionIda: string;
        /**
         * Interworking area B of cross domain acceleration package. Only international stations support returning this parameter.
         */
        cbnGeographicRegionIdb: string;
        /**
         * The description of bandwidth package.
         */
        description: string;
        /**
         * Bandwidth package expiration time.
         */
        expiredTime: string;
        /**
         * The ID of the Bandwidth Package.
         */
        id: string;
        /**
         * The payment type of the bandwidth.
         */
        paymentType: string;
        /**
         * The status of the bandwidth plan.
         */
        status: string;
        /**
         * The type of the bandwidth packet. China station only supports return to basic.
         */
        type: string;
    }

    export interface GetBasicAccelerateIpEndpointRelationsRelation {
        /**
         * The ID of the Basic Accelerate IP.
         */
        accelerateIpId: string;
        /**
         * The ID of the Global Accelerator Basic Accelerator instance.
         */
        acceleratorId: string;
        /**
         * The name of the Basic Endpoint.
         */
        basicEndpointName: string;
        /**
         * The address of the Basic Endpoint.
         */
        endpointAddress: string;
        /**
         * The ID of the Basic Endpoint.
         */
        endpointId: string;
        /**
         * The sub address of the Basic Endpoint.
         */
        endpointSubAddress: string;
        /**
         * The sub address type of the Basic Endpoint.
         */
        endpointSubAddressType: string;
        /**
         * The type of the Basic Endpoint.
         */
        endpointType: string;
        /**
         * The zone id of the Basic Endpoint.
         */
        endpointZoneId: string;
        /**
         * The id of the Global Accelerator Basic Accelerate Ip Endpoint Relation. It formats as `<accelerator_id>:<accelerate_ip_id>:<endpoint_id>`.
         */
        id: string;
        /**
         * The address of the Basic Accelerate IP.
         */
        ipAddress: string;
        /**
         * The status of the Global Accelerator Basic Accelerate Ip Endpoint Relation. Valid Value: `active`.
         */
        status: string;
    }

    export interface GetBasicAccelerateIpsIp {
        /**
         * The address of the Basic Accelerate IP.
         */
        accelerateIpAddress: string;
        /**
         * The id of the Basic Accelerate IP.
         */
        accelerateIpId: string;
        /**
         * The id of the Global Accelerator Basic Accelerator instance.
         */
        acceleratorId: string;
        /**
         * The id of the Basic Accelerate IP.
         */
        id: string;
        /**
         * The ID of the Basic Ip Set.
         */
        ipSetId: string;
        /**
         * The status of the Global Accelerator Basic Accelerate IP instance. Valid Value: `active`, `binding`, `bound`, `unbinding`, `deleting`.
         */
        status: string;
    }

    export interface GetBasicAcceleratorsAccelerator {
        /**
         * The bandwidth billing method.
         */
        bandwidthBillingType: string;
        /**
         * The id of the Global Accelerator Basic Accelerator instance.
         */
        basicAcceleratorId: string;
        /**
         * The name of the Global Accelerator Basic Accelerator instance.
         */
        basicAcceleratorName: string;
        /**
         * The details about the basic bandwidth plan that is associated with the Global Accelerator Basic Accelerator instance.
         */
        basicBandwidthPackages: outputs.ga.GetBasicAcceleratorsAcceleratorBasicBandwidthPackage[];
        /**
         * The ID of the endpoint group that is associated with the Global Accelerator Basic Accelerator instance.
         */
        basicEndpointGroupId: string;
        /**
         * The ID of the acceleration region.
         */
        basicIpSetId: string;
        /**
         * The timestamp that indicates when the Global Accelerator Basic Accelerator instance was created.
         */
        createTime: number;
        /**
         * The details about the cross-region acceleration bandwidth plan that is associated with the Global Accelerator Basic Accelerator instance. **NOTE:** This array is returned only for Global Accelerator Basic Accelerator instances that are created on the International site.
         */
        crossDomainBandwidthPackages: outputs.ga.GetBasicAcceleratorsAcceleratorCrossDomainBandwidthPackage[];
        /**
         * The description of the Global Accelerator Basic Accelerator instance.
         */
        description: string;
        /**
         * The timestamp that indicates when the Global Accelerator Basic Accelerator instance was expired.
         */
        expiredTime: number;
        /**
         * The id of the Global Accelerator Basic Accelerator.
         */
        id: string;
        /**
         * The billing method of the Global Accelerator Basic Accelerator instance. Only `PREPAY` is returned, which indicates the subscription billing method.
         */
        instanceChargeType: string;
        /**
         * The ID of the region where the Global Accelerator Basic Accelerator instance is deployed.
         */
        regionId: string;
        /**
         * The status of the Global Accelerator Basic Accelerator instance. Valid Value: `init`, `active`, `configuring`, `binding`, `unbinding`, `deleting`, `finacialLocked`.
         */
        status: string;
    }

    export interface GetBasicAcceleratorsAcceleratorBasicBandwidthPackage {
        /**
         * The bandwidth value of the cross-region acceleration bandwidth plan. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * The type of the bandwidth that is provided by the basic bandwidth plan.
         */
        bandwidthType: string;
        /**
         * The ID of the cross-region acceleration bandwidth plan.
         */
        instanceId: string;
    }

    export interface GetBasicAcceleratorsAcceleratorCrossDomainBandwidthPackage {
        /**
         * The bandwidth value of the cross-region acceleration bandwidth plan. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * The ID of the cross-region acceleration bandwidth plan.
         */
        instanceId: string;
    }

    export interface GetBasicEndpointsEndpoint {
        /**
         * The ID of the Global Accelerator Basic Accelerator instance.
         */
        acceleratorId: string;
        /**
         * The name of the Basic Endpoint.
         */
        basicEndpointName: string;
        /**
         * The address of the Basic Endpoint.
         */
        endpointAddress: string;
        /**
         * The ID of the Basic Endpoint Group.
         */
        endpointGroupId: string;
        /**
         * The ID of the Basic Endpoint.
         */
        endpointId: string;
        /**
         * The sub address of the Basic Endpoint.
         */
        endpointSubAddress: string;
        /**
         * The sub address type of the Basic Endpoint.
         */
        endpointSubAddressType: string;
        /**
         * The type of the Basic Endpoint. Valid values: `ENI`, `SLB`, `ECS` and `NLB`.
         */
        endpointType: string;
        /**
         * The zone id of the Basic Endpoint.
         */
        endpointZoneId: string;
        /**
         * The id of the Global Accelerator Basic Endpoint. It formats as `<endpoint_group_id>:<endpoint_id>`.
         */
        id: string;
        /**
         * The status of the Global Accelerator Basic Endpoint. Valid Value: `init`, `active`, `updating`, `binding`, `unbinding`, `deleting`, `bound`.
         */
        status: string;
    }

    export interface GetCustomRoutingEndpointGroupDestinationsCustomRoutingEndpointGroupDestination {
        /**
         * The ID of the GA instance.
         */
        acceleratorId: string;
        /**
         * The ID of the Custom Routing Endpoint Group Destination.
         */
        customRoutingEndpointGroupDestinationId: string;
        /**
         * The ID of the endpoint group.
         */
        endpointGroupId: string;
        /**
         * The start port of the backend service port range of the endpoint group. The `fromPort` value must be smaller than or equal to the `toPort` value. Valid values: `1` to `65499`.
         */
        fromPort: number;
        /**
         * The id of the Global Accelerator Custom Routing Endpoint Group Destination. It formats as `<endpoint_group_id>:<custom_routing_endpoint_group_destination_id>`.
         */
        id: string;
        /**
         * The ID of the listener.
         */
        listenerId: string;
        /**
         * The backend service protocol of the endpoint group. Valid values: `TCP`, `UDP`, `TCP, UDP`.
         */
        protocols: string[];
        /**
         * The end port of the backend service port range of the endpoint group. The `fromPort` value must be smaller than or equal to the `toPort` value. Valid values: `1` to `65499`.
         */
        toPort: number;
    }

    export interface GetCustomRoutingEndpointGroupsGroup {
        /**
         * The ID of the GA instance.
         */
        acceleratorId: string;
        /**
         * The name of the endpoint group.
         */
        customRoutingEndpointGroupName: string;
        /**
         * The description of the endpoint group.
         */
        description: string;
        /**
         * The ID of the endpoint group.
         */
        endpointGroupId: string;
        /**
         * The list of endpoint group IP addresses.
         */
        endpointGroupIpLists: string[];
        /**
         * The ID of the region where the endpoint group is created.
         */
        endpointGroupRegion: string;
        /**
         * The endpoint group IP addresses to be confirmed after the GA instance is upgraded.
         */
        endpointGroupUnconfirmedIpLists: string[];
        /**
         * The id of the Custom Routing Endpoint Group.
         */
        id: string;
        /**
         * The ID of the custom routing listener.
         */
        listenerId: string;
        /**
         * The status of the endpoint group. Valid Values: `init`, `active`, `updating`, `deleting`.
         */
        status: string;
    }

    export interface GetCustomRoutingEndpointTrafficPoliciesCustomRoutingEndpointTrafficPolicy {
        /**
         * The ID of the GA instance to which the traffic policies belong.
         */
        acceleratorId: string;
        /**
         * The IP addresses of the traffic policies.
         */
        address: string;
        /**
         * The ID of the Custom Routing Endpoint Traffic Policy.
         */
        customRoutingEndpointTrafficPolicyId: string;
        /**
         * The ID of the endpoint group to which the traffic policies belong.
         */
        endpointGroupId: string;
        /**
         * The ID of the endpoint to which the traffic policies belong.
         */
        endpointId: string;
        /**
         * The id of the Global Accelerator Custom Routing Endpoint Traffic Policy. It formats as `<endpoint_id>:<custom_routing_endpoint_traffic_policy_id>`.
         */
        id: string;
        /**
         * The ID of the listener to which the traffic policies belong.
         */
        listenerId: string;
        /**
         * The port range of the traffic policy.
         */
        portRanges: outputs.ga.GetCustomRoutingEndpointTrafficPoliciesCustomRoutingEndpointTrafficPolicyPortRange[];
    }

    export interface GetCustomRoutingEndpointTrafficPoliciesCustomRoutingEndpointTrafficPolicyPortRange {
        /**
         * The first port of the port range.
         */
        fromPort: number;
        /**
         * The last port of the port range.
         */
        toPort: number;
    }

    export interface GetCustomRoutingEndpointsCustomRoutingEndpoint {
        /**
         * The ID of the GA instance.
         */
        acceleratorId: string;
        /**
         * The ID of the Custom Routing Endpoint.
         */
        customRoutingEndpointId: string;
        /**
         * The ID of the endpoint (vSwitch).
         */
        endpoint: string;
        /**
         * The ID of the endpoint group.
         */
        endpointGroupId: string;
        /**
         * The id of the Global Accelerator Custom Routing Endpoint. It formats as `<endpoint_group_id>:<custom_routing_endpoint_id>`.
         */
        id: string;
        /**
         * The ID of the custom routing listener.
         */
        listenerId: string;
        /**
         * The access policy of traffic for the specified endpoint.
         */
        trafficToEndpointPolicy: string;
        /**
         * The backend service type of the endpoint.
         */
        type: string;
    }

    export interface GetCustomRoutingPortMappingsCustomRoutingPortMapping {
        /**
         * The ID of the GA instance.
         */
        acceleratorId: string;
        /**
         * The acceleration port.
         */
        acceleratorPort: number;
        /**
         * The service IP address and port of the backend instance.
         */
        destinationSocketAddresses: outputs.ga.GetCustomRoutingPortMappingsCustomRoutingPortMappingDestinationSocketAddress[];
        /**
         * The ID of the endpoint group.
         */
        endpointGroupId: string;
        /**
         * The ID of the region in which the endpoint group resides.
         */
        endpointGroupRegion: string;
        /**
         * The ID of the endpoint.
         */
        endpointId: string;
        /**
         * The ID of the listener.
         */
        listenerId: string;
        /**
         * The protocol of the backend service.
         */
        protocols: string[];
        /**
         * The access policy of traffic for the backend instance. Valid Values: `allow`, `deny`.
         */
        status: string;
        /**
         * The ID of the endpoint (vSwitch).
         */
        vswitch: string;
    }

    export interface GetCustomRoutingPortMappingsCustomRoutingPortMappingDestinationSocketAddress {
        /**
         * The service IP address of the backend instance.
         */
        ipAddress: string;
        /**
         * The service port of the backend instance.
         */
        port: number;
    }

    export interface GetDomainsDomain {
        /**
         * The ID of the global acceleration instance.
         */
        acceleratorId: string;
        /**
         * The accelerated domain name to be added. only top-level domain names are supported, such as 'example.com'.
         */
        domain: string;
        /**
         * The ID of the Ga Domain.
         */
        id: string;
        /**
         * The status of the resource. Valid values: `illegal`, `inactive`, `active`, `unknown`.
         */
        status: string;
    }

    export interface GetEndpointGroupsGroup {
        /**
         * The description of the endpoint group.
         */
        description: string;
        /**
         * The endpointConfigurations of the endpoint group.
         */
        endpointConfigurations: outputs.ga.GetEndpointGroupsGroupEndpointConfiguration[];
        /**
         * The endpointGroupId of the Endpoint Group.
         */
        endpointGroupId: string;
        /**
         * The ID of the region where the endpoint group is deployed.
         */
        endpointGroupRegion: string;
        /**
         * The interval between two consecutive health checks. Unit: seconds.
         */
        healthCheckIntervalSeconds: number;
        /**
         * The path specified as the destination of the targets for health checks.
         */
        healthCheckPath: string;
        /**
         * The port that is used for health checks.
         */
        healthCheckPort: number;
        /**
         * The protocol that is used to connect to the targets for health checks.
         */
        healthCheckProtocol: string;
        /**
         * The ID of the Endpoint Group.
         */
        id: string;
        /**
         * The ID of the listener that is associated with the endpoint group.
         */
        listenerId: string;
        /**
         * The name of the endpoint group.
         */
        name: string;
        /**
         * Mapping between listening port and forwarding port of boarding point.
         */
        portOverrides: outputs.ga.GetEndpointGroupsGroupPortOverride[];
        /**
         * The status of the endpoint group.
         */
        status: string;
        /**
         * The number of consecutive failed heath checks that must occur before the endpoint is deemed unhealthy.
         */
        thresholdCount: number;
        /**
         * The weight of the endpoint group when the corresponding listener is associated with multiple endpoint groups.
         */
        trafficPercentage: number;
    }

    export interface GetEndpointGroupsGroupEndpointConfiguration {
        /**
         * Indicates whether client IP addresses are reserved.
         */
        enableClientipPreservation: boolean;
        /**
         * The IP address or domain name of Endpoint N in the endpoint group.
         */
        endpoint: string;
        /**
         * Probe Port.
         */
        probePort: number;
        /**
         * Probe Protocol.
         */
        probeProtocol: string;
        /**
         * The type of Endpoint N in the endpoint group.
         */
        type: string;
        /**
         * The weight of Endpoint N in the endpoint group.
         */
        weight: number;
    }

    export interface GetEndpointGroupsGroupPortOverride {
        /**
         * Forwarding port.
         */
        endpointPort: number;
        /**
         * Listener port.
         */
        listenerPort: number;
    }

    export interface GetForwardingRulesForwardingRule {
        /**
         * Forwarding Policy ID.
         */
        forwardingRuleId: string;
        /**
         * Forwarding policy name. The length of the name is 2-128 English or Chinese characters.
         */
        forwardingRuleName: string;
        /**
         * Forwarding Policy Status.
         */
        forwardingRuleStatus: string;
        id: string;
        /**
         * The ID of the listener.
         */
        listenerId: string;
        /**
         * Forwarding policy priority.
         */
        priority: number;
        /**
         * The IP protocol used by the GA instance.
         * `order` - Forwarding priority.
         * `ruleActionType` - Forward action type.
         * `forwardGroupConfig` - Forwarding configuration.
         * `serverGroupTuples` - Terminal node group configuration.
         * `endpointGroupId` - Terminal node group ID.
         */
        ruleActions: outputs.ga.GetForwardingRulesForwardingRuleRuleAction[];
        /**
         * Forward action.
         * `ruleConditionType` - Forwarding condition type.
         * `pathConfig` - Path configuration information.
         * `values` - The length of the path is 1-128 characters.
         * `hostConfig` - Domain name configuration information.
         * `values` - The domain name is 3-128 characters long.
         */
        ruleConditions: outputs.ga.GetForwardingRulesForwardingRuleRuleCondition[];
    }

    export interface GetForwardingRulesForwardingRuleRuleAction {
        forwardGroupConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleActionForwardGroupConfig[];
        order: number;
        ruleActionType: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleActionForwardGroupConfig {
        serverGroupTuples: outputs.ga.GetForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
        endpointGroupId: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleCondition {
        hostConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleConditionHostConfig[];
        pathConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleConditionPathConfig[];
        ruleConditionType: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleConditionHostConfig {
        values: string[];
    }

    export interface GetForwardingRulesForwardingRuleRuleConditionPathConfig {
        values: string[];
    }

    export interface GetIpSetsSet {
        /**
         * The ID of an acceleration region.
         */
        accelerateRegionId: string;
        /**
         * The bandwidth allocated to the acceleration region.
         */
        bandwidth: number;
        /**
         * The ID of the Ip Set.
         */
        id: string;
        /**
         * The list of accelerated IP addresses in the acceleration region.
         */
        ipAddressLists: string[];
        /**
         * Accelerated area ID.
         */
        ipSetId: string;
        /**
         * The IP protocol used by the GA instance.
         */
        ipVersion: string;
        /**
         * The status of the acceleration region.
         */
        status: string;
    }

    export interface GetListenersListener {
        /**
         * The certificates of the listener.
         */
        certificates: outputs.ga.GetListenersListenerCertificate[];
        /**
         * The clientAffinity of the listener.
         */
        clientAffinity: string;
        /**
         * The description of the listener.
         */
        description: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The listenerId of the listener.
         */
        listenerId: string;
        /**
         * The name of the listener. The length of the name is 2-128 characters. It starts with uppercase and lowercase letters or Chinese characters. It can contain numbers and underscores and dashes.
         */
        name: string;
        /**
         * The portRanges of the listener.
         */
        portRanges: outputs.ga.GetListenersListenerPortRange[];
        /**
         * Type of network transport protocol monitored.
         */
        protocol: string;
        /**
         * The status of the listener.
         */
        status: string;
    }

    export interface GetListenersListenerCertificate {
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The type of the certificate.
         */
        type: string;
    }

    export interface GetListenersListenerPortRange {
        /**
         * The initial listening port used to receive requests and forward them to terminal nodes.
         */
        fromPort: number;
        /**
         * The end listening port used to receive requests and forward them to terminal nodes.
         */
        toPort: number;
    }

    export interface ListenerCertificate {
        /**
         * The id of the certificate.
         */
        id?: string;
    }

    export interface ListenerForwardedForConfig {
        /**
         * Specifies whether to use the GA-AP header to retrieve the information about acceleration regions. Default value: `false`. Valid values:
         */
        forwardedForGaApEnabled?: boolean;
        /**
         * Specifies whether to use the GA-ID header to retrieve the ID of the GA instance. Default value: `false`. Valid values:
         */
        forwardedForGaIdEnabled?: boolean;
        /**
         * Specifies whether to use the GA-X-Forward-Port header to retrieve the listener ports of the GA instance. Default value: `false`. Valid values:
         */
        forwardedForPortEnabled?: boolean;
        /**
         * Specifies whether to use the GA-X-Forward-Proto header to retrieve the listener protocol of the GA instance. Default value: `false`. Valid values:
         */
        forwardedForProtoEnabled?: boolean;
        /**
         * Specifies whether to use the X-Real-IP header to retrieve client IP addresses. Default value: `false`. Valid values:
         */
        realIpEnabled?: boolean;
    }

    export interface ListenerPortRange {
        /**
         * The initial listening port used to receive requests and forward them to terminal nodes.
         */
        fromPort: number;
        /**
         * The end listening port used to receive requests and forward them to terminal nodes.
         */
        toPort: number;
    }

}

export namespace gpdb {
    export interface DbInstancePlanPlanConfig {
        /**
         * Pause instance plan config. See the following `Block pause`.
         */
        pause?: outputs.gpdb.DbInstancePlanPlanConfigPause;
        /**
         * Resume instance plan config. See the following `Block resume`.
         */
        resume?: outputs.gpdb.DbInstancePlanPlanConfigResume;
        /**
         * Scale In instance plan config. See the following `Block scaleIn`.
         */
        scaleIn?: outputs.gpdb.DbInstancePlanPlanConfigScaleIn;
        /**
         * Scale out instance plan config. See the following `Block scaleOut`.
         */
        scaleOut?: outputs.gpdb.DbInstancePlanPlanConfigScaleOut;
    }

    export interface DbInstancePlanPlanConfigPause {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime?: string;
    }

    export interface DbInstancePlanPlanConfigResume {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime?: string;
    }

    export interface DbInstancePlanPlanConfigScaleIn {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime?: string;
        /**
         * The segment Node Num of the Plan.
         */
        segmentNodeNum?: string;
    }

    export interface DbInstancePlanPlanConfigScaleOut {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime?: string;
        /**
         * The segment Node Num of the Plan.
         */
        segmentNodeNum?: string;
    }

    export interface GetAccountsAccount {
        /**
         * The description of the account.
         */
        accountDescription: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The ID of the Account. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The status of the account. Valid values: `Active`, `Creating` and `Deleting`.
         */
        status: string;
    }

    export interface GetDbInstancePlansPlan {
        /**
         * The name of the Plan.
         */
        dbInstancePlanName: string;
        /**
         * The ID of the resource. The value formats as `<db_instance_id>:<plan_id>`.
         */
        id: string;
        /**
         * Plan configuration information.
         */
        planConfigs: outputs.gpdb.GetDbInstancePlansPlanPlanConfig[];
        planDesc: string;
        /**
         * The end time of the Plan.
         */
        planEndDate: string;
        /**
         * The ID of DB Instance Plan.
         */
        planId: string;
        /**
         * Plan scheduling type. Valid values: `Postpone`, `Regular`.
         */
        planScheduleType: string;
        /**
         * The start time of the Plan.
         */
        planStartDate: string;
        /**
         * The type of the Plan. Valid values: `PauseResume`, `Resize`.
         */
        planType: string;
        /**
         * The Status of the Plan.
         */
        status: string;
    }

    export interface GetDbInstancePlansPlanPlanConfig {
        /**
         * Pause instance plan config.
         */
        pauses: outputs.gpdb.GetDbInstancePlansPlanPlanConfigPause[];
        /**
         * Resume instance plan config.
         */
        resumes: outputs.gpdb.GetDbInstancePlansPlanPlanConfigResume[];
        /**
         * Scale In instance plan config.
         */
        scaleIns: outputs.gpdb.GetDbInstancePlansPlanPlanConfigScaleIn[];
        /**
         * Scale out instance plan config.
         */
        scaleOuts: outputs.gpdb.GetDbInstancePlansPlanPlanConfigScaleOut[];
    }

    export interface GetDbInstancePlansPlanPlanConfigPause {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime: string;
        /**
         * The Status of the plan Task.
         */
        planTaskStatus: string;
    }

    export interface GetDbInstancePlansPlanPlanConfigResume {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime: string;
        /**
         * The Status of the plan Task.
         */
        planTaskStatus: string;
    }

    export interface GetDbInstancePlansPlanPlanConfigScaleIn {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime: string;
        /**
         * The Status of the plan Task.
         */
        planTaskStatus: string;
        /**
         * The segment Node Num of the Plan.
         */
        segmentNodeNum: string;
    }

    export interface GetDbInstancePlansPlanPlanConfigScaleOut {
        /**
         * The executed time of the Plan.
         */
        executeTime: string;
        /**
         * The Cron Time of the plan.
         */
        planCronTime: string;
        /**
         * The Status of the plan Task.
         */
        planTaskStatus: string;
        /**
         * The segment Node Num of the Plan.
         */
        segmentNodeNum: string;
    }

    export interface GetInstancesInstance {
        /**
         * Instance availability zone.
         */
        availabilityZone: string;
        chargeType: string;
        /**
         * The connection string of the instance.
         */
        connectionString: string;
        /**
         * The number of CPU cores of the computing node. Unit: Core.
         */
        cpuCores: string;
        /**
         * The time when the instance was created. The time is in the YYYY-MM-DDThh:mm:ssZ format, such as 2011-05-30T12:11:4Z.
         */
        createTime: string;
        creationTime: string;
        /**
         * The db instance category. Valid values: `HighAvailability`, `Basic`.
         */
        dbInstanceCategory: string;
        /**
         * The db instance class.
         */
        dbInstanceClass: string;
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The db instance mode. Valid values: `StorageElastic`, `Serverless`, `Classic`.
         */
        dbInstanceMode: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The database engine used by the instance.
         */
        engine: string;
        /**
         * The version of the database engine used by the instance.
         */
        engineVersion: string;
        /**
         * The ID of the db Instance.
         */
        id: string;
        /**
         * The network type of the instance.
         */
        instanceNetworkType: string;
        /**
         * The ip whitelist.
         */
        ipWhitelists: outputs.gpdb.GetInstancesInstanceIpWhitelist[];
        /**
         * The end time of the maintenance window for the instance.
         */
        maintainEndTime: string;
        /**
         * The start time of the maintenance window for the instance.
         */
        maintainStartTime: string;
        /**
         * The number of Master nodes. Valid values: 1 to 2. if it is not filled in, the default value is 1 Master node.
         */
        masterNodeNum: string;
        /**
         * The memory size of the compute node.
         */
        memorySize: string;
        /**
         * The billing method of the instance. Valid values: `Subscription`, `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Calculate the number of nodes. The value range of the high-availability version of the storage elastic mode is 4 to 512, and the value must be a multiple of 4. The value range of the basic version of the storage elastic mode is 2 to 512, and the value must be a multiple of 2. The-Serverless version has a value range of 2 to 512. The value must be a multiple of 2.
         */
        segNodeNum: string;
        /**
         * The status of the instance. Valid values: `Creating`, `DBInstanceClassChanging`, `DBInstanceNetTypeChanging`, `Deleting`, `EngineVersionUpgrading`, `GuardDBInstanceCreating`, `GuardSwitching`, `Importing`, `ImportingFromOtherInstance`, `Rebooting`, `Restoring`, `Running`, `Transfering`, `TransferingToOtherInstance`.
         */
        status: string;
        /**
         * The storage capacity. Unit: GB. Value: `50` to `4000`.
         */
        storageSize: number;
        /**
         * The type of disks. Valid values: `cloudEssd`, `cloudEfficiency`.
         */
        storageType: string;
        /**
         * The tags of the instance.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceIpWhitelist {
        /**
         * The value of this parameter is empty by default. The attribute of the whitelist group. The console does not display the whitelist group whose value of this parameter is hidden.
         */
        ipGroupAttribute: string;
        /**
         * IP whitelist group name
         */
        ipGroupName: string;
        /**
         * List of IP addresses allowed to access all databases of an instance. The list contains up to 1,000 IP addresses, separated by commas. Supported formats include 0.0.0.0/0, 10.23.12.24 (IP), and 10.23.12.24/24 (Classless Inter-Domain Routing (CIDR) mode. /24 represents the length of the prefix in an IP address. The range of the prefix length is [1,32]). System default to `["127.0.0.1"]`.
         */
        securityIpList: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceIpWhitelist {
        /**
         * The value of this parameter is empty by default. The attribute of the whitelist group. 
         * If the value contains `hidden`, this white list item will not output.
         */
        ipGroupAttribute: string;
        /**
         * IP whitelist group name
         */
        ipGroupName: string;
        /**
         * Field `securityIpList` has been deprecated from provider version 1.187.0. New field `ipWhitelist` instead.
         */
        securityIpList: string;
    }

}

export namespace graphdatabase {
    export interface DbInstanceDbInstanceIpArray {
        /**
         * The default is empty. To distinguish between the different property console does not display a `hidden` label grouping.
         */
        dbInstanceIpArrayAttribute?: string;
        /**
         * IP ADDRESS whitelist group name.
         */
        dbInstanceIpArrayName?: string;
        /**
         * IP ADDRESS whitelist addresses in the IP ADDRESS list, and a maximum of 1000 comma-separated format is as follows: `0.0.0.0/0` and `10.23.12.24`(IP) or `10.23.12.24/24`(CIDR mode, CIDR (Classless Inter-Domain Routing)/24 represents the address prefixes in the length of the range [1,32]).
         */
        securityIps?: string;
    }

    export interface GetDbInstancesInstance {
        /**
         * Virtual Private Cloud (vpc connection such as a VPN connection or leased line domain name).
         */
        connectionString: string;
        /**
         * Creation time, which follows the format of `YYYY-MM-DD 'T'hh:mm:ssZ`, such as `2011-05-30 T12:11:4Z`.
         */
        createTime: string;
        /**
         * The current kernel image version.
         */
        currentMinorVersion: string;
        /**
         * The category of the db instance.
         */
        dbInstanceCategory: string;
        /**
         * For example, instances can be grouped according to Cpu core count.
         */
        dbInstanceCpu: string;
        /**
         * According to the practical example or notes.
         */
        dbInstanceDescription: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * IP ADDRESS whitelist for the instance group list.
         */
        dbInstanceIpArrays: outputs.graphdatabase.GetDbInstancesInstanceDbInstanceIpArray[];
        /**
         * Instance memory, which is measured in MB.
         */
        dbInstanceMemory: string;
        /**
         * The network type of the db instance.
         */
        dbInstanceNetworkType: string;
        /**
         * Disk storage type. Valid values: `cloudEssd`, `cloudSsd`.
         */
        dbInstanceStorageType: string;
        /**
         * The type of the db instance.
         */
        dbInstanceType: string;
        /**
         * The class of the db node.
         */
        dbNodeClass: string;
        /**
         * The count of the db node.
         */
        dbNodeCount: string;
        /**
         * Instance storage space, which is measured in GB.
         */
        dbNodeStorage: string;
        /**
         * Kernel Version. Value range: `1.0` or `1.0-OpenCypher`. `1.0`: represented as gremlin, `1.0-OpenCypher`: said opencypher.
         */
        dbVersion: string;
        /**
         * The instance after it expires time for subscription instance.
         */
        expireTime: string;
        /**
         * The expire status of the db instance.
         */
        expired: string;
        /**
         * The ID of the Db Instance.
         */
        id: string;
        /**
         * The latest kernel image version.
         */
        latestMinorVersion: string;
        /**
         * Instance lock state. Value range: `Unlock`, `ManualLock`, `LockByExpiration`, `LockByRestoration` and `LockByDiskQuota`. `Unlock`: normal. `ManualLock`: the manual trigger lock. `LockByExpiration`: that represents the instance expires automatically lock. `LockByRestoration`: indicates that the instance rollback before auto-lock. `LockByDiskQuota`: that represents the instance space full automatic lock.
         */
        lockMode: string;
        /**
         * An instance is locked the reason.
         */
        lockReason: string;
        /**
         * Instance maintenance time such as `00:00Z-02:00Z`, 0 to 2 points to carry out routine maintenance.
         */
        maintainTime: string;
        /**
         * The master instance ID of the db instance.
         */
        masterDbInstanceId: string;
        /**
         * The paymen type of the resource.
         */
        paymentType: string;
        /**
         * Application Port.
         */
        port: number;
        /**
         * The public connection string ID of the resource.
         */
        publicConnectionString: string;
        /**
         * The public port ID of the resource.
         */
        publicPort: number;
        /**
         * The array of the readonly db instances.
         */
        readOnlyDbInstanceIds: string[];
        /**
         * Instance status. Value range: `Creating`, `Running`, `Deleting`, `Rebooting`, `DBInstanceClassChanging`, `NetAddressCreating` and `NetAddressDeleting`.
         */
        status: string;
        /**
         * The vpc id of the db instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the resource.
         */
        zoneId: string;
    }

    export interface GetDbInstancesInstanceDbInstanceIpArray {
        /**
         * The default is empty. To distinguish between the different property console does not display a `hidden` label grouping.
         */
        dbInstanceIpArrayAttribute?: string;
        /**
         * IP ADDRESS whitelist group name.
         */
        dbInstanceIpArrayName?: string;
        /**
         * IP ADDRESS whitelist addresses in the IP ADDRESS list, and a maximum of 1000 comma-separated format is as follows: `0.0.0.0/0` and `10.23.12.24`(IP) or `10.23.12.24/24`(CIDR mode, CIDR (Classless Inter-Domain Routing)/24 represents the address prefixes in the length of the range [1,32]).
         */
        securityIps?: string;
    }

}

export namespace hbase {
    export interface GetInstanceTypesCoreInstanceType {
        /**
         * Name of the category, single or cluster.
         */
        category: string;
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * The engine name, `singlehbase`, `hbase`, `hbaseue`, `bds`.
         */
        engine: string;
        /**
         * The hbase instance type of create hbase cluster instance.
         */
        instanceType: string;
        /**
         * Max count of the core instance nodes.
         */
        maxCoreCount: number;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
        /**
         * Name of the storage type.
         */
        storageType: string;
        /**
         * The engine version, singlehbase/hbase=1.1/2.0, bds=1.0.
         */
        version: string;
        /**
         * Name of zone id.
         */
        zone: string;
    }

    export interface GetInstanceTypesMasterInstanceType {
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * The hbase instance type of create hbase cluster instance.
         */
        instanceType: string;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
    }

    export interface GetInstanceTypesType {
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
        /**
         * Name of the instance type.
         */
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The Backup Status of the instance.
         */
        backupStatus: string;
        /**
         * Core node disk size, unit:GB.
         */
        coreDiskSize: number;
        /**
         * Cloud_ssd or cloud_efficiency
         */
        coreDiskType: string;
        /**
         * Like hbase.sn2.2xlarge, hbase.sn2.4xlarge, hbase.sn2.8xlarge and so on.
         */
        coreInstanceType: string;
        /**
         * Same with "coreInstanceQuantity"
         */
        coreNodeCount: number;
        /**
         * The created time of the instance.
         */
        createdTime: string;
        /**
         * The switch of delete protection.
         */
        deletionProtection: boolean;
        /**
         * The engine of the instance.
         */
        engine: string;
        /**
         * The engineVersion of the instance.
         */
        engineVersion: string;
        /**
         * The expire time of the instance.
         */
        expireTime: string;
        /**
         * The ID of the HBase instance.
         */
        id: string;
        /**
         * Like hbase.sn2.2xlarge, hbase.sn2.4xlarge, hbase.sn2.8xlarge and so on.
         */
        masterInstanceType: string;
        /**
         * The node count of master
         */
        masterNodeCount: number;
        /**
         * The name of the HBase instance.
         */
        name: string;
        /**
         * Classic network or VPC.
         */
        networkType: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * VPC ID the instance belongs to.
         */
        vpcId: string;
        /**
         * VSwitch ID the instance belongs to.
         */
        vswitchId: string;
        /**
         * Zone ID the instance belongs to.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone. Removed from v1.99.0.
         */
        multiZoneIds: string[];
    }

    export interface InstanceSlbConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

    export interface InstanceUiProxyConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

    export interface InstanceZkConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

}

export namespace hbr {
    export interface GetBackupJobsFilter {
        /**
         * The key of the field to filter. Valid values: `PlanId`, `VaultId`, `InstanceId`, `Bucket`, `FileSystemId`, `CompleteTime`.
         */
        key?: string;
        /**
         * The operator of the field to filter. Valid values: `EQUAL`, `NOT_EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `BETWEEN`, `IN`.
         */
        operator?: string;
        /**
         * Set of values that are accepted for the given field.
         *
         * > **NOTE:** Numeric types such as `CompleteTime` do not support `IN` operations for the time being.
         */
        values?: string[];
    }

    export interface GetBackupJobsJob {
        /**
         * The actual data volume of the backup task (After deduplication) . Unit byte.
         */
        actualBytes: string;
        /**
         * The actual number of items in the backup task. (Currently only file backup is available).
         */
        actualItems: string;
        /**
         * The name of backup job.
         */
        backJobName: string;
        /**
         * The ID of the backup job.
         */
        backupJobId: string;
        /**
         * Backup type. Valid values: `COMPLETE`(full backup).
         */
        backupType: string;
        /**
         * The name of target OSS bucket.
         */
        bucket: string;
        /**
         * The amount of backup data (Incremental). Unit byte.
         */
        bytesDone: string;
        /**
         * The total amount of data sources. Unit byte.
         */
        bytesTotal: string;
        /**
         * The completion time of backup job. UNIX time seconds.
         */
        completeTime: string;
        /**
         * The creation time of backup job. UNIX time seconds.
         */
        createTime: string;
        /**
         * The role name created in the original account RAM backup by the cross account managed by the current account. It is valid only when `sourceType` is `ECS_FILE`, `NAS`, `OSS` or `OTS`.
         */
        crossAccountRoleName: string;
        /**
         * The type of the cross account backup. It is valid only when `sourceType` is `ECS_FILE`, `NAS`, `OSS` or `OTS`.
         */
        crossAccountType: string;
        /**
         * The original account ID of the cross account backup managed by the current account. It is valid only when `sourceType` is `ECS_FILE`, `NAS`, `OSS` or `OTS`.
         */
        crossAccountUserId: number;
        /**
         * Error message.
         */
        errorMessage: string;
        /**
         * Exclude path. String of Json list. Up to 255 characters. e.g. `"[\"/home/work\"]"`
         */
        exclude: string;
        /**
         * The ID of destination file system.
         */
        fileSystemId: string;
        /**
         * The ID of the backup job.
         */
        id: string;
        /**
         * Include path. String of Json list. Up to 255 characters. e.g. `"[\"/var\"]"`
         */
        include: string;
        /**
         * The ID of target ECS instance.
         */
        instanceId: string;
        /**
         * The number of items restore job recovered.
         */
        itemsDone: string;
        /**
         * The total number of items restore job recovered.
         */
        itemsTotal: string;
        /**
         * File system creation time. UNIX time in seconds.
         */
        nasCreateTime: string;
        otsDetails: outputs.hbr.GetBackupJobsJobOtsDetail[];
        /**
         * List of backup path. e.g. `["/home", "/var"]`.
         */
        paths: string[];
        /**
         * The ID of a backup plan.
         */
        planId: string;
        /**
         * The prefix of Oss bucket files.
         */
        prefix: string;
        /**
         * Backup progress. The value is 100%*100.
         */
        progress: string;
        /**
         * The type of data source. Valid Values: `ECS_FILE`, `OSS`, `NAS`, `UDM_DISK`.
         */
        sourceType: string;
        /**
         * The scheduled backup start time. UNIX time seconds.
         */
        startTime: string;
        /**
         * The status of restore job. Valid values: `COMPLETE` , `PARTIAL_COMPLETE`, `FAILED`.
         */
        status: string;
        /**
         * The update time of backup job. UNIX time seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetBackupJobsJobOtsDetail {
        tableNames: string[];
    }

    export interface GetEcsBackupClientsClient {
        /**
         * The system architecture of client, only the ECS File Backup Client is available. Valid values: `AMD64` , `386`.
         */
        archType: string;
        /**
         * Client protected status. Valid values: `UNPROTECTED`, `PROTECTED`.
         */
        backupStatus: string;
        /**
         * The type of client. Valid values: `ECS_CLIENT` (ECS File Backup Client).
         */
        clientType: string;
        /**
         * The version of client.
         */
        clientVersion: string;
        /**
         * The creation time of client. Unix time in seconds.
         */
        createTime: string;
        /**
         * The data plane access point type. Valid Values: `PUBLIC`, `VPC`, `CLASSIC`.
         */
        dataNetworkType: string;
        /**
         * The data plane proxy settings. Valid Values: `DISABLE`, `USE_CONTROL_PROXY`, `CUSTOM`.
         */
        dataProxySetting: string;
        /**
         * The first ID of the resource.
         */
        ecsBackupClientId: string;
        /**
         * The hostname of ECS instance.
         */
        hostname: string;
        /**
         * The ID of the Ecs Backup Client.
         */
        id: string;
        /**
         * The ID of ECS instance. When the client type is ECS file backup client, it indicates the ID of ECS instance. When the client type is a local file backup client, it is a hardware fingerprint generated based on system information.
         */
        instanceId: string;
        /**
         * The name of ECS instance.
         */
        instanceName: string;
        /**
         * The last heartbeat time of client. Unix Time Seconds.
         */
        lastHeartBeatTime: string;
        /**
         * The latest version of client.
         */
        maxClientVersion: string;
        /**
         * The number of CPU cores used by a single backup task, 0 means no restrictions.
         */
        maxCpuCore: string;
        /**
         * The number of concurrent jobs for a single backup task, 0 means no restrictions.
         */
        maxWorker: string;
        /**
         * The operating system type of client, only the ECS File Backup Client is available. Valid values: `windows`, `linux`.
         */
        osType: string;
        /**
         * Intranet IP address of the instance, only available for ECS file backup client.
         */
        privateIpv4: string;
        /**
         * Custom data plane proxy server host address.
         */
        proxyHost: string;
        /**
         * The password of custom data plane proxy server.
         */
        proxyPassword: string;
        /**
         * Custom data plane proxy server host port.
         */
        proxyPort: string;
        /**
         * The username of custom data plane proxy server.
         */
        proxyUser: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The update time of client. Unix Time Seconds.
         */
        updatedTime: string;
        /**
         * Indicates whether to use the HTTPS protocol. Valid values: `true`, `false`.
         */
        useHttps: boolean;
        /**
         * The ID of Zone.
         */
        zoneId: string;
    }

    export interface GetEcsBackupPlansPlan {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        createTime: string;
        /**
         * The creation time of the backup plan. UNIX time in seconds.
         */
        createdTime: string;
        detail: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of ecs backup plan.
         */
        ecsBackupPlanId: string;
        /**
         * The name of the backup plan.
         */
        ecsBackupPlanName: string;
        /**
         * Exclude path. String of Json list. Up to 255 characters. e.g. `"[\"/home/work\"]"`
         */
        exclude: string;
        /**
         * The ID of ecs backup plan.
         */
        id: string;
        /**
         * Include path. String of Json list. Up to 255 characters. e.g. `"[\"/var\"]"`
         */
        include: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * Windows operating system with application consistency using VSS. eg: {`UseVSS`:false}.
         */
        options: string;
        /**
         * Backup path. e.g. `["/home", "/var"]`
         */
        paths: string[];
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy. Optional format: `I|{startTime}|{interval}`. It means to execute a backup task every `{interval}` starting from `{startTime}`. The backup task for the elapsed time will not be compensated. If the last backup task has not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        /**
         * The type of backup source.
         */
        sourceType: string;
        /**
         * Flow control. The format is: {start}|{end}|{bandwidth}. Use `|` to separate multiple flow control configurations, multiple flow control configurations not allowed to have overlapping times.
         */
        speedLimit: string;
        /**
         * The update time of the backup plan. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of Backup vault.
         */
        vaultId: string;
    }

    export interface GetHanaBackupClientsHanaBackupClient {
        /**
         * The alert settings.
         */
        alertSetting: string;
        /**
         * The ID of the backup client.
         */
        clientId: string;
        /**
         * The name of the backup client.
         */
        clientName: string;
        /**
         * The type of the backup client.
         */
        clientType: string;
        /**
         * The version number of the backup client.
         */
        clientVersion: string;
        /**
         * The ID of the SAP HANA instance.
         */
        clusterId: string;
        /**
         * The id of the Hana Backup Client. It formats as `<vault_id>:<client_id>`.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        /**
         * The maximum version number of the backup client.
         */
        maxVersion: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The status of the Hana Backup Client. Valid Values: `REGISTERED`, `ACTIVATED`, `DEACTIVATED`, `INSTALLING`, `INSTALL_FAILED`, `NOT_INSTALLED`, `UPGRADING`, `UPGRADE_FAILED`, `UNINSTALLING`, `UNINSTALL_FAILED`, `STOPPED`, `UNKNOWN`.
         */
        status: string;
        /**
         * The status information.
         */
        statusMessage: string;
        /**
         * Indicates whether data is transmitted over HTTPS.
         */
        useHttps: boolean;
        /**
         * The ID of the backup vault.
         */
        vaultId: string;
    }

    export interface GetHanaBackupPlansPlan {
        /**
         * The backup prefix.
         */
        backupPrefix: string;
        /**
         * The backup type.
         */
        backupType: string;
        /**
         * The ID of the SAP HANA instance.
         */
        clusterId: string;
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * The ID of the resource.
         */
        id: string;
        pageTotal: string;
        /**
         * The ID of the backup plan.
         */
        planId: string;
        /**
         * The name of the backup plan.
         */
        planName: string;
        /**
         * The backup policy.
         */
        schedule: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the backup vault.
         */
        vaultId: string;
    }

    export interface GetHanaInstancesInstance {
        /**
         * The alert settings. Valid value: `INHERITED`, which indicates that the backup client sends alert notifications in the same way as the backup vault.
         */
        alertSetting: string;
        /**
         * The ID of the SAP HANA instance.
         */
        hanaInstanceId: string;
        /**
         * The name of the SAP HANA instance.
         */
        hanaName: string;
        /**
         * The private or internal IP address of the host where the primary node of the SAP HANA instance resides.
         */
        host: string;
        /**
         * The ID of the Hana Instance. The value formats as `<vault_id>:<hana_instance_id>`.
         */
        id: string;
        /**
         * The instance number of the SAP HANA system.
         */
        instanceNumber: number;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The status of the SAP HANA instance.
         */
        status: string;
        /**
         * The status information.
         */
        statusMessage: string;
        /**
         * Indicates whether the SAP HANA instance is connected over Secure Sockets Layer (SSL).
         */
        useSsl: boolean;
        /**
         * The username of the SYSTEMDB database.
         */
        userName: string;
        /**
         * Indicates whether the SSL certificate of the SAP HANA instance is verified.
         */
        validateCertificate: boolean;
        /**
         * The ID of the backup vault.
         */
        vaultId: string;
    }

    export interface GetNasBackupPlansPlan {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        /**
         * File System Creation Time. **Note** The time format of the API adopts the ISO 8601 format, such as `2021-07-09T15:45:30CST`.
         */
        createTime: string;
        /**
         * The creation time of the backup plan. UNIX time in seconds.
         */
        createdTime: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The File System ID of Nas.
         */
        fileSystemId: string;
        /**
         * The ID of Nas backup plan.
         */
        id: string;
        /**
         * The ID of Nas backup plan.
         */
        nasBackupPlanId: string;
        /**
         * The name of the resource.
         */
        nasBackupPlanName: string;
        /**
         * Options field of Nas backup plan.
         */
        options: string;
        /**
         * List of backup path. Up to 65536 Characters. e.g.`["/home", "/var"]`
         */
        paths: string[];
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy. Optional format: `I|{startTime}|{interval}`. It means to execute a backup task every `{interval}` starting from `{startTime}`. The backup task for the elapsed time will not be compensated. If the last backup task has not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        /**
         * The update time of the backup plan. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetOssBackupPlansPlan {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        /**
         * The name of OSS bucket.
         */
        bucket: string;
        /**
         * The creation time of the backup plan. UNIX time in seconds.
         */
        createdTime: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of Oss backup plan.
         */
        id: string;
        /**
         * The ID of Oss backup plan.
         */
        ossBackupPlanId: string;
        /**
         * The name of the backup plan. 1~64 characters, the backup plan name of each data source type in a single warehouse required to be unique.
         */
        ossBackupPlanName: string;
        /**
         * Backup prefix.
         */
        prefix: string;
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy. Optional format: I|{startTime}|{interval}. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        /**
         * The update time of the backup plan. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetOtsBackupPlansPlan {
        /**
         * The Backup type. Valid values: `COMPLETE`.
         */
        backupType: string;
        /**
         * The creation time of the backup plan. UNIX time in seconds.
         */
        createdTime: string;
        /**
         * Whether to be suspended. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of ots backup plan.
         */
        id: string;
        /**
         * The ID of ots backup plan.
         */
        otsBackupPlanId: string;
        /**
         * The name of the backup plan. 1~64 characters, the backup plan name of each data source type in a single warehouse required to be unique.
         */
        otsBackupPlanName: string;
        otsDetails: outputs.hbr.GetOtsBackupPlansPlanOtsDetail[];
        /**
         * The Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * The Backup strategy. Optional format: I|{startTime}|{interval}. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed yet, the next backup task will not be triggered.
         */
        schedule: string;
        /**
         * The type of the data source.
         */
        sourceType: string;
        /**
         * The update time of the backup plan. UNIX time in seconds.
         * *ots_detail - The details about the Tablestore instance.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetOtsBackupPlansPlanOtsDetail {
        tableNames: string[];
    }

    export interface GetOtsSnapshotsSnapshot {
        /**
         * The actual amount of backup snapshots after duplicates are removed. Unit: bytes.
         */
        actualBytes: string;
        /**
         * The backup type. Valid value: `COMPLETE`, which indicates full backup.
         */
        backupType: string;
        /**
         * The total amount of data. Unit: bytes.
         */
        bytesTotal: string;
        /**
         * The time when the backup snapshot was completed. This value is a UNIX timestamp. Unit: seconds.
         */
        completeTime: string;
        /**
         * The time when the Table store instance was created. This value is a UNIX timestamp. Unit: seconds.
         */
        createTime: string;
        /**
         * The time when the backup snapshot was created. This value is a UNIX timestamp. Unit: seconds.
         */
        createdTime: string;
        /**
         * The ID of the backup snapshot.
         */
        id: string;
        /**
         * The name of the Table store instance.
         */
        instanceName: string;
        /**
         * The ID of the backup job.
         */
        jobId: string;
        /**
         * The hash value of the parent backup snapshot.
         */
        parentSnapshotHash: string;
        /**
         * The time when the backup job ended. This value is a UNIX timestamp. Unit: milliseconds.
         */
        rangeEnd: string;
        /**
         * The time when the backup job started. This value is a UNIX timestamp. Unit: milliseconds.
         */
        rangeStart: string;
        /**
         * The retention period of the backup snapshot.
         */
        retention: string;
        /**
         * The hash value of the backup snapshot.
         */
        snapshotHash: string;
        /**
         * The ID of the backup snapshot.
         */
        snapshotId: string;
        /**
         * The type of the data source. Valid values: `ECS_FILE`,`PARTIAL_COMPLETE`,`FAILED`
         */
        sourceType: string;
        /**
         * The start time of the backup snapshot. This value is a UNIX timestamp. Unit: seconds.
         */
        startTime: string;
        /**
         * The status of the backup job. Valid values: `COMPLETE`,`PARTIAL_COMPLETE`,`FAILED`.
         */
        status: string;
        /**
         * The name of the table in the Table store instance.
         */
        tableName: string;
        /**
         * The time when the backup snapshot was updated. This value is a UNIX timestamp. Unit: seconds.
         */
        updatedTime: string;
        /**
         * The ID of the backup vault that stores the backup snapshot.
         */
        vaultId: string;
    }

    export interface GetReplicationVaultRegionsRegion {
        /**
         * The ID of the replication region.
         */
        replicationRegionId: string;
    }

    export interface GetRestoreJobsJob {
        /**
         * The actual size of Snapshot.
         */
        actualBytes: string;
        /**
         * The actual number of files.
         */
        actualItems: string;
        /**
         * The size of restore job recovered.
         */
        bytesDone: string;
        /**
         * The total size of restore job recovered.
         */
        bytesTotal: string;
        /**
         * The completion time of restore Job.
         */
        completeTime: string;
        /**
         * The creation time of restore job.
         */
        createTime: string;
        errorFile: string;
        /**
         * The error message of recovery task execution.
         */
        errorMessage: string;
        /**
         * The expiration time of restore job. Unix Time in seconds.
         */
        expireTime: string;
        /**
         * The ID of the restore job.
         */
        id: string;
        /**
         * The number of items restore job recovered.
         */
        itemsDone: string;
        /**
         * The total number of items restore job recovered.
         */
        itemsTotal: string;
        /**
         * Recovery Options.
         */
        options: string;
        parentId: string;
        /**
         * The recovery progress.
         */
        progress: number;
        /**
         * The ID of restore job.
         */
        restoreJobId: string;
        /**
         * The type of recovery destination. Valid Values: `ECS_FILE`, `OSS`, `NAS`.
         */
        restoreType: string;
        /**
         * The hashcode of Snapshot.
         */
        snapshotHash: string;
        /**
         * The ID of Snapshot.
         */
        snapshotId: string;
        /**
         * The list of data source types. Valid values: `ECS_FILE`, `NAS`, `OSS`, `OTS_TABLE`,`UDM_ECS_ROLLBACK`.
         */
        sourceType: string;
        /**
         * The start time of restore job. Unix Time in Seconds.
         */
        startTime: string;
        /**
         * The status of restore job.
         */
        status: string;
        /**
         * The name of target ofo OSS bucket.
         */
        targetBucket: string;
        targetClientId: string;
        /**
         * The creation time of destination file system.
         */
        targetCreateTime: string;
        targetDataSourceId: string;
        /**
         * The ID of destination file system.
         */
        targetFileSystemId: string;
        /**
         * The ID of target ECS instance.
         */
        targetInstanceId: string;
        /**
         * The target file path of ECS instance.
         */
        targetPath: string;
        /**
         * The file prefix of target OSS object.
         */
        targetPrefix: string;
        /**
         * The update Time of restore job. Unix Time in Seconds.
         */
        updatedTime: string;
        /**
         * The ID of backup vault.
         */
        vaultId: string;
    }

    export interface GetServerBackupPlansFilter {
        /**
         * The key of the field to filter. Valid values: `planId`, `instanceId`, `planName`.
         */
        key?: string;
        /**
         * Set of values that are accepted for the given field.
         */
        values?: string[];
    }

    export interface GetServerBackupPlansPlan {
        /**
         * The creation time of backup plan.
         */
        createTime: string;
        /**
         * ECS server backup plan details.
         */
        details: outputs.hbr.GetServerBackupPlansPlanDetail[];
        /**
         * Whether to disable the backup task. Valid values: `true`, `false`.
         */
        disabled: boolean;
        /**
         * The ID of the server backup plan.
         */
        ecsServerBackupPlanId: string;
        /**
         * The name of the backup plan. 1~64 characters, the backup plan name of each data source type in a single warehouse required to be unique.
         */
        ecsServerBackupPlanName: string;
        /**
         * The ID of the server backup plan.
         */
        id: string;
        /**
         * The ID of ECS Instance.
         */
        instanceId: string;
        /**
         * Backup retention days, the minimum is 1.
         */
        retention: string;
        /**
         * Backup strategy.
         */
        schedule: string;
    }

    export interface GetServerBackupPlansPlanDetail {
        /**
         * Whether to turn on application consistency. The application consistency snapshot backs up memory data and ongoing database transactions at the time of snapshot creation to ensure the consistency of application system data and database transactions. By applying consistent snapshots, there is no data damage or loss, so as to avoid log rollback during database startup and ensure that the application is in a consistent startup state. Valid values: `true`, `false`.
         */
        appConsistent: boolean;
        /**
         * Only vaild when DoCopy is true. The destination region ID when replicating to another region. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRegionId: string;
        /**
         * Only vaild when DoCopy is true. The retention days of the destination backup. When not specified, the destination backup will be saved permanently. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRetention: number;
        /**
         * The list of cloud disks to be backed up in the ECS instance. When not specified, a snapshot is executed for all the disks on the ECS instance.
         */
        diskIdLists: string[];
        /**
         * Whether replicate to another region. Valid values: `true`, `false`.
         */
        doCopy: boolean;
        /**
         * Only the Linux system is valid. Whether to use the Linux FsFreeze mechanism to ensure that the file system is read-only consistent before creating a storage snapshot. The default is True. Valid values: `true`, `false`.
         */
        enableFsFreeze: boolean;
        /**
         * Only vaild for the linux system when AppConsistent is true. The application thaw script path (e.g. /tmp/postscript.sh). The postscript.sh script must meet the following conditions: in terms of permissions, only the root user as the owner has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        postScriptPath: string;
        /**
         * Only vaild for the linux system when AppConsistent is true. Apply the freeze script path (e.g. /tmp/prescript.sh). prescript.sh scripts must meet the following conditions: in terms of permissions, only root, as the owner, has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        preScriptPath: string;
        /**
         * Whether to turn on file system consistency. If SnapshotGroup is true, when AppConsistent is true but the relevant conditions are not met or AppConsistent is false, the resulting snapshot will be a file system consistency snapshot. The file system consistency ensures that the file system memory and disk information are synchronized at the time of snapshot creation, and the file system write operation is frozen to make the file system in a consistent state. The file system consistency snapshot can prevent the operating system from performing disk inspection and repair operations such as CHKDSK or fsck after restart. Valid values: `true`, `false`.
         */
        snapshotGroup: boolean;
        /**
         * Only the Linux system is valid, and the IO freeze timeout period. The default is 30 seconds.
         */
        timeoutInSeconds: number;
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The actual data volume of the snapshot. Unit byte.
         */
        actualBytes: string;
        /**
         * The actual number of items in the snapshot. (Currently only file backup is available).
         */
        actualItems: string;
        /**
         * Backup type. Possible values: `COMPLETE` (full backup).
         */
        backupType: string;
        /**
         * The name of OSS bucket.
         */
        bucket: string;
        /**
         * The incremental amount of backup data. Unit byte.
         */
        bytesDone: string;
        /**
         * The total amount of data sources. Unit byte.
         */
        bytesTotal: string;
        /**
         * The ID of ECS backup client.
         */
        clientId: string;
        /**
         * The time when the snapshot completed. UNIX time in seconds.
         */
        completeTime: string;
        /**
         * File System Creation Time of Nas. Unix Time Seconds.
         */
        createTime: string;
        /**
         * Snapshot creation time. UNIX time in seconds.
         */
        createdTime: string;
        errorFile: string;
        /**
         * The ID of NAS File system.
         */
        fileSystemId: string;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * The number of backup items. (Currently only file backup is available).
         */
        itemsDone: string;
        /**
         * The total number of data source items. (Currently only file backup is available).
         */
        itemsTotal: string;
        /**
         * The job ID of backup task.
         */
        jobId: string;
        /**
         * The hashcode of parent backup snapshot.
         */
        parentSnapshotHash: string;
        /**
         * Backup Path.
         */
        path: string;
        /**
         * Backup file prefix.
         */
        prefix: string;
        /**
         * The number of days to keep.
         */
        retention: string;
        /**
         * The hashcode of Snapshot.
         */
        snapshotHash: string;
        /**
         * The ID of the Snapshot.
         */
        snapshotId: string;
        /**
         * Data source type, optional values: `ECS_FILE`, `OSS`, `NAS`.
         */
        sourceType: string;
        /**
         * The start time of the snapshot. UNIX time in seconds.
         */
        startTime: string;
        /**
         * The status of snapshot execution. Possible values: `COMPLETE`, `PARTIAL_COMPLETE`, `FAILED`.
         */
        status: string;
        /**
         * The update time of snapshot. UNIX time in seconds.
         */
        updatedTime: string;
    }

    export interface GetVaultsVault {
        /**
         * The name of the OSS bucket of the Vault.
         */
        bucketName: string;
        /**
         * The amount of backup data. The unit is Byte.
         */
        bytesDone: string;
        /**
         * The creation time of the Vault. UNIX time in seconds.
         */
        createdTime: string;
        /**
         * Whether to enable the deduplication function for the database backup Vault.
         */
        dedup: boolean;
        /**
         * The description of the vault.
         */
        description: string;
        /**
         * The ID of vault.
         */
        id: string;
        /**
         * Index available.
         */
        indexAvailable: boolean;
        /**
         * Index level.
         */
        indexLevel: string;
        /**
         * Index update time.
         */
        indexUpdateTime: string;
        /**
         * The time of the last remote backup synchronization.
         */
        latestReplicationTime: string;
        /**
         * Billing model, possible values:
         */
        paymentType: string;
        /**
         * Whether it is a remote backup warehouse. It's a boolean value.
         */
        replication: boolean;
        /**
         * The region ID to which the remote backup Vault belongs.
         */
        replicationSourceRegionId: string;
        /**
         * The source vault ID of the remote backup Vault.
         */
        replicationSourceVaultId: string;
        /**
         * Warehouse-level data retention days, only valid for archive libraries.
         */
        retention: string;
        /**
         * Whether to enable the backup search function.
         */
        searchEnabled: boolean;
        sourceTypes: string[];
        /**
         * The status of Vault. Valid values: `CREATED`, `ERROR`, `UNKNOWN`.
         */
        status: string;
        /**
         * Backup vault storage usage. The unit is Byte.
         */
        storageSize: string;
        /**
         * The update time of the Vault. UNIX time in seconds.
         */
        updatedTime: string;
        /**
         * The ID of vault, same as `id`.
         */
        vaultId: string;
        /**
         * The name of vault.
         */
        vaultName: string;
        /**
         * Error status information of Vault. Only valid for remote backup warehouses. Only the remote backup warehouse is valid.
         */
        vaultStatusMessage: string;
        /**
         * The storage class of vault. Valid values: `STANDARD`.
         */
        vaultStorageClass: string;
        /**
         * The type of Vault. Valid values: `STANDARD`,`OTS_BACKUP`.
         */
        vaultType: string;
    }

    export interface OtsBackupPlanOtsDetail {
        /**
         * The names of the destination tables in the Tablestore instance. **Note:** Required while sourceType equals `OTS_TABLE`.
         */
        tableNames?: string[];
    }

    export interface OtsBackupPlanRule {
        /**
         * Backup type. Valid values: `COMPLETE`.
         */
        backupType?: string;
        /**
         * Whether to disable the backup task. Valid values: `true`, `false`. Default values: `false`.
         */
        disabled?: boolean;
        /**
         * Backup retention days, the minimum is 1.
         */
        retention?: string;
        /**
         * The name of the backup rule.**Note:** Required while sourceType equals `OTS_TABLE`. `ruleName` should be unique for the specific user.
         */
        ruleName?: string;
        /**
         * Backup strategy. Optional format: `I|{startTime}|{interval}`. It means to execute a backup task every `{interval}` starting from `{startTime}`. The backup task for the elapsed time will not be compensated. If the last backup task has not completed yet, the next backup task will not be triggered.
         */
        schedule?: string;
    }

    export interface RestoreJobOtsDetail {
        /**
         * Whether to overwrite the existing table storage recovery task. Valid values: `true`, `false`.
         */
        overwriteExisting: boolean;
    }

    export interface ServerBackupPlanDetail {
        /**
         * Whether to turn on application consistency. The application consistency snapshot backs up memory data and ongoing database transactions at the time of snapshot creation to ensure the consistency of application system data and database transactions. By applying consistent snapshots, there is no data damage or loss, so as to avoid log rollback during database startup and ensure that the application is in a consistent startup state. Valid values: `true`, `false`.
         */
        appConsistent: boolean;
        /**
         * Only vaild when DoCopy is true. The destination region ID when replicating to another region. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRegionId?: string;
        /**
         * Only vaild when DoCopy is true. The retention days of the destination backup. When not specified, the destination backup will be saved permanently. **Note:** Once you set a value of this property, you cannot set it to an empty string anymore.
         */
        destinationRetention?: number;
        /**
         * The list of cloud disks to be backed up in the ECS instance. When not specified, a snapshot is executed for all the disks on the ECS instance.
         */
        diskIdLists?: string[];
        /**
         * Whether replicate to another region. Valid values: `true`, `false`.
         */
        doCopy?: boolean;
        /**
         * Only the Linux system is valid. Whether to use the Linux FsFreeze mechanism to ensure that the file system is read-only consistent before creating a storage snapshot. The default is True. Valid values: `true`, `false`.
         */
        enableFsFreeze?: boolean;
        /**
         * Only vaild for the linux system when AppConsistent is true. The application thaw script path (e.g. /tmp/postscript.sh). The postscript.sh script must meet the following conditions: in terms of permissions, only the root user as the owner has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        postScriptPath?: string;
        /**
         * Only vaild for the linux system when AppConsistent is true. Apply the freeze script path (e.g. /tmp/prescript.sh). prescript.sh scripts must meet the following conditions: in terms of permissions, only root, as the owner, has read, write, and execute permissions, that is, 700 permissions. In terms of content, the script content needs to be customized according to the application itself. This indicates that this parameter must be set when creating an application consistency snapshot for a Linux instance. If the script is set incorrectly (for example, permissions, save path, or file name are set incorrectly), the resulting snapshot is a file system consistency snapshot.
         */
        preScriptPath?: string;
        /**
         * Whether to turn on file system consistency. If SnapshotGroup is true, when AppConsistent is true but the relevant conditions are not met or AppConsistent is false, the resulting snapshot will be a file system consistency snapshot. The file system consistency ensures that the file system memory and disk information are synchronized at the time of snapshot creation, and the file system write operation is frozen to make the file system in a consistent state. The file system consistency snapshot can prevent the operating system from performing disk inspection and repair operations such as CHKDSK or fsck after restart. Valid values: `true`, `false`.
         */
        snapshotGroup: boolean;
        /**
         * Only the Linux system is valid, and the IO freeze timeout period. The default is 30 seconds.
         */
        timeoutInSeconds?: number;
    }

}

export namespace imm {
    export interface GetProjectsProject {
        /**
         * The billing type. **Note:** This parameter is deprecated from 2021-04-01.
         */
        billingType: string;
        /**
         * The maximum number of requests that can be processed per second. **Note:** This parameter is deprecated from 2021-04-01.
         */
        computeUnit: number;
        /**
         * The creation time of project.
         */
        createTime: string;
        /**
         * The service address of project.
         */
        endpoint: string;
        /**
         * The ID of project.
         */
        id: string;
        /**
         * The modification time of project.
         */
        modifyTime: string;
        /**
         * The name of project.
         */
        project: string;
        /**
         * The service role authorized to the Intelligent Media Management service to access other cloud resources.
         */
        serviceRole: string;
        /**
         * The type of project.
         */
        type: string;
    }

}

export namespace imp {
    export interface AppTemplateConfigList {
        /**
         * Configuration item key. Valid values: ["config.appCallbackAuthKey","config.appCallbackUrl","config.callbackClass.live","config.callbackClass.user","config.livePullDomain","config.livePushDomain","config.multipleClientsLogin","config.regionId","config.streamChangeCallbackUrl"].
         */
        key: string;
        /**
         * Configuration item content.
         *
         * > **NOTE:**  By default, the attribute `configList` will return all of nine keys with empty value. If you want to set one or more of the key's value, you had better also set other keys, otherwise, there will be a diff.
         */
        value: string;
    }

    export interface GetAppTemplatesTemplate {
        /**
         * Apply template creator.
         */
        appTemplateCreator: string;
        /**
         * The first ID of the resource.
         */
        appTemplateId: string;
        /**
         * The name of the resource.
         */
        appTemplateName: string;
        /**
         * List of components.
         */
        componentLists: string[];
        /**
         * List of config.
         */
        configLists: outputs.imp.GetAppTemplatesTemplateConfigList[];
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * The ID of the App Template.
         */
        id: string;
        /**
         * Integration mode (Integrated SDK:paasSDK, Model Room: standardRoom).
         */
        integrationMode: string;
        /**
         * Application Template scenario, e-commerce business, classroom classroom.
         */
        scene: string;
        /**
         * SDK information.
         */
        sdkInfo: string;
        /**
         * Model room information.
         */
        standardRoomInfo: string;
        /**
         * Application template usage status.
         */
        status: string;
    }

    export interface GetAppTemplatesTemplateConfigList {
        /**
         * Config key.
         */
        key: string;
        /**
         * Config Value.
         */
        value: string;
    }

}

export namespace iot {
    export interface GetDeviceGroupsGroup {
        /**
         * The Group CreateTime.
         */
        createTime: string;
        /**
         * The Group Number of activated devices.
         */
        deviceActive: string;
        /**
         * The Group Total number of devices.
         */
        deviceCount: string;
        /**
         * The Group Number of online devices.
         */
        deviceOnline: string;
        /**
         * The Error_Message of the device group.
         */
        errorMessage: string;
        /**
         * The GroupDesc of the device group.
         */
        groupDesc: string;
        /**
         * The GroupId of the device group.
         */
        groupId: string;
        /**
         * The GroupName of the device group.
         */
        groupName: string;
        /**
         * The ID of the device group.
         */
        id: string;
        /**
         * Whether the call is successful.
         */
        success: boolean;
    }

}

export namespace kms {
    export interface GetAliasesAlias {
        /**
         * The unique identifier of the alias.
         */
        aliasName: string;
        /**
         * ID of the alias. The value is same as KMS alias_name.
         */
        id: string;
        /**
         * ID of the key.
         */
        keyId: string;
    }

    export interface GetKeyVersionsVersion {
        /**
         * Date and time when the key version was created (UTC time).
         */
        createTime: string;
        /**
         * (Removed from v1.124.4) It has been removed and using `createTime` instead.
         */
        creationDate: string;
        /**
         * ID of the KMS KeyVersion resource.
         */
        id: string;
        /**
         * The id of kms key.
         */
        keyId: string;
        /**
         * ID of the key version.
         */
        keyVersionId: string;
    }

    export interface GetKeysKey {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the key.
         */
        arn: string;
        /**
         * (Available in 1.123.1+) Specifies whether to enable automatic key rotation.
         */
        automaticRotation: string;
        /**
         * Creation date of key.
         */
        creationDate: string;
        /**
         * The owner of the key.
         */
        creator: string;
        /**
         * Deletion date of key.
         */
        deleteDate: string;
        /**
         * Description of the key.
         */
        description: string;
        /**
         * ID of the key.
         */
        id: string;
        /**
         * (Available in 1.123.1+)  ID of the key.
         */
        keyId: string;
        /**
         * (Available in 1.123.1+)  The type of the CMK.
         */
        keySpec: string;
        /**
         * (Available in 1.123.1+)  The usage of CMK.
         */
        keyUsage: string;
        /**
         * (Available in 1.123.1+)  The date and time the last rotation was performed.
         */
        lastRotationDate: string;
        /**
         * (Available in 1.123.1+)  The time and date the key material for the CMK expires.
         */
        materialExpireTime: string;
        /**
         * (Available in 1.123.1+)  The time the next rotation is scheduled for execution.
         */
        nextRotationDate: string;
        /**
         * (Available in 1.123.1+)  The source of the key material for the CMK.
         */
        origin: string;
        /**
         * (Available in 1.123.1+)  The ID of the current primary key version of the symmetric CMK.
         */
        primaryKeyVersion: string;
        /**
         * (Available in 1.123.1+)  The protection level of the CMK.
         */
        protectionLevel: string;
        /**
         * (Available in 1.123.1+)  The period of automatic key rotation.
         */
        rotationInterval: string;
        /**
         * Filter the results by status of the KMS keys. Valid values: `Enabled`, `Disabled`, `PendingDeletion`.
         */
        status: string;
    }

    export interface GetSecretVersionsVersion {
        /**
         * The secret value. Secrets Manager decrypts the stored secret value in ciphertext and returns it. (Returned when `enableDetails` is true).
         */
        secretData: string;
        /**
         * The type of the secret value. (Returned when `enableDetails` is true).
         */
        secretDataType: string;
        /**
         * The name of the secret.
         */
        secretName: string;
        /**
         * The version number of the secret value.
         */
        versionId: string;
        /**
         * Stage labels that mark the secret version.
         */
        versionStages: string[];
    }

    export interface GetSecretsSecret {
        /**
         * (Available in 1.124.0+) A mapping of tags to assign to the resource.
         */
        arn: string;
        /**
         * (Available in 1.124.0+)  The description of the secret.
         */
        description: string;
        /**
         * (Available in 1.124.0+)  The ID of the KMS CMK that is used to encrypt the secret value.
         */
        encryptionKeyId: string;
        /**
         * ID of the Kms Secret. The value is same as KMS secret_name.
         */
        id: string;
        /**
         * Schedule deletion time.
         */
        plannedDeleteTime: string;
        /**
         * (Available in 1.124.0+)  The value of the secret that you want to create.
         */
        secretData: string;
        /**
         * (Available in 1.124.0+)  The type of the secret data value.
         */
        secretDataType: string;
        /**
         * Name of the KMS Secret.
         */
        secretName: string;
        /**
         * (Available in 1.124.0+)  The type of the secret.
         */
        secretType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * (Available in 1.124.0+)  The version number of the initial version.
         */
        versionId: string;
        /**
         * (Available in 1.124.0+)  The stage labels that mark the new secret version.
         */
        versionStages: string[];
    }

}

export namespace kvstore {
    export interface GetAccountsAccount {
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The privilege of account access database.
         */
        accountPrivilege: string;
        /**
         * Privilege type of account.
         */
        accountType: string;
        /**
         * The description of account.
         */
        description: string;
        /**
         * The ID of the Account.
         */
        id: string;
        /**
         * The Id of instance in which account belongs.
         */
        instanceId: string;
        /**
         * The status of account.
         */
        status: string;
    }

    export interface GetConnectionsConnection {
        /**
         * The connection string of the instance.
         */
        connectionString: string;
        /**
         * The network type of the instance.
         */
        dbInstanceNetType: string;
        /**
         * The expiration time of the classic network address.
         */
        expiredTime: string;
        id: string;
        instanceId: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The port number of the instance.
         */
        port: string;
        /**
         * The remaining validity period of the endpoint of the classic network.
         */
        upgradeable: string;
        /**
         * The ID of the VPC where the instance is deployed.
         */
        vpcId: string;
        /**
         * The ID of the instance. It is returned only when the value of the DBInstanceNetType parameter is 2 (indicating VPC).
         */
        vpcInstanceId: string;
        /**
         * The ID of the VSwitch.
         */
        vswitchId: string;
    }

    export interface GetInstanceClassesClass {
        /**
         * KVStore available instance class.
         */
        instanceClass: string;
        price: string;
    }

    export interface GetInstanceEnginesInstanceEngine {
        /**
         * Database type. Options are `Redis`, `Memcache`. Default to `Redis`.
         */
        engine: string;
        /**
         * Database version required by the user. Value options of Redis can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/60873.htm) `EngineVersion`. Value of Memcache should be empty.
         */
        engineVersion: string;
        /**
         * The Zone to launch the KVStore instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstance {
        /**
         * The type of the architecture. Valid values: `cluster`, `standard` and `SplitRW`.
         */
        architectureType: string;
        autoRenew: boolean;
        autoRenewPeriod: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `zoneId` instead.
         */
        availabilityZone: string;
        /**
         * Instance bandwidth limit. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * Capacity of the applied ApsaraDB for the instance. Unit: MB.
         */
        capacity: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `paymentType` instead.
         */
        chargeType: string;
        /**
         * The parameter configuration of the instance.
         */
        config: {[key: string]: any};
        /**
         * Instance connection domain (only Intranet access supported).
         */
        connectionDomain: string;
        /**
         * The connection mode of the instance.
         */
        connectionMode: string;
        /**
         * IIt has been deprecated from provider version 1.101.0 and `maxConnections` instead.
         */
        connections: number;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The name of the instance.
         */
        dbInstanceName: string;
        /**
         * The time when the instance was destroyed.
         */
        destroyTime: string;
        /**
         * Expiration time. Pay-As-You-Go instances are never expire.
         */
        endTime: string;
        /**
         * The engine version. Valid values: `2.8`, `4.0`, `5.0`, `6.0`, `7.0`.
         */
        engineVersion: string;
        /**
         * It has been deprecated from provider version 1.101.0 and `endTime` instead.
         */
        expireTime: string;
        /**
         * Indicates whether there was an order of renewal with configuration change that had not taken effect.
         */
        hasRenewChangeOrder: boolean;
        /**
         * The ID of the instance.
         */
        id: string;
        /**
         * Type of the applied ApsaraDB for Redis instance. For more information, see [Instance type table](https://www.alibabacloud.com/help/doc-detail/61135.htm).
         */
        instanceClass: string;
        instanceReleaseProtection: boolean;
        /**
         * The engine type of the KVStore DBInstance. Options are `Memcache`, and `Redis`. If no value is specified, all types are returned.
         */
        instanceType: string;
        /**
         * Indicates whether the instance is managed by Relational Database Service (RDS).
         */
        isRds: boolean;
        maintainEndTime: string;
        maintainStartTime: string;
        /**
         * Instance connection quantity limit. Unit: count.
         */
        maxConnections: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `dbInstanceName` instead.
         */
        name: string;
        /**
         * The type of the network. Valid values: `CLASSIC`, `VPC`.
         */
        networkType: string;
        /**
         * The node type of the instance.
         */
        nodeType: string;
        /**
         * The type of the package.
         */
        packageType: string;
        /**
         * The payment type. Valid values: `PostPaid`, `PrePaid`.
         */
        paymentType: string;
        /**
         * The service port of the instance.
         */
        port: number;
        /**
         * Private IP address of the instance.
         */
        privateIp: string;
        /**
         * The queries per second (QPS) supported by the instance.
         */
        qps: number;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * The logical ID of the replica instance.
         */
        replacateId: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The name of the instance.
         */
        searchKey: string;
        /**
         * (Optional, Available in 1.128.0+) The ID of the secondary zone to which you want to migrate the ApsaraDB for Redis instance.
         */
        secondaryZoneId: string;
        securityGroupId: string;
        securityIpGroupAttribute: string;
        securityIpGroupName: string;
        securityIps: string[];
        sslEnable: string;
        /**
         * The status of the KVStore DBInstance. Valid values: `Changing`, `CleaningUpExpiredData`, `Creating`, `Flushing`, `HASwitching`, `Inactive`, `MajorVersionUpgrading`, `Migrating`, `NetworkModifying`, `Normal`, `Rebooting`, `SSLModifying`, `Transforming`, `ZoneMigrating`.
         */
        status: string;
        /**
         * Query the instance bound to the tag. The format of the incoming value is `json` string, including `TagKey` and `TagValue`. `TagKey` cannot be null, and `TagValue` can be empty. Format example `{"key1":"value1"}`.
         */
        tags: {[key: string]: any};
        /**
         * The username of the instance.
         */
        userName: string;
        vpcAuthMode: string;
        /**
         * Connection port of the instance.
         */
        vpcCloudInstanceId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Used to retrieve instances belong to specified `vswitch` resources.
         */
        vswitchId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceParameter {
        name: string;
        value: string;
    }

}

export namespace lindorm {
    export interface GetInstancesInstance {
        /**
         * AutoRenew.
         */
        autoRenew: string;
        /**
         * The cold storage capacity of the instance. Unit: GB.
         */
        coldStorage: number;
        /**
         * The creation date of Instance.
         */
        createTime: string;
        /**
         * The deletion protection of instance.
         */
        deletionProection: boolean;
        /**
         * The disk type of instance. Valid values: `capacityCloudStorage`, `cloudEfficiency`, `cloudEssd`, `cloudSsd`.
         */
        diskCategory: string;
        /**
         * The usage of disk.
         */
        diskUsage: string;
        /**
         * The threshold of disk.
         */
        diskWarningThreshold: string;
        /**
         * The type of Instance engine .
         */
        engineType: number;
        /**
         * The expiration time of Instance.
         */
        expiredTime: string;
        /**
         * The count of file engine.
         */
        fileEngineNodeCount: number;
        /**
         * The specification of file engine. Valid values: `lindorm.c.xlarge`.
         */
        fileEngineSpecification: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The storage capacity of the instance. Unit: GB. For example, the value 50 indicates 50 GB.
         */
        instanceStorage: string;
        /**
         * The ip white list of instance.
         */
        ipWhiteLists: string[];
        /**
         * The count of lindorm tunnel service.
         */
        ltsNodeCount: number;
        /**
         * The specification of lindorm tunnel service. Valid values: `lindorm.g.2xlarge`, `lindorm.g.xlarge`.
         */
        ltsNodeSpecification: string;
        /**
         * Instance network type, enumerative.VPC.
         */
        networkType: string;
        /**
         * The billing method. Valid values: `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * The count of phoenix.
         */
        phoenixNodeCount: number;
        /**
         * The specification of phoenix. Valid values: `lindorm.c.2xlarge`, `lindorm.c.4xlarge`, `lindorm.c.8xlarge`, `lindorm.c.xlarge`, `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        phoenixNodeSpecification: string;
        /**
         * The owner id of resource.
         */
        resourceOwnerId: string;
        /**
         * The count of search engine.
         */
        searchEngineNodeCount: number;
        /**
         * The specification of search engine. Valid values: `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        searchEngineSpecification: string;
        /**
         * The service type of Instance, Valid values:  `lindorm`, `serverlessLindorm`, `lindormStandalone`.
         */
        serviceType: string;
        /**
         * The status of Instance, enumerative: Valid values: `ACTIVATION`, `DELETED`, `CREATING`, `CLASS_CHANGING`, `LOCKED`, `INSTANCE_LEVEL_MODIFY`, `NET_MODIFYING`, `RESIZING`, `RESTARTING`, `MINOR_VERSION_TRANSING`.
         */
        status: string;
        /**
         * The count of table engine.
         */
        tableEngineNodeCount: number;
        /**
         * The specification of  table engine. Valid values: `lindorm.c.2xlarge`, `lindorm.c.4xlarge`, `lindorm.c.8xlarge`, `lindorm.c.xlarge`, `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        tableEngineSpecification: string;
        /**
         * The count of time series engine.
         */
        timeSeriesEngineNodeCount: number;
        /**
         * The specification of time series engine. Valid values: `lindorm.g.2xlarge`, `lindorm.g.4xlarge`, `lindorm.g.8xlarge`, `lindorm.g.xlarge`.
         */
        timeSeriresEngineSpecification: string;
        /**
         * The ID of the virtual private cloud (VPC) that is connected to the instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

}

export namespace log {
    export interface AlertAnnotation {
        /**
         * Annotations's key for new alert.
         */
        key: string;
        /**
         * Annotations's value for new alert.
         */
        value: string;
    }

    export interface AlertGroupConfiguration {
        fields?: string[];
        /**
         * including FixedRate,Hourly,Daily,Weekly,Cron.
         */
        type: string;
    }

    export interface AlertJoinConfiguration {
        /**
         * Join condition.
         */
        condition: string;
        /**
         * including FixedRate,Hourly,Daily,Weekly,Cron.
         */
        type: string;
    }

    export interface AlertLabel {
        /**
         * Annotations's key for new alert.
         */
        key: string;
        /**
         * Annotations's value for new alert.
         */
        value: string;
    }

    export interface AlertNotificationList {
        /**
         * Notice content of alarm.
         */
        content: string;
        /**
         * Email address list.
         */
        emailLists?: string[];
        /**
         * SMS sending mobile number.
         */
        mobileLists?: string[];
        /**
         * Request address.
         */
        serviceUri?: string;
        /**
         * including FixedRate,Hourly,Daily,Weekly,Cron.
         */
        type: string;
    }

    export interface AlertPolicyConfiguration {
        /**
         * Action Policy Id.
         */
        actionPolicyId?: string;
        /**
         * Alert Policy Id.
         */
        alertPolicyId: string;
        /**
         * Repeat interval used by alert policy, 1h, 1m.e.g.
         */
        repeatInterval: string;
    }

    export interface AlertQueryList {
        /**
         * Chart title, optional from 1.161.0+.
         */
        chartTitle?: string;
        /**
         * Query dashboard id.
         */
        dashboardId?: string;
        /**
         * End time. example: 20s.
         */
        end: string;
        /**
         * Query logstore, use store for new alert, Deprecated from 1.161.0+.
         *
         * @deprecated Deprecated from 1.161.0+, use store
         */
        logstore?: string;
        /**
         * default disable, whether to use power sql. support auto, enable, disable.
         */
        powerSqlMode?: string;
        /**
         * Query project.
         */
        project?: string;
        /**
         * Query corresponding to chart. example: * AND aliyun.
         */
        query: string;
        /**
         * Query project region.
         */
        region?: string;
        /**
         * Query project store's ARN.
         */
        roleArn?: string;
        /**
         * Begin time. example: -60s.
         */
        start: string;
        /**
         * Query store for new alert.
         */
        store?: string;
        /**
         * Query store type for new alert, including log,metric,meta.
         */
        storeType?: string;
        /**
         * default Custom. No need to configure this parameter.
         */
        timeSpanType?: string;
    }

    export interface AlertSchedule {
        /**
         * Cron expression when type is Cron.
         */
        cronExpression?: string;
        /**
         * Day of week when type is Weekly, including 0,1,2,3,4,5,6, 0 for Sunday, 1 for Monday
         */
        dayOfWeek?: number;
        delay?: number;
        /**
         * Hour of day when type is Weekly/Daily.
         */
        hour?: number;
        /**
         * Execution interval. 60 seconds minimum, such as 60s, 1h. used when type is FixedRate.
         */
        interval?: string;
        runImmediately?: boolean;
        /**
         * Time zone for schedule.
         */
        timeZone?: string;
        /**
         * including FixedRate,Hourly,Daily,Weekly,Cron.
         */
        type: string;
    }

    export interface AlertSeverityConfiguration {
        /**
         * Severity when this condition is met.
         */
        evalCondition: {[key: string]: string};
        /**
         * Severity for new alert, including 2,4,6,8,10 for Report,Low,Medium,High,Critical.
         */
        severity: number;
    }

    export interface AlertTemplateConfiguration {
        /**
         * Alert template annotations.
         */
        annotations?: {[key: string]: string};
        /**
         * Alert template id.
         */
        id: string;
        /**
         * Alert template language including `cn`, `en`.
         */
        lang?: string;
        /**
         * Alert template tokens.
         */
        tokens?: {[key: string]: string};
        /**
         * including FixedRate,Hourly,Daily,Weekly,Cron.
         */
        type: string;
    }

    export interface EtlEtlSink {
        /**
         * Delivery target logstore access key id.
         */
        accessKeyId?: string;
        /**
         * Delivery target logstore access key secret.
         */
        accessKeySecret?: string;
        /**
         * Delivery target logstore region.
         */
        endpoint: string;
        /**
         * An KMS encrypts access key id used to a log etl job. If the `accessKeyId` is filled in, this field will be ignored.
         */
        kmsEncryptedAccessKeyId?: string;
        /**
         * An KMS encrypts access key secret used to a log etl job. If the `accessKeySecret` is filled in, this field will be ignored.
         */
        kmsEncryptedAccessKeySecret?: string;
        /**
         * Delivery target logstore.
         */
        logstore: string;
        /**
         * Delivery target name.
         */
        name: string;
        /**
         * The project where the target logstore is delivered.
         */
        project: string;
        /**
         * Sts role info under delivery target logstore. `roleArn` and `(access_key_id, access_key_secret)` fill in at most one. If you do not fill in both, then you must fill in `(kms_encrypted_access_key_id, kms_encrypted_access_key_secret, kms_encryption_access_key_id_context, kms_encryption_access_key_secret_context)` to use KMS to get the key pair.
         */
        roleArn?: string;
        /**
         * ETL sinks type, the default value is AliyunLOG.
         *
         * > **Note:** `fromTime` and `toTime` no modification allowed after successful creation.
         */
        type?: string;
    }

    export interface GetProjectsProject {
        /**
         * The description of the project.
         */
        description: string;
        /**
         * The ID of the project.
         */
        id: string;
        /**
         * The last modify time of project.
         */
        lastModifyTime: string;
        /**
         * The owner of project.
         */
        owner: string;
        /**
         * The policy of project.
         */
        policy: string;
        /**
         * The name of the project.
         */
        projectName: string;
        /**
         * The region of project.
         */
        region: string;
        /**
         * The status of project.
         */
        status: string;
    }

    export interface GetStoresStore {
        /**
         * The ID of the store.
         */
        id: string;
        /**
         * The name of the store.
         */
        storeName: string;
    }

    export interface OssExportConfigColumn {
        /**
         * The name of the key.
         */
        name: string;
        /**
         * Type of configuration name.
         */
        type: string;
    }

    export interface OssShipperParquetConfig {
        name: string;
        type: string;
    }

    export interface StoreEncryptConf {
        /**
         * enable encryption. Default `false`
         */
        enable?: boolean;
        /**
         * Supported encryption type, only supports `default(AES)`,` m4`
         */
        encryptType?: string;
        /**
         * User bring your own key (BYOK) encryption [Refer to details](https://www.alibabacloud.com/help/zh/doc-detail/187853.htm), the format is as follows:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         * #### Block user_cmk_info
         */
        userCmkInfo?: outputs.log.StoreEncryptConfUserCmkInfo;
    }

    export interface StoreEncryptConfUserCmkInfo {
        /**
         * role arn.
         */
        arn: string;
        /**
         * User master key id.
         */
        cmkKeyId: string;
        /**
         * Region id where the  user master key id is located.
         */
        regionId: string;
    }

    export interface StoreIndexFieldSearch {
        /**
         * The alias of one field.
         */
        alias?: string;
        /**
         * Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        caseSensitive?: boolean;
        /**
         * Whether to enable field analytics. Default to true.
         */
        enableAnalytics?: boolean;
        /**
         * Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        includeChinese?: boolean;
        /**
         * Use nested index when type is json
         */
        jsonKeys?: outputs.log.StoreIndexFieldSearchJsonKey[];
        /**
         * When using the jsonKeys field, this field is required.
         */
        name: string;
        /**
         * The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
         */
        token?: string;
        /**
         * The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
         */
        type?: string;
    }

    export interface StoreIndexFieldSearchJsonKey {
        /**
         * The alias of one field.
         */
        alias?: string;
        /**
         * Whether to enable statistics. default to true.
         *
         * > **Note:** At least one of the "fullText" and "fieldSearch" should be specified.
         */
        docValue?: boolean;
        /**
         * When using the jsonKeys field, this field is required.
         */
        name: string;
        /**
         * The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
         */
        type?: string;
    }

    export interface StoreIndexFullText {
        /**
         * Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        caseSensitive?: boolean;
        /**
         * Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        includeChinese?: boolean;
        /**
         * The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
         */
        token?: string;
    }

    export interface StoreShard {
        /**
         * The begin value of the shard range(MD5), included in the shard range.
         */
        beginKey: string;
        /**
         * The end value of the shard range(MD5), not included in shard range.
         */
        endKey: string;
        /**
         * The ID of the shard.
         */
        id: number;
        /**
         * Shard status, only two status of `readwrite` and `readonly`.
         */
        status: string;
    }

}

export namespace marketplace {
    export interface GetProductProduct {
        /**
         * The code of the product.
         */
        code: string;
        /**
         * The description of the product.
         */
        description: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * A list of one element containing sku attributes of an object. Each element contains the following attributes:
         */
        skuses: outputs.marketplace.GetProductProductSkus[];
    }

    export interface GetProductProductSkus {
        /**
         * The list of custom ECS images, Each element contains the following attributes:
         */
        images: outputs.marketplace.GetProductProductSkusImage[];
        /**
         * The list of package version details of this product sku, Each element contains the following attributes:
         */
        packageVersions: outputs.marketplace.GetProductProductSkusPackageVersion[];
        /**
         * The sku code of this product sku.
         */
        skuCode: string;
        /**
         * The sku name of this product sku.
         */
        skuName: string;
    }

    export interface GetProductProductSkusImage {
        /**
         * The Ecs image id.
         */
        imageId: string;
        /**
         * The Ecs image display name.
         */
        imageName: string;
        /**
         * The Ecs image region.
         */
        regionId: string;
    }

    export interface GetProductProductSkusPackageVersion {
        /**
         * The package name of this product sku package.
         */
        packageName: string;
        /**
         * The package version of this product sku package. Currently, the API products can return package_version, but others can not for ensure.
         */
        packageVersion: string;
    }

    export interface GetProductsProduct {
        /**
         * The Category ID of products. For more information, see [DescribeProducts](https://help.aliyun.com/document_detail/89834.htm).
         */
        categoryId: number;
        /**
         * The code of the product.
         */
        code: string;
        /**
         * The delivery date of the product.
         */
        deliveryDate: string;
        /**
         * The delivery way of the product.
         */
        deliveryWay: string;
        /**
         * The image URL of the product.
         */
        imageUrl: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * The operation system of the product.
         */
        operationSystem: string;
        /**
         * The rating information of the product.
         */
        score: string;
        /**
         * The short description of the product.
         */
        shortDescription: string;
        /**
         * The suggested price of the product.
         */
        suggestedPrice: string;
        /**
         * The supplier id of the product.
         */
        supplierId: number;
        /**
         * The supplier name of the product.
         */
        supplierName: string;
        /**
         * The tags of the product.
         */
        tags: string;
        /**
         * The detail page URL of the product.
         */
        targetUrl: string;
        /**
         * The warranty date of the product.
         */
        warrantyDate: string;
    }

}

export namespace maxcompute {
    export interface GetProjectsProject {
        comment: string;
        /**
         * Default Computing Resource Group
         */
        defaultQuota: string;
        /**
         * Project ID. The value is the same as `projectName`.
         */
        id: string;
        /**
         * IP whitelist
         */
        ipWhiteList: outputs.maxcompute.GetProjectsProjectIpWhiteList;
        /**
         * Project owner
         */
        owner: string;
        /**
         * The name of the resource
         */
        projectName: string;
        /**
         * Project base attributes
         */
        properties: outputs.maxcompute.GetProjectsProjectProperties;
        /**
         * Security-related attributes
         */
        securityProperties: outputs.maxcompute.GetProjectsProjectSecurityProperties;
        /**
         * The status of the resource
         */
        status: string;
        /**
         * Project type
         */
        type: string;
    }

    export interface GetProjectsProjectIpWhiteList {
        /**
         * Classic network IP white list.
         */
        ipList: string;
        /**
         * VPC network whitelist.
         */
        vpcIpList: string;
    }

    export interface GetProjectsProjectProperties {
        /**
         * Whether to allow full table scan.
         */
        allowFullScan: boolean;
        /**
         * Whether to turn on Decimal2.0.
         */
        enableDecimal2: boolean;
        /**
         * Whether encryption is turned on.
         */
        encryption: outputs.maxcompute.GetProjectsProjectPropertiesEncryption;
        /**
         * Job default retention time.
         */
        retentionDays: string;
        /**
         * SQL charge limit.
         */
        sqlMeteringMax: string;
        /**
         * Life cycle of tables.
         */
        tableLifecycle: outputs.maxcompute.GetProjectsProjectPropertiesTableLifecycle;
        /**
         * Project time zone.
         */
        timezone: string;
        /**
         * Type system.
         */
        typeSystem: string;
    }

    export interface GetProjectsProjectPropertiesEncryption {
        /**
         * Algorithm.
         */
        algorithm: string;
        /**
         * Whether to open.
         */
        enable: boolean;
        /**
         * Encryption algorithm key.
         */
        key: string;
    }

    export interface GetProjectsProjectPropertiesTableLifecycle {
        /**
         * Project type
         */
        type: string;
        /**
         * The value of the life cycle.
         */
        value: string;
    }

    export interface GetProjectsProjectSecurityProperties {
        /**
         * Whether to enable download permission check.
         */
        enableDownloadPrivilege: boolean;
        /**
         * Label authorization.
         */
        labelSecurity: boolean;
        /**
         * Project creator permissions.
         */
        objectCreatorHasAccessPermission: boolean;
        /**
         * Does the project creator have authorization rights.
         */
        objectCreatorHasGrantPermission: boolean;
        /**
         * Project protection.
         */
        projectProtection: outputs.maxcompute.GetProjectsProjectSecurityPropertiesProjectProtection;
        /**
         * Whether to turn on ACL.
         */
        usingAcl: boolean;
        /**
         * Whether to enable Policy.
         */
        usingPolicy: boolean;
    }

    export interface GetProjectsProjectSecurityPropertiesProjectProtection {
        /**
         * Exclusion policy.
         */
        exceptionPolicy: string;
        /**
         * Is it turned on.
         */
        protected: boolean;
    }

    export interface ProjectIpWhiteList {
        /**
         * Classic network IP white list.
         */
        ipList?: string;
        /**
         * VPC network whitelist.
         */
        vpcIpList?: string;
    }

    export interface ProjectProperties {
        /**
         * Whether to allow full table scan.
         */
        allowFullScan: boolean;
        /**
         * Whether to turn on Decimal2.0.
         */
        enableDecimal2: boolean;
        /**
         * Whether encryption is turned on.See the following `Block Encryption`.
         */
        encryption: outputs.maxcompute.ProjectPropertiesEncryption;
        /**
         * Job default retention time.
         */
        retentionDays: number;
        /**
         * SQL charge limit.
         */
        sqlMeteringMax: string;
        /**
         * Life cycle of tables.See the following `Block TableLifecycle`.
         */
        tableLifecycle: outputs.maxcompute.ProjectPropertiesTableLifecycle;
        /**
         * Project time zone.
         */
        timezone: string;
        /**
         * Type system.
         */
        typeSystem: string;
    }

    export interface ProjectPropertiesEncryption {
        /**
         * Algorithm.
         */
        algorithm: string;
        /**
         * Whether to open.
         */
        enable: boolean;
        /**
         * Encryption algorithm key.
         */
        key: string;
    }

    export interface ProjectPropertiesTableLifecycle {
        /**
         * Life cycle type.
         */
        type: string;
        /**
         * The value of the life cycle.
         */
        value: string;
    }

    export interface ProjectSecurityProperties {
        /**
         * Whether to enable download permission check.
         */
        enableDownloadPrivilege: boolean;
        /**
         * Label authorization.
         */
        labelSecurity: boolean;
        /**
         * Project creator permissions.
         */
        objectCreatorHasAccessPermission: boolean;
        /**
         * Does the project creator have authorization rights.
         */
        objectCreatorHasGrantPermission: boolean;
        /**
         * Project protection.See the following `Block ProjectProtection`.
         */
        projectProtection: outputs.maxcompute.ProjectSecurityPropertiesProjectProtection;
        /**
         * Whether to turn on ACL.
         */
        usingAcl: boolean;
        /**
         * Whether to enable Policy.
         */
        usingPolicy: boolean;
    }

    export interface ProjectSecurityPropertiesProjectProtection {
        /**
         * Exclusion policy.
         */
        exceptionPolicy: string;
        /**
         * Is it turned on.
         */
        protected: boolean;
    }

}

export namespace message {
    export interface GetServiceQueuesQueue {
        /**
         * The total number of messages that are in the Active state in the queue. The value is an approximate number.
         */
        activeMessages: number;
        /**
         * The time when the queue was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
         */
        createTime: number;
        /**
         * The total number of the messages that are in the Delayed state in the queue. The value is an approximate number.
         */
        delayMessages: number;
        /**
         * The delay period after which all messages that are sent to the queue can be consumed. Unit: seconds.
         */
        delaySeconds: number;
        /**
         * The ID of the Queue. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The total number of the messages that are in the Inactive state in the queue. The value is an approximate number.
         */
        inactiveMessages: number;
        /**
         * The time when the queue was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
         */
        lastModifyTime: number;
        /**
         * Indicates whether the log management feature is enabled for the queue.
         */
        loggingEnabled: boolean;
        /**
         * The maximum size of a message body that can be sent to the queue. Unit: bytes.
         */
        maximumMessageSize: number;
        /**
         * The maximum period for which a message can be retained in the queue. A message that is sent to the queue can be retained for a specified period. After the specified period ends, the message is deleted no matter whether it is consumed. Unit: seconds.
         */
        messageRetentionPeriod: number;
        /**
         * The maximum period for which a ReceiveMessage request waits if no message is available in the queue. Unit: seconds.
         */
        pollingWaitSeconds: number;
        /**
         * The internal url of the queue.
         */
        queueInternalUrl: string;
        /**
         * The name of the queue.
         */
        queueName: string;
        /**
         * The url of the queue.
         */
        queueUrl: string;
        /**
         * The invisibility period for which the received message remains the Inactive state. Unit: seconds.
         */
        visibilityTimeout: number;
    }

    export interface GetServiceSubscriptionsSubscription {
        /**
         * The time when the subscription was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
         */
        createTime: number;
        /**
         * The endpoint to which the messages are pushed.
         */
        endpoint: string;
        /**
         * The tag that is used to filter messages. Only the messages that are attached with the specified tag can be pushed.
         */
        filterTag: string;
        /**
         * The id of the Subscription.
         */
        id: string;
        /**
         * The time when the subscription was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
         */
        lastModifyTime: number;
        /**
         * The content format of the messages that are pushed to the endpoint.
         */
        notifyContentFormat: string;
        /**
         * The retry policy that is applied if an error occurs when MNS pushes messages to the endpoint.
         */
        notifyStrategy: string;
        /**
         * The name of the subscription.
         */
        subscriptionName: string;
        /**
         * The url of the subscription.
         */
        subscriptionUrl: string;
        /**
         * The name of the topic.
         */
        topicName: string;
        /**
         * The account ID of the topic owner.
         */
        topicOwner: string;
    }

    export interface GetServiceTopicsTopic {
        /**
         * The time when the topic was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
         */
        createTime: number;
        /**
         * The id of the Topic. Its value is same as Topic Name.
         */
        id: string;
        /**
         * The time when the topic was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
         */
        lastModifyTime: number;
        /**
         * Indicates whether the log management feature is enabled.
         */
        loggingEnabled: boolean;
        /**
         * The maximum size of a message body that can be sent to the topic. Unit: bytes.
         */
        maxMessageSize: number;
        /**
         * The number of messages in the topic.
         */
        messageCount: number;
        /**
         * The maximum period for which a message can be retained in the topic. A message that is sent to the topic can be retained for a specified period. After the specified period ends, the message is deleted no matter whether it is pushed to the specified endpoints. Unit: seconds.
         */
        messageRetentionPeriod: number;
        /**
         * The inner url of the topic.
         */
        topicInnerUrl: string;
        /**
         * The name of the topic.
         */
        topicName: string;
        /**
         * The url of the topic.
         */
        topicUrl: string;
    }

}

export namespace mhub {
    export interface GetAppsApp {
        /**
         * Application AppKey, which uniquely identifies an application when requested by the interface
         */
        appKey: string;
        /**
         * The Name of the App.
         */
        appName: string;
        /**
         * iOS application ID. Required when creating an iOS app. **NOTE:** Either `bundleId` or `packageName` must be set.
         */
        bundleId: string;
        /**
         * The CreateTime of the App.
         */
        createTime: string;
        /**
         * Base64 string of picture.
         */
        encodedIcon: string;
        /**
         * The ID of the App.
         */
        id: string;
        /**
         * The Industry ID of the app. For information about Industry and how to use it, MHUB[Industry](https://help.aliyun.com/document_detail/201638.html).
         */
        industryId: string;
        /**
         * Android App package name.  **NOTE:** Either `bundleId` or `packageName` must be set.
         */
        packageName: string;
        /**
         * The ID of the Product.
         */
        productId: string;
        /**
         * The type of the App. Valid values: `Android` and `iOS`.
         */
        type: string;
    }

    export interface GetProductsProduct {
        /**
         * The ID of the Product.
         */
        id: string;
        /**
         * The ID of the Product.
         */
        productId: string;
        /**
         * The name of the Product.
         */
        productName: string;
    }

}

export namespace mns {
    export interface GetQueuesQueue {
        /**
         * This attribute defines the length of time, in seconds, after which every message sent to the queue is dequeued.
         */
        delaySeconds: number;
        /**
         * The id of the queue, The value is set to `name`.
         */
        id: string;
        /**
         * This indicates the maximum length, in bytes, of any message body sent to the queue.
         */
        maximumMessageSize: number;
        /**
         * Messages are deleted from the queue after a specified length of time, whether they have been activated or not. This attribute defines the viability period, in seconds, for every message in the queue.
         */
        messageRetentionPeriod: number;
        /**
         * The name of the queue
         */
        name: string;
        /**
         * Long polling is measured in seconds. When this attribute is set to 0, long polling is disabled. When it is not set to 0, long polling is enabled and message dequeue requests will be processed only when valid messages are received or when long polling times out.
         */
        pollingWaitSeconds: number;
        /**
         * Dequeued messages change from active (visible) status to inactive (invisible) status. This attribute defines the length of time, in seconds, that messages remain invisible. Messages return to active status after the set period.
         */
        visibilityTimeouts: number;
    }

    export interface GetTopicSubscriptionsSubscription {
        /**
         * Describe the terminal address of the message received in this subscription.
         */
        endpoint: string;
        /**
         * A string to filter resulting messages of the topic by their message tag.
         */
        filterTag: string;
        /**
         * The ID of the topic subscription. The value is set to `name`.
         */
        id: string;
        /**
         * The name of the subscription.
         */
        name: string;
        /**
         * The NotifyContentFormat attribute of Subscription. This attribute specifies the content format of the messages pushed to users.
         */
        notifyContentFormat: string;
        /**
         * The NotifyStrategy attribute of Subscription. This attribute specifies the retry strategy when message sending fails.
         */
        notifyStrategy: string;
        /**
         * Two topics on a single account in the same region cannot have the same name. A topic name must start with an English letter or a digit, and can contain English letters, digits, and hyphens, with the length not exceeding 256 characters.
         */
        topicName: string;
    }

    export interface GetTopicsTopic {
        /**
         * The id of the topic. The value is set to `name`.
         */
        id: string;
        /**
         * Whether to enable logging.
         */
        loggingEnabled: boolean;
        /**
         * This indicates the maximum length, in bytes, of any message body sent to the topic.
         */
        maximumMessageSize: number;
        /**
         * The name of the topic.
         */
        name: string;
    }

}

export namespace mongodb {
    export interface GetAccountsAccount {
        /**
         * The description of the account.
         */
        accountDescription: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The role of the account. Valid values: `db`, `cs`, `mongos`, `logic`, `normal`.
         */
        characterType: string;
        /**
         * The ID of the Account. The value formats as `<instance_id>:<account_name>`.
         */
        id: string;
        /**
         * The id of the instance to which the account belongs.
         */
        instanceId: string;
        /**
         * The status of the account. Valid values: `Unavailable`, `Available`.
         */
        status: string;
    }

    export interface GetAuditPoliciesPolicy {
        /**
         * The status of the log audit feature.
         */
        auditStatus: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The ID of the Audit Policy.
         */
        id: string;
    }

    export interface GetInstancesInstance {
        /**
         * Instance availability zone.
         */
        availabilityZone: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        chargeType: string;
        /**
         * Creation time of the instance in RFC3339 format.
         */
        creationTime: string;
        /**
         * Database engine type. Supported option is `MongoDB`.
         */
        engine: string;
        /**
         * Database engine version.
         */
        engineVersion: string;
        /**
         * Expiration time in RFC3339 format. Pay-As-You-Go instances are never expire.
         */
        expirationTime: string;
        /**
         * The ID of the MongoDB instance.
         */
        id: string;
        /**
         * Sizing of the instance to be queried.
         */
        instanceClass: string;
        /**
         * Type of the instance to be queried. If it is set to `sharding`, the sharded cluster instances are listed. If it is set to `replicate`, replica set instances are listed. Default value `replicate`.
         */
        instanceType: string;
        /**
         * Lock status of the instance.
         */
        lockMode: string;
        /**
         * Array composed of Mongos.
         */
        mongos: outputs.mongodb.GetInstancesInstanceMongo[];
        /**
         * The name of the MongoDB instance.
         */
        name: string;
        /**
         * Classic network or VPC.
         */
        networkType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Replication factor corresponds to number of nodes. Optional values are `1` for single node and `3` for three nodes replica set.
         */
        replication: string;
        /**
         * Array composed of shards.
         */
        shards: outputs.mongodb.GetInstancesInstanceShard[];
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * Shard disk.
         */
        storage: number;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetInstancesInstanceMongo {
        /**
         * Shard instance specification.
         */
        class: string;
        /**
         * Shard instance description.
         */
        description: string;
        /**
         * Shard instance ID.
         */
        nodeId: string;
    }

    export interface GetInstancesInstanceShard {
        /**
         * Shard instance specification.
         */
        class: string;
        /**
         * Shard instance description.
         */
        description: string;
        /**
         * Shard instance ID.
         */
        nodeId: string;
        /**
         * Shard disk.
         */
        storage: number;
    }

    export interface GetServerlessInstancesInstance {
        /**
         * The read/write throughput consumed by the instance.
         */
        capacityUnit: number;
        /**
         * The db instance class.
         */
        dbInstanceClass: string;
        /**
         * The db instance description.
         */
        dbInstanceDescription: string;
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The db instance release protection.
         */
        dbInstanceReleaseProtection: boolean;
        /**
         * The db instance storage.
         */
        dbInstanceStorage: number;
        /**
         * The database engine of the instance.
         */
        engine: string;
        /**
         * The database version number. Valid values: `4.2`.
         */
        engineVersion: string;
        /**
         * The time when the subscription instance expires. The time is in the `yyyy-MM-ddTHH:mmZ` format. The time is displayed in UTC.
         */
        expireTime: string;
        /**
         * The ID of the Serverless Instance.
         */
        id: string;
        /**
         * Indicates the type of the instance. Valid values: `0`: physical machine. `1`: ECS. `2`: DOCKER. `18`: k8s new architecture instance.
         */
        kindCode: string;
        /**
         * The locked status of the instance.
         */
        lockMode: string;
        /**
         * The start time of the maintenance window. The time is in the `HH:mmZ` format. The time is displayed in UTC.
         */
        maintainEndTime: string;
        /**
         * The end time of the maintenance window. The time is in the `HH:mmZ` format. The time is displayed in UTC.
         */
        maintainStartTime: string;
        /**
         * Instance maximum connections.
         */
        maxConnections: number;
        /**
         * The maximum IOPS of the instance.
         */
        maxIops: number;
        /**
         * The network type of the instance.
         */
        networkType: string;
        /**
         * The Payment type of the instance.
         */
        paymentType: string;
        /**
         * The access protocol type of the instance. Valid values: `mongodb`, `dynamodb`.
         */
        protocolType: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The security ip list.
         */
        securityIpGroups: outputs.mongodb.GetServerlessInstancesInstanceSecurityIpGroup[];
        /**
         * The status of the instance.
         */
        status: string;
        /**
         * The storage engine used by the instance.
         */
        storageEngine: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * Intranet secret free access mode.
         */
        vpcAuthMode: string;
        /**
         * The ID of the VPC network.
         */
        vpcId: string;
        /**
         * The id of the vswitch.
         */
        vswitchId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

    export interface GetServerlessInstancesInstanceSecurityIpGroup {
        /**
         * The attribute of the IP whitelist. This parameter is empty by default.
         */
        securityIpGroupAttribute: string;
        /**
         * The name of the IP whitelist.
         */
        securityIpGroupName: string;
        /**
         * The IP addresses in the whitelist.
         */
        securityIpList: string;
    }

    export interface GetShardingNetworkPrivateAddressesAddress {
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The remaining duration of the classic network address. Unit: `seconds`.
         */
        expiredTime: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The endpoint of the instance.
         */
        networkAddress: string;
        /**
         * The type of the network.
         */
        networkType: string;
        /**
         * The ID of the `mongos`, `shard`, or `Configserver` node in the sharded cluster instance.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The port number.
         */
        port: string;
        /**
         * The role of the node.
         */
        role: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vSwitch ID of the VPC.
         */
        vswitchId: string;
    }

    export interface GetShardingNetworkPublicAddressesAddress {
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The remaining duration of the classic network address. Unit: `seconds`.
         */
        expiredTime: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The endpoint of the instance.
         */
        networkAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The ID of the `mongos`, `shard`, or `Configserver` node in the sharded cluster instance.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The port number.
         */
        port: string;
        /**
         * The role of the node.
         */
        role: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vSwitch ID of the VPC.
         */
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceParameter {
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The value of the parameter.
         */
        value: string;
    }

    export interface InstanceReplicaSet {
        /**
         * The connection address of the node.
         */
        connectionDomain: string;
        /**
         * The connection port of the node.
         */
        connectionPort: string;
        /**
         * The network type of the instance. Valid values:`Classic` or `VPC`. Default value: `Classic`.
         */
        networkType: string;
        /**
         * The role of the node. Valid values: `Primary`,`Secondary`.
         */
        replicaSetRole: string;
        /**
         * VPC instance ID.
         */
        vpcCloudInstanceId: string;
        /**
         * The ID of the VPC. > **NOTE:** This parameter is valid only when NetworkType is set to VPC.
         */
        vpcId: string;
        /**
         * The virtual switch ID to launch DB instances in one VPC.
         */
        vswitchId: string;
    }

    export interface ServerlessInstanceSecurityIpGroup {
        /**
         * The attribute of the IP whitelist. This parameter is empty by default.
         */
        securityIpGroupAttribute?: string;
        /**
         * The name of the IP whitelist.
         */
        securityIpGroupName?: string;
        /**
         * The IP addresses in the whitelist.
         */
        securityIpList?: string;
    }

    export interface ShardingInstanceConfigServerList {
        /**
         * The connection address of the Config Server node.
         */
        connectString: string;
        /**
         * The max connections of the Config Server node.
         */
        maxConnections: number;
        /**
         * The maximum IOPS of the Config Server node.
         */
        maxIops: number;
        /**
         * The node class of the Config Server node.
         */
        nodeClass: string;
        /**
         * The description of the Config Server node.
         */
        nodeDescription: string;
        /**
         * The ID of the Config Server node.
         */
        nodeId: string;
        /**
         * The node storage of the Config Server node.
         */
        nodeStorage: number;
        /**
         * The connection port of the Config Server node.
         */
        port: number;
    }

    export interface ShardingInstanceMongoList {
        /**
         * Mongo node connection string.
         */
        connectString: string;
        /**
         * Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The ID of the mongo-node.
         */
        nodeId: string;
        /**
         * Mongo node port.
         */
        port: number;
    }

    export interface ShardingInstanceShardList {
        /**
         * Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The ID of the shard-node.
         */
        nodeId: string;
        /**
         * - Custom storage space; value range: [10, 1,000]
         * - 10-GB increments. Unit: GB.
         */
        nodeStorage: number;
        /**
         * The number of read-only nodes in shard node. Valid values: 0 to 5. Default value: 0.
         */
        readonlyReplicas: number;
    }

    export interface ShardingNetworkPrivateAddressNetworkAddress {
        /**
         * The remaining duration of the classic network address. Unit: `seconds`.
         */
        expiredTime: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The endpoint of the instance.
         */
        networkAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The ID of the Shard node or the ConfigServer node.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The port number.
         */
        port: string;
        /**
         * The role of the node.
         */
        role: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vSwitch ID of the VPC.
         */
        vswitchId: string;
    }

    export interface ShardingNetworkPublicAddressNetworkAddress {
        /**
         * The remaining duration of the classic network address. Unit: `seconds`.
         */
        expiredTime: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The endpoint of the instance.
         */
        networkAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The ID of the `mongos`, `shard`, or `Configserver` node in the sharded cluster instance.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The port number.
         */
        port: string;
        /**
         * The role of the node.
         */
        role: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The vSwitch ID of the VPC.
         */
        vswitchId: string;
    }

}

export namespace mse {
    export interface GatewaySlbList {
        /**
         * The associate id.
         */
        associateId: string;
        /**
         * The Mode of the gateway slb.
         */
        gatewaySlbMode: string;
        /**
         * The Status of the gateway slb.
         */
        gatewaySlbStatus: string;
        /**
         * The creation time of the gateway slb.
         */
        gmtCreate: string;
        /**
         * The ID of the gateway slb.
         */
        slbId: string;
        /**
         * The ip of the gateway slb.
         */
        slbIp: string;
        /**
         * The port of the gateway slb.
         */
        slbPort: string;
        /**
         * The type of the gateway slb.
         */
        type: string;
    }

    export interface GetClustersCluster {
        /**
         * The id of acl.
         */
        aclId: string;
        /**
         * The version of app.
         */
        appVersion: string;
        /**
         * ID of the MSE Cluster.
         */
        clusterId: string;
        /**
         * ID of the OOS Executions.
         */
        clusterName: string;
        /**
         * The type of MSE Cluster.
         */
        clusterType: string;
        /**
         * The num of cpu.
         */
        cpu: number;
        /**
         * The health status of MSE Cluster.
         */
        healthStatus: string;
        /**
         * ID of the MSE Cluster.
         */
        id: string;
        /**
         * Time-consuming to create.
         */
        initCostTime: number;
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * ID of the MSE Cluster.
         */
        instanceId: string;
        /**
         * The list of instances.
         */
        instanceModels: outputs.mse.GetClustersClusterInstanceModel[];
        /**
         * The address of public network.
         */
        internetAddress: string;
        /**
         * The domain of public network.
         */
        internetDomain: string;
        /**
         * The port of public network.
         */
        internetPort: string;
        /**
         * The address of private network.
         */
        intranetAddress: string;
        /**
         * The domain of private network.
         */
        intranetDomain: string;
        /**
         * The port of private network.
         */
        intranetPort: string;
        /**
         * The memory size.
         */
        memoryCapacity: number;
        /**
         * The type of payment.
         */
        payInfo: string;
        /**
         * The public network bandwidth.
         */
        pubNetworkFlow: string;
        /**
         * The status of MSE Cluster. Valid: `DESTROY_FAILED`, `DESTROY_ING`, `DESTROY_SUCCESS`, `INIT_FAILED`, `INIT_ING`, `INIT_SUCCESS`, `INIT_TIME_OUT`, `RESTART_FAILED`, `RESTART_ING`, `RESTART_SUCCESS`, `SCALE_FAILED`, `SCALE_ING`, `SCALE_SUCCESS`
         */
        status: string;
    }

    export interface GetClustersClusterInstanceModel {
        /**
         * The health status of MSE Cluster.
         */
        healthStatus: string;
        instanceType: string;
        internetIp: string;
        ip: string;
        podName: string;
        role: string;
        singleTunnelVip: string;
        vip: string;
    }

    export interface GetEngineNamespacesNamespace {
        /**
         * The Number of Configuration of the Namespace.
         */
        configCount: number;
        /**
         * The ID of the Engine Namespace. It is formatted to `<cluster_id>:<namespace_id>`.
         */
        id: string;
        /**
         * The description of the Namespace.
         */
        namespaceDesc: string;
        /**
         * The id of Namespace.
         */
        namespaceId: string;
        /**
         * The name of the Namespace.
         */
        namespaceShowName: string;
        /**
         * The Quota of the Namespace.
         */
        quota: number;
        /**
         * The number of active services.
         */
        serviceCount: string;
        /**
         * The type of the Namespace, the value is as follows:
         * - '0': Global Configuration.
         * - '1': default namespace.
         * - '2': Custom Namespace.
         */
        type: number;
    }

    export interface GetGatewaysGateway {
        /**
         * The backup vswitch id.
         */
        backupVswitchId: string;
        /**
         * The name of the Gateway.
         */
        gatewayName: string;
        /**
         * Gateway unique identification.
         */
        gatewayUniqueId: string;
        /**
         * The ID of the Gateway.
         */
        id: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * Number of Gateway Nodes.
         */
        replica: string;
        /**
         * A list of gateway Slb.
         */
        slbLists: outputs.mse.GetGatewaysGatewaySlbList[];
        /**
         * Gateway Node Specifications.
         */
        spec: string;
        /**
         * The status of the gateway.
         */
        status: string;
        /**
         * The ID of the vpc.
         */
        vpcId: string;
        /**
         * The ID of the vswitch.
         */
        vswitchId: string;
    }

    export interface GetGatewaysGatewaySlbList {
        /**
         * The associate id.
         */
        associateId: string;
        /**
         * The Mode of the gateway slb.
         */
        gatewaySlbMode: string;
        /**
         * The Status of the gateway slb.
         */
        gatewaySlbStatus: string;
        /**
         * The creation time of the gateway slb.
         */
        gmtCreate: string;
        /**
         * The ID of the gateway slb.
         */
        slbId: string;
        /**
         * The ip of the gateway slb.
         */
        slbIp: string;
        /**
         * The port of the gateway slb.
         */
        slbPort: string;
        /**
         * The type of the gateway slb.
         */
        type: string;
    }

    export interface GetZnodesZnode {
        /**
         * The ID of the Cluster.
         */
        clusterId: string;
        /**
         * The Node data.
         */
        data: string;
        /**
         * Node list information, the value is as follows:
         */
        dir: boolean;
        /**
         * The ID of the Znode. The value formats as `<cluster_id>:<path>`.
         */
        id: string;
        /**
         * The Node path.
         */
        path: string;
        /**
         * The Node name.
         */
        znodeName: string;
    }

}

export namespace nas {
    export interface GetAccessGroupsGroup {
        /**
         * The name of access group.
         */
        accessGroupName: string;
        /**
         * Filter results by a specific AccessGroupType.
         */
        accessGroupType: string;
        /**
         * Filter results by a specific Description.
         */
        description: string;
        /**
         * This ID of this AccessGroup. It is formatted to ``<access_group_id>:<file_system_type>``. Before version 1.95.0, the value is `accessGroupName`.
         */
        id: string;
        /**
         * MountTargetCount block of the AccessGroup
         */
        mountTargetCount: number;
        /**
         * RuleCount of the AccessGroup.
         */
        ruleCount: number;
        /**
         * Field `type` has been deprecated from version 1.95.0. Use `accessGroupType` instead.
         */
        type: string;
    }

    export interface GetAccessRulesRule {
        /**
         * AccessRuleId of the AccessRule.
         */
        accessRuleId: string;
        /**
         * Priority of the AccessRule.
         */
        priority: number;
        /**
         * Filter results by a specific RWAccess.
         */
        rwAccess: string;
        /**
         * Filter results by a specific SourceCidrIp.
         */
        sourceCidrIp: string;
        /**
         * Filter results by a specific UserAccess.
         */
        userAccess: string;
    }

    export interface GetAutoSnapshotPoliciesPolicy {
        /**
         * The ID of the automatic snapshot policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The name of the automatic snapshot policy.
         */
        autoSnapshotPolicyName: string;
        /**
         * The time when the automatic snapshot policy was created.
         */
        createTime: string;
        /**
         * The number of file systems to which the automatic snapshot policy applies.
         */
        fileSystemNums: number;
        /**
         * ID of the Auto Snapshot Policy.
         */
        id: string;
        /**
         * The day on which an auto snapshot was created.
         */
        repeatWeekdays: string[];
        /**
         * The number of days for which you want to retain auto snapshots.
         */
        retentionDays: number;
        /**
         * The status of the automatic snapshot policy. Valid values: `Creating`, `Available`.
         */
        status: string;
        /**
         * The point in time at which an auto snapshot was created. Unit: hours.
         */
        timePoints: string[];
    }

    export interface GetDataFlowsFlow {
        /**
         * The time when Fileset was created. Executing the ISO8601 standard means that the return format is: 'yyyy-MM-ddTHH:mm:ssZ'.
         */
        createTime: string;
        /**
         * The ID of the Data Flow.
         */
        dataFlowId: string;
        /**
         * The Description of data flow.
         */
        description: string;
        /**
         * Error message.
         */
        errorMessage: string;
        /**
         * The ID of the file system.
         */
        fileSystemId: string;
        /**
         * The path of Fileset in the CPFS file system.
         */
        fileSystemPath: string;
        /**
         * Description of automatic update.
         */
        fsetDescription: string;
        /**
         * The ID of the Fileset.
         */
        fsetId: string;
        /**
         * The resource ID of the data flow. The value formats as `<file_system_id>:<data_flow_id>`.
         */
        id: string;
        /**
         * The security protection type of the source storage.
         */
        sourceSecurityType: string;
        /**
         * The access path of the source store. Format: `<storage type>://<path>`.
         */
        sourceStorage: string;
        /**
         * The status of the Data flow.
         */
        status: string;
        /**
         * The maximum transmission bandwidth of data flow, unit: `MB/s`.
         */
        throughput: number;
    }

    export interface GetFileSystemsSystem {
        /**
         * (Optional, Available in v1.140.0+) The capacity of the file system.
         */
        capacity: number;
        /**
         * Time of creation.
         */
        createTime: string;
        /**
         * Description of the FileSystem.
         */
        description: string;
        /**
         * (Optional, Available in v1.121.2+) Whether the file system is encrypted. 
         * * Valid values:
         */
        encryptType: number;
        /**
         * The type of the file system.
         * Valid values:
         * `standard` (Default),
         * `extreme`.
         */
        fileSystemType: string;
        /**
         * ID of the FileSystem.
         */
        id: string;
        /**
         * (Optional, Available in v1.140.0+) The id of the KMS key.
         */
        kmsKeyId: string;
        /**
         * MeteredSize of the FileSystem.
         */
        meteredSize: number;
        /**
         * The protocol type of the file system.
         * Valid values:
         * `NFS`,
         * `SMB` (Available when the `fileSystemType` is `standard`).
         */
        protocolType: string;
        /**
         * ID of the region where the FileSystem is located.
         */
        regionId: string;
        /**
         * The storage type of the file system.
         * * Valid values:
         */
        storageType: string;
        /**
         * (Optional, Available in v1.140.0+) The id of the zone. Each region consists of multiple isolated locations known as zones. Each zone has an independent power supply and network.
         */
        zoneId: string;
    }

    export interface GetFilesetsFileset {
        /**
         * The time when Fileset was created.
         */
        createTime: string;
        /**
         * Description of Fileset.
         */
        description: string;
        /**
         * The ID of the file system.
         */
        fileSystemId: string;
        /**
         * The path of Fileset.
         */
        fileSystemPath: string;
        /**
         * The first ID of the resource.
         */
        filesetId: string;
        /**
         * The ID of the Fileset.
         */
        id: string;
        /**
         * The status of the fileset.
         */
        status: string;
        /**
         * The latest update time of Fileset.
         */
        updateTime: string;
    }

    export interface GetLifecyclePoliciesPolicy {
        /**
         * The time when the lifecycle management policy was created.
         */
        createTime: string;
        /**
         * The ID of the file system.
         */
        fileSystemId: string;
        /**
         * The ID of the Lifecycle Policy. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The name of the lifecycle management policy.
         */
        lifecyclePolicyName: string;
        /**
         * The rules in the lifecycle management policy.
         */
        lifecycleRuleName: string;
        /**
         * The list of absolute paths for multiple directories. In this case, you can associate a lifecycle management policy with each directory.
         */
        paths: string[];
        /**
         * The storage type of the data that is dumped to the IA storage medium.
         */
        storageType: string;
    }

    export interface GetMountTargetsTarget {
        /**
         * Filter results by a specific AccessGroupName.
         */
        accessGroupName: string;
        /**
         * ID of the MountTargetDomain.
         */
        id: string;
        /**
         * Field `mountTargetDomain` has been deprecated from provider version 1.53.0. New field `ids` replaces it.
         */
        mountTargetDomain: string;
        /**
         * Filter results by a specific NetworkType.
         */
        networkType: string;
        /**
         * Filter results by the status of mount target. Valid values: `Active`, `Inactive` and `Pending`.
         */
        status: string;
        /**
         * Field `type` has been deprecated from provider version 1.95.0. New field `networkType` replaces it.
         */
        type: string;
        /**
         * Filter results by a specific VpcId.
         */
        vpcId: string;
        /**
         * Filter results by a specific VSwitchId.
         */
        vswitchId: string;
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The type of the encryption.
         */
        encryptType: number;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The progress of the snapshot creation. The value of this parameter is expressed as a percentage.
         */
        progress: string;
        /**
         * The remaining time that is required to create the snapshot. Unit: seconds.
         */
        remainTime: number;
        /**
         * The retention period of the automatic snapshot. Unit: days.
         */
        retentionDays: number;
        /**
         * The ID of the resource.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The ID of the source file system.
         */
        sourceFileSystemId: string;
        /**
         * The capacity of the source file system. Unit: GiB.
         */
        sourceFileSystemSize: string;
        /**
         * The version of the source file system.
         */
        sourceFileSystemVersion: string;
        /**
         * The status of the snapshot.
         */
        status: string;
    }

    export interface GetZonesZone {
        /**
         * A list of instance type information collection
         */
        instanceTypes: outputs.nas.GetZonesZoneInstanceType[];
        /**
         * String to filter results by zone id.
         */
        zoneId: string;
    }

    export interface GetZonesZoneInstanceType {
        /**
         * File transfer protocol type. Valid values:
         */
        protocolType: string;
        /**
         * The storage type of the nas zones. Valid values:
         */
        storageType: string;
    }

}

export namespace nlb {
    export interface GetListenersListener {
        /**
         * ndicates whether Application-Layer Protocol Negotiation (ALPN) is enabled.
         */
        alpnEnabled: boolean;
        /**
         * The ALPN policy.
         */
        alpnPolicy: string;
        /**
         * CA certificate list information. Currently, only one CA certificate can be added. **NOTE:** This parameter only takes effect for `TCPSSL` listeners.
         */
        caCertificateIds: string[];
        /**
         * Whether to start two-way authentication.
         */
        caEnabled: boolean;
        /**
         * Server certificate list information. Currently, only one server certificate can be added. This parameter only takes effect for `TCPSSL` listeners.
         */
        certificateIds: string[];
        /**
         * The new connection speed limit for a network-based load balancing instance per second. Valid values: `0` ~ `1000000`. `0` indicates unlimited speed.
         */
        cps: number;
        /**
         * Full port listening end port. Valid values: `0` ~ `65535`. The value of the end port is less than the start port.
         */
        endPort: string;
        /**
         * The ID of the Nlb Listener.
         */
        id: string;
        /**
         * Connection idle timeout time. Unit: seconds. Valid values: `1` ~ `900`.
         */
        idleTimeout: number;
        /**
         * Custom listener name. The length is limited to 2 to 256 characters, supports Chinese and English letters, and can include numbers, commas (,), half-width periods (.), half-width semicolons (;), forward slashes (/), at(@), underscores (_), and dashes (-).
         */
        listenerDescription: string;
        /**
         * The ID of the listener.
         */
        listenerId: string;
        /**
         * Listening port. Valid values: `0` ~ `65535`. `0`: indicates that full port listening is used. When set to 0, you must configure `StartPort` and `EndPort`.
         */
        listenerPort: number;
        /**
         * The listening protocol. Valid values: `TCP`, `UDP`, or `TCPSSL`.
         */
        listenerProtocol: string;
        /**
         * The ID of the network-based server load balancer instance.
         */
        loadBalancerId: string;
        /**
         * The maximum segment size of the TCP message. Unit: Bytes. Valid values: `0` ~ `1500`. `0` indicates that the MSS value of the TCP message is not modified. only `TCP` and `TCPSSL` listeners support this field value.
         */
        mss: number;
        /**
         * Whether to enable the Proxy Protocol to carry the source address of the client to the backend server.
         */
        proxyProtocolEnabled: boolean;
        /**
         * Indicates whether fine-grained monitoring is enabled.
         */
        secSensorEnabled: boolean;
        /**
         * Security policy ID. Support system security policies and custom security policies. Valid values: `tlsCipherPolicy10`, `tlsCipherPolicy11`, `tlsCipherPolicy12`, `tlsCipherPolicy12Strict`, or `tlsCipherPolicy12StrictWith13`. **Note:** This parameter only takes effect for `TCPSSL` listeners.
         */
        securityPolicyId: string;
        /**
         * The ID of the server group.
         */
        serverGroupId: string;
        /**
         * Full Port listens to the starting port. Valid values: `0` ~ `65535`.
         */
        startPort: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetLoadBalancersBalancer {
        /**
         * The IP version.
         */
        addressIpVersion: string;
        /**
         * The type of IPv4 address used by the NLB instance.
         */
        addressType: string;
        /**
         * The ID of the EIP bandwidth plan that is associated with the NLB instance if the NLB instance uses a public IP address.
         */
        bandwidthPackageId: string;
        /**
         * The time when the resource was created. The time is displayed in UTC in `yyyy-MM-ddTHH:mm:ssZ` format.
         */
        createTime: string;
        /**
         * Indicates whether cross-zone load balancing is enabled for the NLB instance.
         */
        crossZoneEnabled: boolean;
        /**
         * The domain name of the NLB instance.
         */
        dnsName: string;
        /**
         * The ID of the NLB instance.
         */
        id: string;
        /**
         * The type of IPv6 address used by the NLB instance.
         */
        ipv6AddressType: string;
        /**
         * The business status of the NLB instance.
         */
        loadBalancerBusinessStatus: string;
        /**
         * The ID of the NLB instance.
         */
        loadBalancerId: string;
        /**
         * The name of the NLB instance.
         */
        loadBalancerName: string;
        /**
         * The type of the SLB instance. Only Network is supported, which indicates NLB.
         */
        loadBalancerType: string;
        /**
         * The configuration of the operation lock. This parameter takes effect if LoadBalancerBussinessStatus is Abnormal.
         */
        operationLocks: outputs.nlb.GetLoadBalancersBalancerOperationLock[];
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The security group to which the NLB instance belongs.
         */
        securityGroupIds: string[];
        /**
         * The status of the NLB instance.
         */
        status: string;
        /**
         * The tag of the resource.
         */
        tags?: {[key: string]: any};
        /**
         * The ID of the VPC where the NLB instance is deployed.
         */
        vpcId: string;
        /**
         * The zones and the vSwitches in the zones. An NLB instance can be deployed across 2 to 10 zones.
         */
        zoneMappings: outputs.nlb.GetLoadBalancersBalancerZoneMapping[];
    }

    export interface GetLoadBalancersBalancerOperationLock {
        /**
         * The reason why the NLB instance is locked.
         */
        lockReason: string;
        /**
         * The type of lock.
         */
        lockType: string;
    }

    export interface GetLoadBalancersBalancerZoneMapping {
        /**
         * The ID of the elastic IP address (EIP).
         */
        allocationId: string;
        /**
         * The ID of the elastic network interface (ENI) attached to the NLB instance.
         */
        eniId: string;
        /**
         * The IPv6 address of the NLB instance.
         */
        ipv6Address: string;
        /**
         * The private IPv4 address used by the NLB instance.
         */
        privateIpv4Address: string;
        /**
         * The public IPv4 address used by the NLB instance.
         */
        publicIpv4Address: string;
        /**
         * The ID of the vSwitch. By default, you can specify one vSwitch (subnet) in each zone of the NLB instance.
         */
        vswitchId: string;
        /**
         * The name of the zone.
         */
        zoneId: string;
    }

    export interface GetSecurityPoliciesPolicy {
        /**
         * The supported cipher suites, which are determined by the TLS protocol version.
         */
        ciphers: string[];
        /**
         * The id of the TLS security policy.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The name of the TLS security policy.
         */
        securityPolicyName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The TLS protocol versions that are supported.
         */
        tlsVersions: string[];
    }

    export interface GetServerGroupServerAttachmentsAttachment {
        /**
         * The description of the backend server.
         */
        description: string;
        /**
         * The ID of the server group.
         */
        id: string;
        /**
         * The port used by the backend server.
         */
        port: number;
        /**
         * The ID of the server group.
         */
        serverGroupId: string;
        /**
         * The ID of the server.
         */
        serverId: string;
        /**
         * The IP address of the backend server.
         */
        serverIp: string;
        /**
         * The type of the backend server.
         */
        serverType: string;
        /**
         * Indicates the status of the backend server.
         */
        status: string;
        /**
         * The weight of the backend server.
         */
        weight: number;
        /**
         * The zone ID of the server.
         */
        zoneId: string;
    }

    export interface GetServerGroupsGroup {
        /**
         * The protocol version.
         */
        addressIpVersion: string;
        /**
         * Indicates whether connection draining is enabled.
         */
        connectionDrain: boolean;
        /**
         * The timeout period of connection draining. Unit: seconds.
         */
        connectionDrainTimeout: number;
        /**
         * The configurations of health checks.
         */
        healthChecks: outputs.nlb.GetServerGroupsGroupHealthCheck[];
        /**
         * The ID of the Server Group.
         */
        id: string;
        /**
         * Indicates whether client address retention is enabled.
         */
        preserveClientIpEnabled: boolean;
        /**
         * The protocol used to forward requests to the backend servers.
         */
        protocol: string;
        /**
         * The NLB instance.
         */
        relatedLoadBalancerIds: string[];
        /**
         * The ID of the resource group to which the security group belongs.
         */
        resourceGroupId: string;
        /**
         * The routing algorithm.
         */
        scheduler: string;
        /**
         * The number of server groups associated with the NLB instance.
         */
        serverCount: number;
        /**
         * The name of the server group.
         */
        serverGroupName: string;
        /**
         * The type of the server group.
         */
        serverGroupType: string;
        /**
         * The status of the server group.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC to which the server group belongs.
         */
        vpcId: string;
    }

    export interface GetServerGroupsGroupHealthCheck {
        /**
         * The backend port that is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * The maximum timeout period of a health check response.
         */
        healthCheckConnectTimeout: number;
        /**
         * The domain name that is used for health checks.
         */
        healthCheckDomain: string;
        /**
         * Specifies whether to enable health checks.
         */
        healthCheckEnabled: boolean;
        /**
         * The HTTP status codes returned for health checks.
         */
        healthCheckHttpCodes: string[];
        /**
         * The interval between two consecutive health checks.
         */
        healthCheckInterval: number;
        /**
         * The protocol that is used for health checks.
         */
        healthCheckType: string;
        /**
         * The path to which health check requests are sent.
         */
        healthCheckUrl: string;
        /**
         * The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy.
         */
        healthyThreshold: number;
        /**
         * The HTTP method that is used for health checks.
         */
        httpCheckMethod: string;
        /**
         * The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy.
         */
        unhealthyThreshold: number;
    }

    export interface GetZonesZone {
        /**
         * The ID of zone.
         */
        id: string;
        /**
         * The local name.
         */
        localName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface LoadBalancerZoneMapping {
        /**
         * The ID of the EIP associated with the Internet-facing NLB instance.
         */
        allocationId: string;
        /**
         * The ID of the elastic network interface (ENI).
         */
        eniId: string;
        /**
         * The IPv6 address of the NLB instance.
         */
        ipv6Address: string;
        /**
         * The private IPv4 address of the NLB instance.
         */
        privateIpv4Address: string;
        /**
         * The public IPv4 address of the NLB instance.
         */
        publicIpv4Address: string;
        /**
         * The vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of an NLB instance.
         */
        vswitchId: string;
        /**
         * The ID of the zone of the NLB instance.
         */
        zoneId: string;
    }

    export interface ServerGroupHealthCheck {
        /**
         * The backend port that is used for health checks. Valid values: 0 to 65535. Default value: 0. If you set the value to 0, the port of a backend server is used for health checks.
         */
        healthCheckConnectPort: number;
        /**
         * The maximum timeout period of a health check response. Unit: seconds. Valid values: 1 to 300. Default value: 5.
         */
        healthCheckConnectTimeout: number;
        /**
         * The domain name that is used for health checks. Valid values:
         * - `$SERVER_IP`: the private IP address of a backend server.
         */
        healthCheckDomain: string;
        /**
         * Specifies whether to enable health checks.
         */
        healthCheckEnabled?: boolean;
        /**
         * The HTTP status codes to return to health checks. Separate multiple HTTP status codes with commas (,). Valid values: http2xx (default), http_3xx, http_4xx, and http_5xx. **Note:** This parameter takes effect only if `healthCheckType` is set to `http`.
         */
        healthCheckHttpCodes: string[];
        /**
         * The interval between two consecutive health checks. Unit: seconds. Valid values: 5 to 5000. Default value: 10.
         */
        healthCheckInterval: number;
        /**
         * The protocol that is used for health checks. Valid values: `TCP` (default) and `HTTP`.
         */
        healthCheckType: string;
        /**
         * The path to which health check requests are sent. The path must be 1 to 80 characters in length, and can contain only letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : ' , +`. The path must start with a forward slash (/). **Note:** This parameter takes effect only if `healthCheckType` is set to `http`.
         */
        healthCheckUrl: string;
        /**
         * The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from fail to success. Valid values: 2 to 10. Default value: 2.
         */
        healthyThreshold: number;
        /**
         * The HTTP method that is used for health checks. Valid values: `GET` and `HEAD`. **Note:** This parameter takes effect only if `healthCheckType` is set to `http`.
         */
        httpCheckMethod: string;
        /**
         * The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from success to fail. Valid values: 2 to 10. Default value: 2.
         */
        unhealthyThreshold: number;
    }

}

export namespace ocean {
    export interface GetBaseInstancesInstance {
        /**
         * The product code of the OceanBase cluster.
         */
        commodityCode: string;
        /**
         * The number of CPU cores of the cluster.
         */
        cpu: number;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The size of the storage space, in GB.
         */
        diskSize: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * Cluster specification information.
         */
        instanceClass: string;
        /**
         * OceanBase cluster ID.
         */
        instanceId: string;
        /**
         * OceanBase cluster name.
         */
        instanceName: string;
        /**
         * The number of nodes in the cluster.
         */
        nodeNum: string;
        /**
         * The payment method of the instance.
         */
        paymentType: string;
        /**
         * The ID of the enterprise resource group to which the instance resides.
         */
        resourceGroupId: string;
        /**
         * Series of OceanBase clusters.
         */
        series: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Information about the zone where the cluster is deployed.
         */
        zones: string[];
    }

}

export namespace oos {
    export interface GetApplicationGroupsGroup {
        /**
         * The name of the Application group.
         */
        applicationGroupName: string;
        /**
         * The name of the Application.
         */
        applicationName: string;
        /**
         * The ID of the cloud monitor group.
         */
        cmsGroupId: string;
        /**
         * The Creation time of the resource.
         */
        createTime: string;
        /**
         * The region ID of the deployment.
         */
        deployRegionId: string;
        /**
         * Application group description information.
         */
        description: string;
        /**
         * The ID of the Application Group. Its value is same as Queue Name.
         */
        id: string;
        /**
         * Label key.
         */
        importTagKey: string;
        /**
         * Label value.
         */
        importTagValue: string;
        /**
         * The Update time of the resource.
         */
        updateTime: string;
    }

    export interface GetApplicationsApplication {
        /**
         * The name of the application.
         */
        applicationName: string;
        /**
         * The Created time of the application.
         */
        createTime: string;
        /**
         * Application group description information.
         */
        description: string;
        /**
         * The ID of the Application. The value is formate as <application_name>.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The Updated time of the application.
         */
        updateTime: string;
    }

    export interface GetExecutionsExecution {
        /**
         * The category of template. Valid: `AlarmTrigger`, `EventTrigger`, `Other` and `TimerTrigger`.
         */
        category: string;
        /**
         * The counters of OOS Execution.
         */
        counters: string;
        /**
         * The time when the execution was created.
         */
        createDate: string;
        /**
         * The time when the execution was ended.
         */
        endDate: string;
        /**
         * The user who execute the template.
         */
        executedBy: string;
        /**
         * ID of the OOS Executions.
         */
        executionId: string;
        /**
         * ID of the OOS Executions.
         */
        id: string;
        /**
         * Whether to include subtasks.
         */
        isParent: boolean;
        /**
         * The mode of OOS Execution. Valid: `Automatic`, `Debug`.
         */
        mode: string;
        /**
         * The outputs of OOS Executions.
         */
        outputs: string;
        /**
         * The parameters required by the template
         */
        parameters: string;
        /**
         * The id of parent OOS Execution.
         */
        parentExecutionId: string;
        /**
         * The role that executes the current template.
         */
        ramRole: string;
        /**
         * The time when the template was started.
         */
        startDate: string;
        /**
         * The Status of OOS Execution. Valid: `Cancelled`, `Failed`, `Queued`, `Running`, `Started`, `Success`, `Waiting`.
         */
        status: string;
        /**
         * The message of status.
         */
        statusMessage: string;
        /**
         * The reason of status.
         */
        statusReason: string;
        /**
         * The id of execution template.
         */
        templateId: string;
        /**
         * The name of execution template.
         */
        templateName: string;
        /**
         * The version of execution template.
         */
        templateVersion: string;
        /**
         * The time when the template was updated.
         */
        updateDate: string;
    }

    export interface GetParametersParameter {
        /**
         * The constraints of the common parameter.
         */
        constraints: string;
        /**
         * The time when the common parameter was created.
         */
        createTime: string;
        /**
         * The user who created the common parameter.
         */
        createdBy: string;
        /**
         * The description of the common parameter.
         */
        description: string;
        /**
         * The ID of the Parameter. Its value is same as `parameterName`.
         */
        id: string;
        /**
         * The ID of the common parameter.
         */
        parameterId: string;
        /**
         * The name of the common parameter.
         */
        parameterName: string;
        /**
         * The version number of the common parameter.
         */
        parameterVersion: number;
        /**
         * The ID of the Resource Group.
         */
        resourceGroupId: string;
        /**
         * The share type of the common parameter.
         */
        shareType: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The data type of the common parameter.
         */
        type: string;
        /**
         * The user who updated the common parameter.
         */
        updatedBy: string;
        /**
         * The time when the common parameter was updated.
         */
        updatedDate: string;
        /**
         * The value of the common parameter.
         */
        value: string;
    }

    export interface GetPatchBaselinesBaseline {
        /**
         * Accept the rules.
         */
        approvalRules: string;
        /**
         * The create time of patch baselines.
         */
        createTime: string;
        /**
         * The user who created the patch baselines.
         */
        createdBy: string;
        /**
         * Patches baseline description information.
         */
        description: string;
        /**
         * The ID of the Patch Baseline. Its value is same as `patchBaselineName`.
         */
        id: string;
        /**
         * Whether it is the default patch baseline.
         */
        isDefault: boolean;
        /**
         * Operating system type.
         */
        operationSystem: string;
        /**
         * Patch baseline ID.
         */
        patchBaselineId: string;
        /**
         * The name of the patch baseline.
         */
        patchBaselineName: string;
        /**
         * Patch baseline sharing type.
         */
        shareType: string;
        /**
         * The user who updated the patch baselines.
         */
        updatedBy: string;
        /**
         * The update time of patch baselines.
         */
        updatedDate: string;
    }

    export interface GetSecretParametersParameter {
        /**
         * The constraints of the encryption parameter.
         */
        constraints: string;
        /**
         * The time when the encryption parameter was created.
         */
        createTime: string;
        /**
         * The user who created the encryption parameter.
         */
        createdBy: string;
        /**
         * The description of the encryption parameter.
         */
        description: string;
        /**
         * The ID of the Secret Parameter.
         */
        id: string;
        /**
         * KeyId of KMS used for encryption.
         */
        keyId: string;
        /**
         * The version number of the encryption parameter.
         */
        parameterVersion: number;
        /**
         * The ID of the Resource Group.
         */
        resourceGroupId: string;
        /**
         * The ID of the encryption parameter.
         */
        secretParameterId: string;
        /**
         * The name of the encryption parameter.
         */
        secretParameterName: string;
        /**
         * The share type of the encryption parameter.
         */
        shareType: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The data type of the encryption parameter.
         */
        type: string;
        /**
         * The user who updated the encryption parameter.
         */
        updatedBy: string;
        /**
         * The time when the encryption parameter was updated.
         */
        updatedDate: string;
    }

    export interface GetStateConfigurationsConfiguration {
        /**
         * The configuration mode.
         */
        configureMode: string;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The ID of the State Configuration.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The schedule expression.
         */
        scheduleExpression: string;
        /**
         * The schedule type.
         */
        scheduleType: string;
        /**
         * The ID of the final state configuration.
         */
        stateConfigurationId: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The target resource.
         */
        targets: string;
        /**
         * The ID of the template.
         */
        templateId: string;
        /**
         * The name of the template.
         */
        templateName: string;
        /**
         * The version of the template.
         */
        templateVersion: string;
        /**
         * The time when the configuration is updated.
         */
        updateTime: string;
    }

    export interface GetTemplatesTemplate {
        /**
         * The category of template.
         */
        category: string;
        /**
         * The creator of the template.
         */
        createdBy: string;
        /**
         * The template whose creation time is less than or equal to the specified time. The format is: YYYY-MM-DDThh:mm::ssZ.
         */
        createdDate: string;
        /**
         * Description of the OOS Template.
         */
        description: string;
        /**
         * Is it triggered successfully.
         */
        hasTrigger: boolean;
        /**
         * ID of the OOS Template. The value is same as template_name.
         */
        id: string;
        /**
         * The sharing type of the template. Valid values: `Private`, `Public`.
         */
        shareType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The format of the template. Valid values: `JSON`, `YAML`.
         */
        templateFormat: string;
        /**
         * ID of the OOS Template resource.
         */
        templateId: string;
        /**
         * Name of the OOS Template.
         */
        templateName: string;
        /**
         * The type of OOS Template.
         */
        templateType: string;
        /**
         * Version of the OOS Template.
         */
        templateVersion: string;
        /**
         * The user who updated the template.
         */
        updatedBy: string;
        /**
         * The time when the template was updated.
         */
        updatedDate: string;
    }

}

export namespace opensearch {
    export interface AppGroupOrder {
        /**
         * Whether to renew automatically. It only takes effect when the parameter paymentType takes the value `Subscription`.
         */
        autoRenew?: boolean;
        /**
         * Order cycle. The minimum value is not less than 0.
         */
        duration?: number;
        /**
         * Order cycle unit. Valid values: `Year` and `Month`.
         */
        pricingCycle?: string;
    }

    export interface AppGroupQuota {
        /**
         * Computing resources. Unit: LCU.
         */
        computeResource: number;
        /**
         * Storage Size. Unit: GB.
         */
        docSize: number;
        /**
         * Search request. Unit: times/second.
         */
        qps?: number;
        /**
         * Specification. Valid values: 
         * * `opensearch.share.junior`: Entry-level.
         * * `opensearch.share.common`: Shared universal.
         * * `opensearch.share.compute`: Shared computing.
         * * `opensearch.share.storage`: Shared storage type.
         * * `opensearch.private.common`: Exclusive universal type.
         * * `opensearch.private.compute`: Exclusive computing type.
         * * `opensearch.private.storage`: Exclusive storage type
         */
        spec: string;
    }

    export interface GetAppGroupsGroup {
        /**
         * The ID of the App Group.
         */
        appGroupId: string;
        /**
         * Application Group Name.
         */
        appGroupName: string;
        /**
         * Billing model. Valid values:`computeResource` and `qps`.
         */
        chargeWay: number;
        /**
         * The commodity code.
         */
        commodityCode: string;
        /**
         * The time of creation.
         */
        createTime: number;
        /**
         * The version of Application Group Name.
         */
        currentVersion: string;
        /**
         * The description of the resource.
         */
        description: string;
        /**
         * Domain name.
         */
        domain: string;
        /**
         * Expiration Time.
         */
        expireOn: string;
        /**
         * Coarse deployment ID.
         */
        firstRankAlgoDeploymentId: number;
        /**
         * Whether the quota status is under approval. Valid status:
         */
        hasPendingQuotaReviewTask: number;
        id: string;
        /**
         * The Instance ID.
         */
        instanceId: string;
        /**
         * Locked state. Valid status: `Unlock`,`LockByExpiration`,`ManualLock`.
         */
        lockMode: string;
        /**
         * Instance is automatically locked after expiration.
         */
        lockedByExpiration: number;
        /**
         * The billing method of the resource. Valid values: `Subscription` and `PayAsYouGo`.
         */
        paymentType: string;
        /**
         * Refine deployment ID in deployment.
         */
        pendingSecondRankAlgoDeploymentId: number;
        /**
         * Unfinished order number.
         */
        processingOrderId: string;
        /**
         * Whether the production is completed. Valid values:
         */
        produced: number;
        /**
         * The Project ID.
         */
        projectId: string;
        /**
         * Quota information.
         */
        quotas: outputs.opensearch.GetAppGroupsGroupQuota[];
        /**
         * The Resource Group ID.
         */
        resourceGroupId: string;
        /**
         * Refine deployment ID.
         */
        secondRankAlgoDeploymentId: number;
        /**
         * The status of the resource. Valid values: `producing`,`reviewPending`,`configPending`,`normal`,`frozen`.
         */
        status: string;
        /**
         * The Switched time.
         */
        switchedTime: number;
        /**
         * Application type. Valid Values: `standard`, `enhanced`.
         */
        type: string;
    }

    export interface GetAppGroupsGroupQuota {
        /**
         * Computing resources. Unit: LCU.
         */
        computeResource: string;
        /**
         * Storage Size. Unit: GB.
         */
        docSize: string;
        /**
         * Specification. Valid values:
         * * `opensearch.share.junior`: Entry-level.
         * * `opensearch.share.common`: Shared universal.
         * * `opensearch.share.compute`: Shared computing.
         * * `opensearch.share.storage`: Shared storage type.
         * * `opensearch.private.common`: Exclusive universal type.
         * * `opensearch.private.compute`: Exclusive computing type.
         * * `opensearch.private.storage`: Exclusive storage type
         */
        spec: string;
    }

}

export namespace oss {
    export interface BucketCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders?: string[];
        /**
         * Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies expose header in the response.
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed (documented below).
         */
        abortMultipartUploads?: outputs.oss.BucketLifecycleRuleAbortMultipartUpload[];
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire (documented below).
         */
        expirations?: outputs.oss.BucketLifecycleRuleExpiration[];
        /**
         * Unique identifier for the rule. If omitted, OSS bucket will assign a unique name.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire (documented below).
         */
        noncurrentVersionExpirations?: outputs.oss.BucketLifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies when noncurrent object versions transitions (documented below).
         *
         * `NOTE`: At least one of expiration, transitions, abort_multipart_upload, noncurrentVersionExpiration and noncurrentVersionTransition should be configured.
         */
        noncurrentVersionTransitions?: outputs.oss.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies. Default value is null, the rule applies to all objects in a bucket.
         */
        prefix?: string;
        /**
         * Specifies the time when an object is converted to the IA or archive storage class during a valid life cycle. (documented below).
         */
        transitions?: outputs.oss.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortMultipartUpload {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that objects updated before 2002-10-11T00:00:00.000Z are deleted or converted to another storage class, and objects updated after this time (including this time) are not deleted or converted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         *
         * `NOTE`: One and only one of "createdBeforeDate" and "days" can be specified in one abortMultipartUpload configuration.
         */
        days?: number;
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that objects updated before 2002-10-11T00:00:00.000Z are deleted or converted to another storage class, and objects updated after this time (including this time) are not deleted or converted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the date after which you want the corresponding action to take effect. The value obeys ISO8601 format like `2017-03-09`.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         *
         * `NOTE`: One and only one of "createdBeforeDate" and "days" can be specified in one abortMultipartUpload configuration.
         */
        days?: number;
        /**
         * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct OSS to delete expired object delete markers. This cannot be specified with Days, Date or CreatedBeforeDate in a Lifecycle Expiration Policy.
         *
         * `NOTE`: One and only one of "date", "days", "createdBeforeDate" and "expiredObjectDeleteMarker" can be specified in one expiration configuration.
         */
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         *
         * `NOTE`: One and only one of "createdBeforeDate" and "days" can be specified in one abortMultipartUpload configuration.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         *
         * `NOTE`: One and only one of "createdBeforeDate" and "days" can be specified in one abortMultipartUpload configuration.
         */
        days: number;
        /**
         * The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive" and "ColdArchive". Defaults to "Standard". "ColdArchive" is available in 1.203.0+.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that objects updated before 2002-10-11T00:00:00.000Z are deleted or converted to another storage class, and objects updated after this time (including this time) are not deleted or converted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the number of days after object creation when the specific rule action takes effect.
         *
         * `NOTE`: One and only one of "createdBeforeDate" and "days" can be specified in one abortMultipartUpload configuration.
         */
        days?: number;
        /**
         * The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive" and "ColdArchive". Defaults to "Standard". "ColdArchive" is available in 1.203.0+.
         */
        storageClass?: string;
    }

    export interface BucketLogging {
        /**
         * The name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketRefererConfig {
        /**
         * Allows referer to be empty. Defaults false.
         */
        allowEmpty: boolean;
        /**
         * The list of referer.
         */
        referers: string[];
    }

    export interface BucketReplicationDestination {
        /**
         * The destination bucket to which the data is replicated.
         */
        bucket: string;
        location: string;
        /**
         * The link used to transfer data in data replication.. Can be `internal` or `ossAcc`. Defaults to `internal`.
         *
         * `NOTE`: You can set transferType to ossAcc only when you create cross-region replication (CRR) rules.
         */
        transferType?: string;
    }

    export interface BucketReplicationEncryptionConfiguration {
        /**
         * The CMK ID used in SSE-KMS.
         *
         * `NOTE`: If the status of sseKmsEncryptedObjects is set to Enabled, you must specify the replica_kms_key_id.
         */
        replicaKmsKeyId: string;
    }

    export interface BucketReplicationPrefixSet {
        /**
         * The list of object key name prefix identifying one or more objects to which the rule applies.
         *
         * `NOTE`: The prefix must be less than or equal to 1024 characters in length.
         */
        prefixes: string[];
    }

    export interface BucketReplicationProgress {
        /**
         * The percentage of the replicated historical data. This element is valid only when historicalObjectReplication is set to enabled.
         */
        historicalObject: string;
        /**
         * The time used to distinguish new data from historical data. Data that is written to the source bucket before the time is replicated to the destination bucket as new data. The value of this element is in GMT.
         */
        newObject: string;
    }

    export interface BucketReplicationSourceSelectionCriteria {
        /**
         * Filter source objects encrypted by using SSE-KMS(See the following block `sseKmsEncryptedObjects`).
         */
        sseKmsEncryptedObjects?: outputs.oss.BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjects;
    }

    export interface BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjects {
        /**
         * Specifies whether to replicate objects encrypted by using SSE-KMS. Can be `Enabled` or `Disabled`.
         */
        status?: string;
    }

    export interface BucketServerSideEncryptionRule {
        /**
         * The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
         */
        kmsMasterKeyId?: string;
        /**
         * The server-side encryption algorithm to use. Possible values: `AES256` and `KMS`.
         */
        sseAlgorithm: string;
    }

    export interface BucketTransferAcceleration {
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
    }

    export interface BucketVersioning {
        /**
         * Specifies the versioning state of a bucket. Valid values: `Enabled` and `Suspended`.
         *
         * `NOTE`: Currently, the `versioning` feature is only available in ap-south-1 and with white list. If you want to use it, please contact us.
         */
        status: string;
    }

    export interface BucketWebsite {
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Alicloud OSS returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument: string;
    }

    export interface GetBucketObjectsObject {
        /**
         * Object access control list. Possible values: `default`, `private`, `public-read` and `public-read-write`.
         */
        acl: string;
        /**
         * Caching behavior along the request/reply chain. Read [RFC2616 Cache-Control](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        cacheControl: string;
        /**
         * Presentational information for the object. Read [RFC2616 Content-Disposition](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        contentDisposition: string;
        /**
         * Content encodings that have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read [RFC2616 Content-Encoding](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        contentEncoding: string;
        /**
         * Size of the object in bytes.
         */
        contentLength: string;
        /**
         * MD5 value of the content. Read [MD5](https://www.alibabacloud.com/help/doc-detail/31978.htm) for computing method.
         */
        contentMd5: string;
        /**
         * Standard MIME type describing the format of the object data, e.g. "application/octet-stream".
         */
        contentType: string;
        /**
         * ETag generated for the object (MD5 sum of the object content).
         */
        etag: string;
        /**
         * Expiration date for the the request/response. Read [RFC2616 Expires](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        expires: string;
        /**
         * Object key.
         */
        key: string;
        /**
         * Last modification time of the object.
         */
        lastModificationTime: string;
        /**
         * Server-side encryption of the object in OSS. It can be empty or `AES256`.
         */
        serverSideEncryption: string;
        /**
         * If present, specifies the ID of the Key Management Service(KMS) master encryption key that was used for the object.
         */
        sseKmsKeyId: string;
        /**
         * Object storage type. Possible values: `Standard`, `IA`, `Archive` and `ColdArchive`.
         */
        storageClass: string;
    }

    export interface GetBucketsBucket {
        /**
         * Bucket access control list. Possible values: `private`, `public-read` and `public-read-write`.
         */
        acl: string;
        /**
         * A list of CORS rule configurations. Each element contains the following attributes:
         */
        corsRules: outputs.oss.GetBucketsBucketCorsRule[];
        /**
         * Bucket creation date.
         */
        creationDate: string;
        /**
         * Internet domain name for accessing the bucket from outside.
         */
        extranetEndpoint: string;
        /**
         * Intranet domain name for accessing the bucket from an ECS instance in the same region.
         */
        intranetEndpoint: string;
        /**
         * A list CORS of lifecycle configurations. When Lifecycle is enabled, OSS automatically deletes the objects or transitions the objects (to another storage class) corresponding the lifecycle rules on a regular basis. Each element contains the following attributes:
         */
        lifecycleRules: outputs.oss.GetBucketsBucketLifecycleRule[];
        /**
         * Region of the data center where the bucket is located.
         */
        location: string;
        /**
         * A list of one element containing configuration parameters used for storing access log information. It contains the following attributes:
         */
        logging: outputs.oss.GetBucketsBucketLogging;
        /**
         * Bucket name.
         */
        name: string;
        /**
         * Bucket owner.
         */
        owner: string;
        policy?: string;
        /**
         * Redundancy type. Possible values: `LRS`, and `ZRS`.
         */
        redundancyType: string;
        /**
         * A list of one element containing referer configuration. It contains the following attributes:
         */
        refererConfig: outputs.oss.GetBucketsBucketRefererConfig;
        /**
         * A configuration of default encryption for a bucket. It contains the following attributes:
         */
        serverSideEncryptionRule: outputs.oss.GetBucketsBucketServerSideEncryptionRule;
        /**
         * Object storage type. Possible values: `Standard`, `IA`, `Archive` and `ColdArchive`.
         */
        storageClass: string;
        /**
         * A mapping of tags.
         */
        tags: {[key: string]: any};
        /**
         * If present , the versioning state has been set on the bucket. It contains the following attribute.
         */
        versioning: outputs.oss.GetBucketsBucketVersioning;
        /**
         * A list of one element containing configuration parameters used when the bucket is used as a website. It contains the following attributes:
         */
        website: outputs.oss.GetBucketsBucketWebsite;
    }

    export interface GetBucketsBucketCorsRule {
        /**
         * Control whether the headers specified by Access-Control-Request-Headers in the OPTIONS prefetch command are allowed. Each header specified by Access-Control-Request-Headers must match a value in AllowedHeader. Each rule allows up to one wildcard * .
         */
        allowedHeaders: string[];
        /**
         * Specify the allowed methods for cross-domain requests. Possible values: `GET`, `PUT`, `DELETE`, `POST` and `HEAD`.
         */
        allowedMethods: string[];
        /**
         * The origins allowed for cross-domain requests. Multiple elements can be used to specify multiple allowed origins. Each rule allows up to one wildcard "\*". If "\*" is specified, cross-domain requests of all origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specify the response headers allowing users to access from an application (for example, a Javascript XMLHttpRequest object). The wildcard "\*" is not allowed.
         */
        exposeHeaders: string[];
        /**
         * Specify the cache time for the returned result of a browser prefetch (OPTIONS) request to a specific resource.
         */
        maxAgeSeconds: number;
    }

    export interface GetBucketsBucketLifecycleRule {
        /**
         * Indicate whether the rule is enabled or not.
         */
        enabled: boolean;
        /**
         * A list of one element containing expiration attributes of an object. It contains the following attributes:
         */
        expiration: outputs.oss.GetBucketsBucketLifecycleRuleExpiration;
        /**
         * Unique ID of the rule.
         */
        id: string;
        /**
         * Prefix applicable to a rule. Only those objects with a matching prefix can be affected by the rule.
         */
        prefix: string;
    }

    export interface GetBucketsBucketLifecycleRuleExpiration {
        /**
         * Date after which the rule to take effect. The format is like 2017-03-09.
         */
        date?: string;
        /**
         * Indicate the number of days after the last object update until the rules take effect.
         */
        days?: number;
    }

    export interface GetBucketsBucketLogging {
        /**
         * Bucket for storing access logs.
         */
        targetBucket: string;
        /**
         * Prefix of the saved access log file paths.
         */
        targetPrefix: string;
    }

    export interface GetBucketsBucketRefererConfig {
        /**
         * Indicate whether the access request referer field can be empty.
         */
        allowEmpty: boolean;
        /**
         * Referer access whitelist.
         */
        referers: string[];
    }

    export interface GetBucketsBucketServerSideEncryptionRule {
        /**
         * The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
         */
        kmsMasterKeyId: string;
        /**
         * The server-side encryption algorithm to use.
         */
        sseAlgorithm: string;
    }

    export interface GetBucketsBucketVersioning {
        /**
         * A bucket versioning state. Possible values:`Enabled` and `Suspended`.
         */
        status: string;
    }

    export interface GetBucketsBucketWebsite {
        /**
         * Key of the HTML document containing the error page.
         */
        errorDocument: string;
        /**
         * Key of the HTML document containing the home page.
         */
        indexDocument: string;
    }

    export interface GetInstanceAttachmentsAttachment {
        /**
         * The domain of the instance attachment.
         */
        domain: string;
        /**
         * The access endpoint of the instance attachment.
         */
        endpoint: string;
        /**
         * The resource ID, the value is same as "instanceName".
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The region of the instance attachment.
         */
        region: string;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The name of attaching VPC to instance.
         */
        vpcName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The cluster type of the instance. Possible values: `SSD`, `HYBRID`.
         */
        clusterType: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The instance quota which indicating the maximum number of tables.
         */
        entityQuota: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * The network type of the instance. Possible values: `NORMAL`, `VPC`, `VPC_CONSOLE`.
         */
        network: string;
        /**
         * The maximum adjustable read capacity unit of the instance.
         */
        readCapacity: number;
        /**
         * Instance status. Possible values: `Running`, `Disabled`, `Deleting`.
         */
        status: string;
        /**
         * A map of tags assigned to the instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instancesDs = alicloud.ots.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags: {[key: string]: any};
        /**
         * The user id of the instance.
         */
        userId: string;
        /**
         * The maximum adjustable write capacity unit of the instance.
         */
        writeCapacity: number;
    }

    export interface GetTablesTable {
        definedColumns: outputs.oss.GetTablesTableDefinedColumn[];
        /**
         * ID of the table. The value is `<instance_name>:<table_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The maximum number of versions stored in this table.
         */
        maxVersion: number;
        /**
         * The property of `TableMeta` which indicates the structure information of a table.
         */
        primaryKeys: outputs.oss.GetTablesTablePrimaryKey[];
        /**
         * The table name of the OTS which could not be changed.
         */
        tableName: string;
        /**
         * The retention time of data stored in this table.
         */
        timeToLive: number;
    }

    export interface GetTablesTableDefinedColumn {
        name: string;
        type: string;
    }

    export interface GetTablesTablePrimaryKey {
        name: string;
        type: string;
    }

}

export namespace ots {
    export interface GetInstanceAttachmentsAttachment {
        /**
         * The domain of the instance attachment.
         */
        domain: string;
        /**
         * The access endpoint of the instance attachment.
         */
        endpoint: string;
        /**
         * The resource ID, the value is same as "instanceName".
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The region of the instance attachment.
         */
        region: string;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The name of attaching VPC to instance.
         */
        vpcName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The cluster type of the instance. Possible values: `SSD`, `HYBRID`.
         */
        clusterType: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The instance quota which indicating the maximum number of tables.
         */
        entityQuota: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * The network type of the instance. Possible values: `NORMAL`, `VPC`, `VPC_CONSOLE`.
         */
        network: string;
        /**
         * The maximum adjustable read capacity unit of the instance.
         */
        readCapacity: number;
        /**
         * Instance status. Possible values: `Running`, `Disabled`, `Deleting`.
         */
        status: string;
        /**
         * A map of tags assigned to the instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instancesDs = alicloud.ots.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags: {[key: string]: any};
        /**
         * The user id of the instance.
         */
        userId: string;
        /**
         * The maximum adjustable write capacity unit of the instance.
         */
        writeCapacity: number;
    }

    export interface GetSearchIndexesIndex {
        /**
         * The creation time of the index.
         */
        createTime: number;
        /**
         * Timestamp for sync phase.
         */
        currentSyncTimestamp: number;
        /**
         * The resource ID. The value is `<instance_name>:<table_name>:<indexName>:<indexType>`.
         */
        id: string;
        /**
         * The index name of the OTS Table which could not be changed.
         */
        indexName: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * Last update time for metering data..
         */
        meteringLastUpdateTime: number;
        /**
         * Reserve related resources for the index.
         */
        reservedReadCu: number;
        /**
         * The number of rows of data for index.
         */
        rowCount: number;
        /**
         * JSON representation of the schema of index.
         */
        schema: string;
        /**
         * Storage space occupied by index.
         */
        storageSize: number;
        /**
         * The synchronization state of the index.
         */
        syncPhase: string;
        /**
         * The name of OTS table.
         */
        tableName: string;
        /**
         * TTL of index.
         */
        timeToLive: number;
    }

    export interface GetSecondaryIndexesIndex {
        /**
         * A list of defined column for index, referenced from Table's primary keys or predefined columns.
         */
        definedColumns: string[];
        /**
         * The resource ID. The value is `<instance_name>:<table_name>:<indexName>:<indexType>`.
         */
        id: string;
        /**
         * The index name of the OTS Table which could not be changed.
         */
        indexName: string;
        /**
         * The index type of the OTS Table which could not be changed.
         */
        indexType: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * A list of primary keys for index, referenced from Table's primary keys or predefined columns.
         */
        primaryKeys: string[];
        /**
         * The name of OTS table.
         */
        tableName: string;
    }

    export interface GetTablesTable {
        definedColumns: outputs.ots.GetTablesTableDefinedColumn[];
        /**
         * ID of the table. The value is `<instance_name>:<table_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The maximum number of versions stored in this table.
         */
        maxVersion: number;
        /**
         * The property of `TableMeta` which indicates the structure information of a table.
         */
        primaryKeys: outputs.ots.GetTablesTablePrimaryKey[];
        /**
         * The table name of the OTS which could not be changed.
         */
        tableName: string;
        /**
         * The retention time of data stored in this table.
         */
        timeToLive: number;
    }

    export interface GetTablesTableDefinedColumn {
        name: string;
        type: string;
    }

    export interface GetTablesTablePrimaryKey {
        name: string;
        type: string;
    }

    export interface GetTunnelsTunnel {
        /**
         * The channels of OTS tunnel. Each element contains the following attributes:
         */
        channels: outputs.ots.GetTunnelsTunnelChannel[];
        /**
         * The creation time of the Tunnel.
         */
        createTime: number;
        /**
         * Whether the tunnel has expired.
         */
        expired: boolean;
        /**
         * The resource ID. The value is `<instance_name>:<table_name>:<tunnel_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The name of OTS table.
         */
        tableName: string;
        /**
         * The tunnel id of the OTS which could not be changed.
         */
        tunnelId: string;
        /**
         * The tunnel name of the OTS which could not be changed.
         */
        tunnelName: string;
        /**
         * The latest consumption time of the tunnel, unix time in nanosecond.
         */
        tunnelRpo: number;
        /**
         * The stage of OTS tunnel, valid values: `InitBaseDataAndStreamShard`, `ProcessBaseData`, `ProcessStream`.
         */
        tunnelStage: string;
        /**
         * The type of the OTS tunnel, valid values: `BaseAndStream`, `BaseData`, `Stream`.
         */
        tunnelType: string;
    }

    export interface GetTunnelsTunnelChannel {
        /**
         * The id of the channel.
         */
        channelId: string;
        /**
         * The latest consumption time of the channel, unix time in nanosecond
         */
        channelRpo: number;
        /**
         * The status of the channel, valid values: `WAIT`, `OPEN`, `CLOSING`, `CLOSE`, `TERMINATED`.
         */
        channelStatus: string;
        /**
         * The type of the channel, valid values: `BaseData`, `Stream`.
         */
        channelType: string;
        /**
         * The client id of the channel.
         */
        clientId: string;
    }

    export interface SearchIndexSchema {
        /**
         * A list of field schemas. Each field schema contains the following parameters:
         */
        fieldSchemas: outputs.ots.SearchIndexSchemaFieldSchema[];
        /**
         * The settings of the search index, including routingFields.
         */
        indexSettings?: outputs.ots.SearchIndexSchemaIndexSetting[];
        /**
         * The presorting settings of the search index, including sorters. If no value is specified for the indexSort parameter, field values are sorted by primary key by default.
         */
        indexSorts?: outputs.ots.SearchIndexSchemaIndexSort[];
    }

    export interface SearchIndexSchemaFieldSchema {
        /**
         * Specifies the type of the analyzer that you want to use. If fieldType is set to Text, you can configure this parameter. Otherwise, the default analyzer type single-word tokenization is used.
         */
        analyzer?: string;
        /**
         * Specifies whether to enable sorting and aggregation. Type: Boolean. Sorting can be enabled only for fields for which enableSortAndAgg is set to true.
         */
        enableSortAndAgg?: boolean;
        /**
         * The name of the field that is used to sort data. only required if sorterType is FieldSort.
         */
        fieldName: string;
        /**
         * Specifies the type of the field. Use FieldType.XXX to set the type.
         */
        fieldType: string;
        /**
         * Specifies whether to enable indexing for the column. Type: Boolean.
         */
        index?: boolean;
        /**
         * Specifies whether the value is an array. Type: Boolean.
         */
        isArray?: boolean;
        /**
         * Specifies whether to store the value of the field in the search index. Type: Boolean. If you set store to true, you can read the value of the field from the search index without querying the data table. This improves query performance.
         */
        store?: boolean;
    }

    export interface SearchIndexSchemaIndexSetting {
        /**
         * Specifies custom routing fields. You can specify some primary key columns as routing fields. Tablestore distributes data that is written to a search index across different partitions based on the specified routing fields. The data whose routing field values are the same is distributed to the same partition.
         */
        routingFields?: string[];
    }

    export interface SearchIndexSchemaIndexSort {
        /**
         * Specifies the presorting method for the search index. PrimaryKeySort and FieldSort are supported.
         */
        sorters: outputs.ots.SearchIndexSchemaIndexSortSorter[];
    }

    export interface SearchIndexSchemaIndexSortSorter {
        /**
         * The name of the field that is used to sort data. only required if sorterType is FieldSort.
         */
        fieldName?: string;
        /**
         * The sorting method that is used when the field contains multiple values. valid values: `Min`, `Max`, `Avg`. only required if sorterType is FieldSort.
         */
        mode?: string;
        /**
         * The sort order. Data can be sorted in ascending(`Asc`) or descending(`Desc`) order. Default value: `Asc`.
         */
        order?: string;
        /**
         * Data is sorted by Which fields or keys. valid values: `PrimaryKeySort`, `FieldSort`.
         */
        sorterType?: string;
    }

    export interface TableDefinedColumn {
        /**
         * Name for defined column.
         */
        name: string;
        /**
         * Type for defined column. `Integer`, `String`, `Binary`, `Double`, `Boolean` is allowed.
         */
        type: string;
    }

    export interface TablePrimaryKey {
        /**
         * Name for defined column.
         */
        name: string;
        /**
         * Type for defined column. `Integer`, `String`, `Binary`, `Double`, `Boolean` is allowed.
         */
        type: string;
    }

    export interface TunnelChannel {
        /**
         * The id of the channel.
         */
        channelId: string;
        /**
         * The latest consumption time of the channel, unix time in nanosecond.
         */
        channelRpo: number;
        /**
         * The status of the channel, valid values: `WAIT`, `OPEN`, `CLOSING`, `CLOSE`, `TERMINATED`.
         */
        channelStatus: string;
        /**
         * The type of the channel, valid values: `BaseData`, `Stream`.
         */
        channelType: string;
        /**
         * The client id of the channel.
         */
        clientId: string;
    }

}

export namespace polardb {
    export interface ClusterDbClusterIpArray {
        /**
         * The name of the IP whitelist group. The group name must be 2 to 120 characters in length and consists of lowercase letters and digits. It must start with a letter, and end with a letter or a digit.
         * **NOTE:** If the specified whitelist group name does not exist, the whitelist group is created. If the specified whitelist group name exists, the whitelist group is modified. If you do not specify this parameter, the default group is modified. You can create a maximum of 50 IP whitelist groups for a cluster.
         */
        dbClusterIpArrayName?: string;
        /**
         * The method for modifying the IP whitelist. Valid values are `Cover`, `Append`, `Delete`.
         * **NOTE:** There does not recommend setting modifyMode to `Append` or `Delete` and it will bring a potential diff error.
         */
        modifyMode?: string;
        /**
         * This attribute has been deprecated from v1.130.0 and using `dbClusterIpArray` sub-element `securityIps` instead.
         * Its value is same as `dbClusterIpArray` sub-element `securityIps` value and its dbClusterIpArrayName is "default".
         */
        securityIps?: string[];
    }

    export interface ClusterParameter {
        name: string;
        value: string;
    }

    export interface GetAccountsAccount {
        /**
         * Account description.
         */
        accountDescription: string;
        /**
         * Account lock state, Valid values are `Lock`, `UnLock`.
         */
        accountLockState: string;
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Cluster address type.`Cluster`: the default address of the Cluster.`Primary`: Primary address.`Custom`: Custom cluster addresses.
         */
        accountStatus: string;
        /**
         * Account type, Valid values are `Normal`, `Super`.
         */
        accountType: string;
        /**
         * A list of database privilege. Each element contains the following attributes.
         */
        databasePrivileges: outputs.polardb.GetAccountsAccountDatabasePrivilege[];
    }

    export interface GetAccountsAccountDatabasePrivilege {
        /**
         * Account privilege of database
         */
        accountPrivilege: string;
        /**
         * The account owned database name
         */
        dbName: string;
    }

    export interface GetClustersCluster {
        /**
         * Billing method. Value options: `PostPaid` for Pay-As-You-Go and `PrePaid` for subscription.
         */
        chargeType: string;
        /**
         * PolarDB cluster connection string.
         */
        connectionString: string;
        /**
         * The createTime of the db_nodes.
         */
        createTime: string;
        /**
         * The dbNodeClass of the db_nodes.
         */
        dbNodeClass: string;
        /**
         * The DBNodeNumber of the PolarDB cluster.
         */
        dbNodeNumber: number;
        /**
         * The DBNodes of the PolarDB cluster.
         */
        dbNodes: outputs.polardb.GetClustersClusterDbNode[];
        /**
         * Database type. Options are `MySQL`, `Oracle` and `PostgreSQL`. If no value is specified, all types are returned.
         */
        dbType: string;
        /**
         * The DBVersion of the PolarDB cluster.
         */
        dbVersion: string;
        /**
         * The DeleteLock of the PolarDB cluster.
         */
        deleteLock: number;
        /**
         * The description of the PolarDB cluster.
         */
        description: string;
        /**
         * Database type. Options are `MySQL`, `Oracle` and `PostgreSQL`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Expiration time. Pay-As-You-Go clusters never expire.
         */
        expireTime: string;
        /**
         * The expired of the PolarDB cluster.
         */
        expired: string;
        /**
         * The ID of the PolarDB cluster.
         */
        id: string;
        /**
         * The LockMode of the PolarDB cluster.
         */
        lockMode: string;
        /**
         * The DBClusterNetworkType of the PolarDB cluster.
         */
        networkType: string;
        /**
         * PolarDB cluster connection port.
         */
        port: string;
        /**
         * The regionId of the db_nodes.
         */
        regionId: string;
        /**
         * status of the cluster.
         */
        status: string;
        /**
         * The StorageUsed of the PolarDB cluster.
         */
        storageUsed: number;
        /**
         * ID of the VPC the cluster belongs to.
         */
        vpcId: string;
        /**
         * The zoneId of the db_nodes.
         */
        zoneId: string;
    }

    export interface GetClustersClusterDbNode {
        /**
         * The createTime of the db_nodes.
         */
        createTime: string;
        /**
         * The dbNodeClass of the db_nodes.
         */
        dbNodeClass: string;
        /**
         * The dbNodeId of the db_nodes.
         */
        dbNodeId: string;
        /**
         * The dbNodeRole of the db_nodes.
         */
        dbNodeRole: string;
        /**
         * The dbNodeStatus of the db_nodes.
         */
        dbNodeStatus: string;
        /**
         * The maxConnections of the db_nodes.
         */
        maxConnections: number;
        /**
         * The maxIops of the db_nodes.
         */
        maxIops: number;
        /**
         * The regionId of the db_nodes.
         */
        regionId: string;
        /**
         * The zoneId of the db_nodes.
         */
        zoneId: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * A list of accounts of database. Each element contains the following attributes.
         */
        accounts: outputs.polardb.GetDatabasesDatabaseAccount[];
        /**
         * The character set name of database.
         */
        characterSetName: string;
        /**
         * Database description.
         */
        dbDescription: string;
        /**
         * Database name.
         */
        dbName: string;
        /**
         * The status of database.
         */
        dbStatus: string;
        /**
         * The engine of database.
         */
        engine: string;
    }

    export interface GetDatabasesDatabaseAccount {
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Account status.
         */
        accountStatus: string;
        /**
         * The privilege status of account.
         */
        privilegeStatus: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * A list of endpoint addresses. Each element contains the following attributes.
         */
        addressItems: outputs.polardb.GetEndpointsEndpointAddressItem[];
        /**
         * Whether the new node is automatically added to the default cluster address.Options are `Enable` and `Disable`.
         */
        autoAddNewNodes: string;
        /**
         * endpoint of the cluster.
         */
        dbEndpointId: string;
        /**
         * The Endpoint configuration. `ConsistLevel`: session consistency level, value:`0`: final consistency,`1`: session consistency;`LoadBalanceStrategy`: load balancing strategy. Based on the automatic scheduling of load, the value is: `load`.
         */
        endpointConfig: string;
        /**
         * Cluster address type.`Cluster`: the default address of the Cluster.`Primary`: Primary address.`Custom`: Custom cluster addresses.
         */
        endpointType: string;
        /**
         * A list of nodes that connect to the address configuration.
         */
        nodes: string;
        /**
         * Read-write mode:`ReadWrite`: readable and writable (automatic read-write separation).`ReadOnly`: ReadOnly.
         */
        readWriteMode: string;
    }

    export interface GetEndpointsEndpointAddressItem {
        /**
         * Connection instance string.
         */
        connectionString: string;
        /**
         * The ip address of connection string.
         */
        ipAddress: string;
        /**
         * IP network type:`Public` or `Private`.
         */
        netType: string;
        /**
         * Intranet connection port.
         */
        port: string;
        /**
         * ID of the VPC the instance belongs to.
         */
        vpcId: string;
        /**
         * ID of the VSwitch the cluster belongs to.
         */
        vswitchId: string;
    }

    export interface GetGlobalDatabaseNetworksNetwork {
        /**
         * The time when the Global Database Network was created. The time is in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The details of each cluster in the Global Database Network.
         */
        dbClusters: outputs.polardb.GetGlobalDatabaseNetworksNetworkDbCluster[];
        /**
         * The type of the database engine. Only MySQL is supported.
         */
        dbType: string;
        /**
         * The version number of the database engine. Only the 8.0 version is supported.
         */
        dbVersion: string;
        /**
         * The description of the Global Database Network.
         */
        description: string;
        /**
         * The ID of the Global Database Network.
         */
        gdnId: string;
        /**
         * The ID of the Global Database Network.
         */
        id: string;
        /**
         * The status of the Global Database Network.
         */
        status: string;
    }

    export interface GetGlobalDatabaseNetworksNetworkDbCluster {
        /**
         * The ID of the PolarDB cluster.
         */
        dbClusterId: string;
        /**
         * The region ID of the cluster.
         */
        regionId: string;
        /**
         * The role of the cluster.
         */
        role: string;
    }

    export interface GetNodeClassesClass {
        /**
         * A list of PolarDB node classes in the zone.
         */
        supportedEngines: outputs.polardb.GetNodeClassesClassSupportedEngine[];
        /**
         * The Zone to launch the PolarDB cluster.
         */
        zoneId: string;
    }

    export interface GetNodeClassesClassSupportedEngine {
        /**
         * A list of PolarDB node available classes.
         */
        availableResources: outputs.polardb.GetNodeClassesClassSupportedEngineAvailableResource[];
        /**
         * In the zone, the database type supports classes in the following available_resources.
         */
        engine: string;
    }

    export interface GetNodeClassesClassSupportedEngineAvailableResource {
        /**
         * The PolarDB node class type by the user.
         */
        dbNodeClass: string;
    }

    export interface GetParameterGroupsGroup {
        /**
         * The time when the parameter template was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The type of the database engine.
         */
        dbType: string;
        /**
         * The version number of the database engine.
         */
        dbVersion: string;
        /**
         * Indicates whether to restart the cluster when this parameter template is applied.
         */
        forceRestart: string;
        /**
         * The ID of the Parameter Group.
         */
        id: string;
        /**
         * The number of parameters in the parameter template.
         */
        parameterCounts: number;
        /**
         * The description of the parameter template.
         */
        parameterGroupDesc: string;
        /**
         * The ID of the Parameter Group.
         */
        parameterGroupId: string;
        /**
         * The name of the parameter template.
         */
        parameterGroupName: string;
        /**
         * The type of the parameter template.
         */
        parameterGroupType: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface ParameterGroupParameter {
        /**
         * The name of a parameter in the parameter template.
         */
        paramName: string;
        /**
         * The value of a parameter in the parameter template.
         */
        paramValue: string;
    }

}

export namespace privatelink {
    export interface GetVpcEndpointConnectionsConnection {
        /**
         * The Bandwidth.
         */
        bandwidth: number;
        /**
         * The ID of the Vpc Endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Vpc Endpoint Connection.
         */
        id: string;
        /**
         * The status of Vpc Endpoint Connection.
         */
        status: string;
    }

    export interface GetVpcEndpointServiceResourcesResource {
        /**
         * The ID of the Vpc Endpoint Service Resource.
         */
        id: string;
        /**
         * The ID of Resource.
         */
        resourceId: string;
        /**
         * The type of Resource.
         */
        resourceType: string;
    }

    export interface GetVpcEndpointServiceUsersUser {
        /**
         * The ID of the Vpc Endpoint Service User.
         */
        id: string;
        /**
         * The Id of Ram User.
         */
        userId: string;
    }

    export interface GetVpcEndpointServicesService {
        /**
         * Whether to automatically accept terminal node connections..
         */
        autoAcceptConnection: boolean;
        /**
         * The connection bandwidth.
         */
        connectBandwidth: number;
        /**
         * The ID of the Vpc Endpoint Service.
         */
        id: string;
        /**
         * The business status of the terminal node service..
         */
        serviceBusinessStatus: string;
        /**
         * The description of the terminal node service.
         */
        serviceDescription: string;
        /**
         * The domain of service.
         */
        serviceDomain: string;
        /**
         * The ID of the Vpc Endpoint Service.
         */
        serviceId: string;
        /**
         * The Status of Vpc Endpoint Service.
         */
        status: string;
        /**
         * The name of Vpc Endpoint Service.
         */
        vpcEndpointServiceName: string;
    }

    export interface GetVpcEndpointZonesZone {
        /**
         * Terminal node network card.
         */
        eniId: string;
        /**
         * IP address of the terminal node network card.
         */
        eniIp: string;
        /**
         * The ID of the Vpc Endpoint Zone.
         */
        id: string;
        /**
         * The Status of Vpc Endpoint Zone..
         */
        status: string;
        /**
         * The VSwitch id.
         */
        vswitchId: string;
        /**
         * The Zone Domain.
         */
        zoneDomain: string;
        /**
         * The Zone Id.
         */
        zoneId: string;
    }

    export interface GetVpcEndpointsEndpoint {
        /**
         * The Bandwidth.
         */
        bandwidth: number;
        /**
         * The status of Connection.
         */
        connectionStatus: string;
        /**
         * The status of Endpoint Business.
         */
        endpointBusinessStatus: string;
        /**
         * The description of Vpc Endpoint.
         */
        endpointDescription: string;
        /**
         * The Endpoint Domain.
         */
        endpointDomain: string;
        /**
         * The ID of the Vpc Endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Vpc Endpoint.
         */
        id: string;
        /**
         * The security group associated with the terminal node network card.
         */
        securityGroupIds: string[];
        /**
         * The terminal node service associated with the terminal node.
         */
        serviceId: string;
        /**
         * The name of the terminal node service associated with the terminal node.
         */
        serviceName: string;
        /**
         * The status of Vpc Endpoint.
         */
        status: string;
        /**
         * The name of Vpc Endpoint.
         */
        vpcEndpointName: string;
        /**
         * The private network to which the terminal node belongs.
         */
        vpcId: string;
    }

}

export namespace pvtz {
    export interface EndpointIpConfig {
        /**
         * The Subnet mask.
         */
        cidrBlock: string;
        /**
         * The IP address within the parameter range of the subnet mask.  It is recommended to use the IP address assigned by the system.
         */
        ip: string;
        /**
         * The Vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone ID.
         */
        zoneId: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The name of the resource.
         */
        endpointName: string;
        id: string;
        /**
         * The Ip Configs.
         */
        ipConfigs: outputs.pvtz.GetEndpointsEndpointIpConfig[];
        /**
         * The ID of the Security Group.
         */
        securityGroupId: string;
        /**
         * The status of the resource. Valid values: `CHANGE_FAILED`, `CHANGE_INIT`, `EXCEPTION`, `FAILED`, `INIT`, `SUCCESS`.
         */
        status: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
        /**
         * The name of the VPC.
         */
        vpcName: string;
        /**
         * The Region of the VPC.
         */
        vpcRegionId: string;
    }

    export interface GetEndpointsEndpointIpConfig {
        /**
         * The Subnet mask.
         */
        cidrBlock: string;
        /**
         * The IP address within the parameter range of the subnet mask. **NOTE:** It is recommended to use the IP address assigned by the system.
         */
        ip: string;
        /**
         * The Vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone ID.
         */
        zoneId: string;
    }

    export interface GetResolverZonesZone {
        /**
         * The status of the Zone.
         */
        status: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetRulesRule {
        /**
         * The List of the VPC. See the following `Block bindVpcs`. **NOTE:** Available in v1.158.0+.
         */
        bindVpcs: outputs.pvtz.GetRulesRuleBindVpc[];
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the Endpoint.
         */
        endpointId: string;
        /**
         * The Name of the Endpoint.
         */
        endpointName: string;
        forwardIps: outputs.pvtz.GetRulesRuleForwardIp[];
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        ruleId: string;
        /**
         * The name of the resource.
         */
        ruleName: string;
        /**
         * The type of the rule.
         */
        type: string;
        /**
         * The name of the forwarding zone.
         */
        zoneName: string;
    }

    export interface GetRulesRuleBindVpc {
        /**
         * The region ID of the vpc.
         */
        regionId: string;
        /**
         * The Region Name of the vpc.
         */
        regionName: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The Name of the VPC.
         */
        vpcName: string;
    }

    export interface GetRulesRuleForwardIp {
        ip: string;
        port: number;
    }

    export interface GetZoneRecordsRecord {
        /**
         * ID of the Private Zone Record.
         */
        id: string;
        /**
         * Priority of the Private Zone Record.
         */
        priority: number;
        /**
         * RecordId of the Private Zone Record.
         */
        recordId: string;
        /**
         * Remark of the Private Zone Record.
         */
        remark: string;
        /**
         * Resource record of the Private Zone Record.
         */
        resourceRecord: string;
        /**
         * Rr of the Private Zone Record.
         */
        rr: string;
        /**
         * Resolve record status. Value:
         * - ENABLE: enable resolution.
         * - DISABLE: pause parsing.
         */
        status: string;
        /**
         * Ttl of the Private Zone Record.
         */
        ttl: number;
        /**
         * Type of the Private Zone Record.
         */
        type: string;
        /**
         * Value of the Private Zone Record.
         */
        value: string;
    }

    export interface GetZonesZone {
        /**
         * List of the VPCs is bound to the Private Zone:
         */
        bindVpcs: outputs.pvtz.GetZonesZoneBindVpc[];
        /**
         * Time of create of the Private Zone.
         */
        createTimestamp: number;
        creationTime: string;
        /**
         * ID of the Private Zone.
         */
        id: string;
        /**
         * Whether the Private Zone is ptr.
         */
        isPtr: boolean;
        /**
         * Name of the Private Zone.
         */
        name: string;
        /**
         * The recursive DNS proxy.
         */
        proxyPattern: string;
        /**
         * Count of the Private Zone Record.
         */
        recordCount: number;
        /**
         * Remark of the Private Zone.
         */
        remark: string;
        /**
         * resource_group_id for zone resourceGroupId.
         */
        resourceGroupId: string;
        /**
         * Whether to turn on secondary DNS.
         */
        slaveDns: boolean;
        updateTime: string;
        /**
         * Time of update of the Private Zone.
         */
        updateTimestamp: number;
        /**
         * ZoneId of the Private Zone.
         */
        zoneId: string;
        /**
         * ZoneName of the Private Zone.
         */
        zoneName: string;
    }

    export interface GetZonesZoneBindVpc {
        /**
         * Binding the regionId of VPC.
         */
        regionId: string;
        /**
         * Binding the regionName of VPC.
         */
        regionName: string;
        /**
         * Binding the vpcId of VPC.
         */
        vpcId: string;
        vpcName: string;
    }

    export interface RuleAttachmentVpc {
        /**
         * The region of the vpc. If not set, the current region will instead of.
         */
        regionId: string;
        /**
         * The ID of the VPC.  **NOTE:** The VPC that can be associated with the forwarding rule must belong to the same region as the Endpoint.
         */
        vpcId: string;
    }

    export interface RuleForwardIp {
        /**
         * The ip of the forwarding destination.
         */
        ip: string;
        /**
         * The port of the forwarding destination.
         */
        port: number;
    }

    export interface ZoneAttachmentVpc {
        /**
         * The region of the vpc. If not set, the current region will instead of.
         *
         * Recommend to use `vpcs`.
         */
        regionId: string;
        /**
         * The Id of the vpc.
         */
        vpcId: string;
    }

    export interface ZoneUserInfo {
        /**
         * The list of the region IDs.
         */
        regionIds?: string[];
        /**
         * The user ID belonging to the region is used for cross-account synchronization scenarios.
         */
        userId?: string;
    }

}

export namespace quickbi {
    export interface GetUsersUser {
        /**
         * Alibaba Cloud account ID.
         */
        accountId: string;
        /**
         * An Alibaba Cloud account, Alibaba Cloud name.
         */
        accountName: string;
        /**
         * Whether it is the administrator. Valid values: `true` and `false`.
         */
        adminUser: boolean;
        /**
         * Whether this is a permissions administrator. Valid values: `true` and `false`.
         */
        authAdminUser: boolean;
        /**
         * The email of the user.
         */
        email: string;
        /**
         * The ID of the User.
         */
        id: string;
        /**
         * The nickname of the user.
         */
        nickName: string;
        /**
         * The phone number of the user.
         */
        phone: string;
        /**
         * The ID of the User.
         */
        userId: string;
        /**
         * The members of the organization of the type of role separately. Valid values: `Analyst`, `Developer` and `Visitor`.
         */
        userType: string;
    }

}

export namespace quotas {
    export interface ApplicationInfoDimension {
        key?: string;
        value?: string;
    }

    export interface GetApplicationInfosApplication {
        applicationId: string;
        approveValue: string;
        auditReason: string;
        desireValue: number;
        dimensions: outputs.quotas.GetApplicationInfosApplicationDimension[];
        effectiveTime: string;
        expireTime: string;
        id: string;
        noticeType: number;
        productCode: string;
        quotaActionCode: string;
        quotaDescription: string;
        quotaName: string;
        quotaUnit: string;
        reason: string;
        status: string;
    }

    export interface GetApplicationInfosApplicationDimension {
        key: string;
        value: string;
    }

    export interface GetApplicationInfosDimension {
        key?: string;
        value?: string;
    }

    export interface GetQuotaAlarmsAlarm {
        /**
         * The first ID of the resource.
         */
        alarmId: string;
        /**
         * The ID of the Quota Alarm.
         */
        id: string;
        /**
         * The Product Code.
         */
        productCode: string;
        /**
         * The Quota Action Code.
         */
        quotaActionCode: string;
        /**
         * The name of Quota Alarm.
         */
        quotaAlarmName: string;
        /**
         * The Quota Dimensions.
         */
        quotaDimensions: outputs.quotas.GetQuotaAlarmsAlarmQuotaDimension[];
        /**
         * The threshold of Quota Alarm.
         */
        threshold: number;
        /**
         * The threshold percent of Quota Alarm.
         */
        thresholdPercent: number;
        /**
         * The WebHook of Quota Alarm.
         */
        webHook: string;
    }

    export interface GetQuotaAlarmsAlarmQuotaDimension {
        /**
         * The key of quota_dimensions.
         */
        key: string;
        /**
         * The value of quota_dimensions.
         */
        value: string;
    }

    export interface GetQuotaAlarmsQuotaDimension {
        /**
         * The key of quota_dimensions.
         */
        key?: string;
        /**
         * The value of quota_dimensions.
         */
        value?: string;
    }

    export interface GetQuotaApplicationsApplication {
        /**
         * The first ID of the resource.
         */
        applicationId: string;
        /**
         * The approve value.
         */
        approveValue: string;
        /**
         * The audit reason.
         */
        auditReason: string;
        /**
         * The desire value of the quota application.
         */
        desireValue: number;
        /**
         * The quota dimensions.
         */
        dimensions: outputs.quotas.GetQuotaApplicationsApplicationDimension[];
        /**
         * The effective time.
         */
        effectiveTime: string;
        /**
         * The expire time.
         */
        expireTime: string;
        /**
         * The ID of the Application Info.
         */
        id: string;
        /**
         * The notice type.
         */
        noticeType: number;
        /**
         * The product code.
         */
        productCode: string;
        /**
         * The ID of quota action..
         */
        quotaActionCode: string;
        /**
         * The description of the quota.
         */
        quotaDescription: string;
        /**
         * The name of the quota.
         */
        quotaName: string;
        /**
         * The quota unit.
         */
        quotaUnit: string;
        /**
         * The reason of the quota application.
         */
        reason: string;
        /**
         * The status of the quota application.
         */
        status: string;
    }

    export interface GetQuotaApplicationsApplicationDimension {
        /**
         * The key of dimensions.
         */
        key: string;
        /**
         * The value of dimensions.
         */
        value: string;
    }

    export interface GetQuotaApplicationsDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

    export interface GetQuotasDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

    export interface GetQuotasQuota {
        /**
         * Is the quota adjustable.
         */
        adjustable: boolean;
        /**
         * The range of quota adjustment.
         */
        applicableRanges: string[];
        /**
         * The type of quota.
         */
        applicableType: string;
        /**
         * Show used quota.
         */
        consumable: boolean;
        /**
         * The ID of the Quota.
         */
        id: string;
        /**
         * The quota action code.
         */
        quotaActionCode: string;
        /**
         * The quota description.
         */
        quotaDescription: string;
        /**
         * The quota name.
         */
        quotaName: string;
        /**
         * The quota type.
         */
        quotaType: string;
        /**
         * The quota unit.
         */
        quotaUnit: string;
        /**
         * TotalQuota.
         */
        totalQuota: number;
        /**
         * The total of usage.
         */
        totalUsage: number;
        /**
         * The unadjustable detail.
         */
        unadjustableDetail: string;
    }

    export interface QuotaAlarmQuotaDimension {
        /**
         * The Key of quota_dimensions.
         */
        key?: string;
        /**
         * The Value of quota_dimensions.
         */
        value?: string;
    }

    export interface QuotaApplicationDimension {
        /**
         * Key.
         */
        key?: string;
        /**
         * Value.
         */
        value?: string;
    }

    export interface TemplateQuotaDimension {
        /**
         * The Key of quota_dimensions.
         */
        key?: string;
        /**
         * The Value of quota_dimensions.
         */
        value?: string;
    }

}

export namespace ram {
    export interface GetGroupsGroup {
        /**
         * Comments of the group.
         */
        comments: string;
        /**
         * Name of the group.
         */
        name: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * Attachment count of the policy.
         */
        attachmentCount: number;
        /**
         * Creation date of the policy.
         */
        createDate: string;
        /**
         * Default version of the policy.
         */
        defaultVersion: string;
        /**
         * Description of the policy.
         */
        description: string;
        /**
         * Policy document of the policy.
         */
        document: string;
        id: string;
        /**
         * Name of the policy.
         */
        name: string;
        /**
         * Policy document of the policy.
         */
        policyDocument: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Filter results by a specific policy type. Valid values are `Custom` and `System`.
         */
        type: string;
        /**
         * Update date of the policy.
         */
        updateDate: string;
        /**
         * Filter results by a specific user name. Returned policies are attached to the specified user.
         */
        userName: string;
        /**
         * The ID of default policy.
         */
        versionId: string;
    }

    export interface GetPolicyDocumentStatement {
        /**
         * Action of the RAM policy document. If you want to create a RAM role policy document, it must be `["sts:AssumeRole"]`.
         */
        actions: string[];
        /**
         * Specifies the condition that are required for a policy to take effect. See the following `Block condition`.
         */
        conditions?: outputs.ram.GetPolicyDocumentStatementCondition[];
        /**
         * This parameter indicates whether or not the `action` is allowed. Valid values are `Allow` and `Deny`. Default value is `Allow`. If you want to create a RAM role policy document, it must be `Allow`.
         */
        effect?: string;
        /**
         * Principal of the RAM policy document. If you want to create a RAM role policy document, it must be set. See the following `Block principal`.
         */
        principals?: outputs.ram.GetPolicyDocumentStatementPrincipal[];
        /**
         * List of specific objects which will be authorized. If you want to create a RAM policy document, it must be set.
         */
        resources?: string[];
    }

    export interface GetPolicyDocumentStatementCondition {
        /**
         * The operator of the condition.
         */
        operator: string;
        /**
         * The values of the condition.
         */
        values: string[];
        /**
         * The variable of the condition.
         */
        variable: string;
    }

    export interface GetPolicyDocumentStatementPrincipal {
        /**
         * The trusted entity. Valid values: `RAM`, `Service` and `Federated`.
         */
        entity: string;
        /**
         * The identifiers of the principal.
         */
        identifiers: string[];
    }

    export interface GetRolesRole {
        /**
         * Resource descriptor of the role.
         */
        arn: string;
        /**
         * Authorization strategy of the role. This parameter is deprecated and replaced by `document`.
         */
        assumeRolePolicyDocument: string;
        /**
         * Creation date of the role.
         */
        createDate: string;
        /**
         * Description of the role.
         */
        description: string;
        /**
         * Authorization strategy of the role.
         */
        document: string;
        /**
         * ID of the role.
         */
        id: string;
        /**
         * Name of the role.
         */
        name: string;
        /**
         * Update date of the role.
         */
        updateDate: string;
    }

    export interface GetSamlProvidersProvider {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the IdP.
         */
        arn: string;
        /**
         * The description of SAML Provider.
         */
        description: string;
        /**
         * The encodedsaml metadata document.
         */
        encodedsamlMetadataDocument: string;
        /**
         * The ID of the SAML Provider.
         */
        id: string;
        /**
         * The saml provider name.
         */
        samlProviderName: string;
        /**
         * The update time.
         */
        updateDate: string;
    }

    export interface GetUsersUser {
        /**
         * Creation date of the user.
         */
        createDate: string;
        /**
         * The original id is user's name, but it is user id in 1.37.0+.
         */
        id: string;
        /**
         * Last login date of the user. Removed from version 1.79.0.
         */
        lastLoginDate: string;
        /**
         * Name of the user.
         */
        name: string;
    }

    export interface PolicyStatement {
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) List of operations for the `resource`. The format of each item in this list is `${service}:${action_name}`, such as `oss:ListBuckets` and `ecs:Describe*`. The `${service}` can be `ecs`, `oss`, `ots` and so on, the `${action_name}` refers to the name of an api interface which related to the `${service}`.
         */
        actions: string[];
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) This parameter indicates whether or not the `action` is allowed. Valid values are `Allow` and `Deny`.
         */
        effect: string;
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) List of specific objects which will be authorized. The format of each item in this list is `acs:${service}:${region}:${account_id}:${relative_id}`, such as `acs:ecs:*:*:instance/inst-002` and `acs:oss:*:1234567890000:mybucket`. The `${service}` can be `ecs`, `oss`, `ots` and so on, the `${region}` is the region info which can use `*` replace when it is not supplied, the `${account_id}` refers to someone's Alicloud account id or you can use `*` to replace, the `${relative_id}` is the resource description section which related to the `${service}`.
         */
        resources: string[];
    }

}

export namespace rdc {
    export interface GetOrganizationsOrganization {
        /**
         * The ID of the Organization.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        organizationId: string;
        /**
         * Company name.
         */
        organizationName: string;
    }

}

export namespace rds {
    export interface DbInstanceEndpointNodeItem {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * The weight of the node. Read requests are distributed based on the weight.Valid values: 0 to 100.
         */
        weight: number;
    }

    export interface DdrInstanceParameter {
        /**
         * The parameter name.
         */
        name: string;
        /**
         * The parameter value.
         */
        value: string;
    }

    export interface DdrInstancePgHbaConf {
        /**
         * The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
         */
        address: string;
        /**
         * The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
         */
        database: string;
        /**
         * The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
         */
        mask: string;
        /**
         * The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
         */
        method: string;
        /**
         * Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
         */
        option: string;
        /**
         * The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
         */
        priorityId: number;
        /**
         * The type of connection to the instance. Valid values:
         * * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
         * * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
         * * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
         *
         * > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
         */
        type: string;
        /**
         * The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
         */
        user: string;
    }

    export interface GetAccountsAccount {
        /**
         * Database description.
         */
        accountDescription: string;
        /**
         * Name of database account.
         */
        accountName: string;
        /**
         * Privilege type of account.
         */
        accountType: string;
        /**
         * A list of database permissions the account has.
         */
        databasePrivileges: outputs.rds.GetAccountsAccountDatabasePrivilege[];
        /**
         * The ID of the Account.
         */
        id: string;
        /**
         * Whether the maximum number of databases managed by the account is exceeded.
         */
        privExceeded: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAccountsAccountDatabasePrivilege {
        /**
         * The type of permission for the account.
         */
        accountPrivilege: string;
        /**
         * The specific permissions corresponding to the type of account permissions.
         */
        accountPrivilegeDetail: string;
        /**
         * Database name.
         */
        dbName: string;
    }

    export interface GetCollationTimeZonesCollationTimeZone {
        /**
         * The code of the instance type.
         */
        description?: string;
        /**
         * The offset of the UTC time. The offset is in the following format: (UTC+<i>HH:mm</i>).
         */
        standardTimeOffset?: string;
        /**
         * The time zone that is available for use in ApsaraDB RDS.
         */
        timeZone?: string;
    }

    export interface GetCrossRegionBackupsBackup {
        /**
         * The time when the cross-region data backup file was generated.
         */
        backupEndTime: string;
        /**
         * The method that is used to generate the cross-region data backup file. Valid values:
         * `L` - logical backup.
         * `P` - physical backup.
         */
        backupMethod: string;
        /**
         * The level at which the cross-region data backup file is generated.
         * `0` - instance-level backup.
         * `1` - database-level backup.
         */
        backupSetScale: string;
        /**
         * TThe status of the cross-region data backup. Valid values:
         * `0` - The cross-region data backup is successful.
         * `1` - The cross-region data backup failed.
         */
        backupSetStatus: number;
        /**
         * The time when the cross-region data backup started.
         */
        backupStartTime: string;
        /**
         * The type of the cross-region data backup. Valid values:F: full data backup
         * `F` - full data backup.
         * `I` - incremental data backup.
         */
        backupType: string;
        /**
         * The RDS edition of the instance. Valid values:
         * `Basic` - Basic Edition.
         * `HighAvailability` - High-availability Edition.
         * `Finance` - Enterprise Edition. This edition is supported only by the China site (aliyun.com).
         */
        category: string;
        /**
         * The point in time that is indicated by the data in the cross-region data backup file.
         */
        consistentTime: string;
        /**
         * The external URL from which you can download the cross-region data backup file.
         */
        crossBackupDownloadLink: string;
        /**
         * The ID of the cross-region data backup file.
         */
        crossBackupId: string;
        /**
         * The ID of the destination region where the cross-region data backup file of the instance is stored.
         */
        crossBackupRegion: string;
        /**
         * The name of the compressed package that contains the cross-region data backup file.
         */
        crossBackupSetFile: string;
        /**
         * The location where the cross-region data backup file is stored.
         */
        crossBackupSetLocation: string;
        /**
         * The size of the cross-region data backup file. Unit: bytes.
         */
        crossBackupSetSize: number;
        /**
         * The storage type.
         */
        dbInstanceStorageType: string;
        /**
         * The engine of the database.
         */
        engine: string;
        /**
         * The version of the database engine.
         */
        engineVersion: string;
        /**
         * The ID of the cross-region data backup file.
         */
        id: string;
        /**
         * The ID of the instance. This parameter is used to determine whether the instance that generates the cross-region data backup file is a primary or secondary instance.
         */
        instanceId: number;
        /**
         * The start time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        recoveryBeginTime: string;
        /**
         * The end time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        recoveryEndTime: string;
        /**
         * An array that consists of the regions to which the cross-region data backup file can be restored.
         */
        restoreRegions: string[];
    }

    export interface GetCrossRegionsRegion {
        /**
         * ID of the region.
         */
        id: string;
    }

    export interface GetInstanceClassInfosInfo {
        /**
         * The code of the instance type.
         */
        classCode?: string;
        /**
         * The instance family of the instance.
         */
        classGroup?: string;
        /**
         * The number of cores that are supported by the instance type. Unit: cores.
         */
        cpu?: string;
        /**
         * The architecture of the instance type.
         */
        instructionSetArch?: string;
        /**
         * The maximum number of connections that are supported by the instance type. Unit: connections.
         */
        maxConnections?: string;
        /**
         * The maximum I/O bandwidth that is supported by the instance type. Unit: Mbit/s.
         */
        maxIombps?: string;
        /**
         * The maximum input/output operations per second (IOPS) that is supported by the instance type. Unit: operations per second.
         */
        maxIops?: string;
        /**
         * The memory capacity that is supported by the instance type. Unit: GB.
         */
        memoryClass?: string;
        /**
         * The fee that you must pay for the instance type. Unit: cent (USD).
         */
        referencePrice?: string;
    }

    export interface GetInstanceClassesInstanceClass {
        /**
         * DB Instance available class.
         */
        instanceClass: string;
        price: string;
        /**
         * DB Instance available storage range.
         */
        storageRange: outputs.rds.GetInstanceClassesInstanceClassStorageRange;
        /**
         * A list of Zone to launch the DB instance.
         */
        zoneIds: outputs.rds.GetInstanceClassesInstanceClassZoneId[];
    }

    export interface GetInstanceClassesInstanceClassStorageRange {
        /**
         * DB Instance available storage max value.
         */
        max: string;
        /**
         * DB Instance available storage min value.
         */
        min: string;
        /**
         * DB Instance available storage increase step.
         */
        step: string;
    }

    export interface GetInstanceClassesInstanceClassZoneId {
        /**
         * The Zone to launch the DB instance
         */
        id: string;
        /**
         * A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `subZoneIds` will be `["cn-beijing-a", "cn-beijing-b"]`.
         */
        subZoneIds: string[];
    }

    export interface GetInstanceEnginesInstanceEngine {
        /**
         * DB Instance category. the value like [`Basic`, `HighAvailability`, `Finance`, `AlwaysOn`], [detail info](https://www.alibabacloud.com/help/doc-detail/69795.htm).
         */
        category: string;
        /**
         * Database type. Valid values: "MySQL", "SQLServer", "PostgreSQL", "MariaDB". If not set, it will match all of engines.
         */
        engine: string;
        /**
         * Database version required by the user. Value options can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/26228.htm) `EngineVersion`.
         */
        engineVersion: string;
        /**
         * A list of Zone to launch the DB instance.
         */
        zoneIds: outputs.rds.GetInstanceEnginesInstanceEngineZoneId[];
    }

    export interface GetInstanceEnginesInstanceEngineZoneId {
        /**
         * The Zone to launch the DB instance
         */
        id: string;
        /**
         * A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `subZoneIds` will be `["cn-beijing-a", "cn-beijing-b"]`.
         */
        subZoneIds: string[];
    }

    export interface GetInstancesInstance {
        /**
         * (Available in 1.124.1+) The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - cert
         * - perfer
         * - verify-ca
         * - verify-full (supported only when the instance runs PostgreSQL 12 or later)
         */
        acl: string;
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * (Available in 1.124.1+) The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - aliyun: a cloud certificate
         * - custom: a custom certificate
         */
        caType: string;
        /**
         * Billing method. Value options: `Postpaid` for Pay-As-You-Go and `Prepaid` for subscription.
         */
        chargeType: string;
        /**
         * (Available in 1.124.1+) The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        clientCaCert: string;
        clientCaCertExpireTime: string;
        /**
         * (Available in 1.124.1+) The certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        clientCertRevocationList: string;
        /**
         * `Standard` for standard access mode and `Safe` for high security access mode.
         */
        connectionMode: string;
        /**
         * (Available in 1.70.3+) RDS database connection string.
         */
        connectionString: string;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * (Available in 1.124.3+) The creator of the encryption key.
         */
        creator: string;
        /**
         * (Available in 1.70.3+) The storage type of the instance.
         */
        dbInstanceStorageType: string;
        /**
         * (Available in 1.197.0+) The type of instance.
         */
        dbInstanceType: string;
        /**
         * `Primary` for primary instance, `Readonly` for read-only instance, `Guard` for disaster recovery instance, and `Temp` for temporary instance.
         */
        dbType: string;
        /**
         * (Available in 1.124.3+) The estimated time when the encryption key will be deleted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        deleteDate: string;
        /**
         * (Available in 1.167.0+) Indicates whether the release protection feature is enabled for the instance. Valid values:
         * * **true**: The release protection feature is enabled.
         * * **false**: The release protection feature is disabled.
         */
        deletionProtection: boolean;
        /**
         * (Available in 1.124.3+) The description of the encryption key.
         */
        description: string;
        /**
         * (Available in 1.124.3+) The ID of the encryption key.
         */
        encryptionKey: string;
        /**
         * (Available in 1.124.3+) The status of the encryption key. Valid values:
         * - Enabled
         * - Disabled
         */
        encryptionKeyStatus: string;
        /**
         * Database type. Options are `MySQL`, `SQLServer`, `PostgreSQL`, `MariaDB`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Database version.
         */
        engineVersion: string;
        /**
         * Expiration time. Pay-As-You-Go instances never expire.
         */
        expireTime: string;
        /**
         * If a disaster recovery instance is attached to the current instance, the ID of the disaster recovery instance applies.
         */
        guardInstanceId: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * (Available in 1.70.3+) User-defined DB instance storage space.
         */
        instanceStorage: number;
        /**
         * Sizing of the RDS instance.
         */
        instanceType: string;
        /**
         * (Available in 1.124.3+) The purpose of the encryption key.
         */
        keyUsage: string;
        /**
         * (Available in 1.124.1+) The status of the SSL link. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - success
         * - setting
         * - failed
         */
        lastModifyStatus: string;
        /**
         * ID of the primary instance. If this parameter is not returned, the current instance is a primary instance.
         */
        masterInstanceId: string;
        /**
         * (Available in 1.101.0+) The master zone of the instance.
         */
        masterZone: string;
        /**
         * (Available in 1.124.3+) The time when the encryption key expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        materialExpireTime: string;
        /**
         * (Available in 1.124.1+) The reason why the SSL link stays in the current state. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        modifyStatusReason: string;
        /**
         * The name of the RDS instance.
         */
        name: string;
        /**
         * `Internet` for public network or `Intranet` for private network.
         */
        netType: string;
        /**
         * (Available in 1.124.3+) The source of the encryption key.
         */
        origin: string;
        /**
         * (Available in 1.135.0+) Parameter list.
         */
        parameters: outputs.rds.GetInstancesInstanceParameter[];
        /**
         * (Available in 1.70.3+) RDS database connection port.
         */
        port: string;
        /**
         * A list of IDs of read-only instances attached to the primary instance.
         */
        readonlyInstanceIds: string[];
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * (Available in 1.124.1+) The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - cert
         * - perfer
         * - verify-ca
         * - verify-full (supported only when the instance runs PostgreSQL 12 or later)
         */
        replicationAcl: string;
        /**
         * (Available in 1.124.1+) Indicates whether the server certificate needs to be updated.
         * - Valid values for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server:
         * - No
         * - Yes
         * - Valid values for ApsaraDB RDS for PostgreSQL:
         * - 0: no
         * - 1: yes
         */
        requireUpdate: string;
        /**
         * (Available in 1.124.1+) The server certificate that needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        requireUpdateItem: string;
        /**
         * (Available in 1.124.1+) The reason why the server certificate needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        requireUpdateReason: string;
        /**
         * (Available in 1.124.1+) The URL of the CA that issues the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverCaUrl: string;
        /**
         * (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverCert: string;
        /**
         * (Available in 1.124.1+) The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverKey: string;
        /**
         * (Available in 1.124.1+) The time when the server certificate was created. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. In addition, this parameter is valid only when the CAType parameter is set to aliyun.
         */
        sslCreateTime: string;
        /**
         * (Available in 1.124.1+) Indicates whether SSL encryption is enabled. Valid values:
         * - on: enabled
         * - off: disabled
         */
        sslEnabled: string;
        /**
         * (Available in 1.124.1+) The time when the server certificate expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        sslExpireTime: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * If a temporary instance is attached to the current instance, the ID of the temporary instance applies.
         */
        tempInstanceId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Used to retrieve instances belong to specified `vswitch` resources.
         */
        vswitchId: string;
        /**
         * (Available in 1.101.0+) The region ID of the secondary instance if you create a secondary instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
         */
        zoneIdSlaveA: string;
        /**
         * (Available in 1.101.0+) The region ID of the log instance if you create a log instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
         */
        zoneIdSlaveB: string;
    }

    export interface GetInstancesInstanceParameter {
        /**
         * The value range of the parameter.
         */
        checkingCode: string;
        /**
         * Indicates whether the parameter can be modified. Valid values: true | false
         */
        forceModify: string;
        /**
         * Indicates whether the modified parameter takes effect only after a database restart. Valid values: true | false
         */
        forceRestart: string;
        /**
         * The description of the parameter.
         */
        parameterDescription: string;
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The default value of the parameter.
         */
        parameterValue: string;
    }

    export interface GetModifyParameterLogsLog {
        /**
         * The time when the parameter was reconfigured. This value is a UNIX timestamp. Unit: milliseconds.
         */
        modifyTime: string;
        /**
         * The new value of the parameter.
         */
        newParameterValue: string;
        /**
         * The original value of the parameter.
         */
        oldParameterValue: string;
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The status of the new value specified for the parameter. Valid values:
         * * **Applied**: The new value has taken effect.
         * * **Syncing**: The new value is being applied and has not taken effect.
         */
        status: string;
    }

    export interface GetRdsBackupsBackup {
        /**
         * The backup download url.
         */
        backupDownloadUrl: string;
        /**
         * BackupEndTime.
         */
        backupEndTime: string;
        /**
         * BackupId.
         */
        backupId: string;
        /**
         * The initiator of the backup task. Value:
         * * **System**: automatically initiated by the System
         * * **User**: manually initiated by the User.
         */
        backupInitiator: string;
        /**
         * The backup intranet download url.
         */
        backupIntranetDownloadUrl: string;
        /**
         * BackupMethod.
         */
        backupMethod: string;
        /**
         * BackupMode.
         */
        backupMode: string;
        /**
         * BackupSize.
         */
        backupSize: string;
        /**
         * BackupStartTime.
         */
        backupStartTime: string;
        /**
         * Backup task status. **NOTE:** This parameter will only be returned when a task is executed. Value:
         * * **NoStart**: Not started
         * * **Checking**: check the backup
         * * **Preparing**: Prepare a backup
         * * **Waiting**: Waiting for backup
         * * **Uploading**: Upload backup
         * * **Finished**: Complete backup
         * * **Failed**: backup Failed
         */
        backupStatus: string;
        /**
         * BackupType.
         */
        backupType: string;
        /**
         * The consistency point of the backup set. The return value is a timestamp. **NOTE:** only MySQL 5.6 returns this parameter, and other versions return 0.
         */
        consistentTime: string;
        /**
         * The backup mode is divided into the normal backup mode (full and incremental recovery is supported) and the replication-only mode (full recovery is supported only). **NOTE:** Only SQL Server returns this parameter. Valid values:
         * * **0**: General Backup Mode
         * * **1**: Copy only mode
         */
        copyOnlyBackup: string;
        /**
         * The db instance id.
         */
        dbInstanceId: string;
        /**
         * The encrypted information of the backup set.
         */
        encryption: string;
        /**
         * HostInstanceID.
         */
        hostInstanceId: string;
        /**
         * The ID of the Backup.
         */
        id: string;
        /**
         * Whether the backup set is available, the value is:
         * * **0**: Not available
         * * **1**: Available.
         */
        isAvail: number;
        /**
         * The backup set status of the database table. **NOTE:** an empty string indicates that the backup set for database table recovery is not enabled. Valid values:
         * * **OK**: normal.
         * * **LARGE**: There are too many tables that cannot be used for database and table recovery.
         * * **EMPTY**: The backup set that failed to be backed up.
         */
        metaStatus: string;
        /**
         * The storage medium for the backup set. Valid values:
         * * **0**: Regular storage
         * * **1**: Archive storage.
         */
        storageClass: string;
        /**
         * StoreStatus.
         */
        storeStatus: string;
    }

    export interface GetRdsParameterGroupsGroup {
        engine: string;
        engineVersion: string;
        forceRestart: number;
        id: string;
        paramCounts: number;
        paramDetails: outputs.rds.GetRdsParameterGroupsGroupParamDetail[];
        parameterGroupDesc: string;
        parameterGroupId: string;
        parameterGroupName: string;
        parameterGroupType: number;
    }

    export interface GetRdsParameterGroupsGroupParamDetail {
        paramName: string;
        paramValue: string;
    }

    export interface GetSlotsSlot {
        /**
         * The name of the database where Replication Slot is located.
         */
        database: string;
        /**
         * The plugin used by Replication Slot.
         */
        plugin: string;
        /**
         * The Replication Slot name.
         */
        slotName: string;
        /**
         * The Replication Slot status.
         */
        slotStatus: string;
        /**
         * The Replication Slot type.
         */
        slotType: string;
        /**
         * Is the Replication Slot temporary.
         */
        temporary: string;
        /**
         * The amount of logs accumulated by Replication Slot.
         */
        walDelay: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceBabelfishConfig {
        /**
         * specifies whether to enable the Babelfish for the instance. If you set this parameter to **true**, you enable Babelfish for the instance. If you leave this parameter empty, you disable Babelfish for the instance.
         */
        babelfishEnabled: string;
        /**
         * The password of the administrator account. The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. It must be 8 to 32 characters in length. The password can contain any of the following characters:! @ # $ % ^ & * () _ + - =
         */
        masterUserPassword: string;
        /**
         * The name of the administrator account. The name can contain lowercase letters, digits, and underscores (_). It must start with a letter and end with a letter or digit. It can be up to 63 characters in length and cannot start with pg.
         */
        masterUsername: string;
        /**
         * The migration mode of the instance. Valid values: **single-db** and **multi-db**.
         */
        migrationMode: string;
    }

    export interface InstanceParameter {
        /**
         * The parameter name.
         */
        name: string;
        /**
         * The parameter value.
         */
        value: string;
    }

    export interface InstancePgHbaConf {
        /**
         * The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
         */
        address: string;
        /**
         * The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
         */
        database: string;
        /**
         * The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
         */
        mask?: string;
        /**
         * The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
         */
        method: string;
        /**
         * Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
         */
        option?: string;
        /**
         * The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
         */
        priorityId: number;
        /**
         * The type of connection to the instance. Valid values:
         * * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
         * * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
         * * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
         *
         * > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
         */
        type: string;
        /**
         * The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
         */
        user: string;
    }

    export interface InstanceServerlessConfig {
        /**
         * Specifies whether to enable the smart startup and stop feature for the serverless instance. Valid values:
         * - true: enables the feature.
         * - false: disables the feature. This is the default value.
         * > - Only MySQL Serverless instances need to set this parameter. If there is no connection within 10 minutes, it will enter a paused state and automatically wake up when the connection enters.
         */
        autoPause?: boolean;
        /**
         * The maximum number of RDS Capacity Units (RCUs). The value of this parameter must be greater than or equal to `minCapacity` and only supports passing integers. Valid values:
         * - MySQL: 1~8
         * - SQLServer: 2~8
         * - PostgreSQL: 1~12
         */
        maxCapacity: number;
        /**
         * The minimum number of RCUs. The value of this parameter must be less than or equal to `maxCapacity`. Valid values:
         * - MySQL: 0.5~8
         * - SQLServer: 2~8 \(Supports integers only\).
         * - PostgreSQL: 0.5~12
         */
        minCapacity: number;
        /**
         * Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
         * - true: enables the feature.
         * - false: disables the feature. This is the default value.
         * > - Only MySQL Serverless instances need to set this parameter. After enabling this parameter, there will be a flash break within 1 minute when the instance is forced to expand or shrink. Please use it with caution according to the actual situation.
         * > - The elastic scaling of an instance RCU usually takes effect immediately, but in some special circumstances (such as during large transaction execution), it is not possible to complete scaling immediately. In this case, this parameter can be enabled to force scaling.
         */
        switchForce?: boolean;
    }

    export interface RdsCloneDbInstanceParameter {
        /**
         * The parameters name.
         */
        name: string;
        /**
         * The parameters value.
         */
        value: string;
    }

    export interface RdsCloneDbInstancePgHbaConf {
        /**
         * The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
         */
        address: string;
        /**
         * The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
         */
        database: string;
        /**
         * The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
         */
        mask?: string;
        /**
         * The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
         */
        method: string;
        /**
         * Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
         */
        option?: string;
        /**
         * The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
         */
        priorityId: number;
        /**
         * The type of connection to the instance. Valid values:
         * * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
         * * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
         * * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
         *
         * > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
         */
        type: string;
        /**
         * The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
         */
        user: string;
    }

    export interface RdsCloneDbInstanceServerlessConfig {
        /**
         * Specifies whether to enable the smart startup and stop feature for the serverless instance. Valid values:
         * - true: enables the feature.
         * - false: disables the feature. This is the default value.
         * > - Only MySQL Serverless instances need to set this parameter. If there is no connection within 10 minutes, it will enter a paused state and automatically wake up when the connection enters.
         */
        autoPause?: boolean;
        /**
         * The maximum number of RDS Capacity Units (RCUs). The value of this parameter must be greater than or equal to `minCapacity` and only supports passing integers. Valid values:
         * - MySQL: 1~8
         * - SQLServer: 2~8
         * - PostgreSQL: 1~12
         */
        maxCapacity: number;
        /**
         * The minimum number of RCUs. The value of this parameter must be less than or equal to `maxCapacity`. Valid values:
         * - MySQL: 0.5~8
         * - SQLServer: 2~8 \(Supports integers only\).
         * - PostgreSQL: 0.5~12
         */
        minCapacity: number;
        /**
         * Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
         * - true: enables the feature.
         * - false: disables the feature. This is the default value.
         * > - Only MySQL Serverless instances need to set this parameter. After enabling this parameter, there will be a flash break within 1 minute when the instance is forced to expand or shrink. Please use it with caution according to the actual situation.
         * > - The elastic scaling of an instance RCU usually takes effect immediately, but in some special circumstances (such as during large transaction execution), it is not possible to complete scaling immediately. In this case, this parameter can be enabled to force scaling.
         */
        switchForce?: boolean;
    }

    export interface RdsDbProxyReadOnlyInstanceWeight {
        /**
         * The Id of instance that can run database.
         */
        instanceId: string;
        weight: string;
    }

    export interface RdsParameterGroupParamDetail {
        /**
         * The name of a parameter.
         */
        paramName: string;
        /**
         * The value of a parameter.
         */
        paramValue: string;
    }

    export interface RdsUpgradeDbInstanceParameter {
        name: string;
        value: string;
    }

    export interface RdsUpgradeDbInstancePgHbaConf {
        /**
         * The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
         */
        address: string;
        /**
         * The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
         */
        database: string;
        /**
         * The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
         */
        mask?: string;
        /**
         * The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
         */
        method: string;
        /**
         * Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
         */
        option?: string;
        /**
         * The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
         */
        priorityId: number;
        /**
         * The type of connection to the instance. Valid values:
         * * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
         * * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
         * * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
         *
         * > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
         */
        type: string;
        /**
         * The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
         */
        user: string;
    }

    export interface ReadOnlyInstanceParameter {
        name: string;
        value: string;
    }

}

export namespace resourcemanager {
    export interface GetAccountDeletionCheckTaskAbandonAbleCheck {
        /**
         * The ID of the check item.
         */
        checkId: string;
        /**
         * The name of the cloud service to which the check item belongs.
         */
        checkName: string;
        /**
         * The description of the check item.
         */
        description: string;
    }

    export interface GetAccountDeletionCheckTaskNotAllowReason {
        /**
         * The ID of the check item.
         */
        checkId: string;
        /**
         * The name of the cloud service to which the check item belongs.
         */
        checkName: string;
        /**
         * The description of the check item.
         */
        description: string;
    }

    export interface GetAccountsAccount {
        /**
         * The ID of the account.
         */
        accountId: string;
        /**
         * (Available in v1.125.0+) The Alibaba Cloud account name of the member account.
         */
        accountName: string;
        /**
         * The name of the member account.
         */
        displayName: string;
        /**
         * The ID of the folder.
         */
        folderId: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The way in which the member account joined the resource directory.
         */
        joinMethod: string;
        /**
         * The time when the member account joined the resource directory.
         */
        joinTime: string;
        /**
         * The time when the member account was modified.
         */
        modifyTime: string;
        /**
         * (Available in v1.124.3+) Settlement account ID. If the value is empty, the current account will be used for settlement.
         */
        payerAccountId: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The status of account, valid values: `CreateCancelled`, `CreateExpired`, `CreateFailed`, `CreateSuccess`, `CreateVerifying`, `InviteSuccess`, `PromoteCancelled`, `PromoteExpired`, `PromoteFailed`, `PromoteSuccess`, and `PromoteVerifying`.
         */
        status: string;
        /**
         * The type of the member account.
         */
        type: string;
    }

    export interface GetControlPoliciesPolicy {
        /**
         * The count of policy attachment.
         */
        attachmentCount: number;
        /**
         * The name of policy.
         */
        controlPolicyName: string;
        /**
         * The description of policy.
         */
        description: string;
        /**
         * The effect scope.
         */
        effectScope: string;
        /**
         * The ID of the Control Policy.
         */
        id: string;
        /**
         * The policy document.
         */
        policyDocument: string;
        /**
         * The ID of policy.
         */
        policyId: string;
        /**
         * The type of policy.
         */
        policyType: string;
    }

    export interface GetControlPolicyAttachmentsAttachment {
        /**
         * The attach date.
         */
        attachDate: string;
        /**
         * The description of policy.
         */
        description: string;
        /**
         * The ID of the Control Policy Attachment.
         */
        id: string;
        /**
         * The ID of policy.
         */
        policyId: string;
        /**
         * The name of policy.
         */
        policyName: string;
        /**
         * The type of policy.
         */
        policyType: string;
    }

    export interface GetDelegatedAdministratorsAdministrator {
        /**
         * The ID of the member account.
         */
        accountId: string;
        /**
         * The time when the member was specified as a delegated administrator account.
         */
        delegationEnabledTime: string;
        /**
         * The ID of the Delegated Administrator.
         */
        id: string;
        /**
         * The identity of the trusted service.
         */
        servicePrincipal: string;
    }

    export interface GetFoldersFolder {
        /**
         * The ID of the folder.
         */
        folderId: string;
        /**
         * The name of the folder.
         */
        folderName: string;
        /**
         * The ID of the folder.
         */
        id: string;
        /**
         * The ID of the parent folder.
         */
        parentFolderId: string;
    }

    export interface GetHandshakesHandshake {
        /**
         * The time when the invitation expires.
         */
        expireTime: string;
        /**
         * The ID of the invitation.
         */
        handshakeId: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * (Available in v1.114.0+) The real name of the invited account.
         */
        invitedAccountRealName: string;
        /**
         * The ID of the master account of the resource directory.
         */
        masterAccountId: string;
        /**
         * The name of the master account of the resource directory.
         */
        masterAccountName: string;
        /**
         * (Available in v1.114.0+) The real name of the master account of the resource directory.
         */
        masterAccountRealName: string;
        /**
         * The time when the invitation was modified.
         */
        modifyTime: string;
        /**
         * The invitation note.
         */
        note: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The status of handshake, valid values: `Accepted`, `Cancelled`, `Declined`, `Deleted`, `Expired` and `Pending`.
         */
        status: string;
        /**
         * The ID or logon email address of the invited account.
         */
        targetEntity: string;
        /**
         * The type of the invited account.
         */
        targetType: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * The number of times the policy is referenced.
         */
        attachmentCount: number;
        /**
         * The default version of the policy.
         */
        defaultVersion: string;
        /**
         * The description of the policy.
         */
        description: string;
        /**
         * The ID of the policy.
         */
        id: string;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The type of the policy. If you do not specify this parameter, the system lists all types of policies. Valid values: `Custom` and `System`.
         */
        policyType: string;
        /**
         * The time when the policy was updated.
         */
        updateDate: string;
    }

    export interface GetPolicyAttachmentsAttachment {
        /**
         * The time when the policy was attached.
         */
        attachDate: string;
        /**
         * The description of the policy.
         */
        description: string;
        /**
         * The ID of the Resource Manager Policy Attachment.
         */
        id: string;
        /**
         * The name of the policy. The name must be 1 to 128 characters in length and can contain letters, digits, and hyphens (-).
         */
        policyName: string;
        /**
         * The type of the policy. Valid values: `Custom` and `System`.
         */
        policyType: string;
        /**
         * The name of the object to which the policy is attached.
         */
        principalName: string;
        /**
         * The type of the object to which the policy is attached. If you do not specify this parameter, the system lists all types of objects. Valid values: `IMSUser`: RAM user, `IMSGroup`: RAM user group, `ServiceRole`: RAM role.
         */
        principalType: string;
        /**
         * The ID of the resource group or the ID of the Alibaba Cloud account to which the resource group belongs. If you do not specify this parameter, the system lists all policy attachment records under the current account.
         */
        resourceGroupId: string;
    }

    export interface GetPolicyVersionsVersion {
        /**
         * The ID of the resource, the value is `<policy_name>`:`<version_id>`.
         */
        id: string;
        /**
         * Indicates whether the policy version is the default version.
         */
        isDefaultVersion: boolean;
        /**
         * (Available in v1.114.0+) The policy document of the policy version.
         */
        policyDocument: string;
        /**
         * The ID of the policy version.
         */
        versionId: string;
    }

    export interface GetResourceDirectoriesDirectory {
        /**
         * The ID of resource directory.
         */
        id: string;
        /**
         * The ID of the master account.
         */
        masterAccountId: string;
        /**
         * The name of the master account.
         */
        masterAccountName: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The ID of the root folder.
         */
        rootFolderId: string;
        /**
         * (Available in 1.120.0+.) The status of the control policy.
         */
        status: string;
    }

    export interface GetResourceGroupsGroup {
        /**
         * The ID of the Alibaba Cloud account to which the resource group belongs.
         */
        accountId: string;
        /**
         * The display name of the resource group.
         */
        displayName: string;
        /**
         * The ID of the resource group.
         */
        id: string;
        /**
         * The unique identifier of the resource group.
         */
        name: string;
        /**
         * (Available in v1.114.0+) The status of the resource group in all regions.
         */
        regionStatuses: outputs.resourcemanager.GetResourceGroupsGroupRegionStatus[];
        /**
         * (Available in v1.114.0+) The unique identifier of the resource group.
         */
        resourceGroupName: string;
        /**
         * The status of the resource group. Possible values:`Creating`,`Deleted`,`Deleting`(Available 1.114.0+) `OK` and `PendingDelete`.
         */
        status: string;
    }

    export interface GetResourceGroupsGroupRegionStatus {
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The status of the resource group. Possible values:`Creating`,`Deleted`,`Deleting`(Available 1.114.0+) `OK` and `PendingDelete`.
         */
        status: string;
    }

    export interface GetResourceSharesShare {
        /**
         * The ID of the Resource Share.
         */
        id: string;
        /**
         * The ID of the resource share.
         */
        resourceShareId: string;
        /**
         * The name of resource share.
         */
        resourceShareName: string;
        /**
         * The owner of resource share.
         */
        resourceShareOwner: string;
        /**
         * The status of resource share.
         */
        status: string;
    }

    export interface GetRolesRole {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the RAM role.
         */
        arn: string;
        /**
         * (Available in v1.114.0+) The assume role policy document.
         */
        assumeRolePolicyDocument: string;
        /**
         * The description of the RAM role.
         */
        description: string;
        /**
         * The ID of the role.
         */
        id: string;
        /**
         * The maximum session duration of the RAM role.
         */
        maxSessionDuration: number;
        /**
         * The ID of the role.
         */
        roleId: string;
        /**
         * The name of the role.
         */
        roleName: string;
        /**
         * The time when the RAM role was updated.
         */
        updateDate: string;
    }

    export interface GetSharedResourcesResource {
        /**
         * The ID of the Shared Resource.
         */
        id: string;
        /**
         * The ID of the shared resource.
         */
        resourceId: string;
        /**
         * The resource share ID of resource manager.
         */
        resourceShareId: string;
        /**
         * The type of shared resource.
         */
        resourceType: string;
        /**
         * The status of shared resource.
         */
        status: string;
    }

    export interface GetSharedTargetsTarget {
        /**
         * The ID of the Shared Target.
         */
        id: string;
        /**
         * The resource shared ID of resource manager.
         */
        resourceShareId: string;
        /**
         * The status of shared target.
         */
        status: string;
        /**
         * The member account ID in resource directory.
         */
        targetId: string;
    }

    export interface ResourceGroupRegionStatus {
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The status of the regional resource group.
         */
        status: string;
    }

}

export namespace rocketmq {
    export interface GetGroupsGroup {
        /**
         * The name of the group.
         */
        groupName: string;
        /**
         * Specify the protocol applicable to the created Group ID. Valid values: `tcp`, `http`. Default to `tcp`.
         */
        groupType: string;
        /**
         * The name of the group.
         */
        id: string;
        /**
         * Indicates whether namespaces are available. Read [Fields in SubscribeInfoDo](https://www.alibabacloud.com/help/doc-detail/29619.html) for further details.
         */
        independentNaming: boolean;
        /**
         * ID of the ONS Instance that owns the groups.
         */
        instanceId: string;
        /**
         * The ID of the group owner, which is the Alibaba Cloud UID.
         */
        owner: string;
        /**
         * Remark of the group.
         */
        remark: string;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
    }

    export interface GetInstancesInstance {
        /**
         * The internal HTTP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternalEndpoint: string;
        /**
         * The public HTTP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternetEndpoint: string;
        /**
         * The public HTTPS endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternetSecureEndpoint: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Indicates whether any namespace is configured for the Message Queue for Apache RocketMQ instance.
         */
        independentNaming: boolean;
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Name of the instance.
         */
        instanceName: string;
        /**
         * The status of the instance. Read [Fields in InstanceVO](https://www.alibabacloud.com/help/doc-detail/106351.html) for further details.
         */
        instanceStatus: number;
        /**
         * The type of the instance. Read [Fields in InstanceVO](https://www.alibabacloud.com/help/doc-detail/106351.html) for further details.
         */
        instanceType: number;
        /**
         * The automatic release time of an Enterprise Platinum Edition instance.
         */
        releaseTime: string;
        /**
         * This attribute is a concise description of instance.
         */
        remark: string;
        /**
         * The status of Ons instance. Valid values: `0` deploying, `2` arrears, `5` running, `7` upgrading.
         */
        status: number;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
        /**
         * The TCP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        tcpEndpoint: string;
    }

    export interface GetTopicsTopic {
        /**
         * The id of the topic.
         */
        id: string;
        /**
         * Indicates whether namespaces are available. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        independentNaming: boolean;
        /**
         * ID of the ONS Instance that owns the topics.
         */
        instanceId: string;
        /**
         * The type of the message. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        messageType: number;
        /**
         * The ID of the topic owner, which is the Alibaba Cloud UID.
         */
        owner: string;
        /**
         * This attribute is used to set the read-write mode for the topic.
         */
        perm: number;
        /**
         * The relation ID. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        relation: number;
        /**
         * The name of the relation, for example, owner, publishable, subscribable, and publishable and subscribable.
         */
        relationName: string;
        /**
         * Remark of the topic.
         */
        remark: string;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
        /**
         * The name of the topic.
         */
        topic: string;
        /**
         * The name of the topic.
         */
        topicName: string;
    }

}

export namespace ros {
    export interface ChangeSetParameter {
        /**
         * The parameter key.
         */
        parameterKey: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface GetChangeSetsSet {
        /**
         * The ID of the change set.
         */
        changeSetId: string;
        /**
         * The name of the change set.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        changeSetName: string;
        /**
         * The type of the change set. Valid values:  CREATE: creates a change set for a new stack. UPDATE: creates a change set for an existing stack. IMPORT: creates a change set for a new stack or an existing stack to import non-ROS-managed resources. If you create a change set for a new stack, ROS creates a stack that has a unique stack ID. The stack is in the REVIEW_IN_PROGRESS state until you execute the change set.  You cannot use the UPDATE type to create a change set for a new stack or the CREATE type to create a change set for an existing stack.
         */
        changeSetType: string;
        /**
         * The description of the change set. The description can be up to 1,024 bytes in length.
         */
        description: string;
        /**
         * Specifies whether to disable rollback on stack creation failure. Default value: false.  Valid values:  true: disables rollback on stack creation failure. false: enables rollback on stack creation failure. Note This parameter takes effect only when ChangeSetType is set to CREATE or IMPORT.
         */
        disableRollback: boolean;
        /**
         * The execution status of change set N. Maximum value of N: 5. Valid values:  UNAVAILABLE AVAILABLE EXECUTE_IN_PROGRESS EXECUTE_COMPLETE EXECUTE_FAILED OBSOLETE.
         */
        executionStatus: string;
        /**
         * The ID of the Change Set.
         */
        id: string;
        /**
         * Parameters.
         */
        parameters: outputs.ros.GetChangeSetsSetParameter[];
        /**
         * The ID of the stack for which you want to create the change set. ROS generates the change set by comparing the stack information with the information that you submit, such as a modified template or different inputs.
         */
        stackId: string;
        /**
         * The name of the stack for which you want to create the change set.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.  Note This parameter takes effect only when ChangeSetType is set to CREATE or IMPORT.
         */
        stackName: string;
        /**
         * The status of the change set.
         */
        status: string;
        /**
         * The structure that contains the template body. The template body must be 1 to 524,288 bytes in length.  If the length of the template body is longer than required, we recommend that you add parameters to the HTTP POST request body to avoid request failures due to excessive length of URLs.  You can specify one of TemplateBody or TemplateURL parameters, but you cannot specify both of them.
         */
        templateBody: string;
        /**
         * Timeout In Minutes.
         */
        timeoutInMinutes: number;
    }

    export interface GetChangeSetsSetParameter {
        /**
         * The parameters.
         */
        parameterKey: string;
        /**
         * The parameters.
         */
        parameterValue: string;
    }

    export interface GetRegionsRegion {
        /**
         * The name of the region.
         */
        localName: string;
        /**
         * The endpoint of the region.
         */
        regionEndpoint: string;
        /**
         * The ID of the region.
         */
        regionId: string;
    }

    export interface GetStackGroupsGroup {
        /**
         * The name of the RAM administrator role assumed by ROS.
         */
        administrationRoleName: string;
        /**
         * The description of the stack group.
         */
        description: string;
        /**
         * The name of the RAM execution role assumed by the administrator role.
         */
        executionRoleName: string;
        /**
         * The ID of the Stack Group.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: outputs.ros.GetStackGroupsGroupParameter[];
        /**
         * The id of Stack Group.
         */
        stackGroupId: string;
        /**
         * The name of the stack group..
         */
        stackGroupName: string;
        /**
         * The status of Stack Group.
         */
        status: string;
        /**
         * The structure that contains the template body.
         */
        templateBody: string;
    }

    export interface GetStackGroupsGroupParameter {
        /**
         * The parameter key.
         */
        parameterKey: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface GetStackInstancesInstance {
        /**
         * The ID of the Stack Instance. The value formats as `<stack_group_name>:<stack_instance_account_id>:<stack_instance_region_id>`.
         */
        id: string;
        /**
         * ParameterOverrides.
         */
        parameterOverrides: outputs.ros.GetStackInstancesInstanceParameterOverride[];
        /**
         * The ID of the stack group.
         */
        stackGroupId: string;
        /**
         * The name of the stack group.
         */
        stackGroupName: string;
        /**
         * The ID of the stack corresponding to the stack instance.
         */
        stackId: string;
        /**
         * The account to which the stack instance belongs.
         */
        stackInstanceAccountId: string;
        /**
         * The region of the stack instance.
         */
        stackInstanceRegionId: string;
        /**
         * The status of the stack instance. Valid values: `CURRENT` or `OUTDATED`.
         */
        status: string;
        /**
         * The reason why the stack is in its current state.
         */
        statusReason: string;
    }

    export interface GetStackInstancesInstanceParameterOverride {
        /**
         * The key of override parameter.
         */
        parameterKey: string;
        /**
         * The value of override parameter.
         */
        parameterValue: string;
    }

    export interface GetStacksStack {
        /**
         * Specifies whether to enable deletion protection on the stack.
         */
        deletionProtection: string;
        /**
         * The Description of the Stack.
         */
        description: string;
        /**
         * Specifies whether to disable rollback on stack creation failure..
         */
        disableRollback: boolean;
        /**
         * Drift DetectionTime.
         */
        driftDetectionTime: string;
        /**
         * The ID of the Stack.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: outputs.ros.GetStacksStackParameter[];
        /**
         * Parent Stack Id.
         */
        parentStackId: string;
        /**
         * The RamRoleName.
         */
        ramRoleName: string;
        /**
         * Root Stack Id.
         */
        rootStackId: string;
        /**
         * Stack DriftStatus.
         */
        stackDriftStatus: string;
        /**
         * Stack Id.
         */
        stackId: string;
        /**
         * Stack Name.
         */
        stackName: string;
        /**
         * The structure that contains the stack policy body.
         */
        stackPolicyBody: string;
        /**
         * The status of Stack. Valid Values: `CREATE_COMPLETE`, `CREATE_FAILED`, `CREATE_IN_PROGRESS`, `DELETE_COMPLETE`, `DELETE_FAILED`, `DELETE_IN_PROGRESS`, `ROLLBACK_COMPLETE`, `ROLLBACK_FAILED`, `ROLLBACK_IN_PROGRESS`.
         */
        status: string;
        /**
         * Status Reason.
         */
        statusReason: string;
        /**
         * Query the instance bound to the tag. The format of the incoming value is `json` string, including `TagKey` and `TagValue`. `TagKey` cannot be null, and `TagValue` can be empty. Format example `{"key1":"value1"}`.
         */
        tags: {[key: string]: any};
        /**
         * Template Description.
         */
        templateDescription: string;
        /**
         * Specifies whether to use the values that were passed last time for the parameters that you do not specify in the current request.
         */
        timeoutInMinutes: number;
    }

    export interface GetStacksStackParameter {
        /**
         * The key of parameters.
         */
        parameterKey: string;
        /**
         * The value of parameters.
         */
        parameterValue: string;
    }

    export interface GetTemplateScratchesScratch {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description of the Template Scratch.
         */
        description: string;
        /**
         * The ID of the Template Scratch.
         */
        id: string;
        /**
         * The Logical ID generation strategy of the Template Scratch.
         */
        logicalIdStrategy: string;
        /**
         * Priority parameter.
         */
        preferenceParameters: outputs.ros.GetTemplateScratchesScratchPreferenceParameter[];
        /**
         * Source resource grouping.
         */
        sourceResourceGroups: outputs.ros.GetTemplateScratchesScratchSourceResourceGroup[];
        /**
         * Source resource.
         */
        sourceResources: outputs.ros.GetTemplateScratchesScratchSourceResource[];
        /**
         * The Source label list.
         */
        sourceTags: outputs.ros.GetTemplateScratchesScratchSourceTag[];
        /**
         * A list of resource stacks associated with the resource scene.
         */
        stacks: outputs.ros.GetTemplateScratchesScratchStack[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the Template Scratch.
         */
        templateScratchId: string;
        /**
         * The type of the Template Scratch.
         */
        templateScratchType: string;
    }

    export interface GetTemplateScratchesScratchPreferenceParameter {
        /**
         * Priority parameter key.
         */
        parameterKey: string;
        /**
         * Priority parameter value.
         */
        parameterValue: string;
    }

    export interface GetTemplateScratchesScratchSourceResource {
        /**
         * The ID of the Source Resource.
         */
        resourceId: string;
        /**
         * The type of the Source resource.
         */
        resourceType: string;
    }

    export interface GetTemplateScratchesScratchSourceResourceGroup {
        /**
         * The ID of the Source Resource Group.
         */
        resourceGroupId: string;
        /**
         * Source resource type filter list.
         */
        resourceTypeFilters: string[];
    }

    export interface GetTemplateScratchesScratchSourceTag {
        /**
         * Source label.
         */
        resourceTags: {[key: string]: any};
        /**
         * Source resource type filter list.
         */
        resourceTypeFilters: string[];
    }

    export interface GetTemplateScratchesScratchStack {
        /**
         * The ID of the Resource stack.
         */
        stackId: string;
    }

    export interface GetTemplatesTemplate {
        /**
         * The ID of the change set.
         */
        changeSetId: string;
        /**
         * The description of the template. The description can be up to 256 characters in length.
         */
        description: string;
        /**
         * The ID of the Template.
         */
        id: string;
        /**
         * Share Type.
         */
        shareType: string;
        /**
         * The name of the stack group. The name must be unique in a region.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        stackGroupName: string;
        /**
         * The ID of the stack.
         */
        stackId: string;
        /**
         * Tags.
         */
        tags: {[key: string]: any};
        /**
         * The structure that contains the template body. The template body must be 1 to 524,288 bytes in length.  If the length of the template body is longer than required, we recommend that you add parameters to the HTTP POST request body to avoid request failures due to excessive length of URLs.  You must specify one of the TemplateBody and TemplateURL parameters, but you cannot specify both of them.
         */
        templateBody: string;
        /**
         * The ID of the template.
         */
        templateId: string;
        /**
         * The name of the template.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        templateName: string;
        /**
         * Template Version.
         */
        templateVersion: string;
    }

    export interface StackGroupParameter {
        /**
         * The parameter key.
         */
        parameterKey?: string;
        /**
         * The parameter value.
         */
        parameterValue?: string;
    }

    export interface StackInstanceParameterOverride {
        /**
         * The key of override parameter. If you do not specify the key and value of the parameter, ROS uses the key and value that you specified when you created the stack group.
         */
        parameterKey?: string;
        /**
         * The value of override parameter. If you do not specify the key and value of the parameter, ROS uses the key and value that you specified when you created the stack group.
         */
        parameterValue?: string;
    }

    export interface StackParameter {
        /**
         * The parameter key.
         */
        parameterKey?: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface TemplateScratchPreferenceParameter {
        /**
         * Priority parameter key. For more information about values, see [supplementary instructions for request parameters](https://www.alibabacloud.com/help/zh/doc-detail/358846.html#h2-url-4).
         */
        parameterKey: string;
        /**
         * Priority parameter value. For more information about values, see [supplementary instructions for request parameters](https://www.alibabacloud.com/help/zh/doc-detail/358846.html#h2-url-4).
         */
        parameterValue: string;
    }

    export interface TemplateScratchSourceResource {
        /**
         * The ID of the Source Resource.
         */
        resourceId: string;
        /**
         * The type of the Source resource.
         */
        resourceType: string;
    }

    export interface TemplateScratchSourceResourceGroup {
        /**
         * The ID of the Source Resource Group.
         */
        resourceGroupId: string;
        /**
         * Source resource type filter list. If the resource type list is specified, it means to scan the resources of the specified resource type and in the specified resource group; Otherwise, it means to scan all resources in the specified resource group. **NOTE:** A maximum of `20` resource type filter can be configured.
         */
        resourceTypeFilters?: string[];
    }

    export interface TemplateScratchSourceTag {
        /**
         * Source label. **NOTE:** A maximum of 10 source labels can be configured.
         */
        resourceTags: {[key: string]: any};
        /**
         * Source resource type filter list. If the resource type list is specified, it means to scan the resources of the specified resource type and in the specified resource group; Otherwise, it means to scan all resources in the specified resource group. **NOTE:** A maximum of `20` resource type filter can be configured.
         */
        resourceTypeFilters?: string[];
    }

}

export namespace sae {
    export interface ApplicationScalingRuleScalingRuleMetric {
        /**
         * Maximum number of instances applied. > **NOTE:** The attribute is valid when the attribute `scalingRuleType` is `mix`.
         */
        maxReplicas?: number;
        /**
         * Indicator rule configuration. See the following `Block metrics`.
         */
        metrics?: outputs.sae.ApplicationScalingRuleScalingRuleMetricMetric[];
        /**
         * Minimum number of instances applied. > **NOTE:** The attribute is valid when the attribute `scalingRuleType` is `mix`.
         */
        minReplicas?: number;
        /**
         * Apply shrink rules. See the following `Block scaleDownRules`.
         */
        scaleDownRules?: outputs.sae.ApplicationScalingRuleScalingRuleMetricScaleDownRules;
        /**
         * Apply expansion rules. See the following `Block scaleUpRules`.
         */
        scaleUpRules?: outputs.sae.ApplicationScalingRuleScalingRuleMetricScaleUpRules;
    }

    export interface ApplicationScalingRuleScalingRuleMetricMetric {
        /**
         * According to different `metricType`, set the target value of the corresponding monitoring index.
         */
        metricTargetAverageUtilization?: number;
        /**
         * Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
         * - CPU: CPU usage.
         * - MEMORY: MEMORY usage.
         * - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
         * - QPS: The average QPS of a single instance within 1 minute of JAVA application.
         * - RT: The average response time of all service interfaces within 1 minute of JAVA application.
         * - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
         * - SLB_RT: The average response time of public network SLB within 15 seconds.
         * - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
         * - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
         * **NOTE:** From version 1.206.0, `metricType` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
         */
        metricType?: string;
        /**
         * SLB ID.
         */
        slbId?: string;
        /**
         * The log store of the Log Service.
         */
        slbLogStore?: string;
        /**
         * The project of the Log Service.
         */
        slbProject?: string;
        /**
         * SLB listening port.
         */
        vport?: string;
    }

    export interface ApplicationScalingRuleScalingRuleMetricScaleDownRules {
        /**
         * Whether shrinkage is prohibited.
         */
        disabled?: boolean;
        /**
         * Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
         */
        stabilizationWindowSeconds?: number;
        /**
         * Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
         */
        step?: number;
    }

    export interface ApplicationScalingRuleScalingRuleMetricScaleUpRules {
        /**
         * Whether shrinkage is prohibited.
         */
        disabled?: boolean;
        /**
         * Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
         */
        stabilizationWindowSeconds?: number;
        /**
         * Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
         */
        step?: number;
    }

    export interface ApplicationScalingRuleScalingRuleTimer {
        /**
         * The Start date. When the `beginDate` and `endDate` values are empty. it indicates long-term execution and is the default value.
         */
        beginDate?: string;
        /**
         * The End Date. When the `beginDate` and `endDate` values are empty. it indicates long-term execution and is the default value.
         */
        endDate?: string;
        /**
         * The period in which a timed elastic scaling strategy is executed.
         */
        period?: string;
        /**
         * Resilient Scaling Strategy Trigger Timing. See the following `Block schedules`.
         */
        schedules?: outputs.sae.ApplicationScalingRuleScalingRuleTimerSchedule[];
    }

    export interface ApplicationScalingRuleScalingRuleTimerSchedule {
        /**
         * Trigger point in time. When supporting format: minutes, for example: `08:00`.
         */
        atTime?: string;
        /**
         * Maximum number of instances applied. > **NOTE:** The attribute is valid when the attribute `scalingRuleType` is `mix`.
         */
        maxReplicas?: number;
        /**
         * Minimum number of instances applied. > **NOTE:** The attribute is valid when the attribute `scalingRuleType` is `mix`.
         */
        minReplicas?: number;
        /**
         * This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scalingRuleType` is `timing`.
         */
        targetReplicas?: number;
    }

    export interface GetApplicationScalingRulesRule {
        /**
         * The ID of the Application.
         */
        appId: string;
        /**
         * The CreateTime of the Application Scaling Rule.
         */
        createTime: string;
        /**
         * The ID of the Application Scaling Rule.
         */
        id: string;
        /**
         * Whether to enable the auto scaling policy.
         */
        scalingRuleEnable: boolean;
        /**
         * Monitoring indicators for elastic scaling.
         */
        scalingRuleMetrics: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetric[];
        /**
         * The name of the scaling rule.
         */
        scalingRuleName: string;
        /**
         * Timing elastic expansion.
         */
        scalingRuleTimers: outputs.sae.GetApplicationScalingRulesRuleScalingRuleTimer[];
        /**
         * Flexible strategy type.
         */
        scalingRuleType: string;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetric {
        /**
         * The maximum number of instances.
         */
        maxReplicas: number;
        /**
         * The auto scaling list of monitoring indicators.
         */
        metrics: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetricMetric[];
        /**
         * Monitor indicator elasticity status.
         */
        metricsStatuses: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatus[];
        /**
         * The minimum number of instances.
         */
        minReplicas: number;
        /**
         * The shrink rule.
         */
        scaleDownRules: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRule[];
        /**
         * The expansion rules.
         */
        scaleUpRules: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRule[];
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetricMetric {
        /**
         * The target value of the monitoring indicator.
         */
        metricTargetAverageUtilization: number;
        /**
         * The metric type of the Application Scaling Rule.
         */
        metricType: string;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatus {
        /**
         * The current monitoring indicator elasticity list.
         */
        currentMetrics: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetric[];
        /**
         * The number of current instances.
         */
        currentReplicas: number;
        /**
         * The number of target instances.
         */
        desiredReplicas: number;
        /**
         * The time of the last elastic expansion.
         */
        lastScaleTime: string;
        /**
         * The maximum number of instances.
         */
        maxReplicas: number;
        /**
         * The minimum number of instances.
         */
        minReplicas: number;
        /**
         * Next monitoring indicator elasticity list
         */
        nextScaleMetrics: outputs.sae.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetric[];
        /**
         * The next cycle of monitoring indicator elasticity.
         */
        nextScaleTimePeriod: number;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetric {
        /**
         * The current value.
         */
        currentValue: number;
        /**
         * The name of the trigger condition.
         */
        name: string;
        /**
         * The metric type. Associated with monitoring indicators.
         */
        type: string;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetric {
        /**
         * The name of the trigger condition.
         */
        name: string;
        /**
         * The percentage value of the monitoring indicator elasticity that triggers the shrinkage condition next time.
         */
        nextScaleInAverageUtilization: number;
        /**
         * The percentage value of the monitoring indicator elasticity that triggers the expansion condition next time.
         */
        nextScaleOutAverageUtilization: number;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRule {
        /**
         * Whether shrinkage is prohibited. The values are described as follows:
         */
        disabled: boolean;
        /**
         * Expansion cooling time.
         */
        stabilizationWindowSeconds: number;
        /**
         * Flexible expansion step. The maximum number of instances per unit time.
         */
        step: number;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRule {
        /**
         * Whether shrinkage is prohibited. The values are described as follows:
         */
        disabled: boolean;
        /**
         * Expansion cooling time.
         */
        stabilizationWindowSeconds: number;
        /**
         * Flexible expansion step. The maximum number of instances per unit time.
         */
        step: number;
    }

    export interface GetApplicationScalingRulesRuleScalingRuleTimer {
        /**
         * The short-term start date of the timed elastic scaling strategy.
         */
        beginDate: string;
        /**
         * The short-term end date of the timed elastic scaling strategy.
         */
        endDate: string;
        /**
         * The period in which a timed elastic scaling strategy is executed.
         */
        period: string;
        /**
         * Trigger point in time within a single day.
         */
        schedules: outputs.sae.GetApplicationScalingRulesRuleScalingRuleTimerSchedule[];
    }

    export interface GetApplicationScalingRulesRuleScalingRuleTimerSchedule {
        /**
         * Time point. Format: `hours:minutes`.
         */
        atTime: string;
        /**
         * The maximum number of instances.
         */
        maxReplicas: number;
        /**
         * The minimum number of instances.
         */
        minReplicas: number;
        /**
         * The number of target instances.
         */
        targetReplicas: number;
    }

    export interface GetApplicationsApplication {
        /**
         * The ARN of the RAM role required when pulling images across accounts.
         */
        acrAssumeRoleArn: string;
        /**
         * The ID of the ACR EE instance.
         */
        acrInstanceId: string;
        /**
         * Application description information. No more than 1024 characters.
         */
        appDescription: string;
        /**
         * Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
         */
        appName: string;
        /**
         * The first ID of the resource.
         */
        applicationId: string;
        /**
         * Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
         */
        command: string;
        /**
         * Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
         */
        commandArgs: string;
        /**
         * ConfigMap mount description.
         */
        configMapMountDesc: string;
        /**
         * The CPU required for each instance, in millicores, cannot be 0.
         */
        cpu: number;
        /**
         * Indicates That the Application of the Creation Time.
         */
        createTime: string;
        /**
         * Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
         */
        customHostAlias: string;
        /**
         * The operating environment used by the Pandora application.
         */
        edasContainerVersion: string;
        /**
         * The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
         */
        envs: string;
        /**
         * The ID of the Application.
         */
        id: string;
        /**
         * Mirror address. Only Image type applications can configure the mirror address.
         */
        imageUrl: string;
        /**
         * The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
         */
        jarStartArgs: string;
        /**
         * The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
         */
        jarStartOptions: string;
        /**
         * The JDK version that the deployment package depends on. Image type applications are not supported.
         */
        jdk: string;
        /**
         * Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
         */
        liveness: string;
        /**
         * The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
         */
        memory: number;
        /**
         * The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
         */
        minReadyInstances: number;
        /**
         * Mount description information.
         */
        mountDescs: outputs.sae.GetApplicationsApplicationMountDesc[];
        /**
         * Mount point of NAS in application VPC.
         */
        mountHost: string;
        /**
         * SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
         */
        namespaceId: string;
        /**
         * ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
         */
        nasId: string;
        /**
         * OSS AccessKey ID.
         */
        ossAkId: string;
        /**
         * OSS  AccessKey Secret.
         */
        ossAkSecret: string;
        /**
         * OSS mount description information.
         */
        ossMountDescs: string;
        /**
         * The OSS mount detail.
         */
        ossMountDetails: outputs.sae.GetApplicationsApplicationOssMountDetail[];
        /**
         * Application package type. Support FatJar, War and Image.
         */
        packageType: string;
        /**
         * Deployment package address. Only FatJar or War type applications can configure the deployment package address.
         */
        packageUrl: string;
        /**
         * The version number of the deployment package. Required when the Package Type is War and FatJar.
         */
        packageVersion: string;
        /**
         * The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
         */
        phpArmsConfigLocation: string;
        /**
         * PHP configuration file content.
         */
        phpConfig: string;
        /**
         * PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
         */
        phpConfigLocation: string;
        /**
         * Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
         */
        postStart: string;
        /**
         * Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
         */
        preStop: string;
        /**
         * Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
         */
        readiness: string;
        regionId: string;
        /**
         * Initial number of instances.
         */
        replicas: number;
        repoName: string;
        repoNamespace: string;
        repoOriginType: string;
        /**
         * Security group ID.
         */
        securityGroupId: string;
        /**
         * SLS  configuration.
         */
        slsConfigs: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
         */
        terminationGracePeriodSeconds: number;
        /**
         * Time zone, the default value is Asia/Shanghai.
         */
        timezone: string;
        /**
         * Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
         */
        tomcatConfig: string;
        /**
         * The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
         */
        warStartOptions: string;
        /**
         * The version of tomcat that the deployment package depends on. Image type applications are not supported.
         */
        webContainer: string;
    }

    export interface GetApplicationsApplicationMountDesc {
        /**
         * The Container mount path.
         */
        mountPath: string;
        /**
         * NAS relative file directory.
         */
        nasPath: string;
    }

    export interface GetApplicationsApplicationOssMountDetail {
        /**
         * The name of the bucket.
         */
        bucketName: string;
        /**
         * The path of the bucket.
         */
        bucketPath: string;
        /**
         * The Container mount path.
         */
        mountPath: string;
        /**
         * Whether the container path has readable permission to mount directory resources.
         */
        readOnly: boolean;
    }

    export interface GetConfigMapsMap {
        /**
         * The first ID of the resource.
         */
        configMapId: string;
        /**
         * The Creation Time of the ConfigMap.
         */
        createTime: string;
        /**
         * ConfigMap instance data. The value's format is a `json` string
         */
        data: string;
        /**
         * The Description of Config Map.
         */
        description: string;
        /**
         * The ID of the Config Map.
         */
        id: string;
        /**
         * ConfigMap instance name.
         */
        name: string;
        /**
         * The NamespaceId of Config Maps.
         */
        namespaceId: string;
    }

    export interface GetGreyTagRoutesRoute {
        /**
         * The description of GreyTagRoute.
         */
        description: string;
        /**
         * The grayscale rule created for Dubbo Application.
         */
        dubboRules: outputs.sae.GetGreyTagRoutesRouteDubboRule[];
        /**
         * The name of GreyTagRoute.
         */
        greyTagRouteName: string;
        /**
         * The ID of the GreyTagRoute.
         */
        id: string;
        /**
         * The grayscale rule created for SpringCloud Application.
         */
        scRules: outputs.sae.GetGreyTagRoutesRouteScRule[];
    }

    export interface GetGreyTagRoutesRouteDubboRule {
        /**
         * The Conditional Patterns for Grayscale Rules.
         */
        condition: string;
        /**
         * The service group.
         */
        group: string;
        /**
         * A list of conditions items.
         */
        items: outputs.sae.GetGreyTagRoutesRouteDubboRuleItem[];
        /**
         * The method name
         */
        methodName: string;
        /**
         * The service name.
         */
        serviceName: string;
        /**
         * The service version.
         */
        version: string;
    }

    export interface GetGreyTagRoutesRouteDubboRuleItem {
        /**
         * The comparison operator.
         */
        cond: string;
        /**
         * The parameter value gets the expression.
         */
        expr: string;
        /**
         * The parameter number.
         */
        index: number;
        /**
         * The operator.
         */
        operator: string;
        /**
         * The value of the parameter.
         */
        value: string;
    }

    export interface GetGreyTagRoutesRouteScRule {
        /**
         * The Conditional Patterns for Grayscale Rules.
         */
        condition: string;
        /**
         * A list of conditions items.
         */
        items: outputs.sae.GetGreyTagRoutesRouteScRuleItem[];
        /**
         * The path corresponding to the grayscale rule.
         */
        path: string;
    }

    export interface GetGreyTagRoutesRouteScRuleItem {
        /**
         * The comparison operator.
         */
        cond: string;
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The operator.
         */
        operator: string;
        /**
         * The Compare types.
         */
        type: string;
        /**
         * The value of the parameter.
         */
        value: string;
    }

    export interface GetIngressesIngress {
        /**
         * Cert Id.
         */
        certId: string;
        /**
         * Default Rule.
         */
        defaultRule: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The ID of the Ingress.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        ingressId: string;
        /**
         * SLB listening port.
         */
        listenerPort: number;
        /**
         * The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
         */
        namespaceId: string;
        /**
         * SLB ID.
         */
        slbId: string;
    }

    export interface GetInstanceSpecificationsSpecification {
        /**
         * CPU Size, Specifications for Micronucleus.
         */
        cpu: number;
        /**
         * Whether the instance is available. The value description is as follows:
         */
        enable: boolean;
        /**
         * The ID of the Instance Specification.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        instanceSpecificationId: string;
        /**
         * The Memory specifications for the MB.
         */
        memory: number;
        /**
         * The specification configuration name.
         */
        specInfo: string;
        /**
         * The specification configuration version.
         */
        version: number;
    }

    export interface GetNamespacesNamespace {
        /**
         * The ID of the Namespace.
         */
        id: string;
        /**
         * The Description of Namespace.
         */
        namespaceDescription: string;
        /**
         * The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
         */
        namespaceId: string;
        /**
         * The Name of Namespace.
         */
        namespaceName: string;
    }

    export interface GreyTagRouteDubboRule {
        /**
         * The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
         */
        condition?: string;
        /**
         * The service group.
         */
        group?: string;
        /**
         * A list of conditions items. The details see Block `dubboRulesItems`.
         */
        items?: outputs.sae.GreyTagRouteDubboRuleItem[];
        /**
         * The method name
         */
        methodName?: string;
        /**
         * The service name.
         */
        serviceName?: string;
        /**
         * The service version.
         */
        version?: string;
    }

    export interface GreyTagRouteDubboRuleItem {
        /**
         * The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
         */
        cond?: string;
        /**
         * The parameter value gets the expression.
         */
        expr?: string;
        /**
         * The parameter number.
         */
        index?: number;
        /**
         * The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministicProportionalSteamingDivision`
         */
        operator?: string;
        /**
         * The value of the parameter.
         */
        value?: string;
    }

    export interface GreyTagRouteScRule {
        /**
         * The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
         */
        condition?: string;
        /**
         * A list of conditions items. The details see Block `scRulesItems`.
         */
        items?: outputs.sae.GreyTagRouteScRuleItem[];
        /**
         * The path corresponding to the grayscale rule.
         */
        path?: string;
    }

    export interface GreyTagRouteScRuleItem {
        /**
         * The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
         */
        cond?: string;
        /**
         * The name of the parameter.
         */
        name?: string;
        /**
         * The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministicProportionalSteamingDivision`
         */
        operator?: string;
        /**
         * The compare types. Valid values: `param`, `cookie`, `header`.
         */
        type?: string;
        /**
         * The value of the parameter.
         */
        value?: string;
    }

    export interface IngressDefaultRule {
        /**
         * Target application ID.
         */
        appId?: string;
        /**
         * Target application name.
         */
        appName?: string;
        /**
         * Application backend port.
         */
        containerPort?: number;
    }

    export interface IngressRule {
        /**
         * Target application ID.
         */
        appId: string;
        /**
         * Target application name.
         */
        appName: string;
        /**
         * The backend protocol.
         */
        backendProtocol?: string;
        /**
         * Application backend port.
         */
        containerPort: number;
        /**
         * Application domain name.
         */
        domain: string;
        /**
         * URL path.
         */
        path: string;
        /**
         * The rewrite path.
         */
        rewritePath?: string;
    }

    export interface LoadBalancerInternetInternet {
        /**
         * The SSL certificate. `httpsCertId` is required when HTTPS is selected
         */
        httpsCertId?: string;
        /**
         * The SLB Port.
         */
        port?: number;
        /**
         * The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
         */
        protocol?: string;
        /**
         * The Container port.
         */
        targetPort?: number;
    }

    export interface LoadBalancerIntranetIntranet {
        /**
         * The SSL certificate. `httpsCertId` is required when HTTPS is selected
         */
        httpsCertId?: string;
        /**
         * The SLB Port.
         */
        port?: number;
        /**
         * The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
         */
        protocol?: string;
        /**
         * The Container port.
         */
        targetPort?: number;
    }

}

export namespace sag {
    export interface GetAclsAcl {
        /**
         * The ID of the ACL. For example "acl-xxx".
         */
        id: string;
        /**
         * The name of the Acl.
         */
        name: string;
    }

    export interface GetSmartagFlowLogsLog {
        /**
         * The time interval at which log data of active connections is collected. Valid values: 60 to 6000. Default value: 300. Unit: second.
         */
        activeAging: number;
        /**
         * The description of the flow log.
         */
        description: string;
        /**
         * The ID of the flow log.
         */
        flowLogId: string;
        /**
         * The name of the flow log.
         */
        flowLogName: string;
        /**
         * The ID of the Flow Log.
         */
        id: string;
        /**
         * The time interval at which log data of inactive connections is connected. Valid values: 10 to 600. Default value: 15. Unit: second.
         */
        inactiveAging: number;
        /**
         * The name of the Log Service Logstore.
         */
        logstoreName: string;
        /**
         * The IP address of the NetFlow collector where the flow log is stored.
         */
        netflowServerIp: string;
        /**
         * The port of the NetFlow collector. Default value: 9995.
         */
        netflowServerPort: number;
        /**
         * The NetFlow version. Default value: V9.
         */
        netflowVersion: string;
        /**
         * The location where the flow log is stored. Valid values:  sls: The flow log is stored in Log Service. netflow: The flow log is stored on a NetFlow collector. all: The flow log is stored both in Log Service and on a NetFlow collector.
         */
        outputType: string;
        /**
         * The name of the Log Service project.
         */
        projectName: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The ID of the region where Log Service is deployed.
         */
        slsRegionId: string;
        /**
         * The status of the flow log. Valid values:  `Active`: The flow log is enabled. `Inactive`: The flow log is disabled.
         */
        status: string;
        /**
         * The number of Smart Access gateway (SAG) instances with which the flow log is associated.
         */
        totalSagNum: number;
    }

}

export namespace scdn {
    export interface DomainCertInfo {
        /**
         * If You Enable HTTPS Here Certificate Name.
         */
        certName?: string;
        /**
         * Certificate Type. Value Range: 
         * * upload: Certificate
         * * cas: Certificate Authority Certificate.
         * * free: Free Certificate.
         */
        certType?: string;
        /**
         * Private Key. Do Not Enable Certificate without Entering a User Name and Configure Certificates Enter Private Key.
         */
        sslPri?: string;
        /**
         * Whether to Enable SSL Certificate. Valid Values: on, off. Valid values: `on`, `off`.
         */
        sslProtocol?: string;
        /**
         * If You Enable HTTPS Here Key.
         */
        sslPub?: string;
    }

    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainSource {
        /**
         * The Back-to-Source Address.
         */
        content: string;
        /**
         * The source status. Valid values: online, offline.
         */
        enabled: string;
        /**
         * Port.
         */
        port: number;
        /**
         * Priority.
         */
        priority: string;
        /**
         * The Origin Server Type. Valid Values: 
         * * ipaddr: IP Source Station
         * * domain: the Domain Name
         * * oss: OSS Bucket as a Source Station.
         */
        type: string;
    }

    export interface GetDomainsDomain {
        /**
         * Certificate Information.
         */
        certInfos: outputs.scdn.GetDomainsDomainCertInfo[];
        /**
         * In Order to Link the CDN Domain Name to Generate a CNAME Domain Name, in the Domain Name Resolution Service Provider at the Acceleration Domain Name CNAME Resolution to the Domain.
         */
        cname: string;
        /**
         * Creation Time.
         */
        createTime: string;
        /**
         * Review the Reason for the Failure Is Displayed.
         */
        description: string;
        /**
         * Your Domain Name.
         */
        domainName: string;
        /**
         * Last Modified Date.
         */
        gmtModified: string;
        /**
         * The ID of the Domain. Its value is same as Queue Name.
         */
        id: string;
        /**
         * The Resource Group ID.
         */
        resourceGroupId: string;
        /**
         * the Origin Server Information.
         */
        sources: outputs.scdn.GetDomainsDomainSource[];
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetDomainsDomainCertInfo {
        /**
         * If You Enable HTTPS Here Certificate Name.
         */
        certName: string;
        /**
         * Certificate Type. Value Range: Upload: Certificate. CAS: Certificate Authority Certificate. Free: Free Certificate.
         */
        certType: string;
        /**
         * Whether to Enable SSL Certificate. Valid Values: on, off.
         */
        sslProtocol: string;
        /**
         * If You Enable HTTPS Here Key.
         */
        sslPub: string;
    }

    export interface GetDomainsDomainSource {
        /**
         * The Back-to-Source Address.
         */
        content: string;
        /**
         * State.
         */
        enabled: string;
        /**
         * Port.
         */
        port: number;
        /**
         * Priority.
         */
        priority: string;
        /**
         * the Origin Server Type. Valid Values: Ipaddr: IP Source Station Domain: the Domain Name, See Extra Domain Quota OSS: OSS Bucket as a Source Station.
         */
        type: string;
    }

}

export namespace schedulerx {
    export interface GetNamespacesNamespace {
        /**
         * The description of the resource.
         */
        description: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The ID of the Namespace.
         */
        namespaceId: string;
        /**
         * The name of the resource.
         */
        namespaceName: string;
    }

}

export namespace sddp {
    export interface GetConfigsConfig {
        /**
         * Abnormal Alarm General Configuration Module by Using the Encoding.Valid values: `accessFailedCnt`, `accessPermissionExprieMaxDays`, `logDatasizeAvgDays`.
         */
        code: string;
        /**
         * Configure the Number.
         */
        configId: string;
        /**
         * Default Value.
         */
        defaultValue: string;
        /**
         * Abnormal Alarm General Description of the Configuration Item.
         */
        description: string;
        /**
         * The ID of the Config.
         */
        id: string;
        /**
         * The Specified Exception Alarm Generic by Using the Value. Code Different Values for This Parameter the Specific Meaning of Different.
         */
        value: string;
    }

    export interface GetDataLimitsLimit {
        /**
         * Whether to enable the log auditing feature.
         */
        auditStatus: number;
        /**
         * The status of the connectivity test between the data asset and SDDP.
         */
        checkStatus: number;
        /**
         * The first ID of the resource.
         */
        dataLimitId: string;
        /**
         * The type of the database.
         */
        engineType: string;
        /**
         * The ID of the Data Limit.
         */
        id: string;
        /**
         * The name of the service to which the data asset belongs.
         */
        localName: string;
        /**
         * The retention period of raw logs after you enable the log auditing feature.
         */
        logStoreDay: number;
        /**
         * The ID of the data asset.
         */
        parentId: string;
        /**
         * The port that is used to connect to the database.
         */
        port: number;
        /**
         * The type of the service to which the data asset belongs.
         */
        resourceType: string;
        /**
         * The name of the user who owns the data asset.
         */
        userName: string;
    }

    export interface GetInstancesInstance {
        /**
         * Whether the required RAM authorization is configured.
         */
        authed: boolean;
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The number of instances.
         */
        instanceNum: string;
        /**
         * Whether the authorized MaxCompute (ODPS) assets.
         */
        odpsSet: boolean;
        /**
         * Whether the authorized oss assets.
         */
        ossBucketSet: boolean;
        /**
         * The OSS size of the instance.
         */
        ossSize: string;
        /**
         * The payment type of the resource. Valid values: `Subscription`.
         */
        paymentType: string;
        /**
         * Whether the authorized rds assets.
         */
        rdsSet: boolean;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetRulesRule {
        /**
         * Sensitive Data Identification Rules for the Type of.
         */
        category: number;
        /**
         * Sensitive Data Identification Rules Belongs Type Name.
         */
        categoryName: string;
        /**
         * Sensitive Data Identification Rules the Content.
         */
        content: string;
        /**
         * The Content Classification.
         */
        contentCategory: string;
        /**
         * Sensitive Data Identification Rules the Creation Time of the Number of Milliseconds.
         */
        createTime: string;
        /**
         * Sensitive Data Identification Rules of Type. 0: the Built-in 1: The User-Defined.
         */
        customType: number;
        /**
         * Sensitive Data Identification a Description of the Rule Information.
         */
        description: string;
        /**
         * Sensitive Data Identification Rules, Founder of Account Display Name.
         */
        displayName: string;
        /**
         * Sensitive Data Identification Rules to the Modified Time of the Number of Milliseconds.
         */
        gmtModified: string;
        /**
         * The ID of the Rule.
         */
        id: string;
        /**
         * Sensitive Data Identification Rules, Founder Of Account Login.
         */
        loginName: string;
        /**
         * The Primary Key.
         */
        majorKey: string;
        /**
         * The name of rule.
         */
        name: string;
        /**
         * Product Code.
         */
        productCode: string;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * Sensitive Data Identification Rules of Risk Level ID. Valid values:1:S1, Weak Risk Level. 2:S2, Medium Risk Level. 3:S3 High Risk Level. 4:S4, the Highest Risk Level.
         */
        riskLevelId: string;
        /**
         * Sensitive Data Identification Rules the Risk Level of. S1: Weak Risk Level S2: Moderate Risk Level S3: High Risk Level S4: the Highest Risk Level.
         */
        riskLevelName: string;
        /**
         * The first ID of the resource.
         */
        ruleId: string;
        /**
         * Triggered the Alarm Conditions.
         */
        statExpress: string;
        /**
         * Sensitive Data Identification Rules Detection State of.
         */
        status: number;
        /**
         * The Target.
         */
        target: string;
        /**
         * The User ID.
         */
        userId: string;
        /**
         * The Level of Risk.
         */
        warnLevel: number;
    }

}

export namespace securitycenter {
    export interface GetGroupsGroup {
        /**
         * GroupFlag, '0' mean default group(created by system), '1' means customer defined group.
         */
        groupFlag: number;
        /**
         * The ID of Group.
         */
        groupId: string;
        /**
         * The name of Group.
         */
        groupName: string;
        /**
         * The ID of the Group(same as the group_id).
         */
        id: string;
    }

}

export namespace servicecatalog {
    export interface GetEndUserProductsEndUserProduct {
        /**
         * Product creation time.According to ISO8601 standard, UTC time is used in the format: YYYY-MM-DDThh:mm:ssZ.
         */
        createTime: string;
        /**
         * Product description.
         */
        description: string;
        /**
         * Whether there is a default Startup option. Value:-true: There is a default Startup option, and there is no need to fill in the portfolio when starting the product or updating the instance.-false: there is no default Startup option. You must fill in the portfolio when starting the product or updating the instance. For more information about how to obtain the portfolio, see ListLaunchOptions.> If the product is added to only one product portfolio, there will be a default Startup option. If the product is added to multiple product combinations, there will be multiple startup options at the same time, but there is no default Startup option at this time.
         */
        hasDefaultLaunchOption: boolean;
        /**
         * ID of product, Its value is the same as `productId`.
         */
        id: string;
        /**
         * Product ARN.
         */
        productArn: string;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * Product name.
         */
        productName: string;
        /**
         * Type of product.The value is Ros, which indicates the resource orchestration service (ROS).
         */
        productType: string;
        /**
         * Product provider.
         */
        providerName: string;
    }

    export interface GetLaunchOptionsLaunchOption {
        /**
         * List of constraints.
         */
        constraintSummaries: outputs.servicecatalog.GetLaunchOptionsLaunchOptionConstraintSummary[];
        /**
         * ID of Service Catalog Launch Option.
         */
        id: string;
        /**
         * Product mix ID.
         */
        portfolioId: string;
        /**
         * Product portfolio name.
         */
        portfolioName: string;
    }

    export interface GetLaunchOptionsLaunchOptionConstraintSummary {
        /**
         * Constraint type.The value is Launch, which indicates that the constraint is started.
         */
        constraintType: string;
        /**
         * Constraint description.
         */
        description: string;
    }

    export interface GetLaunchOptionsOption {
        /**
         * List of constraints.
         */
        constraintSummaries: outputs.servicecatalog.GetLaunchOptionsOptionConstraintSummary[];
        /**
         * ID of Service Catalog Launch Option.
         */
        id: string;
        /**
         * Product mix ID.
         */
        portfolioId: string;
        /**
         * Product portfolio name.
         */
        portfolioName: string;
    }

    export interface GetLaunchOptionsOptionConstraintSummary {
        /**
         * Constraint type.The value is Launch, which indicates that the constraint is started.
         */
        constraintType: string;
        /**
         * Constraint description.
         */
        description: string;
    }

    export interface GetPortfoliosPortfolio {
        /**
         * The creation time of the portfolio
         */
        createTime: string;
        /**
         * The description of the portfolio
         */
        description: string;
        /**
         * The ID of the portfolio
         */
        id: string;
        /**
         * The ARN of the portfolio
         */
        portfolioArn: string;
        /**
         * The ID of the portfolio
         */
        portfolioId: string;
        /**
         * The name of the portfolio
         */
        portfolioName: string;
        /**
         * The provider name of the portfolio
         */
        providerName: string;
    }

    export interface GetProductAsEndUsersUser {
        /**
         * Product creation time.According to ISO8601 standard, UTC time is used in the format: YYYY-MM-DDThh:mm:ssZ.
         */
        createTime: string;
        /**
         * Product description.
         */
        description: string;
        /**
         * Whether there is a default Startup option. Value:-true: There is a default Startup option, and there is no need to fill in the portfolio when starting the product or updating the instance.-false: there is no default Startup option. You must fill in the portfolio when starting the product or updating the instance. > If the product is added to only one product portfolio, there will be a default Startup option. If the product is added to multiple product combinations, there will be multiple startup options at the same time, but there is no default Startup option at this time.
         */
        hasDefaultLaunchOption: boolean;
        /**
         * ID of product, Its value is the same as `productId`.
         */
        id: string;
        /**
         * Product ARN.
         */
        productArn: string;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * Product name.
         */
        productName: string;
        /**
         * Type of product.The value is Ros, which indicates the resource orchestration service (ROS).
         */
        productType: string;
        /**
         * Product provider.
         */
        providerName: string;
    }

    export interface GetProductVersionsProductVersion {
        /**
         * Whether the version is activated
         */
        active: boolean;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * Version description
         */
        description: string;
        /**
         * Administrator guidance
         */
        guidance: string;
        /**
         * ID of product version.
         */
        id: string;
        /**
         * Product ID
         */
        productId: string;
        /**
         * The first ID of the resource
         */
        productVersionId: string;
        /**
         * The name of the resource
         */
        productVersionName: string;
        /**
         * Template Type
         */
        templateType: string;
        /**
         * Template URL
         */
        templateUrl: string;
    }

    export interface GetProductVersionsVersion {
        /**
         * Whether the version is activated
         */
        active: boolean;
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * Version description
         */
        description: string;
        /**
         * Administrator guidance
         */
        guidance: string;
        /**
         * ID of product version.
         */
        id: string;
        /**
         * Product ID
         */
        productId: string;
        /**
         * The first ID of the resource
         */
        productVersionId: string;
        /**
         * The name of the resource
         */
        productVersionName: string;
        /**
         * Template Type
         */
        templateType: string;
        /**
         * Template URL
         */
        templateUrl: string;
    }

    export interface GetProvisionedProductsProduct {
        /**
         * The creation time of the product instance
         */
        createTime: string;
        id: string;
        /**
         * The ID of the last instance operation task
         */
        lastProvisioningTaskId: string;
        /**
         * The ID of the last successful instance operation task
         */
        lastSuccessfulProvisioningTaskId: string;
        /**
         * The ID of the last task
         */
        lastTaskId: string;
        outputs: outputs.servicecatalog.GetProvisionedProductsProductOutput[];
        /**
         * The RAM entity ID of the owner
         */
        ownerPrincipalId: string;
        /**
         * The RAM entity type of the owner
         */
        ownerPrincipalType: string;
        parameters: outputs.servicecatalog.GetProvisionedProductsProductParameter[];
        /**
         * Product mix ID.> When there is a default Startup option, there is no need to fill in the portfolio. When there is no default Startup option, you must fill in the portfolio.
         */
        portfolioId: string;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * The name of the product
         */
        productName: string;
        /**
         * Product version ID.
         */
        productVersionId: string;
        /**
         * The name of the product version
         */
        productVersionName: string;
        /**
         * The ARN of the product instance
         */
        provisionedProductArn: string;
        /**
         * The ID of the instance.
         */
        provisionedProductId: string;
        /**
         * The name of the instance.The length is 1~128 characters.
         */
        provisionedProductName: string;
        /**
         * Instance type.The value is RosStack, which indicates the stack of Alibaba Cloud resource orchestration service (ROS).
         */
        provisionedProductType: string;
        /**
         * The ID of the ROS stack
         */
        stackId: string;
        /**
         * The ID of the region to which the resource stack of the Alibaba Cloud resource orchestration service (ROS) belongs.
         */
        stackRegionId: string;
        /**
         * Instance status
         */
        status: string;
        /**
         * The status message of the product instance
         */
        statusMessage: string;
        tags?: {[key: string]: any};
    }

    export interface GetProvisionedProductsProductOutput {
        description: string;
        outputKey: string;
        outputValue: string;
    }

    export interface GetProvisionedProductsProductParameter {
        parameterKey: string;
        parameterValue: string;
    }

    export interface GetProvisionedProductsProvisionedProduct {
        /**
         * The creation time of the product instance
         */
        createTime: string;
        id: string;
        /**
         * The ID of the last instance operation task
         */
        lastProvisioningTaskId: string;
        /**
         * The ID of the last successful instance operation task
         */
        lastSuccessfulProvisioningTaskId: string;
        /**
         * The ID of the last task
         */
        lastTaskId: string;
        outputs: outputs.servicecatalog.GetProvisionedProductsProvisionedProductOutput[];
        /**
         * The RAM entity ID of the owner
         */
        ownerPrincipalId: string;
        /**
         * The RAM entity type of the owner
         */
        ownerPrincipalType: string;
        parameters: outputs.servicecatalog.GetProvisionedProductsProvisionedProductParameter[];
        /**
         * Product mix ID.> When there is a default Startup option, there is no need to fill in the portfolio. When there is no default Startup option, you must fill in the portfolio.
         */
        portfolioId: string;
        /**
         * Product ID.
         */
        productId: string;
        /**
         * The name of the product
         */
        productName: string;
        /**
         * Product version ID.
         */
        productVersionId: string;
        /**
         * The name of the product version
         */
        productVersionName: string;
        /**
         * The ARN of the product instance
         */
        provisionedProductArn: string;
        /**
         * The ID of the instance.
         */
        provisionedProductId: string;
        /**
         * The name of the instance.The length is 1~128 characters.
         */
        provisionedProductName: string;
        /**
         * Instance type.The value is RosStack, which indicates the stack of Alibaba Cloud resource orchestration service (ROS).
         */
        provisionedProductType: string;
        /**
         * The ID of the ROS stack
         */
        stackId: string;
        /**
         * The ID of the region to which the resource stack of the Alibaba Cloud resource orchestration service (ROS) belongs.
         */
        stackRegionId: string;
        /**
         * Instance status
         */
        status: string;
        /**
         * The status message of the product instance
         */
        statusMessage: string;
        tags?: {[key: string]: any};
    }

    export interface GetProvisionedProductsProvisionedProductOutput {
        description: string;
        outputKey: string;
        outputValue: string;
    }

    export interface GetProvisionedProductsProvisionedProductParameter {
        parameterKey: string;
        parameterValue: string;
    }

    export interface ProvisionedProductOutput {
        /**
         * Description of the output value defined in the template.
         */
        description: string;
        /**
         * The name of the output value defined in the template.
         */
        outputKey: string;
        /**
         * The content of the output value defined in the template.
         */
        outputValue: string;
    }

    export interface ProvisionedProductParameter {
        /**
         * The name of the parameter defined in the template.
         */
        parameterKey?: string;
        /**
         * The Template parameter value entered by the user.
         */
        parameterValue?: string;
    }

}

export namespace servicemesh {
    export interface GetExtensionProvidersProvider {
        /**
         * The config of the Service Mesh Extension Provider.
         */
        config: string;
        /**
         * The name of the Service Mesh Extension Provider.
         */
        extensionProviderName: string;
        /**
         * The ID of the Service Mesh Extension Provider. It formats as `<service_mesh_id>:<type>:<extension_provider_name>`.
         */
        id: string;
        /**
         * The ID of the Service Mesh.
         */
        serviceMeshId: string;
        /**
         * The type of the Service Mesh Extension Provider. Valid values: `httpextauth`, `grpcextauth`.
         */
        type: string;
    }

    export interface GetServiceMeshesMesh {
        /**
         * Cluster List.
         */
        clusters: string[];
        /**
         * The created time of the resource.
         */
        createTime: string;
        /**
         * Grid instance version type. Valid values: `Default` and `Pro`. `Default`:the standard. `Pro`:the Pro version.
         */
        edition: string;
        /**
         * The endpoint details.
         */
        endpoints: outputs.servicemesh.GetServiceMeshesMeshEndpoint[];
        /**
         * The Cause of the Error.
         */
        errorMessage: string;
        /**
         * The ID of the Service Mesh.
         */
        id: string;
        /**
         * The Istio Operator Version. **Note:** the `istioOperatorVersion` is available from the version v1.170.0.
         */
        istioOperatorVersion: string;
        /**
         * The configuration of the Load Balancer.
         */
        loadBalancers: outputs.servicemesh.GetServiceMeshesMeshLoadBalancer[];
        /**
         * The configuration of the Service grid.
         */
        meshConfigs: outputs.servicemesh.GetServiceMeshesMeshMeshConfig[];
        /**
         * The configuration of the Service grid network.
         */
        networks: outputs.servicemesh.GetServiceMeshesMeshNetwork[];
        /**
         * The first ID of the resource.
         */
        serviceMeshId: string;
        /**
         * The name of the resource.
         */
        serviceMeshName: string;
        /**
         * The SideCar Version. **Note:** the `sidecarVersion` is available from the version v1.170.0.
         */
        sidecarVersion: string;
        /**
         * The status of the resource. Valid values: `running` or `initial`.
         */
        status: string;
        /**
         * The version of the resource.
         */
        version: string;
    }

    export interface GetServiceMeshesMeshEndpoint {
        /**
         * The internal address of the API Server.
         */
        intranetApiServerEndpoint: string;
        /**
         * The internal address of the Istio Pilot.
         */
        intranetPilotEndpoint: string;
        /**
         * The public address of the API Server.
         */
        publicApiServerEndpoint: string;
        /**
         * The public address of the Istio Pilot.
         */
        publicPilotEndpoint: string;
    }

    export interface GetServiceMeshesMeshLoadBalancer {
        /**
         * The IP address of a public network exposed API Server corresponding to the Load Balance.
         */
        apiServerLoadbalancerId: string;
        /**
         * Whether to use the IP address of a public network exposed the API Server.
         */
        apiServerPublicEip: boolean;
        /**
         * Whether to use the IP address of a public network exposure the Istio Pilot.
         */
        pilotPublicEip: boolean;
        /**
         * The IP address of a public network exposure Istio Pilot corresponds to the Load Balance.
         */
        pilotPublicLoadbalancerId: string;
    }

    export interface GetServiceMeshesMeshMeshConfig {
        /**
         * The configuration of the access logging.
         */
        accessLogs: outputs.servicemesh.GetServiceMeshesMeshMeshConfigAccessLog[];
        /**
         * The configuration of the Service grid audit.
         */
        audits: outputs.servicemesh.GetServiceMeshesMeshMeshConfigAudit[];
        /**
         * The configuration of the control plane logging. **NOTE:** Available in 1.174.0+
         */
        controlPlaneLogs: outputs.servicemesh.GetServiceMeshesMeshMeshConfigControlPlaneLog[];
        /**
         * Whether or not to enable the use of a custom zipkin.
         */
        customizedZipkin: boolean;
        /**
         * Whether to enable service can access the service through the nearest node access.
         */
        enableLocalityLb: boolean;
        /**
         * The IP ADDRESS range.
         */
        includeIpRanges: string;
        /**
         * The configuration of the Kiali.
         */
        kialis: outputs.servicemesh.GetServiceMeshesMeshMeshConfigKiali[];
        /**
         * The open-door policy of agent (OPA) plug-in information.
         */
        opas: outputs.servicemesh.GetServiceMeshesMeshMeshConfigOpa[];
        /**
         * The policy of the Out to the traffic. Valid values: `ALLOW_ANY` and `REGISTRY_ONLY`.
         */
        outboundTrafficPolicy: string;
        /**
         * The configuration of the Link trace sampling.
         */
        pilots: outputs.servicemesh.GetServiceMeshesMeshMeshConfigPilot[];
        /**
         * the configuration of the Prometheus.
         */
        prometheuses: outputs.servicemesh.GetServiceMeshesMeshMeshConfigPrometheus[];
        /**
         * The configuration of the Proxy.
         */
        proxies: outputs.servicemesh.GetServiceMeshesMeshMeshConfigProxy[];
        /**
         * The configuration of the Sidecar injector.
         */
        sidecarInjectors: outputs.servicemesh.GetServiceMeshesMeshMeshConfigSidecarInjector[];
        /**
         * Whether to enable acquisition Prometheus metrics.
         */
        telemetry: boolean;
        /**
         * Whether to enable link trace.
         */
        tracing: boolean;
    }

    export interface GetServiceMeshesMeshMeshConfigAccessLog {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The Service grid audit that to the project.
         */
        project: string;
    }

    export interface GetServiceMeshesMeshMeshConfigAudit {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The Service grid audit that to the project.
         */
        project: string;
    }

    export interface GetServiceMeshesMeshMeshConfigControlPlaneLog {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The Service grid audit that to the project.
         */
        project: string;
    }

    export interface GetServiceMeshesMeshMeshConfigKiali {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The service address of the Kiali.
         */
        url: string;
    }

    export interface GetServiceMeshesMeshMeshConfigOpa {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitCpu: string;
        /**
         * The memory limit  of the Sidecar injector Pods.
         */
        limitMemory: string;
        /**
         * The log level of the OPA proxy container .
         */
        logLevel: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface GetServiceMeshesMeshMeshConfigPilot {
        /**
         * Whether to support the HTTP1.0.
         */
        http10Enabled: boolean;
        /**
         * The  percentage of the Link trace sampling.
         */
        traceSampling: number;
    }

    export interface GetServiceMeshesMeshMeshConfigPrometheus {
        /**
         * The  service addresses of the Prometheus.
         */
        externalUrl: string;
        /**
         * Whether to enable external Prometheus.
         */
        useExternal: boolean;
    }

    export interface GetServiceMeshesMeshMeshConfigProxy {
        /**
         * The domain name of the Cluster.
         */
        clusterDomain: string;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitCpu: string;
        /**
         * The memory limit  of the Sidecar injector Pods.
         */
        limitMemory: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface GetServiceMeshesMeshMeshConfigSidecarInjector {
        /**
         * Whether to enable by Pod Annotations automatic injection Sidecar.
         */
        autoInjectionPolicyEnabled: boolean;
        /**
         * Whether it is the all namespaces you turn on the auto injection capabilities.
         */
        enableNamespacesByDefault: boolean;
        /**
         * The configuration of the CNI
         */
        initCniConfigurations: outputs.servicemesh.GetServiceMeshesMeshMeshConfigSidecarInjectorInitCniConfiguration[];
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitCpu: string;
        /**
         * The memory limit  of the Sidecar injector Pods.
         */
        limitMemory: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
        /**
         * Other automatic injection Sidecar configuration (in YAML format).
         */
        sidecarInjectorWebhookAsYaml: string;
    }

    export interface GetServiceMeshesMeshMeshConfigSidecarInjectorInitCniConfiguration {
        /**
         * Whether to enable Service grid audit.
         */
        enabled: boolean;
        /**
         * The excluded namespace of the CNI.
         */
        excludeNamespaces: string;
    }

    export interface GetServiceMeshesMeshNetwork {
        /**
         * The ID of the Security group
         */
        securityGroupId: string;
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The list of Virtual Switch.
         */
        vswitcheLists: string[];
    }

    export interface GetVersionsVersion {
        /**
         * The edition of the ASM instance.
         */
        edition: string;
        /**
         * The ASM version id. It formats as `<edition>:<version>`.
         */
        id: string;
        /**
         * The AMS version.
         */
        version: string;
    }

    export interface ServiceMeshExtraConfiguration {
        /**
         * Indicates whether the Kubernetes API of clusters on the data plane is used to access Istio resources. A value of `true` indicates that the Kubernetes API is used.
         */
        crAggregationEnabled: boolean;
    }

    export interface ServiceMeshLoadBalancer {
        apiServerLoadbalancerId: string;
        /**
         * Whether to use the IP address of a public network exposed the API Server.
         */
        apiServerPublicEip: boolean;
        /**
         * Whether to use the IP address of a public network exposure the Istio Pilot.
         */
        pilotPublicEip: boolean;
        pilotPublicLoadbalancerId: string;
    }

    export interface ServiceMeshMeshConfig {
        /**
         * The configuration of the access logging.
         */
        accessLog: outputs.servicemesh.ServiceMeshMeshConfigAccessLog;
        /**
         * The configuration of the audit. See the following `Block audit`.
         */
        audit: outputs.servicemesh.ServiceMeshMeshConfigAudit;
        /**
         * The configuration of the control plane logging.
         */
        controlPlaneLog: outputs.servicemesh.ServiceMeshMeshConfigControlPlaneLog;
        /**
         * Whether to enable the use of a custom zipkin.
         */
        customizedZipkin: boolean;
        /**
         * The enable locality lb.
         */
        enableLocalityLb: boolean;
        /**
         * The configuration of the Kiali. See the following `Block kiali`.
         */
        kiali: outputs.servicemesh.ServiceMeshMeshConfigKiali;
        /**
         * The open-door policy of agent (OPA) plug-in information. See the following `Block opa`.
         */
        opa: outputs.servicemesh.ServiceMeshMeshConfigOpa;
        /**
         * The policy of the Out to the traffic. Valid values: `ALLOW_ANY` and `REGISTRY_ONLY`.
         */
        outboundTrafficPolicy: string;
        /**
         * The configuration of the Link trace sampling. See the following `Block pilot`.
         */
        pilot: outputs.servicemesh.ServiceMeshMeshConfigPilot;
        /**
         * The configuration of the Proxy. See the following `Block proxy`.
         */
        proxy: outputs.servicemesh.ServiceMeshMeshConfigProxy;
        /**
         * The configuration of the Sidecar injector. See the following `Block sidecarInjector`.
         */
        sidecarInjector: outputs.servicemesh.ServiceMeshMeshConfigSidecarInjector;
        /**
         * Whether to enable acquisition Prometheus metrics (it is recommended that you use [Alibaba Cloud Prometheus monitoring](https://arms.console.aliyun.com/).
         */
        telemetry: boolean;
        /**
         * Whether to enable link trace (you need to have [Alibaba Cloud link tracking service](https://tracing-analysis.console.aliyun.com/).
         */
        tracing: boolean;
    }

    export interface ServiceMeshMeshConfigAccessLog {
        /**
         * Whether to enable of the access logging. Valid values: `true` and `false`.
         */
        enabled: boolean;
        /**
         * The SLS Project of the access logging.
         */
        project?: string;
    }

    export interface ServiceMeshMeshConfigAudit {
        /**
         * Whether to enable of the access logging. Valid values: `true` and `false`.
         */
        enabled: boolean;
        /**
         * The SLS Project of the access logging.
         */
        project: string;
    }

    export interface ServiceMeshMeshConfigControlPlaneLog {
        /**
         * Whether to enable of the access logging. Valid values: `true` and `false`.
         */
        enabled: boolean;
        /**
         * The SLS Project of the access logging.
         */
        project?: string;
    }

    export interface ServiceMeshMeshConfigKiali {
        /**
         * Whether to enable of the access logging. Valid values: `true` and `false`.
         */
        enabled: boolean;
    }

    export interface ServiceMeshMeshConfigOpa {
        /**
         * Whether to enable of the access logging. Valid values: `true` and `false`.
         */
        enabled: boolean;
        /**
         * The limit cpu of the Sidecar injector Pods.
         */
        limitCpu: string;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitMemory: string;
        /**
         * The log level of the OPA proxy container .
         */
        logLevel: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface ServiceMeshMeshConfigPilot {
        /**
         * Whether to support the HTTP1.0.
         */
        http10Enabled: boolean;
        /**
         * The  percentage of the Link trace sampling.
         */
        traceSampling?: number;
    }

    export interface ServiceMeshMeshConfigProxy {
        /**
         * The limit cpu of the Sidecar injector Pods.
         */
        limitCpu: string;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitMemory: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface ServiceMeshMeshConfigSidecarInjector {
        /**
         * Whether to enable by Pod Annotations automatic injection Sidecar.
         */
        autoInjectionPolicyEnabled: boolean;
        /**
         * Whether it is the all namespaces you turn on the auto injection capabilities.
         */
        enableNamespacesByDefault: boolean;
        /**
         * The limit cpu of the Sidecar injector Pods.
         */
        limitCpu: string;
        /**
         * Sidecar injector Pods on the throttle.
         */
        limitMemory: string;
        /**
         * The requested cpu the Sidecar injector Pods.
         */
        requestCpu: string;
        /**
         * The requested memory the Sidecar injector Pods.
         */
        requestMemory: string;
    }

    export interface ServiceMeshNetwork {
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The list of Virtual Switch.
         */
        vswitcheList: string;
    }

    export interface UserPermissionPermission {
        /**
         * Whether the grant object is a RAM role.
         */
        isCustom: boolean;
        /**
         * Whether the grant object is an entity.
         */
        isRamRole: boolean;
        /**
         * The permission name. Valid values: `istio-admin`, `istio-ops`, `istio-readonly`.
         * - `istio-admin`:  The administrator.
         * - `istio-ops`: The administrator of the service mesh resource.
         * - `istio-readonly`: The read only permission.
         */
        roleName: string;
        /**
         * The role type. Valid Value: `custom`.
         */
        roleType: string;
        /**
         * The service mesh id.
         */
        serviceMeshId: string;
    }

}

export namespace simpleapplicationserver {
    export interface GetImagesImage {
        /**
         * The description of the image.
         */
        description: string;
        /**
         * The ID of the Instance Image.
         */
        id: string;
        /**
         * The ID of the image.
         */
        imageId: string;
        /**
         * The name of the resource.
         */
        imageName: string;
        /**
         * The type of the image. Valid values: `app`, `custom`, `system`.
         */
        imageType: string;
        /**
         * The platform of Plan supported.
         */
        platform: string;
    }

    export interface GetInstancesInstance {
        /**
         * The billing status of the simple application server. Valid values: `Normal`, `Expired` and `Overdue`.
         */
        businessStatus: string;
        /**
         * The time when the simple application server was created.
         */
        createTime: string;
        /**
         * The DDoS protection status. Valid values: `Normal`, `BlackHole`, and `Defense`.
         */
        ddosStatus: string;
        /**
         * The time when the simple application server expires.
         */
        expiredTime: string;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The ID of the simple application server Image.
         */
        imageId: string;
        /**
         * The internal IP address of the simple application server.
         */
        innerIpAddress: string;
        /**
         * The ID of the simple application server.
         */
        instanceId: string;
        /**
         * The name of the resource.
         */
        instanceName: string;
        /**
         * The billing method of the simple application server.
         */
        paymentType: string;
        /**
         * The ID of the simple application server plan.
         */
        planId: string;
        /**
         * The public IP address of the simple application server.
         */
        publicIpAddress: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetServerCustomImagesImage {
        /**
         * The first ID of the resource.
         */
        customImageId: string;
        /**
         * The name of the resource.
         */
        customImageName: string;
        /**
         * Image description information.
         */
        description: string;
        /**
         * The ID of the Custom Image.
         */
        id: string;
        /**
         * The type of operating system used by the Mirror. Valid values: `Linux`, `Windows`.
         */
        platform: string;
    }

    export interface GetServerDisksDisk {
        /**
         * Disk type. Possible values: `ESSD`, `SSD`.
         */
        category: string;
        /**
         * The time when the disk was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The device name of the disk on the simple application server.
         */
        device: string;
        /**
         * The first ID of the resource.
         */
        diskId: string;
        /**
         * The name of the resource.
         */
        diskName: string;
        /**
         * The type of the disk. Possible values: `System`, `Data`.
         */
        diskType: string;
        /**
         * The ID of the Disk.
         */
        id: string;
        /**
         * Alibaba Cloud simple application server instance ID.
         */
        instanceId: string;
        /**
         * The payment type of the resource. Valid values: `PayAsYouGo`, `Subscription`.
         */
        paymentType: string;
        /**
         * The size of the disk. Unit: `GB`.
         */
        size: number;
        /**
         * The status of the disk. Valid values: `ReIniting`, `Creating`, `In_Use`, `Available`, `Attaching`, `Detaching`.
         */
        status: string;
    }

    export interface GetServerFirewallRulesRule {
        /**
         * The ID of the firewall rule.
         */
        firewallRuleId: string;
        /**
         * The ID of the Firewall Rule. The value formats as `<instance_id>:<firewall_rule_id>`.
         */
        id: string;
        /**
         * Alibaba Cloud simple application server instance ID.
         */
        instanceId: string;
        /**
         * The port range of the firewall rule.
         */
        port: string;
        /**
         * The remarks of the firewall rule.
         */
        remark: string;
        /**
         * The transport layer protocol. Valid values: `Tcp`, `Udp`, `TcpAndUdp`.
         */
        ruleProtocol: string;
    }

    export interface GetServerPlansPlan {
        /**
         * The peak bandwidth. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * The number of CPU cores.
         */
        core: number;
        /**
         * The size of the enhanced SSD (ESSD). Unit: GB.
         */
        diskSize: number;
        /**
         * The monthly data transfer quota. Unit: GB.
         */
        flow: number;
        /**
         * The ID of the Instance Plan.
         */
        id: string;
        /**
         * The memory size. Unit: GB.
         */
        memory: number;
        /**
         * The ID of the Instance Plan.
         */
        planId: string;
        /**
         * The platform of Plan supported.
         */
        supportPlatform: string;
    }

    export interface GetServerSnapshotsSnapshot {
        /**
         * The time when the snapshot was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
         */
        createTime: string;
        /**
         * The ID of the source disk. This parameter has a value even after the source disk is released.
         */
        diskId: string;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * The progress of snapshot creation.
         */
        progress: string;
        /**
         * The remarks of the snapshot.
         */
        remark: string;
        /**
         * The ID of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * A snapshot of the source of a disk type. Possible values: `System`, `Data`.
         */
        sourceDiskType: string;
        /**
         * The status of the snapshots. Valid values: `Progressing`, `Accomplished` and `Failed`.
         */
        status: string;
    }

}

export namespace slb {
    export interface AclEntryList {
        comment: string;
        entry: string;
    }

    export interface BackendServerBackendServer {
        serverId: string;
        serverIp: string;
        type?: string;
        weight: number;
    }

    export interface GetAclsAcl {
        /**
         * A list of entry (IP addresses or CIDR blocks).  Each entry contains two sub-fields as `Entry Block` follows.
         */
        entryLists: outputs.slb.GetAclsAclEntryList[];
        /**
         * Acl ID.
         */
        id: string;
        ipVersion: string;
        /**
         * Acl name.
         */
        name: string;
        /**
         * A list of listener are attached by the acl.  Each listener contains four sub-fields as `Listener Block` follows.
         */
        relatedListeners: outputs.slb.GetAclsAclRelatedListener[];
        /**
         * The Id of resource group which acl belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetAclsAclEntryList {
        comment: string;
        entry: string;
    }

    export interface GetAclsAclRelatedListener {
        aclType: string;
        frontendPort: number;
        loadBalancerId: string;
        protocol: string;
    }

    export interface GetApplicationLoadBalancersBalancer {
        /**
         * Service address of the SLBs.
         */
        address: string;
        /**
         * The address ip version. Valid values `ipv4` and `ipv6`.
         */
        addressIpVersion: string;
        /**
         * The address type of the SLB. Valid values `internet` and `intranet`.
         */
        addressType: string;
        /**
         * The auto release time.
         */
        autoReleaseTime: number;
        /**
         * The backend servers of the SLB.
         */
        backendServers: outputs.slb.GetApplicationLoadBalancersBalancerBackendServer[];
        /**
         * The bandwidth of the SLB.
         */
        bandwidth: number;
        /**
         * The create time stamp of the SLB.
         */
        createTimeStamp: number;
        /**
         * Whether the SLB should delete protection.
         */
        deleteProtection: string;
        /**
         * The end time of the SLB.
         */
        endTime: string;
        /**
         * The end time stamp of the SLB.
         */
        endTimeStamp: number;
        /**
         * ID of the SLB.
         */
        id: string;
        /**
         * The internet charge type. Valid values `PayByBandwidth` and `PayByTraffic`.
         */
        internetChargeType: string;
        /**
         * The listener ports and protocal of the SLB.
         */
        listenerPortsAndProtocals: outputs.slb.GetApplicationLoadBalancersBalancerListenerPortsAndProtocal[];
        /**
         * The listener ports and protocol of the SLB.
         */
        listenerPortsAndProtocols: outputs.slb.GetApplicationLoadBalancersBalancerListenerPortsAndProtocol[];
        /**
         * Thd ID of the SLB.
         */
        loadBalancerId: string;
        /**
         * The name of the SLB.
         */
        loadBalancerName: string;
        /**
         * The specification of the SLB.
         */
        loadBalancerSpec: string;
        /**
         * The master zone id of the SLB.
         */
        masterZoneId: string;
        /**
         * The reason of modification protection.
         */
        modificationProtectionReason: string;
        /**
         * The status of modification protection.
         */
        modificationProtectionStatus: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        /**
         * The payment type of SLB. Valid values `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * Region ID the SLB belongs to.
         */
        regionIdAlias: string;
        /**
         * The renewal cyc unit of the SLB.
         */
        renewalCycUnit: string;
        /**
         * The renewal duration of the SLB.
         */
        renewalDuration: number;
        /**
         * The renewal status of the SLB.
         */
        renewalStatus: string;
        /**
         * The Id of resource group which SLB belongs.
         */
        resourceGroupId: string;
        /**
         * The slave zone id of the SLB.
         */
        slaveZoneId: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetApplicationLoadBalancersBalancerBackendServer {
        /**
         * The description of protocol.
         */
        description: string;
        /**
         * The server ID.
         */
        serverId: string;
        /**
         * The type of servers.
         */
        type: string;
        /**
         * The weight of servers.
         */
        weight: number;
    }

    export interface GetApplicationLoadBalancersBalancerListenerPortsAndProtocal {
        /**
         * The listener port.
         */
        listenerPort: number;
        /**
         * The listener protoal.
         */
        listenerProtocal: string;
    }

    export interface GetApplicationLoadBalancersBalancerListenerPortsAndProtocol {
        /**
         * The description of protocol.
         */
        description: string;
        /**
         * The forward port.
         */
        forwardPort: number;
        /**
         * The listener forward.
         */
        listenerForward: string;
        /**
         * The listener port.
         */
        listenerPort: number;
        /**
         * The listener protocol.
         */
        listenerProtocol: string;
    }

    export interface GetApplicationLoadBalancersSlb {
        /**
         * Service address of the SLBs.
         */
        address: string;
        creationTime: string;
        /**
         * ID of the SLB.
         */
        id: string;
        internet: boolean;
        masterAvailabilityZone: string;
        name: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        regionId: string;
        slaveAvailabilityZone: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetAttachmentsSlbAttachment {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetBackendServersBackendServer {
        /**
         * backend server ID.
         */
        id: string;
        /**
         * Type of the backend server.
         */
        serverType: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetCaCertificatesCertificate {
        /**
         * (Available in v1.123.1+) CA certificate ID.
         */
        caCertificateId: string;
        /**
         * (Available in v1.123.1+) CA certificate name.
         */
        caCertificateName: string;
        /**
         * CA certificate common name.
         */
        commonName: string;
        /**
         * CA certificate created timestamp.
         */
        createdTimestamp: number;
        /**
         * CA certificate expired time.
         */
        expiredTime: string;
        /**
         * CA certificate expired timestamp.
         */
        expiredTimestamp: number;
        /**
         * CA certificate fingerprint.
         */
        fingerprint: string;
        /**
         * CA certificate ID.
         */
        id: string;
        /**
         * (Deprecated from v1.123.1) Deprecated and replace by `caCertificateName`.
         */
        name: string;
        /**
         * The Id of resource group which ca certificates belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetDomainExtensionsExtension {
        /**
         * The domain name.
         */
        domain: string;
        /**
         * The ID of the domain extension.
         */
        id: string;
        /**
         * The ID of the certificate used by the domain name.
         */
        serverCertificateId: string;
    }

    export interface GetListenersSlbListener {
        /**
         * Port opened on the backend server to receive requests.
         */
        backendPort: number;
        /**
         * Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
         */
        bandwidth: number;
        /**
         * ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
         */
        caCertificateId: string;
        /**
         * Cookie configured by the backend server. Only available when the stickySessionType is `server`.
         */
        cookie: string;
        /**
         * Cookie timeout in seconds. Only available when the stickySessionType is `insert`.
         */
        cookieTimeout: number;
        /**
         * The description of slb listener.
         */
        description: string;
        /**
         * Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
         */
        enableHttp2: string;
        /**
         * Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
         */
        establishedTimeout: number;
        /**
         * Filter listeners by the specified frontend port.
         */
        frontendPort: number;
        /**
         * Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        gzip: string;
        /**
         * Indicate whether health check is enabled of not. Possible values are `on` and `off`.
         */
        healthCheck: string;
        /**
         * Port used for health check.
         */
        healthCheckConnectPort: number;
        /**
         * Amount of time in seconds to wait for the response for a health check.
         */
        healthCheckConnectTimeout: number;
        /**
         * Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckDomain: string;
        /**
         * HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as "http_2xx,http_3xx". Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckHttpCode: string;
        /**
         * Time interval between two consecutive health checks.
         */
        healthCheckInterval: number;
        /**
         * Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
         */
        healthCheckTimeout: number;
        /**
         * Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
         */
        healthCheckType: string;
        /**
         * URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckUri: string;
        /**
         * Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
         */
        healthyThreshold: number;
        /**
         * Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
         */
        idleTimeout: number;
        /**
         * ID of the active/standby server group.
         */
        masterSlaveServerGroupId: string;
        /**
         * Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
         */
        persistenceTimeout: number;
        /**
         * Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
         */
        protocol: string;
        /**
         * Whether to support carrying the client source address to the backend server through the Proxy Protocol. Valid values are `true` and `false`. Default to `false`.
         */
        proxyProtocolV2Enabled: boolean;
        /**
         * Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
         */
        requestTimeout: number;
        /**
         * Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
         */
        scheduler: string;
        /**
         * Security status. Only available when the protocol is `https`.
         */
        securityStatus: string;
        serverCertificateId: string;
        /**
         * ID of the linked VServer group.
         */
        serverGroupId: string;
        /**
         * ID of the server certificate. Only available when the protocol is `https`.
         */
        sslCertificateId: string;
        /**
         * Listener status.
         */
        status: string;
        /**
         * Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        stickySession: string;
        /**
         * Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and stickySession is `on`.
         */
        stickySessionType: string;
        /**
         * Https listener TLS cipher policy. Valid values are `tlsCipherPolicy10`, `tlsCipherPolicy11`, `tlsCipherPolicy12`, `tlsCipherPolicy12Strict`. Default to `tlsCipherPolicy10`.
         */
        tlsCipherPolicy: string;
        /**
         * Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
         */
        unhealthyThreshold: number;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For" is added or not; it allows the backend server to know about the user's IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedFor: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_SLBID" is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbId: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_SLBIP" is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbIp: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_proto" is added or not; it allows the backend server to know about the user's protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbProto: string;
    }

    export interface GetLoadBalancersBalancer {
        /**
         * Service address of the SLBs.
         */
        address: string;
        addressIpVersion: string;
        addressType: string;
        autoReleaseTime: number;
        backendServers: outputs.slb.GetLoadBalancersBalancerBackendServer[];
        bandwidth: number;
        createTimeStamp: number;
        deleteProtection: string;
        endTime: string;
        endTimeStamp: number;
        /**
         * ID of the SLB.
         */
        id: string;
        internetChargeType: string;
        listenerPortsAndProtocals: outputs.slb.GetLoadBalancersBalancerListenerPortsAndProtocal[];
        listenerPortsAndProtocols: outputs.slb.GetLoadBalancersBalancerListenerPortsAndProtocol[];
        loadBalancerId: string;
        loadBalancerName: string;
        loadBalancerSpec: string;
        masterZoneId: string;
        modificationProtectionReason: string;
        modificationProtectionStatus: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        paymentType: string;
        regionIdAlias: string;
        renewalCycUnit: string;
        renewalDuration: number;
        renewalStatus: string;
        /**
         * The Id of resource group which SLB belongs.
         */
        resourceGroupId: string;
        slaveZoneId: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = alicloud.slb.getLoadBalancers({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetLoadBalancersBalancerBackendServer {
        description: string;
        serverId: string;
        type: string;
        weight: number;
    }

    export interface GetLoadBalancersBalancerListenerPortsAndProtocal {
        listenerPort: number;
        listenerProtocal: string;
    }

    export interface GetLoadBalancersBalancerListenerPortsAndProtocol {
        description: string;
        forwardPort: number;
        listenerForward: string;
        listenerPort: number;
        listenerProtocol: string;
    }

    export interface GetLoadBalancersSlb {
        /**
         * Service address of the SLBs.
         */
        address: string;
        /**
         * SLB creation time.
         */
        creationTime: string;
        /**
         * ID of the SLB.
         */
        id: string;
        /**
         * SLB addressType: internet if `true`, intranet if `false`. Must be `false` when `networkType` is `vpc`.
         */
        internet: boolean;
        /**
         * Master availability zone of the SLBs.
         */
        masterAvailabilityZone: string;
        /**
         * SLB name.
         */
        name: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        /**
         * Region ID the SLB belongs to.
         */
        regionId: string;
        /**
         * Slave availability zone of the SLBs.
         */
        slaveAvailabilityZone: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = alicloud.slb.getLoadBalancers({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * });
         * ```
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetMasterSlaveServerGroupsGroup {
        /**
         * master slave server group ID.
         */
        id: string;
        /**
         * master slave server group name.
         */
        name: string;
        /**
         * ECS instances associated to the group. Each element contains the following attributes:
         */
        servers: outputs.slb.GetMasterSlaveServerGroupsGroupServer[];
    }

    export interface GetMasterSlaveServerGroupsGroupServer {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * (Removed from v1.63.0) Determine if the server is executing.
         */
        isBackup: number;
        /**
         * The port used by the master slave server group.
         */
        port: number;
        /**
         * The server type of the attached ECS instance.
         */
        serverType: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetRulesSlbRule {
        /**
         * Domain name in the HTTP request where the rule applies (e.g. "*.aliyun.com").
         */
        domain: string;
        /**
         * Rule ID.
         */
        id: string;
        /**
         * Rule name.
         */
        name: string;
        /**
         * ID of the linked VServer group.
         */
        serverGroupId: string;
        /**
         * Path in the HTTP request where the rule applies (e.g. "/image").
         */
        url: string;
    }

    export interface GetServerCertificatesCertificate {
        /**
         * Id of server certificate issued by alibaba cloud.
         */
        alicloudCertificateId: string;
        /**
         * Name of server certificate issued by alibaba cloud.
         */
        alicloudCertificateName: string;
        /**
         * Server certificate common name.
         */
        commonName: string;
        /**
         * Server certificate created time.
         */
        createdTime: string;
        /**
         * Server certificate created timestamp.
         */
        createdTimestamp: number;
        /**
         * Server certificate expired time.
         */
        expiredTime: string;
        /**
         * Server certificate expired timestamp.
         */
        expiredTimestamp: number;
        /**
         * Server certificate fingerprint.
         */
        fingerprint: string;
        /**
         * Server certificate ID.
         */
        id: string;
        /**
         * Is server certificate issued by alibaba cloud or not.
         */
        isAlicloudCertificate: boolean;
        /**
         * Server certificate name.
         */
        name: string;
        /**
         * The Id of resource group which the slb server certificates belongs.
         */
        resourceGroupId?: string;
        /**
         * Server certificate subject alternative name list.
         */
        subjectAlternativeNames: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetServerGroupsSlbServerGroup {
        /**
         * VServer group ID.
         */
        id: string;
        /**
         * VServer group name.
         */
        name: string;
        /**
         * ECS instances associated to the group. Each element contains the following attributes:
         */
        servers: outputs.slb.GetServerGroupsSlbServerGroupServer[];
    }

    export interface GetServerGroupsSlbServerGroupServer {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetTlsCipherPoliciesPolicy {
        /**
         * The encryption algorithms supported. It depends on the value of `tlsVersions`.
         */
        ciphers: string[];
        /**
         * The creation time timestamp.
         */
        createTime: string;
        /**
         * The ID of the Tls Cipher Policy.
         */
        id: string;
        /**
         * Array of Relate Listeners.
         */
        relateListeners: outputs.slb.GetTlsCipherPoliciesPolicyRelateListener[];
        /**
         * TLS policy instance state.
         */
        status: string;
        /**
         * The ID of TLS cipher policy.
         */
        tlsCipherPolicyId: string;
        /**
         * TLS policy name. Length is from 2 to 128, or in both the English and Chinese characters must be with an uppercase/lowercase letter or a Chinese character and the beginning, may contain numbers, in dot `.`, underscore `_` or dash `-`.
         */
        tlsCipherPolicyName: string;
        /**
         * The version of TLS protocol.
         */
        tlsVersions: string[];
    }

    export interface GetTlsCipherPoliciesPolicyRelateListener {
        /**
         * The ID of SLB instance.
         */
        loadBalancerId: string;
        /**
         * Listening port. Valid value: 1 to 65535.
         */
        port: number;
        /**
         * Snooping protocols. Valid values: `TCP`, `UDP`, `HTTP`, or `HTTPS`.
         */
        protocol: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone. It is same as `masterZoneId`.
         */
        id: string;
        /**
         * The primary zone.
         */
        masterZoneId: string;
        /**
         * The secondary zone.
         */
        slaveZoneId: string;
        /**
         * (Deprecated from 1.157.0) A list of slb slave zone ids in which the slb master zone. 
         * It has been deprecated from v1.157.0 and use `slaveZoneId` instead.
         *
         * @deprecated the attribute slb_slave_zone_ids has been deprecated from version 1.157.0 and use slave_zone_id instead.
         */
        slbSlaveZoneIds: string[];
        /**
         * (Available in 1.154.0+)A list of available resource which the slb master zone supported.
         */
        supportedResources: outputs.slb.GetZonesZoneSupportedResource[];
    }

    export interface GetZonesZoneSupportedResource {
        /**
         * The type of IP address.
         */
        addressIpVersion: string;
        /**
         * The type of network.
         */
        addressType: string;
    }

    export interface ListenerXForwardedFor {
        retriveClientIp: boolean;
        /**
         * Whether to use the XForwardedFor header to obtain the ID of the SLB instance. Default to false.
         */
        retriveSlbId?: boolean;
        /**
         * Whether to use the XForwardedFor_SLBIP header to obtain the public IP address of the SLB instance. Default to false.
         */
        retriveSlbIp?: boolean;
        /**
         * Whether to use the XForwardedFor_proto header to obtain the protocol used by the listener. Default to false.
         */
        retriveSlbProto?: boolean;
    }

    export interface MasterSlaveServerGroupServer {
        isBackup?: number;
        port: number;
        serverId: string;
        serverType?: string;
        type?: string;
        weight?: number;
    }

    export interface ServerGroupServer {
        port: number;
        serverIds: string[];
        type?: string;
        weight?: number;
    }

}

export namespace tag {
    export interface GetMetaTagsTag {
        /**
         * The type of the resource tags.
         */
        category: string;
        /**
         * The name of the key.
         */
        keyName: string;
        /**
         * The name of the value.
         */
        valueName: string;
    }

}

export namespace threatdetection {
    export interface GetAntiBruteForceRulesRule {
        /**
         * The ID of the defense rule.
         */
        antiBruteForceRuleId: string;
        /**
         * The name of the defense rule.
         */
        antiBruteForceRuleName: string;
        /**
         * Specifies whether to set the defense rule as the default rule.
         */
        defaultRule: boolean;
        /**
         * The threshold for the number of failed user logins when the brute-force defense rule takes effect.
         */
        failCount: number;
        /**
         * The period of time during which logons from an account are not allowed. Unit: minutes.
         */
        forbiddenTime: number;
        /**
         * The ID of the defense rule.
         */
        id: string;
        /**
         * The period of time during which logon failures from an account are measured. Unit: minutes. If Span is set to 10, the defense rule takes effect when the logon failures measured within 10 minutes reaches the specified threshold. The IP address of attackers cannot be used to log on to the server in the specified period of time.
         */
        span: number;
        /**
         * An array consisting of the UUIDs of servers to which the defense rule is applied.
         */
        uuidLists: string[];
    }

    export interface GetAssetsAsset {
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * The ID of the instance.
         */
        id: string;
        /**
         * The UUID of the instance.
         */
        uuid: string;
    }

    export interface GetBackupPoliciesPolicy {
        /**
         * The ID of the anti-ransomware policy.
         */
        backupPolicyId: number;
        /**
         * The name of the anti-ransomware policy.
         */
        backupPolicyName: string;
        /**
         * The ID of the anti-ransomware policy.
         */
        id: number;
        /**
         * The configurations of the anti-ransomware policy.
         */
        policy: string;
        /**
         * The ID of the region that you specified for data backup when you installed the anti-ransomware agent for the server not deployed on Alibaba Cloud.
         */
        policyRegionId: string;
        /**
         * The version of the anti-ransomware policy.
         */
        policyVersion: string;
        /**
         * The status of the anti-ransomware policy. Valid Value: `enabled`, `disabled`, `closed`.
         */
        status: string;
        /**
         * The UUIDs of the servers to which the anti-ransomware policy is applied.
         */
        uuidLists: string[];
    }

    export interface GetBaselineStrategiesStrategy {
        /**
         * The ID of the baseline check policy.
         */
        baselineStrategyId: string;
        /**
         * Policy name.
         */
        baselineStrategyName: string;
        /**
         * The type of policy. Value:-**common**: standard policy-**custom**: custom policy
         */
        customType: string;
        /**
         * The detection period of the policy.
         */
        cycleDays: number;
        /**
         * The detection period of the policy. Value:
         * * **0**: 0:00~06:00
         * * **6**: 6:00~12:00
         * * *12**: 12:00~18:00
         * * **18**: 18:00~24:00
         */
        cycleStartTime: number;
        /**
         * The baseline check policy execution end time.
         */
        endTime: string;
        /**
         * The ID of the baseline check policy.
         */
        id: string;
        riskSubTypeName: string;
        /**
         * The baseline check policy start time.
         */
        startTime: string;
        targetType: string;
    }

    export interface GetHoneyPotsPot {
        /**
         * Honeypot ID.
         */
        honeypotId: string;
        /**
         * The image ID of the honeypot.
         */
        honeypotImageId: string;
        /**
         * Honeypot mirror name.
         */
        honeypotImageName: string;
        /**
         * Honeypot custom name.
         */
        honeypotName: string;
        /**
         * Honeypot ID. The value is the same as `honeypotId`.
         */
        id: string;
        /**
         * The ID of the honeypot management node.
         */
        nodeId: string;
        /**
         * The custom parameter ID of honeypot.
         */
        presetId: string;
        /**
         * Honeypot status.
         */
        states: string[];
        /**
         * The status of the resource
         */
        status: string;
    }

    export interface GetHoneypotImagesImage {
        /**
         * The name of the honeypot image display.
         */
        honeypotImageDisplayName: string;
        /**
         * The image ID of the honeypot.
         */
        honeypotImageId: string;
        /**
         * Honeypot mirror name.
         */
        honeypotImageName: string;
        /**
         * Honeypot mirror type.
         */
        honeypotImageType: string;
        /**
         * Honeypot Mirror version.
         */
        honeypotImageVersion: string;
        /**
         * The image ID of the honeypot.The value is the same as `honeypotImageId`.
         */
        id: string;
        /**
         * Ports supported by honeypots. In JSON format. Contains the following fields:-**log_type**: log type-**proto**: Support Protocol-**description**: description-**ports**: supports Port collection-**port_str**: supports port strings-**type**: type
         */
        multiports: string;
        /**
         * Honeypot-supported protocols.
         */
        proto: string;
        /**
         * Honeypot service port.
         */
        servicePort: string;
        /**
         * Honeypot configuration parameter template.
         */
        template: string;
    }

    export interface GetHoneypotNodesNode {
        /**
         * Whether to allow honeypot access to the external network. Value:-**true**: Allow-**false**: Disabled
         */
        allowHoneypotAccessInternet: boolean;
        /**
         * Number of probes available.
         */
        availableProbeNum: number;
        createTime: string;
        /**
         * The ID of the Honeypot management node.
         */
        id: string;
        /**
         * Honeypot management node id.
         */
        nodeId: string;
        /**
         * The name of the management node.
         */
        nodeName: string;
        /**
         * Release the collection of network segments.
         */
        securityGroupProbeIpLists: string[];
        status: number;
    }

    export interface GetHoneypotPresetsPreset {
        /**
         * Honeypot mirror name
         */
        honeypotImageName: string;
        /**
         * Unique ID of honeypot Template.
         */
        honeypotPresetId: string;
        /**
         * The id of the Honeypot template.
         */
        id: string;
        /**
         * Honeypot template custom parameters.
         */
        metas: outputs.threatdetection.GetHoneypotPresetsPresetMeta[];
        /**
         * Unique id of management node
         */
        nodeId: string;
        /**
         * Honeypot template custom name
         */
        presetName: string;
    }

    export interface GetHoneypotPresetsPresetMeta {
        /**
         * Burp counter.
         */
        burp: string;
        /**
         * Social traceability.
         */
        portraitOption: boolean;
        /**
         * Git countered.
         */
        trojanGit: string;
    }

    export interface GetHoneypotProbesProbe {
        /**
         * ARP spoofing detection.-**true**: Enable-**false**: Disabled. Available when `enableDetails` is on.
         */
        arp: boolean;
        /**
         * The ID of the management node.
         */
        controlNodeId: string;
        /**
         * Probe name
         */
        displayName: string;
        honeypotBindLists: outputs.threatdetection.GetHoneypotProbesProbeHoneypotBindList[];
        /**
         * The first ID of the resource
         */
        honeypotProbeId: string;
        /**
         * The ID of the honeypot probe. Its value is the same as `honeypotProbeId`.
         */
        id: string;
        /**
         * Ping scan detection. Value:**true**: Enable **false**: Disabled. Available when `enableDetails` is on.
         */
        ping: boolean;
        /**
         * Probe type
         */
        probeType: string;
        /**
         * Listen to the IP address list. Available when `enableDetails` is on.
         */
        serviceIpLists: string[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * Machine uuid. Has a value when the type is `hostProbe`.
         */
        uuid: string;
        /**
         * The ID of the VPC. Has a value when the type is `vpcBlackHoleProbe`.
         */
        vpcId: string;
    }

    export interface GetHoneypotProbesProbeHoneypotBindList {
        /**
         * List of listening ports. Available when `enableDetails` is on.
         */
        bindPortLists: outputs.threatdetection.GetHoneypotProbesProbeHoneypotBindListBindPortList[];
        honeypotId: string;
    }

    export interface GetHoneypotProbesProbeHoneypotBindListBindPortList {
        /**
         * Whether to bind the port.
         */
        bindPort: boolean;
        /**
         * End port.
         */
        endPort: number;
        /**
         * Whether the port is fixed.
         */
        fixed: boolean;
        /**
         * Start port.
         */
        startPort: number;
        /**
         * Destination port.
         */
        targetPort: number;
    }

    export interface GetInstancesInstance {
        /**
         * The creation time of the resource
         */
        createTime: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The first ID of the resource
         */
        instanceId: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetVulWhitelistsWhitelist {
        /**
         * The ID of the Vul Whitelist.
         */
        id: string;
        /**
         * Reason for adding whitelist.
         */
        reason: string;
        /**
         * Set the effective range of the whitelist.
         */
        targetInfo: string;
        /**
         * The ID of the Vul Whitelist.
         */
        vulWhitelistId: string;
        /**
         * Information about the vulnerability to be added to the whitelist.
         */
        whitelist: string;
    }

    export interface GetWebLockConfigsConfig {
        /**
         * The prevention mode.
         */
        defenceMode: string;
        /**
         * The directory that has web tamper proofing enabled.
         */
        dir: string;
        /**
         * The directory that has web tamper proofing disabled.
         */
        exclusiveDir: string;
        /**
         * The file that has web tamper proofing disabled. **Note:** If the value of `mode` is `blacklist`, this parameter is returned.
         */
        exclusiveFile: string;
        /**
         * The type of the file that has web tamper proofing disabled. **Note:** If the value of `mode` is `blacklist`, this parameter is returned.
         */
        exclusiveFileType: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The type of the file that has web tamper proofing enabled. **Note:** If the value of `mode` is `whitelist`, this parameter is returned.
         */
        inclusiveFileType: string;
        /**
         * The local path to the backup files of the protected directory.
         */
        localBackupDir: string;
        /**
         * The protection mode of web tamper proofing.
         */
        mode: string;
        /**
         * The UUID of the server that has web tamper proofing enabled.
         */
        uuid: string;
    }

    export interface HoneypotPresetMeta {
        /**
         * Burp counter.
         */
        burp: string;
        /**
         * Social traceability.
         */
        portraitOption?: boolean;
        /**
         * Git countered.
         */
        trojanGit?: string;
    }

    export interface HoneypotProbeHoneypotBindList {
        /**
         * List of listening ports.See the following `Block BindPortList`.
         */
        bindPortLists?: outputs.threatdetection.HoneypotProbeHoneypotBindListBindPortList[];
        /**
         * Honeypot ID.
         */
        honeypotId?: string;
    }

    export interface HoneypotProbeHoneypotBindListBindPortList {
        /**
         * Whether to bind the port.
         */
        bindPort: boolean;
        /**
         * End port.
         */
        endPort: number;
        /**
         * Whether the port is fixed.
         */
        fixed: boolean;
        /**
         * Start port.
         */
        startPort: number;
        /**
         * Destination port.
         */
        targetPort: number;
    }

}

export namespace tsdb {
    export interface GetInstancesInstance {
        /**
         * Auto renew.
         */
        autoRenew: string;
        /**
         * The cpu core number of instance.
         */
        cpuNumber: string;
        /**
         * The disk type of instance. `cloudSsd` refers to SSD disk, `cloudEfficiency` refers to efficiency disk,cloud_essd refers to ESSD PL1 disk.
         */
        diskCategory: string;
        /**
         * The engine type of instance. Enumerative: `tsdbTsdb` refers to TSDB, `tsdbInfluxdb` refers to TSDB for InfluxDB.
         */
        engineType: string;
        /**
         * Instance expiration time.
         */
        expiredTime: number;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The alias of the instance.
         */
        instanceAlias: string;
        /**
         * The specification of the instance.
         */
        instanceClass: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The storage capacity of the instance. Unit: GB. For example, the value 50 indicates 50 GB.
         */
        instanceStorage: string;
        /**
         * The memory size of instance.
         */
        memorySize: string;
        /**
         * Instance network type.
         */
        networkType: string;
        /**
         * The billing method. Valid values: `PayAsYouGo` and `Subscription`. The `PayAsYouGo` value indicates the pay-as-you-go method, and the `Subscription` value indicates the subscription method.
         */
        paymentType: string;
        /**
         * Instance status, enumerative: ACTIVATION,DELETED, CREATING,CLASS_CHANGING,LOCKED.
         */
        status: string;
        /**
         * The vpc connection address of instance.
         */
        vpcConnectionAddress: string;
        /**
         * The ID of the virtual private cloud (VPC) that is connected to the instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * The ID of zone.
         */
        id: string;
        /**
         * The local name.
         */
        localName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

}

export namespace videosurveillance {
    export interface GetSystemGroupsGroup {
        /**
         * The App Name of Group.
         */
        app: string;
        /**
         * The space within the device status update of the callback, need to start with http:// or https:// at the beginning.
         */
        callback: string;
        /**
         * The creation time of the Group.
         */
        createTime: string;
        /**
         * The description of the Group.
         */
        description: string;
        /**
         * Whether to open Group.
         */
        enabled: boolean;
        /**
         * Space of national standard ID. **NOTE:** Available only in the national standard access space.
         */
        gbId: string;
        /**
         * Space of national standard signaling server address. **NOTE:** Available only in the national standard access space.
         */
        gbIp: string;
        /**
         * The ID of Group.
         */
        groupId: string;
        /**
         * The name of Group.
         */
        groupName: string;
        /**
         * The ID of the Group.
         */
        id: string;
        /**
         * The use of the access protocol support `gb28181`,`rtmp`(Real Time Messaging Protocol).
         */
        inProtocol: string;
        /**
         * The use of space play Protocol multi-valued separate them with commas (,). Valid values: `flv`,`hls`, `rtmp`(Real Time Messaging Protocol).
         */
        outProtocol: string;
        /**
         * The domain name of plan streaming used by the group.
         */
        playDomain: string;
        /**
         * The domain name of push streaming used by the group.
         */
        pushDomain: string;
        /**
         * The Device statistics of Group.
         */
        stats: outputs.videosurveillance.GetSystemGroupsGroupStat[];
    }

    export interface GetSystemGroupsGroupStat {
        /**
         * The total number of devices in the group.
         */
        deviceNum: string;
        /**
         * The total number of smart devices in the group.
         */
        iedNum: string;
        /**
         * The total number of cameras in the group.
         */
        ipcNum: string;
        /**
         * The total number of platforms in the group.
         */
        platformNum: string;
    }

}

export namespace vod {
    export interface DomainSource {
        /**
         * The address of the origin server. You can specify an IP address or a domain name.
         */
        sourceContent: string;
        /**
         * The port number. You can specify port 443 or 80. **Default value: 80**. If you specify port 443, Alibaba Cloud CDN communicates with the origin server over HTTPS. You can also customize a port.
         */
        sourcePort: string;
        /**
         * The priority of the origin server if multiple origin servers are specified. Valid values: `20` and `30`. **Default value: 20**. A value of 20 indicates that the origin server is the primary origin server. A value of 30 indicates that the origin server is a secondary origin server.
         */
        sourcePriority: string;
        /**
         * The type of the origin server. Valid values:
         */
        sourceType: string;
    }

    export interface GetDomainsDomain {
        /**
         * The CNAME that is assigned to the domain name for CDN. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name for CDN to the CNAME.
         */
        cname: string;
        /**
         * The description of the domain name for CDN.
         */
        description: string;
        /**
         * The domain name for CDN.
         */
        domainName: string;
        /**
         * The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        gmtCreated: string;
        /**
         * The last time when the domain name for CDN was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        gmtModified: string;
        /**
         * The ID of the Domain. Its value is same as Queue Name.
         */
        id: string;
        /**
         * Indicates whether the domain name for CDN is in a sandbox environment.
         */
        sandBox: string;
        /**
         * The information about the address of the origin server. For more information about the Sources parameter, See the following `Block sources`.
         */
        sources: outputs.vod.GetDomainsDomainSource[];
        /**
         * Indicates whether the Secure Sockets Layer (SSL) certificate is enabled. Valid values: `on`,`off`.
         */
        sslProtocol: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetDomainsDomainSource {
        sourceContent: string;
        sourcePort: string;
        sourcePriority: string;
        sourceType: string;
    }

}

export namespace vpc {
    export interface DhcpOptionsSetAssociateVpc {
        /**
         * The status of the VPC associated with the DHCP option set.
         */
        associateStatus: string;
        /**
         * The ID of the VPC network that is associated with the DHCP options set.
         */
        vpcId: string;
    }

    export interface GetBgpGroupsGroup {
        /**
         * The key used by the BGP group.
         */
        authKey: string;
        /**
         * The name of the BGP group.
         */
        bgpGroupName: string;
        /**
         * Description of the BGP group.
         */
        description: string;
        /**
         * The hold time to wait for the incoming BGP message. If no message has been passed in after the hold time, the BGP neighbor is considered disconnected.
         */
        hold: string;
        /**
         * The ID of the Bgp Group.
         */
        id: string;
        /**
         * IP version.
         */
        ipVersion: string;
        /**
         * Whether the AS number is false.
         */
        isFakeAsn: boolean;
        /**
         * The keepalive time.
         */
        keepalive: string;
        /**
         * The local AS number.
         */
        localAsn: number;
        /**
         * The autonomous system (AS) number of the BGP peer.
         */
        peerAsn: number;
        /**
         * Routing limits.
         */
        routeLimit: string;
        /**
         * The ID of the VBR.
         */
        routerId: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetBgpNetworksNetwork {
        /**
         * Advertised BGP networks.
         */
        dstCidrBlock: string;
        /**
         * The ID of the Bgp Network. The value formats as `<router_id>:<dst_cidr_block>`.
         */
        id: string;
        /**
         * The ID of the vRouter.
         */
        routerId: string;
        /**
         * The state of the advertised BGP network.
         */
        status: string;
    }

    export interface GetBgpPeersPeer {
        /**
         * The authentication key of the BGP group.
         */
        authKey: string;
        /**
         * The BFD hop count.
         */
        bfdMultiHop: number;
        /**
         * The ID of the BGP group.
         */
        bgpGroupId: string;
        /**
         * The ID of the BGP neighbor.
         */
        bgpPeerId: string;
        /**
         * The name of the BGP neighbor.
         */
        bgpPeerName: string;
        /**
         * The status of the BGP connection.
         */
        bgpStatus: string;
        /**
         * The description of the BGP group.
         */
        description: string;
        /**
         * Indicates whether the Bidirectional Forwarding Detection (BFD) protocol is enabled.
         */
        enableBfd: boolean;
        /**
         * The hold time.
         */
        hold: string;
        /**
         * The ID of the Bgp Peer.
         */
        id: string;
        /**
         * The IP version.
         */
        ipVersion: string;
        /**
         * Indicates whether a fake AS number is used.
         */
        isFake: boolean;
        /**
         * The keepalive time.
         */
        keepalive: string;
        /**
         * The AS number of the device on the Alibaba Cloud side.
         */
        localAsn: string;
        /**
         * The autonomous system (AS) number of the BGP peer.
         */
        peerAsn: string;
        /**
         * The IP address of the BGP neighbor.
         */
        peerIpAddress: string;
        /**
         * The limit on routes.
         */
        routeLimit: string;
        /**
         * The ID of the router.
         */
        routerId: string;
        /**
         * The status of the BGP peer.
         */
        status: string;
    }

    export interface GetCommonBandwidthPackagesPackage {
        /**
         * The peak bandwidth of the Internet Shared Bandwidth instance.
         */
        bandwidth: string;
        /**
         * The resource ID of bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * The name of bandwidth package.
         */
        bandwidthPackageName: string;
        /**
         * The business status of the Common Bandwidth Package instance.
         */
        businessStatus: string;
        /**
         * The deletion protection of bandwidth package.
         */
        deletionProtection: boolean;
        /**
         * The description of the Common Bandwidth Package instance.
         */
        description: string;
        /**
         * The expired time of bandwidth package.
         */
        expiredTime: string;
        /**
         * Is has reservation data.
         */
        hasReservationData: boolean;
        /**
         * ID of the Common Bandwidth Package.
         */
        id: string;
        /**
         * The internet charge type of bandwidth package.
         */
        internetChargeType: string;
        /**
         * ISP of the Common Bandwidth Package.
         */
        isp: string;
        /**
         * Name of the Common Bandwidth Package.
         */
        name: string;
        /**
         * The payment type of bandwidth package.
         */
        paymentType: string;
        /**
         * Public ip addresses that in the Common Bandwidth Pakcage.
         */
        publicIpAddresses: outputs.vpc.GetCommonBandwidthPackagesPackagePublicIpAddress[];
        /**
         * The ratio of bandwidth package.
         */
        ratio: number;
        /**
         * The active time of reservation.
         */
        reservationActiveTime: string;
        /**
         * The bandwidth of reservation.
         */
        reservationBandwidth: string;
        /**
         * The charge type of reservation internet.
         */
        reservationInternetChargeType: string;
        /**
         * The type of reservation order.
         */
        reservationOrderType: string;
        /**
         * The Id of resource group which the common bandwidth package belongs.
         */
        resourceGroupId: string;
        /**
         * The service managed.
         */
        serviceManaged: number;
        /**
         * The status of bandwidth package. Valid values: `Available` and `Pending`.
         */
        status: string;
    }

    export interface GetCommonBandwidthPackagesPackagePublicIpAddress {
        allocationId: string;
        bandwidthPackageIpRelationStatus: string;
        ipAddress: string;
    }

    export interface GetDhcpOptionsSetsSet {
        /**
         * The Number of VPCs bound by the DHCP option set.
         */
        associateVpcCount: number;
        /**
         * The description of the DHCP options set. The description must be 2 to 256
         * characters in length and cannot start with `http://` or `https://`.
         */
        dhcpOptionsSetDescription: string;
        dhcpOptionsSetId: string;
        /**
         * The root domain, for example, example.com. After a DHCP options set is associated with a
         * Virtual Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the
         * ECS instances in the VPC network.
         */
        dhcpOptionsSetName: string;
        /**
         * The root domain, for example, example.com. After a DHCP options set is associated with a Virtual
         * Private Cloud (VPC) network, the root domain in the DHCP options set is automatically synchronized to the ECS
         * instances in the VPC network.
         */
        domainName: string;
        /**
         * The DNS server IP addresses. Up to four DNS server IP addresses can be specified. IP
         * addresses must be separated with commas (,).
         */
        domainNameServers: string;
        id: string;
        /**
         * The ID of the account to which the DHCP options set belongs.
         */
        ownerId: string;
        /**
         * The status of the DHCP options set. Valid values: `Available`, `InUse` or `Pending`. `Available`: The DHCP options set is available for use. `InUse`: The DHCP options set is in use. `Pending`: The DHCP options set is being configured.
         */
        status: string;
    }

    export interface GetEnhancedNatAvailableZonesZone {
        localName: string;
        zoneId: string;
    }

    export interface GetForwardEntriesEntry {
        /**
         * The public IP address.
         */
        externalIp: string;
        /**
         * The public port.
         */
        externalPort: string;
        /**
         * The forward entry ID.
         */
        forwardEntryId: string;
        /**
         * The name of forward entry.
         */
        forwardEntryName: string;
        /**
         * The ID of the Forward Entry.
         */
        id: string;
        /**
         * The private IP address.
         */
        internalIp: string;
        /**
         * The internal port.
         */
        internalPort: string;
        /**
         * The ip protocol. Valid values: `any`,`tcp` and `udp`.
         */
        ipProtocol: string;
        /**
         * The forward entry name.
         */
        name: string;
        /**
         * The status of farward entry. Valid value `Available`, `Deleting` and `Pending`.
         */
        status: string;
    }

    export interface GetHavipsHavip {
        /**
         * EIP bound to HaVip.
         */
        associatedEipAddresses: string[];
        /**
         * An ECS instance that is bound to HaVip.
         */
        associatedInstances: string[];
        /**
         * Dependence of a HaVip instance.
         */
        description: string;
        /**
         * The  ID of the resource.
         */
        havipId: string;
        /**
         * The name of the HaVip instance.
         */
        havipName: string;
        /**
         * The ID of the Ha Vip.
         */
        id: string;
        /**
         * IP address of private network.
         */
        ipAddress: string;
        /**
         * The primary instance ID bound to HaVip.
         */
        masterInstanceId: string;
        /**
         * The status.
         */
        status: string;
        /**
         * The VPC ID to which the HaVip instance belongs.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetIpsecServersServer {
        /**
         * The CIDR block of the client, which is assigned an access address to the virtual NIC of the client.
         */
        clientIpPool: string;
        /**
         * The creation time of the IPsec server. T represents the delimiter, and Z represents UTC, which is World Standard Time.
         */
        createTime: string;
        /**
         * Indicates whether the current IPsec tunnel is deleted and negotiations are reinitiated.
         */
        effectImmediately: boolean;
        /**
         * The ID of the Ipsec Server.
         */
        id: string;
        /**
         * The ID of the Identity as a Service (IDaaS) instance.
         */
        idaasInstanceId: string;
        /**
         * The configurations of Phase 1 negotiations.
         */
        ikeConfigs: outputs.vpc.GetIpsecServersServerIkeConfig[];
        /**
         * The public IP address of the VPN gateway.
         */
        internetIp: string;
        /**
         * The configuration of Phase 2 negotiations.
         */
        ipsecConfigs: outputs.vpc.GetIpsecServersServerIpsecConfig[];
        /**
         * The ID of the IPsec server.
         */
        ipsecServerId: string;
        /**
         * The name of the IPsec server.
         */
        ipsecServerName: string;
        /**
         * Local network segment: the network segment on The VPC side that needs to be interconnected with the client network segment.
         */
        localSubnet: string;
        /**
         * The number of SSL connections of the VPN gateway. SSL-VPN the number of SSL connections shared with the IPsec server. For example, if the number of SSL connections is 5 and you have three SSL clients connected to the SSL-VPN, you can also use two clients to connect to the IPsec server.
         */
        maxConnections: number;
        /**
         * Whether the two-factor authentication function has been turned on.
         */
        multiFactorAuthEnabled: boolean;
        /**
         * The number of clients that have connected to the IPsec server.
         */
        onlineClientCount: number;
        /**
         * The pre-shared key.
         */
        psk: string;
        /**
         * Whether to enable the pre-shared key authentication method. The value is only `true`, which indicates that the pre-shared key authentication method is enabled.
         */
        pskEnabled: boolean;
        /**
         * The ID of the VPN gateway.
         */
        vpnGatewayId: string;
    }

    export interface GetIpsecServersServerIkeConfig {
        /**
         * The IKE authentication algorithm.
         */
        ikeAuthAlg: string;
        /**
         * The IKE encryption algorithm.
         */
        ikeEncAlg: string;
        /**
         * The IKE lifetime. Unit: seconds.
         */
        ikeLifetime: number;
        /**
         * The IKE negotiation mode.
         */
        ikeMode: string;
        /**
         * Diffie-Hellman key exchange algorithm.
         */
        ikePfs: string;
        /**
         * The IKE version.
         */
        ikeVersion: string;
        /**
         * IPsec server identifier. Supports the format of FQDN and IP address. The public IP address of the VPN gateway is selected by default.
         */
        localId: string;
        /**
         * The peer identifier. Supports the format of FQDN and IP address, which is empty by default.
         */
        remoteId: string;
    }

    export interface GetIpsecServersServerIpsecConfig {
        /**
         * IPsec authentication algorithm.
         */
        ipsecAuthAlg: string;
        /**
         * IPsec encryption algorithm.
         */
        ipsecEncAlg: string;
        /**
         * IPsec survival time. Unit: seconds.
         */
        ipsecLifetime: number;
        /**
         * Diffie-Hellman key exchange algorithm.
         */
        ipsecPfs: string;
    }

    export interface GetIpv4GatewaysGateway {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * Indicates whether the IPv4 gateway is activated.
         */
        enabled: boolean;
        /**
         * The ID of the Ipv4 Gateway.
         */
        id: string;
        /**
         * The description of the IPv4 gateway.
         */
        ipv4GatewayDescription: string;
        /**
         * The resource attribute field that represents the resource level 1 ID.
         */
        ipv4GatewayId: string;
        /**
         * The name of the IPv4 gateway.
         */
        ipv4GatewayName: string;
        /**
         * ID of the route table associated with IPv4 Gateway.
         */
        ipv4GatewayRouteTableId: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the VPC associated with the IPv4 Gateway.
         */
        vpcId: string;
    }

    export interface GetIpv6AddressesAddress {
        /**
         * The ID of the instance that is assigned the IPv6 address.
         */
        associatedInstanceId: string;
        /**
         * The type of the instance that is assigned the IPv6 address.
         */
        associatedInstanceType: string;
        /**
         * The time when the IPv6 address was created.
         */
        createTime: string;
        /**
         * The ID of the Ipv6 Address.
         */
        id: string;
        /**
         * The address of the Ipv6 Address.
         */
        ipv6Address: string;
        /**
         * The ID of the IPv6 address.
         */
        ipv6AddressId: string;
        /**
         * The name of the IPv6 address.
         */
        ipv6AddressName: string;
        /**
         * The ID of the IPv6 gateway to which the IPv6 address belongs.
         */
        ipv6GatewayId: string;
        /**
         * The type of communication supported by the IPv6 address. Valid values:`Private` or `Public`. `Private`: communication within the private network. `Public`: communication over the public network
         */
        networkType: string;
        /**
         * The status of the IPv6 address. Valid values:`Pending` or `Available`.
         */
        status: string;
        /**
         * The ID of the VPC to which the IPv6 address belongs.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch to which the IPv6 address belongs.
         */
        vswitchId: string;
    }

    export interface GetIpv6EgressRulesRule {
        /**
         * The description of the egress-only rule.
         */
        description: string;
        /**
         * The ID of the Ipv6 Egress Rule. The value formats as `<ipv6_gateway_id>:<ipv6_egress_rule_id>`.
         */
        id: string;
        /**
         * The ID of the instance to which the egress-only rule is applied.
         */
        instanceId: string;
        /**
         * The type of the instance to which the egress-only rule is applied.
         */
        instanceType: string;
        /**
         * The first ID of the resource.
         */
        ipv6EgressRuleId: string;
        /**
         * The name of the resource.
         */
        ipv6EgressRuleName: string;
        /**
         * The ID of the IPv6 gateway.
         */
        ipv6GatewayId: string;
        /**
         * The status of the resource. Valid values: `Available`, `Pending` and `Deleting`.
         */
        status: string;
    }

    export interface GetIpv6GatewaysGateway {
        /**
         * The status of the IPv6 gateway. Valid values:`Normal`, `FinancialLocked` and `SecurityLocked`. `Normal`: working as expected. `FinancialLocked`: locked due to overdue payments. `SecurityLocked`: locked due to security reasons.
         */
        businessStatus: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description of the IPv6 gateway.
         */
        description: string;
        /**
         * The time when the IPv6 gateway expires.
         */
        expiredTime: string;
        /**
         * The ID of the Ipv6 Gateway.
         */
        id: string;
        /**
         * The metering method of the IPv6 gateway. Valid values: `PayAsYouGo`.
         */
        instanceChargeType: string;
        /**
         * The first ID of the resource.
         */
        ipv6GatewayId: string;
        /**
         * The name of the IPv6 gateway.
         */
        ipv6GatewayName: string;
        /**
         * The specification of the IPv6 gateway. Valid values: `Large`, `Medium` and `Small`. `Small` (default): Free Edition. `Medium`: Enterprise Edition . `Large`: Enhanced Enterprise Edition. The throughput capacity of an IPv6 gateway varies based on the edition. For more information, see [Editions of IPv6 gateways](https://www.alibabacloud.com/help/doc-detail/98926.htm).
         */
        spec: string;
        /**
         * The status of the IPv6 gateway. Valid values: `Available`, `Deleting`, `Pending`.
         */
        status: string;
        /**
         * The ID of the virtual private cloud (VPC) to which the IPv6 gateway belongs.
         */
        vpcId: string;
    }

    export interface GetIpv6InternetBandwidthsBandwidth {
        /**
         * The amount of Internet bandwidth resources of the IPv6 address, Unit: `Mbit/s`.
         */
        bandwidth: number;
        /**
         * The ID of the Ipv6 Internet Bandwidth.
         */
        id: string;
        /**
         * The metering method of the Internet bandwidth resources of the IPv6 gateway.
         */
        internetChargeType: string;
        /**
         * The ID of the IPv6 address.
         */
        ipv6AddressId: string;
        /**
         * The ID of the IPv6 gateway.
         */
        ipv6GatewayId: string;
        /**
         * The ID of the Ipv6 Internet Bandwidth.
         */
        ipv6InternetBandwidthId: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The status of the resource. Valid values: `Normal`, `FinancialLocked` and `SecurityLocked`.
         */
        status: string;
    }

    export interface GetNatGatewaysGateway {
        /**
         * The state of the NAT gateway.
         */
        businessStatus: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The description of the NAT gateway.
         */
        description: string;
        /**
         * Indicates whether the traffic monitoring feature is enabled.
         */
        ecsMetricEnabled: boolean;
        /**
         * The time when the NAT gateway expires.
         */
        expiredTime: string;
        /**
         * The ID of the DNAT table.
         */
        forwardTableIds: string[];
        /**
         * The ID of the NAT gateway.
         */
        id: string;
        /**
         * The metering method of the NAT gateway.
         */
        internetChargeType: string;
        /**
         * The ip address of the bind eip.
         */
        ipLists: string[];
        /**
         * Name of the NAT gateway.
         */
        name: string;
        /**
         * The ID of the NAT gateway.
         */
        natGatewayId: string;
        /**
         * The name of NAT gateway.
         */
        natGatewayName: string;
        /**
         * The nat type of NAT gateway. Valid values `Enhanced` and `Normal`.
         */
        natType: string;
        /**
         * (Available in 1.137.0+) Indicates the type of the created NAT gateway. Valid values `internet` and `intranet`.
         */
        networkType: string;
        /**
         * The payment type of NAT gateway. Valid values `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * The resource group id of NAT gateway.
         */
        resourceGroupId: string;
        /**
         * The ID of the SNAT table that is associated with the NAT gateway.
         */
        snatTableIds: string[];
        /**
         * The specification of the NAT gateway.
         */
        spec: string;
        /**
         * The specification of NAT gateway. Valid values `Middle`, `Large`, `Small` and `XLarge.1`. Default value is `Small`.
         */
        specification: string;
        /**
         * The status of NAT gateway. Valid values `Available`, `Converting`, `Creating`, `Deleting` and `Modifying`.
         */
        status: string;
        /**
         * The tags of NAT gateway.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch to which the NAT gateway belongs.
         */
        vswitchId: string;
    }

    export interface GetNatIpCidrsCidr {
        /**
         * The time when the CIDR block was created.
         */
        createTime: string;
        /**
         * The ID of the Nat Ip Cidr.
         */
        id: string;
        /**
         * Whether it is the default NAT IP ADDRESS. Valid values:`true` or `false`.`true`: is the default NAT IP ADDRESS. `false`: it is not the default NAT IP ADDRESS.
         */
        isDefault: boolean;
        /**
         * The ID of the VPC NAT gateway.
         */
        natGatewayId: string;
        /**
         * The NAT CIDR block to be created. The CIDR block must meet the following conditions: It must be `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`, or one of their subnets. The subnet mask must be `16` to `32` bits in lengths. To use a public CIDR block as the NAT CIDR block, the VPC to which the VPC NAT gateway belongs must be authorized to use public CIDR blocks. For more information, see [Create a VPC NAT gateway](https://www.alibabacloud.com/help/doc-detail/268230.htm).
         */
        natIpCidr: string;
        /**
         * NAT IP ADDRESS range to the description of. Length is from `2` to `256` characters, must start with a letter or the Chinese at the beginning, but not at the` http://` Or `https://` at the beginning.
         */
        natIpCidrDescription: string;
        /**
         * NAT IP ADDRESS instance ID.
         */
        natIpCidrId: string;
        /**
         * NAT IP ADDRESS the name of the root directory. Length is from `2` to `128` characters, must start with a letter or the Chinese at the beginning can contain numbers, half a period (.), underscore (_) and dash (-). But do not start with `http://` or `https://` at the beginning.
         */
        natIpCidrName: string;
        /**
         * The status of the CIDR block of the NAT gateway. If the value is `Available`, the CIDR block is available.
         */
        status: string;
    }

    export interface GetNatIpsIp {
        /**
         * The ID of the Nat Ip.
         */
        id: string;
        /**
         * Indicates whether the BGP Group is the default NAT IP ADDRESS. Valid values: `true`: is the default NAT IP ADDRESS. `false`: it is not the default NAT IP ADDRESS.
         */
        isDefault: boolean;
        /**
         * The ID of the Virtual Private Cloud (VPC) NAT gateway to which the NAT IP address belongs.
         */
        natGatewayId: string;
        /**
         * The NAT IP address that is queried.
         */
        natIp: string;
        /**
         * The CIDR block to which the NAT IP address belongs.
         */
        natIpCidr: string;
        /**
         * The description of the NAT IP address.
         */
        natIpDescription: string;
        /**
         * The ID of the NAT IP address.
         */
        natIpId: string;
        /**
         * The name of the NAT IP address.
         */
        natIpName: string;
        /**
         * The status of the NAT IP address. Valid values: `Available`, `Deleting` and `Creating`.
         */
        status: string;
    }

    export interface GetNetworkAclsAcl {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * Output direction rule information.
         */
        egressAclEntries: outputs.vpc.GetNetworkAclsAclEgressAclEntry[];
        /**
         * The ID of the Network Acl.
         */
        id: string;
        /**
         * Entry direction rule information.
         */
        ingressAclEntries: outputs.vpc.GetNetworkAclsAclIngressAclEntry[];
        /**
         * The first ID of the resource.
         */
        networkAclId: string;
        /**
         * The name of the network ACL.
         */
        networkAclName: string;
        /**
         * The associated resource.
         */
        resources: outputs.vpc.GetNetworkAclsAclResource[];
        /**
         * The state of the network ACL.
         */
        status: string;
        /**
         * The ID of the associated VPC.
         */
        vpcId: string;
    }

    export interface GetNetworkAclsAclEgressAclEntry {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * The destination address segment.
         */
        destinationCidrIp: string;
        /**
         * The name of the entry direction rule entry.
         */
        networkAclEntryName: string;
        /**
         * The authorization policy.
         */
        policy: string;
        /**
         * Source port range.
         */
        port: string;
        /**
         * Transport layer protocol.
         */
        protocol: string;
    }

    export interface GetNetworkAclsAclIngressAclEntry {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * The name of the entry direction rule entry.
         */
        networkAclEntryName: string;
        /**
         * The authorization policy.
         */
        policy: string;
        /**
         * Source port range.
         */
        port: string;
        /**
         * Transport layer protocol.
         */
        protocol: string;
        /**
         * The source address field.
         */
        sourceCidrIp: string;
    }

    export interface GetNetworkAclsAclResource {
        /**
         * The ID of the associated resource.
         */
        resourceId: string;
        /**
         * The type of the associated resource.
         */
        resourceType: string;
        /**
         * The state of the network ACL.
         */
        status: string;
    }

    export interface GetNetworksVpc {
        /**
         * Filter results by a specific CIDR block. For example: "172.16.0.0/12".
         */
        cidrBlock: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the VPC
         */
        description: string;
        /**
         * ID of the VPC.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * Indicate whether the VPC is the default one in the specified region.
         */
        isDefault: boolean;
        /**
         * ID of the region where the VPC is located.
         */
        regionId: string;
        /**
         * The Id of resource group which VPC belongs.
         */
        resourceGroupId: string;
        /**
         * Route table ID of the VRouter.
         */
        routeTableId: string;
        /**
         * The ID of the VRouter.
         */
        routerId: string;
        /**
         * A list of secondary IPv4 CIDR blocks of the VPC.
         */
        secondaryCidrBlocks: string[];
        /**
         * Filter results by a specific status. Valid value are `Pending` and `Available`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * A list of user CIDRs.
         */
        userCidrs: string[];
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * The name of the VPC.
         */
        vpcName: string;
        /**
         * ID of the VRouter.
         */
        vrouterId: string;
        /**
         * List of VSwitch IDs in the specified VPC
         */
        vswitchIds: string[];
    }

    export interface GetPbrRouteEntriesEntry {
        /**
         * The creation time of the VPN Pbr Route Entry.
         */
        createTime: string;
        /**
         * The id of the vpn pbr route entry. The value formats as `<vpn_gateway_id>:<next_hop>:<route_source>:<route_dest>`.
         */
        id: string;
        /**
         * The next hop of the policy-based route.
         */
        nextHop: string;
        /**
         * The destination CIDR block of the policy-based route.
         */
        routeDest: string;
        /**
         * The source CIDR block of the policy-based route.
         */
        routeSource: string;
        /**
         * The status of the VPN Pbr Route Entry.
         */
        status: string;
        /**
         * The ID of the VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The weight of the policy-based route. Valid values: 0 and 100.
         */
        weight: number;
    }

    export interface GetPeerConnectionsConnection {
        /**
         * The ID of the Alibaba Cloud account (primary account) of the receiving end of the VPC peering connection to be created.
         */
        acceptingAliUid: number;
        /**
         * The region ID of the recipient of the VPC peering connection to be created.
         */
        acceptingRegionId: string;
        /**
         * The VPC ID of the receiving end of the VPC peer connection.
         */
        acceptingVpcId: string;
        /**
         * The bandwidth of the VPC peering connection to be modified. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The description of the VPC peer connection to be created.
         */
        description: string;
        /**
         * The ID of the PeerConnection.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        peerConnectionId: string;
        /**
         * The name of the resource.
         */
        peerConnectionName: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The ID of the requester VPC.
         */
        vpcId: string;
    }

    export interface GetPrefixListsList {
        /**
         * The time when the prefix list was created.
         */
        createTime: string;
        /**
         * The CIDR address block list of the prefix list.
         */
        entrys: outputs.vpc.GetPrefixListsListEntry[];
        /**
         * The ID of the Prefix List.
         */
        id: string;
        /**
         * The IP version of the prefix list.
         */
        ipVersion: string;
        /**
         * The maximum number of entries for CIDR address blocks in the prefix list.
         */
        maxEntries: number;
        /**
         * The description of the prefix list.
         */
        prefixListDescription: string;
        /**
         * The ID of the query Prefix List.
         */
        prefixListId: string;
        /**
         * The name of the prefix list.
         */
        prefixListName: string;
        /**
         * The share type of the prefix list.
         */
        shareType: string;
    }

    export interface GetPrefixListsListEntry {
        /**
         * The CIDR address block of the prefix list.
         */
        cidr: string;
        /**
         * The description of the cidr entry.
         */
        description: string;
    }

    export interface GetPublicIpAddressPoolCidrBlocksBlock {
        /**
         * The CIDR block.
         */
        cidrBlock: string;
        /**
         * The time when the CIDR block was created. The time is displayed in YYYY-MM-DDThh:mm:ssZ format.
         */
        createTime: string;
        /**
         * The ID of the Public Ip Address Pool Cidr Block.
         */
        id: string;
        /**
         * The ID of the Vpc Public IP address pool.
         */
        publicIpAddressPoolId: string;
        /**
         * The status of the CIDR block in the Vpc Public IP address pool. Valid values: `Created`, `Modifying`, `Deleting`.
         */
        status: string;
        /**
         * The number of occupied IP addresses in the CIDR block.
         */
        totalIpNum: number;
        /**
         * The total number of available IP addresses in the CIDR block.
         */
        usedIpNum: number;
    }

    export interface GetPublicIpAddressPoolsPool {
        /**
         * The time when the Vpc Public Ip Address Pool was created. The time is displayed in YYYY-MM-DDThh:mm:ssZ format.
         */
        createTime: string;
        /**
         * The description of the Vpc Public Ip Address Pool.
         */
        description: string;
        /**
         * The ID of the Vpc Public Ip Address Pool.
         */
        id: string;
        /**
         * Indicates whether the Vpc Public Ip Address Pool has idle IP addresses.
         */
        ipAddressRemaining: boolean;
        /**
         * The Internet service provider.
         */
        isp: string;
        /**
         * The ID of the Vpc Public Ip Address Pool.
         */
        publicIpAddressPoolId: string;
        /**
         * The name of the Vpc Public Ip Address Pool.
         */
        publicIpAddressPoolName: string;
        /**
         * The region ID of the Vpc Public Ip Address Pool.
         */
        regionId: string;
        /**
         * The status of the Vpc Public Ip Address Pool.
         */
        status: string;
        /**
         * The total number of IP addresses in the Vpc Public Ip Address Pool.
         */
        totalIpNum: number;
        /**
         * The number of occupied IP addresses in the Vpc Public Ip Address Pool.
         */
        usedIpNum: number;
        /**
         * The user type.
         */
        userType: string;
    }

    export interface GetRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry.
         */
        cidrBlock: string;
        /**
         * The instance ID of the next hop.
         */
        instanceId: string;
        /**
         * The type of the next hop.
         */
        nextHopType: string;
        /**
         * The ID of the router table to which the route entry belongs.
         */
        routeTableId: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The type of the route entry.
         */
        type: string;
    }

    export interface GetRouteTablesTable {
        /**
         * The description of the route table instance.
         */
        description: string;
        /**
         * ID of the Route Table.
         */
        id: string;
        /**
         * Name of the route table.
         */
        name: string;
        /**
         * The Id of resource group which route tables belongs.
         */
        resourceGroupId: string;
        /**
         * The route table id.
         */
        routeTableId: string;
        /**
         * The route table name.
         */
        routeTableName: string;
        /**
         * The type of route table.
         */
        routeTableType: string;
        /**
         * The router ID.
         */
        routerId: string;
        /**
         * The route type of route table. Valid values: `VRouter` and `VBR`.
         */
        routerType: string;
        /**
         * The status of resource. Valid values: `Available` and `Pending`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Vpc id of the route table.
         */
        vpcId: string;
        /**
         * A list of vswitch id.
         */
        vswitchIds: string[];
    }

    export interface GetRouterInterfacesInterface {
        /**
         * ID of the access point used by the VBR.
         */
        accessPointId: string;
        /**
         * Router interface creation time.
         */
        creationTime: string;
        /**
         * Router interface description.
         */
        description: string;
        /**
         * Source IP address used to perform health check on the physical connection.
         */
        healthCheckSourceIp: string;
        /**
         * Destination IP address used to perform health check on the physical connection.
         */
        healthCheckTargetIp: string;
        /**
         * Router interface ID.
         */
        id: string;
        /**
         * Router interface name.
         */
        name: string;
        /**
         * ID of the peer router interface.
         */
        oppositeInterfaceId: string;
        /**
         * Account ID of the owner of the peer router interface.
         */
        oppositeInterfaceOwnerId: string;
        /**
         * Peer router region ID.
         */
        oppositeRegionId: string;
        /**
         * Peer router ID.
         */
        oppositeRouterId: string;
        /**
         * Router type in the peer region. Possible values: `VRouter` and `VBR`.
         */
        oppositeRouterType: string;
        /**
         * Role of the router interface. Valid values are `InitiatingSide` (connection initiator) and 
         * `AcceptingSide` (connection receiver). The value of this parameter must be `InitiatingSide` if the `routerType` is set to `VBR`.
         */
        role: string;
        /**
         * ID of the VRouter located in the local region.
         */
        routerId: string;
        /**
         * Router type in the local region. Valid values are `VRouter` and `VBR` (physical connection).
         */
        routerType: string;
        /**
         * Specification of the link, such as `Small.1` (10Mb), `Middle.1` (100Mb), `Large.2` (2Gb), ...etc.
         */
        specification: string;
        /**
         * Expected status. Valid values are `Active`, `Inactive` and `Idle`.
         */
        status: string;
        /**
         * ID of the VPC that owns the router in the local region.
         */
        vpcId: string;
    }

    export interface GetSnatEntriesEntry {
        /**
         * The ID of the Snat Entry.
         */
        id: string;
        /**
         * The ID of snat entry.
         */
        snatEntryId: string;
        /**
         * The name of snat entry.
         */
        snatEntryName: string;
        /**
         * The public IP of the Snat Entry.
         */
        snatIp: string;
        /**
         * The source CIDR block of the Snat Entry.
         */
        sourceCidr: string;
        /**
         * The source vswitch ID.
         */
        sourceVswitchId: string;
        /**
         * The status of the Snat Entry. Valid values: `Available`, `Deleting` and `Pending`.
         */
        status: string;
    }

    export interface GetSslVpnClientCertsCert {
        /**
         * The time of creation.
         */
        createTime: string;
        /**
         * The expiration time of the client certificate.
         */
        endTime: number;
        /**
         * ID of the SSL-VPN client certificate.
         */
        id: string;
        /**
         * The name of the SSL-VPN client certificate.
         */
        name: string;
        /**
         * Use the SSL-VPN server ID as the search key.
         */
        sslVpnServerId: string;
        /**
         * The status of the client certificate. valid value:expiring-soon, normal, expired.
         */
        status: string;
    }

    export interface GetSslVpnServersServer {
        /**
         * The encryption algorithm used.
         */
        cipher: string;
        /**
         * The IP address pool of the client.
         */
        clientIpPool: string;
        /**
         * Whether to compress.
         */
        compress: boolean;
        /**
         * The number of current connections.
         */
        connections: number;
        /**
         * The time of creation.
         */
        createTime: string;
        /**
         * The ID of the SSL-VPN server.
         */
        id: string;
        /**
         * The public IP.
         */
        internetIp: string;
        /**
         * The local subnet of the VPN connection.
         */
        localSubnet: string;
        /**
         * The maximum number of connections.
         */
        maxConnections: number;
        /**
         * The name of the SSL-VPN server.
         */
        name: string;
        /**
         * The port used by the SSL-VPN server.
         */
        port: number;
        /**
         * The protocol used by the SSL-VPN server.
         */
        proto: string;
        /**
         * Use the VPN gateway ID as the search key.
         */
        vpnGatewayId: string;
    }

    export interface GetSwitchesVswitch {
        /**
         * The available ip address count of the VSwitch.
         */
        availableIpAddressCount: number;
        /**
         * Filter results by a specific CIDR block. For example: "172.16.0.0/12".
         */
        cidrBlock: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the VSwitch.
         */
        description: string;
        /**
         * ID of the VSwitch.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the switch.
         */
        ipv6CidrBlock: string;
        /**
         * Indicate whether the VSwitch is created by the system.
         */
        isDefault: boolean;
        /**
         * Name of the VSwitch.
         */
        name: string;
        /**
         * The Id of resource group which VSWitch belongs.
         */
        resourceGroupId: string;
        /**
         * The route table ID of the VSwitch.
         */
        routeTableId: string;
        /**
         * The status of the VSwitch. Valid values: `Available` and `Pending`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC that owns the VSwitch.
         */
        vpcId: string;
        /**
         * ID of the VSwitch.
         */
        vswitchId: string;
        /**
         * The name of the VSwitch.
         */
        vswitchName: string;
        /**
         * The availability zone of the VSwitch.
         */
        zoneId: string;
    }

    export interface GetTrafficMirrorFilterEgressRulesRule {
        /**
         * The destination CIDR block of the outbound traffic.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of the outbound traffic.
         */
        destinationPortRange: string;
        /**
         * The ID of the Traffic Mirror Filter Egress Rule.
         */
        id: string;
        /**
         * The priority of the outbound rule. A smaller value indicates a higher priority. The maximum value is `10`, which indicates that you can configure at most 10 inbound rules for a filter.
         */
        priority: number;
        /**
         * The transport protocol used by outbound traffic that needs to be mirrored. Valid values: `ALL`, `ICMP`, `TCP`, `UDP`.
         */
        protocol: string;
        /**
         * The collection policy of the inbound rule. Valid values: `accept` or `drop`. `accept`: collects network traffic. `drop`: does not collect network traffic.
         */
        ruleAction: string;
        /**
         * The source CIDR block of the outbound traffic.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of the outbound traffic.
         */
        sourcePortRange: string;
        /**
         * The status of the resource. Valid values:`Creating`, `Created`, `Modifying` and `Deleting`.
         */
        status: string;
        /**
         * The ID of the filter associated with the outbound rule.
         */
        trafficMirrorFilterId: string;
        /**
         * The first ID of the resource.
         */
        trafficMirrorFilterRuleId: string;
    }

    export interface GetTrafficMirrorFilterIngressRulesRule {
        /**
         * The destination CIDR block of the inbound traffic.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of the inbound traffic.
         */
        destinationPortRange: string;
        /**
         * The ID of the Traffic Mirror Filter Egress Rule.
         */
        id: string;
        /**
         * The priority of the inbound rule. A smaller value indicates a higher priority. The maximum value is `10`, which indicates that you can configure at most 10 inbound rules for a filter.
         */
        priority: number;
        /**
         * The transport protocol used by inbound traffic that needs to be mirrored. Valid values: `ALL`, `ICMP`, `TCP`, `UDP`.
         */
        protocol: string;
        /**
         * The collection policy of the inbound rule. Valid values: `accept` or `drop`. `accept`: collects network traffic. `drop`: does not collect network traffic.
         */
        ruleAction: string;
        /**
         * The source CIDR block of the inbound traffic.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of the inbound traffic.
         */
        sourcePortRange: string;
        /**
         * The status of the resource. Valid values:`Creating`, `Created`, `Modifying` and `Deleting`.
         */
        status: string;
        /**
         * The ID of the filter associated with the inbound rule.
         */
        trafficMirrorFilterId: string;
        /**
         * The first ID of the resource.
         */
        trafficMirrorFilterRuleId: string;
    }

    export interface GetTrafficMirrorFiltersFilter {
        /**
         * The ID of the Traffic Mirror Filter.
         */
        id: string;
        /**
         * The state of the filter. Valid values:`Creating`, `Created`, `Modifying` and `Deleting`. `Creating`: The filter is being created. `Created`: The filter is created. `Modifying`: The filter is being modified. `Deleting`: The filter is being deleted.
         */
        status: string;
        /**
         * The description of the filter.
         */
        trafficMirrorFilterDescription: string;
        /**
         * The ID of the filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The name of the filter.
         */
        trafficMirrorFilterName: string;
    }

    export interface GetTrafficMirrorSessionsSession {
        /**
         * Indicates whether traffic mirror sessions are enabled. default to `false`.
         */
        enabled: boolean;
        /**
         * The ID of the Traffic Mirror Session.
         */
        id: string;
        /**
         * The maximum transmission unit (MTU).
         */
        packetLength: number;
        /**
         * The priority of the traffic mirror session. A smaller value indicates a higher priority.
         */
        priority: number;
        /**
         * The state of the traffic mirror session. Valid values: `Creating`, `Created`, `Modifying` and `Deleting`.
         */
        status: string;
        /**
         * The ID of the filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The state of the traffic mirror session. Valid values: `Normal` or `FinancialLocked`. `Normal`: working as expected. `FinancialLocked`: locked due to overdue payments.
         */
        trafficMirrorSessionBusinessStatus: string;
        /**
         * The description of the traffic mirror session.
         */
        trafficMirrorSessionDescription: string;
        /**
         * The first ID of the resource.
         */
        trafficMirrorSessionId: string;
        /**
         * The name of the traffic mirror session.
         */
        trafficMirrorSessionName: string;
        /**
         * The ID of the mirror source.
         */
        trafficMirrorSourceIds: string[];
        /**
         * The ID of the mirror destination. You can specify only an ENI or a Server Load Balancer (SLB) instance as a mirror destination.
         */
        trafficMirrorTargetId: string;
        /**
         * The type of the mirror destination. Valid values: `NetworkInterface` or `SLB`. `NetworkInterface`: an ENI. `SLB`: an internal-facing SLB instance
         */
        trafficMirrorTargetType: string;
        /**
         * You can specify VNIs to distinguish different mirrored traffic.
         */
        virtualNetworkId: number;
    }

    export interface GetVpcFlowLogsLog {
        /**
         * The Description of flow log.
         */
        description: string;
        /**
         * The flow log ID.
         */
        flowLogId: string;
        /**
         * The flow log name.
         */
        flowLogName: string;
        /**
         * The ID of the Flow Log.
         */
        id: string;
        /**
         * The log store name.
         */
        logStoreName: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The resource id.
         */
        resourceId: string;
        /**
         * The resource type.
         */
        resourceType: string;
        /**
         * The status of flow log.
         */
        status: string;
        /**
         * The traffic type.
         */
        trafficType: string;
    }

    export interface NetworkAclAttachmentResource {
        /**
         * The resource id that the network acl will associate with.
         */
        resourceId: string;
        /**
         * The resource id that the network acl will associate with. Only support `VSwitch` now.
         */
        resourceType: string;
    }

    export interface NetworkAclEgressAclEntry {
        /**
         * The description of the network ACL.The description must be 1 to 256 characters in length and cannot start with http:// or https.
         */
        description?: string;
        /**
         * The network of the destination address.
         */
        destinationCidrIp?: string;
        /**
         * Name of the outbound rule entry.The name must be 1 to 128 characters in length and cannot start with http:// or https.
         */
        networkAclEntryName?: string;
        /**
         * Authorization policy. Value:
         * - accept: Allow.
         * - drop: Refused.
         * - accept: Allow.
         * - drop: Refused.
         */
        policy?: string;
        /**
         * The destination port range of the outbound rule.When the Protocol type of the outbound rule is all, icmp, or gre, the port range is - 1/-1, indicating that the port is not restricted.When the Protocol type of the outbound rule is tcp or udp, the port range is 1 to 65535, and the format is 1/200 or 80/80, indicating port 1 to port 200 or port 80.
         */
        port?: string;
        /**
         * The protocol type. Value:
         * - icmp: Network Control Message Protocol.
         * - gre: Generic Routing Encapsulation Protocol.
         * - tcp: Transmission Control Protocol.
         * - udp: User Datagram Protocol.
         * - all: Supports all protocols.
         *
         * - icmp: Network Control Message Protocol.
         * - gre: Generic Routing Encapsulation Protocol.
         * - tcp: Transmission Control Protocol.
         * - udp: User Datagram Protocol.
         * - all: Supports all protocols.
         */
        protocol?: string;
    }

    export interface NetworkAclEntriesEgress {
        /**
         * The description of the ingress entry.
         */
        description: string;
        /**
         * The destination ip of the egress entry.
         */
        destinationCidrIp: string;
        /**
         * The entry type of the ingress entry. It must be `custom` or `system`. Default value is `custom`.
         */
        entryType: string;
        /**
         * The name of the ingress entry.
         */
        name: string;
        /**
         * The policy of the ingress entry. It must be `accept` or `drop`.
         */
        policy: string;
        /**
         * The port of the ingress entry.
         */
        port: string;
        /**
         * The protocol of the ingress entry.
         */
        protocol: string;
    }

    export interface NetworkAclEntriesIngress {
        /**
         * The description of the ingress entry.
         */
        description: string;
        /**
         * The entry type of the ingress entry. It must be `custom` or `system`. Default value is `custom`.
         */
        entryType: string;
        /**
         * The name of the ingress entry.
         */
        name: string;
        /**
         * The policy of the ingress entry. It must be `accept` or `drop`.
         */
        policy: string;
        /**
         * The port of the ingress entry.
         */
        port: string;
        /**
         * The protocol of the ingress entry.
         */
        protocol: string;
        /**
         * The source ip of the ingress entry.
         */
        sourceCidrIp: string;
    }

    export interface NetworkAclIngressAclEntry {
        /**
         * The description of the network ACL.The description must be 1 to 256 characters in length and cannot start with http:// or https.
         */
        description?: string;
        /**
         * Name of the outbound rule entry.The name must be 1 to 128 characters in length and cannot start with http:// or https.
         */
        networkAclEntryName?: string;
        /**
         * Authorization policy. Value:
         * - accept: Allow.
         * - drop: Refused.
         * - accept: Allow.
         * - drop: Refused.
         */
        policy?: string;
        /**
         * The destination port range of the outbound rule.When the Protocol type of the outbound rule is all, icmp, or gre, the port range is - 1/-1, indicating that the port is not restricted.When the Protocol type of the outbound rule is tcp or udp, the port range is 1 to 65535, and the format is 1/200 or 80/80, indicating port 1 to port 200 or port 80.
         */
        port?: string;
        /**
         * The protocol type. Value:
         * - icmp: Network Control Message Protocol.
         * - gre: Generic Routing Encapsulation Protocol.
         * - tcp: Transmission Control Protocol.
         * - udp: User Datagram Protocol.
         * - all: Supports all protocols.
         *
         * - icmp: Network Control Message Protocol.
         * - gre: Generic Routing Encapsulation Protocol.
         * - tcp: Transmission Control Protocol.
         * - udp: User Datagram Protocol.
         * - all: Supports all protocols.
         */
        protocol?: string;
        /**
         * Source address network segment.
         */
        sourceCidrIp?: string;
    }

    export interface NetworkAclResource {
        /**
         * The ID of the associated resource.
         */
        resourceId: string;
        /**
         * The type of the associated resource.
         */
        resourceType: string;
        /**
         * The state of the network ACL.
         */
        status: string;
    }

    export interface NetworkIpv6CidrBlock {
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The IPv6 address segment type of the VPC. Value:
         * - **BGP** (default): Alibaba Cloud BGP IPv6.
         * - **ChinaMobile**: China Mobile (single line).
         * - **ChinaUnicom**: China Unicom (single line).
         * - **ChinaTelecom**: China Telecom (single line).
         * > **NOTE:**  If a single-line bandwidth whitelist is enabled, this field can be set to **ChinaTelecom** (China Telecom), **ChinaUnicom** (China Unicom), or **ChinaMobile** (China Mobile).
         */
        ipv6Isp: string;
    }

    export interface PrefixListEntry {
        /**
         * The CIDR address block of the prefix list.
         */
        cidr?: string;
        /**
         * The description of the cidr entry. It must be 2 to 256 characters in length and must start with a letter or Chinese, but cannot start with `http://` or `https://`.
         */
        description?: string;
    }

    export interface PrefixListPrefixListAssociation {
        /**
         * The ID of the Alibaba Cloud account (primary account) to which the prefix list belongs.
         */
        ownerId: string;
        /**
         * The ID of the query Prefix List.
         */
        prefixListId: string;
        /**
         * Reason when the association fails.
         */
        reason: string;
        /**
         * The region ID of the prefix list to be queried.
         */
        regionId: string;
        /**
         * The ID of the associated resource.
         */
        resourceId: string;
        /**
         * The associated resource type. Value:-**vpcRouteTable**: The VPC route table.-**trRouteTable**: the routing table of the forwarding router.
         */
        resourceType: string;
        /**
         * The ID of the Alibaba Cloud account (primary account) to which the resource bound to the prefix list belongs.
         */
        resourceUid: string;
        /**
         * Resource attribute fields that represent the status of the resource.
         */
        status: string;
    }

    export interface TrafficMirrorFilterEgressRule {
        /**
         * Collection strategy for outbound rules. Value:
         * - accept: collects network traffic.
         * - drop: No network traffic is collected.
         * - accept: collects network traffic.
         * - drop: No network traffic is collected.
         */
        action: string;
        /**
         * DestinationCidrBlock.
         */
        destinationCidrBlock?: string;
        /**
         * The destination port range of the outbound rule network traffic. The port range is 1 to 65535. Use a forward slash (/) to separate the start port and the end Port. The format is 1/200 and 80/80. Among them, - 1/-1 cannot be set separately, which means that the port is not limited.
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         */
        destinationPortRange?: string;
        /**
         * Priority.
         */
        priority?: number;
        /**
         * The type of protocol used by the outbound network traffic to be mirrored. Value:
         * - ALL: ALL agreements.
         * - ICMP: Network Control Message Protocol.
         * - TCP: Transmission Control Protocol.
         * - UDP: User Datagram Protocol.
         * - ALL: ALL agreements.
         * - ICMP: Network Control Message Protocol.
         * - TCP: Transmission Control Protocol.
         * - UDP: User Datagram Protocol.
         */
        protocol: string;
        /**
         * The source address of the outbound rule network traffic.
         */
        sourceCidrBlock?: string;
        /**
         * The source port range of the outbound rule network traffic. The port range is 1 to 65535. Use a forward slash (/) to separate the start port and the end Port. The format is 1/200 and 80/80. Among them, - 1/-1 cannot be set separately, which means that the port is not limited.
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         *
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         */
        sourcePortRange?: string;
        trafficMirrorFilterRuleStatus: string;
    }

    export interface TrafficMirrorFilterIngressRule {
        /**
         * Collection strategy for outbound rules. Value:
         * - accept: collects network traffic.
         * - drop: No network traffic is collected.
         * - accept: collects network traffic.
         * - drop: No network traffic is collected.
         */
        action: string;
        /**
         * DestinationCidrBlock.
         */
        destinationCidrBlock?: string;
        /**
         * The destination port range of the outbound rule network traffic. The port range is 1 to 65535. Use a forward slash (/) to separate the start port and the end Port. The format is 1/200 and 80/80. Among them, - 1/-1 cannot be set separately, which means that the port is not limited.
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         */
        destinationPortRange?: string;
        /**
         * Priority.
         */
        priority?: number;
        /**
         * The type of protocol used by the outbound network traffic to be mirrored. Value:
         * - ALL: ALL agreements.
         * - ICMP: Network Control Message Protocol.
         * - TCP: Transmission Control Protocol.
         * - UDP: User Datagram Protocol.
         * - ALL: ALL agreements.
         * - ICMP: Network Control Message Protocol.
         * - TCP: Transmission Control Protocol.
         * - UDP: User Datagram Protocol.
         */
        protocol: string;
        /**
         * The source address of the outbound rule network traffic.
         */
        sourceCidrBlock?: string;
        /**
         * The source port range of the outbound rule network traffic. The port range is 1 to 65535. Use a forward slash (/) to separate the start port and the end Port. The format is 1/200 and 80/80. Among them, - 1/-1 cannot be set separately, which means that the port is not limited.
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         *
         * > **NOTE:**  When egresrules. N.Protocol is set to ALL or ICMP, this parameter does not need to be configured, indicating that the port is not restricted.
         */
        sourcePortRange?: string;
        trafficMirrorFilterRuleStatus: string;
    }

}

export namespace vpn {
    export interface ConnectionBgpConfig {
        /**
         * Whether to enable Health Check.
         */
        enable: boolean;
        /**
         * The ASN on the Alibaba Cloud side.
         */
        localAsn: string;
        /**
         * The BGP IP address on the Alibaba Cloud side.
         */
        localBgpIp: string;
        /**
         * The CIDR block of the IPsec tunnel. The CIDR block belongs to 169.254.0.0/16. The mask of the CIDR block is 30 bits in length.
         */
        tunnelCidr: string;
    }

    export interface ConnectionHealthCheckConfig {
        /**
         * The destination IP address.
         */
        dip: string;
        /**
         * Whether to enable Health Check.
         */
        enable: boolean;
        /**
         * The interval between two consecutive health checks. Unit: seconds.
         */
        interval: number;
        /**
         * The maximum number of health check retries.
         */
        retry: number;
        /**
         * The source IP address.
         */
        sip: string;
    }

    export interface ConnectionIkeConfig {
        /**
         * The authentication algorithm of phase-one negotiation. Valid value: md5 | sha1 . Default value: md5
         */
        ikeAuthAlg: string;
        /**
         * The encryption algorithm of phase-one negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default Valid value: aes
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation. The valid value of n is [0, 86400], the unit is second and the default value is 86400.
         */
        ikeLifetime?: number;
        /**
         * The identification of the VPN gateway.
         */
        ikeLocalId: string;
        /**
         * The negotiation mode of IKE V1. Valid value: main (main mode) | aggressive (aggressive mode). Default value: main
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation. Valid value: group1 | group2 | group5 | group14 | group24. Default value: group2
         */
        ikePfs?: string;
        /**
         * The identification of the customer gateway.
         */
        ikeRemoteId: string;
        /**
         * The version of the IKE protocol. Valid value: ikev1 | ikev2. Default value: ikev1
         */
        ikeVersion?: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
    }

    export interface ConnectionIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation. Valid value: md5 | sha1 | sha256 | sha384 | sha512 |. Default value: sha1
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default value: aes
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation. The valid value is [0, 86400], the unit is second and the default value is 86400.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation. Valid value: group1 | group2 | group5 | group14 | group24| disabled. Default value: group2
         */
        ipsecPfs?: string;
    }

    export interface GatewayVpnAttachmentBgpConfig {
        /**
         * Specifies whether to enable health checks.
         */
        enable: boolean;
        /**
         * The ASN on the Alibaba Cloud side.
         */
        localAsn: number;
        /**
         * The BGP IP address on the Alibaba Cloud side.
         */
        localBgpIp: string;
        /**
         * The CIDR block of the IPsec tunnel. The CIDR block belongs to 169.254.0.0/16. The mask of the CIDR block is 30 bits in length.
         */
        tunnelCidr: string;
    }

    export interface GatewayVpnAttachmentHealthCheckConfig {
        /**
         * The destination IP address that is used for health checks.
         */
        dip: string;
        /**
         * Specifies whether to enable health checks.
         */
        enable: boolean;
        /**
         * The interval between two consecutive health checks. Unit: seconds.
         */
        interval: number;
        /**
         * Whether to revoke the published route when the health check fails. Valid values: `revokeRoute` or `reserveRoute`.
         */
        policy: string;
        /**
         * The maximum number of health check retries.
         */
        retry: number;
        /**
         * The source IP address that is used for health checks.
         */
        sip: string;
    }

    export interface GatewayVpnAttachmentIkeConfig {
        /**
         * IKE authentication algorithm supports sha1 and MD5.
         */
        ikeAuthAlg: string;
        /**
         * The encryption algorithm of phase-one negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default Valid value: aes.
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation. The valid value of n is [0, 86400], the unit is second and the default value is 86400.
         */
        ikeLifetime?: number;
        /**
         * The negotiation mode of IKE V1. Valid value: main (main mode) | aggressive (aggressive mode). Default value: `main`.
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation. Valid value: group1 | group2 | group5 | group14 | group24. Default value: group2
         */
        ikePfs?: string;
        /**
         * The version of the IKE protocol. Valid value: `ikev1`, `ikev2`. Default value: `ikev1`.
         */
        ikeVersion?: string;
        /**
         * The local ID, which supports the FQDN and IP formats. The current VPN gateway IP address is selected by default.
         */
        localId: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
        /**
         * The peer ID, which supports FQDN and IP formats. By default, the IP address of the currently selected user gateway.
         */
        remoteId: string;
    }

    export interface GatewayVpnAttachmentIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation. Valid value: md5 | sha1 | sha256 | sha384 | sha512 |. Default value: sha1
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default value: aes
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation. The valid value is [0, 86400], the unit is second and the default value is 86400.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation. Valid value: group1 | group2 | group5 | group14 | group24| disabled. Default value: group2
         */
        ipsecPfs?: string;
    }

    export interface GetConnectionsConnection {
        createTime: string;
        /**
         * Use the VPN customer gateway ID as the search key.
         */
        customerGatewayId: string;
        effectImmediately: boolean;
        /**
         * Specifies whether to enable the dead peer detection (DPD) feature.
         */
        enableDpd: boolean;
        /**
         * Specifies whether to enable NAT traversal.
         */
        enableNatTraversal: boolean;
        /**
         * ID of the VPN connection.
         */
        id: string;
        /**
         * The configurations of phase-one negotiation.
         */
        ikeConfigs?: outputs.vpn.GetConnectionsConnectionIkeConfig[];
        /**
         * The configurations of phase-two negotiation.
         */
        ipsecConfigs?: outputs.vpn.GetConnectionsConnectionIpsecConfig[];
        /**
         * The local subnet of the VPN connection.
         */
        localSubnet: string;
        /**
         * The name of the VPN connection.
         */
        name: string;
        /**
         * The remote subnet of the VPN connection.
         */
        remoteSubnet: string;
        /**
         * The negotiation status of the BGP routing protocol. Valid values: `success`, `false`.
         */
        status: string;
        vcoHealthChecks?: outputs.vpn.GetConnectionsConnectionVcoHealthCheck[];
        /**
         * The configuration information for BGP.
         */
        vpnBgpConfigs?: outputs.vpn.GetConnectionsConnectionVpnBgpConfig[];
        /**
         * Use the VPN gateway ID as the search key.
         */
        vpnGatewayId: string;
    }

    export interface GetConnectionsConnectionIkeConfig {
        /**
         * The authentication algorithm of phase-one negotiation.
         */
        ikeAuthAlg?: string;
        /**
         * The encryption algorithm of phase-one negotiation.
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation.
         */
        ikeLifetime?: number;
        /**
         * The identification of the VPN gateway.
         */
        ikeLocalId?: string;
        /**
         * The negotiation mode of IKE phase-one.
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation.
         */
        ikePfs?: string;
        /**
         * The identification of the customer gateway.
         */
        ikeRemoteId?: string;
        /**
         * The version of the IKE protocol.
         */
        ikeVersion?: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
    }

    export interface GetConnectionsConnectionIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation.
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation.
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation.
         */
        ipsecPfs?: string;
    }

    export interface GetConnectionsConnectionVcoHealthCheck {
        /**
         * The destination ip address.
         */
        dip?: string;
        /**
         * The health check on status. Valid values: `true`, `false`.
         */
        enable?: string;
        /**
         * The time interval between health checks.
         */
        interval?: number;
        /**
         * The number of retries for health checks issued.
         */
        retry?: number;
        /**
         * The source ip address.
         */
        sip?: string;
        /**
         * The negotiation status of the BGP routing protocol. Valid values: `success`, `false`.
         */
        status?: string;
    }

    export interface GetConnectionsConnectionVpnBgpConfig {
        /**
         * The authentication keys for BGP routing protocols.
         */
        authKey?: string;
        /**
         * The ali cloud side autonomous system.
         */
        localAsn?: number;
        /**
         * The ali cloud side BGP address.
         */
        localBgpIp?: string;
        /**
         * The counterpart autonomous system number.
         */
        peerAsn?: number;
        /**
         * The BGP address on the other side.
         */
        peerBgpIp?: string;
        /**
         * The negotiation status of the BGP routing protocol. Valid values: `success`, `false`.
         */
        status?: string;
        /**
         * The ipsec tunnel segments.
         */
        tunnelCidr?: string;
    }

    export interface GetCustomerGatewaysGateway {
        /**
         * The autonomous system number of the local data center gateway device of the VPN customer gateway.
         */
        asn: number;
        /**
         * The creation time of the VPN customer gateway.
         */
        createTime: string;
        /**
         * The description of the VPN customer gateway.
         */
        description: string;
        /**
         * ID of the VPN customer gateway .
         */
        id: string;
        /**
         * The ip address of the VPN customer gateway.
         */
        ipAddress: string;
        /**
         * The name of the VPN customer gateway.
         */
        name: string;
    }

    export interface GetGatewayVcoRoutesRoute {
        /**
         * List of autonomous system numbers through which BGP routing entries pass.
         */
        asPath: string;
        /**
         * The creation time of the VPN destination route.
         */
        createTime: string;
        /**
         * The ID of the Vpn Gateway Vco Routes.
         */
        id: string;
        /**
         * The next hop of the destination route.
         */
        nextHop: string;
        /**
         * The destination network segment of the destination route.
         */
        routeDest: string;
        /**
         * The source CIDR block of the destination route.
         */
        source: string;
        /**
         * The status of the vpn route entry.
         */
        status: string;
        /**
         * The id of the vpn connection.
         */
        vpnConnectionId: string;
        /**
         * The weight value of the destination route.
         */
        weight: number;
    }

    export interface GetGatewayVpnAttachmentsAttachment {
        /**
         * The configurations of the BGP routing protocol.
         */
        bgpConfigs: outputs.vpn.GetGatewayVpnAttachmentsAttachmentBgpConfig[];
        /**
         * The status of the IPsec-VPN connection.
         */
        connectionStatus: string;
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the customer gateway.
         */
        customerGatewayId: string;
        /**
         * Indicates whether IPsec-VPN negotiations are initiated immediately. Valid values.
         */
        effectImmediately: boolean;
        /**
         * The health check configurations.
         */
        healthCheckConfigs: outputs.vpn.GetGatewayVpnAttachmentsAttachmentHealthCheckConfig[];
        /**
         * The ID of the Vpn Attachment.
         */
        id: string;
        /**
         * Configuration negotiated in the second stage.
         */
        ikeConfigs: outputs.vpn.GetGatewayVpnAttachmentsAttachmentIkeConfig[];
        /**
         * The internet ip of the resource. The alicloud.cen.TransitRouterVpnAttachment resource will not have a value until after it is created.
         */
        internetIp: string;
        /**
         * The configuration of Phase 2 negotiations.
         */
        ipsecConfigs: outputs.vpn.GetGatewayVpnAttachmentsAttachmentIpsecConfig[];
        /**
         * The CIDR block of the virtual private cloud (VPC).
         */
        localSubnet: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The CIDR block of the on-premises data center.
         */
        remoteSubnet: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The name of the IPsec-VPN connection.
         */
        vpnAttachmentName: string;
        /**
         * The first ID of the resource.
         */
        vpnConnectionId: string;
    }

    export interface GetGatewayVpnAttachmentsAttachmentBgpConfig {
        /**
         * The ASN on the Alibaba Cloud side.
         */
        localAsn: string;
        /**
         * The BGP IP address on the Alibaba Cloud side.
         */
        localBgpIp: string;
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The CIDR block of the IPsec tunnel. The CIDR block belongs to 169.254.0.0/16. The mask of the CIDR block is 30 bits in length.
         */
        tunnelCidr: string;
    }

    export interface GetGatewayVpnAttachmentsAttachmentHealthCheckConfig {
        /**
         * The destination IP address.
         */
        dip: string;
        /**
         * Specifies whether to enable health checks.
         */
        enable: boolean;
        /**
         * The interval between two consecutive health checks. Unit: seconds.
         */
        interval: number;
        /**
         * Whether to revoke the published route when the health check fails.
         */
        policy: string;
        /**
         * The maximum number of health check retries.
         */
        retry: number;
        /**
         * The source IP address.
         */
        sip: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetGatewayVpnAttachmentsAttachmentIkeConfig {
        /**
         * The IKE authentication algorithm.
         */
        ikeAuthAlg: string;
        /**
         * The IKE encryption algorithm.
         */
        ikeEncAlg: string;
        /**
         * The IKE lifetime. Unit: seconds.
         */
        ikeLifetime: string;
        /**
         * The IKE negotiation mode.
         */
        ikeMode: string;
        /**
         * The DH group.
         */
        ikePfs: string;
        /**
         * The version of the IKE protocol.
         */
        ikeVersion: string;
        /**
         * The local ID, which supports the FQDN and IP formats. The current VPN gateway IP address is selected by default. The alicloud.cen.TransitRouterVpnAttachment resource will not have a value until after it is created.
         */
        localId: string;
        /**
         * The pre-shared key.
         */
        psk: string;
        /**
         * The identifier of the peer. The default value is the IP address of the VPN gateway. The value can be a fully qualified domain name (FQDN) or an IP address.
         */
        remoteId: string;
    }

    export interface GetGatewayVpnAttachmentsAttachmentIpsecConfig {
        /**
         * The IPsec authentication algorithm.
         */
        ipsecAuthAlg: string;
        /**
         * The IPsec encryption algorithm.
         */
        ipsecEncAlg: string;
        /**
         * The IPsec lifetime. Unit: seconds.
         */
        ipsecLifetime: string;
        /**
         * The DH group.
         */
        ipsecPfs: string;
    }

    export interface GetGatewaysGateway {
        /**
         * Whether to automatically propagate BGP routes to the VPC. Valid values: `true`, `false`.
         */
        autoPropagate: string;
        /**
         * Limit search to specific business status - valid value is "Normal", "FinancialLocked".
         */
        businessStatus: string;
        /**
         * The creation time of the VPN gateway.
         */
        createTime: string;
        /**
         * The description of the VPN
         */
        description: string;
        /**
         * Indicates whether the IPsec-VPN feature is enabled.
         */
        enableIpsec: string;
        /**
         * Whether the ssl function is enabled.
         */
        enableSsl: string;
        /**
         * The expiration time of the VPN gateway.
         */
        endTime: string;
        /**
         * ID of the VPN.
         */
        id: string;
        /**
         * The charge type of the VPN gateway.
         */
        instanceChargeType: string;
        /**
         * The internet ip of the VPN.
         */
        internetIp: string;
        /**
         * The name of the VPN.
         */
        name: string;
        /**
         * The network type of the VPN gateway.
         */
        networkType: string;
        /**
         * The Specification of the VPN
         */
        specification: string;
        /**
         * Total count of ssl vpn connections.
         */
        sslConnections: number;
        /**
         * Limit search to specific status - valid value is "Init", "Provisioning", "Active", "Updating", "Deleting".
         */
        status: string;
        /**
         * Use the VPC ID as the search key.
         */
        vpcId: string;
    }

    export interface IpsecServerIkeConfig {
        /**
         * The authentication algorithm that is used in Phase 1 negotiations. Default value: `sha1`.
         */
        ikeAuthAlg?: string;
        /**
         * The encryption algorithm that is used in Phase 1 negotiations. Default value: `aes`.
         */
        ikeEncAlg?: string;
        /**
         * IkeLifetime: the SA lifetime determined by Phase 1 negotiations. Valid values: `0` to `86400`. Default value: `86400`. Unit: `seconds`.
         */
        ikeLifetime?: number;
        /**
         * The IKE negotiation mode. Default value: `main`.
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm that is used in Phase 1 negotiations. Default value: `group2`.
         */
        ikePfs?: string;
        /**
         * The IKE version. Valid values: `ikev1` and `ikev2`. Default value: `ikev2`.
         */
        ikeVersion?: string;
        /**
         * The identifier of the IPsec server. The value can be a fully qualified domain name (FQDN) or an IP address. The default value is the public IP address of the VPN gateway.
         */
        localId?: string;
        /**
         * The identifier of the customer gateway. The value can be an FQDN or an IP address. By default, this parameter is not specified.
         */
        remoteId?: string;
    }

    export interface IpsecServerIpsecConfig {
        /**
         * The authentication algorithm that is used in Phase 2 negotiations. Default value: `sha1`.
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm that is used in Phase 2 negotiations. Default value: `aes`.
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifetime determined by Phase 2 negotiations. Valid values: `0` to `86400`. Default value: `86400`. Unit: `seconds`.
         */
        ipsecLifetime?: number;
        /**
         * Forwards packets of all protocols. The Diffie-Hellman key exchange algorithm used in Phase 2 negotiations. Default value: `group2`.
         */
        ipsecPfs?: string;
    }

}

export namespace waf {
    export interface DomainLogHeader {
        key?: string;
        value?: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Certificate recording ID.
         */
        certificateId: string;
        /**
         * Your certificate name.
         */
        certificateName: string;
        /**
         * Certificate bound to the domain name.
         */
        commonName: string;
        /**
         * The domain that you want to add to WAF.
         */
        domain: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * WAF instance ID.
         */
        instanceId: string;
        isUsing: boolean;
        sans: string[];
    }

    export interface GetDomainsDomain {
        /**
         * The type of the WAF cluster.
         */
        clusterType: string;
        /**
         * The CNAME record assigned by the WAF instance to the specified domain.
         */
        cname: string;
        /**
         * The connection timeout for WAF exclusive clusters. Valid values: `PhysicalCluster` and `VirtualCluster`. Default to `PhysicalCluster`.
         */
        connectionTime: number;
        /**
         * Field `domain` has been deprecated from version 1.94.0. Use `domainName` instead.
         */
        domain: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * List of the HTTP 2.0 ports.
         */
        http2Ports: string[];
        /**
         * List of the HTTP ports.
         */
        httpPorts: string[];
        /**
         * Specifies whether to enable the HTTP back-to-origin feature. After this feature is enabled, the WAF instance can use HTTP to forward HTTPS requests to the origin server.
         */
        httpToUserIp: string;
        /**
         * List of the HTTPS ports.
         */
        httpsPorts: string[];
        /**
         * Specifies whether to redirect HTTP requests as HTTPS requests. Valid values: `On` and `Off`. Default to `Off`.
         */
        httpsRedirect: string;
        /**
         * The ID of domain self ID, value as `domainName`.
         */
        id: string;
        /**
         * Specifies whether to configure a Layer-7 proxy, such as Anti-DDoS Pro or CDN, to filter the inbound traffic before it is forwarded to WAF. Valid values: `On` and "Off". Default to `Off`.
         */
        isAccessProduct: string;
        /**
         * The load balancing algorithm that is used to forward requests to the origin. Valid values: `IpHash` and `RoundRobin`. Default to `IpHash`.
         */
        loadBalancing: string;
        /**
         * The key-value pair that is used to mark the traffic that flows through WAF to the domain. Each item contains two field:
         */
        logHeaders: outputs.waf.GetDomainsDomainLogHeader[];
        /**
         * The read timeout of a WAF exclusive cluster. Unit: seconds.
         */
        readTime: number;
        /**
         * The ID of the resource group to which the queried domain belongs in Resource Management.
         */
        resourceGroupId: string;
        /**
         * List of the IP address or domain of the origin server to which the specified domain points.
         */
        sourceIps: string[];
        /**
         * The system data identifier that is used to control optimistic locking.
         */
        version: number;
        /**
         * The timeout period for a WAF exclusive cluster write connection. Unit: seconds.
         */
        writeTime: number;
    }

    export interface GetDomainsDomainLogHeader {
        /**
         * The key of label.
         */
        key: string;
        /**
         * The value of label.
         */
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The timestamp (in seconds) indicating when the WAF instance expires.
         */
        endDate: number;
        /**
         * The ID of the WAF instance.
         */
        id: string;
        /**
         * Indicates whether the WAF instance has overdue payments.
         */
        inDebt: number;
        /**
         * The ID of WAF the instance.
         */
        instanceId: string;
        /**
         * The number of days before the trial period of the WAF instance expires.
         */
        remainDay: number;
        /**
         * The status of WAF instance to filter results. Optional value: `0`: The instance has expired, `1` : The instance has not expired and is working properly.
         */
        status: number;
        subscriptionType: string;
        /**
         * Indicates whether this is a trial instance.
         */
        trial: number;
    }

}

export namespace wafv3 {
    export interface DomainListen {
        /**
         * The ID of the certificate to be added. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        certId?: string;
        /**
         * The type of encryption suite to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **1**: indicates that all encryption suites are added.
         * - **2**: indicates that a strong encryption package is added. You can select this value only if the value of **tls_version** is `tlsv1.2`.
         * - **99**: indicates that a custom encryption suite is added.
         */
        cipherSuite?: number;
        /**
         * The specific custom encryption suite to add.
         */
        customCiphers?: string[];
        /**
         * Whether TSL1.3 version is supported. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that TSL1.3 is supported.
         * - **false**: indicates that TSL1.3 is not supported.
         */
        enableTlsv3?: boolean;
        /**
         * Whether to enable exclusive IP address. This parameter is used only when the value of **ipv6_enabled** is **false** (indicating that IPv6 is not enabled) and the value of **protection_resource** is **share** (indicating that a shared cluster is used). Value:
         * - **true**: indicates that the exclusive IP address is enabled.
         * - **false** (default): indicates that exclusive IP address is not enabled.
         */
        exclusiveIp?: boolean;
        /**
         * Whether to enable the forced jump of HTTPS. This parameter is used only when the value of `httpsPorts` is not empty (indicating that the domain name uses HTTPS protocol) and the value of httports is empty (indicating that the domain name does not use HTTP protocol). Value:
         * - **true**: indicates that HTTPS forced redirection is enabled.
         * - **false**: indicates that HTTPS forced redirection is not enabled.
         */
        focusHttps?: boolean;
        /**
         * Whether to turn on http2. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true:** indicates that HTTP2 is enabled.
         * - **false** (default): indicates that HTTP2 is not enabled.
         */
        http2Enabled?: boolean;
        /**
         * The listening port of the HTTP protocol.
         */
        httpPorts?: number[];
        /**
         * The listening port of the HTTPS protocol.
         */
        httpsPorts?: number[];
        /**
         * Whether IPv6 is turned on. Value:
         * - **true**: indicates that IPv6 is enabled.
         * - **false** (default): indicates that IPv6 is not enabled.
         */
        ipv6Enabled?: boolean;
        /**
         * The type of protection resource to use. Value:
         * - **share** (default): indicates that a shared cluster is used.
         * - **gslb**: indicates that the shared cluster intelligent load balancing is used.
         */
        protectionResource?: string;
        /**
         * The version of TLS to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value: **tlsv1**, **tlsv1.1**, **tlsv1.2**.
         */
        tlsVersion?: string;
        /**
         * WAF obtains the real IP address of the client. Value:
         * - **0** (default): indicates that the client has not forwarded the traffic to WAF through other layer -7 agents.
         * - **1**: indicates that the first value of the X-Forwarded-For(XFF) field in the WAF read request header is used as the client IP address.
         * - **2**: indicates that the custom field value set by you in the WAF read request header is used as the client IP address.
         */
        xffHeaderMode?: number;
        /**
         * Set the list of custom fields used to obtain the client IP address.
         */
        xffHeaders?: string[];
    }

    export interface DomainRedirect {
        /**
         * The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
         */
        backends?: string[];
        /**
         * Connection timeout. Unit: seconds, value range: 5~120.
         */
        connectTimeout?: number;
        /**
         * Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that forced HTTP back-to-origin is enabled.
         * - **false**: indicates that forced HTTP back-to-origin is not enabled.
         */
        focusHttpBackend?: boolean;
        /**
         * Open long connection, default true.
         */
        keepalive?: boolean;
        /**
         * Number of long connections,  default: `60`. range :60-1000.
         */
        keepaliveRequests?: number;
        /**
         * Long connection over time, default: `15`. Range: 1-60.
         */
        keepaliveTimeout?: number;
        /**
         * The load balancing algorithm used when returning to the source. Value:
         * - **iphash**: indicates the IPHash algorithm.
         * - **roundRobin**: indicates the polling algorithm.
         * - **leastTime**: indicates the Least Time algorithm.
         * - This value can be selected only if the value of **protection_resource** is **gslb** (indicating that the protected resource type uses shared cluster intelligent load balancing).
         */
        loadbalance: string;
        /**
         * Read timeout duration. **Unit**: seconds, **Value range**: 5~1800.
         */
        readTimeout?: number;
        /**
         * The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is `[{" k ":"_key_"," v ":"_value_"}]`. whereKeyRepresents the specified custom request header field, andValueRepresents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.See the following `Block RequestHeaders`.
         */
        requestHeaders?: outputs.wafv3.DomainRedirectRequestHeader[];
        /**
         * Back to Source Retry. default: true, retry 3 times by default.
         */
        retry?: boolean;
        /**
         * Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that the back-to-source SNI is enabled.
         * - **false** (default) indicates that the back-to-source SNI is not enabled.
         */
        sniEnabled?: boolean;
        /**
         * Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).> This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
         */
        sniHost?: string;
        /**
         * Write timeout duration> **Unit**: seconds, **Value range**: 5~1800.
         */
        writeTimeout?: number;
    }

    export interface DomainRedirectRequestHeader {
        /**
         * The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{" k ":"_key_"," v ":"_value_"}]**. whereKeyRepresents the specified custom request header field, andValueRepresents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
         */
        key?: string;
        /**
         * The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{" k ":"_key_"," v ":"_value_"}]**. whereKeyRepresents the specified custom request header field, andValueRepresents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
         */
        value?: string;
    }

    export interface GetDomainsDomain {
        /**
         * The name of the domain name to query.
         */
        domain: string;
        /**
         * The ID of the domain. The value is formulated as `<instance_id>:<domain>`.
         */
        id: string;
        /**
         * Configure listening information
         */
        listens: outputs.wafv3.GetDomainsDomainListen[];
        /**
         * Configure forwarding information.
         */
        redirects: outputs.wafv3.GetDomainsDomainRedirect[];
        /**
         * The ID of the resource group
         */
        resourceManagerResourceGroupId: string;
        /**
         * The status of the domain.
         */
        status: string;
    }

    export interface GetDomainsDomainListen {
        /**
         * The ID of the certificate to be added. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        certId: string;
        /**
         * The type of encryption suite to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        cipherSuite: number;
        /**
         * The specific custom encryption suite to add.
         */
        customCiphers: string[];
        /**
         * Whether TSL1.3 version is supported. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        enableTlsv3: boolean;
        /**
         * Whether to enable exclusive IP address. This parameter is used only when the value of **ipv6_enabled** is **false** (indicating that IPv6 is not enabled) and the value of **protection_resource** is **share** (indicating that a shared cluster is used).
         */
        exclusiveIp: boolean;
        /**
         * Whether to enable the forced jump of HTTPS. This parameter is used only when the value of `httpsPorts` is not empty (indicating that the domain name uses HTTPS protocol) and the value of httports is empty (indicating that the domain name does not use HTTP protocol).
         */
        focusHttps: boolean;
        /**
         * Whether to turn on http2. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        http2Enabled: boolean;
        /**
         * The listening port of the HTTP protocol.
         */
        httpPorts: number[];
        /**
         * The listening port of the HTTPS protocol.
         */
        httpsPorts: number[];
        /**
         * Whether IPv6 is turned on.
         */
        ipv6Enabled: boolean;
        /**
         * The type of protection resource to use.
         */
        protectionResource: string;
        /**
         * The version of TLS to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        tlsVersion: string;
        /**
         * WAF obtains the real IP address of the client.
         */
        xffHeaderMode: number;
        /**
         * Set the list of custom fields used to obtain the client IP address.
         */
        xffHeaders: string[];
    }

    export interface GetDomainsDomainRedirect {
        /**
         * The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
         */
        backends: string[];
        /**
         * Connection timeout, Unit: seconds, value range: 5~120.
         */
        connectTimeout: number;
        /**
         * Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        focusHttpBackend: boolean;
        /**
         * Open long connection, default true.
         */
        keepalive: boolean;
        /**
         * Number of long connections, default: `60`. range :60-1000.
         */
        keepaliveRequests: number;
        /**
         * Long connection over time, default: `15`. Range: 1-60.
         */
        keepaliveTimeout: number;
        /**
         * The load balancing algorithm used when returning to the source.
         */
        loadbalance: string;
        /**
         * Read timeout duration. Unit: seconds, Value range: 5~1800.
         */
        readTimeout: number;
        /**
         * The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{" k ":"_key_"," v ":"_value_"}]**. whereKeyRepresents the specified custom request header field, andValueRepresents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
         */
        requestHeaders: outputs.wafv3.GetDomainsDomainRedirectRequestHeader[];
        /**
         * Back to Source Retry. default `true`, retry 3 times by default.
         */
        retry: boolean;
        /**
         * Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
         */
        sniEnabled: boolean;
        /**
         * Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).> This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
         */
        sniHost: string;
        /**
         * Write timeout duration. **Unit**: seconds, **Value range**:5~1800.
         */
        writeTimeout: number;
    }

    export interface GetDomainsDomainRedirectRequestHeader {
        /**
         * The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{" k ":"_key_"," v ":"_value_"}]**. whereKeyRepresents the specified custom request header field, andValueRepresents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
         */
        key: string;
        /**
         * The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{" k ":"_key_"," v ":"_value_"}]**. whereKeyRepresents the specified custom request header field, andValueRepresents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
         */
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The creation time of the resource.
         */
        createTime: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The first ID of the resource.
         */
        instanceId: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

}

export namespace yundun {
    export interface BastionHostInstanceAdAuthServer {
        account: string;
        baseDn: string;
        domain: string;
        emailMapping?: string;
        filter?: string;
        isSsl: boolean;
        mobileMapping?: string;
        nameMapping?: string;
        password: string;
        port: number;
        server: string;
        standbyServer?: string;
    }

    export interface BastionHostInstanceLdapAuthServer {
        account: string;
        baseDn: string;
        emailMapping?: string;
        filter?: string;
        isSsl?: boolean;
        loginNameMapping?: string;
        mobileMapping?: string;
        nameMapping?: string;
        password: string;
        port: number;
        server: string;
        standbyServer?: string;
    }

    export interface GetBastionHostInstancesInstance {
        description: string;
        id: string;
        instanceStatus: string;
        licenseCode: string;
        privateDomain: string;
        publicDomain: string;
        publicNetworkAccess: boolean;
        securityGroupIds: string[];
        tags?: {[key: string]: any};
        userVswitchId: string;
    }

    export interface GetDBAuditInstanceInstance {
        description: string;
        id: string;
        instanceStatus: string;
        licenseCode: string;
        privateDomain: string;
        publicDomain: string;
        publicNetworkAccess: boolean;
        tags?: {[key: string]: any};
        userVswitchId: string;
    }

}
