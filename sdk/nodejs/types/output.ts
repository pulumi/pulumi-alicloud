// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface GetRegionsRegion {
    /**
     * ID of the region.
     */
    id: string;
    /**
     * Name of the region in the local language.
     */
    localName: string;
    regionId: string;
}

export interface GetZonesZone {
    /**
     * Set of supported disk categories.
     */
    availableDiskCategories: string[];
    /**
     * Allowed instance types.
     */
    availableInstanceTypes: string[];
    /**
     * Filter the results by a specific resource type.
     * Valid values: `Instance`, `Disk`, `VSwitch`, `Rds`, `KVStore`, `FunctionCompute`, `Elasticsearch`, `Slb`.
     */
    availableResourceCreations: string[];
    /**
     * ID of the zone.
     */
    id: string;
    /**
     * Name of the zone in the local language.
     */
    localName: string;
    /**
     * A list of zone ids in which the multi zone.
     */
    multiZoneIds: string[];
    /**
     * A list of slb slave zone ids in which the slb master zone.
     */
    slbSlaveZoneIds: string[];
}

export interface ProviderAssumeRole {
    policy?: string;
    roleArn?: string;
    sessionExpiration?: number;
    sessionName?: string;
}

export interface ProviderEndpoint {
    actiontrail?: string;
    adb?: string;
    alidns?: string;
    alikafka?: string;
    apigateway?: string;
    brainIndustrial?: string;
    bssopenapi?: string;
    cas?: string;
    cassandra?: string;
    cbn?: string;
    cdn?: string;
    cen?: string;
    cms?: string;
    config?: string;
    cr?: string;
    cs?: string;
    datahub?: string;
    dcdn?: string;
    ddosbgp?: string;
    ddoscoo?: string;
    dds?: string;
    dmsEnterprise?: string;
    dns?: string;
    drds?: string;
    eci?: string;
    ecs?: string;
    eipanycast?: string;
    elasticsearch?: string;
    emr?: string;
    ess?: string;
    fc?: string;
    fnf?: string;
    ga?: string;
    gpdb?: string;
    hitsdb?: string;
    ims?: string;
    kms?: string;
    kvstore?: string;
    location?: string;
    log?: string;
    market?: string;
    maxcompute?: string;
    mns?: string;
    mse?: string;
    nas?: string;
    ons?: string;
    oos?: string;
    oss?: string;
    ots?: string;
    polardb?: string;
    privatelink?: string;
    pvtz?: string;
    quotas?: string;
    rKvstore?: string;
    ram?: string;
    rds?: string;
    resourcemanager?: string;
    resourcesharing?: string;
    ros?: string;
    sgw?: string;
    slb?: string;
    sts?: string;
    vpc?: string;
    wafOpenapi?: string;
}
export namespace actiontrail {
    export interface GetInstancesInstance {
        /**
         * The config the instance.
         */
        config: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The deploy type of the instance. 0: sharing instance, 1: vpc instance, 2: vpc instance(support ip mapping), 3: eip instance, 4: eip/vpc instance, 5: vpc instance.
         */
        deployType: number;
        /**
         * The disk size of the instance.
         */
        diskSize: number;
        /**
         * The disk type of the instance. 0: efficient cloud disk , 1: SSD.
         */
        diskType: number;
        /**
         * The peak bandwidth of the instance.
         */
        eipMax: number;
        /**
         * The endPoint to access the instance.
         */
        endPoint: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The peak value of io of the instance.
         */
        ioMax: number;
        /**
         * Name of the instance.
         */
        name: string;
        /**
         * The paid type of the instance.
         */
        paidType: string;
        /**
         * The security group of the instance.
         */
        securityGroup: string;
        /**
         * The current status of the instance. -1: unknown status, 0: wait deploy, 1: initializing, 2: preparing, 3 starting, 5: in service, 7: wait upgrade, 8: upgrading, 10: released, 15: freeze, 101: deploy error, 102: upgrade error.
         */
        serviceStatus: number;
        /**
         * The kafka openSource version of the instance.
         */
        serviceVersion: string;
        /**
         * The spec type of the instance.
         */
        specType: string;
        /**
         * The max num of topic can be create of the instance.
         */
        topicQuota: number;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The ID of attaching vswitch to instance.
         */
        vswitchId: string;
        /**
         * The ID of attaching zone to instance.
         */
        zoneId: string;
    }

    export interface GetSaslAclsAcl {
        /**
         * The operation type of the sasl acl.
         */
        aclOperationType: string;
        /**
         * Get results for the specified resource name.
         */
        aclResourceName: string;
        /**
         * The resource pattern type of the sasl acl.
         */
        aclResourcePatternType: string;
        /**
         * Get results for the specified resource type.
         */
        aclResourceType: string;
        /**
         * The host of the sasl acl.
         */
        host: string;
        /**
         * Get results for the specified username.
         */
        username: string;
    }

    export interface GetSaslUsersUser {
        /**
         * The password of the user.
         */
        password: string;
        /**
         * The username of the user.
         */
        username: string;
    }

    export interface GetTopicsTopic {
        /**
         * whether the current topic is kafka compact topic or not.
         */
        compactTopic: boolean;
        /**
         * Time of creation.
         */
        createTime: string;
        /**
         * whether the current topic is kafka local topic or not.
         */
        localTopic: boolean;
        /**
         * Partition number of the topic.
         */
        partitionNum: number;
        /**
         * Remark of the topic.
         */
        remark: string;
        /**
         * The current status code of the topic. There are three values to describe the topic status: 0 stands for the topic is in service, 1 stands for freezing and 2 stands for pause.
         */
        status: number;
        /**
         * The name of the topic.
         */
        topic: string;
    }

    export interface GetTrailsActiontrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        /**
         * The id of the ActionTrail Trail. It is the same as trail name.
         */
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        /**
         * Filter the results by status of the ActionTrail Trail. Valid values: `Disable`, `Enable`, `Fresh`.
         */
        status: string;
        /**
         * The name of the ActionTrail Trail.
         */
        trailName: string;
        /**
         * The regions to which the trail is applied.
         */
        trailRegion: string;
    }

    export interface GetTrailsDeprecatedActiontrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        status: string;
        trailName: string;
        trailRegion: string;
    }

    export interface GetTrailsDeprecatedTrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        status: string;
        trailName: string;
        trailRegion: string;
    }

    export interface GetTrailsTrail {
        /**
         * Indicates whether the event is a read or a write event.
         */
        eventRw: string;
        /**
         * The id of the ActionTrail Trail. It is the same as trail name.
         */
        id: string;
        isOrganizationTrail: boolean;
        /**
         * The name of the specified OSS bucket.
         */
        ossBucketName: string;
        /**
         * The prefix of the specified OSS bucket name.
         */
        ossKeyPrefix: string;
        ossWriteRoleArn: string;
        /**
         * The unique ARN of the Log Service project.
         */
        slsProjectArn: string;
        /**
         * The unique ARN of the Log Service role.
         */
        slsWriteRoleArn: string;
        /**
         * Filter the results by status of the ActionTrail Trail. Valid values: `Disable`, `Enable`, `Fresh`.
         */
        status: string;
        /**
         * The name of the ActionTrail Trail.
         */
        trailName: string;
        /**
         * The regions to which the trail is applied.
         */
        trailRegion: string;
    }
}

export namespace adb {
    export interface GetClustersCluster {
        autoRenewPeriod: number;
        /**
         * Billing method. Value options: `PostPaid` for Pay-As-You-Go and `PrePaid` for subscription.
         */
        chargeType: string;
        commodityCode: string;
        computeResource: string;
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        dbClusterCategory: string;
        dbClusterId: string;
        dbClusterNetworkType: string;
        dbClusterType: string;
        dbClusterVersion: string;
        /**
         * The DBNodeClass of the ADB cluster.
         */
        dbNodeClass: string;
        /**
         * The DBNodeCount of the ADB cluster.
         */
        dbNodeCount: number;
        /**
         * The DBNodeStorage of the ADB cluster.
         */
        dbNodeStorage: number;
        /**
         * The description of the ADB cluster.
         */
        description: string;
        diskType: string;
        dtsJobId: string;
        elasticIoResource: number;
        engine: string;
        engineVersion: string;
        executorCount: string;
        /**
         * Expiration time. Pay-As-You-Go clusters never expire.
         */
        expireTime: string;
        /**
         * The expired of the ADB cluster.
         */
        expired: string;
        /**
         * The ID of the ADB cluster.
         */
        id: string;
        /**
         * The LockMode of the ADB cluster.
         */
        lockMode: string;
        lockReason: string;
        maintainTime: string;
        /**
         * The DBClusterNetworkType of the ADB cluster.
         */
        networkType: string;
        paymentType: string;
        port: number;
        rdsInstanceId: string;
        /**
         * Region ID the cluster belongs to.
         */
        regionId: string;
        renewalStatus: string;
        resourceGroupId: string;
        securityIps: string[];
        /**
         * The status of the cluster. Valid values: `Preparing`, `Creating`, `Restoring`, `Running`, `Deleting`, `ClassChanging`, `NetAddressCreating`, `NetAddressDeleting`. For more information, see [Cluster status](https://www.alibabacloud.com/help/doc-detail/143075.htm).
         */
        status: string;
        storageResource: string;
        /**
         * A mapping of tags to assign to the resource.
         * - Key: It can be up to 64 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://". It cannot be a null string.
         * - Value: It can be up to 128 characters in length. It cannot begin with "aliyun", "acs:", "http://", or "https://". It can be a null string.
         */
        tags: {[key: string]: any};
        vpcCloudInstanceId: string;
        /**
         * ID of the VPC the cluster belongs to.
         */
        vpcId: string;
        vswitchId: string;
        /**
         * The ZoneId of the ADB cluster.
         */
        zoneId: string;
    }

    export interface GetDBClustersCluster {
        /**
         * Auto-renewal period of an cluster, in the unit of the month.
         */
        autoRenewPeriod: number;
        /**
         * The payment type of the resource.
         */
        chargeType: string;
        /**
         * The name of the service.
         */
        commodityCode: string;
        /**
         * The specifications of computing resources in elastic mode. The increase of resources can speed up queries. AnalyticDB for MySQL automatically scales computing resources. For more information, see [Specifications](https://www.alibabacloud.com/help/en/doc-detail/144851.htm).
         */
        computeResource: string;
        /**
         * The endpoint of the cluster.
         */
        connectionString: string;
        /**
         * The CreateTime of the ADB cluster.
         */
        createTime: string;
        /**
         * The db cluster category.
         */
        dbClusterCategory: string;
        /**
         * The db cluster id.
         */
        dbClusterId: string;
        /**
         * The db cluster network type.
         */
        dbClusterNetworkType: string;
        /**
         * The db cluster type.
         */
        dbClusterType: string;
        /**
         * The db cluster version.
         */
        dbClusterVersion: string;
        /**
         * The db node class.
         */
        dbNodeClass: string;
        /**
         * The db node count.
         */
        dbNodeCount: number;
        /**
         * The db node storage.
         */
        dbNodeStorage: number;
        /**
         * The description of DBCluster.
         */
        description: string;
        /**
         * The type of the disk.
         */
        diskType: string;
        /**
         * The ID of the data synchronization task in Data Transmission Service (DTS). This parameter is valid only for analytic instances.
         */
        dtsJobId: string;
        /**
         * The elastic io resource.
         */
        elasticIoResource: number;
        /**
         * The engine of the database.
         */
        engine: string;
        /**
         * The engine version of the database..
         */
        engineVersion: string;
        /**
         * The number of nodes. The node resources are used for data computing in elastic mode.
         */
        executorCount: string;
        /**
         * The time when the cluster expires.
         */
        expireTime: string;
        /**
         * Indicates whether the cluster has expired.
         */
        expired: string;
        /**
         * The ID of the DBCluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The reason why the cluster is locked.
         */
        lockReason: string;
        /**
         * The maintenance window of the cluster.
         */
        maintainTime: string;
        networkType: string;
        /**
         * The payment type of the resource.
         */
        paymentType: string;
        /**
         * The port that is used to access the cluster.
         */
        port: number;
        /**
         * The ID of the ApsaraDB RDS instance from which data is synchronized to the cluster. This parameter is valid only for analytic instances.
         */
        rdsInstanceId: string;
        regionId: string;
        /**
         * The status of renewal.
         */
        renewalStatus: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * List of IP addresses allowed to access all databases of an cluster.
         */
        securityIps: string[];
        /**
         * The status of the resource.
         */
        status: string;
        /**
         * The specifications of storage resources in elastic mode. The resources are used for data read and write operations. The increase of resources can improve the read and write performance of your cluster. For more information, see [Specifications](https://www.alibabacloud.com/help/en/doc-detail/144851.htm).
         */
        storageResource: string;
        /**
         * The tag of the resource.
         */
        tags: {[key: string]: any};
        /**
         * The vpc cloud instance id.
         */
        vpcCloudInstanceId: string;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID  of the resource.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }
}

export namespace apigateway {
    export interface ApiConstantParameter {
        /**
         * The description of Constant parameter.
         */
        description?: string;
        /**
         * System parameter location; values: 'HEAD' and 'QUERY'.
         */
        in: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html)
         */
        name: string;
        /**
         * Constant parameter value.
         */
        value: string;
    }

    export interface ApiFcServiceConfig {
        /**
         * RAM role arn attached to the Function Compute service. This governs both who / what can invoke your Function, as well as what resources our Function has access to. See [User Permissions](https://www.alibabacloud.com/help/doc-detail/52885.htm) for more details.
         */
        arnRole?: string;
        /**
         * The function name of function compute service.
         */
        functionName: string;
        /**
         * The region that the function compute service belongs to.
         */
        region: string;
        /**
         * The service name of function compute service.
         */
        serviceName: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiHttpServiceConfig {
        /**
         * The address of backend service.
         */
        address: string;
        aoneName?: string;
        /**
         * The http method of backend service.
         */
        method: string;
        /**
         * The path of backend service.
         */
        path: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiHttpVpcServiceConfig {
        aoneName?: string;
        /**
         * The http method of backend service.
         */
        method: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html)
         */
        name: string;
        /**
         * The path of backend service.
         */
        path: string;
        /**
         * Backend service time-out time; unit: millisecond.
         */
        timeout: number;
    }

    export interface ApiMockServiceConfig {
        aoneName?: string;
        /**
         * The result of the mock service.
         */
        result: string;
    }

    export interface ApiRequestConfig {
        /**
         * The body format of the api, which support the values of 'STREAM' and 'FORM'
         */
        bodyFormat?: string;
        /**
         * The http method of backend service.
         */
        method: string;
        /**
         * The mode of the parameters between request parameters and service parameters, which support the values of 'MAPPING' and 'PASSTHROUGH'
         */
        mode: string;
        /**
         * The path of backend service.
         */
        path: string;
        /**
         * The protocol of api which supports values of 'HTTP','HTTPS' or 'HTTP,HTTPS'
         */
        protocol: string;
    }

    export interface ApiRequestParameter {
        /**
         * The default value of the parameter.
         */
        defaultValue?: string;
        /**
         * The description of Constant parameter.
         */
        description?: string;
        /**
         * System parameter location; values: 'HEAD' and 'QUERY'.
         */
        in: string;
        /**
         * Backend service's parameter location; values: BODY, HEAD, QUERY, and PATH.
         */
        inService: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html)
         */
        name: string;
        /**
         * Backend service's parameter name.
         */
        nameService: string;
        /**
         * Parameter required or not; values: REQUIRED and OPTIONAL.
         */
        required: string;
        /**
         * Parameter type which supports values of 'STRING','INT','BOOLEAN','LONG',"FLOAT" and "DOUBLE"
         */
        type: string;
    }

    export interface ApiSystemParameter {
        /**
         * System parameter location; values: 'HEAD' and 'QUERY'.
         */
        in: string;
        /**
         * System parameter name which supports values including in [system parameter list](https://www.alibabacloud.com/help/doc-detail/43677.html)
         */
        name: string;
        /**
         * Backend service's parameter name.
         */
        nameService: string;
    }

    export interface GetApisApi {
        /**
         * API description.
         */
        description: string;
        /**
         * ID of the specified group.
         */
        groupId: string;
        /**
         * The group name that the apis belong to.
         */
        groupName: string;
        /**
         * API ID, which is generated by the system and globally unique.
         */
        id: string;
        /**
         * API name.
         */
        name: string;
        /**
         * The ID of the region where the API is located.
         */
        regionId: string;
    }

    export interface GetAppsApp {
        /**
         * App code.
         */
        appCode: string;
        /**
         * Creation time (Greenwich mean time).
         */
        createdTime: string;
        /**
         * App description.
         */
        description: string;
        /**
         * App ID, which is generated by the system and globally unique.
         */
        id: number;
        /**
         * Last modification time (Greenwich mean time).
         */
        modifiedTime: string;
        /**
         * App name.
         */
        name: string;
    }

    export interface GetGroupsGroup {
        /**
         * Billing status.
         * - NORMAL: The API group is normal.
         * - LOCKED: Locked due to outstanding payment.
         */
        billingStatus: string;
        /**
         * Creation time (Greenwich mean time).
         */
        createdTime: string;
        /**
         * API group description.
         */
        description: string;
        /**
         * API group ID, which is generated by the system and globally unique.
         */
        id: string;
        /**
         * Locking in invalid state.
         * - NORMAL: The API group is normal.
         * - LOCKED: Locked due to illegality.
         */
        illegalStatus: string;
        /**
         * Last modification time (Greenwich mean time).
         */
        modifiedTime: string;
        /**
         * API group name.
         */
        name: string;
        /**
         * The ID of the region where the API group is located.
         */
        regionId: string;
        /**
         * Second-level domain name automatically assigned to the API group.
         */
        subDomain: string;
        /**
         * Upper QPS limit of the API group; default value: 500, which can be increased by submitting an application.
         */
        trafficLimit: number;
    }
}

export namespace brain {
    export interface GetIndustrialPidLoopsLoop {
        /**
         * The ID of the Pid Loop.
         */
        id: string;
        pidLoopConfiguration: string;
        /**
         * The dcs type of Pid Loop.
         */
        pidLoopDcsType: string;
        pidLoopDesc: string;
        /**
         * The ID of the Pid Loop.
         */
        pidLoopId: string;
        /**
         * Whether is crucial Pid Loop.
         */
        pidLoopIsCrucial: boolean;
        /**
         * The name of Pid Loop.
         */
        pidLoopName: string;
        /**
         * The type of Pid Loop.
         */
        pidLoopType: string;
        /**
         * The pid project id.
         */
        pidProjectId: string;
        /**
         * The status of Pid Loop.
         */
        status: string;
    }

    export interface GetIndustrialPidOrganizationsOrganization {
        /**
         * The ID of the Pid Organization.
         */
        id: string;
        /**
         * The parent organization id.
         */
        parentPidOrganizationId: string;
        /**
         * The organization id.
         */
        pidOrganizationId: string;
        /**
         * The organization level.
         */
        pidOrganizationLevel: number;
        /**
         * The organization name.
         */
        pidOrganizationName: string;
    }

    export interface GetIndustrialPidProjectsProject {
        /**
         * The ID of the Pid Project.
         */
        id: string;
        /**
         * The ID of Pid Organization.
         */
        pidOrganizationId: string;
        /**
         * The description of Pid Project.
         */
        pidProjectDesc: string;
        /**
         * The ID of Pid Project.
         */
        pidProjectId: string;
        /**
         * The name of Pid Project.
         */
        pidProjectName: string;
    }
}

export namespace cas {
    export interface GetCertificatesCertificate {
        /**
         * The cert is buy from aliyun or not.
         */
        buyInAliyun: boolean;
        /**
         * The cert's city.
         */
        city: string;
        /**
         * The cert's common name.
         */
        common: string;
        /**
         * The cert's country.
         */
        country: string;
        /**
         * The cert's not valid after time.
         */
        endDate: string;
        /**
         * The cert is expired or not.
         */
        expired: boolean;
        /**
         * The cert's finger.
         */
        fingerPrint: string;
        /**
         * The cert's id.
         */
        id: number;
        /**
         * The cert's .
         */
        issuer: string;
        /**
         * The cert's name.
         */
        name: string;
        /**
         * The cert's organization.
         */
        orgName: string;
        /**
         * The cert's province.
         */
        province: string;
        /**
         * The cert's subject alternative name.
         */
        sans: string;
        /**
         * The cert's not valid before time.
         */
        startDate: string;
    }
}

export namespace cassandra {
    export interface GetClustersCluster {
        /**
         * The ID of the Cassandra cluster.
         */
        clusterId: string;
        /**
         * The name of the Cassandra cluster.
         */
        clusterName: string;
        createdTime: string;
        /**
         * The count of data centers
         */
        dataCenterCount: number;
        /**
         * The expire time of the cluster.
         */
        expireTime: string;
        /**
         * The ID of the Cassandra cluster.
         */
        id: string;
        /**
         * The lock mode of the cluster.
         */
        lockMode: string;
        /**
         * The major version of the cluster.
         */
        majorVersion: string;
        /**
         * The minor version of the cluster.
         */
        minorVersion: string;
        /**
         * Billing method. Value options are `Subscription` for Pay-As-You-Go and `PayAsYouGo` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Status of the cluster.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetDataCentersCenter {
        /**
         * The cluster id of dataCenters belongs to.
         */
        clusterId: string;
        /**
         * The commodity ID of the Cassandra dataCenter.
         */
        commodityInstance: string;
        createdTime: string;
        /**
         * The id of the Cassandra dataCenter.
         */
        dataCenterId: string;
        /**
         * The name of the Cassandra dataCenter.
         */
        dataCenterName: string;
        /**
         * One node disk size, unit:GB.
         */
        diskSize: number;
        /**
         * Cloud_ssd or cloud_efficiency.
         */
        diskType: string;
        /**
         * The expire time of the dataCenter.
         */
        expireTime: string;
        /**
         * The instance type of the Cassandra dataCenter, eg: cassandra.c.large.
         */
        instanceType: string;
        /**
         * The lock mode of the dataCenter.
         */
        lockMode: string;
        /**
         * The node count of dataCenter.
         */
        nodeCount: number;
        /**
         * Billing method. Value options are `Subscription` for Pay-As-You-Go and `PayAsYouGo` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Status of the dataCenter.
         */
        status: string;
        /**
         * VPC ID the dataCenter belongs to.
         */
        vpcId: string;
        /**
         * VSwitch ID the dataCenter belongs to.
         */
        vswitchId: string;
        /**
         * Zone ID the dataCenter belongs to.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }
}

export namespace cdn {
    export interface DomainAuthConfig {
        /**
         * Auth type of the auth config. Valid values are  `noAuth`, `typeA`, `typeB` and `typeC`. Default value is `noAuth`.
         */
        authType?: string;
        /**
         * Master authentication key of the auth config. This parameter can have a string of 6 to 32 characters and must contain only alphanumeric characters.
         */
        masterKey: string;
        /**
         * Slave authentication key of the auth config. This parameter can have a string of 6 to 32 characters and must contain only alphanumeric characters.
         */
        slaveKey: string;
        /**
         * Authentication cache time of the auth config. Default value is `1800`. It's value is valid only when the `authType` is `typeB` or `typeC`.
         */
        timeout?: number;
    }

    export interface DomainCacheConfig {
        /**
         * Cache content of the cache config. It's value is a path string when the `cacheType` is `path`. When the `cacheType` is `suffix`, it's value is a string which contains multiple file suffixes separated by commas.
         */
        cacheContent: string;
        cacheId: string;
        /**
         * Cache type of the cache config. Valid values are `suffix` and `path`.
         */
        cacheType: string;
        /**
         * Cache time of the cache config.
         */
        ttl: number;
        /**
         * Weight of the cache config. This parameter's value is between 1 and 99. Default value is `1`. The higher the value, the higher the priority.
         */
        weight?: number;
    }

    export interface DomainCertificateConfig {
        /**
         * The SSL private key. This is required if `serverCertificateStatus` is `on`
         */
        privateKey?: string;
        /**
         * The SSL server certificate string. This is required if `serverCertificateStatus` is `on`
         */
        serverCertificate?: string;
        /**
         * This parameter indicates whether or not enable https. Valid values are `on` and `off`. Default value is `on`.
         */
        serverCertificateStatus?: string;
    }

    export interface DomainConfigFunctionArg {
        /**
         * The name of arg.
         */
        argName: string;
        /**
         * The value of arg.
         */
        argValue: string;
    }

    export interface DomainHttpHeaderConfig {
        headerId: string;
        /**
         * Header key of the http header. Valid values are `Content-Type`, `Cache-Control`, `Content-Disposition`, `Content-Language`ï¼Œ`Expires`, `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods` and `Access-Control-Max-Age`.
         */
        headerKey: string;
        /**
         * Header value of the http header.
         */
        headerValue: string;
    }

    export interface DomainNewCertificateConfig {
        /**
         * The SSL certificate name.
         */
        certName?: string;
        /**
         * The SSL certificate type, can be "upload", "cas" and "free".
         */
        certType?: string;
        /**
         * Set `1` to ignore the repeated verification for certificate name, and cover the information of the origin certificate (with the same name). Set `0` to work the verification.
         */
        forceSet?: string;
        /**
         * The SSL private key. This is required if `serverCertificateStatus` is `on`
         */
        privateKey?: string;
        /**
         * The SSL server certificate string. This is required if `serverCertificateStatus` is `on`
         */
        serverCertificate?: string;
        /**
         * This parameter indicates whether or not enable https. Valid values are `on` and `off`. Default value is `on`.
         */
        serverCertificateStatus?: string;
    }

    export interface DomainNewSource {
        /**
         * The adress of source. Valid values can be ip or doaminName. Each item's `content` can not be repeated.
         */
        content: string;
        /**
         * The port of source. Valid values are `443` and `80`. Default value is `80`.
         */
        port?: number;
        /**
         * Priority of the source. Valid values are `0` and `100`. Default value is `20`.
         */
        priority?: number;
        /**
         * The type of the source. Valid values are `ipaddr`, `domain` and `oss`.
         */
        type: string;
        /**
         * Weight of the source. Valid values are from `0` to `100`. Default value is `10`, but if type is `ipaddr`, the value can only be `10`.
         */
        weight?: number;
    }

    export interface DomainPage404Config {
        /**
         * Custom page url of the error page. It must be the full path under the accelerated domain name. It's value must be `http://promotion.alicdn.com/help/oss/error.html` when `pageType` value is `charity` and It can not be set when `pageType` value is `default`.
         */
        customPageUrl?: string;
        errorCode: string;
        /**
         * Page type of the error page. Valid values are `default`, `charity`, `other`. Default value is `default`.
         */
        pageType?: string;
    }

    export interface DomainParameterFilterConfig {
        /**
         * This parameter indicates whether or not the `parameterFilterConfig` is enable. Valid values are `on` and `off`. Default value is `off`.
         */
        enable?: string;
        /**
         * Reserved parameters of `parameterFilterConfig`. It's a list of string and consists of at most 10 items.
         */
        hashKeyArgs: string[];
    }

    export interface DomainReferConfig {
        /**
         * This parameter indicates whether or not to allow empty refer access. Valid values are `on` and `off`. Default value is `on`.
         */
        allowEmpty?: string;
        /**
         * A list of domain names of the refer config.
         */
        referLists: string[];
        /**
         * Refer type of the refer config. Valid values are `block` and `allow`. Default value is `block`.
         */
        referType?: string;
    }
}

export namespace cen {
    export interface GetBandwidthLimitsLimit {
        /**
         * The bandwidth limit configured for the interconnected regions communication.
         */
        bandwidthLimit: number;
        /**
         * ID of the CEN instance.
         */
        instanceId: string;
        /**
         * ID of local region.
         */
        localRegionId: string;
        /**
         * ID of opposite region.
         */
        oppositeRegionId: string;
        /**
         * Status of the CEN Bandwidth Limit, including "Active" and "Modifying".
         */
        status: string;
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth in Mbps of the CEN bandwidth package.
         */
        bandwidth: number;
        /**
         * The billing method, including `POSTPAY` and `PREPAY`.
         */
        bandwidthPackageChargeType: string;
        /**
         * Status of the CEN Bandwidth Package, including `Normal`, `FinancialLocked` and `SecurityLocked`.
         */
        businessStatus: string;
        /**
         * The ID of the bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The name of the bandwidth package.
         */
        cenBandwidthPackageName: string;
        /**
         * The list of CEN instances that are associated with the bandwidth package.
         */
        cenIds: string[];
        /**
         * Description of the CEN Bandwidth Package.
         */
        description: string;
        expiredTime: string;
        /**
         * Region ID of the interconnected regions.
         */
        geographicRegionAId: string;
        /**
         * Region ID of the interconnected regions.
         */
        geographicRegionBId: string;
        /**
         * The area ID of the cross-area connection.
         */
        geographicSpanId: string;
        /**
         * Indicates whether renewal data is involved.
         */
        hasReservationData: string;
        /**
         * ID of the CEN Bandwidth Package.
         */
        id: string;
        /**
         * ID of a CEN instance.
         */
        instanceId: string;
        /**
         * Indicates whether the bandwidth package is a cross-border bandwidth package.
         */
        isCrossBorder: boolean;
        /**
         * Name of the CEN Bandwidth Package.
         */
        name: string;
        /**
         * The billing method of the bandwidth package.
         */
        paymentType: string;
        /**
         * The expiration time of the temporary upgrade.
         */
        reservationActiveTime: string;
        /**
         * The restored bandwidth after the temporary upgrade.
         */
        reservationBandwidth: string;
        /**
         * The billing method after the configuration change.
         */
        reservationInternetChargeType: string;
        /**
         * The type of the configuration change.
         */
        reservationOrderType: string;
        /**
         * Status of the CEN Bandwidth Package in CEN instance, Valid value: `Idle` and `InUse`.
         */
        status: string;
    }

    export interface GetFlowlogsFlowlog {
        /**
         * The ID of the CEN Instance.
         */
        cenId: string;
        /**
         * The description of flowlog.
         */
        description: string;
        /**
         * ID of the CEN flow log.
         */
        flowLogId: string;
        /**
         * The name of flowlog.
         */
        flowLogName: string;
        /**
         * ID of the CEN flow log.
         */
        id: string;
        /**
         * The name of the log store which is in the  `projectName` SLS project.
         */
        logStoreName: string;
        /**
         * The name of the SLS project.
         */
        projectName: string;
        /**
         * The status of flowlog. Valid values: ["Active", "Inactive"]. Default to "Active".
         */
        status: string;
    }

    export interface GetInstanceAttachmentsAttachment {
        /**
         * The time when the network is associated with the CEN instance.
         */
        childInstanceAttachTime: string;
        /**
         * The ID of the network.
         */
        childInstanceId: string;
        /**
         * The ID of the account to which the network belongs.
         */
        childInstanceOwnerId: number;
        /**
         * The region to which the network to be queried belongs.
         */
        childInstanceRegionId: string;
        /**
         * The type of the associated network. Valid values: `VPC`, `VBR` and `CCN`.
         */
        childInstanceType: string;
        /**
         * The ID of the CEN Instance Attachment.
         */
        id: string;
        /**
         * The ID of the CEN instance.
         */
        instanceId: string;
        /**
         * The status of the Cen Child Instance Attachment. Valid value: `Attaching`, `Attached` and `Aetaching`.
         */
        status: string;
    }

    export interface GetInstancesInstance {
        /**
         * List of CEN Bandwidth Package IDs in the specified CEN instance.
         */
        cenBandwidthPackageIds: string[];
        /**
         * ID of the CEN instance.
         */
        cenId: string;
        /**
         * Name of the CEN instance.
         */
        cenInstanceName: string;
        /**
         * Description of the CEN instance.
         */
        description: string;
        /**
         * ID of the CEN instance.
         */
        id: string;
        /**
         * Name of the CEN instance.
         */
        name: string;
        /**
         * Indicates the allowed level of CIDR block overlapping.
         */
        protectionLevel: string;
        /**
         * The status of CEN instance. Valid value: `Active`, `Creating` and `Deleting`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetPrivateZonesZone {
        /**
         * The access region. The access region is the region of the cloud resource that accesses the PrivateZone service through CEN.
         */
        accessRegionId: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The service region. The service region is the target region of the PrivateZone service accessed through CEN.
         */
        hostRegionId: string;
        /**
         * The VPC that belongs to the service region.
         */
        hostVpcId: string;
        /**
         * The DNS IP addresses of the PrivateZone service.
         */
        privateZoneDnsServers: string;
        /**
         * The status of the PrivateZone service, including `Creating`, `Active` and `Deleting`.
         */
        status: string;
    }

    export interface GetRegionRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry.
         */
        cidrBlock: string;
        /**
         * ID of the next hop.
         */
        nextHopId: string;
        /**
         * ID of the region where the next hop is located.
         */
        nextHopRegionId: string;
        /**
         * Type of the next hop.
         */
        nextHopType: string;
        /**
         * Type of the route entry.
         */
        type: string;
    }

    export interface GetRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry to query.
         */
        cidrBlock: string;
        /**
         * A list of conflicted Route Entries. Each element contains the following attributes:
         */
        conflicts: outputs.cen.GetRouteEntriesEntryConflict[];
        /**
         * ID of the next hop.
         */
        nextHopId: string;
        /**
         * Type of the next hop, including "Instance", "HaVip" and "RouterInterface".
         */
        nextHopType: string;
        /**
         * Whether to allow the route entry to be published or removed to or from CEN.
         */
        operationalMode: boolean;
        /**
         * The publish status of the route entry in CEN, including "Published" and "NonPublished".
         */
        publishStatus: string;
        /**
         * ID of the route table of the VPC or VBR.
         */
        routeTableId: string;
        /**
         * Type of the route entry, including "System", "Custom" and "BGP".
         */
        routeType: string;
    }

    export interface GetRouteEntriesEntryConflict {
        /**
         * The destination CIDR block of the route entry to query.
         */
        cidrBlock: string;
        /**
         * ID of the CEN instance.
         */
        instanceId: string;
        /**
         * The type of the CEN child instance.
         */
        instanceType: string;
        /**
         * ID of the region where the conflicted route entry is located.
         */
        regionId: string;
        /**
         * Reasons of exceptions.
         */
        status: string;
    }

    export interface GetRouteMapsMap {
        /**
         * A match statement. It indicates the mode in which the as-path attribute is matched.
         */
        asPathMatchMode: string;
        /**
         * The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The ID of the region to which the CEN instance belongs.
         */
        cenRegionId: string;
        /**
         * A match statement. It indicates the mode in which the prefix attribute is matched.
         */
        cidrMatchMode: string;
        /**
         * A match statement. It indicates the mode in which the community attribute is matched.
         */
        communityMatchMode: string;
        /**
         * An action statement. It indicates the mode in which the community attribute is operated.
         */
        communityOperateMode: string;
        /**
         * The description of the route map.
         */
        description: string;
        /**
         * A match statement that indicates the list of IDs of the destination instances.
         */
        destinationChildInstanceTypes: string[];
        /**
         * A match statement that indicates the prefix list.
         */
        destinationCidrBlocks: string[];
        /**
         * A match statement that indicates the list of IDs of the destination instances.
         */
        destinationInstanceIds: string[];
        /**
         * Indicates whether to enable the reverse match method of the DestinationInstanceIds match condition.
         */
        destinationInstanceIdsReverseMatch: boolean;
        /**
         * A match statement that indicates the list of IDs of the destination route tables.
         */
        destinationRouteTableIds: string[];
        /**
         * The ID of the route map.
         */
        id: string;
        /**
         * The action that is performed to a route if the route meets all the match conditions.
         */
        mapResult: string;
        /**
         * A match statement that indicates the As path list.
         */
        matchAsns: string[];
        /**
         * A match statement that indicates the community set.
         */
        matchCommunitySets: string[];
        /**
         * The priority of the next route map that is associated with the current route map.
         */
        nextPriority: number;
        /**
         * An action statement that operates the community attribute.
         */
        operateCommunitySets: string[];
        /**
         * An action statement that modifies the preference of the route.
         */
        preference: number;
        /**
         * Indicates AS Path prepending when a regional gateway receives or publishes a route.
         */
        prependAsPaths: string[];
        /**
         * The priority of the route map.
         */
        priority: number;
        /**
         * The ID of the route map.
         */
        routeMapId: string;
        /**
         * A match statement that indicates the list of route types.
         */
        routeTypes: string[];
        /**
         * A match statement that indicates the list of IDs of the source instances.
         */
        sourceChildInstanceTypes: string[];
        /**
         * A match statement that indicates the list of IDs of the source instances.
         */
        sourceInstanceIds: string[];
        /**
         * Indicates whether to enable the reverse match method of the SourceInstanceIds match condition.
         */
        sourceInstanceIdsReverseMatch: boolean;
        /**
         * A match statement that indicates the list of IDs of the source regions.
         */
        sourceRegionIds: string[];
        /**
         * A match statement that indicates the list of IDs of the source route tables.
         */
        sourceRouteTableIds: string[];
        /**
         * The status of the route map, including `Creating`, `Active` and `Deleting`.
         */
        status: string;
        /**
         * The direction in which the route map is applied, including `RegionIn` and `RegionOut`.
         */
        transmitDirection: string;
    }

    export interface GetRouteServicesService {
        /**
         * The region of the network instances that access the cloud services.
         */
        accessRegionId: string;
        /**
         * -(Required, ForceNew) The ID of the CEN instance.
         */
        cenId: string;
        /**
         * The IP address of the cloud service.
         */
        cidrs: string[];
        /**
         * The description of the cloud service.
         */
        description: string;
        /**
         * -(Optional, ForceNew) The domain name or IP address of the cloud service.
         */
        host: string;
        /**
         * The region of the cloud service.
         */
        hostRegionId: string;
        /**
         * The VPC associated with the cloud service.
         */
        hostVpcId: string;
        /**
         * The ID of the route service.
         */
        id: string;
        /**
         * The status of the cloud service. Valid values: `Active`, `Creating` and `Deleting`.
         */
        status: string;
        /**
         * The update interval. Default value: 5. The value cannot be modified.
         */
        updateInterval: string;
    }

    export interface GetVbrHealthChecksCheck {
        /**
         * The ID of the Cloud Enterprise Network (CEN) instance.
         */
        cenId: string;
        /**
         * The time interval at which probe packets are sent during the health check.
         */
        healthCheckInterval: number;
        /**
         * The source IP address of the health check.
         */
        healthCheckSourceIp: string;
        /**
         * The destination IP address of the health check.
         */
        healthCheckTargetIp: string;
        /**
         * The number of probe packets that are sent during the health check.
         */
        healthyThreshold: number;
        /**
         * The ID of the CEN VBR Heath Check.
         */
        id: string;
        /**
         * The ID of the VBR instance.
         */
        vbrInstanceId: string;
        /**
         * The ID of the region where the VBR instance is deployed.
         */
        vbrInstanceRegionId: string;
    }
}

export namespace cfg {
    export interface AggregateCompliancePackConfigRule {
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.AggregateCompliancePackConfigRuleConfigRuleParameter[];
        /**
         * The Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface AggregateCompliancePackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
    }

    export interface AggregatorAggregatorAccount {
        /**
         * Aggregator account Uid.
         */
        accountId: string;
        /**
         * Aggregator account name.
         */
        accountName: string;
        /**
         * Aggregator account source type. Valid values: `ResourceDirectory`.
         */
        accountType: string;
    }

    export interface CompliancePackConfigRule {
        /**
         * A list of Config Rule Parameters.
         */
        configRuleParameters: outputs.cfg.CompliancePackConfigRuleConfigRuleParameter[];
        /**
         * The Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface CompliancePackConfigRuleConfigRuleParameter {
        /**
         * The parameter name.
         */
        parameterName: string;
        /**
         * The parameter value.
         */
        parameterValue?: string;
    }

    export interface GetAggregateCompliancePacksPack {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * -The Aggregate Compliance Package Name.
         */
        aggregateCompliancePackName: string;
        /**
         * The first ID of the resource.
         */
        aggregatorCompliancePackId: string;
        /**
         * The template ID of the Compliance Package.
         */
        compliancePackTemplateId: string;
        /**
         * A list of The Aggregate Compliance Package Rules.
         */
        configRules: outputs.cfg.GetAggregateCompliancePacksPackConfigRule[];
        /**
         * The description of aggregate compliance pack.
         */
        description: string;
        /**
         * The ID of the Aggregate Compliance Pack.
         */
        id: string;
        /**
         * The Risk Level.
         */
        riskLevel: number;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAggregateCompliancePacksPackConfigRule {
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.GetAggregateCompliancePacksPackConfigRuleConfigRuleParameter[];
        /**
         * Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface GetAggregateCompliancePacksPackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
        /**
         * Required.
         */
        required: boolean;
    }

    export interface GetAggregateConfigRulesRule {
        /**
         * The Aliyun User ID.
         */
        accountId: string;
        /**
         * The name of the rule.
         */
        aggregateConfigRuleName: string;
        /**
         * The ID of Compliance Package.
         */
        compliancePackId: string;
        /**
         * -The Compliance information.
         */
        compliances: outputs.cfg.GetAggregateConfigRulesRuleCompliance[];
        /**
         * The config rule arn.
         */
        configRuleArn: string;
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * The trigger types of config rules.
         */
        configRuleTriggerTypes: string;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Event source of the Config Rule.
         */
        eventSource: string;
        /**
         * The types of the resources to be evaluated against the rule.
         */
        excludeResourceIdsScope: string;
        /**
         * The ID of the Aggregate Config Rule.
         */
        id: string;
        /**
         * The settings of the input parameters for the rule.
         */
        inputParameters: {[key: string]: any};
        /**
         * The frequency of the compliance evaluations.
         */
        maximumExecutionFrequency: string;
        /**
         * The timestamp when the rule was last modified.
         */
        modifiedTimestamp: string;
        /**
         * The Exclude ResourceId List.
         */
        regionIdsScope: string;
        /**
         * The scope of resource group ids.
         */
        resourceGroupIdsScope: string;
        resourceTypesScopes: string[];
        /**
         * The risk level of the resources that are not compliant with the rule. Valid values: `1`: critical, `2`: warning, `3`: info.
         */
        riskLevel: number;
        /**
         * The name of the custom rule or managed rule.
         */
        sourceIdentifier: string;
        /**
         * The source owner of the Config Rule.
         */
        sourceOwner: string;
        /**
         * The status of the rule.
         */
        status: string;
        /**
         * The scope of tay key.
         */
        tagKeyScope: string;
        /**
         * The scope of tay value.
         */
        tagValueScope: string;
    }

    export interface GetAggregateConfigRulesRuleCompliance {
        /**
         * The Compliance Type.
         */
        complianceType: string;
        /**
         * The Count.
         */
        count: number;
    }

    export interface GetAggregatorsAggregator {
        /**
         * Aggregator account uid.
         */
        accountId: string;
        /**
         * Account information in aggregator.
         */
        aggregatorAccounts: outputs.cfg.GetAggregatorsAggregatorAggregatorAccount[];
        /**
         * The id of aggregator.
         */
        aggregatorId: string;
        /**
         * The name of aggregator.
         */
        aggregatorName: string;
        /**
         * The type of aggregator.
         */
        aggregatorType: string;
        /**
         * The description of aggregator.
         */
        description: string;
        /**
         * The id of the aggregator.
         */
        id: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAggregatorsAggregatorAggregatorAccount {
        /**
         * Aggregator account uid.
         */
        accountId: string;
        /**
         * Aggregator account name.
         */
        accountName: string;
        /**
         * Aggregator account source type.
         */
        accountType: string;
    }

    export interface GetCompliancePacksPack {
        /**
         * The Aliyun User Id.
         */
        accountId: string;
        /**
         * The Compliance Package ID.
         */
        compliancePackId: string;
        /**
         * The Compliance Package Name.
         */
        compliancePackName: string;
        /**
         * The template ID of the Compliance Package.
         */
        compliancePackTemplateId: string;
        /**
         * A list of The Compliance Package Rules.
         */
        configRules: outputs.cfg.GetCompliancePacksPackConfigRule[];
        /**
         * The description of compliance pack.
         */
        description: string;
        /**
         * The ID of the Compliance Pack.
         */
        id: string;
        /**
         * The Ris Level.
         */
        riskLevel: number;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetCompliancePacksPackConfigRule {
        /**
         * The ID of the rule.
         */
        configRuleId: string;
        /**
         * A list of parameter rules.
         */
        configRuleParameters: outputs.cfg.GetCompliancePacksPackConfigRuleConfigRuleParameter[];
        /**
         * Managed Rule Identifier.
         */
        managedRuleIdentifier: string;
    }

    export interface GetCompliancePacksPackConfigRuleConfigRuleParameter {
        /**
         * The Parameter Name.
         */
        parameterName: string;
        /**
         * The Parameter Value.
         */
        parameterValue: string;
        /**
         * Required.
         */
        required: boolean;
    }

    export interface GetConfigurationRecordersRecorder {
        accountId: string;
        /**
         * The ID of the Config Configuration Recorder. Value as the `accountId`.
         * * `accountId`- The ID of the Alicloud account.
         */
        id: string;
        /**
         * Status of resource monitoring.
         */
        organizationEnableStatus: string;
        /**
         * The ID of the Enterprise management account.
         */
        organizationMasterId: number;
        /**
         * A list of resource types to be monitored.
         */
        resourceTypes: string[];
        /**
         * Enterprise version configuration audit enabled status.
         */
        status: string;
    }

    export interface GetDeliveryChannelsChannel {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the role assumed by delivery method.
         */
        deliveryChannelAssumeRoleArn: string;
        /**
         * The rule attached to the delivery method. This parameter is applicable only to delivery methods of the Message Service (MNS) type.
         */
        deliveryChannelCondition: string;
        /**
         * The ID of the delivery channel.
         */
        deliveryChannelId: string;
        /**
         * The name of the delivery channel.
         */
        deliveryChannelName: string;
        /**
         * The ARN of the delivery destination.
         */
        deliveryChannelTargetArn: string;
        /**
         * The type of the delivery method.
         */
        deliveryChannelType: string;
        /**
         * The description of the delivery method.
         */
        description: string;
        /**
         * The ID of the Config Delivery Channel.
         */
        id: string;
        /**
         * The status of the config delivery channel. Valid values `0`: Disable delivery channel, `1`: Enable delivery channel.
         */
        status: number;
    }

    export interface GetRulesRule {
        accountId: string;
        compliancePackId: string;
        /**
         * The information about the compliance evaluations based on the rule.
         */
        compliances: outputs.cfg.GetRulesRuleCompliance[];
        configRuleArn: string;
        configRuleId: string;
        /**
         * Field `configRuleState` has been deprecated from provider version 1.124.1. New field `status` instead.
         */
        configRuleState: string;
        /**
         * (Available in 1.124.1+) A list of trigger types of config rule.
         */
        configRuleTriggerTypes: string;
        description: string;
        /**
         * Event source of the Config Rule.
         */
        eventSource: string;
        /**
         * (Available in 1.124.1+) The scope of exclude of resource ids.
         */
        excludeResourceIdsScope: string;
        /**
         * The ID of the Config Rule.
         * * `accountId`- The ID of the Alicloud account.
         * * `configRuleArn`- The ARN of the Config Rule.
         * * `configRuleId`- The ID of the Config Rule.
         * * `configRuleState`- The state of the Config Rule.
         * * `description`- The description of the Config Rule.
         * * `inputParameters`- The input parameters of the Config Rule.
         * * `modifiedTimestamp`- the timestamp of the Config Rule modified.
         * * `riskLevel`- The risk level of the Config Rule.
         * * `ruleName`- The name of the Config Rule.
         */
        id: string;
        inputParameters: {[key: string]: any};
        /**
         * (Available in 1.124.1+) The frequency of maximum execution.
         */
        maximumExecutionFrequency: string;
        modifiedTimestamp: string;
        /**
         * (Available in 1.124.1+) The scope of region ids.
         */
        regionIdsScope: string;
        /**
         * (Available in 1.124.1+) The scope of resource ids.
         */
        resourceGroupIdsScope: string;
        /**
         * (Available in 1.124.1+) The scope of resource types.
         */
        resourceTypesScopes: string[];
        /**
         * The risk level of Config Rule. Valid values: `1`: Critical ,`2`: Warning , `3`: Info.
         */
        riskLevel: number;
        /**
         * The name of config rule.
         */
        ruleName: string;
        /**
         * The types of the resources to be evaluated against the rule.
         */
        scopeComplianceResourceTypes: string[];
        /**
         * Rule trigger mechanism.
         */
        sourceDetailMessageType: string;
        sourceIdentifier: string;
        /**
         * Rule execution cycle. 
         * * `sourceIdentifier`- The name of the custom rule or managed rule.
         * * `sourceOwner`- The source owner of the Config Rule.
         */
        sourceMaximumExecutionFrequency: string;
        sourceOwner: string;
        /**
         * The status of the config rule, valid values: `ACTIVE`, `DELETING`, `EVALUATING` and `INACTIVE`.
         */
        status: string;
        /**
         * (Available in 1.124.1+) The scope of tag key.
         */
        tagKeyScope: string;
        /**
         * (Available in 1.124.1+) The scope of tag value.
         */
        tagValueScope: string;
    }

    export interface GetRulesRuleCompliance {
        /**
         * The compliance evaluation result of the target resources.
         */
        complianceType: string;
        /**
         * The number of resources with the specified compliance evaluation result.
         */
        count: number;
    }
}

export namespace cloudconnect {
    export interface GetNetworksNetwork {
        /**
         * CidrBlock of the CCN instance.
         */
        cidrBlock: string;
        description: string;
        /**
         * ID of the CCN instance.
         */
        id: string;
        /**
         * IsDefault of the CCN instance.
         */
        isDefault: boolean;
        /**
         * Name of the CCN instance.
         */
        name: string;
    }
}

export namespace cloudstoragegateway {
    export interface GetStorageBundlesBundle {
        description: string;
        id: string;
        location: string;
        storageBundleId: string;
        storageBundleName: string;
    }
}

export namespace cms {
    export interface AlarmEscalationsCritical {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * Critical level alarm statistics method.. It must be consistent with that defined for metrics. Valid values: ["Average", "Minimum", "Maximum"]. Default to "Average".
         */
        statistics?: string;
        /**
         * Critical level alarm threshold value, which must be a numeric value currently.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmEscalationsInfo {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * Critical level alarm statistics method.. It must be consistent with that defined for metrics. Valid values: ["Average", "Minimum", "Maximum"]. Default to "Average".
         */
        statistics?: string;
        /**
         * Critical level alarm threshold value, which must be a numeric value currently.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface AlarmEscalationsWarn {
        /**
         * Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
         */
        comparisonOperator?: string;
        /**
         * Critical level alarm statistics method.. It must be consistent with that defined for metrics. Valid values: ["Average", "Minimum", "Maximum"]. Default to "Average".
         */
        statistics?: string;
        /**
         * Critical level alarm threshold value, which must be a numeric value currently.
         */
        threshold?: string;
        /**
         * Critical level alarm retry times. Default to 3.
         */
        times?: number;
    }

    export interface GetAlarmContactGroupsGroup {
        /**
         * The name of Alarm Contact Group.
         */
        alarmContactGroupName: string;
        /**
         * The alarm contacts in the alarm group.
         */
        contacts: string[];
        /**
         * The description of the Alarm Group.
         */
        describe: string;
        /**
         * Indicates whether the alarm group subscribes to weekly reports.
         */
        enableSubscribed: boolean;
        /**
         * The ID of the CMS.
         */
        id: string;
    }

    export interface GetAlarmContactsContact {
        /**
         * The name of the alarm contact.
         */
        alarmContactName: string;
        /**
         * The TradeManager ID of the alarm contact.
         */
        channelsAliim: string;
        /**
         * The webhook URL of the DingTalk chatbot.
         */
        channelsDingWebHook: string;
        /**
         * The email address of the alarm contact.
         */
        channelsMail: string;
        /**
         * The phone number of the alarm contact.
         */
        channelsSms: string;
        /**
         * Indicates whether the TradeManager ID is valid.
         */
        channelsStateAliim: string;
        /**
         * Indicates whether the DingTalk chatbot is normal.
         */
        channelsStateDingWebHook: string;
        /**
         * The status of the email address.
         */
        channelsStateMail: string;
        /**
         * The status of the phone number.
         */
        channelsStatusSms: string;
        /**
         * The alert groups to which the alarm contact is added.
         */
        contactGroups: string[];
        /**
         * The description of the alarm contact.
         */
        describe: string;
        /**
         * The ID of the alarm contact.
         */
        id: string;
        lang: string;
    }

    export interface GetGroupMetricRulesRule {
        /**
         * Alarm contact group.
         */
        contactGroups: string;
        /**
         * The dimensions that specify the resources to be associated with the alert rule.
         */
        dimensions: string;
        /**
         * The time period during which the alert rule is effective.
         */
        effectiveInterval: string;
        /**
         * The subject of the alert notification email.
         */
        emailSubject: string;
        /**
         * Indicates whether the alert rule is enabled.
         */
        enableState: boolean;
        /**
         * Alarm level.
         */
        escalations: outputs.cms.GetGroupMetricRulesRuleEscalation[];
        /**
         * The ID of the application group.
         */
        groupId: string;
        /**
         * The name of the alert rule.
         */
        groupMetricRuleName: string;
        /**
         * The ID of the Group Metric Rule.
         */
        id: string;
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the service.
         */
        namespace: string;
        /**
         * The time period during which the alert rule is ineffective.
         */
        noEffectiveInterval: string;
        /**
         * The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
         */
        period: number;
        /**
         * The resources that are associated with the alert rule.
         */
        resources: string;
        /**
         * The ID of the alert rule.
         */
        ruleId: string;
        /**
         * The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
         */
        silenceTime: number;
        /**
         * The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
         */
        sourceType: string;
        /**
         * The status of Group Metric Rule..
         */
        status: string;
        /**
         * The callback URL.
         */
        webhook: string;
    }

    export interface GetGroupMetricRulesRuleEscalation {
        /**
         * The critical level.
         */
        criticals: outputs.cms.GetGroupMetricRulesRuleEscalationCritical[];
        /**
         * The info level.
         */
        infos: outputs.cms.GetGroupMetricRulesRuleEscalationInfo[];
        /**
         * The warn level.
         */
        warns: outputs.cms.GetGroupMetricRulesRuleEscalationWarn[];
    }

    export interface GetGroupMetricRulesRuleEscalationCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetGroupMetricRulesRuleEscalationInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetGroupMetricRulesRuleEscalationWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times: number;
    }

    export interface GetMonitorGroupInstancesInstance {
        instances: outputs.cms.GetMonitorGroupInstancesInstanceInstance[];
    }

    export interface GetMonitorGroupInstancesInstanceInstance {
        category: string;
        instanceId: string;
        instanceName: string;
        regionId: string;
    }

    export interface GetMonitorGroupsGroup {
        /**
         * The URL of the Kubernetes cluster from which the application group is synchronized.
         */
        bindUrl: string;
        /**
         * The list of  alert groups that receive alert notifications for the application group.
         */
        contactGroups: string[];
        /**
         * The ID of the tag rule.
         */
        dynamicTagRuleId: string;
        /**
         * The time when the application group was created.
         */
        gmtCreate: number;
        /**
         * The time when the application group was modified.
         */
        gmtModified: number;
        /**
         * The ID of the application group.
         */
        groupId: string;
        /**
         * The ID of the Monitor Group.
         */
        id: string;
        /**
         * The name of the application group.
         */
        monitorGroupName: string;
        /**
         * The ID of the Alibaba Cloud service.
         */
        serviceId: string;
        /**
         * A map of tags assigned to the Cms Monitor Group.
         */
        tags: {[key: string]: any};
        /**
         * The alert templates applied to the application group.
         */
        templateIds: string[];
        /**
         * The type of the application group.
         */
        type: string;
    }

    export interface GroupMetricRuleEscalations {
        /**
         * The critical level.
         */
        critical?: outputs.cms.GroupMetricRuleEscalationsCritical;
        /**
         * The info level.
         */
        info?: outputs.cms.GroupMetricRuleEscalationsInfo;
        /**
         * The warn level.
         */
        warn?: outputs.cms.GroupMetricRuleEscalationsWarn;
    }

    export interface GroupMetricRuleEscalationsCritical {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleEscalationsInfo {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: number;
    }

    export interface GroupMetricRuleEscalationsWarn {
        /**
         * The comparison operator of the threshold for warn-level alerts.
         */
        comparisonOperator?: string;
        /**
         * The statistical aggregation method for warn-level alerts.
         */
        statistics?: string;
        /**
         * The threshold for warn-level alerts.
         */
        threshold?: string;
        /**
         * The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
         */
        times?: number;
    }

    export interface MonitorGroupInstancesInstance {
        /**
         * The category of instance.
         */
        category: string;
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The region id of instance.
         */
        regionId: string;
    }

    export interface SiteMonitorIspCity {
        city: string;
        isp: string;
    }
}

export namespace config {
    export interface AssumeRole {
        policy?: string;
        roleArn: string;
        sessionExpiration?: number;
        sessionName?: string;
    }

    export interface Endpoints {
        actiontrail?: string;
        adb?: string;
        alidns?: string;
        alikafka?: string;
        apigateway?: string;
        brainIndustrial?: string;
        bssopenapi?: string;
        cas?: string;
        cassandra?: string;
        cbn?: string;
        cdn?: string;
        cen?: string;
        cms?: string;
        config?: string;
        cr?: string;
        cs?: string;
        datahub?: string;
        dcdn?: string;
        ddosbgp?: string;
        ddoscoo?: string;
        dds?: string;
        dmsEnterprise?: string;
        dns?: string;
        drds?: string;
        eci?: string;
        ecs?: string;
        eipanycast?: string;
        elasticsearch?: string;
        emr?: string;
        ess?: string;
        fc?: string;
        fnf?: string;
        ga?: string;
        gpdb?: string;
        hitsdb?: string;
        ims?: string;
        kms?: string;
        kvstore?: string;
        location?: string;
        log?: string;
        market?: string;
        maxcompute?: string;
        mns?: string;
        mse?: string;
        nas?: string;
        ons?: string;
        oos?: string;
        oss?: string;
        ots?: string;
        polardb?: string;
        privatelink?: string;
        pvtz?: string;
        quotas?: string;
        rKvstore?: string;
        ram?: string;
        rds?: string;
        resourcemanager?: string;
        resourcesharing?: string;
        ros?: string;
        sgw?: string;
        slb?: string;
        sts?: string;
        vpc?: string;
        wafOpenapi?: string;
    }
}

export namespace cr {
    export interface GetNamespacesNamespace {
        /**
         * Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
         */
        autoCreate: boolean;
        /**
         * `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
         */
        defaultVisibility: string;
        /**
         * Name of Container Registry namespace.
         */
        name: string;
    }

    export interface GetReposRepo {
        /**
         * The repository domain list.
         */
        domainList: outputs.cr.GetReposRepoDomainList;
        /**
         * Name of container registry namespace.
         */
        name: string;
        /**
         * Name of container registry namespace where the repositories are located in.
         */
        namespace: string;
        /**
         * `PUBLIC` or `PRIVATE`, repository's visibility.
         */
        repoType: string;
        /**
         * The repository general information.
         */
        summary: string;
        /**
         * A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
         */
        tags: outputs.cr.GetReposRepoTag[];
    }

    export interface GetReposRepoDomainList {
        /**
         * Domain of internal endpoint, only in some regions.
         */
        internal: string;
        /**
         * Domain of public endpoint.
         */
        public: string;
        /**
         * Domain of vpc endpoint.
         */
        vpc: string;
    }

    export interface GetReposRepoTag {
        /**
         * Digest of this image.
         */
        digest: string;
        /**
         * Create time of this image, unix time in nanoseconds.
         */
        imageCreate: number;
        /**
         * Id of this image.
         */
        imageId: string;
        /**
         * Status of this image, in bytes.
         */
        imageSize: number;
        /**
         * Last update time of this image, unix time in nanoseconds.
         */
        imageUpdate: number;
        /**
         * Status of this image.
         */
        status: string;
        /**
         * Tag of this image.
         */
        tag: string;
    }

    export interface RepoDomainList {
        /**
         * Domain of internal endpoint, only in some regions.
         */
        internal: string;
        /**
         * Domain of public endpoint.
         */
        public: string;
        /**
         * Domain of vpc endpoint.
         */
        vpc: string;
    }
}

export namespace cs {
    export interface ApplicationService {
        id: string;
        name: string;
        status: string;
        version: string;
    }

    export interface ClusterNode {
        eip: string;
        id: string;
        name: string;
        privateIp: string;
        status: string;
    }

    export interface EdgeKubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface EdgeKubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface EdgeKubernetesConnections {
        apiServerInternet: string;
        apiServerIntranet: string;
        masterPublicIp: string;
        serviceDomain: string;
    }

    export interface EdgeKubernetesLogConfig {
        project?: string;
        type: string;
    }

    export interface EdgeKubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface EdgeKubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetEdgeKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetEdgeKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetEdgeKubernetesClustersClusterWorkerNode[];
    }

    export interface GetEdgeKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
    }

    export interface GetEdgeKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        clusterNetworkType: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The ID of node image.
         */
        imageId: string;
        /**
         * The keypair of ssh login cluster node, you have to create it first.
         */
        keyName: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfigs: outputs.cs.GetKubernetesClustersClusterLogConfig[];
        masterAutoRenew: boolean;
        masterAutoRenewPeriod: number;
        /**
         * The system disk category of master node.
         */
        masterDiskCategory: string;
        /**
         * The system disk size of master node.
         */
        masterDiskSize: number;
        masterInstanceChargeType: string;
        /**
         * The instance type of master node.
         */
        masterInstanceTypes: string[];
        /**
         * List of cluster master nodes. It contains several attributes to `Block Nodes`.
         */
        masterNodes: outputs.cs.GetKubernetesClustersClusterMasterNode[];
        masterPeriod: number;
        masterPeriodUnit: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The network mask used on pods for each node.
         */
        nodeCidrMask: number;
        podCidr: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        serviceCidr: string;
        /**
         * Whether internet load balancer for API Server is created
         */
        slbInternetEnabled: boolean;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitches where the current cluster is located.
         */
        vswitchIds: string[];
        workerAutoRenew: boolean;
        workerAutoRenewPeriod: number;
        /**
         * The data disk size of worker node.
         */
        workerDataDiskCategory: string;
        /**
         * The data disk category of worker node.
         */
        workerDataDiskSize: number;
        /**
         * The system disk category of worker node.
         */
        workerDiskCategory: string;
        /**
         * The system disk size of worker node.
         */
        workerDiskSize: number;
        workerInstanceChargeType: string;
        /**
         * The instance type of worker node.
         */
        workerInstanceTypes: string[];
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetKubernetesClustersClusterWorkerNode[];
        /**
         * The ECS instance node number in the current container cluster.
         */
        workerNumbers: number[];
        workerPeriod: number;
        workerPeriodUnit: string;
    }

    export interface GetKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface GetKubernetesClustersClusterLogConfig {
        /**
         * Log Service project name.
         */
        project: string;
        /**
         * Type of collecting logs.
         */
        type: string;
    }

    export interface GetKubernetesClustersClusterMasterNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetKubernetesPermissionPermission {
        /**
         * ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
         * * `isRamRole` -Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
         */
        isOwner?: boolean;
        isRamRole?: boolean;
        /**
         * The permission settings to manage ACK clusters.
         */
        resourceId: string;
        /**
         * The authorization type. Valid values `cluster`, `namespace` and `console`.
         */
        resourceType: string;
        /**
         * The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
         */
        roleName: string;
        /**
         * The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
         */
        roleType?: string;
    }

    export interface GetManagedKubernetesClustersCluster {
        /**
         * The ID of availability zone.
         */
        availabilityZone: string;
        clusterNetworkType: string;
        /**
         * Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetManagedKubernetesClustersClusterConnections;
        /**
         * ID of the node.
         */
        id: string;
        imageId: string;
        /**
         * The keypair of ssh login cluster node, you have to create it first.
         */
        keyName: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfigs: outputs.cs.GetManagedKubernetesClustersClusterLogConfig[];
        /**
         * Node name.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        podCidr: string;
        /**
         * The ID of security group where the current cluster worker node is located.
         */
        securityGroupId: string;
        serviceCidr: string;
        slbInternetEnabled: boolean;
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitches where the current cluster is located.
         */
        vswitchIds: string[];
        workerAutoRenew: boolean;
        workerAutoRenewPeriod: number;
        workerDataDiskCategory: string;
        workerDataDiskSize: number;
        workerDiskCategory: string;
        workerDiskSize: number;
        workerInstanceChargeType: string;
        workerInstanceTypes: string[];
        /**
         * List of cluster worker nodes. It contains several attributes to `Block Nodes`.
         */
        workerNodes: outputs.cs.GetManagedKubernetesClustersClusterWorkerNode[];
        /**
         * The ECS instance node number in the current container cluster.
         */
        workerNumbers: number[];
        workerPeriod: number;
        workerPeriodUnit: string;
    }

    export interface GetManagedKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface GetManagedKubernetesClustersClusterLogConfig {
        /**
         * Log Service project name.
         */
        project: string;
        /**
         * Type of collecting logs.
         */
        type: string;
    }

    export interface GetManagedKubernetesClustersClusterWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * Node name.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface GetRegistryEnterpriseInstancesInstance {
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        id: string;
        /**
         * Name of Container Registry Enterprise Edition instance.
         */
        name: string;
        /**
         * The max number of namespaces that an instance can create.
         */
        namespaceQuota: string;
        /**
         * The number of namespaces already created.
         */
        namespaceUsage: string;
        /**
         * A list of domains for access on internet network.
         */
        publicEndpoints: string[];
        /**
         * Region of Container Registry Enterprise Edition instance.
         */
        region: string;
        /**
         * The max number of repos that an instance can create.
         */
        repoQuota: string;
        /**
         * The number of repos already created.
         */
        repoUsage: string;
        /**
         * Specification of Container Registry Enterprise Edition instance.
         */
        specification: string;
        /**
         * A list of domains for access on vpc network.
         */
        vpcEndpoints: string[];
    }

    export interface GetRegistryEnterpriseNamespacesNamespace {
        /**
         * Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
         */
        autoCreate: boolean;
        /**
         * `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
         */
        defaultVisibility: string;
        /**
         * ID of Container Registry Enterprise Edition namespace.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition namespace.
         */
        name: string;
    }

    export interface GetRegistryEnterpriseReposRepo {
        /**
         * ID of Container Registry Enterprise Edition repository.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition repository.
         */
        name: string;
        /**
         * Name of Container Registry Enterprise Edition namespace where the repositories are located in.
         */
        namespace: string;
        /**
         * `PUBLIC` or `PRIVATE`, repository's visibility.
         */
        repoType: string;
        /**
         * The repository general information.
         */
        summary: string;
        /**
         * A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
         */
        tags: outputs.cs.GetRegistryEnterpriseReposRepoTag[];
    }

    export interface GetRegistryEnterpriseReposRepoTag {
        /**
         * Digest of this image.
         */
        digest: string;
        /**
         * Create time of this image, unix time in nanoseconds.
         */
        imageCreate: string;
        /**
         * Id of this image.
         */
        imageId: string;
        /**
         * Status of this image, in bytes.
         */
        imageSize: number;
        /**
         * Last update time of this image, unix time in nanoseconds.
         */
        imageUpdate: string;
        /**
         * Status of this image.
         */
        status: string;
        /**
         * Tag of this image.
         */
        tag: string;
    }

    export interface GetRegistryEnterpriseSyncRulesRule {
        /**
         * ID of Container Registry Enterprise Edition sync rule.
         */
        id: string;
        /**
         * ID of Container Registry Enterprise Edition local instance.
         */
        instanceId: string;
        /**
         * Name of Container Registry Enterprise Edition sync rule.
         */
        name: string;
        /**
         * Name of Container Registry Enterprise Edition local namespace.
         */
        namespaceName: string;
        /**
         * Region of Container Registry Enterprise Edition local instance.
         */
        regionId: string;
        /**
         * Name of Container Registry Enterprise Edition local repo.
         */
        repoName: string;
        /**
         * `FROM` or `TO`, the direction of synchronization. `FROM` indicates that the local instance is the source instance. `TO` indicates that the local instance is the target instance to be synchronized.
         */
        syncDirection: string;
        /**
         * `REPO` or `NAMESPACE`,the scope that the synchronization rule applies.
         */
        syncScope: string;
        /**
         * `PASSIVE` or `INITIATIVE`, the policy configured to trigger the synchronization rule.
         */
        syncTrigger: string;
        /**
         * The regular expression used to filter image tags for synchronization in the source repository.
         */
        tagFilter: string;
        /**
         * ID of Container Registry Enterprise Edition target instance.
         */
        targetInstanceId: string;
        /**
         * Name of Container Registry Enterprise Edition target namespace.
         */
        targetNamespaceName: string;
        /**
         * Region of Container Registry Enterprise Edition target instance.
         */
        targetRegionId: string;
        /**
         * Name of Container Registry Enterprise Edition target repo.
         */
        targetRepoName: string;
    }

    export interface GetServerlessKubernetesClustersCluster {
        /**
         * Map of serverless cluster connection information. It contains several attributes to `Block Connections`.
         */
        connections: outputs.cs.GetServerlessKubernetesClustersClusterConnections;
        /**
         * Whether the cluster support delete protection.
         */
        deletionProtection: boolean;
        endpointPublicAccessEnabled: boolean;
        /**
         * The ID of the container cluster.
         */
        id: string;
        /**
         * The name of the container cluster.
         */
        name: string;
        /**
         * The ID of nat gateway used to launch kubernetes cluster.
         */
        natGatewayId: string;
        /**
         * The ID of security group where the current cluster  is located.
         */
        securityGroupId: string;
        tags: {[key: string]: any};
        /**
         * The ID of VPC where the current cluster is located.
         */
        vpcId: string;
        /**
         * The ID of VSwitch where the current cluster is located.
         */
        vswitchId: string;
    }

    export interface GetServerlessKubernetesClustersClusterConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
    }

    export interface KubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface KubernetesAutoscalerNodepool {
        id?: string;
        labels?: string;
        taints?: string;
    }

    export interface KubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface KubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface KubernetesMasterNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface KubernetesPermissionPermission {
        /**
         * The ID of the cluster that you want to manage.
         */
        cluster: string;
        /**
         * Specifies whether to perform a custom authorization. To perform a custom authorization, set `roleName` to a custom cluster role.
         */
        isCustom?: boolean;
        /**
         * Specifies whether the permissions are granted to a RAM role.
         */
        isRamRole?: boolean;
        /**
         * The namespace to which the permissions are scoped. This parameter is required only if you set roleType to namespace.
         */
        namespace?: string;
        /**
         * Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
         */
        roleName: string;
        /**
         * The authorization type. Valid values `cluster`, `namespace`.
         */
        roleType: string;
    }

    export interface KubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface KubernetesTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface KubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface KubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface ManagedKubernetesAddon {
        config?: string;
        disabled?: boolean;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
    }

    export interface ManagedKubernetesCertificateAuthority {
        /**
         * The path of client certificate, like `~/.kube/client-cert.pem`.
         */
        clientCert: string;
        /**
         * The path of client key, like `~/.kube/client-key.pem`.
         */
        clientKey: string;
        /**
         * The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
         */
        clusterCert: string;
    }

    export interface ManagedKubernetesConnections {
        /**
         * API Server Internet endpoint.
         */
        apiServerInternet: string;
        /**
         * API Server Intranet endpoint.
         */
        apiServerIntranet: string;
        /**
         * Master node SSH IP address.
         */
        masterPublicIp: string;
        /**
         * Service Access Domain.
         */
        serviceDomain: string;
    }

    export interface ManagedKubernetesMaintenanceWindow {
        /**
         * The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
         */
        duration: string;
        /**
         * Whether to open the maintenance window. The following parameters take effect only `enable = true`.
         */
        enable: boolean;
        /**
         * Initial maintenance time, For example:"03:00:00Z".
         */
        maintenanceTime: string;
        /**
         * Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
         */
        weeklyPeriod: string;
    }

    export interface ManagedKubernetesRuntime {
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
         */
        version?: string;
    }

    export interface ManagedKubernetesTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface ManagedKubernetesWorkerDataDisk {
        /**
         * Worker node data disk auto snapshot policy.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values: `cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`. Default to `cloudEfficiency`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, at least 40. Unit: GiB.
         */
        size?: string;
        snapshotId?: string;
    }

    export interface ManagedKubernetesWorkerNode {
        /**
         * ID of the node.
         */
        id: string;
        /**
         * The kubernetes cluster's name. It is unique in one Alicloud account.
         */
        name: string;
        /**
         * The private IP address of node.
         */
        privateIp: string;
    }

    export interface NodePoolDataDisk {
        autoSnapshotPolicyId?: string;
        /**
         * The type of the data disks. Valid values:`cloud`, `cloudEfficiency`, `cloudSsd` and `cloudEssd`.
         */
        category?: string;
        device?: string;
        /**
         * Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
         */
        encrypted?: string;
        kmsKeyId?: string;
        /**
         * The name of node pool.
         */
        name?: string;
        /**
         * Worker node data disk performance level, when `category` values `cloudEssd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
         */
        performanceLevel?: string;
        /**
         * The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
         */
        size?: number;
        snapshotId?: string;
    }

    export interface NodePoolLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface NodePoolManagement {
        /**
         * Whether automatic repair, Default to `false`.
         */
        autoRepair?: boolean;
        /**
         * Whether auto upgrade, Default to `false`.
         */
        autoUpgrade?: boolean;
        /**
         * Max number of unavailable nodes. Default to `1`.
         */
        maxUnavailable: number;
        /**
         * Number of additional nodes. You have to specify one of surge, surge_percentage.
         */
        surge?: number;
        /**
         * Proportion of additional nodes. You have to specify one of surge, surge_percentage.
         */
        surgePercentage?: number;
    }

    export interface NodePoolScalingConfig {
        /**
         * Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
         */
        eipBandwidth?: number;
        /**
         * EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internetChargeType`, EIP and public network IP can only choose one.
         */
        eipInternetChargeType?: string;
        /**
         * Whether to bind EIP for an instance. Default: `false`.
         */
        isBondEip?: boolean;
        /**
         * Max number of instances in a auto scaling group, its valid value range [0~1000]. `maxSize` has to be greater than `minSize`.
         */
        maxSize: number;
        /**
         * Min number of instances in a auto scaling group, its valid value range [0~1000].
         */
        minSize: number;
        /**
         * Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instanceTypes`.
         */
        type?: string;
    }

    export interface NodePoolSpotPriceLimit {
        /**
         * Spot instance type.
         */
        instanceType?: string;
        /**
         * The maximum hourly price of the spot instance.
         */
        priceLimit?: string;
    }

    export interface NodePoolTaint {
        effect?: string;
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface ServerlessKubernetesAddon {
        /**
         * The ACK add-on configurations.
         */
        config?: string;
        /**
         * Disables the automatic installation of a component. Default is `false`.
         */
        disabled?: boolean;
        /**
         * Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
         */
        name?: string;
    }

    export interface SwarmNode {
        eip: string;
        id: string;
        name: string;
        privateIp: string;
        status: string;
    }
}

export namespace dcdn {
    export interface DomainSource {
        /**
         * The origin address.
         */
        content: string;
        /**
         * The port number. Valid values: `443` and `80`. Default to `80`.
         */
        port?: number;
        /**
         * The priority of the origin if multiple origins are specified. Default to `20`.
         */
        priority?: string;
        /**
         * The type of the origin. Valid values:
         * `ipaddr`: The origin is configured using an IP address.
         * `domain`: The origin is configured using a domain name.
         * `oss`: The origin is configured using the Internet domain name of an Alibaba Cloud Object Storage Service (OSS) bucket.
         */
        type: string;
        /**
         * The weight of the origin if multiple origins are specified. Default to `10`.
         */
        weight?: string;
    }

    export interface GetDomainsDomain {
        /**
         * Indicates the name of the certificate.
         */
        certName: string;
        /**
         * The canonical name (CNAME) of the accelerated domain.
         */
        cname: string;
        /**
         * The reason that causes the review failure.
         */
        description: string;
        /**
         * The name of the DCDN Domain.
         */
        domainName: string;
        /**
         * The time when the accelerated domain was last modified.
         */
        gmtModified: string;
        /**
         * The ID of the DCDN Domain.
         */
        id: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The acceleration region.
         */
        scope: string;
        /**
         * The origin information.
         */
        sources: outputs.dcdn.GetDomainsDomainSource[];
        /**
         * Indicates whether the SSL certificate is enabled.
         */
        sslProtocol: string;
        /**
         * Indicates the public key of the certificate.
         */
        sslPub: string;
        /**
         * The status of DCDN Domain.
         */
        status: string;
    }

    export interface GetDomainsDomainSource {
        /**
         * The origin address.
         */
        content: string;
        /**
         * The status of the origin.
         */
        enabled: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The priority of the origin if multiple origins are specified.
         */
        priority: string;
        /**
         * The type of the origin. Valid values:
         */
        type: string;
        /**
         * The weight of the origin if multiple origins are specified.
         */
        weight: string;
    }
}

export namespace ddos {
    export interface DomainResourceProxyType {
        /**
         * the port number. This field is required and must be an integer.
         */
        proxyPorts?: number[];
        /**
         * the protocol type. This field is required and must be a string. Valid values: `http`, `https`, `websocket`, and `websockets`.
         */
        proxyType?: string;
    }

    export interface GetDdosBgpInstancesInstance {
        /**
         * The instance's elastic defend bandwidth.
         */
        bandwidth: number;
        /**
         * The instance's base defend bandwidth.
         */
        baseBandwidth: number;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's count of ip config.
         */
        ipCount: number;
        /**
         * The instance's IP version.
         */
        ipType: string;
        /**
         * The instance's remark.
         */
        name: string;
        /**
         * A region of instance.
         */
        region: string;
        /**
         * The instance's type.
         */
        type: string;
    }

    export interface GetDdosCooDomainResourcesResource {
        /**
         * The IP addresses in the blacklist for the domain name.
         */
        blackLists: string[];
        /**
         * Whether frequency control guard (CC guard) is enabled. Values: `True`: Opened, `False`: Not enabled.
         */
        ccEnabled: boolean;
        /**
         * Whether custom frequency control guard (CC guard) is enabled. Values: `True`: Opened, `False`: Not enabled.
         */
        ccRuleEnabled: boolean;
        /**
         * The mode of the Frequency Control policy.
         */
        ccTemplate: string;
        /**
         * The name of the certificate.
         */
        certName: string;
        /**
         * The domain name of the website that you want to add to the instance.
         */
        domain: string;
        /**
         * Whether Http2.0 is enabled.
         */
        http2Enable: boolean;
        /**
         * The advanced HTTPS settings.
         */
        httpsExt: string;
        /**
         * The ID of the Domain Resource.
         */
        id: string;
        /**
         * A list ID of instance that you want to associate.
         */
        instanceIds: string[];
        /**
         * The type of backload algorithm.
         */
        policyMode: string;
        /**
         * Whether the website service forwarding rules have been turned on.
         */
        proxyEnabled: boolean;
        /**
         * Protocol type and port number information.
         */
        proxyTypes: outputs.ddos.GetDdosCooDomainResourcesResourceProxyType[];
        /**
         * Server address information of the source station.
         */
        realServers: string[];
        /**
         * Server address type.
         */
        rsType: number;
        /**
         * The type of the cipher suite.
         */
        sslCiphers: string;
        /**
         * The version of the TLS protocol.
         */
        sslProtocols: string;
        /**
         * The IP addresses in the whitelist for the domain name.
         */
        whiteLists: string[];
    }

    export interface GetDdosCooDomainResourcesResourceProxyType {
        /**
         * The forwarding port.
         */
        proxyPorts: number[];
        /**
         * Protocol type.
         */
        proxyType: string;
    }

    export interface GetDdosCooInstancesInstance {
        /**
         * The instance's elastic defend bandwidth.
         */
        bandwidth: number;
        /**
         * The instance's base defend bandwidth.
         */
        baseBandwidth: number;
        /**
         * The instance's count of domain retransmission config.
         */
        domainCount: number;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's remark.
         */
        name: string;
        /**
         * The instance's count of port retransmission config.
         */
        portCount: number;
        /**
         * The instance's business bandwidth.
         */
        serviceBandwidth: number;
    }

    export interface GetDdosCooPortsPort {
        /**
         * The source station port.
         */
        backendPort: string;
        /**
         * The forwarding port.
         */
        frontendPort: string;
        /**
         * The forwarding protocol.
         */
        frontendProtocol: string;
        /**
         * The ID of the Port.
         */
        id: string;
        /**
         * The Ddoscoo instance ID.
         */
        instanceId: string;
        /**
         * List of source IP addresses.
         */
        realServers: string[];
    }

    export interface SchedulerRuleRule {
        priority?: number;
        regionId?: string;
        status: number;
        type?: string;
        value?: string;
        valueType?: number;
    }
}

export namespace dds {
    export interface GetMongoInstancesInstance {
        availabilityZone: string;
        chargeType: string;
        creationTime: string;
        engine: string;
        engineVersion: string;
        expirationTime: string;
        id: string;
        instanceClass: string;
        instanceType: string;
        lockMode: string;
        mongos: outputs.dds.GetMongoInstancesInstanceMongo[];
        name: string;
        networkType: string;
        regionId: string;
        replication: string;
        shards: outputs.dds.GetMongoInstancesInstanceShard[];
        status: string;
        storage: number;
        tags: {[key: string]: any};
    }

    export interface GetMongoInstancesInstanceMongo {
        class: string;
        description: string;
        nodeId: string;
    }

    export interface GetMongoInstancesInstanceShard {
        class: string;
        description: string;
        nodeId: string;
        storage: number;
    }
}

export namespace dms {
    export interface GetEnterpriseInstancesInstance {
        /**
         * The name of the data link for the database instance.
         */
        dataLinkName: string;
        /**
         * The logon password of the database instance.
         */
        databasePassword: string;
        /**
         * The logon username of the database instance.
         */
        databaseUser: string;
        /**
         * The ID of the database administrator (DBA) of the database instance.
         */
        dbaId: string;
        /**
         * The nickname of the DBA.
         */
        dbaNickName: string;
        /**
         * Indicates whether the online data description language (DDL) service was enabled for the database instance.
         */
        ddlOnline: number;
        /**
         * The ID of the Elastic Compute Service (ECS) instance to which the database instance belongs.
         */
        ecsInstanceId: string;
        /**
         * The region where the database instance resides.
         */
        ecsRegion: string;
        /**
         * The type of the environment to which the database instance belongs.
         */
        envType: string;
        /**
         * The timeout period for exporting the database instance.
         */
        exportTimeout: number;
        /**
         * The endpoint of the database instance.
         */
        host: string;
        id: string;
        /**
         * The alias of the database instance.
         */
        instanceAlias: string;
        /**
         * The ID of the database instance.
         */
        instanceId: string;
        instanceName: string;
        /**
         * The source of the database instance.
         */
        instanceSource: string;
        /**
         * The ID of the database instance.
         */
        instanceType: string;
        /**
         * The connection port of the database instance.
         */
        port: number;
        /**
         * The timeout period for querying the database instance.
         */
        queryTimeout: number;
        /**
         * The ID of the security rule for the database instance.
         */
        safeRuleId: string;
        /**
         * The system ID (SID) of the database instance.
         */
        sid: string;
        /**
         * Filter the results by status of the DMS Enterprise Instances. Valid values: `NORMAL`, `UNAVAILABLE`, `UNKNOWN`, `DELETED`, `DISABLE`.
         */
        status: string;
        /**
         * Indicates whether cross-database query was enabled for the database instance.
         */
        useDsql: number;
        /**
         * The ID of the Virtual Private Cloud (VPC) to which the database instance belongs.
         */
        vpcId: string;
    }

    export interface GetEnterpriseUsersUser {
        /**
         * The Alibaba Cloud unique ID (UID) of the user.
         */
        id: string;
        /**
         * The DingTalk number or mobile number of the user.
         */
        mobile: string;
        /**
         * The nickname of the user.
         */
        nickName: string;
        /**
         * The Alibaba Cloud unique ID (UID) of the parent account if the user corresponds to a Resource Access Management (RAM) user.
         */
        parentUid: number;
        /**
         * The list ids of the role that the user plays.
         */
        roleIds: number[];
        /**
         * The list names of the role that he user plays.
         */
        roleNames: string[];
        /**
         * The status of the user.
         */
        status: string;
        uid: string;
        /**
         * The ID of the user.
         */
        userId: string;
        /**
         * The nickname of the user.
         */
        userName: string;
    }
}

export namespace dns {
    export interface GetAlidnsDomainGroupsGroup {
        /**
         * Number of domain names in the group.
         */
        domainCount: number;
        /**
         * Id of the domain group.
         */
        groupId: string;
        /**
         * The name of the domain group.
         */
        groupName: string;
        /**
         * Id of the instance.
         */
        id: string;
    }

    export interface GetAlidnsDomainsDomain {
        /**
         * Specifies whether the domain is from Alibaba Cloud or not.
         */
        aliDomain: boolean;
        /**
         * List of available TTLs.
         */
        availableTtls: number[];
        /**
         * DNS list of domain names in the resolution system.
         */
        dnsServers: string[];
        /**
         * ID of the domain.
         */
        domainId: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * Domain group ID, if not filled, the default is all groups.
         */
        groupId: string;
        /**
         * Name of group that contains the domain.
         */
        groupName: string;
        /**
         * The Id of resource.
         */
        id: string;
        /**
         * Whether it is in black hole.
         */
        inBlackHole: boolean;
        /**
         * Whether it is cleaning.
         */
        inClean: boolean;
        /**
         * Cloud analysis product ID.
         */
        instanceId: string;
        lineType: string;
        /**
         * Minimum TTL.
         */
        minTtl: number;
        /**
         * Punycode of the Chinese domain.
         */
        punyCode: string;
        /**
         * Tree-like analytical line list.
         */
        recordLineTreeJson: string;
        /**
         * Parse the line data list.
         */
        recordLines: outputs.dns.GetAlidnsDomainsDomainRecordLine[];
        /**
         * Whether it is a regional route.
         */
        regionLines: boolean;
        /**
         * The Id of resource group which the dns belongs.
         */
        remark: string;
        /**
         * The Id of resource group which the dns belongs.
         */
        resourceGroupId: string;
        /**
         * Whether to allow auxiliary dns.
         */
        slaveDns: boolean;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Cloud analysis version code.
         */
        versionCode: string;
        versionName: string;
    }

    export interface GetAlidnsDomainsDomainRecordLine {
        /**
         * The code of the parent line, or empty if there is none.
         */
        fatherCode: string;
        /**
         * Sub-line Code.
         */
        lineCode: string;
        /**
         * Parent line display name.
         */
        lineDisplayName: string;
        /**
         * Sub-line display name.
         */
        lineName: string;
    }

    export interface GetAlidnsInstancesInstance {
        /**
         * DNS security level.
         */
        dnsSecurity: string;
        /**
         * (Available in 1.124.1+) The domain name.
         */
        domain: string;
        /**
         * Number of domain names bound.
         */
        domainNumbers: string;
        /**
         * Id of the instance.
         */
        id: string;
        /**
         * Id of the instance resource.
         */
        instanceId: string;
        /**
         * (Available in 1.124.1+) The payment type of alidns instance.
         */
        paymentType: string;
        /**
         * Paid package version.
         */
        versionCode: string;
        /**
         * Paid package version name.
         */
        versionName: string;
    }

    export interface GetAlidnsRecordsRecord {
        /**
         * The domain name associated to the records.
         */
        domainName: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * ISP line. For checking all resolution lines enumeration please visit [Alibaba Cloud DNS doc](https://www.alibabacloud.com/help/doc-detail/34339.htm)
         */
        line: string;
        /**
         * Indicates whether the record is locked.
         */
        locked: boolean;
        /**
         * Priority of the `MX` record.
         */
        priority: number;
        /**
         * ID of the record.
         */
        recordId: string;
        /**
         * Host record of the domain.
         */
        rr: string;
        /**
         * Record status. Valid values: `ENABLE` and `DISABLE`.
         */
        status: string;
        /**
         * TTL of the record.
         */
        ttl: number;
        /**
         * Record type. Valid values: `A`, `NS`, `MX`, `TXT`, `CNAME`, `SRV`, `AAAA`, `REDIRECT_URL`, `FORWORD_URL` .
         */
        type: string;
        /**
         * Host record value of the domain.
         */
        value: string;
    }

    export interface GetDomainGroupsGroup {
        groupId: string;
        groupName: string;
    }

    export interface GetDomainRecordsRecord {
        domainName: string;
        hostRecord: string;
        line: string;
        locked: boolean;
        priority: number;
        recordId: string;
        status: string;
        ttl: number;
        type: string;
        value: string;
    }

    export interface GetDomainsDomain {
        /**
         * Specifies whether the domain is from Alibaba Cloud or not.
         */
        aliDomain: boolean;
        availableTtls: number[];
        /**
         * DNS list of domain names in the resolution system.
         */
        dnsServers: string[];
        /**
         * ID of the domain.
         */
        domainId: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * Domain group ID, if not filled, the default is all groups.
         */
        groupId: string;
        /**
         * Name of group that contains the domain.
         */
        groupName: string;
        /**
         * The Id of resource.
         */
        id: string;
        /**
         * Whether it is in black hole.
         */
        inBlackHole: boolean;
        /**
         * Whether it is cleaning.
         */
        inClean: boolean;
        /**
         * Cloud analysis product ID.
         */
        instanceId: string;
        lineType: string;
        /**
         * Minimum TTL.
         */
        minTtl: number;
        /**
         * Punycode of the Chinese domain.
         */
        punyCode: string;
        /**
         * Tree-like analytical line list.
         */
        recordLineTreeJson: string;
        recordLines: outputs.dns.GetDomainsDomainRecordLine[];
        /**
         * Whether it is a regional route.
         */
        regionLines: boolean;
        /**
         * The Id of resource group which the dns belongs.
         */
        remark: string;
        /**
         * The Id of resource group which the dns belongs.
         */
        resourceGroupId: string;
        /**
         * Whether to allow auxiliary dns.
         */
        slaveDns: boolean;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Cloud analysis version code.
         */
        versionCode: string;
        versionName: string;
    }

    export interface GetDomainsDomainRecordLine {
        fatherCode: string;
        lineCode: string;
        lineDisplayName: string;
        lineName: string;
    }

    export interface GetGroupsGroup {
        /**
         * Id of the group.
         */
        groupId: string;
        /**
         * Name of the group.
         */
        groupName: string;
    }

    export interface GetInstancesInstance {
        /**
         * DNS security level.
         */
        dnsSecurity: string;
        domain: string;
        /**
         * Number of domain names bound.
         */
        domainNumbers: string;
        /**
         * Id of the instance.
         */
        id: string;
        /**
         * Id of the instance resource.
         */
        instanceId: string;
        paymentType: string;
        /**
         * Paid package version.
         */
        versionCode: string;
        /**
         * Paid package version name.
         */
        versionName: string;
    }

    export interface GetRecordsRecord {
        /**
         * The domain name associated to the records.
         */
        domainName: string;
        /**
         * Host record of the domain.
         */
        hostRecord: string;
        /**
         * ISP line. Valid items are `default`, `telecom`, `unicom`, `mobile`, `oversea`, `edu`, `drpeng`, `btvn`, .etc. For checking all resolution lines enumeration please visit [Alibaba Cloud DNS doc](https://www.alibabacloud.com/help/doc-detail/34339.htm)
         */
        line: string;
        /**
         * Indicates whether the record is locked.
         */
        locked: boolean;
        /**
         * Priority of the `MX` record.
         */
        priority: number;
        /**
         * ID of the record.
         */
        recordId: string;
        /**
         * Record status. Valid items are `ENABLE` and `DISABLE`.
         */
        status: string;
        /**
         * TTL of the record.
         */
        ttl: number;
        /**
         * Record type. Valid items are `A`, `NS`, `MX`, `TXT`, `CNAME`, `SRV`, `AAAA`, `REDIRECT_URL`, `FORWORD_URL` .
         */
        type: string;
        /**
         * Host record value of the domain.
         */
        value: string;
    }

    export interface GetResolutionLinesLine {
        lineCode: string;
        /**
         * Line display name.
         */
        lineDisplayName: string;
        /**
         * Line name.
         */
        lineName: string;
    }
}

export namespace drds {
    export interface GetInstancesInstance {
        /**
         * Creation time of the instance.
         */
        createTime: number;
        /**
         * The DRDS instance description.
         */
        description: string;
        /**
         * The ID of the DRDS instance.
         */
        id: string;
        /**
         * `Classic` for public classic network or `VPC` for private network.
         */
        networkType: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * The DRDS Instance type.
         */
        type: string;
        /**
         * The DRDS Instance version.
         */
        version: number;
        /**
         * Zone ID the instance belongs to.
         */
        zoneId: string;
    }
}

export namespace eci {
    export interface ContainerGroupContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         */
        environmentVars?: outputs.eci.ContainerGroupContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The amount of memory resources allocated to the container.
         */
        memory?: number;
        /**
         * The name of the mounted volume.
         */
        name: string;
        /**
         * The structure of port.
         */
        ports?: outputs.eci.ContainerGroupContainerPort[];
        ready: boolean;
        restartCount: number;
        /**
         * The structure of volumeMounts.
         */
        volumeMounts?: outputs.eci.ContainerGroupContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface ContainerGroupContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters, digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface ContainerGroupContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface ContainerGroupDnsConfig {
        /**
         * The list of DNS server IP addresses.
         */
        nameServers?: string[];
        /**
         * The structure of options.
         */
        options?: outputs.eci.ContainerGroupDnsConfigOption[];
        /**
         * The list of DNS lookup domains.
         */
        searches?: string[];
    }

    export interface ContainerGroupDnsConfigOption {
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupEciSecurityContext {
        sysctls?: outputs.eci.ContainerGroupEciSecurityContextSysctl[];
    }

    export interface ContainerGroupEciSecurityContextSysctl {
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupHostAlias {
        /**
         * Adds a host name.
         */
        hostnames?: string[];
        /**
         * Adds an IP address.
         */
        ip?: string;
    }

    export interface ContainerGroupInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args?: string[];
        /**
         * The commands run by the init container.
         */
        commands?: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu?: number;
        /**
         * The structure of environmentVars.
         */
        environmentVars?: outputs.eci.ContainerGroupInitContainerEnvironmentVar[];
        /**
         * The number GPUs.
         */
        gpu?: number;
        /**
         * The image of the container.
         */
        image?: string;
        /**
         * The restart policy of the image.
         */
        imagePullPolicy?: string;
        /**
         * The amount of memory resources allocated to the container.
         */
        memory?: number;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The structure of port.
         */
        ports?: outputs.eci.ContainerGroupInitContainerPort[];
        ready: boolean;
        restartCount: number;
        /**
         * The structure of volumeMounts.
         */
        volumeMounts?: outputs.eci.ContainerGroupInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir?: string;
    }

    export interface ContainerGroupInitContainerEnvironmentVar {
        /**
         * The name of the variable. The name can be 1 to 128 characters in length and can contain letters, digits, and underscores (_). It cannot start with a digit.
         */
        key?: string;
        /**
         * The value of the variable. The value can be 0 to 256 characters in length.
         */
        value?: string;
    }

    export interface ContainerGroupInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port?: number;
        /**
         * Valid values: TCP and UDP.
         */
        protocol?: string;
    }

    export interface ContainerGroupInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath?: string;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * Default to `false`.
         */
        readOnly?: boolean;
    }

    export interface ContainerGroupVolume {
        /**
         * ConfigFileVolumeConfigFileToPaths.
         */
        configFileVolumeConfigFileToPaths?: outputs.eci.ContainerGroupVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId?: string;
        /**
         * The system type of DiskVolume.
         */
        diskVolumeFsType?: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver?: string;
        /**
         * The type of the mounted file system. The default value is determined by the script of FlexVolume.
         */
        flexVolumeFsType?: string;
        /**
         * The list of FlexVolume objects. Each object is a key-value pair contained in a JSON string.
         */
        flexVolumeOptions?: string;
        /**
         * The name of the mounted volume.
         */
        name?: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath?: string;
        /**
         * The nfs volume read only. Default to `false`.
         */
        nfsVolumeReadOnly?: boolean;
        /**
         * The address of the NFS server.
         */
        nfsVolumeServer?: string;
        /**
         * The type of the volume.
         */
        type?: string;
    }

    export interface ContainerGroupVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content?: string;
        /**
         * The relative file path.
         */
        path?: string;
    }

    export interface GetContainerGroupsGroup {
        /**
         * The id if ContainerGroup.
         */
        containerGroupId: string;
        /**
         * The name of ContainerGroup.
         */
        containerGroupName: string;
        /**
         * A list of containers. Each element contains the following attributes:
         */
        containers: outputs.eci.GetContainerGroupsGroupContainer[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        discount: number;
        /**
         * The DNS settings.
         */
        dnsConfigs: outputs.eci.GetContainerGroupsGroupDnsConfig[];
        /**
         * The security context of the container group.
         */
        eciSecurityContexts: outputs.eci.GetContainerGroupsGroupEciSecurityContext[];
        /**
         * The ID of the ENI instance.
         */
        eniInstanceId: string;
        /**
         * The events of the container group. Maximum: `50`.
         */
        events: outputs.eci.GetContainerGroupsGroupEvent[];
        /**
         * The time when the container group failed to run due to overdue payments. The timestamp follows the UTC and RFC3339 formats.
         */
        expiredTime: string;
        /**
         * The time when the container failed to run tasks. The timestamp follows the UTC and RFC3339 formats.
         */
        failedTime: string;
        /**
         * The mapping between host names and IP addresses for a container in the container group.
         */
        hostAliases: outputs.eci.GetContainerGroupsGroupHostAlias[];
        /**
         * The ID of the Container Group.
         */
        id: string;
        /**
         * A list of init containers. Each element contains the following attributes:
         */
        initContainers: outputs.eci.GetContainerGroupsGroupInitContainer[];
        /**
         * The type of the ECS instance.
         */
        instanceType: string;
        /**
         * The public IP address of the container group.
         */
        internetIp: string;
        /**
         * The internal IP address of the container group.
         */
        intranetIp: string;
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The RAM role that the container group assumes. ECI and ECS share the same RAM role.
         */
        ramRoleName: string;
        /**
         * The ID of the resource group to which the container group belongs. If you have not specified a resource group for the container group, it is added to the default resource group.
         */
        resourceGroupId: string;
        /**
         * The restart policy of the container group.
         */
        restartPolicy: string;
        /**
         * The ID of the security group.
         */
        securityGroupId: string;
        /**
         * The status of container.
         */
        status: string;
        /**
         * The time when all containers in the container group completed running the specified tasks. The timestamp follows the UTC and RFC 3339 formats. For example, 2018-08-02T15:00:00Z.
         */
        succeededTime: string;
        /**
         * The tags attached to the container group. Each tag is a key-value pair. You can attach up to 20 tags to a container group.
         */
        tags: {[key: string]: any};
        /**
         * The information about the mounted volume. You can mount up to 20 volumes.
         */
        volumes: outputs.eci.GetContainerGroupsGroupVolume[];
        /**
         * The if of vpc.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The IDs of the zones where the container groups are deployed. If this parameter is not set, the system automatically selects the zones. By default, no value is specified.
         */
        zoneId: string;
    }

    export interface GetContainerGroupsGroupContainer {
        /**
         * The arguments passed to the commands.
         */
        args: string[];
        /**
         * The commands run by the container.
         */
        commands: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        /**
         * The environment variables.
         */
        environmentVars: outputs.eci.GetContainerGroupsGroupContainerEnvironmentVar[];
        /**
         * The amount of GPU resources allocated to the container.
         */
        gpu: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The policy for pulling an image.
         */
        imagePullPolicy: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The exposed ports and protocols. Maximum: `100`.
         */
        ports: outputs.eci.GetContainerGroupsGroupContainerPort[];
        /**
         * Indicates whether the container is ready.
         */
        ready: boolean;
        /**
         * The number of times that the container has restarted.
         */
        restartCount: number;
        /**
         * The list of volumes mounted to the container.
         */
        volumeMounts: outputs.eci.GetContainerGroupsGroupContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir: string;
    }

    export interface GetContainerGroupsGroupContainerEnvironmentVar {
        /**
         * The name of the variable.
         */
        key: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port: number;
        /**
         * Valid values: `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface GetContainerGroupsGroupContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * Default value: `false`.
         */
        readOnly: boolean;
    }

    export interface GetContainerGroupsGroupDnsConfig {
        /**
         * The list of DNS server IP addresses.
         */
        nameServers: string[];
        /**
         * The list of objects. Each object is a name-value pair. The value is optional.
         */
        options: outputs.eci.GetContainerGroupsGroupDnsConfigOption[];
        /**
         * The list of DNS lookup domains.
         */
        searches: string[];
    }

    export interface GetContainerGroupsGroupDnsConfigOption {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupEciSecurityContext {
        /**
         * The system information.
         */
        sysctls: outputs.eci.GetContainerGroupsGroupEciSecurityContextSysctl[];
    }

    export interface GetContainerGroupsGroupEciSecurityContextSysctl {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupEvent {
        /**
         * The number of events.
         */
        count: number;
        /**
         * The time when the event started.
         */
        firstTimestamp: string;
        /**
         * The time when the event ended.
         */
        lastTimestamp: string;
        /**
         * The content of the event.
         */
        message: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The name of the event.
         */
        reason: string;
        /**
         * The type of the volume. Currently, the following types of volumes are supported: EmptyDirVolume, NFSVolume, ConfigFileVolume, and FlexVolume.
         */
        type: string;
    }

    export interface GetContainerGroupsGroupHostAlias {
        /**
         * The name of the host.
         */
        hostnames: string[];
        /**
         * The IP address of the container.
         */
        ip: string;
    }

    export interface GetContainerGroupsGroupInitContainer {
        /**
         * The arguments passed to the commands.
         */
        args: string[];
        /**
         * The commands run by the container.
         */
        commands: string[];
        /**
         * The amount of CPU resources allocated to the container.
         */
        cpu: number;
        /**
         * The environment variables.
         */
        environmentVars: outputs.eci.GetContainerGroupsGroupInitContainerEnvironmentVar[];
        /**
         * The amount of GPU resources allocated to the container.
         */
        gpu: number;
        /**
         * The image of the container.
         */
        image: string;
        /**
         * The policy for pulling an image.
         */
        imagePullPolicy: string;
        /**
         * The amount of memory resources allocated to the container group.
         */
        memory: number;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The exposed ports and protocols. Maximum: `100`.
         */
        ports: outputs.eci.GetContainerGroupsGroupInitContainerPort[];
        /**
         * Indicates whether the container is ready.
         */
        ready: boolean;
        /**
         * The number of times that the container has restarted.
         */
        restartCount: number;
        /**
         * The list of volumes mounted to the container.
         */
        volumeMounts: outputs.eci.GetContainerGroupsGroupInitContainerVolumeMount[];
        /**
         * The working directory of the container.
         */
        workingDir: string;
    }

    export interface GetContainerGroupsGroupInitContainerEnvironmentVar {
        /**
         * The name of the variable.
         */
        key: string;
        /**
         * The value of the variable.
         */
        value: string;
    }

    export interface GetContainerGroupsGroupInitContainerPort {
        /**
         * The port number. Valid values: 1 to 65535.
         */
        port: number;
        /**
         * Valid values: `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface GetContainerGroupsGroupInitContainerVolumeMount {
        /**
         * The directory of the mounted volume. Data under this directory will be overwritten by the data in the volume.
         */
        mountPath: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * Default value: `false`.
         */
        readOnly: boolean;
    }

    export interface GetContainerGroupsGroupVolume {
        /**
         * The list of configuration file paths.
         */
        configFileVolumeConfigFileToPaths: outputs.eci.GetContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath[];
        /**
         * The ID of DiskVolume.
         */
        diskVolumeDiskId: string;
        /**
         * The type of DiskVolume.
         */
        diskVolumeFsType: string;
        /**
         * The name of the FlexVolume driver.
         */
        flexVolumeDriver: string;
        /**
         * The type of the mounted file system. The default value is determined by the script of FlexVolume.
         */
        flexVolumeFsType: string;
        /**
         * The list of FlexVolume objects.
         */
        flexVolumeOptions: string;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The path to the NFS volume.
         */
        nfsVolumePath: string;
        /**
         * Default value: `false`.
         */
        nfsVolumeReadOnly: boolean;
        /**
         * The address of the NFS server.
         */
        nfsVolumeServer: string;
        /**
         * The type of the volume. Currently, the following types of volumes are supported: EmptyDirVolume, NFSVolume, ConfigFileVolume, and FlexVolume.
         */
        type: string;
    }

    export interface GetContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath {
        /**
         * The content of the configuration file. Maximum size: 32 KB.
         */
        content: string;
        /**
         * The relative file path.
         */
        path: string;
    }

    export interface GetImageCachesCach {
        /**
         * The id of container group.
         */
        containerGroupId: string;
        /**
         * Image cache pulls image event information.
         */
        events: outputs.eci.GetImageCachesCachEvent[];
        /**
         * The time of expired.
         */
        expireDateTime: string;
        /**
         * The ID of the ECI Image Cache.
         */
        id: string;
        /**
         * The id of the ECI Image Cache.
         */
        imageCacheId: string;
        /**
         * The name of ECI Image Cache.
         */
        imageCacheName: string;
        /**
         * The list of cached images.
         */
        images: string[];
        /**
         * The progress of ECI Image Cache.
         */
        progress: string;
        /**
         * The id of snapshot.
         */
        snapshotId: string;
        /**
         * The status of ECI Image Cache.
         */
        status: string;
    }

    export interface GetImageCachesCachEvent {
        /**
         * Number of events.
         */
        count: number;
        /**
         * Start time.
         */
        firstTimestamp: string;
        /**
         * End time.
         */
        lastTimestamp: string;
        message: string;
        /**
         * The name of event.
         */
        name: string;
        /**
         * The type of event.
         */
        type: string;
    }

    export interface ImageCacheImageRegistryCredential {
        /**
         * The password of the Image Registry.
         */
        password?: string;
        /**
         * The address of Image Registry without `http://` or `https://`.
         */
        server?: string;
        /**
         * The user name of Image Registry.
         */
        userName?: string;
    }

    export interface OpenApiImageCacheImageRegistryCredential {
        password?: string;
        server?: string;
        userName?: string;
    }
}

export namespace ecs {
    export interface AutoProvisioningGroupLaunchTemplateConfig {
        instanceType?: string;
        maxPrice: string;
        priority: string;
        vswitchId: string;
        weightedCapacity: string;
    }

    export interface DedicatedHostNetworkAttribute {
        /**
         * The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
         */
        slbUdpTimeout?: number;
        /**
         * The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
         */
        udpTimeout?: number;
    }

    export interface EcsLaunchTemplateDataDisk {
        /**
         * The category of the disk.
         */
        category?: string;
        /**
         * Indicates whether the data disk is released with the instance.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * Encrypted the data in this disk.
         */
        encrypted?: boolean;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as the data disk.
         */
        performanceLevel?: string;
        /**
         * The size of the data disk.
         */
        size?: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface EcsLaunchTemplateNetworkInterfaces {
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp?: string;
        /**
         * The security group ID must be one in the same VPC.
         */
        securityGroupId?: string;
        /**
         * The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
         */
        vswitchId?: string;
    }

    export interface EcsLaunchTemplateSystemDisk {
        /**
         * The category of the disk.
         */
        category: string;
        /**
         * Indicates whether the data disk is released with the instance.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description: string;
        /**
         * The Iops.
         */
        iops?: string;
        /**
         * The name of the data disk.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the data disk.
         */
        performanceLevel?: string;
        /**
         * The size of the data disk.
         */
        size: number;
    }

    export interface GetAutoSnapshotPoliciesPolicy {
        /**
         * The ID of the Auto Snapshot Policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The retention period of the snapshot copied across regions.
         */
        copiedSnapshotsRetentionDays: number;
        /**
         * The number of disks to which the automatic snapshot policy is applied.
         */
        diskNums: number;
        /**
         * Specifies whether to enable the system to automatically copy snapshots across regions.
         */
        enableCrossRegionCopy: boolean;
        /**
         * The ID of the Auto Snapshot Policy.
         */
        id: string;
        /**
         * The snapshot policy name..
         */
        name: string;
        /**
         * The automatic snapshot repetition dates.
         */
        repeatWeekdays: string[];
        /**
         * The snapshot retention time, and the unit of measurement is day.
         */
        retentionDays: number;
        /**
         * The status of Auto Snapshot Policy.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The destination region to which the snapshot is copied.
         */
        targetCopyRegions: string[];
        /**
         * The automatic snapshot creation schedule, and the unit of measurement is hour.
         */
        timePoints: string[];
        /**
         * The number of extended volumes on which this policy is enabled.
         */
        volumeNums: number;
    }

    export interface GetCommandsCommand {
        /**
         * The Base64-encoded content of the command.
         */
        commandContent: string;
        /**
         * The ID of the Command.
         */
        commandId: string;
        /**
         * The description of command.
         */
        description: string;
        /**
         * Specifies whether to use custom parameters in the command to be created.
         */
        enableParameter: boolean;
        /**
         * The ID of the Command.
         */
        id: string;
        /**
         * The name of the command
         */
        name: string;
        /**
         * A list of custom parameter names which are parsed from the command content specified when the command was being created.
         */
        parameterNames: string[];
        /**
         * The timeout period that is specified for the command to be run on ECS instances.
         */
        timeout: number;
        /**
         * The command type.
         */
        type: string;
        /**
         * The execution path of the command in the ECS instance.
         */
        workingDir: string;
    }

    export interface GetDedicatedHostsHost {
        /**
         * The policy used to migrate the instances from the dedicated host when the dedicated host fails or needs to be repaired online.
         */
        actionOnMaintenance: string;
        /**
         * Specifies whether to add the dedicated host to the resource pool for automatic deployment.
         */
        autoPlacement: string;
        /**
         * The automatic release time of the dedicated host.
         */
        autoReleaseTime: string;
        /**
         * (Available in 1.123.1+) A collection of proprietary host performance indicators.
         */
        capacities: outputs.ecs.GetDedicatedHostsHostCapacity[];
        /**
         * A mapping of tags to assign to the resource.
         */
        cores: number;
        /**
         * (Available in 1.123.1+) CPU oversold ratio.
         */
        cpuOverCommitRatio: number;
        /**
         * The ID of ECS Dedicated Host.
         */
        dedicatedHostId: string;
        /**
         * The name of ECS Dedicated Host.
         */
        dedicatedHostName: string;
        /**
         * The type of the dedicated host.
         */
        dedicatedHostType: string;
        /**
         * The description of the dedicated host.
         */
        description: string;
        /**
         * The expiration time of the subscription dedicated host.
         */
        expiredTime: string;
        /**
         * The GPU model.
         */
        gpuSpec: string;
        /**
         * ID of the ECS Dedicated Host.
         */
        id: string;
        /**
         * The machine code of the dedicated host.
         */
        machineId: string;
        /**
         * dedicated host network parameters. contains the following attributes:
         */
        networkAttributes: outputs.ecs.GetDedicatedHostsHostNetworkAttribute[];
        /**
         * The reason why the dedicated host resource is locked.
         */
        operationLocks: outputs.ecs.GetDedicatedHostsHostOperationLock[];
        /**
         * The billing method of the dedicated host.
         */
        paymentType: string;
        /**
         * The number of physical GPUs.
         */
        physicalGpus: number;
        /**
         * The ID of the resource group to which the ECS Dedicated Host belongs.
         */
        resourceGroupId: string;
        /**
         * The unit of the subscription billing method.
         */
        saleCycle: string;
        /**
         * The number of physical CPUs.
         */
        sockets: number;
        /**
         * The status of the ECS Dedicated Host. validate value: `Available`, `Creating`, `PermanentFailure`, `Released`, `UnderAssessment`.
         */
        status: string;
        /**
         * (Available in 1.123.1+) A custom instance type family supported by a dedicated host.
         */
        supportedCustomInstanceTypeFamilies: string[];
        /**
         * (Available in 1.123.1+) ECS instance type family supported by the dedicated host.
         */
        supportedInstanceTypeFamilies: string[];
        /**
         * The list of ECS instance
         */
        supportedInstanceTypesLists: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The zone ID of the ECS Dedicated Host.
         */
        zoneId: string;
    }

    export interface GetDedicatedHostsHostCapacity {
        /**
         * The remaining local disk capacity. Unit: GiB.
         */
        availableLocalStorage: number;
        /**
         * The remaining memory capacity, unit: GiB.
         */
        availableMemory: number;
        /**
         * The number of remaining vCPU cores.
         */
        availableVcpus: number;
        /**
         * The number of available virtual GPUs.
         */
        availableVgpus: number;
        /**
         * Local disk type.
         */
        localStorageCategory: string;
        /**
         * The total capacity of the local disk, in GiB.
         */
        totalLocalStorage: number;
        /**
         * The total memory capacity, unit: GiB.
         */
        totalMemory: number;
        /**
         * The total number of vCPU cores.
         */
        totalVcpus: number;
        /**
         * The total number of virtual GPUs.
         */
        totalVgpus: number;
    }

    export interface GetDedicatedHostsHostNetworkAttribute {
        /**
         * The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds.
         */
        slbUdpTimeout: number;
        /**
         * (Available in 1.123.1+) The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds.
         */
        udpTimeout: number;
    }

    export interface GetDedicatedHostsHostOperationLock {
        /**
         * The reason why the dedicated host resource is locked.
         */
        lockReason: string;
    }

    export interface GetDedicatedHostsOperationLock {
        /**
         * The reason why the dedicated host resource is locked.
         */
        lockReason?: string;
    }

    export interface GetDisksDisk {
        /**
         * Disk attachment time.
         */
        attachedTime: string;
        autoSnapshotPolicyId: string;
        /**
         * Availability zone of the disk.
         */
        availabilityZone: string;
        /**
         * Disk category. Possible values: `cloud` (basic cloud disk), `cloudEfficiency` (ultra cloud disk), `ephemeralSsd` (local SSD cloud disk), `cloudSsd` (SSD cloud disk), and `cloudEssd` (ESSD cloud disk).
         */
        category: string;
        /**
         * Disk creation time.
         */
        creationTime: string;
        deleteAutoSnapshot: boolean;
        deleteWithInstance: boolean;
        /**
         * Disk description.
         */
        description: string;
        /**
         * Disk detachment time.
         */
        detachedTime: string;
        device: string;
        diskId: string;
        diskName: string;
        diskType: string;
        enableAutoSnapshot: boolean;
        enableAutomatedSnapshotPolicy: boolean;
        /**
         * Indicate whether the disk is encrypted or not. Possible values: `on` and `off`.
         */
        encrypted: string;
        expiredTime: string;
        /**
         * ID of the disk.
         */
        id: string;
        /**
         * ID of the image from which the disk is created. It is null unless the disk is created using an image.
         */
        imageId: string;
        /**
         * Filter the results by the specified ECS instance ID.
         */
        instanceId: string;
        iops: number;
        iopsRead: number;
        iopsWrite: number;
        kmsKeyId: string;
        mountInstanceNum: number;
        mountInstances: outputs.ecs.GetDisksDiskMountInstance[];
        /**
         * Disk name.
         */
        name: string;
        operationLocks: outputs.ecs.GetDisksDiskOperationLock[];
        paymentType: string;
        performanceLevel: string;
        portable: boolean;
        productCode: string;
        /**
         * Region ID the disk belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group which the disk belongs.
         */
        resourceGroupId: string;
        /**
         * Disk size in GiB.
         */
        size: number;
        /**
         * Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
         */
        snapshotId: string;
        /**
         * Current status. Possible values: `In_use`, `Available`, `Attaching`, `Detaching`, `Creating` and `ReIniting`.
         */
        status: string;
        /**
         * A map of tags assigned to the disks. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const disksDs = pulumi.output(alicloud.ecs.getDisks({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * Disk type. Possible values: `system` and `data`.
         */
        type: string;
        zoneId: string;
    }

    export interface GetDisksDiskMountInstance {
        /**
         * Disk attachment time.
         */
        attachedTime: string;
        device: string;
        /**
         * Filter the results by the specified ECS instance ID.
         */
        instanceId: string;
    }

    export interface GetDisksDiskOperationLock {
        lockReason: string;
    }

    export interface GetDisksOperationLock {
        lockReason?: string;
    }

    export interface GetEcsDisksDisk {
        /**
         * A mount of time.
         */
        attachedTime: string;
        /**
         * Query cloud disks based on the automatic snapshot policy ID.
         */
        autoSnapshotPolicyId: string;
        /**
         * Availability zone of the disk.
         */
        availabilityZone: string;
        /**
         * Disk category.
         */
        category: string;
        /**
         * Disk creation time.
         */
        creationTime: string;
        /**
         * Indicates whether the automatic snapshot is deleted when the disk is released.
         */
        deleteAutoSnapshot: boolean;
        /**
         * Indicates whether the disk is released together with the instance.
         */
        deleteWithInstance: boolean;
        /**
         * Disk description.
         */
        description: string;
        /**
         * Disk detachment time.
         */
        detachedTime: string;
        /**
         * The mount point of the disk.
         */
        device: string;
        /**
         * ID of the disk.
         */
        diskId: string;
        /**
         * The disk name.
         */
        diskName: string;
        /**
         * The disk type.
         */
        diskType: string;
        /**
         * Whether the disk implements an automatic snapshot policy.
         */
        enableAutoSnapshot: boolean;
        /**
         * Whether the disk implements an automatic snapshot policy.
         */
        enableAutomatedSnapshotPolicy: boolean;
        /**
         * Indicate whether the disk is encrypted or not.
         */
        encrypted: string;
        expiredTime: string;
        /**
         * ID of the disk.
         */
        id: string;
        /**
         * ID of the image from which the disk is created. It is null unless the disk is created using an image.
         */
        imageId: string;
        /**
         * The instance ID of the disk mount.
         */
        instanceId: string;
        iops: number;
        iopsRead: number;
        iopsWrite: number;
        /**
         * The kms key id.
         */
        kmsKeyId: string;
        /**
         * Number of instances mounted on shared storage.
         */
        mountInstanceNum: number;
        /**
         * Disk mount instances.
         */
        mountInstances: outputs.ecs.GetEcsDisksDiskMountInstance[];
        /**
         * Disk name.
         */
        name: string;
        operationLocks: outputs.ecs.GetEcsDisksDiskOperationLock[];
        /**
         * Payment method for disk.
         */
        paymentType: string;
        /**
         * Performance levels of ESSD cloud disk.
         */
        performanceLevel: string;
        /**
         * Whether the disk is unmountable.
         */
        portable: boolean;
        /**
         * The product logo of the cloud market.
         */
        productCode: string;
        /**
         * Region ID the disk belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group.
         */
        resourceGroupId: string;
        /**
         * Disk size in GiB.
         */
        size: number;
        /**
         * Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
         */
        snapshotId: string;
        /**
         * Current status.
         */
        status: string;
        /**
         * A map of tags assigned to the disk.
         */
        tags: {[key: string]: any};
        /**
         * Disk type.
         */
        type: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetEcsDisksDiskMountInstance {
        /**
         * A mount of time.
         */
        attachedTime: string;
        /**
         * The mount point of the disk.
         */
        device: string;
        /**
         * The instance ID of the disk mount.
         */
        instanceId: string;
    }

    export interface GetEcsDisksDiskOperationLock {
        lockReason: string;
    }

    export interface GetEcsDisksOperationLock {
        lockReason?: string;
    }

    export interface GetEcsKeyPairsKeyPair {
        /**
         * The finger print of the key pair.
         */
        fingerPrint: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetEcsKeyPairsKeyPairInstance[];
        /**
         * The Key Pair Name.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Resource Group Id.
         */
        resourceGroupId: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsKeyPairsKeyPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * The Key Pair Name.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetEcsKeyPairsPair {
        /**
         * The finger print of the key pair.
         */
        fingerPrint: string;
        /**
         * The ID of the Key Pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetEcsKeyPairsPairInstance[];
        /**
         * The Key Pair Name.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Resource Group Id.
         */
        resourceGroupId: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
    }

    export interface GetEcsKeyPairsPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * The Key Pair Name.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetEcsLaunchTemplatesTemplate {
        /**
         * Instance auto release time.
         */
        autoReleaseTime: string;
        /**
         * CreatedBy.
         */
        createdBy: string;
        /**
         * The list of data disks created with instance.
         */
        dataDisks: outputs.ecs.GetEcsLaunchTemplatesTemplateDataDisk[];
        /**
         * The Default Version Number.
         */
        defaultVersionNumber: number;
        /**
         * The Deployment Set Id.
         */
        deploymentSetId: string;
        /**
         * System disk description.
         */
        description: string;
        /**
         * Whether to enable the instance operating system configuration.
         */
        enableVmOsConfig: boolean;
        /**
         * Instance host name.
         */
        hostName: string;
        /**
         * The ID of the Launch Template.
         */
        id: string;
        /**
         * The Image Id.
         */
        imageId: string;
        /**
         * Mirror source.
         */
        imageOwnerAlias: string;
        /**
         * Internet bandwidth billing method.
         */
        instanceChargeType: string;
        /**
         * The Instance Name.
         */
        instanceName: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Internet bandwidth billing method.
         */
        internetChargeType: string;
        /**
         * The maximum inbound bandwidth from the Internet network, measured in Mbit/s.
         */
        internetMaxBandwidthIn: number;
        /**
         * Maximum outbound bandwidth from the Internet, its unit of measurement is Mbit/s.
         */
        internetMaxBandwidthOut: number;
        /**
         * Whether it is an I/O-optimized instance or not.
         */
        ioOptimized: string;
        /**
         * The name of the key pair.
         */
        keyPairName: string;
        /**
         * The Latest Version Number.
         */
        latestVersionNumber: number;
        /**
         * The ID of the Launch Template.
         */
        launchTemplateId: string;
        /**
         * The Launch Template Name.
         */
        launchTemplateName: string;
        /**
         * The Modified Time.
         */
        modifiedTime: string;
        /**
         * The list of network interfaces created with instance.
         */
        networkInterfaces: outputs.ecs.GetEcsLaunchTemplatesTemplateNetworkInterface[];
        /**
         * Network type of the instance.
         */
        networkType: string;
        /**
         * Whether to use the password preset by the mirror.
         */
        passwordInherit: boolean;
        /**
         * The subscription period of the instance.
         */
        period: number;
        /**
         * The private IP address of the instance.
         */
        privateIpAddress: string;
        /**
         * The RAM role name of the instance.
         */
        ramRoleName: string;
        /**
         * The ID of the resource group to which to assign the instance, Elastic Block Storage (EBS) device, and ENI.
         */
        resourceGroupId: string;
        /**
         * Whether or not to activate the security enhancement feature and install network security software free of charge.
         */
        securityEnhancementStrategy: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The security group IDs.
         */
        securityGroupIds: string[];
        /**
         * The protection period of the preemptible instance.
         */
        spotDuration: string;
        /**
         * Sets the maximum hourly instance price.
         */
        spotPriceLimit: number;
        /**
         * The spot strategy for a Pay-As-You-Go instance.
         */
        spotStrategy: string;
        /**
         * The System Disk.
         */
        systemDisks: outputs.ecs.GetEcsLaunchTemplatesTemplateSystemDisk[];
        /**
         * The template tags.
         */
        templateTags: {[key: string]: any};
        /**
         * The User Data.
         */
        userData: string;
        /**
         * The Version Description.
         */
        versionDescription: string;
        /**
         * VpcId.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The Zone Id.
         */
        zoneId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateDataDisk {
        /**
         * The category of the system disk.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released.
         */
        deleteWithInstance: boolean;
        /**
         * System disk description.
         */
        description: string;
        /**
         * Encrypted the data in this disk.
         */
        encrypted: boolean;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        performanceLevel: string;
        /**
         * Size of the system disk, measured in GB.
         */
        size: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateNetworkInterface {
        /**
         * System disk description.
         */
        description: string;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp: string;
        /**
         * The security group ID.
         */
        securityGroupId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetEcsLaunchTemplatesTemplateSystemDisk {
        /**
         * The category of the system disk.
         */
        category: string;
        /**
         * Specifies whether to release the system disk when the instance is released.
         */
        deleteWithInstance: boolean;
        /**
         * System disk description.
         */
        description: string;
        /**
         * The Iops.
         */
        iops: string;
        /**
         * System disk name.
         */
        name: string;
        /**
         * The performance level of the ESSD used as the system disk.
         */
        performanceLevel: string;
        /**
         * Size of the system disk, measured in GB.
         */
        size: number;
    }

    export interface GetEcsNetworkInterfacesInterface {
        /**
         * The creation time.
         */
        creationTime: string;
        /**
         * The description of the ENI.
         */
        description: string;
        /**
         * The ID of the Network Interface.
         */
        id: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The MAC address of the ENI.
         */
        mac: string;
        /**
         * The network interface name.
         */
        name: string;
        /**
         * The network interface id.
         */
        networkInterfaceId: string;
        /**
         * The network interface name.
         */
        networkInterfaceName: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIpAddress: string;
        /**
         * The primary private IP address of the ENI.
         */
        privateIp: string;
        privateIpAddresses: string[];
        /**
         * A list of secondary private IP address that is assigned to the ENI.
         */
        privateIps: string[];
        /**
         * Number of network card queues.
         */
        queueNumber: number;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * The security group ids.
         */
        securityGroupIds: string[];
        /**
         * The security groups.
         */
        securityGroups: string[];
        /**
         * The service id.
         */
        serviceId: number;
        /**
         * Whether the user of the elastic network card is a cloud product or a virtual vendor.
         */
        serviceManaged: boolean;
        /**
         * The status of the ENI.
         */
        status: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
        /**
         * The type of the ENI.
         */
        type: string;
        /**
         * The Vpc Id.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetEcsSnapshotsSnapshot {
        /**
         * The category of the snapshot.
         */
        category: string;
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The source disk id.
         */
        diskId: string;
        /**
         * Whether the snapshot is encrypted.
         */
        encrypted: boolean;
        /**
         * The ID of the Snapshot.
         */
        id: string;
        /**
         * Whether snapshot speed availability is enabled.
         */
        instantAccess: boolean;
        /**
         * Specifies the retention period of the instant access feature. After the retention period ends, the snapshot is automatically released.
         */
        instantAccessRetentionDays: number;
        name: string;
        /**
         * The product number inherited from the mirror market.
         */
        productCode: string;
        /**
         * Snapshot creation progress, in percentage.
         */
        progress: string;
        /**
         * Remaining completion time for the snapshot being created.
         */
        remainTime: number;
        /**
         * The resource group id.
         */
        resourceGroupId: string;
        /**
         * Automatic snapshot retention days.
         */
        retentionDays: number;
        /**
         * The snapshot id.
         */
        snapshotId: string;
        /**
         * Snapshot Display Name.
         */
        snapshotName: string;
        /**
         * The serial number of the snapshot.
         */
        snapshotSn: string;
        /**
         * Snapshot creation type.
         */
        snapshotType: string;
        sourceDiskId: string;
        /**
         * Source disk capacity.
         */
        sourceDiskSize: string;
        /**
         * Source disk attributes.
         */
        sourceDiskType: string;
        /**
         * Original disk type.
         */
        sourceStorageType: string;
        /**
         * The status of the snapshot.
         */
        status: string;
        /**
         * The tags.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * A resource type that has a reference relationship.
         */
        usage: string;
    }

    export interface GetEipsEip {
        /**
         * EIP internet max bandwidth in Mbps.
         */
        bandwidth: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * ID of the EIP.
         */
        id: string;
        /**
         * The ID of the instance that is being bound.
         */
        instanceId: string;
        /**
         * The instance type of that the EIP is bound.
         */
        instanceType: string;
        /**
         * EIP internet charge type.
         */
        internetChargeType: string;
        /**
         * Public IP Address of the the EIP.
         */
        ipAddress: string;
        /**
         * EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
         */
        status: string;
    }

    export interface GetHpcClustersCluster {
        /**
         * The description of ECS Hpc Cluster.
         */
        description: string;
        /**
         * The ID of the Hpc Cluster.
         */
        hpcClusterId: string;
        /**
         * The ID of the Hpc Cluster.
         */
        id: string;
        /**
         * The name of ECS Hpc Cluster.
         */
        name: string;
    }

    export interface GetImagesImage {
        /**
         * The image architecture. Valid values: `i386` and `x8664`.
         */
        architecture: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the image.
         */
        description: string;
        /**
         * Description of the system with disks and snapshots under the image.
         */
        diskDeviceMappings: outputs.ecs.GetImagesImageDiskDeviceMapping[];
        /**
         * ID of the image.
         */
        id: string;
        imageId: string;
        /**
         * Alias of the image owner.
         */
        imageOwnerAlias: string;
        /**
         * Version of the image.
         */
        imageVersion: string;
        isCopied: boolean;
        isSelfShared: string;
        /**
         * Whether the user has subscribed to the terms of service for the image product corresponding to the ProductCode.
         */
        isSubscribed: boolean;
        /**
         * Specifies whether the image can be used on I/O optimized instances.
         */
        isSupportIoOptimized: boolean;
        name: string;
        /**
         * Display Chinese name of the OS.
         */
        osName: string;
        /**
         * Display English name of the OS.
         */
        osNameEn: string;
        /**
         * The operating system type of the image. Valid values: `windows` and `linux`.
         */
        osType: string;
        platform: string;
        /**
         * Product code of the image on the image market.
         */
        productCode: string;
        /**
         * Progress of image creation, presented in percentages.
         */
        progress: string;
        /**
         * Size of the created disk.
         */
        size: number;
        state: string;
        /**
         * The status of the image. The following values are available, Separate multiple parameter values by using commas (,). Default value: `Available`. Valid values: 
         * * `Creating`: The image is being created.
         * * `Waiting`: The image is waiting to be processed.
         * * `Available`: The image is available.
         * * `UnAvailable`: The image is unavailable.
         * * `CreateFailed`: The image failed to be created.
         * * `Deprecated`: The image is discontinued.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * Specifies whether to check the validity of the request without actually making the request. Valid values:                                           
         * * `instance`: The image is already in use and running on an ECS instance.
         * * `none`: The image is not in use.
         */
        usage: string;
    }

    export interface GetImagesImageDiskDeviceMapping {
        /**
         * Device information of the created disk: such as /dev/xvdb.
         */
        device: string;
        /**
         * Size of the created disk.
         */
        size: string;
        /**
         * The ID of the snapshot used to create the custom image.
         */
        snapshotId: string;
    }

    export interface GetInstanceTypeFamiliesFamily {
        /**
         * The generation of the instance type family, Valid values: `ecs-1`, `ecs-2`, `ecs-3` and `ecs-4`. For more information, see [Instance type families](https://www.alibabacloud.com/help/doc-detail/25378.htm).
         */
        generation: string;
        /**
         * ID of the instance type family.
         */
        id: string;
        /**
         * A list of Zone to launch the instance.
         */
        zoneIds: string[];
    }

    export interface GetInstanceTypesInstanceType {
        /**
         * List of availability zones that support the instance type.
         */
        availabilityZones: string[];
        /**
         * The burstable instance attribution:
         */
        burstableInstance: outputs.ecs.GetInstanceTypesInstanceTypeBurstableInstance;
        /**
         * Filter the results to a specific number of cpu cores.
         */
        cpuCoreCount: number;
        /**
         * Filter the result whose network interface number is no more than `eniAmount`.
         */
        eniAmount: number;
        /**
         * The instance type family.
         */
        family: string;
        /**
         * The GPU attribution of an instance type:
         */
        gpu: outputs.ecs.GetInstanceTypesInstanceTypeGpu;
        /**
         * ID of the instance type.
         */
        id: string;
        /**
         * Local storage of an instance type:
         */
        localStorage: outputs.ecs.GetInstanceTypesInstanceTypeLocalStorage;
        /**
         * Filter the results to a specific memory size in GB.
         */
        memorySize: number;
        price: string;
    }

    export interface GetInstanceTypesInstanceTypeBurstableInstance {
        /**
         * The compute performance benchmark CPU credit of a burstable instance.
         */
        baselineCredit: string;
        /**
         * The initial CPU credit of a burstable instance.
         */
        initialCredit: string;
    }

    export interface GetInstanceTypesInstanceTypeGpu {
        /**
         * The number of local storage devices that an instance has been attached to.
         */
        amount: string;
        /**
         * The category of local storage that an instance has been attached to.
         */
        category: string;
    }

    export interface GetInstanceTypesInstanceTypeLocalStorage {
        /**
         * The number of local storage devices that an instance has been attached to.
         */
        amount: string;
        /**
         * The capacity of a local storage in GB.
         */
        capacity: string;
        /**
         * The category of local storage that an instance has been attached to.
         */
        category: string;
    }

    export interface GetInstancesInstance {
        /**
         * Availability zone where instances are located.
         */
        availabilityZone: string;
        /**
         * Instance creation time.
         */
        creationTime: string;
        /**
         * Instance description.
         */
        description: string;
        /**
         * Description of the attached disks.
         */
        diskDeviceMappings: outputs.ecs.GetInstancesInstanceDiskDeviceMapping[];
        /**
         * EIP address the VPC instance is using.
         */
        eip: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * The image ID of some ECS instance used.
         */
        imageId: string;
        /**
         * Instance charge type.
         */
        instanceChargeType: string;
        /**
         * Instance type.
         */
        instanceType: string;
        /**
         * Instance network charge type.
         */
        internetChargeType: string;
        /**
         * Max output bandwidth for internet.
         */
        internetMaxBandwidthOut: number;
        /**
         * Key pair the instance is using.
         */
        keyName: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * Instance private IP address.
         */
        privateIp: string;
        /**
         * Instance public IP address.
         */
        publicIp: string;
        /**
         * The RAM role name which the instance attaches.
         */
        ramRoleName: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * The Id of resource group which the instance belongs.
         */
        resourceGroupId: string;
        /**
         * List of security group IDs the instance belongs to.
         */
        securityGroups: string[];
        /**
         * Spot strategy the instance is using.
         */
        spotStrategy: string;
        /**
         * Instance status. Valid values: "Creating", "Starting", "Running", "Stopping" and "Stopped". If undefined, all statuses are considered.
         */
        status: string;
        /**
         * A map of tags assigned to the ECS instances. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = pulumi.output(alicloud.ecs.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * ID of the VPC linked to the instances.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the instances.
         */
        vswitchId: string;
    }

    export interface GetInstancesInstanceDiskDeviceMapping {
        /**
         * Cloud disk category.
         */
        category: string;
        /**
         * Device information of the created disk: such as /dev/xvdb.
         */
        device: string;
        /**
         * Size of the created disk.
         */
        size: number;
        /**
         * Cloud disk type: system disk or data disk.
         */
        type: string;
    }

    export interface GetKeyPairsKeyPair {
        /**
         * A finger print used to retrieve specified key pair.
         */
        fingerPrint: string;
        /**
         * ID of the key pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetKeyPairsKeyPairInstance[];
        /**
         * Name of the key pair.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Id of resource group which the key pair belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetKeyPairsKeyPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * Name of the key pair.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetKeyPairsPair {
        /**
         * A finger print used to retrieve specified key pair.
         */
        fingerPrint: string;
        /**
         * ID of the key pair.
         */
        id: string;
        /**
         * A list of ECS instances that has been bound this key pair.
         */
        instances: outputs.ecs.GetKeyPairsPairInstance[];
        /**
         * Name of the key pair.
         */
        keyName: string;
        keyPairName: string;
        /**
         * The Id of resource group which the key pair belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetKeyPairsPairInstance {
        /**
         * The ID of the availability zone where the ECS instance is located.
         */
        availabilityZone: string;
        description: string;
        imageId: string;
        /**
         * The ID of the ECS instance.
         */
        instanceId: string;
        /**
         * The name of the ECS instance.
         */
        instanceName: string;
        instanceType: string;
        /**
         * Name of the key pair.
         */
        keyName: string;
        /**
         * The private IP address of the ECS instance.
         */
        privateIp: string;
        /**
         * The public IP address or EIP of the ECS instance.
         */
        publicIp: string;
        regionId: string;
        status: string;
        /**
         * The ID of the VSwitch attached to the ECS instance.
         */
        vswitchId: string;
    }

    export interface GetNetworkInterfacesInterface {
        /**
         * Creation time of the ENI.
         */
        creationTime: string;
        /**
         * Description of the ENI.
         */
        description: string;
        /**
         * ID of the ENI.
         */
        id: string;
        /**
         * ID of the instance that the ENI is attached to.
         */
        instanceId: string;
        /**
         * MAC address of the ENI.
         */
        mac: string;
        /**
         * Name of the ENI.
         */
        name: string;
        networkInterfaceId: string;
        networkInterfaceName: string;
        primaryIpAddress: string;
        /**
         * Primary private IP of the ENI.
         */
        privateIp: string;
        privateIpAddresses: string[];
        /**
         * A list of secondary private IP address that is assigned to the ENI.
         */
        privateIps: string[];
        queueNumber: number;
        /**
         * The Id of resource group.
         */
        resourceGroupId: string;
        securityGroupIds: string[];
        /**
         * A list of security group that the ENI belongs to.
         */
        securityGroups: string[];
        serviceId: number;
        serviceManaged: boolean;
        /**
         * Current status of the ENI.
         */
        status: string;
        /**
         * A map of tags assigned to the ENI.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * ID of the VPC that the ENI belongs to.
         */
        vpcId: string;
        /**
         * ID of the VSwitch that the ENI is linked to.
         */
        vswitchId: string;
        /**
         * ID of the availability zone that the ENI belongs to.
         */
        zoneId: string;
    }

    export interface GetSecurityGroupRulesRule {
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * Target IP address segment for egress authorization.
         */
        destCidrIp: string;
        /**
         * Target security group id for ingress authorization.
         */
        destGroupId: string;
        /**
         * Alibaba Cloud account of the target security group.
         */
        destGroupOwnerAccount: string;
        /**
         * Authorization direction. Valid values are: `ingress` or `egress`.
         */
        direction: string;
        /**
         * The IP protocol. Valid values are: `tcp`, `udp`, `icmp`, `gre` and `all`.
         */
        ipProtocol: string;
        /**
         * Refers to the network type. Can be either `internet` or `intranet`. The default value is `internet`.
         */
        nicType: string;
        /**
         * Authorization policy. Can be either `accept` or `drop`. The default value is `accept`.
         */
        policy: string;
        /**
         * The range of port numbers.
         */
        portRange: string;
        /**
         * Rule priority.
         */
        priority: number;
        /**
         * Source IP address segment for ingress authorization.
         */
        sourceCidrIp: string;
        /**
         * Source security group ID for ingress authorization.
         */
        sourceGroupId: string;
        /**
         * Alibaba Cloud account of the source security group.
         */
        sourceGroupOwnerAccount: string;
    }

    export interface GetSecurityGroupsGroup {
        /**
         * Creation time of the security group.
         */
        creationTime: string;
        /**
         * The description of the security group.
         */
        description: string;
        /**
         * The ID of the security group.
         */
        id: string;
        /**
         * Whether to allow inner network access.
         */
        innerAccess: boolean;
        /**
         * The name of the security group.
         */
        name: string;
        /**
         * The Id of resource group which the securityGroup belongs.
         */
        resourceGroupId: string;
        /**
         * The type of the security group.
         */
        securityGroupType: string;
        /**
         * A map of tags assigned to the ECS instances. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedSecurityGroups = pulumi.output(alicloud.ecs.getSecurityGroups({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * Used to retrieve security groups that belong to the specified VPC ID.
         */
        vpcId: string;
    }

    export interface GetSnapshotsSnapshot {
        category: string;
        /**
         * Creation time. Time of creation. It is represented according to ISO8601, and UTC time is used. Format: YYYY-MM-DDThh:mmZ.
         */
        creationTime: string;
        /**
         * Description of the snapshot.
         */
        description: string;
        diskId: string;
        /**
         * Whether the snapshot is encrypted or not.
         */
        encrypted: boolean;
        /**
         * ID of the snapshot.
         */
        id: string;
        instantAccess: boolean;
        instantAccessRetentionDays: number;
        /**
         * Name of the snapshot.
         */
        name: string;
        /**
         * Product code on the image market place.
         */
        productCode: string;
        /**
         * Progress of snapshot creation, presented in percentage.
         */
        progress: string;
        /**
         * The remaining time of a snapshot creation task, in seconds.
         */
        remainTime: number;
        resourceGroupId: string;
        /**
         * The number of days that an automatic snapshot retains in the console for your instance.
         */
        retentionDays: number;
        snapshotId: string;
        snapshotName: string;
        snapshotSn: string;
        snapshotType: string;
        /**
         * Source disk ID, which is retained after the source disk of the snapshot is deleted.
         */
        sourceDiskId: string;
        /**
         * Size of the source disk, measured in GB.
         */
        sourceDiskSize: string;
        /**
         * Source disk attribute. Value range: `System`,`Data`.
         */
        sourceDiskType: string;
        sourceStorageType: string;
        /**
         * The snapshot status. Value range: `progressing`, `accomplished` and `failed`.
         */
        status: string;
        /**
         * A map of tags assigned to the snapshot.
         */
        tags: {[key: string]: any};
        type: string;
        /**
         * Whether the snapshots are used to create resources or not. Value range: `image`, `disk`, `imageDisk` and `none`.
         */
        usage: string;
    }

    export interface ImageDiskDeviceMapping {
        /**
         * Specifies the name of a disk in the combined custom image. Value range: /dev/xvda to /dev/xvdz.
         */
        device: string;
        /**
         * Specifies the type of a disk in the combined custom image. If you specify this parameter, you can use a data disk snapshot as the data source of a system disk for creating an image. If it is not specified, the disk type is determined by the corresponding snapshot. Valid values: `system`, `data`,
         */
        diskType: string;
        /**
         * Specifies the size of a disk in the combined custom image, in GiB. Value range: 5 to 2000.
         */
        size: number;
        /**
         * Specifies a snapshot that is used to create a combined custom image.
         */
        snapshotId: string;
    }

    export interface ImageImportDiskDeviceMapping {
        /**
         * The name of disk N in the custom image.
         */
        device: string;
        /**
         * Resolution size. You must ensure that the system disk space â‰¥ file system space. Ranges: When n = 1, the system disk: 5 ~ 500GiB, When n = 2 ~ 17, that is, data disk: 5 ~ 1000GiB, When temporary is introduced, the system automatically detects the size, which is subject to the detection result.
         */
        diskImageSize?: number;
        /**
         * Image format. Value range: When the `RAW`, `VHD`, `qcow2` is imported into the image, the system automatically detects the image format, whichever comes first.
         */
        format: string;
        /**
         * Save the exported OSS bucket.
         */
        ossBucket?: string;
        /**
         * The file name of your OSS Object.
         */
        ossObject?: string;
    }

    export interface InstanceDataDisk {
        /**
         * The ID of the automatic snapshot policy applied to the system disk.
         */
        autoSnapshotPolicyId?: string;
        /**
         * The category of the disk:
         * - `cloud`: The general cloud disk.
         * - `cloudEfficiency`: The efficiency cloud disk.
         * - `cloudSsd`: The SSD cloud disk.
         * - `cloudEssd`: The ESSD cloud disk.
         * - `ephemeralSsd`: The local SSD disk.
         * Default to `cloudEfficiency`.
         */
        category?: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_essd, cloudSsd disk. If the category of this data disk was ephemeral_ssd, please don't set this param. Default value: `true`.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * -(Optional, Bool, ForceNew) Encrypted the data in this disk. Default value: `false`.
         */
        encrypted?: boolean;
        /**
         * The KMS key ID corresponding to the Nth data disk.
         */
        kmsKeyId?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The performance level of the ESSD used as data disk:
         * - `PL0`: A single ESSD can deliver up to 10,000 random read/write IOPS.
         * - `PL1`: A single ESSD can deliver up to 50,000 random read/write IOPS.
         * - `PL2`: A single ESSD can deliver up to 100,000 random read/write IOPS.
         * - `PL3`: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
         * Default to `PL1`.
         */
        performanceLevel: string;
        /**
         * The size of the data disk.
         * - cloudï¼š[5, 2000]
         * - cloud_efficiencyï¼š[20, 32768]
         * - cloud_ssdï¼š[20, 32768]
         * - cloud_essdï¼š[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface LaunchTemplateDataDisk {
        /**
         * The category of the disk:
         * - cloud: Basic cloud disk.
         * - cloud_efficiency: Ultra cloud disk.
         * - cloud_ssd: SSD cloud Disks.
         * - ephemeral_ssd: local SSD Disks
         * - cloud_essd: ESSD cloud Disks.
         */
        category?: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloudSsd and cloudEssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * -(Optional, Bool) Encrypted the data in this disk.
         */
        encrypted?: boolean;
        /**
         * The name of the data disk.
         */
        name?: string;
        performanceLevel?: string;
        /**
         * The size of the data disk.
         * - cloudï¼š[5, 2000]
         * - cloud_efficiencyï¼š[20, 32768]
         * - cloud_ssdï¼š[20, 32768]
         * - cloud_essdï¼š[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size?: number;
        /**
         * The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
         */
        snapshotId?: string;
    }

    export interface LaunchTemplateNetworkInterfaces {
        /**
         * The description of the data disk.
         */
        description?: string;
        /**
         * The name of the data disk.
         */
        name?: string;
        /**
         * The primary private IP address of the ENI.
         */
        primaryIp?: string;
        /**
         * The security group ID must be one in the same VPC.
         */
        securityGroupId?: string;
        /**
         * The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
         */
        vswitchId?: string;
    }

    export interface LaunchTemplateSystemDisk {
        /**
         * The category of the disk:
         * - cloud: Basic cloud disk.
         * - cloud_efficiency: Ultra cloud disk.
         * - cloud_ssd: SSD cloud Disks.
         * - ephemeral_ssd: local SSD Disks
         * - cloud_essd: ESSD cloud Disks.
         */
        category: string;
        /**
         * Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloudSsd and cloudEssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
         */
        deleteWithInstance?: boolean;
        /**
         * The description of the data disk.
         */
        description: string;
        iops?: string;
        /**
         * The name of the data disk.
         */
        name: string;
        performanceLevel?: string;
        /**
         * The size of the data disk.
         * - cloudï¼š[5, 2000]
         * - cloud_efficiencyï¼š[20, 32768]
         * - cloud_ssdï¼š[20, 32768]
         * - cloud_essdï¼š[20, 32768]
         * - ephemeral_ssd: [5, 800]
         */
        size: number;
    }
}

export namespace edas {
    export interface GetApplicationsApplication {
        /**
         * The ID of the application that you want to deploy.
         */
        appId: string;
        /**
         * The name of your EDAS application. Only letters '-' '_' and numbers are allowed. The length cannot exceed 36 characters.
         */
        appName: string;
        /**
         * The type of the package for the deployment of the application that you want to create. The valid values are: WAR and JAR. We strongly recommend you to set this parameter when creating the application.
         */
        applicationType: string;
        /**
         * The package ID of Enterprise Distributed Application Service (EDAS) Container.
         */
        buildPackageId: number;
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The type of the cluster that you want to create. Valid values: 1: Swarm cluster. 2: ECS cluster. 3: Kubernates cluster.
         */
        clusterType: number;
        /**
         * The ID of the namespace the application belongs to.
         */
        regionId: string;
    }

    export interface GetClustersCluster {
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The name of the cluster.
         */
        clusterName: string;
        /**
         * The type of the cluster, Valid values: 1: Swarm cluster. 2: ECS cluster. 3: Kubernates cluster.
         */
        clusterType: number;
        /**
         * The total number of CPUs in the cluster.
         */
        cpu: number;
        /**
         * The number of used CPUs in the cluster.
         */
        cpuUsed: number;
        /**
         * Cluster's creation time.
         */
        createTime: number;
        /**
         * The total amount of memory in the cluser. Unit: MB.
         */
        mem: number;
        /**
         * The amount of used memory in the cluser. Unit: MB.
         */
        memUsed: number;
        /**
         * The network type of the cluster. Valid values: 1: classic network. 2: VPC.
         */
        networkMode: number;
        /**
         * The number of the Elastic Compute Service (ECS) instances that are deployed to the cluster.
         */
        nodeNum: number;
        /**
         * The ID of the namespace the application belongs to.
         */
        regionId: string;
        /**
         * The time when the cluster was last updated.
         */
        updateTime: number;
        /**
         * The ID of the Virtual Private Cloud (VPC) for the cluster.
         */
        vpcId: string;
    }

    export interface GetDeployGroupsGroup {
        /**
         * ID of the EDAS application.
         */
        appId: string;
        /**
         * The version of the deployment package for the application.
         */
        appVersionId: string;
        /**
         * The ID of the cluster that you want to create the application.
         */
        clusterId: string;
        /**
         * The time when the instance group was created.
         */
        createTime: number;
        /**
         * The ID of the instance group.
         */
        groupId: string;
        /**
         * The name of the instance group. The length cannot exceed 64 characters.
         */
        groupName: string;
        /**
         * The type of the instance group. Valid values: 0: Default group. 1: Phased release is disabled for traffic management. 2: Phased release is enabled for traffic management.
         */
        groupType: number;
        /**
         * The version of the deployment package for the instance group that was created.
         */
        packageVersionId: string;
        /**
         * The time when the instance group was updated.
         */
        updateTime: number;
    }
}

export namespace eipanycast {
    export interface GetAnycastEipAddressesAddress {
        /**
         * Anycast EIP instance account ID.
         */
        aliUid: number;
        /**
         * Anycast EIP instance name.
         */
        anycastEipAddressName: string;
        /**
         * AnycastEip binding information.
         */
        anycastEipBindInfoLists: outputs.eipanycast.GetAnycastEipAddressesAddressAnycastEipBindInfoList[];
        /**
         * Anycast EIP instance ID.
         */
        anycastId: string;
        /**
         * The peak bandwidth of the Anycast EIP instance, in Mbps.
         */
        bandwidth: number;
        /**
         * Anycast EIP instance account BID.
         */
        bid: string;
        /**
         * The business status of the Anycast EIP instance. -`Normal`: Normal state. -`FinancialLocked`: The status of arrears locked.
         */
        businessStatus: string;
        /**
         * Anycast EIP instance description.
         */
        description: string;
        /**
         * The ID of the Anycast Eip Address.
         */
        id: string;
        /**
         * The billing method of Anycast EIP instance. `PayByBandwidth`: refers to the method of billing based on traffic.
         */
        internetChargeType: string;
        /**
         * Anycast EIP instance IP address.
         */
        ipAddress: string;
        /**
         * The payment model of Anycast EIP instance. "PostPaid": Refers to the post-paid mode.
         */
        paymentType: string;
        /**
         * Anycast EIP instance access area. "international": Refers to areas outside of Mainland China.
         */
        serviceLocation: string;
        /**
         * IP statusã€‚- `Associating`, `Unassociating`, `Allocated`, `Associated`, `Modifying`, `Releasing`, `Released`.
         */
        status: string;
    }

    export interface GetAnycastEipAddressesAddressAnycastEipBindInfoList {
        /**
         * The bound cloud resource instance ID.
         */
        bindInstanceId: string;
        /**
         * The region ID of the bound cloud resource instance.
         */
        bindInstanceRegionId: string;
        /**
         * Bind the cloud resource instance type.
         */
        bindInstanceType: string;
        /**
         * Binding time.
         */
        bindTime: string;
    }
}

export namespace elasticsearch {
    export interface GetInstancesInstance {
        createdAt: string;
        dataNodeAmount: number;
        dataNodeDiskSize: number;
        dataNodeDiskType: string;
        dataNodeSpec: string;
        description: string;
        id: string;
        instanceChargeType: string;
        status: string;
        tags: {[key: string]: any};
        updatedAt: string;
        version: string;
        vswitchId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }
}

export namespace emr {
    export interface ClusterBootstrapAction {
        /**
         * bootstrap action args, e.g. "--a=b".
         */
        arg?: string;
        /**
         * bootstrap action name.
         */
        name?: string;
        /**
         * bootstrap action path, e.g. "oss://bucket/path".
         */
        path?: string;
    }

    export interface ClusterHostGroup {
        /**
         * Auto renew for prepaid, true of false. Default is false.
         */
        autoRenew?: boolean;
        /**
         * Charge Type for this group of hosts: PostPaid or PrePaid. If this is not specified, charge type will follow global chargeType value.
         */
        chargeType?: string;
        /**
         * Data disk capacity.
         */
        diskCapacity?: string;
        /**
         * Data disk count.
         */
        diskCount?: string;
        /**
         * Data disk type. Supported value: cloud,cloud_efficiency,cloud_ssd,local_disk,cloud_essd.
         */
        diskType?: string;
        gpuDriver?: string;
        /**
         * host group name.
         */
        hostGroupName?: string;
        /**
         * host group type, supported value: MASTER, CORE or TASK, supported 'GATEWAY' available in 1.61.0+.
         */
        hostGroupType?: string;
        /**
         * Instance list for cluster scale down. This value follows the json format, e.g. ["instanceId1","instanceId2"]. escape character for " is \".
         */
        instanceList?: string;
        /**
         * Host Ecs instance type.
         */
        instanceType?: string;
        /**
         * Host number in this group.
         */
        nodeCount?: string;
        /**
         * If charge type is PrePaid, this should be specified, unit is month. Supported value: 1ã€2ã€3ã€4ã€5ã€6ã€7ã€8ã€9ã€12ã€24ã€36.
         */
        period?: number;
        /**
         * System disk capacity.
         */
        sysDiskCapacity?: string;
        /**
         * System disk type. Supported value: cloud,cloud_efficiency,cloud_ssd,cloud_essd.
         */
        sysDiskType?: string;
    }

    export interface GetDiskTypesType {
        /**
         * The maximum value of the data disk to supported the specific instance type
         */
        max: number;
        /**
         * The mininum value of the data disk to supported the specific instance type
         */
        min: number;
        /**
         * The value of the data disk or system disk
         */
        value: string;
    }

    export interface GetInstanceTypesType {
        /**
         * The ID of the instance type.
         */
        id: string;
        /**
         * Local capacity of the applied ecs instance for emr cluster. Unit: GB.
         */
        localStorageCapacity: number;
        /**
         * The supported resources of specific zoneId.
         */
        zoneId: string;
    }

    export interface GetMainVersionsMainVersion {
        /**
         * A list of cluster types the emr cluster supported. Possible values: `HADOOP`, `ZOOKEEPER`, `KAFKA`, `DRUID`.
         */
        clusterTypes: string[];
        /**
         * The version of the emr cluster instance. Possible values: `EMR-4.0.0`, `EMR-3.23.0`, `EMR-3.22.0`.
         */
        emrVersion: string;
        /**
         * The image id of the emr cluster instance.
         */
        imageId: string;
    }
}

export namespace ess {
    export interface GetAlarmsAlarm {
        /**
         * The list of actions to execute when this alarm transition into an ALARM state. Each action is specified as ess scaling rule ari.
         */
        alarmActions: string[];
        /**
         * Defines the application group id defined by CMS which is assigned when you upload custom metric to CMS, only available for custom metirc.
         */
        cloudMonitorGroupId: number;
        /**
         * The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand.
         */
        comparisonOperator: string;
        /**
         * The description for the alarm.
         */
        description: string;
        /**
         * The dimension map for the alarm's associated metric.
         */
        dimensions: {[key: string]: any};
        /**
         * Whether to enable specific ess alarm.
         */
        enable: boolean;
        /**
         * The number of times that needs to satisfies comparison condition before transition into ALARM state.
         */
        evaluationCount: number;
        /**
         * The id of alarm.
         */
        id: string;
        /**
         * The name for the alarm's associated metric. See Block_metricNames_and_dimensions below for details.
         */
        metricName: string;
        /**
         * The type for the alarm's associated metric. Supported value: system, custom. "system" means the metric data is collected by Aliyun Cloud Monitor Service(CMS), "custom" means the metric data is upload to CMS by users. Defaults to system.
         */
        metricType: string;
        /**
         * The name for ess alarm.
         */
        name: string;
        /**
         * The period in seconds over which the specified statistic is applied.
         */
        period: number;
        /**
         * Scaling group id the alarms belong to.
         */
        scalingGroupId: string;
        /**
         * The state of alarm task.
         */
        state: string;
        /**
         * The statistic to apply to the alarm's associated metric.
         */
        statistics: string;
        /**
         * The value against which the specified statistics is compared.
         */
        threshold: string;
    }

    export interface GetLifecycleHooksHook {
        /**
         * Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses.
         */
        defaultResult: string;
        /**
         * Defines the amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action defined in the defaultResult parameter.
         */
        heartbeatTimeout: number;
        /**
         * ID of the lifecycle hook.
         */
        id: string;
        /**
         * Type of Scaling activity attached to lifecycle hook.
         */
        lifecycleTransition: string;
        /**
         * Name of the lifecycle hook.
         */
        name: string;
        /**
         * The Arn of notification target.
         */
        notificationArn: string;
        /**
         * Additional information that you want to include when Auto Scaling sends a message to the notification target.
         */
        notificationMetadata: string;
        /**
         * Scaling group id the lifecycle hooks belong to.
         */
        scalingGroupId: string;
    }

    export interface GetNotificationsNotification {
        /**
         * ID of the notification.
         */
        id: string;
        /**
         * The Alibaba Cloud Resource Name (ARN) for the notification object.
         */
        notificationArn: string;
        /**
         * The notification types of Auto Scaling events and resource changes.
         */
        notificationTypes: string[];
        /**
         * Scaling group id the notifications belong to.
         */
        scalingGroupId: string;
    }

    export interface GetScalingConfigurationsConfiguration {
        /**
         * Creation time of the scaling configuration.
         */
        creationTime: string;
        /**
         * Performance mode of the t5 burstable instance.
         */
        creditSpecification: string;
        /**
         * Data disks of the scaling configuration.
         */
        dataDisks: outputs.ess.GetScalingConfigurationsConfigurationDataDisk[];
        /**
         * ID of the scaling rule.
         */
        id: string;
        /**
         * Image ID of the scaling configuration.
         */
        imageId: string;
        /**
         * Instance type of the scaling configuration.
         */
        instanceType: string;
        /**
         * Internet charge type of the scaling configuration.
         */
        internetChargeType: string;
        /**
         * Internet max bandwidth in of the scaling configuration.
         */
        internetMaxBandwidthIn: number;
        /**
         * Internet max bandwidth of the scaling configuration.
         */
        internetMaxBandwidthOut: number;
        /**
         * Lifecycle state of the scaling configuration.
         */
        lifecycleState: string;
        /**
         * Name of the scaling configuration.
         */
        name: string;
        /**
         * Scaling group id the scaling configurations belong to.
         */
        scalingGroupId: string;
        /**
         * Security group ID of the scaling configuration.
         */
        securityGroupId: string;
        /**
         * System disk category of the scaling configuration.
         */
        systemDiskCategory: string;
        /**
         * System disk size of the scaling configuration.
         */
        systemDiskSize: number;
    }

    export interface GetScalingConfigurationsConfigurationDataDisk {
        /**
         * Category of data disk.
         */
        category?: string;
        /**
         * Delete_with_instance attribute of data disk.
         */
        deleteWithInstance?: boolean;
        /**
         * Device attribute of data disk.
         */
        device?: string;
        /**
         * Size of data disk.
         */
        size?: number;
        /**
         * Size of data disk.
         */
        snapshotId?: string;
    }

    export interface GetScalingGroupsGroup {
        /**
         * Number of active instances in scaling group.
         */
        activeCapacity: number;
        activeScalingConfiguration: string;
        /**
         * Default cooldown time of scaling group.
         */
        cooldownTime: number;
        /**
         * Creation time of scaling group.
         */
        creationTime: string;
        /**
         * Db instances id which the ECS instance attached to.
         */
        dbInstanceIds: string[];
        /**
         * ID of the scaling group.
         */
        id: string;
        /**
         * Active launch template ID for scaling group.
         */
        launchTemplateId: string;
        /**
         * Version of active launch template.
         */
        launchTemplateVersion: string;
        /**
         * Lifecycle state of scaling group.
         */
        lifecycleState: string;
        /**
         * Slb instances id which the ECS instance attached to.
         */
        loadBalancerIds: string[];
        /**
         * The maximum number of ECS instances.
         */
        maxSize: number;
        /**
         * The minimum number of ECS instances.
         */
        minSize: number;
        /**
         * Name of the scaling group.
         * * `activeScalingConfiguration` -Active scaling configuration for scaling group.
         */
        name: string;
        /**
         * Number of pending instances in scaling group.
         */
        pendingCapacity: number;
        /**
         * Region ID the scaling group belongs to.
         */
        regionId: string;
        /**
         * Removal policy used to select the ECS instance to remove from the scaling group.
         */
        removalPolicies: string[];
        /**
         * Number of removing instances in scaling group.
         */
        removingCapacity: number;
        /**
         * Number of instances in scaling group.
         */
        totalCapacity: number;
        /**
         * Vswitches id in which the ECS instance launched.
         */
        vswitchIds: string[];
    }

    export interface GetScalingRulesRule {
        /**
         * Adjustment type of the scaling rule.
         */
        adjustmentType: string;
        /**
         * Adjustment value of the scaling rule.
         */
        adjustmentValue: number;
        /**
         * Cooldown time of the scaling rule.
         */
        cooldown: number;
        /**
         * ID of the scaling rule.
         */
        id: string;
        /**
         * Min adjustment magnitude of scaling rule.
         */
        minAdjustmentMagnitude: number;
        /**
         * Name of the scaling rule.
         */
        name: string;
        /**
         * Scaling group id the scaling rules belong to.
         */
        scalingGroupId: string;
        /**
         * Ari of scaling rule.
         */
        scalingRuleAri: string;
        /**
         * Type of scaling rule.
         */
        type: string;
    }

    export interface GetScheduledTasksTask {
        /**
         * Description of the scheduled task.
         */
        description: string;
        /**
         * ID of the scheduled task id.
         */
        id: string;
        /**
         * The time period during which a failed scheduled task is retried.
         */
        launchExpirationTime: number;
        /**
         * The time at which the scheduled task is triggered.
         */
        launchTime: string;
        maxValue: number;
        minValue: number;
        /**
         * Name of the scheduled task name.
         */
        name: string;
        /**
         * Specifies the end time after which the scheduled task is no longer repeated.
         */
        recurrenceEndTime: string;
        /**
         * Specifies the recurrence type of the scheduled task.
         */
        recurrenceType: string;
        /**
         * Specifies how often a scheduled task recurs.
         */
        recurrenceValue: string;
        /**
         * The operation to be performed when a scheduled task is triggered.
         */
        scheduledAction: string;
        taskEnabled: boolean;
    }

    export interface ScalingConfigurationDataDisk {
        autoSnapshotPolicyId?: string;
        category?: string;
        deleteWithInstance?: boolean;
        description?: string;
        /**
         * @deprecated Attribute device has been deprecated on disk attachment resource. Suggest to remove it from your template.
         */
        device?: string;
        encrypted?: boolean;
        kmsKeyId?: string;
        name?: string;
        size?: number;
        snapshotId?: string;
    }

    export interface ScalingGroupVServerGroupsVserverGroup {
        loadbalancerId: string;
        vserverAttributes: outputs.ess.ScalingGroupVServerGroupsVserverGroupVserverAttribute[];
    }

    export interface ScalingGroupVServerGroupsVserverGroupVserverAttribute {
        port: number;
        vserverGroupId: string;
        weight: number;
    }

    export interface ScalingRuleStepAdjustment {
        metricIntervalLowerBound?: string;
        metricIntervalUpperBound?: string;
        scalingAdjustment?: number;
    }
}

export namespace fc {
    export interface AliasRoutingConfig {
        /**
         * A map that defines the proportion of events that should be sent to different versions of a Function Compute service.
         */
        additionalVersionWeights?: {[key: string]: number};
    }

    export interface CustomDomainCertConfig {
        /**
         * The name of the certificate, used to distinguish different certificates.
         */
        certName: string;
        /**
         * Certificate data of the HTTPS certificates, follow the 'pem' format.
         */
        certificate: string;
        /**
         * Private key of the HTTPS certificates, follow the 'pem' format.
         */
        privateKey: string;
    }

    export interface CustomDomainRouteConfig {
        /**
         * The name of the Function Compute function that requests are routed to.
         */
        functionName: string;
        /**
         * The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
         */
        methods?: string[];
        /**
         * The path that requests are routed from.
         */
        path: string;
        /**
         * The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service. For detail information about verison and alias, please refer to the [developer guide](https://www.alibabacloud.com/help/doc-detail/96464.htm).
         */
        qualifier?: string;
        serviceName: string;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfig {
        /**
         * Configuration block with destination configuration for failed asynchronous invocations. See below for details.
         */
        onFailure?: outputs.fc.FunctionAsyncInvokeConfigDestinationConfigOnFailure;
        /**
         * Configuration block with destination configuration for successful asynchronous invocations. See below for details.
         */
        onSuccess?: outputs.fc.FunctionAsyncInvokeConfigDestinationConfigOnSuccess;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfigOnFailure {
        /**
         * Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
         */
        destination: string;
    }

    export interface FunctionAsyncInvokeConfigDestinationConfigOnSuccess {
        /**
         * Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
         */
        destination: string;
    }

    export interface FunctionCustomContainerConfig {
        /**
         * The args field specifies the arguments passed to the command.
         */
        args?: string;
        /**
         * The entry point of the container, which specifies the actual command run by the container.
         */
        command?: string;
        /**
         * The container image address.
         */
        image: string;
    }

    export interface GetCustomDomainsDomain {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The API version of the Function Compute service.
         */
        apiVersion: string;
        /**
         * The configuration of HTTPS certificate.
         */
        certConfig: outputs.fc.GetCustomDomainsDomainCertConfig;
        /**
         * The created time of the custom domain.
         */
        createdTime: string;
        /**
         * The custom domain name.
         */
        domainName: string;
        /**
         * The custom domain id, same as domain name.
         */
        id: string;
        /**
         * The last modified time of the custom domain.
         */
        lastModifiedTime: string;
        /**
         * The custom domain protocol.
         */
        protocol: string;
        /**
         * The configuration of domain route, mapping the path and Function Compute function.
         */
        routeConfigs: outputs.fc.GetCustomDomainsDomainRouteConfig[];
    }

    export interface GetCustomDomainsDomainCertConfig {
        /**
         * The name of the certificate.
         */
        certName: string;
        /**
         * Certificate data of the HTTPS certificates, follow the 'pem'.
         */
        certificate: string;
    }

    export interface GetCustomDomainsDomainRouteConfig {
        /**
         * The name of the Function Compute function that requests are routed to.
         */
        functionName: string;
        /**
         * The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
         */
        methods: string[];
        /**
         * The path that requests are routed from.
         */
        path: string;
        /**
         * The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service.
         */
        qualifier: string;
        /**
         * The name of the Function Compute service that requests are routed to.
         */
        serviceName: string;
    }

    export interface GetFunctionsFunction {
        /**
         * The port that the function listen to, only valid for [custom runtime](https://www.alibabacloud.com/help/doc-detail/132044.htm) and [custom container runtime](https://www.alibabacloud.com/help/doc-detail/179368.htm).
         */
        caPort: number;
        /**
         * Checksum (crc64) of the function code.
         */
        codeChecksum: string;
        /**
         * Function code size in bytes.
         */
        codeSize: number;
        /**
         * Function creation time.
         */
        creationTime: string;
        /**
         * The configuration for custom container runtime. It contains following attributes:
         */
        customContainerConfig?: outputs.fc.GetFunctionsFunctionCustomContainerConfig;
        /**
         * Function description.
         */
        description: string;
        /**
         * A map that defines environment variables for the function.
         */
        environmentVariables: {[key: string]: any};
        /**
         * Function [entry point](https://www.alibabacloud.com/help/doc-detail/62213.htm) in the code.
         */
        handler: string;
        /**
         * Function ID.
         */
        id: string;
        /**
         * The maximum length of time, in seconds, that the function's initialization should be run for.
         */
        initializationTimeout: number;
        /**
         * The entry point of the function's [initialization](https://www.alibabacloud.com/help/doc-detail/157704.htm).
         */
        initializer: string;
        /**
         * The maximum number of requests can be executed concurrently within the single function instance.
         */
        instanceConcurrency: number;
        /**
         * The instance type of the function.
         */
        instanceType: string;
        /**
         * Function last modification time.
         */
        lastModificationTime: string;
        /**
         * Amount of memory in MB the function can use at runtime.
         */
        memorySize: number;
        /**
         * Function name.
         */
        name: string;
        /**
         * Function runtime. The list of possible values is [available here](https://www.alibabacloud.com/help/doc-detail/52077.htm).
         */
        runtime: string;
        /**
         * Maximum amount of time the function can run in seconds.
         */
        timeout: number;
    }

    export interface GetFunctionsFunctionCustomContainerConfig {
        /**
         * The args field specifies the arguments passed to the command.
         */
        args: string;
        /**
         * The entry point of the container, which specifies the actual command run by the container.
         */
        command: string;
        /**
         * The container image address.
         */
        image: string;
    }

    export interface GetServicesService {
        /**
         * FC service creation time.
         */
        creationTime: string;
        /**
         * FC service description.
         */
        description: string;
        /**
         * FC service ID.
         */
        id: string;
        /**
         * Indicate whether the service can access to internet or not.
         */
        internetAccess: boolean;
        /**
         * FC service last modification time.
         */
        lastModificationTime: string;
        /**
         * A list of one element containing information about the associated log store. It contains the following attributes:
         */
        logConfig: outputs.fc.GetServicesServiceLogConfig;
        /**
         * FC service name.
         */
        name: string;
        /**
         * A list of one element about the nas configuration.
         */
        nasConfig: outputs.fc.GetServicesServiceNasConfig;
        /**
         * FC service role ARN.
         */
        role: string;
        /**
         * A list of one element containing information about accessible VPC resources. It contains the following attributes:
         */
        vpcConfig: outputs.fc.GetServicesServiceVpcConfig;
    }

    export interface GetServicesServiceLogConfig {
        /**
         * Log Service store name.
         */
        logstore: string;
        /**
         * Log Service project name.
         */
        project: string;
    }

    export interface GetServicesServiceNasConfig {
        /**
         * The group id of the NAS file system.
         */
        groupId: number;
        /**
         * The mount points configuration, including following attributes:
         */
        mountPoints: outputs.fc.GetServicesServiceNasConfigMountPoint[];
        /**
         * The user id of the NAS file system.
         */
        userId: number;
    }

    export interface GetServicesServiceNasConfigMountPoint {
        /**
         * The local address where to mount your remote NAS directory.
         */
        mountDir: string;
        /**
         * The address of the remote NAS directory.
         */
        serverAddr: string;
    }

    export interface GetServicesServiceVpcConfig {
        /**
         * Associated security group ID.
         */
        securityGroupId: string;
        /**
         * Associated VPC ID.
         */
        vpcId: string;
        /**
         * Associated VSwitch IDs.
         */
        vswitchIds: string[];
    }

    export interface GetTriggersTrigger {
        /**
         * JSON-encoded trigger configuration. See [Configure triggers and events](https://www.alibabacloud.com/help/doc-detail/70140.htm) for more details.
         */
        config: string;
        /**
         * FC trigger creation time.
         */
        creationTime: string;
        /**
         * FC trigger ID.
         */
        id: string;
        /**
         * RAM role arn attached to the Function Compute trigger. Role used by the event source to call the function. The value format is "acs:ram::$account-id:role/$role-name". See [Create a trigger](https://www.alibabacloud.com/help/doc-detail/53102.htm) for more details.
         */
        invocationRole: string;
        /**
         * FC trigger last modification time.
         */
        lastModificationTime: string;
        /**
         * FC trigger name.
         */
        name: string;
        /**
         * Event source resource address. See [Create a trigger](https://www.alibabacloud.com/help/doc-detail/53102.htm) for more details.
         */
        sourceArn: string;
        /**
         * Type of the trigger. Valid values: `oss`, `log`, `timer`, `http` and `mnsTopic`.
         */
        type: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
    }

    export interface ServiceLogConfig {
        /**
         * The log store name of Alicloud Simple Log Service.
         */
        logstore: string;
        /**
         * The project name of the Alicloud Simple Log Service.
         */
        project: string;
    }

    export interface ServiceNasConfig {
        /**
         * The group id of your NAS file system.
         */
        groupId: number;
        /**
         * Config the NAS mount points, including following attributes:
         */
        mountPoints: outputs.fc.ServiceNasConfigMountPoint[];
        /**
         * The user id of your NAS file system.
         */
        userId: number;
    }

    export interface ServiceNasConfigMountPoint {
        /**
         * The local address where to mount your remote NAS directory.
         */
        mountDir: string;
        /**
         * The address of the remote NAS directory.
         */
        serverAddr: string;
    }

    export interface ServiceVpcConfig {
        /**
         * A security group ID associated with the Function Compute Service.
         */
        securityGroupId: string;
        vpcId: string;
        /**
         * A list of vswitch IDs associated with the Function Compute Service.
         */
        vswitchIds: string[];
    }
}

export namespace fnf {
    export interface GetFlowsFlow {
        /**
         * The definition of the flow. It must comply with the Flow Definition Language (FDL) syntax.
         */
        definition: string;
        /**
         * The description of the flow.
         */
        description: string;
        /**
         * The unique ID of the flow.
         */
        flowId: string;
        /**
         * The ID of the Flow.
         */
        id: string;
        /**
         * The time when the flow was last modified.
         */
        lastModifiedTime: string;
        /**
         * The name of the flow. The name must be unique in an Alibaba Cloud account.
         */
        name: string;
        /**
         * The ARN of the specified RAM role that Serverless Workflow uses to assume the role when Serverless Workflow executes a flow.
         */
        roleArn: string;
        /**
         * The type of the flow. Set the value to `FDL`.
         */
        type: string;
    }

    export interface GetSchedulesSchedule {
        /**
         * The CRON expression of the time-based schedule to be created.
         */
        cronExpression: string;
        /**
         * The description of the time-based schedule to be created.
         */
        description: string;
        /**
         * Specifies whether to enable the time-based schedule you want to create.
         */
        enable: boolean;
        /**
         * The ID of the Schedule.
         */
        id: string;
        /**
         * The time when the time-based schedule was last updated.
         */
        lastModifiedTime: string;
        /**
         * The trigger message of the time-based schedule to be created. It must be in JSON object format.
         */
        payload: string;
        /**
         * The ID of the time-based schedule.
         */
        scheduleId: string;
        /**
         * The name of the time-based schedule to be created.
         */
        scheduleName: string;
    }
}

export namespace ga {
    export interface EndpointGroupEndpointConfiguration {
        /**
         * Indicates whether client IP addresses are reserved. Valid values: `true`: Client IP addresses are reserved, `false`: Client IP addresses are not reserved. Default value is `false`.
         */
        enableClientipPreservation?: boolean;
        /**
         * The IP address or domain name of Endpoint N in the endpoint group.
         */
        endpoint: string;
        /**
         * The type of Endpoint N in the endpoint group. Valid values: `Domain`: a custom domain name, `Ip`: a custom IP address, `PublicIp`: an Alibaba Cloud public IP address, `ECS`: an Alibaba Cloud Elastic Compute Service (ECS) instance, `SLB`: an Alibaba Cloud Server Load Balancer (SLB) instance.
         */
        type: string;
        /**
         * The weight of Endpoint N in the endpoint group. Valid value is 0 to 255.
         */
        weight: number;
    }

    export interface EndpointGroupPortOverrides {
        /**
         * Forwarding port.
         */
        endpointPort?: number;
        /**
         * Listener port.
         */
        listenerPort?: number;
    }

    export interface ForwardingRuleRuleAction {
        /**
         * Forwarding configuration.
         */
        forwardGroupConfig: outputs.ga.ForwardingRuleRuleActionForwardGroupConfig;
        /**
         * Forwarding priority.
         */
        order: number;
        /**
         * Forward action type. Default: forwardgroup.
         */
        ruleActionType: string;
    }

    export interface ForwardingRuleRuleActionForwardGroupConfig {
        /**
         * Terminal node group configuration.
         */
        serverGroupTuples: outputs.ga.ForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface ForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
        /**
         * Terminal node group ID.
         */
        endpointGroupId: string;
    }

    export interface ForwardingRuleRuleCondition {
        /**
         * Domain name configuration information.
         */
        hostConfigs?: outputs.ga.ForwardingRuleRuleConditionHostConfig[];
        /**
         * Path configuration information.
         */
        pathConfig?: outputs.ga.ForwardingRuleRuleConditionPathConfig;
        /**
         * Forwarding condition type. Valid value: `Host`, `Path`.
         */
        ruleConditionType: string;
    }

    export interface ForwardingRuleRuleConditionHostConfig {
        /**
         * The domain name is 3-128 characters long, which can contain letters, numbers, dashes (-) and width period (.), and supports the use of asterisk (*) and width question mark (?) as wildcard characters.
         */
        values?: string[];
    }

    export interface ForwardingRuleRuleConditionPathConfig {
        /**
         * The domain name is 3-128 characters long, which can contain letters, numbers, dashes (-) and width period (.), and supports the use of asterisk (*) and width question mark (?) as wildcard characters.
         */
        values?: string[];
    }

    export interface GetAcceleratorsAccelerator {
        /**
         * The ID of the GA instance to query.
         */
        acceleratorId: string;
        /**
         * The Name of the GA instance.
         */
        acceleratorName: string;
        /**
         * Details of the basic bandwidth package bound to the global acceleration instance.
         */
        basicBandwidthPackages: outputs.ga.GetAcceleratorsAcceleratorBasicBandwidthPackage[];
        /**
         * The cloud enterprise network instance ID bound to the global acceleration instance.
         */
        cenId: string;
        /**
         * Details of the cross-domain acceleration package bound to the global acceleration instance.
         */
        crossDomainBandwidthPackages: outputs.ga.GetAcceleratorsAcceleratorCrossDomainBandwidthPackage[];
        /**
         * DDoS high-defense instance ID that is unbound from the global acceleration instance.
         */
        ddosId: string;
        /**
         * Descriptive information of the global acceleration instance.
         */
        description: string;
        /**
         * CNAME address assigned by Global Acceleration instance.
         */
        dnsName: string;
        /**
         * Time when the global acceleration instance expires.
         */
        expiredTime: number;
        /**
         * The ID of the Accelerator.
         */
        id: string;
        /**
         * The Payment Typethe GA instance.
         */
        paymentType: string;
        /**
         * CNAME of the Global Acceleration Linkage DDoS High Defense Instance.
         */
        secondDnsName: string;
        /**
         * The instance type of the GA instance.
         */
        spec: string;
        /**
         * The status of the GA instance.
         */
        status: string;
    }

    export interface GetAcceleratorsAcceleratorBasicBandwidthPackage {
        /**
         * Bandwidth value of cross-domain acceleration package.
         */
        bandwidth: number;
        /**
         * The bandwidth type of the basic bandwidth package.
         */
        bandwidthType: string;
        /**
         * Instance ID of the cross-domain acceleration package.
         */
        instanceId: string;
    }

    export interface GetAcceleratorsAcceleratorCrossDomainBandwidthPackage {
        /**
         * Bandwidth value of cross-domain acceleration package.
         */
        bandwidth: number;
        /**
         * Instance ID of the cross-domain acceleration package.
         */
        instanceId: string;
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth value of bandwidth packet.
         */
        bandwidth: number;
        /**
         * The Resource ID of the bandwidth.
         */
        bandwidthPackageId: string;
        /**
         * The name of the bandwidth packet.
         */
        bandwidthPackageName: string;
        /**
         * The bandwidth type of the bandwidth.
         */
        bandwidthType: string;
        /**
         * Interworking area A of cross domain acceleration package. Only international stations support returning this parameter.
         */
        cbnGeographicRegionIda: string;
        /**
         * Interworking area B of cross domain acceleration package. Only international stations support returning this parameter.
         */
        cbnGeographicRegionIdb: string;
        /**
         * The description of bandwidth package.
         */
        description: string;
        /**
         * Bandwidth package expiration time.
         */
        expiredTime: string;
        /**
         * The ID of the Bandwidth Package.
         */
        id: string;
        /**
         * The payment type of the bandwidth.
         */
        paymentType: string;
        /**
         * The status of the bandwidth plan.
         */
        status: string;
        /**
         * The type of the bandwidth packet. China station only supports return to basic.
         */
        type: string;
    }

    export interface GetEndpointGroupsGroup {
        /**
         * The description of the endpoint group.
         */
        description: string;
        /**
         * The endpointConfigurations of the endpoint group.
         */
        endpointConfigurations: outputs.ga.GetEndpointGroupsGroupEndpointConfiguration[];
        /**
         * The endpointGroupId of the Endpoint Group.
         */
        endpointGroupId: string;
        /**
         * The ID of the region where the endpoint group is deployed.
         */
        endpointGroupRegion: string;
        /**
         * The interval between two consecutive health checks. Unit: seconds.
         */
        healthCheckIntervalSeconds: number;
        /**
         * The path specified as the destination of the targets for health checks.
         */
        healthCheckPath: string;
        /**
         * The port that is used for health checks.
         */
        healthCheckPort: number;
        /**
         * The protocol that is used to connect to the targets for health checks.
         */
        healthCheckProtocol: string;
        /**
         * The ID of the Endpoint Group.
         */
        id: string;
        /**
         * The ID of the listener that is associated with the endpoint group.
         */
        listenerId: string;
        /**
         * The name of the endpoint group.
         */
        name: string;
        /**
         * Mapping between listening port and forwarding port of boarding point.
         */
        portOverrides: outputs.ga.GetEndpointGroupsGroupPortOverride[];
        /**
         * The status of the endpoint group.
         */
        status: string;
        /**
         * The number of consecutive failed heath checks that must occur before the endpoint is deemed unhealthy.
         */
        thresholdCount: number;
        /**
         * The weight of the endpoint group when the corresponding listener is associated with multiple endpoint groups.
         */
        trafficPercentage: number;
    }

    export interface GetEndpointGroupsGroupEndpointConfiguration {
        /**
         * Indicates whether client IP addresses are reserved.
         */
        enableClientipPreservation: boolean;
        /**
         * The IP address or domain name of Endpoint N in the endpoint group.
         */
        endpoint: string;
        /**
         * Probe Port.
         */
        probePort: number;
        /**
         * Probe Protocol.
         */
        probeProtocol: string;
        /**
         * The type of Endpoint N in the endpoint group.
         */
        type: string;
        /**
         * The weight of Endpoint N in the endpoint group.
         */
        weight: number;
    }

    export interface GetEndpointGroupsGroupPortOverride {
        /**
         * Forwarding port.
         */
        endpointPort: number;
        /**
         * Listener port.
         */
        listenerPort: number;
    }

    export interface GetForwardingRulesForwardingRule {
        /**
         * Forwarding Policy ID.
         */
        forwardingRuleId: string;
        /**
         * Forwarding policy name. The length of the name is 2-128 English or Chinese characters.
         */
        forwardingRuleName: string;
        /**
         * Forwarding Policy Status.
         */
        forwardingRuleStatus: string;
        id: string;
        /**
         * The ID of the listener.
         */
        listenerId: string;
        /**
         * Forwarding policy priority.
         */
        priority: number;
        /**
         * The IP protocol used by the GA instance.
         * `order` - Forwarding priority.
         * `ruleActionType` - Forward action type.
         * `forwardGroupConfig` - Forwarding configuration.
         * `serverGroupTuples` - Terminal node group configuration.
         * `endpointGroupId` - Terminal node group ID.
         */
        ruleActions: outputs.ga.GetForwardingRulesForwardingRuleRuleAction[];
        /**
         * Forward action.
         * `ruleConditionType` - Forwarding condition type.
         * `pathConfig` - Path configuration information.
         * `values` - The length of the path is 1-128 characters.
         * `hostConfig` - Domain name configuration information.
         * `values` - The domain name is 3-128 characters long.
         */
        ruleConditions: outputs.ga.GetForwardingRulesForwardingRuleRuleCondition[];
    }

    export interface GetForwardingRulesForwardingRuleRuleAction {
        forwardGroupConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleActionForwardGroupConfig[];
        order: number;
        ruleActionType: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleActionForwardGroupConfig {
        serverGroupTuples: outputs.ga.GetForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
    }

    export interface GetForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
        endpointGroupId: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleCondition {
        hostConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleConditionHostConfig[];
        pathConfigs: outputs.ga.GetForwardingRulesForwardingRuleRuleConditionPathConfig[];
        ruleConditionType: string;
    }

    export interface GetForwardingRulesForwardingRuleRuleConditionHostConfig {
        values: string[];
    }

    export interface GetForwardingRulesForwardingRuleRuleConditionPathConfig {
        values: string[];
    }

    export interface GetIpSetsSet {
        /**
         * The ID of an acceleration region.
         */
        accelerateRegionId: string;
        /**
         * The bandwidth allocated to the acceleration region.
         */
        bandwidth: number;
        /**
         * The ID of the Ip Set.
         */
        id: string;
        /**
         * The list of accelerated IP addresses in the acceleration region.
         */
        ipAddressLists: string[];
        /**
         * Accelerated area ID.
         */
        ipSetId: string;
        /**
         * The IP protocol used by the GA instance.
         */
        ipVersion: string;
        /**
         * The status of the acceleration region.
         */
        status: string;
    }

    export interface GetListenersListener {
        /**
         * The certificates of the listener.
         */
        certificates: outputs.ga.GetListenersListenerCertificate[];
        /**
         * The clientAffinity of the listener.
         */
        clientAffinity: string;
        /**
         * The description of the listener.
         */
        description: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The listenerId of the listener.
         */
        listenerId: string;
        /**
         * The name of the listener. The length of the name is 2-128 characters. It starts with uppercase and lowercase letters or Chinese characters. It can contain numbers and underscores and dashes.
         */
        name: string;
        /**
         * The portRanges of the listener.
         */
        portRanges: outputs.ga.GetListenersListenerPortRange[];
        /**
         * Type of network transport protocol monitored.
         */
        protocol: string;
        /**
         * The status of the listener.
         */
        status: string;
    }

    export interface GetListenersListenerCertificate {
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The type of the certificate.
         */
        type: string;
    }

    export interface GetListenersListenerPortRange {
        /**
         * The initial listening port used to receive requests and forward them to terminal nodes.
         */
        fromPort: number;
        /**
         * The end listening port used to receive requests and forward them to terminal nodes.
         */
        toPort: number;
    }

    export interface ListenerCertificate {
        /**
         * The id of the certificate.
         */
        id?: string;
    }

    export interface ListenerPortRange {
        /**
         * The initial listening port used to receive requests and forward them to terminal nodes.
         */
        fromPort: number;
        /**
         * The end listening port used to receive requests and forward them to terminal nodes.
         */
        toPort: number;
    }
}

export namespace gpdb {
    export interface GetInstancesInstance {
        /**
         * Instance availability zone.
         */
        availabilityZone: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        chargeType: string;
        /**
         * The time when you create an instance. The format is YYYY-MM-DDThh:mm:ssZ, such as 2011-05-30T12:11:4Z.
         */
        creationTime: string;
        /**
         * The description of an instance.
         */
        description: string;
        /**
         * Database engine type. Supported option is `gpdb`.
         */
        engine: string;
        /**
         * Database engine version.
         */
        engineVersion: string;
        /**
         * The instance id.
         */
        id: string;
        /**
         * The group type.
         */
        instanceClass: string;
        /**
         * The number of groups.
         */
        instanceGroupCount: string;
        instanceNetworkType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Status of the instance.
         */
        status: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }
}

export namespace hbase {
    export interface GetInstanceTypesCoreInstanceType {
        /**
         * Name of the category, single or cluster.
         */
        category: string;
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * The engine name, `singlehbase`, `hbase`, `hbaseue`, `bds`.
         */
        engine: string;
        /**
         * The hbase instance type of create hbase cluster instance.
         */
        instanceType: string;
        /**
         * Max count of the core instance nodes.
         */
        maxCoreCount: number;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
        /**
         * Name of the storage type.
         */
        storageType: string;
        /**
         * The engine version, singlehbase/hbase=1.1/2.0, bds=1.0.
         */
        version: string;
        /**
         * Name of zone id.
         */
        zone: string;
    }

    export interface GetInstanceTypesMasterInstanceType {
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * The hbase instance type of create hbase cluster instance.
         */
        instanceType: string;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
    }

    export interface GetInstanceTypesType {
        /**
         * Cpu size of the instance type.
         */
        cpuSize: number;
        /**
         * Mem size of the instance type.
         */
        memSize: number;
        /**
         * Name of the instance type.
         */
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The Backup Status of the instance.
         */
        backupStatus: string;
        /**
         * Core node disk size, unit:GB.
         */
        coreDiskSize: number;
        /**
         * Cloud_ssd or cloud_efficiency
         */
        coreDiskType: string;
        /**
         * Like hbase.sn1.large, hbase.sn1.large, hbase.n1.2xlarge and so on.
         */
        coreInstanceType: string;
        /**
         * Same with "coreInstanceQuantity"
         */
        coreNodeCount: number;
        /**
         * The created time of the instance.
         */
        createdTime: string;
        /**
         * The switch of delete protection.
         */
        deletionProtection: boolean;
        /**
         * The engine of the instance.
         */
        engine: string;
        /**
         * The engineVersion of the instance.
         */
        engineVersion: string;
        /**
         * The expire time of the instance.
         */
        expireTime: string;
        /**
         * The ID of the HBase instance.
         */
        id: string;
        /**
         * Like hbase.sn1.large, hbase.sn1.large, hbase.n1.2xlarge and so on.
         */
        masterInstanceType: string;
        /**
         * The node count of master
         */
        masterNodeCount: number;
        /**
         * The name of the HBase instance.
         */
        name: string;
        /**
         * Classic network or VPC.
         */
        networkType: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        payType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
        /**
         * VPC ID the instance belongs to.
         */
        vpcId: string;
        /**
         * VSwitch ID the instance belongs to.
         */
        vswitchId: string;
        /**
         * Zone ID the instance belongs to.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone. Removed from v1.99.0.
         */
        multiZoneIds: string[];
    }

    export interface InstanceSlbConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

    export interface InstanceUiProxyConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }

    export interface InstanceZkConnAddr {
        connAddr: string;
        connAddrPort: string;
        netType: string;
    }
}

export namespace kms {
    export interface GetAliasesAlias {
        /**
         * The unique identifier of the alias.
         */
        aliasName: string;
        /**
         * ID of the alias. The value is same as KMS alias_name.
         */
        id: string;
        /**
         * ID of the key.
         */
        keyId: string;
    }

    export interface GetKeyVersionsVersion {
        /**
         * Date and time when the key version was created (UTC time).
         */
        creationDate: string;
        /**
         * ID of the KMS KeyVersion resource.
         */
        id: string;
        /**
         * The id of kms key.
         */
        keyId: string;
        /**
         * ID of the key version.
         */
        keyVersionId: string;
    }

    export interface GetKeysKey {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the key.
         */
        arn: string;
        automaticRotation: string;
        /**
         * Creation date of key.
         */
        creationDate: string;
        /**
         * The owner of the key.
         * * `automaticRotation` -(Available in 1.123.1+) Specifies whether to enable automatic key rotation.
         * * `keyId` -(Available in 1.123.1+)  ID of the key.
         * * `keySpec` -(Available in 1.123.1+)  The type of the CMK.
         * * `keyUsage` -(Available in 1.123.1+)  The usage of CMK.
         * * `lastRotationDate` -(Available in 1.123.1+)  The date and time the last rotation was performed.
         * * `materialExpireTime` -(Available in 1.123.1+)  The time and date the key material for the CMK expires.
         * * `nextRotationDate` -(Available in 1.123.1+)  The time the next rotation is scheduled for execution.
         * * `origin` -(Available in 1.123.1+)  The source of the key material for the CMK.
         * * `protectionLevel` -(Available in 1.123.1+)  The protection level of the CMK.
         * * `rotationInterval` -(Available in 1.123.1+)  The period of automatic key rotation.
         * * `primaryKeyVersion` -(Available in 1.123.1+)  The ID of the current primary key version of the symmetric CMK.
         */
        creator: string;
        /**
         * Deletion date of key.
         */
        deleteDate: string;
        /**
         * Description of the key.
         */
        description: string;
        /**
         * ID of the key.
         */
        id: string;
        keyId: string;
        keySpec: string;
        keyUsage: string;
        lastRotationDate: string;
        materialExpireTime: string;
        nextRotationDate: string;
        origin: string;
        primaryKeyVersion: string;
        protectionLevel: string;
        rotationInterval: string;
        /**
         * Filter the results by status of the KMS keys. Valid values: `Enabled`, `Disabled`, `PendingDeletion`.
         */
        status: string;
    }

    export interface GetSecretVersionsVersion {
        /**
         * The secret value. Secrets Manager decrypts the stored secret value in ciphertext and returns it. (Returned when `enableDetails` is true).
         */
        secretData: string;
        /**
         * The type of the secret value. (Returned when `enableDetails` is true).
         */
        secretDataType: string;
        /**
         * The name of the secret.
         */
        secretName: string;
        /**
         * The version number of the secret value.
         */
        versionId: string;
        /**
         * Stage labels that mark the secret version.
         */
        versionStages: string[];
    }

    export interface GetSecretsSecret {
        /**
         * (Available in 1.124.0+) A mapping of tags to assign to the resource.
         */
        arn: string;
        /**
         * (Available in 1.124.0+)  The description of the secret.
         */
        description: string;
        /**
         * (Available in 1.124.0+)  The ID of the KMS CMK that is used to encrypt the secret value.
         */
        encryptionKeyId: string;
        /**
         * ID of the Kms Secret. The value is same as KMS secret_name.
         */
        id: string;
        /**
         * Schedule deletion time.
         */
        plannedDeleteTime: string;
        /**
         * (Available in 1.124.0+)  The value of the secret that you want to create.
         */
        secretData: string;
        /**
         * (Available in 1.124.0+)  The type of the secret data value.
         */
        secretDataType: string;
        /**
         * Name of the KMS Secret.
         */
        secretName: string;
        /**
         * (Available in 1.124.0+)  The type of the secret.
         */
        secretType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * (Available in 1.124.0+)  The version number of the initial version.
         */
        versionId: string;
        /**
         * (Available in 1.124.0+)  The stage labels that mark the new secret version.
         */
        versionStages: string[];
    }
}

export namespace kvstore {
    export interface GetAccountsAccount {
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * The privilege of account access database.
         */
        accountPrivilege: string;
        /**
         * Privilege type of account.
         */
        accountType: string;
        /**
         * The description of account.
         */
        description: string;
        /**
         * The ID of the Account.
         */
        id: string;
        /**
         * The Id of instance in which account belongs.
         */
        instanceId: string;
        /**
         * The status of account.
         */
        status: string;
    }

    export interface GetConnectionsConnection {
        /**
         * The connection string of the instance.
         */
        connectionString: string;
        /**
         * The network type of the instance.
         */
        dbInstanceNetType: string;
        /**
         * The expiration time of the classic network address.
         */
        expiredTime: string;
        id: string;
        instanceId: string;
        /**
         * The IP address of the instance.
         */
        ipAddress: string;
        /**
         * The port number of the instance.
         */
        port: string;
        /**
         * The remaining validity period of the endpoint of the classic network.
         */
        upgradeable: string;
        /**
         * The ID of the VPC where the instance is deployed.
         */
        vpcId: string;
        /**
         * The ID of the instance. It is returned only when the value of the DBInstanceNetType parameter is 2 (indicating VPC).
         */
        vpcInstanceId: string;
        /**
         * The ID of the VSwitch.
         */
        vswitchId: string;
    }

    export interface GetInstanceClassesClass {
        /**
         * KVStore available instance class.
         */
        instanceClass: string;
        price: string;
    }

    export interface GetInstanceEnginesInstanceEngine {
        /**
         * Database type. Options are `Redis`, `Memcache`. Default to `Redis`.
         */
        engine: string;
        /**
         * Database version required by the user. Value options of Redis can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/60873.htm) `EngineVersion`. Value of Memcache should be empty.
         */
        engineVersion: string;
        /**
         * The Zone to launch the KVStore instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstance {
        /**
         * The type of the architecture. Valid values: `cluster`, `standard` and `SplitRW`.
         */
        architectureType: string;
        autoRenew: boolean;
        autoRenewPeriod: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `zoneId` instead.
         */
        availabilityZone: string;
        /**
         * Instance bandwidth limit. Unit: Mbit/s.
         */
        bandwidth: number;
        /**
         * Capacity of the applied ApsaraDB for the instance. Unit: MB.
         */
        capacity: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `paymentType` instead.
         */
        chargeType: string;
        /**
         * The parameter configuration of the instance.
         */
        config: {[key: string]: any};
        /**
         * Instance connection domain (only Intranet access supported).
         */
        connectionDomain: string;
        /**
         * The connection mode of the instance.
         */
        connectionMode: string;
        /**
         * IIt has been deprecated from provider version 1.101.0 and `maxConnections` instead.
         */
        connections: number;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * The ID of the instance.
         */
        dbInstanceId: string;
        /**
         * The name of the instance.
         */
        dbInstanceName: string;
        /**
         * The time when the instance was destroyed.
         */
        destroyTime: string;
        /**
         * Expiration time. Pay-As-You-Go instances are never expire.
         */
        endTime: string;
        /**
         * The engine version. Valid values: `2.8`, `4.0`, `5.0`, `6.0`.
         */
        engineVersion: string;
        /**
         * It has been deprecated from provider version 1.101.0 and `endTime` instead.
         */
        expireTime: string;
        /**
         * Indicates whether there was an order of renewal with configuration change that had not taken effect.
         */
        hasRenewChangeOrder: boolean;
        /**
         * The ID of the instance.
         */
        id: string;
        /**
         * Type of the applied ApsaraDB for Redis instance. For more information, see [Instance type table](https://www.alibabacloud.com/help/doc-detail/61135.htm).
         */
        instanceClass: string;
        instanceReleaseProtection: boolean;
        /**
         * The engine type of the KVStore DBInstance. Options are `Memcache`, and `Redis`. If no value is specified, all types are returned.
         */
        instanceType: string;
        /**
         * Indicates whether the instance is managed by Relational Database Service (RDS).
         */
        isRds: boolean;
        maintainEndTime: string;
        maintainStartTime: string;
        /**
         * Instance connection quantity limit. Unit: count.
         */
        maxConnections: number;
        /**
         * It has been deprecated from provider version 1.101.0 and `dbInstanceName` instead.
         */
        name: string;
        /**
         * The type of the network. Valid values: `CLASSIC`, `VPC`.
         */
        networkType: string;
        /**
         * The node type of the instance.
         */
        nodeType: string;
        /**
         * The type of the package.
         */
        packageType: string;
        /**
         * The payment type. Valid values: `PostPaid`, `PrePaid`.
         */
        paymentType: string;
        /**
         * The service port of the instance.
         */
        port: number;
        /**
         * Private IP address of the instance.
         */
        privateIp: string;
        /**
         * The queries per second (QPS) supported by the instance.
         */
        qps: number;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * The logical ID of the replica instance.
         */
        replacateId: string;
        /**
         * The ID of the resource group.
         */
        resourceGroupId: string;
        /**
         * The name of the instance.
         */
        searchKey: string;
        securityGroupId: string;
        securityIpGroupAttribute: string;
        securityIpGroupName: string;
        securityIps: string[];
        sslEnable: string;
        /**
         * The status of the KVStore DBInstance. Valid values: `Changing`, `CleaningUpExpiredData`, `Creating`, `Flushing`, `HASwitching`, `Inactive`, `MajorVersionUpgrading`, `Migrating`, `NetworkModifying`, `Normal`, `Rebooting`, `SSLModifying`, `Transforming`, `ZoneMigrating`.
         */
        status: string;
        /**
         * Query the instance bound to the tag. The format of the incoming value is `json` string, including `TagKey` and `TagValue`. `TagKey` cannot be null, and `TagValue` can be empty. Format example `{"key1":"value1"}`.
         */
        tags: {[key: string]: any};
        /**
         * The username of the instance.
         */
        userName: string;
        vpcAuthMode: string;
        /**
         * Connection port of the instance.
         */
        vpcCloudInstanceId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Used to retrieve instances belong to specified `vswitch` resources.
         */
        vswitchId: string;
        /**
         * The ID of the zone.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceParameter {
        name: string;
        value: string;
    }
}

export namespace log {
    export interface AlertNotificationList {
        /**
         * Notice content of alarm.
         */
        content: string;
        /**
         * Email address list.
         */
        emailLists?: string[];
        /**
         * SMS sending mobile number.
         */
        mobileLists?: string[];
        /**
         * Request address.
         */
        serviceUri?: string;
        /**
         * Notification type. support Email, SMS, DingTalk, MessageCenter.
         */
        type: string;
    }

    export interface AlertQueryList {
        /**
         * chart title
         */
        chartTitle: string;
        /**
         * end time. example: 20s.
         */
        end: string;
        /**
         * Query logstore
         */
        logstore: string;
        /**
         * query corresponding to chart. example: * AND aliyun.
         */
        query: string;
        /**
         * begin time. example: -60s.
         */
        start: string;
        /**
         * default Custom. No need to configure this parameter.
         */
        timeSpanType?: string;
    }

    export interface EtlEtlSink {
        /**
         * Delivery target logstore access key id.
         */
        accessKeyId?: string;
        /**
         * Delivery target logstore access key secret.
         */
        accessKeySecret?: string;
        /**
         * Delivery target logstore region.
         */
        endpoint: string;
        /**
         * An KMS encrypts access key id used to a log etl job. If the `accessKeyId` is filled in, this field will be ignored.
         */
        kmsEncryptedAccessKeyId?: string;
        /**
         * An KMS encrypts access key secret used to a log etl job. If the `accessKeySecret` is filled in, this field will be ignored.
         */
        kmsEncryptedAccessKeySecret?: string;
        /**
         * Delivery target logstore.
         */
        logstore: string;
        /**
         * Delivery target name.
         */
        name: string;
        /**
         * The project where the target logstore is delivered.
         */
        project: string;
        /**
         * Sts role info under delivery target logstore. `roleArn` and `(access_key_id, access_key_secret)` fill in at most one. If you do not fill in both, then you must fill in `(kms_encrypted_access_key_id, kms_encrypted_access_key_secret, kms_encryption_access_key_id_context, kms_encryption_access_key_secret_context)` to use KMS to get the key pair.
         */
        roleArn?: string;
        /**
         * ETL sinks type, the default value is AliyunLOG.
         */
        type?: string;
    }

    export interface OssShipperParquetConfig {
        name: string;
        type: string;
    }

    export interface StoreEncryptConf {
        /**
         * enable encryption. Default `false`
         */
        enable?: boolean;
        /**
         * Supported encryption type, only supports `default(AES)`,` m4`
         */
        encryptType?: string;
        /**
         * User bring your own key (BYOK) encryption.[Refer to details](https://www.alibabacloud.com/help/zh/doc-detail/187853.htm?spm=a2c63.p38356.b99.673.cafa2b38qBskFV)
         */
        userCmkInfo?: outputs.log.StoreEncryptConfUserCmkInfo;
    }

    export interface StoreEncryptConfUserCmkInfo {
        /**
         * role arn
         */
        arn: string;
        /**
         * User master key id
         */
        cmkKeyId: string;
        /**
         * Region id where the  user master key id is located
         */
        regionId: string;
    }

    export interface StoreIndexFieldSearch {
        /**
         * The alias of one field.
         */
        alias?: string;
        /**
         * Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        caseSensitive?: boolean;
        /**
         * Whether to enable field analytics. Default to true.
         */
        enableAnalytics?: boolean;
        /**
         * Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        includeChinese?: boolean;
        /**
         * Use nested index when type is json
         */
        jsonKeys?: outputs.log.StoreIndexFieldSearchJsonKey[];
        /**
         * When using the jsonKeys field, this field is required.
         */
        name: string;
        /**
         * The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
         */
        token?: string;
        /**
         * The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
         */
        type?: string;
    }

    export interface StoreIndexFieldSearchJsonKey {
        /**
         * The alias of one field.
         */
        alias?: string;
        /**
         * Whether to enable statistics. default to true.
         */
        docValue?: boolean;
        /**
         * When using the jsonKeys field, this field is required.
         */
        name: string;
        /**
         * The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
         */
        type?: string;
    }

    export interface StoreIndexFullText {
        /**
         * Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        caseSensitive?: boolean;
        /**
         * Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
         */
        includeChinese?: boolean;
        /**
         * The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
         */
        token?: string;
    }

    export interface StoreShard {
        beginKey: string;
        endKey: string;
        /**
         * The ID of the log project. It formats of `<project>:<name>`.
         */
        id: number;
        status: string;
    }
}

export namespace marketplace {
    export interface GetProductProduct {
        /**
         * The code of the product.
         */
        code: string;
        /**
         * The description of the product.
         */
        description: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * A list of one element containing sku attributes of an object. Each element contains the following attributes:
         */
        skuses: outputs.marketplace.GetProductProductSkus[];
    }

    export interface GetProductProductSkus {
        /**
         * The list of custom ECS images, Each element contains the following attributes:
         */
        images: outputs.marketplace.GetProductProductSkusImage[];
        /**
         * The list of package version details of this product sku, Each element contains the following attributes:
         */
        packageVersions: outputs.marketplace.GetProductProductSkusPackageVersion[];
        /**
         * The sku code of this product sku.
         */
        skuCode: string;
        /**
         * The sku name of this product sku.
         */
        skuName: string;
    }

    export interface GetProductProductSkusImage {
        /**
         * The Ecs image id.
         */
        imageId: string;
        /**
         * The Ecs image display name.
         */
        imageName: string;
        /**
         * The Ecs image region.
         */
        regionId: string;
    }

    export interface GetProductProductSkusPackageVersion {
        /**
         * The package name of this product sku package.
         */
        packageName: string;
        /**
         * The package version of this product sku package. Currently, the API products can return package_version, but others can not for ensure.
         */
        packageVersion: string;
    }

    export interface GetProductsProduct {
        /**
         * The Category ID of products. For more information, see [DescribeProducts](https://help.aliyun.com/document_detail/89834.htm).
         */
        categoryId: number;
        /**
         * The code of the product.
         */
        code: string;
        /**
         * The delivery date of the product.
         */
        deliveryDate: string;
        /**
         * The delivery way of the product.
         */
        deliveryWay: string;
        /**
         * The image URL of the product.
         */
        imageUrl: string;
        /**
         * The name of the product.
         */
        name: string;
        /**
         * The operation system of the product.
         */
        operationSystem: string;
        /**
         * The rating information of the product.
         */
        score: string;
        /**
         * The short description of the product.
         */
        shortDescription: string;
        /**
         * The suggested price of the product.
         */
        suggestedPrice: string;
        /**
         * The supplier id of the product.
         */
        supplierId: number;
        /**
         * The supplier name of the product.
         */
        supplierName: string;
        /**
         * The tags of the product.
         */
        tags: string;
        /**
         * The detail page URL of the product.
         */
        targetUrl: string;
        /**
         * The warranty date of the product.
         */
        warrantyDate: string;
    }
}

export namespace mns {
    export interface GetQueuesQueue {
        /**
         * This attribute defines the length of time, in seconds, after which every message sent to the queue is dequeued.
         */
        delaySeconds: number;
        /**
         * The id of the queue, The value is set to `name`.
         */
        id: string;
        /**
         * This indicates the maximum length, in bytes, of any message body sent to the queue.
         */
        maximumMessageSize: number;
        /**
         * Messages are deleted from the queue after a specified length of time, whether they have been activated or not. This attribute defines the viability period, in seconds, for every message in the queue.
         */
        messageRetentionPeriod: number;
        /**
         * The name of the queue
         */
        name: string;
        /**
         * Long polling is measured in seconds. When this attribute is set to 0, long polling is disabled. When it is not set to 0, long polling is enabled and message dequeue requests will be processed only when valid messages are received or when long polling times out.
         */
        pollingWaitSeconds: number;
        /**
         * Dequeued messages change from active (visible) status to inactive (invisible) status. This attribute defines the length of time, in seconds, that messages remain invisible. Messages return to active status after the set period.
         */
        visibilityTimeouts: number;
    }

    export interface GetTopicSubscriptionsSubscription {
        /**
         * Describe the terminal address of the message received in this subscription.
         * * `filterTag`- A string to filter resulting messages of the topic by their message tag.
         */
        endpoint: string;
        filterTag: string;
        /**
         * The ID of the topic subscription. The value is set to `name`.
         */
        id: string;
        /**
         * The name of the subscription.
         * * `topicName`- The topic which The subscription belongs to was named with the name.
         */
        name: string;
        /**
         * The NotifyContentFormat attribute of Subscription. This attribute specifies the content format of the messages pushed to users.
         */
        notifyContentFormat: string;
        /**
         * The NotifyStrategy attribute of Subscription. This attribute specifies the retry strategy when message sending fails.
         */
        notifyStrategy: string;
        /**
         * Two topics on a single account in the same region cannot have the same name. A topic name must start with an English letter or a digit, and can contain English letters, digits, and hyphens, with the length not exceeding 256 characters.
         */
        topicName: string;
    }

    export interface GetTopicsTopic {
        /**
         * The id of the topic. The value is set to `name`.
         */
        id: string;
        /**
         * Whether to enable logging.
         */
        loggingEnabled: boolean;
        /**
         * This indicates the maximum length, in bytes, of any message body sent to the topic.
         */
        maximumMessageSize: number;
        /**
         * The name of the topic.
         */
        name: string;
    }
}

export namespace mongodb {
    export interface GetInstancesInstance {
        /**
         * Instance availability zone.
         */
        availabilityZone: string;
        /**
         * Billing method. Value options are `PostPaid` for  Pay-As-You-Go and `PrePaid` for yearly or monthly subscription.
         */
        chargeType: string;
        /**
         * Creation time of the instance in RFC3339 format.
         */
        creationTime: string;
        /**
         * Database engine type. Supported option is `MongoDB`.
         */
        engine: string;
        /**
         * Database engine version.
         */
        engineVersion: string;
        /**
         * Expiration time in RFC3339 format. Pay-As-You-Go instances are never expire.
         */
        expirationTime: string;
        /**
         * The ID of the MongoDB instance.
         */
        id: string;
        /**
         * Sizing of the instance to be queried.
         */
        instanceClass: string;
        /**
         * Type of the instance to be queried. If it is set to `sharding`, the sharded cluster instances are listed. If it is set to `replicate`, replica set instances are listed. Default value `replicate`.
         */
        instanceType: string;
        /**
         * Lock status of the instance.
         */
        lockMode: string;
        /**
         * Array composed of Mongos.
         */
        mongos: outputs.mongodb.GetInstancesInstanceMongo[];
        /**
         * The name of the MongoDB instance.
         */
        name: string;
        /**
         * Classic network or VPC.
         */
        networkType: string;
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * Replication factor corresponds to number of nodes. Optional values are `1` for single node and `3` for three nodes replica set.
         */
        replication: string;
        /**
         * Array composed of shards.
         */
        shards: outputs.mongodb.GetInstancesInstanceShard[];
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * Shard disk.
         */
        storage: number;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetInstancesInstanceMongo {
        /**
         * Shard instance specification.
         */
        class: string;
        /**
         * Shard instance description.
         */
        description: string;
        /**
         * Shard instance ID.
         */
        nodeId: string;
    }

    export interface GetInstancesInstanceShard {
        /**
         * Shard instance specification.
         */
        class: string;
        /**
         * Shard instance description.
         */
        description: string;
        /**
         * Shard instance ID.
         */
        nodeId: string;
        /**
         * Shard disk.
         */
        storage: number;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface ShardingInstanceMongoList {
        /**
         * Mongo node connection string
         */
        connectString: string;
        /**
         * -(Required) Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The ID of the shard-node.
         */
        nodeId: string;
        /**
         * Mongo node port
         * * `shardList`
         */
        port: number;
    }

    export interface ShardingInstanceShardList {
        /**
         * -(Required) Node specification. see [Instance specifications](https://www.alibabacloud.com/help/doc-detail/57141.htm).
         */
        nodeClass: string;
        /**
         * The ID of the shard-node.
         */
        nodeId: string;
        /**
         * - Custom storage space; value range: [10, 1,000]
         * - 10-GB increments. Unit: GB.
         */
        nodeStorage: number;
    }
}

export namespace mse {
    export interface GetClustersCluster {
        /**
         * The id of acl.
         */
        aclId: string;
        /**
         * The version of app.
         */
        appVersion: string;
        /**
         * ID of the MSE Cluster.
         */
        clusterId: string;
        /**
         * ID of the OOS Executions.
         */
        clusterName: string;
        /**
         * The type of MSE Cluster.
         */
        clusterType: string;
        /**
         * The num of cpu.
         */
        cpu: number;
        /**
         * The health status of MSE Cluster.
         */
        healthStatus: string;
        /**
         * ID of the MSE Cluster.
         */
        id: string;
        /**
         * Time-consuming to create.
         */
        initCostTime: number;
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * ID of the MSE Cluster.
         */
        instanceId: string;
        /**
         * The list of instances.
         */
        instanceModels: outputs.mse.GetClustersClusterInstanceModel[];
        /**
         * The address of public network.
         */
        internetAddress: string;
        /**
         * The domain of public network.
         */
        internetDomain: string;
        /**
         * The port of public network.
         */
        internetPort: string;
        /**
         * The address of private network.
         */
        intranetAddress: string;
        /**
         * The domain of private network.
         */
        intranetDomain: string;
        /**
         * The port of private network.
         */
        intranetPort: string;
        /**
         * The memory size.
         */
        memoryCapacity: number;
        /**
         * The type of payment.
         */
        payInfo: string;
        /**
         * The public network bandwidth.
         */
        pubNetworkFlow: string;
        /**
         * The status of MSE Cluster. Valid: `DESTROY_FAILED`, `DESTROY_ING`, `DESTROY_SUCCESS`, `INIT_FAILED`, `INIT_ING`, `INIT_SUCCESS`, `INIT_TIME_OUT`, `RESTART_FAILED`, `RESTART_ING`, `RESTART_SUCCESS`, `SCALE_FAILED`, `SCALE_ING`, `SCALE_SUCCESS`
         */
        status: string;
    }

    export interface GetClustersClusterInstanceModel {
        /**
         * The health status of MSE Cluster.
         */
        healthStatus: string;
        instanceType: string;
        internetIp: string;
        ip: string;
        podName: string;
        role: string;
        singleTunnelVip: string;
        vip: string;
    }
}

export namespace nas {
    export interface GetAccessGroupsGroup {
        /**
         * The name of access group.
         */
        accessGroupName: string;
        /**
         * Filter results by a specific AccessGroupType.
         */
        accessGroupType: string;
        /**
         * Filter results by a specific Description.
         */
        description: string;
        /**
         * This ID of this AccessGroup. It is formatted to ``<access_group_id>:<file_system_type>``. Before version 1.95.0, the value is `accessGroupName`.
         */
        id: string;
        /**
         * MountTargetCount block of the AccessGroup
         */
        mountTargetCount: number;
        /**
         * RuleCount of the AccessGroup.
         */
        ruleCount: number;
        /**
         * Field `type` has been deprecated from version 1.95.0. Use `accessGroupType` instead.
         */
        type: string;
    }

    export interface GetAccessRulesRule {
        /**
         * AccessRuleId of the AccessRule.
         */
        accessRuleId: string;
        /**
         * Priority of the AccessRule.
         */
        priority: number;
        /**
         * Filter results by a specific RWAccess.
         */
        rwAccess: string;
        /**
         * Filter results by a specific SourceCidrIp.
         */
        sourceCidrIp: string;
        /**
         * Filter results by a specific UserAccess.
         */
        userAccess: string;
    }

    export interface GetFileSystemsSystem {
        /**
         * Time of creation.
         */
        createTime: string;
        /**
         * Destription of the FileSystem.
         */
        description: string;
        /**
         * (Optional, Available in v1.121.2+) Whether the file system is encrypted.
         * Valid values:
         * 0: The file system is not encrypted.
         * 1: The file system is encrypted with a managed secret key.
         */
        encryptType: number;
        /**
         * ID of the FileSystem.
         */
        id: string;
        /**
         * MeteredSize of the FileSystem.
         */
        meteredSize: number;
        /**
         * Filter results by a specific ProtocolType. Valid values: `NFS` and `SMB`.
         */
        protocolType: string;
        /**
         * ID of the region where the FileSystem is located.
         */
        regionId: string;
        /**
         * Filter results by a specific StorageType. Valid values: `Capacity` and `Performance`.
         */
        storageType: string;
    }

    export interface GetMountTargetsTarget {
        /**
         * Filter results by a specific AccessGroupName.
         */
        accessGroupName: string;
        /**
         * ID of the MountTargetDomain.
         */
        id: string;
        /**
         * Field `mountTargetDomain` has been deprecated from provider version 1.53.0. New field `ids` replaces it.
         */
        mountTargetDomain: string;
        /**
         * Filter results by a specific NetworkType.
         */
        networkType: string;
        /**
         * Filter results by the status of mount target. Valid values: `Active`, `Inactive` and `Pending`.
         */
        status: string;
        /**
         * Field `type` has been deprecated from provider version 1.95.0. New field `networkType` replaces it.
         */
        type: string;
        /**
         * Filter results by a specific VpcId.
         */
        vpcId: string;
        /**
         * Filter results by a specific VSwitchId.
         */
        vswitchId: string;
    }
}

export namespace oos {
    export interface GetExecutionsExecution {
        /**
         * The category of template. Valid: `AlarmTrigger`, `EventTrigger`, `Other` and `TimerTrigger`.
         */
        category: string;
        /**
         * The counters of OOS Execution.
         */
        counters: string;
        /**
         * The time when the execution was created.
         */
        createDate: string;
        /**
         * The time when the execution was ended.
         */
        endDate: string;
        /**
         * The user who execute the template.
         */
        executedBy: string;
        /**
         * ID of the OOS Executions.
         */
        executionId: string;
        /**
         * ID of the OOS Executions.
         */
        id: string;
        /**
         * Whether to include subtasks.
         */
        isParent: boolean;
        /**
         * The mode of OOS Execution. Valid: `Automatic`, `Debug`.
         */
        mode: string;
        /**
         * The outputs of OOS Executions.
         */
        outputs: string;
        /**
         * The parameters required by the template
         */
        parameters: string;
        /**
         * The id of parent OOS Execution.
         */
        parentExecutionId: string;
        /**
         * The role that executes the current template.
         */
        ramRole: string;
        /**
         * The time when the template was started.
         */
        startDate: string;
        /**
         * The Status of OOS Execution. Valid: `Cancelled`, `Failed`, `Queued`, `Running`, `Started`, `Success`, `Waiting`.
         */
        status: string;
        /**
         * The message of status.
         */
        statusMessage: string;
        /**
         * The reason of status.
         */
        statusReason: string;
        /**
         * The id of execution template.
         */
        templateId: string;
        /**
         * The name of execution template.
         */
        templateName: string;
        /**
         * The version of execution template.
         */
        templateVersion: string;
        /**
         * The time when the template was updated.
         */
        updateDate: string;
    }

    export interface GetTemplatesTemplate {
        /**
         * The category of template.
         */
        category: string;
        /**
         * The creator of the template.
         */
        createdBy: string;
        /**
         * The template whose creation time is less than or equal to the specified time. The format is: YYYY-MM-DDThh:mm::ssZ.
         */
        createdDate: string;
        /**
         * Description of the OOS Template.
         */
        description: string;
        /**
         * Is it triggered successfully.
         */
        hasTrigger: boolean;
        /**
         * ID of the OOS Template. The value is same as template_name.
         */
        id: string;
        /**
         * The sharing type of the template. Valid values: `Private`, `Public`.
         */
        shareType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * The format of the template. Valid values: `JSON`, `YAML`.
         */
        templateFormat: string;
        /**
         * ID of the OOS Template resource.
         */
        templateId: string;
        /**
         * Name of the OOS Template.
         */
        templateName: string;
        /**
         * The type of OOS Template.
         */
        templateType: string;
        /**
         * Version of the OOS Template.
         */
        templateVersion: string;
        /**
         * The user who updated the template.
         */
        updatedBy: string;
        /**
         * The time when the template was updated.
         */
        updatedDate: string;
    }
}

export namespace oss {
    export interface BucketCorsRule {
        /**
         * Specifies which headers are allowed.
         */
        allowedHeaders?: string[];
        /**
         * Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
         */
        allowedMethods: string[];
        /**
         * Specifies which origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specifies expose header in the response.
         */
        exposeHeaders?: string[];
        /**
         * Specifies time in seconds that browser can cache the response for a preflight request.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        /**
         * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed (documented below).
         */
        abortMultipartUploads?: outputs.oss.BucketLifecycleRuleAbortMultipartUpload[];
        /**
         * Specifies the accelerate status of a bucket.
         */
        enabled: boolean;
        /**
         * Specifies a period in the object's expire (documented below).
         */
        expirations?: outputs.oss.BucketLifecycleRuleExpiration[];
        /**
         * Unique identifier for the rule. If omitted, OSS bucket will assign a unique name.
         */
        id: string;
        /**
         * Specifies when noncurrent object versions expire (documented below).
         */
        noncurrentVersionExpirations?: outputs.oss.BucketLifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies when noncurrent object versions transitions (documented below).
         */
        noncurrentVersionTransitions?: outputs.oss.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies. Default value is null, the rule applies to all objects in a bucket.
         */
        prefix?: string;
        /**
         * Specifies the time when an object is converted to the IA or archive storage class during a valid life cycle. (documented below).
         */
        transitions?: outputs.oss.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortMultipartUpload {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the date after which you want the corresponding action to take effect. The value obeys ISO8601 format like `2017-03-09`.
         */
        date?: string;
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days: number;
        /**
         * Specifies the storage class that objects that conform to the rule are converted into. The storage class of the objects in a bucket of the IA storage class can be converted into Archive but cannot be converted into Standard. Values: `IA`, `Archive`.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
         */
        createdBeforeDate?: string;
        /**
         * Specifies the number of days noncurrent object versions transition.
         */
        days?: number;
        /**
         * Specifies the storage class that objects that conform to the rule are converted into. The storage class of the objects in a bucket of the IA storage class can be converted into Archive but cannot be converted into Standard. Values: `IA`, `Archive`.
         */
        storageClass?: string;
    }

    export interface BucketLogging {
        /**
         * The name of the bucket that will receive the log objects.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketRefererConfig {
        /**
         * Allows referer to be empty. Defaults false.
         */
        allowEmpty: boolean;
        /**
         * The list of referer.
         */
        referers: string[];
    }

    export interface BucketServerSideEncryptionRule {
        /**
         * The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
         */
        kmsMasterKeyId?: string;
        /**
         * The server-side encryption algorithm to use. Possible values: `AES256` and `KMS`.
         */
        sseAlgorithm: string;
    }

    export interface BucketTransferAcceleration {
        /**
         * Specifies the accelerate status of a bucket.
         */
        enabled: boolean;
    }

    export interface BucketVersioning {
        /**
         * Specifies the versioning state of a bucket. Valid values: `Enabled` and `Suspended`.
         */
        status: string;
    }

    export interface BucketWebsite {
        /**
         * An absolute path to the document to return in case of a 4XX error.
         */
        errorDocument?: string;
        /**
         * Alicloud OSS returns this index document when requests are made to the root domain or any of the subfolders.
         */
        indexDocument: string;
    }

    export interface GetBucketObjectsObject {
        /**
         * Object access control list. Possible values: `default`, `private`, `public-read` and `public-read-write`.
         */
        acl: string;
        /**
         * Caching behavior along the request/reply chain. Read [RFC2616 Cache-Control](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        cacheControl: string;
        /**
         * Presentational information for the object. Read [RFC2616 Content-Disposition](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        contentDisposition: string;
        /**
         * Content encodings that have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read [RFC2616 Content-Encoding](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        contentEncoding: string;
        /**
         * Size of the object in bytes.
         */
        contentLength: string;
        /**
         * MD5 value of the content. Read [MD5](https://www.alibabacloud.com/help/doc-detail/31978.htm) for computing method.
         */
        contentMd5: string;
        /**
         * Standard MIME type describing the format of the object data, e.g. "application/octet-stream".
         */
        contentType: string;
        /**
         * ETag generated for the object (MD5 sum of the object content).
         */
        etag: string;
        /**
         * Expiration date for the the request/response. Read [RFC2616 Expires](https://www.ietf.org/rfc/rfc2616.txt) for further details.
         */
        expires: string;
        /**
         * Object key.
         */
        key: string;
        /**
         * Last modification time of the object.
         */
        lastModificationTime: string;
        /**
         * Server-side encryption of the object in OSS. It can be empty or `AES256`.
         */
        serverSideEncryption: string;
        /**
         * If present, specifies the ID of the Key Management Service(KMS) master encryption key that was used for the object.
         */
        sseKmsKeyId: string;
        /**
         * Object storage type. Possible values: `Standard`, `IA` and `Archive`.
         */
        storageClass: string;
    }

    export interface GetBucketsBucket {
        /**
         * Bucket access control list. Possible values: `private`, `public-read` and `public-read-write`.
         */
        acl: string;
        /**
         * A list of CORS rule configurations. Each element contains the following attributes:
         */
        corsRules: outputs.oss.GetBucketsBucketCorsRule[];
        /**
         * Bucket creation date.
         */
        creationDate: string;
        /**
         * Internet domain name for accessing the bucket from outside.
         */
        extranetEndpoint: string;
        /**
         * Intranet domain name for accessing the bucket from an ECS instance in the same region.
         */
        intranetEndpoint: string;
        /**
         * A list CORS of lifecycle configurations. When Lifecycle is enabled, OSS automatically deletes the objects or transitions the objects (to another storage class) corresponding the lifecycle rules on a regular basis. Each element contains the following attributes:
         */
        lifecycleRules: outputs.oss.GetBucketsBucketLifecycleRule[];
        /**
         * Region of the data center where the bucket is located.
         */
        location: string;
        /**
         * A list of one element containing configuration parameters used for storing access log information. It contains the following attributes:
         */
        logging: outputs.oss.GetBucketsBucketLogging;
        /**
         * Bucket name.
         */
        name: string;
        /**
         * Bucket owner.
         */
        owner: string;
        policy?: string;
        /**
         * Redundancy type. Possible values: `LRS`, and `ZRS`.
         */
        redundancyType: string;
        /**
         * A list of one element containing referer configuration. It contains the following attributes:
         */
        refererConfig: outputs.oss.GetBucketsBucketRefererConfig;
        /**
         * A configuration of default encryption for a bucket. It contains the following attributes:
         */
        serverSideEncryptionRule: outputs.oss.GetBucketsBucketServerSideEncryptionRule;
        /**
         * Object storage type. Possible values: `Standard`, `IA` and `Archive`.
         */
        storageClass: string;
        /**
         * A mapping of tags.
         */
        tags: {[key: string]: any};
        /**
         * If present , the versioning state has been set on the bucket. It contains the following attribute.
         */
        versioning: outputs.oss.GetBucketsBucketVersioning;
        /**
         * A list of one element containing configuration parameters used when the bucket is used as a website. It contains the following attributes:
         */
        website: outputs.oss.GetBucketsBucketWebsite;
    }

    export interface GetBucketsBucketCorsRule {
        /**
         * Control whether the headers specified by Access-Control-Request-Headers in the OPTIONS prefetch command are allowed. Each header specified by Access-Control-Request-Headers must match a value in AllowedHeader. Each rule allows up to one wildcard â€œ*â€ .
         */
        allowedHeaders: string[];
        /**
         * Specify the allowed methods for cross-domain requests. Possible values: `GET`, `PUT`, `DELETE`, `POST` and `HEAD`.
         */
        allowedMethods: string[];
        /**
         * The origins allowed for cross-domain requests. Multiple elements can be used to specify multiple allowed origins. Each rule allows up to one wildcard "\*". If "\*" is specified, cross-domain requests of all origins are allowed.
         */
        allowedOrigins: string[];
        /**
         * Specify the response headers allowing users to access from an application (for example, a Javascript XMLHttpRequest object). The wildcard "\*" is not allowed.
         */
        exposeHeaders: string[];
        /**
         * Specify the cache time for the returned result of a browser prefetch (OPTIONS) request to a specific resource.
         */
        maxAgeSeconds: number;
    }

    export interface GetBucketsBucketLifecycleRule {
        /**
         * Indicate whether the rule is enabled or not.
         */
        enabled: boolean;
        /**
         * A list of one element containing expiration attributes of an object. It contains the following attributes:
         */
        expiration: outputs.oss.GetBucketsBucketLifecycleRuleExpiration;
        /**
         * Unique ID of the rule.
         */
        id: string;
        /**
         * Prefix applicable to a rule. Only those objects with a matching prefix can be affected by the rule.
         */
        prefix: string;
    }

    export interface GetBucketsBucketLifecycleRuleExpiration {
        /**
         * Date after which the rule to take effect. The format is like 2017-03-09.
         */
        date?: string;
        /**
         * Indicate the number of days after the last object update until the rules take effect.
         */
        days?: number;
    }

    export interface GetBucketsBucketLogging {
        /**
         * Bucket for storing access logs.
         */
        targetBucket: string;
        /**
         * Prefix of the saved access log file paths.
         */
        targetPrefix: string;
    }

    export interface GetBucketsBucketRefererConfig {
        /**
         * Indicate whether the access request referer field can be empty.
         */
        allowEmpty: boolean;
        /**
         * Referer access whitelist.
         */
        referers: string[];
    }

    export interface GetBucketsBucketServerSideEncryptionRule {
        /**
         * The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
         */
        kmsMasterKeyId: string;
        /**
         * The server-side encryption algorithm to use.
         */
        sseAlgorithm: string;
    }

    export interface GetBucketsBucketVersioning {
        /**
         * A bucket versioning state. Possible values:`Enabled` and `Suspended`.
         */
        status: string;
    }

    export interface GetBucketsBucketWebsite {
        /**
         * Key of the HTML document containing the error page.
         */
        errorDocument: string;
        /**
         * Key of the HTML document containing the home page.
         */
        indexDocument: string;
    }

    export interface GetInstanceAttachmentsAttachment {
        /**
         * The domain of the instance attachment.
         */
        domain: string;
        /**
         * The access endpoint of the instance attachment.
         */
        endpoint: string;
        /**
         * The resource ID, the value is same as "instanceName".
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The region of the instance attachment.
         */
        region: string;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The name of attaching VPC to instance.
         */
        vpcName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The cluster type of the instance. Possible values: `SSD`, `HYBRID`.
         */
        clusterType: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The instance quota which indicating the maximum number of tables.
         */
        entityQuota: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * The network type of the instance. Possible values: `NORMAL`, `VPC`, `VPC_CONSOLE`.
         */
        network: string;
        /**
         * The maximum adjustable read capacity unit of the instance.
         */
        readCapacity: number;
        /**
         * Instance status. Possible values: `Running`, `Disabled`, `Deleting`.
         */
        status: string;
        /**
         * A map of tags assigned to the instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instancesDs = pulumi.output(alicloud.ots.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * The user id of the instance.
         */
        userId: string;
        /**
         * The maximum adjustable write capacity unit of the instance.
         */
        writeCapacity: number;
    }

    export interface GetTablesTable {
        /**
         * ID of the table. The value is `<instance_name>:<table_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The maximum number of versions stored in this table.
         */
        maxVersion: number;
        /**
         * The property of `TableMeta` which indicates the structure information of a table.
         */
        primaryKeys: outputs.oss.GetTablesTablePrimaryKey[];
        /**
         * The table name of the OTS which could not be changed.
         */
        tableName: string;
        /**
         * The retention time of data stored in this table.
         */
        timeToLive: number;
    }

    export interface GetTablesTablePrimaryKey {
        name: string;
        type: string;
    }
}

export namespace ots {
    export interface GetInstanceAttachmentsAttachment {
        /**
         * The domain of the instance attachment.
         */
        domain: string;
        /**
         * The access endpoint of the instance attachment.
         */
        endpoint: string;
        /**
         * The resource ID, the value is same as "instanceName".
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The region of the instance attachment.
         */
        region: string;
        /**
         * The ID of attaching VPC to instance.
         */
        vpcId: string;
        /**
         * The name of attaching VPC to instance.
         */
        vpcName: string;
    }

    export interface GetInstancesInstance {
        /**
         * The cluster type of the instance. Possible values: `SSD`, `HYBRID`.
         */
        clusterType: string;
        /**
         * The create time of the instance.
         */
        createTime: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The instance quota which indicating the maximum number of tables.
         */
        entityQuota: number;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Instance name.
         */
        name: string;
        /**
         * The network type of the instance. Possible values: `NORMAL`, `VPC`, `VPC_CONSOLE`.
         */
        network: string;
        /**
         * The maximum adjustable read capacity unit of the instance.
         */
        readCapacity: number;
        /**
         * Instance status. Possible values: `Running`, `Disabled`, `Deleting`.
         */
        status: string;
        /**
         * A map of tags assigned to the instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instancesDs = pulumi.output(alicloud.ots.getInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * The user id of the instance.
         */
        userId: string;
        /**
         * The maximum adjustable write capacity unit of the instance.
         */
        writeCapacity: number;
    }

    export interface GetTablesTable {
        /**
         * ID of the table. The value is `<instance_name>:<table_name>`.
         */
        id: string;
        /**
         * The name of OTS instance.
         */
        instanceName: string;
        /**
         * The maximum number of versions stored in this table.
         */
        maxVersion: number;
        /**
         * The property of `TableMeta` which indicates the structure information of a table.
         */
        primaryKeys: outputs.ots.GetTablesTablePrimaryKey[];
        /**
         * The table name of the OTS which could not be changed.
         */
        tableName: string;
        /**
         * The retention time of data stored in this table.
         */
        timeToLive: number;
    }

    export interface GetTablesTablePrimaryKey {
        name: string;
        type: string;
    }

    export interface TablePrimaryKey {
        /**
         * Name for primary key.
         */
        name: string;
        /**
         * Type for primary key. Only `Integer`, `String` or `Binary` is allowed.
         */
        type: string;
    }
}

export namespace polardb {
    export interface ClusterParameter {
        name: string;
        value: string;
    }

    export interface GetAccountsAccount {
        /**
         * Account description.
         */
        accountDescription: string;
        /**
         * Account lock state, Valid values are `Lock`, `UnLock`.
         */
        accountLockState: string;
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Cluster address type.`Cluster`: the default address of the Cluster.`Primary`: Primary address.`Custom`: Custom cluster addresses.
         */
        accountStatus: string;
        /**
         * Account type, Valid values are `Normal`, `Super`.
         */
        accountType: string;
        /**
         * A list of database privilege. Each element contains the following attributes.
         */
        databasePrivileges: outputs.polardb.GetAccountsAccountDatabasePrivilege[];
    }

    export interface GetAccountsAccountDatabasePrivilege {
        /**
         * Account privilege of database
         */
        accountPrivilege: string;
        /**
         * The account owned database name
         */
        dbName: string;
    }

    export interface GetClustersCluster {
        /**
         * Billing method. Value options: `PostPaid` for Pay-As-You-Go and `PrePaid` for subscription.
         */
        chargeType: string;
        /**
         * The createTime of the db_nodes.
         */
        createTime: string;
        /**
         * The dbNodeClass of the db_nodes.
         */
        dbNodeClass: string;
        /**
         * The DBNodeNumber of the PolarDB cluster.
         */
        dbNodeNumber: number;
        /**
         * The DBNodes of the PolarDB cluster.
         */
        dbNodes: outputs.polardb.GetClustersClusterDbNode[];
        /**
         * Database type. Options are `MySQL`, `Oracle` and `PostgreSQL`. If no value is specified, all types are returned.
         */
        dbType: string;
        /**
         * The DBVersion of the PolarDB cluster.
         */
        dbVersion: string;
        /**
         * The DeleteLock of the PolarDB cluster.
         */
        deleteLock: number;
        /**
         * The description of the PolarDB cluster.
         */
        description: string;
        /**
         * Database type. Options are `MySQL`, `Oracle` and `PostgreSQL`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Expiration time. Pay-As-You-Go clusters never expire.
         */
        expireTime: string;
        /**
         * The expired of the PolarDB cluster.
         */
        expired: string;
        /**
         * The ID of the PolarDB cluster.
         */
        id: string;
        /**
         * The LockMode of the PolarDB cluster.
         */
        lockMode: string;
        /**
         * The DBClusterNetworkType of the PolarDB cluster.
         */
        networkType: string;
        /**
         * The regionId of the db_nodes.
         */
        regionId: string;
        /**
         * status of the cluster.
         */
        status: string;
        /**
         * The StorageUsed of the PolarDB cluster.
         */
        storageUsed: number;
        /**
         * ID of the VPC the cluster belongs to.
         */
        vpcId: string;
        /**
         * The zoneId of the db_nodes.
         */
        zoneId: string;
    }

    export interface GetClustersClusterDbNode {
        /**
         * The createTime of the db_nodes.
         */
        createTime: string;
        /**
         * The dbNodeClass of the db_nodes.
         */
        dbNodeClass: string;
        /**
         * The dbNodeId of the db_nodes.
         */
        dbNodeId: string;
        /**
         * The dbNodeRole of the db_nodes.
         */
        dbNodeRole: string;
        /**
         * The dbNodeStatus of the db_nodes.
         */
        dbNodeStatus: string;
        /**
         * The maxConnections of the db_nodes.
         */
        maxConnections: number;
        /**
         * The maxIops of the db_nodes.
         */
        maxIops: number;
        /**
         * The regionId of the db_nodes.
         */
        regionId: string;
        /**
         * The zoneId of the db_nodes.
         */
        zoneId: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * A list of accounts of database. Each element contains the following attributes.
         */
        accounts: outputs.polardb.GetDatabasesDatabaseAccount[];
        /**
         * The character set name of database.
         */
        characterSetName: string;
        /**
         * Database description.
         */
        dbDescription: string;
        /**
         * Database name.
         */
        dbName: string;
        /**
         * The status of database.
         */
        dbStatus: string;
        /**
         * The engine of database.
         */
        engine: string;
    }

    export interface GetDatabasesDatabaseAccount {
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Account status.
         */
        accountStatus: string;
        /**
         * The privilege status of account.
         */
        privilegeStatus: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * A list of endpoint addresses. Each element contains the following attributes.
         */
        addressItems: outputs.polardb.GetEndpointsEndpointAddressItem[];
        /**
         * Whether the new node is automatically added to the default cluster address.Options are `Enable` and `Disable`.
         */
        autoAddNewNodes: string;
        /**
         * endpoint of the cluster.
         */
        dbEndpointId: string;
        /**
         * The Endpoint configuration. `ConsistLevel`: session consistency level, value:`0`: final consistency,`1`: session consistency;`LoadBalanceStrategy`: load balancing strategy. Based on the automatic scheduling of load, the value is: `load`.
         */
        endpointConfig: string;
        /**
         * Cluster address type.`Cluster`: the default address of the Cluster.`Primary`: Primary address.`Custom`: Custom cluster addresses.
         */
        endpointType: string;
        /**
         * A list of nodes that connect to the address configuration.
         */
        nodes: string;
        /**
         * Read-write mode:`ReadWrite`: readable and writable (automatic read-write separation).`ReadOnly`: ReadOnly.
         */
        readWriteMode: string;
    }

    export interface GetEndpointsEndpointAddressItem {
        /**
         * Connection instance string.
         */
        connectionString: string;
        /**
         * The ip address of connection string.
         */
        ipAddress: string;
        /**
         * IP network type:`Public` or `Private`.
         */
        netType: string;
        /**
         * Intranet connection port.
         */
        port: string;
        /**
         * ID of the VPC the instance belongs to.
         */
        vpcId: string;
        /**
         * ID of the VSwitch the cluster belongs to.
         */
        vswitchId: string;
    }

    export interface GetNodeClassesClass {
        /**
         * A list of PolarDB node classes in the zone.
         */
        supportedEngines: outputs.polardb.GetNodeClassesClassSupportedEngine[];
        /**
         * The Zone to launch the PolarDB cluster.
         */
        zoneId: string;
    }

    export interface GetNodeClassesClassSupportedEngine {
        /**
         * A list of PolarDB node available classes.
         */
        availableResources: outputs.polardb.GetNodeClassesClassSupportedEngineAvailableResource[];
        /**
         * In the zone, the database type supports classes in the following available_resources.
         */
        engine: string;
    }

    export interface GetNodeClassesClassSupportedEngineAvailableResource {
        /**
         * The PolarDB node class type by the user.
         */
        dbNodeClass: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }
}

export namespace privatelink {
    export interface GetVpcEndpointConnectionsConnection {
        /**
         * The Bandwidth.
         */
        bandwidth: number;
        /**
         * The ID of the Vpc Endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Vpc Endpoint Connection.
         */
        id: string;
        /**
         * The status of Vpc Endpoint Connection.
         */
        status: string;
    }

    export interface GetVpcEndpointServiceResourcesResource {
        /**
         * The ID of the Vpc Endpoint Service Resource.
         */
        id: string;
        /**
         * The ID of Resource.
         */
        resourceId: string;
        /**
         * The type of Resource.
         */
        resourceType: string;
    }

    export interface GetVpcEndpointServiceUsersUser {
        /**
         * The ID of the Vpc Endpoint Service User.
         */
        id: string;
        /**
         * The Id of Ram User.
         */
        userId: string;
    }

    export interface GetVpcEndpointServicesService {
        /**
         * Whether to automatically accept terminal node connections..
         */
        autoAcceptConnection: boolean;
        /**
         * The connection bandwidth.
         */
        connectBandwidth: number;
        /**
         * The ID of the Vpc Endpoint Service.
         */
        id: string;
        /**
         * The business status of the terminal node service..
         */
        serviceBusinessStatus: string;
        /**
         * The description of the terminal node service.
         */
        serviceDescription: string;
        /**
         * The domain of service.
         */
        serviceDomain: string;
        /**
         * The ID of the Vpc Endpoint Service.
         */
        serviceId: string;
        /**
         * The Status of Vpc Endpoint Service.
         */
        status: string;
        /**
         * The name of Vpc Endpoint Service.
         */
        vpcEndpointServiceName: string;
    }

    export interface GetVpcEndpointZonesZone {
        /**
         * Terminal node network card.
         */
        eniId: string;
        /**
         * IP address of the terminal node network card.
         */
        eniIp: string;
        /**
         * The ID of the Vpc Endpoint Zone.
         */
        id: string;
        /**
         * The Status of Vpc Endpoint Zone..
         */
        status: string;
        /**
         * The VSwitch id.
         */
        vswitchId: string;
        /**
         * The Zone Domain.
         */
        zoneDomain: string;
        /**
         * The Zone Id.
         */
        zoneId: string;
    }

    export interface GetVpcEndpointsEndpoint {
        /**
         * The Bandwidth.
         */
        bandwidth: number;
        /**
         * The status of Connection.
         */
        connectionStatus: string;
        /**
         * The status of Endpoint Business.
         */
        endpointBusinessStatus: string;
        /**
         * The description of Vpc Endpoint.
         */
        endpointDescription: string;
        /**
         * The Endpoint Domain.
         */
        endpointDomain: string;
        /**
         * The ID of the Vpc Endpoint.
         */
        endpointId: string;
        /**
         * The ID of the Vpc Endpoint.
         */
        id: string;
        /**
         * The security group associated with the terminal node network card.
         */
        securityGroupIds: string[];
        /**
         * The terminal node service associated with the terminal node.
         */
        serviceId: string;
        /**
         * The name of the terminal node service associated with the terminal node.
         */
        serviceName: string;
        /**
         * The status of Vpc Endpoint.
         */
        status: string;
        /**
         * The name of Vpc Endpoint.
         */
        vpcEndpointName: string;
        /**
         * The private network to which the terminal node belongs.
         */
        vpcId: string;
    }
}

export namespace pvtz {
    export interface GetZoneRecordsRecord {
        /**
         * ID of the Private Zone Record.
         */
        id: string;
        /**
         * Priority of the Private Zone Record.
         */
        priority: number;
        /**
         * RecordId of the Private Zone Record.
         */
        recordId: string;
        /**
         * Remark of the Private Zone Record.
         */
        remark: string;
        /**
         * Resource record of the Private Zone Record.
         */
        resourceRecord: string;
        /**
         * Rr of the Private Zone Record.
         */
        rr: string;
        /**
         * Resolve record status. Value:
         * - ENABLE: enable resolution.
         * - DISABLE: pause parsing.
         */
        status: string;
        /**
         * Ttl of the Private Zone Record.
         */
        ttl: number;
        /**
         * Type of the Private Zone Record.
         */
        type: string;
        /**
         * Value of the Private Zone Record.
         */
        value: string;
    }

    export interface GetZonesZone {
        /**
         * List of the VPCs is bound to the Private Zone:
         */
        bindVpcs: outputs.pvtz.GetZonesZoneBindVpc[];
        /**
         * Time of create of the Private Zone.
         */
        createTimestamp: number;
        creationTime: string;
        /**
         * ID of the Private Zone.
         */
        id: string;
        /**
         * Whether the Private Zone is ptr.
         */
        isPtr: boolean;
        /**
         * Name of the Private Zone.
         */
        name: string;
        /**
         * The recursive DNS proxy.
         */
        proxyPattern: string;
        /**
         * Count of the Private Zone Record.
         */
        recordCount: number;
        /**
         * Remark of the Private Zone.
         */
        remark: string;
        /**
         * resource_group_id for zone resourceGroupId.
         */
        resourceGroupId: string;
        /**
         * Whether to turn on secondary DNS.
         */
        slaveDns: boolean;
        updateTime: string;
        /**
         * Time of update of the Private Zone.
         */
        updateTimestamp: number;
        /**
         * ZoneId of the Private Zone.
         */
        zoneId: string;
        /**
         * ZoneName of the Private Zone.
         */
        zoneName: string;
    }

    export interface GetZonesZoneBindVpc {
        /**
         * Binding the regionId of VPC.
         */
        regionId: string;
        /**
         * Binding the regionName of VPC.
         */
        regionName: string;
        /**
         * Binding the vpcId of VPC.
         */
        vpcId: string;
        vpcName: string;
    }

    export interface ZoneAttachmentVpc {
        /**
         * The region of the vpc. If not set, the current region will instead of.
         */
        regionId: string;
        /**
         * The Id of the vpc.
         */
        vpcId: string;
    }
}

export namespace quotas {
    export interface ApplicationInfoDimension {
        key?: string;
        value?: string;
    }

    export interface GetApplicationInfosApplication {
        applicationId: string;
        approveValue: string;
        auditReason: string;
        desireValue: number;
        dimensions: outputs.quotas.GetApplicationInfosApplicationDimension[];
        effectiveTime: string;
        expireTime: string;
        id: string;
        noticeType: number;
        productCode: string;
        quotaActionCode: string;
        quotaDescription: string;
        quotaName: string;
        quotaUnit: string;
        reason: string;
        status: string;
    }

    export interface GetApplicationInfosApplicationDimension {
        key: string;
        value: string;
    }

    export interface GetApplicationInfosDimension {
        key?: string;
        value?: string;
    }

    export interface GetQuotaAlarmsAlarm {
        /**
         * The first ID of the resource.
         */
        alarmId: string;
        /**
         * The ID of the Quota Alarm.
         */
        id: string;
        /**
         * The Product Code.
         */
        productCode: string;
        /**
         * The Quota Action Code.
         */
        quotaActionCode: string;
        /**
         * The name of Quota Alarm.
         */
        quotaAlarmName: string;
        /**
         * The Quota Dimensions.
         */
        quotaDimensions: outputs.quotas.GetQuotaAlarmsAlarmQuotaDimension[];
        /**
         * The threshold of Quota Alarm.
         */
        threshold: number;
        /**
         * The threshold percent of Quota Alarm.
         */
        thresholdPercent: number;
        /**
         * The WebHook of Quota Alarm.
         */
        webHook: string;
    }

    export interface GetQuotaAlarmsAlarmQuotaDimension {
        /**
         * The key of quota_dimensions.
         */
        key: string;
        /**
         * The value of quota_dimensions.
         */
        value: string;
    }

    export interface GetQuotaAlarmsQuotaDimension {
        /**
         * The key of quota_dimensions.
         */
        key?: string;
        /**
         * The value of quota_dimensions.
         */
        value?: string;
    }

    export interface GetQuotaApplicationsApplication {
        /**
         * The first ID of the resource.
         */
        applicationId: string;
        /**
         * The approve value.
         */
        approveValue: string;
        /**
         * The audit reason.
         */
        auditReason: string;
        /**
         * The desire value of the quota application.
         */
        desireValue: number;
        /**
         * The quota dimensions.
         */
        dimensions: outputs.quotas.GetQuotaApplicationsApplicationDimension[];
        /**
         * The effective time.
         */
        effectiveTime: string;
        /**
         * The expire time.
         */
        expireTime: string;
        /**
         * The ID of the Application Info.
         */
        id: string;
        /**
         * The notice type.
         */
        noticeType: number;
        /**
         * The product code.
         */
        productCode: string;
        /**
         * The ID of quota action..
         */
        quotaActionCode: string;
        /**
         * The description of the quota.
         */
        quotaDescription: string;
        /**
         * The name of the quota.
         */
        quotaName: string;
        /**
         * The quota unit.
         */
        quotaUnit: string;
        /**
         * The reason of the quota application.
         */
        reason: string;
        /**
         * The status of the quota application.
         */
        status: string;
    }

    export interface GetQuotaApplicationsApplicationDimension {
        /**
         * The key of dimensions.
         */
        key: string;
        /**
         * The value of dimensions.
         */
        value: string;
    }

    export interface GetQuotaApplicationsDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

    export interface GetQuotasDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }

    export interface GetQuotasQuota {
        /**
         * Is the quota adjustable.
         */
        adjustable: boolean;
        /**
         * The range of quota adjustment.
         */
        applicableRanges: string[];
        /**
         * The type of quota.
         */
        applicableType: string;
        /**
         * Show used quota.
         */
        consumable: boolean;
        /**
         * The ID of the Quota.
         */
        id: string;
        /**
         * The quota action code.
         */
        quotaActionCode: string;
        /**
         * The quota description.
         */
        quotaDescription: string;
        /**
         * The quota name.
         */
        quotaName: string;
        /**
         * The quota type.
         */
        quotaType: string;
        /**
         * The quota unit.
         */
        quotaUnit: string;
        /**
         * TotalQuota.
         */
        totalQuota: number;
        /**
         * The total of usage.
         */
        totalUsage: number;
        /**
         * The unadjustable detail.
         */
        unadjustableDetail: string;
    }

    export interface QuotaAlarmQuotaDimension {
        /**
         * The Key of quota_dimensions.
         */
        key?: string;
        /**
         * The Value of quota_dimensions.
         */
        value?: string;
    }

    export interface QuotaApplicationDimension {
        /**
         * The key of dimensions.
         */
        key?: string;
        /**
         * The value of dimensions.
         */
        value?: string;
    }
}

export namespace ram {
    export interface GetGroupsGroup {
        /**
         * Comments of the group.
         */
        comments: string;
        /**
         * Name of the group.
         */
        name: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * Attachment count of the policy.
         */
        attachmentCount: number;
        /**
         * Creation date of the policy.
         */
        createDate: string;
        /**
         * Default version of the policy.
         */
        defaultVersion: string;
        /**
         * Description of the policy.
         */
        description: string;
        /**
         * Policy document of the policy.
         */
        document: string;
        id: string;
        /**
         * Name of the policy.
         */
        name: string;
        /**
         * Policy document of the policy.
         */
        policyDocument: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Filter results by a specific policy type. Valid values are `Custom` and `System`.
         */
        type: string;
        /**
         * Update date of the policy.
         */
        updateDate: string;
        /**
         * Filter results by a specific user name. Returned policies are attached to the specified user.
         */
        userName: string;
        /**
         * The ID of default policy.
         */
        versionId: string;
    }

    export interface GetRolesRole {
        /**
         * Resource descriptor of the role.
         */
        arn: string;
        /**
         * Authorization strategy of the role. This parameter is deprecated and replaced by `document`.
         */
        assumeRolePolicyDocument: string;
        /**
         * Creation date of the role.
         */
        createDate: string;
        /**
         * Description of the role.
         */
        description: string;
        /**
         * Authorization strategy of the role.
         */
        document: string;
        /**
         * Id of the role.
         */
        id: string;
        /**
         * Name of the role.
         */
        name: string;
        /**
         * Update date of the role.
         */
        updateDate: string;
    }

    export interface GetSamlProvidersProvider {
        /**
         * The Alibaba Cloud Resource Name (ARN) of the IdP.
         */
        arn: string;
        /**
         * The description of SAML Provider.
         */
        description: string;
        /**
         * The encodedsaml metadata document.
         */
        encodedsamlMetadataDocument: string;
        /**
         * The ID of the SAML Provider.
         */
        id: string;
        /**
         * The saml provider name.
         */
        samlProviderName: string;
        /**
         * The update time.
         */
        updateDate: string;
    }

    export interface GetUsersUser {
        /**
         * Creation date of the user.
         */
        createDate: string;
        /**
         * The original id is user name, but it is user id in 1.37.0+.
         */
        id: string;
        /**
         * Last login date of the user. Removed from version 1.79.0.
         */
        lastLoginDate: string;
        /**
         * Name of the user.
         */
        name: string;
    }

    export interface PolicyStatement {
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) List of operations for the `resource`. The format of each item in this list is `${service}:${action_name}`, such as `oss:ListBuckets` and `ecs:Describe*`. The `${service}` can be `ecs`, `oss`, `ots` and so on, the `${action_name}` refers to the name of an api interface which related to the `${service}`.
         */
        actions: string[];
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) This parameter indicates whether or not the `action` is allowed. Valid values are `Allow` and `Deny`.
         */
        effect: string;
        /**
         * (It has been deprecated from version 1.49.0, and use field 'document' to replace.) List of specific objects which will be authorized. The format of each item in this list is `acs:${service}:${region}:${account_id}:${relative_id}`, such as `acs:ecs:*:*:instance/inst-002` and `acs:oss:*:1234567890000:mybucket`. The `${service}` can be `ecs`, `oss`, `ots` and so on, the `${region}` is the region info which can use `*` replace when it is not supplied, the `${account_id}` refers to someone's Alicloud account id or you can use `*` to replace, the `${relative_id}` is the resource description section which related to the `${service}`.
         */
        resources: string[];
    }
}

export namespace rds {
    export interface GetAccountsAccount {
        /**
         * Database description.
         */
        accountDescription: string;
        /**
         * Name of database account.
         */
        accountName: string;
        /**
         * Privilege type of account.
         */
        accountType: string;
        /**
         * A list of database permissions the account has.
         */
        databasePrivileges: outputs.rds.GetAccountsAccountDatabasePrivilege[];
        /**
         * The ID of the Account.
         */
        id: string;
        /**
         * Whether the maximum number of databases managed by the account is exceeded.
         */
        privExceeded: string;
        /**
         * The status of the resource.
         */
        status: string;
    }

    export interface GetAccountsAccountDatabasePrivilege {
        /**
         * The type of permission for the account.
         */
        accountPrivilege: string;
        /**
         * The specific permissions corresponding to the type of account permissions.
         */
        accountPrivilegeDetail: string;
        /**
         * Database name.
         */
        dbName: string;
    }

    export interface GetInstanceClassesInstanceClass {
        /**
         * DB Instance available class.
         */
        instanceClass: string;
        price: string;
        /**
         * DB Instance available storage range.
         */
        storageRange: outputs.rds.GetInstanceClassesInstanceClassStorageRange;
        /**
         * A list of Zone to launch the DB instance.
         */
        zoneIds: outputs.rds.GetInstanceClassesInstanceClassZoneId[];
    }

    export interface GetInstanceClassesInstanceClassStorageRange {
        /**
         * DB Instance available storage max value.
         */
        max: string;
        /**
         * DB Instance available storage min value.
         */
        min: string;
        /**
         * DB Instance available storage increase step.
         */
        step: string;
    }

    export interface GetInstanceClassesInstanceClassZoneId {
        /**
         * The Zone to launch the DB instance
         */
        id: string;
        /**
         * A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `subZoneIds` will be `["cn-beijing-a", "cn-beijing-b"]`.
         */
        subZoneIds: string[];
    }

    export interface GetInstanceEnginesInstanceEngine {
        /**
         * DB Instance category.
         */
        category: string;
        /**
         * Database type. Options are `MySQL`, `SQLServer`, `PostgreSQL` and `PPAS`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Database version required by the user. Value options can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/26228.htm) `EngineVersion`.
         */
        engineVersion: string;
        /**
         * A list of Zone to launch the DB instance.
         */
        zoneIds: outputs.rds.GetInstanceEnginesInstanceEngineZoneId[];
    }

    export interface GetInstanceEnginesInstanceEngineZoneId {
        /**
         * The Zone to launch the DB instance
         */
        id: string;
        /**
         * A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `subZoneIds` will be `["cn-beijing-a", "cn-beijing-b"]`.
         */
        subZoneIds: string[];
    }

    export interface GetInstancesInstance {
        /**
         * (Available in 1.124.1+) The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - cert
         * - perfer
         * - verify-ca
         * - verify-full (supported only when the instance runs PostgreSQL 12 or later)
         */
        acl: string;
        /**
         * Availability zone.
         */
        availabilityZone: string;
        /**
         * (Available in 1.124.1+) The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - aliyun: a cloud certificate
         * - custom: a custom certificate
         */
        caType: string;
        /**
         * Billing method. Value options: `Postpaid` for Pay-As-You-Go and `Prepaid` for subscription.
         */
        chargeType: string;
        /**
         * (Available in 1.124.1+) The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        clientCaCert: string;
        clientCaCertExpireTime: string;
        /**
         * (Available in 1.124.1+) The certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        clientCertRevocationList: string;
        /**
         * `Standard` for standard access mode and `Safe` for high security access mode.
         */
        connectionMode: string;
        /**
         * (Available in 1.70.3+) RDS database connection string.
         */
        connectionString: string;
        /**
         * Creation time of the instance.
         */
        createTime: string;
        /**
         * (Available in 1.70.3+) The storage type of the instance.
         */
        dbInstanceStorageType: string;
        /**
         * `Primary` for primary instance, `Readonly` for read-only instance, `Guard` for disaster recovery instance, and `Temp` for temporary instance.
         */
        dbType: string;
        /**
         * Database type. Options are `MySQL`, `SQLServer`, `PostgreSQL` and `PPAS`. If no value is specified, all types are returned.
         */
        engine: string;
        /**
         * Database version.
         */
        engineVersion: string;
        /**
         * Expiration time. Pay-As-You-Go instances never expire.
         */
        expireTime: string;
        /**
         * If a disaster recovery instance is attached to the current instance, the ID of the disaster recovery instance applies.
         */
        guardInstanceId: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * (Available in 1.70.3+) User-defined DB instance storage space.
         */
        instanceStorage: number;
        /**
         * Sizing of the RDS instance.
         */
        instanceType: string;
        /**
         * (Available in 1.124.1+) The status of the SSL link. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - success
         * - setting
         * - failed
         */
        lastModifyStatus: string;
        /**
         * ID of the primary instance. If this parameter is not returned, the current instance is a primary instance.
         */
        masterInstanceId: string;
        /**
         * (Available in 1.101.0+) The master zone of the instance.
         */
        masterZone: string;
        /**
         * (Available in 1.124.1+) The reason why the SSL link stays in the current state. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        modifyStatusReason: string;
        /**
         * The name of the RDS instance.
         */
        name: string;
        /**
         * `Internet` for public network or `Intranet` for private network.
         */
        netType: string;
        /**
         * (Available in 1.70.3+) RDS database connection port.
         */
        port: string;
        /**
         * A list of IDs of read-only instances attached to the primary instance.
         */
        readonlyInstanceIds: string[];
        /**
         * Region ID the instance belongs to.
         */
        regionId: string;
        /**
         * (Available in 1.124.1+) The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
         * - cert
         * - perfer
         * - verify-ca
         * - verify-full (supported only when the instance runs PostgreSQL 12 or later)
         */
        replicationAcl: string;
        /**
         * (Available in 1.124.1+) Indicates whether the server certificate needs to be updated.
         * - Valid values for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server:
         * - No
         * - Yes
         * - Valid values for ApsaraDB RDS for PostgreSQL:
         * - 0: no
         * - 1: yes
         */
        requireUpdate: string;
        /**
         * (Available in 1.124.1+) The server certificate that needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        requireUpdateItem: string;
        /**
         * (Available in 1.124.1+) The reason why the server certificate needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        requireUpdateReason: string;
        /**
         * (Available in 1.124.1+) The URL of the CA that issues the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverCaUrl: string;
        /**
         * (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverCert: string;
        /**
         * (Available in 1.124.1+) The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
         */
        serverKey: string;
        /**
         * (Available in 1.124.1+) The time when the server certificate was created. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. In addition, this parameter is valid only when the CAType parameter is set to aliyun.
         */
        sslCreateTime: string;
        /**
         * (Available in 1.124.1+) Indicates whether SSL encryption is enabled. Valid values:
         * - on: enabled
         * - off: disabled
         */
        sslEnabled: string;
        /**
         * (Available in 1.124.1+) The time when the server certificate expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
         */
        sslExpireTime: string;
        /**
         * Status of the instance.
         */
        status: string;
        /**
         * If a temporary instance is attached to the current instance, the ID of the temporary instance applies.
         */
        tempInstanceId: string;
        /**
         * Used to retrieve instances belong to specified VPC.
         */
        vpcId: string;
        /**
         * Used to retrieve instances belong to specified `vswitch` resources.
         */
        vswitchId: string;
        /**
         * (Available in 1.101.0+) The region ID of the secondary instance if you create a secondary instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
         */
        zoneIdSlaveA: string;
        /**
         * (Available in 1.101.0+) The region ID of the log instance if you create a log instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
         */
        zoneIdSlaveB: string;
    }

    export interface GetRdsParameterGroupsGroup {
        engine: string;
        engineVersion: string;
        forceRestart: number;
        id: string;
        paramCounts: number;
        paramDetails: outputs.rds.GetRdsParameterGroupsGroupParamDetail[];
        parameterGroupDesc: string;
        parameterGroupId: string;
        parameterGroupName: string;
        parameterGroupType: number;
    }

    export interface GetRdsParameterGroupsGroupParamDetail {
        paramName: string;
        paramValue: string;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of zone ids in which the multi zone.
         */
        multiZoneIds: string[];
    }

    export interface InstanceParameter {
        name: string;
        value: string;
    }

    export interface RdsParameterGroupParamDetail {
        /**
         * The name of a parameter.
         */
        paramName: string;
        /**
         * The value of a parameter.
         */
        paramValue: string;
    }

    export interface ReadOnlyInstanceParameter {
        name: string;
        value: string;
    }
}

export namespace resourcemanager {
    export interface GetAccountsAccount {
        accountId: string;
        displayName: string;
        /**
         * The ID of the folder.
         */
        folderId: string;
        /**
         * The ID of the resource.
         * * `accountId`- The ID of the account.
         * * `displayName`- The name of the member account.
         */
        id: string;
        /**
         * The way in which the member account joined the resource directory.
         */
        joinMethod: string;
        /**
         * The time when the member account joined the resource directory.
         */
        joinTime: string;
        /**
         * The time when the member account was modified.
         */
        modifyTime: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The status of account, valid values: `CreateCancelled`, `CreateExpired`, `CreateFailed`, `CreateSuccess`, `CreateVerifying`, `InviteSuccess`, `PromoteCancelled`, `PromoteExpired`, `PromoteFailed`, `PromoteSuccess`, and `PromoteVerifying`.
         */
        status: string;
        /**
         * The type of the member account.
         */
        type: string;
    }

    export interface GetControlPoliciesPolicy {
        /**
         * The count of policy attachment.
         */
        attachmentCount: number;
        /**
         * The name of policy.
         */
        controlPolicyName: string;
        /**
         * The description of policy.
         */
        description: string;
        /**
         * The effect scope.
         */
        effectScope: string;
        /**
         * The ID of the Control Policy.
         */
        id: string;
        /**
         * The policy document.
         */
        policyDocument: string;
        /**
         * The ID of policy.
         */
        policyId: string;
        /**
         * The type of policy.
         */
        policyType: string;
    }

    export interface GetControlPolicyAttachmentsAttachment {
        /**
         * The attach date.
         */
        attachDate: string;
        /**
         * The description of policy.
         */
        description: string;
        /**
         * The ID of the Control Policy Attachment.
         */
        id: string;
        /**
         * The ID of policy.
         */
        policyId: string;
        /**
         * The name of policy.
         */
        policyName: string;
        /**
         * The type of policy.
         */
        policyType: string;
    }

    export interface GetFoldersFolder {
        folderId: string;
        folderName: string;
        /**
         * The ID of the folder.
         * * `folderId`- The ID of the folder.
         * * `folderName`- The name of the folder.
         * * `parentFolderId`- (Available in v1.114.0+)The ID of the parent folder.
         */
        id: string;
        /**
         * The ID of the parent folder.
         */
        parentFolderId: string;
    }

    export interface GetHandshakesHandshake {
        /**
         * The time when the invitation expires.
         */
        expireTime: string;
        handshakeId: string;
        /**
         * The ID of the resource.
         * * `handshakeId`- The ID of the invitation.
         */
        id: string;
        /**
         * (Available in v1.114.0+) The real name of the invited account.
         */
        invitedAccountRealName: string;
        /**
         * The ID of the master account of the resource directory.
         */
        masterAccountId: string;
        /**
         * The name of the master account of the resource directory.
         */
        masterAccountName: string;
        /**
         * (Available in v1.114.0+) The real name of the master account of the resource directory.
         */
        masterAccountRealName: string;
        /**
         * The time when the invitation was modified.
         */
        modifyTime: string;
        /**
         * The invitation note.
         */
        note: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The status of handshake, valid values: `Accepted`, `Cancelled`, `Declined`, `Deleted`, `Expired` and `Pending`.
         */
        status: string;
        /**
         * The ID or logon email address of the invited account.
         */
        targetEntity: string;
        /**
         * The type of the invited account.
         */
        targetType: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * The number of times the policy is referenced.
         */
        attachmentCount: number;
        /**
         * The default version of the policy.
         */
        defaultVersion: string;
        /**
         * The description of the policy.
         */
        description: string;
        /**
         * The ID of the policy.
         * * `policyName`- The name of the policy.
         * * `policyType`- The type of the policy.
         */
        id: string;
        policyName: string;
        /**
         * The type of the policy. If you do not specify this parameter, the system lists all types of policies. Valid values: `Custom` and `System`.
         */
        policyType: string;
        /**
         * The time when the policy was updated.
         */
        updateDate: string;
    }

    export interface GetPolicyAttachmentsAttachment {
        /**
         * The time when the policy was attached.
         */
        attachDate: string;
        /**
         * The description of the policy.
         */
        description: string;
        /**
         * The ID of the Resource Manager Policy Attachment.
         * * `policyName`- The name of the policy.
         * * `policyType`- The type of the policy.
         * * `principalName`- The name of the object to which the policy is attached.
         * * `principalType`- The type of the object to which the policy is attached.
         */
        id: string;
        /**
         * The name of the policy. The name must be 1 to 128 characters in length and can contain letters, digits, and hyphens (-).
         */
        policyName: string;
        /**
         * The type of the policy. Valid values: `Custom` and `System`.
         */
        policyType: string;
        /**
         * The name of the object to which the policy is attached.
         */
        principalName: string;
        /**
         * The type of the object to which the policy is attached. If you do not specify this parameter, the system lists all types of objects. Valid values: `IMSUser`: RAM user, `IMSGroup`: RAM user group, `ServiceRole`: RAM role.
         */
        principalType: string;
        /**
         * The ID of the resource group or the ID of the Alibaba Cloud account to which the resource group belongs. If you do not specify this parameter, the system lists all policy attachment records under the current account.
         */
        resourceGroupId: string;
    }

    export interface GetPolicyVersionsVersion {
        /**
         * The ID of the resource, the value is `<policy_name>`:`<version_id>`.
         * * `versionId`- The ID of the policy version.
         * * `createDate`- (Removed form v1.114.0)The time when the policy version was created.
         * * `isDefaultVersion`- Indicates whether the policy version is the default version.
         * * `policyDocument`- (Available in v1.114.0+) The policy document of the policy version.
         */
        id: string;
        isDefaultVersion: boolean;
        policyDocument: string;
        versionId: string;
    }

    export interface GetResourceDirectoriesDirectory {
        /**
         * The ID of resource directory.
         * * `masterAccountId`- The ID of the master account.
         * * `masterAccountName`- The name of the master account.
         */
        id: string;
        masterAccountId: string;
        masterAccountName: string;
        /**
         * The ID of the resource directory.
         */
        resourceDirectoryId: string;
        /**
         * The ID of the root folder.
         */
        rootFolderId: string;
        /**
         * (Available in 1.120.0+.) The status of the control policy.
         */
        status: string;
    }

    export interface GetResourceGroupsGroup {
        /**
         * The ID of the Alibaba Cloud account to which the resource group belongs.
         */
        accountId: string;
        /**
         * The display name of the resource group.
         */
        displayName: string;
        /**
         * The ID of the resource group.
         */
        id: string;
        /**
         * The unique identifier of the resource group.
         */
        name: string;
        regionStatuses: outputs.resourcemanager.GetResourceGroupsGroupRegionStatus[];
        /**
         * (Available in v1.114.0+) The unique identifier of the resource group.
         */
        resourceGroupName: string;
        /**
         * The status of the resource group. Possible values:`Creating`,`Deleted`,`Deleting`(Available 1.114.0+) `OK` and `PendingDelete`.
         */
        status: string;
    }

    export interface GetResourceGroupsGroupRegionStatus {
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The status of the resource group. Possible values:`Creating`,`Deleted`,`Deleting`(Available 1.114.0+) `OK` and `PendingDelete`.
         */
        status: string;
    }

    export interface GetResourceSharesShare {
        /**
         * The ID of the Resource Share.
         */
        id: string;
        /**
         * The ID of the resource share.
         */
        resourceShareId: string;
        /**
         * The name of resource share.
         */
        resourceShareName: string;
        /**
         * The owner of resource share.
         */
        resourceShareOwner: string;
        /**
         * The status of resource share.
         */
        status: string;
    }

    export interface GetRolesRole {
        arn: string;
        assumeRolePolicyDocument: string;
        description: string;
        /**
         * The ID of the role.
         * * `roleId`- The ID of the role.
         * * `roleName`- The name of the role.
         * * `arn`- The Alibaba Cloud Resource Name (ARN) of the RAM role.
         * * `createDate`- (Removed form v1.114.0) The time when the RAM role was created.
         * * `updateDate`- The time when the RAM role was updated.
         * * `description`- The description of the RAM role.
         * * `maxSessionDuration`- The maximum session duration of the RAM role.
         * * `assumeRolePolicyDocument`- (Available in v1.114.0+) The assume role policy document.
         */
        id: string;
        maxSessionDuration: number;
        roleId: string;
        roleName: string;
        updateDate: string;
    }

    export interface GetSharedResourcesResource {
        /**
         * The ID of the Shared Resource.
         */
        id: string;
        /**
         * The ID of the shared resource.
         */
        resourceId: string;
        /**
         * The resource share ID of resource manager.
         */
        resourceShareId: string;
        /**
         * The type of shared resource.
         */
        resourceType: string;
        /**
         * The status of shared resource.
         */
        status: string;
    }

    export interface GetSharedTargetsTarget {
        /**
         * The ID of the Shared Target.
         */
        id: string;
        /**
         * The resource shared ID of resource manager.
         */
        resourceShareId: string;
        /**
         * The status of shared target.
         */
        status: string;
        /**
         * The member account ID in resource directory.
         */
        targetId: string;
    }

    export interface ResourceGroupRegionStatus {
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The status of the regional resource group.
         */
        status: string;
    }
}

export namespace rocketmq {
    export interface GetGroupsGroup {
        /**
         * The name of the group.
         */
        groupName: string;
        /**
         * Specify the protocol applicable to the created Group ID. Valid values: `tcp`, `http`. Default to `tcp`.
         */
        groupType: string;
        /**
         * The name of the group.
         */
        id: string;
        /**
         * Indicates whether namespaces are available. Read [Fields in SubscribeInfoDo](https://www.alibabacloud.com/help/doc-detail/29619.html) for further details.
         */
        independentNaming: boolean;
        /**
         * ID of the ONS Instance that owns the groups.
         */
        instanceId: string;
        /**
         * The ID of the group owner, which is the Alibaba Cloud UID.
         */
        owner: string;
        /**
         * Remark of the group.
         */
        remark: string;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
    }

    export interface GetInstancesInstance {
        /**
         * The internal HTTP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternalEndpoint: string;
        /**
         * The public HTTP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternetEndpoint: string;
        /**
         * The public HTTPS endpoint for the Message Queue for Apache RocketMQ instance.
         */
        httpInternetSecureEndpoint: string;
        /**
         * ID of the instance.
         */
        id: string;
        /**
         * Indicates whether any namespace is configured for the Message Queue for Apache RocketMQ instance.
         */
        independentNaming: boolean;
        /**
         * ID of the instance.
         */
        instanceId: string;
        /**
         * Name of the instance.
         */
        instanceName: string;
        /**
         * The status of the instance. Read [Fields in InstanceVO](https://www.alibabacloud.com/help/doc-detail/106351.html) for further details.
         */
        instanceStatus: number;
        /**
         * The type of the instance. Read [Fields in InstanceVO](https://www.alibabacloud.com/help/doc-detail/106351.html) for further details.
         */
        instanceType: number;
        /**
         * The automatic release time of an Enterprise Platinum Edition instance.
         */
        releaseTime: string;
        /**
         * This attribute is a concise description of instance.
         */
        remark: string;
        /**
         * The status of Ons instance. Valid values: `0` deploying, `2` arrears, `5` running, `7` upgrading.
         */
        status: number;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
        /**
         * The TCP endpoint for the Message Queue for Apache RocketMQ instance.
         */
        tcpEndpoint: string;
    }

    export interface GetTopicsTopic {
        /**
         * The id of the topic.
         */
        id: string;
        /**
         * Indicates whether namespaces are available. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        independentNaming: boolean;
        /**
         * ID of the ONS Instance that owns the topics.
         */
        instanceId: string;
        /**
         * The type of the message. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        messageType: number;
        /**
         * The ID of the topic owner, which is the Alibaba Cloud UID.
         */
        owner: string;
        /**
         * This attribute is used to set the read-write mode for the topic.
         */
        perm: number;
        /**
         * The relation ID. Read [Fields in PublishInfoDo](https://www.alibabacloud.com/help/doc-detail/29590.html) for further details.
         */
        relation: number;
        /**
         * The name of the relation, for example, owner, publishable, subscribable, and publishable and subscribable.
         */
        relationName: string;
        /**
         * Remark of the topic.
         */
        remark: string;
        /**
         * A map of tags assigned to the Ons instance.
         */
        tags: {[key: string]: any};
        /**
         * The name of the topic.
         */
        topic: string;
        /**
         * The name of the topic.
         */
        topicName: string;
    }
}

export namespace ros {
    export interface ChangeSetParameter {
        /**
         * The parameter key.
         */
        parameterKey: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface GetChangeSetsSet {
        /**
         * The ID of the change set.
         */
        changeSetId: string;
        /**
         * The name of the change set.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        changeSetName: string;
        /**
         * The type of the change set. Valid values:  CREATE: creates a change set for a new stack. UPDATE: creates a change set for an existing stack. IMPORT: creates a change set for a new stack or an existing stack to import non-ROS-managed resources. If you create a change set for a new stack, ROS creates a stack that has a unique stack ID. The stack is in the REVIEW_IN_PROGRESS state until you execute the change set.  You cannot use the UPDATE type to create a change set for a new stack or the CREATE type to create a change set for an existing stack.
         */
        changeSetType: string;
        /**
         * The description of the change set. The description can be up to 1,024 bytes in length.
         */
        description: string;
        /**
         * Specifies whether to disable rollback on stack creation failure. Default value: false.  Valid values:  true: disables rollback on stack creation failure. false: enables rollback on stack creation failure. Note This parameter takes effect only when ChangeSetType is set to CREATE or IMPORT.
         */
        disableRollback: boolean;
        /**
         * The execution status of change set N. Maximum value of N: 5. Valid values:  UNAVAILABLE AVAILABLE EXECUTE_IN_PROGRESS EXECUTE_COMPLETE EXECUTE_FAILED OBSOLETE.
         */
        executionStatus: string;
        /**
         * The ID of the Change Set.
         */
        id: string;
        /**
         * Parameters.
         */
        parameters: outputs.ros.GetChangeSetsSetParameter[];
        /**
         * The ID of the stack for which you want to create the change set. ROS generates the change set by comparing the stack information with the information that you submit, such as a modified template or different inputs.
         */
        stackId: string;
        /**
         * The name of the stack for which you want to create the change set.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.  Note This parameter takes effect only when ChangeSetType is set to CREATE or IMPORT.
         */
        stackName: string;
        /**
         * The status of the change set.
         */
        status: string;
        /**
         * The structure that contains the template body. The template body must be 1 to 524,288 bytes in length.  If the length of the template body is longer than required, we recommend that you add parameters to the HTTP POST request body to avoid request failures due to excessive length of URLs.  You can specify one of TemplateBody or TemplateURL parameters, but you cannot specify both of them.
         */
        templateBody: string;
        /**
         * Timeout In Minutes.
         */
        timeoutInMinutes: number;
    }

    export interface GetChangeSetsSetParameter {
        /**
         * The parameters.
         */
        parameterKey: string;
        /**
         * The parameters.
         */
        parameterValue: string;
    }

    export interface GetStackGroupsGroup {
        /**
         * The name of the RAM administrator role assumed by ROS.
         */
        administrationRoleName: string;
        /**
         * The description of the stack group.
         */
        description: string;
        /**
         * The name of the RAM execution role assumed by the administrator role.
         */
        executionRoleName: string;
        /**
         * The ID of the Stack Group.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: outputs.ros.GetStackGroupsGroupParameter[];
        /**
         * The id of Stack Group.
         */
        stackGroupId: string;
        /**
         * The name of the stack group..
         */
        stackGroupName: string;
        /**
         * The status of Stack Group.
         */
        status: string;
        /**
         * The structure that contains the template body.
         */
        templateBody: string;
    }

    export interface GetStackGroupsGroupParameter {
        /**
         * The parameter key.
         */
        parameterKey: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }

    export interface GetStacksStack {
        /**
         * Specifies whether to enable deletion protection on the stack.
         */
        deletionProtection: string;
        /**
         * The Description of the Stack.
         */
        description: string;
        /**
         * Specifies whether to disable rollback on stack creation failure..
         */
        disableRollback: boolean;
        /**
         * Drift DetectionTime.
         */
        driftDetectionTime: string;
        /**
         * The ID of the Stack.
         */
        id: string;
        /**
         * The parameters.
         */
        parameters: outputs.ros.GetStacksStackParameter[];
        /**
         * Parent Stack Id.
         */
        parentStackId: string;
        /**
         * The RamRoleName.
         */
        ramRoleName: string;
        /**
         * Root Stack Id.
         */
        rootStackId: string;
        /**
         * Stack DriftStatus.
         */
        stackDriftStatus: string;
        /**
         * Stack Id.
         */
        stackId: string;
        /**
         * Stack Name.
         */
        stackName: string;
        /**
         * The structure that contains the stack policy body.
         */
        stackPolicyBody: string;
        /**
         * The status of Stack. Valid Values: `CREATE_COMPLETE`, `CREATE_FAILED`, `CREATE_IN_PROGRESS`, `DELETE_COMPLETE`, `DELETE_FAILED`, `DELETE_IN_PROGRESS`, `ROLLBACK_COMPLETE`, `ROLLBACK_FAILED`, `ROLLBACK_IN_PROGRESS`.
         */
        status: string;
        /**
         * Status Reason.
         */
        statusReason: string;
        /**
         * Query the instance bound to the tag. The format of the incoming value is `json` string, including `TagKey` and `TagValue`. `TagKey` cannot be null, and `TagValue` can be empty. Format example `{"key1":"value1"}`.
         */
        tags: {[key: string]: any};
        /**
         * Template Description.
         */
        templateDescription: string;
        /**
         * Specifies whether to use the values that were passed last time for the parameters that you do not specify in the current request.
         */
        timeoutInMinutes: number;
    }

    export interface GetStacksStackParameter {
        /**
         * The key of parameters.
         */
        parameterKey: string;
        /**
         * The value of parameters.
         */
        parameterValue: string;
    }

    export interface GetTemplatesTemplate {
        /**
         * The ID of the change set.
         */
        changeSetId: string;
        /**
         * The description of the template. The description can be up to 256 characters in length.
         */
        description: string;
        /**
         * The ID of the Template.
         */
        id: string;
        /**
         * Share Type.
         */
        shareType: string;
        /**
         * The name of the stack group. The name must be unique in a region.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        stackGroupName: string;
        /**
         * The ID of the stack.
         */
        stackId: string;
        /**
         * Tags.
         */
        tags: {[key: string]: any};
        /**
         * The structure that contains the template body. The template body must be 1 to 524,288 bytes in length.  If the length of the template body is longer than required, we recommend that you add parameters to the HTTP POST request body to avoid request failures due to excessive length of URLs.  You must specify one of the TemplateBody and TemplateURL parameters, but you cannot specify both of them.
         */
        templateBody: string;
        /**
         * The ID of the template.
         */
        templateId: string;
        /**
         * The name of the template.  The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). It must start with a digit or letter.
         */
        templateName: string;
        /**
         * Template Version.
         */
        templateVersion: string;
    }

    export interface StackGroupParameter {
        /**
         * The parameter key.
         */
        parameterKey?: string;
        /**
         * The parameter value.
         */
        parameterValue?: string;
    }

    export interface StackParameter {
        /**
         * The parameter key.
         */
        parameterKey?: string;
        /**
         * The parameter value.
         */
        parameterValue: string;
    }
}

export namespace sag {
    export interface GetAclsAcl {
        /**
         * The ID of the ACL. For example "acl-xxx".
         */
        id: string;
        /**
         * The name of the Acl.
         */
        name: string;
    }
}

export namespace slb {
    export interface AclEntryList {
        comment?: string;
        entry: string;
    }

    export interface BackendServerBackendServer {
        serverId: string;
        serverIp?: string;
        type?: string;
        weight: number;
    }

    export interface GetAclsAcl {
        /**
         * A list of entry (IP addresses or CIDR blocks).  Each entry contains two sub-fields as `Entry Block` follows.
         */
        entryLists: outputs.slb.GetAclsAclEntryList[];
        /**
         * Acl ID.
         */
        id: string;
        ipVersion: string;
        /**
         * Acl name.
         */
        name: string;
        /**
         * A list of listener are attached by the acl.  Each listener contains four sub-fields as `Listener Block` follows.
         */
        relatedListeners: outputs.slb.GetAclsAclRelatedListener[];
        /**
         * The Id of resource group which acl belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetAclsAclEntryList {
        comment: string;
        entry: string;
    }

    export interface GetAclsAclRelatedListener {
        aclType: string;
        frontendPort: number;
        loadBalancerId: string;
        protocol: string;
    }

    export interface GetApplicationLoadBalancersBalancer {
        /**
         * Service address of the SLBs.
         */
        address: string;
        /**
         * The address ip version. Valid values `ipv4` and `ipv6`.
         */
        addressIpVersion: string;
        /**
         * The address type of the SLB. Valid values `internet` and `intranet`.
         */
        addressType: string;
        /**
         * The auto release time.
         */
        autoReleaseTime: number;
        /**
         * The backend servers of the SLB.
         */
        backendServers: outputs.slb.GetApplicationLoadBalancersBalancerBackendServer[];
        /**
         * The bandwidth of the SLB.
         */
        bandwidth: number;
        /**
         * The create time stamp of the SLB.
         */
        createTimeStamp: number;
        /**
         * Whether the SLB should delete protection.
         */
        deleteProtection: string;
        /**
         * The end time of the SLB.
         */
        endTime: string;
        /**
         * The end time stamp of the SLB.
         */
        endTimeStamp: number;
        /**
         * ID of the SLB.
         */
        id: string;
        /**
         * The internet charge type. Valid values `PayByBandwidth` and `PayByTraffic`.
         */
        internetChargeType: string;
        /**
         * The listener ports and protocal of the SLB.
         */
        listenerPortsAndProtocals: outputs.slb.GetApplicationLoadBalancersBalancerListenerPortsAndProtocal[];
        /**
         * The listener ports and protocol of the SLB.
         */
        listenerPortsAndProtocols: outputs.slb.GetApplicationLoadBalancersBalancerListenerPortsAndProtocol[];
        /**
         * Thd ID of the SLB.
         */
        loadBalancerId: string;
        /**
         * The name of the SLB.
         */
        loadBalancerName: string;
        /**
         * The specification of the SLB.
         */
        loadBalancerSpec: string;
        /**
         * The master zone id of the SLB.
         */
        masterZoneId: string;
        /**
         * The reason of modification protection.
         */
        modificationProtectionReason: string;
        /**
         * The status of modification protection.
         */
        modificationProtectionStatus: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        /**
         * The payment type of SLB. Valid values `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * Region ID the SLB belongs to.
         */
        regionIdAlias: string;
        /**
         * The renewal cyc unit of the SLB.
         */
        renewalCycUnit: string;
        /**
         * The renewal duration of the SLB.
         */
        renewalDuration: number;
        /**
         * The renewal status of the SLB.
         */
        renewalStatus: string;
        /**
         * The Id of resource group which SLB belongs.
         */
        resourceGroupId: string;
        /**
         * The slave zone id of the SLB.
         */
        slaveZoneId: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetApplicationLoadBalancersBalancerBackendServer {
        /**
         * The description of protocol.
         */
        description: string;
        /**
         * The server ID.
         */
        serverId: string;
        /**
         * The type of servers.
         */
        type: string;
        /**
         * The weight of servers.
         */
        weight: number;
    }

    export interface GetApplicationLoadBalancersBalancerListenerPortsAndProtocal {
        /**
         * The listener port.
         */
        listenerPort: number;
        /**
         * The listener protoal.
         */
        listenerProtocal: string;
    }

    export interface GetApplicationLoadBalancersBalancerListenerPortsAndProtocol {
        /**
         * The description of protocol.
         */
        description: string;
        /**
         * The forward port.
         */
        forwardPort: number;
        /**
         * The listener forward.
         */
        listenerForward: string;
        /**
         * The listener port.
         */
        listenerPort: number;
        /**
         * The listener protocol.
         */
        listenerProtocol: string;
    }

    export interface GetApplicationLoadBalancersSlb {
        /**
         * Service address of the SLBs.
         */
        address: string;
        creationTime: string;
        /**
         * ID of the SLB.
         */
        id: string;
        internet: boolean;
        masterAvailabilityZone: string;
        name: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        regionId: string;
        slaveAvailabilityZone: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetAttachmentsSlbAttachment {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetBackendServersBackendServer {
        /**
         * backend server ID.
         */
        id: string;
        /**
         * Type of the backend server.
         */
        serverType: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetCaCertificatesCertificate {
        /**
         * (Available in v1.123.1+) CA certificate ID.
         */
        caCertificateId: string;
        /**
         * (Available in v1.123.1+) CA certificate name.
         */
        caCertificateName: string;
        /**
         * CA certificate common name.
         */
        commonName: string;
        /**
         * CA certificate created timestamp.
         */
        createdTimestamp: number;
        /**
         * CA certificate expired time.
         */
        expiredTime: string;
        /**
         * CA certificate expired timestamp.
         */
        expiredTimestamp: number;
        /**
         * CA certificate fingerprint.
         */
        fingerprint: string;
        /**
         * CA certificate ID.
         */
        id: string;
        /**
         * (Deprecated from v1.123.1) Deprecated and replace by `caCertificateName`.
         */
        name: string;
        /**
         * The Id of resource group which ca certificates belongs.
         */
        resourceGroupId: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
    }

    export interface GetDomainExtensionsExtension {
        /**
         * The domain name.
         */
        domain: string;
        /**
         * The ID of the domain extension.
         */
        id: string;
        /**
         * The ID of the certificate used by the domain name.
         */
        serverCertificateId: string;
    }

    export interface GetListenersSlbListener {
        /**
         * Port opened on the backend server to receive requests.
         */
        backendPort: number;
        /**
         * Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
         */
        bandwidth: number;
        /**
         * ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
         */
        caCertificateId: string;
        /**
         * Cookie configured by the backend server. Only available when the stickySessionType is `server`.
         */
        cookie: string;
        /**
         * Cookie timeout in seconds. Only available when the stickySessionType is `insert`.
         */
        cookieTimeout: number;
        /**
         * The description of slb listener.
         */
        description: string;
        /**
         * Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
         */
        enableHttp2: string;
        /**
         * Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
         */
        establishedTimeout: number;
        /**
         * Filter listeners by the specified frontend port.
         */
        frontendPort: number;
        /**
         * Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        gzip: string;
        /**
         * Indicate whether health check is enabled of not. Possible values are `on` and `off`.
         */
        healthCheck: string;
        /**
         * Port used for health check.
         */
        healthCheckConnectPort: number;
        /**
         * Amount of time in seconds to wait for the response for a health check.
         */
        healthCheckConnectTimeout: number;
        /**
         * Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckDomain: string;
        /**
         * HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as "http_2xx,http_3xx". Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckHttpCode: string;
        /**
         * Time interval between two consecutive health checks.
         */
        healthCheckInterval: number;
        /**
         * Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
         */
        healthCheckTimeout: number;
        /**
         * Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
         */
        healthCheckType: string;
        /**
         * URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case healthCheckType must be `http`).
         */
        healthCheckUri: string;
        /**
         * Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
         */
        healthyThreshold: number;
        /**
         * Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
         */
        idleTimeout: number;
        /**
         * ID of the active/standby server group.
         */
        masterSlaveServerGroupId: string;
        /**
         * Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
         */
        persistenceTimeout: number;
        /**
         * Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
         */
        protocol: string;
        /**
         * Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
         */
        requestTimeout: number;
        /**
         * Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
         */
        scheduler: string;
        /**
         * Security status. Only available when the protocol is `https`.
         */
        securityStatus: string;
        serverCertificateId: string;
        /**
         * ID of the linked VServer group.
         */
        serverGroupId: string;
        /**
         * ID of the server certificate. Only available when the protocol is `https`.
         */
        sslCertificateId: string;
        /**
         * Listener status.
         */
        status: string;
        /**
         * Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        stickySession: string;
        /**
         * Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and stickySession is `on`.
         */
        stickySessionType: string;
        /**
         * Https listener TLS cipher policy. Valid values are `tlsCipherPolicy10`, `tlsCipherPolicy11`, `tlsCipherPolicy12`, `tlsCipherPolicy12Strict`. Default to `tlsCipherPolicy10`.
         */
        tlsCipherPolicy: string;
        /**
         * Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
         */
        unhealthyThreshold: number;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For" is added or not; it allows the backend server to know about the user's IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedFor: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_SLBID" is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbId: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_SLBIP" is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbIp: string;
        /**
         * Indicate whether the HTTP header field "X-Forwarded-For_proto" is added or not; it allows the backend server to know about the user's protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
         */
        xForwardedForSlbProto: string;
    }

    export interface GetLoadBalancersBalancer {
        /**
         * Service address of the SLBs.
         */
        address: string;
        addressIpVersion: string;
        addressType: string;
        autoReleaseTime: number;
        backendServers: outputs.slb.GetLoadBalancersBalancerBackendServer[];
        bandwidth: number;
        createTimeStamp: number;
        deleteProtection: string;
        endTime: string;
        endTimeStamp: number;
        /**
         * ID of the SLB.
         */
        id: string;
        internetChargeType: string;
        listenerPortsAndProtocals: outputs.slb.GetLoadBalancersBalancerListenerPortsAndProtocal[];
        listenerPortsAndProtocols: outputs.slb.GetLoadBalancersBalancerListenerPortsAndProtocol[];
        loadBalancerId: string;
        loadBalancerName: string;
        loadBalancerSpec: string;
        masterZoneId: string;
        modificationProtectionReason: string;
        modificationProtectionStatus: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        paymentType: string;
        regionIdAlias: string;
        renewalCycUnit: string;
        renewalDuration: number;
        renewalStatus: string;
        /**
         * The Id of resource group which SLB belongs.
         */
        resourceGroupId: string;
        slaveZoneId: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = pulumi.output(alicloud.slb.getLoadBalancers({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetLoadBalancersBalancerBackendServer {
        description: string;
        serverId: string;
        type: string;
        weight: number;
    }

    export interface GetLoadBalancersBalancerListenerPortsAndProtocal {
        listenerPort: number;
        listenerProtocal: string;
    }

    export interface GetLoadBalancersBalancerListenerPortsAndProtocol {
        description: string;
        forwardPort: number;
        listenerForward: string;
        listenerPort: number;
        listenerProtocol: string;
    }

    export interface GetLoadBalancersSlb {
        /**
         * Service address of the SLBs.
         */
        address: string;
        /**
         * SLB creation time.
         */
        creationTime: string;
        /**
         * ID of the SLB.
         */
        id: string;
        /**
         * SLB addressType: internet if `true`, intranet if `false`. Must be `false` when `networkType` is `vpc`.
         */
        internet: boolean;
        /**
         * Master availability zone of the SLBs.
         */
        masterAvailabilityZone: string;
        /**
         * SLB name.
         */
        name: string;
        /**
         * Network type of the SLBs. Valid values: `vpc` and `classic`.
         */
        networkType: string;
        /**
         * Region ID the SLB belongs to.
         */
        regionId: string;
        /**
         * Slave availability zone of the SLBs.
         */
        slaveAvailabilityZone: string;
        /**
         * SLB current status. Possible values: `inactive`, `active` and `locked`.
         */
        status: string;
        /**
         * A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const taggedInstances = pulumi.output(alicloud.slb.getLoadBalancers({
         *     tags: {
         *         tagKey1: "tagValue1",
         *         tagKey2: "tagValue2",
         *     },
         * }, { async: true }));
         * ```
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC linked to the SLBs.
         */
        vpcId: string;
        /**
         * ID of the VSwitch linked to the SLBs.
         */
        vswitchId: string;
    }

    export interface GetMasterSlaveServerGroupsGroup {
        /**
         * master slave server group ID.
         */
        id: string;
        /**
         * master slave server group name.
         */
        name: string;
        /**
         * ECS instances associated to the group. Each element contains the following attributes:
         */
        servers: outputs.slb.GetMasterSlaveServerGroupsGroupServer[];
    }

    export interface GetMasterSlaveServerGroupsGroupServer {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * (Removed from v1.63.0) Determine if the server is executing.
         */
        isBackup: number;
        /**
         * The port used by the master slave server group.
         */
        port: number;
        /**
         * The server type of the attached ECS instance.
         */
        serverType: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetRulesSlbRule {
        /**
         * Domain name in the HTTP request where the rule applies (e.g. "*.aliyun.com").
         */
        domain: string;
        /**
         * Rule ID.
         */
        id: string;
        /**
         * Rule name.
         */
        name: string;
        /**
         * ID of the linked VServer group.
         */
        serverGroupId: string;
        /**
         * Path in the HTTP request where the rule applies (e.g. "/image").
         */
        url: string;
    }

    export interface GetServerCertificatesCertificate {
        /**
         * Id of server certificate issued by alibaba cloud.
         * * `alicloudCertificateName`- Name of server certificate issued by alibaba cloud.
         * * `isAlicloudCertificate`- Is server certificate issued by alibaba cloud or not.
         */
        alicloudCertificateId: string;
        alicloudCertificateName: string;
        /**
         * Server certificate common name.
         */
        commonName: string;
        /**
         * Server certificate created time.
         */
        createdTime: string;
        /**
         * Server certificate created timestamp.
         */
        createdTimestamp: number;
        /**
         * Server certificate expired time.
         */
        expiredTime: string;
        /**
         * Server certificate expired timestamp.
         */
        expiredTimestamp: number;
        /**
         * Server certificate fingerprint.
         */
        fingerprint: string;
        /**
         * Server certificate ID.
         */
        id: string;
        isAlicloudCertificate: boolean;
        /**
         * Server certificate name.
         */
        name: string;
        /**
         * The Id of resource group which the slb server certificates belongs.
         */
        resourceGroupId?: string;
        /**
         * Server certificate subject alternative name list.
         */
        subjectAlternativeNames: string[];
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: any};
    }

    export interface GetServerGroupsSlbServerGroup {
        /**
         * VServer group ID.
         */
        id: string;
        /**
         * VServer group name.
         */
        name: string;
        /**
         * ECS instances associated to the group. Each element contains the following attributes:
         */
        servers: outputs.slb.GetServerGroupsSlbServerGroupServer[];
    }

    export interface GetServerGroupsSlbServerGroupServer {
        /**
         * ID of the attached ECS instance.
         */
        instanceId: string;
        /**
         * Weight associated to the ECS instance.
         */
        weight: number;
    }

    export interface GetZonesZone {
        /**
         * ID of the zone.
         */
        id: string;
        /**
         * A list of slb slave zone ids in which the slb master zone.
         */
        slbSlaveZoneIds: string[];
    }

    export interface ListenerXForwardedFor {
        retriveClientIp: boolean;
        /**
         * Whether to use the XForwardedFor header to obtain the ID of the SLB instance. Default to false.
         */
        retriveSlbId?: boolean;
        /**
         * Whether to use the XForwardedFor_SLBIP header to obtain the public IP address of the SLB instance. Default to false.
         */
        retriveSlbIp?: boolean;
        /**
         * Whether to use the XForwardedFor_proto header to obtain the protocol used by the listener. Default to false.
         */
        retriveSlbProto?: boolean;
    }

    export interface MasterSlaveServerGroupServer {
        isBackup?: number;
        port: number;
        serverId: string;
        serverType?: string;
        type?: string;
        weight?: number;
    }

    export interface ServerGroupServer {
        port: number;
        serverIds: string[];
        type?: string;
        weight?: number;
    }
}

export namespace tsdb {
    export interface GetInstancesInstance {
        /**
         * Auto renew.
         */
        autoRenew: string;
        /**
         * The cpu core number of instance.
         */
        cpuNumber: string;
        /**
         * The disk type of instance. `cloudSsd` refers to SSD disk, `cloudEfficiency` refers to efficiency disk,cloud_essd refers to ESSD PL1 disk.
         */
        diskCategory: string;
        /**
         * The engine type of instance. Enumerative: `tsdbTsdb` refers to TSDB, `tsdbInfluxdb` refers to TSDB for InfluxDBï¸.
         */
        engineType: string;
        /**
         * Instance expiration time.
         */
        expiredTime: number;
        /**
         * The ID of the Instance.
         */
        id: string;
        /**
         * The alias of the instance.
         */
        instanceAlias: string;
        /**
         * The specification of the instance.
         */
        instanceClass: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The storage capacity of the instance. Unit: GB. For example, the value 50 indicates 50 GB.
         */
        instanceStorage: string;
        /**
         * The memory size of instance.
         */
        memorySize: string;
        /**
         * Instance network type.
         */
        networkType: string;
        /**
         * The billing method. Valid values: `PayAsYouGo` and `Subscription`. The `PayAsYouGo` value indicates the pay-as-you-go method, and the `Subscription` value indicates the subscription method.
         */
        paymentType: string;
        /**
         * Instance status, enumerative: ACTIVATION,DELETED, CREATING,CLASS_CHANGING,LOCKED.
         */
        status: string;
        /**
         * The vpc connection address of instance.
         */
        vpcConnectionAddress: string;
        /**
         * The ID of the virtual private cloud (VPC) that is connected to the instance.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * The ID of zone.
         */
        id: string;
        /**
         * The local name.
         */
        localName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }
}

export namespace vpc {
    export interface GetCommonBandwidthPackagesPackage {
        /**
         * The peak bandwidth of the Internet Shared Bandwidth instance.
         */
        bandwidth: string;
        /**
         * The resource ID of bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * The name of bandwidth package.
         */
        bandwidthPackageName: string;
        /**
         * The business status of the Common Bandwidth Package instance.
         */
        businessStatus: string;
        /**
         * The deletion protection of bandwidth package.
         */
        deletionProtection: boolean;
        /**
         * The description of the Common Bandwidth Package instance.
         */
        description: string;
        /**
         * The expired time of bandwidth package.
         */
        expiredTime: string;
        /**
         * Is has reservation data.
         */
        hasReservationData: boolean;
        /**
         * ID of the Common Bandwidth Package.
         */
        id: string;
        /**
         * The internet charge type of bandwidth package.
         */
        internetChargeType: string;
        /**
         * ISP of the Common Bandwidth Package.
         */
        isp: string;
        /**
         * Name of the Common Bandwidth Package.
         */
        name: string;
        /**
         * The payment type of bandwidth package.
         */
        paymentType: string;
        /**
         * Public ip addresses that in the Common Bandwidth Pakcage.
         */
        publicIpAddresses: outputs.vpc.GetCommonBandwidthPackagesPackagePublicIpAddress[];
        /**
         * The ratio of bandwidth package.
         */
        ratio: number;
        /**
         * The active time of reservation.
         */
        reservationActiveTime: string;
        /**
         * The bandwidth of reservation.
         */
        reservationBandwidth: string;
        /**
         * The charge type of reservation internet.
         */
        reservationInternetChargeType: string;
        /**
         * The type of reservation order.
         */
        reservationOrderType: string;
        /**
         * The Id of resource group which the common bandwidth package belongs.
         */
        resourceGroupId: string;
        /**
         * The service managed.
         */
        serviceManaged: number;
        /**
         * The status of bandwidth package. Valid values: `Available` and `Pending`.
         */
        status: string;
    }

    export interface GetCommonBandwidthPackagesPackagePublicIpAddress {
        allocationId: string;
        bandwidthPackageIpRelationStatus: string;
        ipAddress: string;
    }

    export interface GetEnhancedNatAvailableZonesZone {
        localName: string;
        zoneId: string;
    }

    export interface GetForwardEntriesEntry {
        /**
         * The public IP address.
         */
        externalIp: string;
        /**
         * The public port.
         */
        externalPort: string;
        /**
         * The forward entry ID.
         */
        forwardEntryId: string;
        /**
         * The name of forward entry.
         */
        forwardEntryName: string;
        /**
         * The ID of the Forward Entry.
         */
        id: string;
        /**
         * The private IP address.
         */
        internalIp: string;
        /**
         * The internal port.
         */
        internalPort: string;
        /**
         * The ip protocol. Valid values: `any`,`tcp` and `udp`.
         */
        ipProtocol: string;
        /**
         * The forward entry name.
         */
        name: string;
        /**
         * The status of farward entry. Valid value `Available`, `Deleting` and `Pending`.
         */
        status: string;
    }

    export interface GetHavipsHavip {
        /**
         * EIP bound to HaVip.
         */
        associatedEipAddresses: string[];
        /**
         * An ECS instance that is bound to HaVip.
         */
        associatedInstances: string[];
        /**
         * Dependence of a HaVip instance.
         */
        description: string;
        /**
         * The  ID of the resource.
         */
        havipId: string;
        /**
         * The name of the HaVip instance.
         */
        havipName: string;
        /**
         * The ID of the Ha Vip.
         */
        id: string;
        /**
         * IP address of private network.
         */
        ipAddress: string;
        /**
         * The primary instance ID bound to HaVip.
         */
        masterInstanceId: string;
        /**
         * The status.
         */
        status: string;
        /**
         * The VPC ID to which the HaVip instance belongs.
         */
        vpcId: string;
        /**
         * The vswitch id.
         */
        vswitchId: string;
    }

    export interface GetNatGatewaysGateway {
        /**
         * The state of the NAT gateway.
         */
        businessStatus: string;
        /**
         * Indicates whether deletion protection is enabled.
         */
        deletionProtection: boolean;
        /**
         * The description of the NAT gateway.
         */
        description: string;
        /**
         * Indicates whether the traffic monitoring feature is enabled.
         */
        ecsMetricEnabled: boolean;
        /**
         * The time when the NAT gateway expires.
         */
        expiredTime: string;
        /**
         * The ID of the DNAT table.
         */
        forwardTableIds: string[];
        /**
         * The ID of the NAT gateway.
         */
        id: string;
        /**
         * The metering method of the NAT gateway.
         */
        internetChargeType: string;
        /**
         * The ip address of the bind eip.
         */
        ipLists: string[];
        /**
         * Name of the NAT gateway.
         */
        name: string;
        /**
         * The ID of the NAT gateway.
         */
        natGatewayId: string;
        /**
         * The name of NAT gateway.
         */
        natGatewayName: string;
        /**
         * The nat type of NAT gateway. Valid values `Enhanced` and `Normal`. Default value `Normal`.
         */
        natType: string;
        /**
         * The payment type of NAT gateway. Valid values `PayAsYouGo` and `Subscription`.
         */
        paymentType: string;
        /**
         * The resource group id of NAT gateway.
         */
        resourceGroupId: string;
        /**
         * The ID of the SNAT table that is associated with the NAT gateway.
         */
        snatTableIds: string[];
        /**
         * The specification of the NAT gateway.
         */
        spec: string;
        /**
         * The specification of NAT gateway. Valid values `Middle`, `Large`, `Small` and `XLarge.1`. Default value is `Small`.
         */
        specification: string;
        /**
         * The status of NAT gateway. Valid values `Available`, `Converting`, `Creating`, `Deleting` and `Modifying`.
         */
        status: string;
        /**
         * The tags of NAT gateway.
         */
        tags: {[key: string]: any};
        /**
         * The ID of the VPC.
         */
        vpcId: string;
        /**
         * The ID of the vSwitch to which the NAT gateway belongs.
         */
        vswitchId: string;
    }

    export interface GetNetworkAclsAcl {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * Output direction rule information.
         */
        egressAclEntries: outputs.vpc.GetNetworkAclsAclEgressAclEntry[];
        /**
         * The ID of the Network Acl.
         */
        id: string;
        /**
         * Entry direction rule information.
         */
        ingressAclEntries: outputs.vpc.GetNetworkAclsAclIngressAclEntry[];
        /**
         * The first ID of the resource.
         */
        networkAclId: string;
        /**
         * The name of the network ACL.
         */
        networkAclName: string;
        /**
         * The associated resource.
         */
        resources: outputs.vpc.GetNetworkAclsAclResource[];
        /**
         * The state of the network ACL.
         */
        status: string;
        /**
         * The ID of the associated VPC.
         */
        vpcId: string;
    }

    export interface GetNetworkAclsAclEgressAclEntry {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * The destination address segment.
         */
        destinationCidrIp: string;
        /**
         * The name of the entry direction rule entry.
         */
        networkAclEntryName: string;
        /**
         * The authorization policy.
         */
        policy: string;
        /**
         * Source port range.
         */
        port: string;
        /**
         * Transport layer protocol.
         */
        protocol: string;
    }

    export interface GetNetworkAclsAclIngressAclEntry {
        /**
         * Description of the entry direction rule.
         */
        description: string;
        /**
         * The name of the entry direction rule entry.
         */
        networkAclEntryName: string;
        /**
         * The authorization policy.
         */
        policy: string;
        /**
         * Source port range.
         */
        port: string;
        /**
         * Transport layer protocol.
         */
        protocol: string;
        /**
         * The source address field.
         */
        sourceCidrIp: string;
    }

    export interface GetNetworkAclsAclResource {
        /**
         * The ID of the associated resource.
         */
        resourceId: string;
        /**
         * The type of the associated resource.
         */
        resourceType: string;
        /**
         * The state of the network ACL.
         */
        status: string;
    }

    export interface GetNetworksVpc {
        /**
         * Filter results by a specific CIDR block. For example: "172.16.0.0/12".
         */
        cidrBlock: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the VPC
         */
        description: string;
        /**
         * ID of the VPC.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * Indicate whether the VPC is the default one in the specified region.
         */
        isDefault: boolean;
        /**
         * ID of the region where the VPC is located.
         */
        regionId: string;
        /**
         * The Id of resource group which VPC belongs.
         */
        resourceGroupId: string;
        /**
         * Route table ID of the VRouter.
         */
        routeTableId: string;
        /**
         * The ID of the VRouter.
         */
        routerId: string;
        /**
         * A list of secondary IPv4 CIDR blocks of the VPC.
         */
        secondaryCidrBlocks: string[];
        /**
         * Filter results by a specific status. Valid value are `Pending` and `Available`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * A list of user CIDRs.
         */
        userCidrs: string[];
        /**
         * ID of the VPC.
         */
        vpcId: string;
        /**
         * The name of the VPC.
         */
        vpcName: string;
        /**
         * ID of the VRouter.
         */
        vrouterId: string;
        /**
         * List of VSwitch IDs in the specified VPC
         */
        vswitchIds: string[];
    }

    export interface GetRouteEntriesEntry {
        /**
         * The destination CIDR block of the route entry.
         */
        cidrBlock: string;
        /**
         * The instance ID of the next hop.
         */
        instanceId: string;
        /**
         * The type of the next hop.
         */
        nextHopType: string;
        /**
         * The ID of the router table to which the route entry belongs.
         */
        routeTableId: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The type of the route entry.
         */
        type: string;
    }

    export interface GetRouteTablesTable {
        /**
         * The description of the route table instance.
         */
        description: string;
        /**
         * ID of the Route Table.
         */
        id: string;
        /**
         * Name of the route table.
         */
        name: string;
        /**
         * The Id of resource group which route tables belongs.
         */
        resourceGroupId: string;
        /**
         * The route table id.
         */
        routeTableId: string;
        /**
         * The route table name.
         */
        routeTableName: string;
        /**
         * The type of route table.
         */
        routeTableType: string;
        /**
         * The router ID.
         */
        routerId: string;
        /**
         * The route type of route table. Valid values: `VRouter` and `VBR`.
         */
        routerType: string;
        /**
         * The status of resource. Valid values: `Available` and `Pending`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * Vpc id of the route table.
         */
        vpcId: string;
        /**
         * A list of vswitch id.
         */
        vswitchIds: string[];
    }

    export interface GetRouterInterfacesInterface {
        /**
         * ID of the access point used by the VBR.
         */
        accessPointId: string;
        /**
         * Router interface creation time.
         */
        creationTime: string;
        /**
         * Router interface description.
         */
        description: string;
        /**
         * Source IP address used to perform health check on the physical connection.
         */
        healthCheckSourceIp: string;
        /**
         * Destination IP address used to perform health check on the physical connection.
         */
        healthCheckTargetIp: string;
        /**
         * Router interface ID.
         */
        id: string;
        /**
         * Router interface name.
         */
        name: string;
        /**
         * ID of the peer router interface.
         */
        oppositeInterfaceId: string;
        /**
         * Account ID of the owner of the peer router interface.
         */
        oppositeInterfaceOwnerId: string;
        /**
         * Peer router region ID.
         */
        oppositeRegionId: string;
        /**
         * Peer router ID.
         */
        oppositeRouterId: string;
        /**
         * Router type in the peer region. Possible values: `VRouter` and `VBR`.
         */
        oppositeRouterType: string;
        /**
         * Role of the router interface. Valid values are `InitiatingSide` (connection initiator) and 
         * `AcceptingSide` (connection receiver). The value of this parameter must be `InitiatingSide` if the `routerType` is set to `VBR`.
         */
        role: string;
        /**
         * ID of the VRouter located in the local region.
         */
        routerId: string;
        /**
         * Router type in the local region. Valid values are `VRouter` and `VBR` (physical connection).
         */
        routerType: string;
        /**
         * Specification of the link, such as `Small.1` (10Mb), `Middle.1` (100Mb), `Large.2` (2Gb), ...etc.
         */
        specification: string;
        /**
         * Expected status. Valid values are `Active`, `Inactive` and `Idle`.
         */
        status: string;
        /**
         * ID of the VPC that owns the router in the local region.
         */
        vpcId: string;
    }

    export interface GetSnatEntriesEntry {
        /**
         * The ID of the Snat Entry.
         */
        id: string;
        /**
         * The ID of snat entry.
         */
        snatEntryId: string;
        /**
         * The name of snat entry.
         */
        snatEntryName: string;
        /**
         * The public IP of the Snat Entry.
         */
        snatIp: string;
        /**
         * The source CIDR block of the Snat Entry.
         */
        sourceCidr: string;
        /**
         * The source vswitch ID.
         */
        sourceVswitchId: string;
        /**
         * The status of the Snat Entry. Valid values: `Available`, `Deleting` and `Pending`.
         */
        status: string;
    }

    export interface GetSslVpnClientCertsCert {
        /**
         * The time of creation.
         */
        createTime: string;
        /**
         * The expiration time of the client certificate.
         */
        endTime: number;
        /**
         * ID of the SSL-VPN client certificate.
         */
        id: string;
        /**
         * The name of the SSL-VPN client certificate.
         */
        name: string;
        /**
         * Use the SSL-VPN server ID as the search key.
         */
        sslVpnServerId: string;
        /**
         * The status of the client certificate. valid value:expiring-soon, normal, expired.
         */
        status: string;
    }

    export interface GetSslVpnServersServer {
        /**
         * The encryption algorithm used.
         */
        cipher: string;
        /**
         * The IP address pool of the client.
         */
        clientIpPool: string;
        /**
         * Whether to compress.
         */
        compress: boolean;
        /**
         * The number of current connections.
         */
        connections: number;
        /**
         * The time of creation.
         */
        createTime: string;
        /**
         * The ID of the SSL-VPN server.
         */
        id: string;
        /**
         * The public IP.
         */
        internetIp: string;
        /**
         * The local subnet of the VPN connection.
         */
        localSubnet: string;
        /**
         * The maximum number of connections.
         */
        maxConnections: number;
        /**
         * The name of the SSL-VPN server.
         */
        name: string;
        /**
         * The port used by the SSL-VPN server.
         */
        port: number;
        /**
         * The protocol used by the SSL-VPN server.
         */
        proto: string;
        /**
         * Use the VPN gateway ID as the search key.
         */
        vpnGatewayId: string;
    }

    export interface GetSwitchesVswitch {
        /**
         * The available ip address count of the VSwitch.
         */
        availableIpAddressCount: number;
        /**
         * Filter results by a specific CIDR block. For example: "172.16.0.0/12".
         */
        cidrBlock: string;
        /**
         * Time of creation.
         */
        creationTime: string;
        /**
         * Description of the VSwitch.
         */
        description: string;
        /**
         * ID of the VSwitch.
         */
        id: string;
        /**
         * Indicate whether the VSwitch is created by the system.
         */
        isDefault: boolean;
        /**
         * Name of the VSwitch.
         */
        name: string;
        /**
         * The Id of resource group which VSWitch belongs.
         */
        resourceGroupId: string;
        /**
         * The route table ID of the VSwitch.
         */
        routeTableId: string;
        /**
         * The status of the VSwitch. Valid values: `Available` and `Pending`.
         */
        status: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: any};
        /**
         * ID of the VPC that owns the VSwitch.
         */
        vpcId: string;
        /**
         * ID of the VSwitch.
         */
        vswitchId: string;
        /**
         * The name of the VSwitch.
         */
        vswitchName: string;
        /**
         * The availability zone of the VSwitch.
         */
        zoneId: string;
    }

    export interface GetVpcFlowLogsLog {
        /**
         * The Description of flow log.
         */
        description: string;
        /**
         * The flow log ID.
         */
        flowLogId: string;
        /**
         * The flow log name.
         */
        flowLogName: string;
        /**
         * The ID of the Flow Log.
         */
        id: string;
        /**
         * The log store name.
         */
        logStoreName: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The resource id.
         */
        resourceId: string;
        /**
         * The resource type.
         */
        resourceType: string;
        /**
         * The status of flow log.
         */
        status: string;
        /**
         * The traffic type.
         */
        trafficType: string;
    }

    export interface NetworkAclAttachmentResource {
        /**
         * The resource id that the network acl will associate with.
         */
        resourceId: string;
        /**
         * The resource id that the network acl will associate with. Only support `VSwitch` now.
         */
        resourceType: string;
    }

    export interface NetworkAclEgressAclEntry {
        /**
         * The description of egress entries.
         */
        description?: string;
        /**
         * The destination cidr ip of egress entries.
         */
        destinationCidrIp?: string;
        /**
         * The entry name of egress entries.
         */
        networkAclEntryName?: string;
        /**
         * The policy of egress entries. Valid values `accept` and `drop`.
         */
        policy?: string;
        /**
         * The port of egress entries.
         */
        port?: string;
        /**
         * The protocol of egress entries. Valid values `icmp`,`gre`,`tcp`,`udp`, and `all`.
         */
        protocol?: string;
    }

    export interface NetworkAclEntriesEgress {
        /**
         * The description of the egress entry.
         */
        description: string;
        /**
         * The destination ip of the egress entry.
         */
        destinationCidrIp: string;
        /**
         * The entry type of the egress entry. It must be `custom` or `system`. Default value is `custom`.
         */
        entryType: string;
        /**
         * The name of the egress entry.
         */
        name: string;
        /**
         * The policy of the egress entry. It must be `accept` or `drop`.
         */
        policy: string;
        /**
         * The port of the egress entry.
         */
        port: string;
        /**
         * The protocol of the egress entry.
         */
        protocol: string;
    }

    export interface NetworkAclEntriesIngress {
        /**
         * The description of the egress entry.
         */
        description: string;
        /**
         * The entry type of the egress entry. It must be `custom` or `system`. Default value is `custom`.
         */
        entryType: string;
        /**
         * The name of the egress entry.
         */
        name: string;
        /**
         * The policy of the egress entry. It must be `accept` or `drop`.
         */
        policy: string;
        /**
         * The port of the egress entry.
         */
        port: string;
        /**
         * The protocol of the egress entry.
         */
        protocol: string;
        /**
         * The source ip of the ingress entry.
         */
        sourceCidrIp: string;
    }

    export interface NetworkAclIngressAclEntry {
        /**
         * The description of egress entries.
         */
        description?: string;
        /**
         * The entry name of egress entries.
         */
        networkAclEntryName?: string;
        /**
         * The policy of egress entries. Valid values `accept` and `drop`.
         */
        policy?: string;
        /**
         * The port of egress entries.
         */
        port?: string;
        /**
         * The protocol of egress entries. Valid values `icmp`,`gre`,`tcp`,`udp`, and `all`.
         */
        protocol?: string;
        /**
         * The source cidr ip of ingress entries.
         */
        sourceCidrIp?: string;
    }

    export interface NetworkAclResource {
        /**
         * The ID of the associated resource.
         */
        resourceId?: string;
        /**
         * The type of the associated resource. Valid values `VSwitch`.
         */
        resourceType?: string;
    }
}

export namespace vpn {
    export interface ConnectionIkeConfig {
        /**
         * The authentication algorithm of phase-one negotiation. Valid value: md5 | sha1 | sha256 | sha384 | sha512 |. Default value: sha1
         */
        ikeAuthAlg?: string;
        /**
         * The encryption algorithm of phase-one negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default Valid value: aes
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation. The valid value of n is [0, 86400], the unit is second and the default value is 86400.
         */
        ikeLifetime?: number;
        /**
         * The identification of the VPN gateway.
         */
        ikeLocalId?: string;
        /**
         * The negotiation mode of IKE V1. Valid value: main (main mode) | aggressive (aggressive mode). Default value: main
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation. Valid value: group1 | group2 | group5 | group14 | group24. Default value: group2
         */
        ikePfs?: string;
        /**
         * The identification of the customer gateway.
         */
        ikeRemoteId?: string;
        /**
         * The version of the IKE protocol. Valid value: ikev1 | ikev2. Default value: ikev1
         */
        ikeVersion?: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
    }

    export interface ConnectionIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation. Valid value: md5 | sha1 | sha256 | sha384 | sha512 |. Default value: sha1
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation. Valid value: aes | aes192 | aes256 | des | 3des. Default value: aes
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation. The valid value is [0, 86400], the unit is second and the default value is 86400.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation. Valid value: group1 | group2 | group5 | group14 | group24| disabled. Default value: group2
         */
        ipsecPfs?: string;
    }

    export interface GetConnectionsConnection {
        createTime: string;
        /**
         * Use the VPN customer gateway ID as the search key.
         */
        customerGatewayId: string;
        effectImmediately: boolean;
        /**
         * ID of the VPN connection.
         */
        id: string;
        /**
         * The configurations of phase-one negotiation.
         */
        ikeConfigs?: outputs.vpn.GetConnectionsConnectionIkeConfig[];
        /**
         * The configurations of phase-two negotiation.
         */
        ipsecConfigs?: outputs.vpn.GetConnectionsConnectionIpsecConfig[];
        /**
         * The local subnet of the VPN connection.
         */
        localSubnet: string;
        /**
         * The name of the VPN connection.
         */
        name: string;
        /**
         * The remote subnet of the VPN connection.
         */
        remoteSubnet: string;
        /**
         * The status of the VPN connection, valid value:ike_sa_not_established, ike_sa_established, ipsec_sa_not_established, ipsec_sa_established.
         */
        status: string;
        /**
         * Use the VPN gateway ID as the search key.
         */
        vpnGatewayId: string;
    }

    export interface GetConnectionsConnectionIkeConfig {
        /**
         * The authentication algorithm of phase-one negotiation.
         */
        ikeAuthAlg?: string;
        /**
         * The encryption algorithm of phase-one negotiation.
         */
        ikeEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-one negotiation.
         */
        ikeLifetime?: number;
        /**
         * The identification of the VPN gateway.
         */
        ikeLocalId?: string;
        /**
         * The negotiation mode of IKE phase-one.
         */
        ikeMode?: string;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-one negotiation.
         */
        ikePfs?: string;
        /**
         * The identification of the customer gateway.
         */
        ikeRemoteId?: string;
        /**
         * The version of the IKE protocol.
         */
        ikeVersion?: string;
        /**
         * Used for authentication between the IPsec VPN gateway and the customer gateway.
         */
        psk?: string;
    }

    export interface GetConnectionsConnectionIpsecConfig {
        /**
         * The authentication algorithm of phase-two negotiation.
         */
        ipsecAuthAlg?: string;
        /**
         * The encryption algorithm of phase-two negotiation.
         */
        ipsecEncAlg?: string;
        /**
         * The SA lifecycle as the result of phase-two negotiation.
         */
        ipsecLifetime?: number;
        /**
         * The Diffie-Hellman key exchange algorithm used by phase-two negotiation.
         */
        ipsecPfs?: string;
    }

    export interface GetCustomerGatewaysGateway {
        /**
         * The creation time of the VPN customer gateway.
         */
        createTime: string;
        /**
         * The description of the VPN customer gateway.
         */
        description: string;
        /**
         * ID of the VPN customer gateway .
         */
        id: string;
        /**
         * The ip address of the VPN customer gateway.
         */
        ipAddress: string;
        /**
         * The name of the VPN customer gateway.
         */
        name: string;
    }

    export interface GetGatewaysGateway {
        /**
         * Limit search to specific business status - valid value is "Normal", "FinancialLocked".
         */
        businessStatus: string;
        /**
         * The creation time of the VPN gateway.
         */
        createTime: string;
        /**
         * The description of the VPN
         */
        description: string;
        /**
         * Whether the ipsec function is enabled.
         */
        enableIpsec: string;
        /**
         * Whether the ssl function is enabled.
         */
        enableSsl: string;
        /**
         * The expiration time of the VPN gateway.
         */
        endTime: string;
        /**
         * ID of the VPN.
         */
        id: string;
        /**
         * The charge type of the VPN gateway.
         */
        instanceChargeType: string;
        /**
         * The internet ip of the VPN.
         */
        internetIp: string;
        /**
         * The name of the VPN.
         */
        name: string;
        /**
         * The Specification of the VPN
         */
        specification: string;
        /**
         * Total count of ssl vpn connections.
         */
        sslConnections: number;
        /**
         * Limit search to specific status - valid value is "Init", "Provisioning", "Active", "Updating", "Deleting".
         */
        status: string;
        /**
         * Use the VPC ID as the search key.
         */
        vpcId: string;
    }
}

export namespace waf {
    export interface DomainLogHeader {
        key?: string;
        value?: string;
    }

    export interface GetDomainsDomain {
        /**
         * The type of the WAF cluster.
         */
        clusterType: string;
        /**
         * The CNAME record assigned by the WAF instance to the specified domain.
         */
        cname: string;
        /**
         * The connection timeout for WAF exclusive clusters. Valid values: `PhysicalCluster` and `VirtualCluster`. Default to `PhysicalCluster`.
         */
        connectionTime: number;
        /**
         * Field `domain` has been deprecated from version 1.94.0. Use `domainName` instead.
         */
        domain: string;
        /**
         * Name of the domain.
         */
        domainName: string;
        /**
         * List of the HTTP 2.0 ports.
         */
        http2Ports: string[];
        /**
         * List of the HTTP ports.
         */
        httpPorts: string[];
        /**
         * Specifies whether to enable the HTTP back-to-origin feature. After this feature is enabled, the WAF instance can use HTTP to forward HTTPS requests to the origin server.
         */
        httpToUserIp: string;
        /**
         * List of the HTTPS ports.
         */
        httpsPorts: string[];
        /**
         * Specifies whether to redirect HTTP requests as HTTPS requests. Valid values: `On` and `Off`. Default to `Off`.
         */
        httpsRedirect: string;
        /**
         * The ID of domain self ID, value as `domainName`.
         */
        id: string;
        /**
         * Specifies whether to configure a Layer-7 proxy, such as Anti-DDoS Pro or CDN, to filter the inbound traffic before it is forwarded to WAF. Valid values: `On` and "Off". Default to `Off`.
         */
        isAccessProduct: string;
        /**
         * The load balancing algorithm that is used to forward requests to the origin. Valid values: `IpHash` and `RoundRobin`. Default to `IpHash`.
         */
        loadBalancing: string;
        /**
         * The key-value pair that is used to mark the traffic that flows through WAF to the domain. Each item contains two field:
         * * `key`: The key of label.
         * * `value`: The value of label.
         */
        logHeaders: outputs.waf.GetDomainsDomainLogHeader[];
        /**
         * The read timeout of a WAF exclusive cluster. Unit: seconds.
         */
        readTime: number;
        /**
         * The ID of the resource group to which the queried domain belongs in Resource Management.
         */
        resourceGroupId: string;
        /**
         * List of the IP address or domain of the origin server to which the specified domain points.
         */
        sourceIps: string[];
        /**
         * The system data identifier that is used to control optimistic locking.
         */
        version: number;
        /**
         * The timeout period for a WAF exclusive cluster write connection. Unit: seconds.
         */
        writeTime: number;
    }

    export interface GetDomainsDomainLogHeader {
        key: string;
        value: string;
    }

    export interface GetInstancesInstance {
        /**
         * The timestamp (in seconds) indicating when the WAF instance expires.
         */
        endDate: number;
        /**
         * The ID of the WAF instance.
         */
        id: string;
        /**
         * Indicates whether the WAF instance has overdue payments.
         */
        inDebt: number;
        /**
         * The ID of WAF the instance.
         */
        instanceId: string;
        /**
         * The number of days before the trial period of the WAF instance expires.
         */
        remainDay: number;
        /**
         * The status of WAF instance to filter results. Optional value: `0`: The instance has expired, `1` : The instance has not expired and is working properly.
         */
        status: number;
        subscriptionType: string;
        /**
         * Indicates whether this is a trial instance.
         */
        trial: number;
    }
}

export namespace yundun {
    export interface GetBastionHostInstancesInstance {
        /**
         * The instance's remark.
         */
        description: string;
        /**
         * The instance's id.
         */
        id: string;
        /**
         * The instance's status.
         */
        instanceStatus: string;
        licenseCode: string;
        /**
         * The instance's private domain name.
         */
        privateDomain: string;
        /**
         * The instance's public domain name.
         */
        publicDomain: string;
        /**
         * The instance's public network access configuration.
         */
        publicNetworkAccess: boolean;
        /**
         * The instance's security group configuration.
         */
        securityGroupIds: string[];
        /**
         * A map of tags assigned to the bastionhost instance. It must be in the format:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as alicloud from "@pulumi/alicloud";
         *
         * const instance = pulumi.output(alicloud.yundun.getBastionHostInstances({
         *     tags: {
         *         tagKey1: "tagValue1",
         *     },
         * }, { async: true }));
         * ```
         */
        tags?: {[key: string]: any};
        /**
         * The instance's vSwitch ID.
         */
        userVswitchId: string;
    }

    export interface GetDBAuditInstanceInstance {
        description: string;
        id: string;
        instanceStatus: string;
        licenseCode: string;
        privateDomain: string;
        publicDomain: string;
        publicNetworkAccess: boolean;
        tags?: {[key: string]: any};
        userVswitchId: string;
    }
}
