// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sls

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Log Service (SLS) Index resource.
//
// For information about Log Service (SLS) Index and how to use it, see [What is Index](https://next.api.alibabacloud.com/document/Sls/2020-12-30/CreateIndex).
//
// > **NOTE:** Available since v1.260.0.
//
// ## Example Usage
//
// # Basic Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/log"
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/sls"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			name := "terraform-example"
//			if param := cfg.Get("name"); param != "" {
//				name = param
//			}
//			logstoreName := "logstore-example"
//			if param := cfg.Get("logstoreName"); param != "" {
//				logstoreName = param
//			}
//			projectName := "project-for-index-terraform-example"
//			if param := cfg.Get("projectName"); param != "" {
//				projectName = param
//			}
//			_default, err := log.NewProject(ctx, "default", &log.ProjectArgs{
//				Description: pulumi.String("terraform example"),
//				ProjectName: pulumi.String(projectName),
//			})
//			if err != nil {
//				return err
//			}
//			defaultStore, err := log.NewStore(ctx, "default", &log.StoreArgs{
//				HotTtl:          pulumi.Int(7),
//				RetentionPeriod: pulumi.Int(30),
//				ShardCount:      pulumi.Int(2),
//				ProjectName:     _default.ProjectName,
//				LogstoreName:    pulumi.String(logstoreName),
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"example": map[string]interface{}{
//					"caseSensitive": false,
//					"token": []string{
//						"\n",
//						"	",
//						",",
//						" ",
//						";",
//						"\"",
//						"'",
//						"(",
//						")",
//						"{",
//						"}",
//						"[",
//						"]",
//						"<",
//						">",
//						"?",
//						"/",
//						"#",
//						":",
//					},
//					"type":      "text",
//					"doc_value": false,
//					"alias":     "",
//					"chn":       false,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			_, err = sls.NewIndex(ctx, "default", &sls.IndexArgs{
//				Line: &sls.IndexLineArgs{
//					Chn:           pulumi.Bool(true),
//					CaseSensitive: pulumi.Bool(true),
//					Tokens: pulumi.StringArray{
//						pulumi.String("a"),
//					},
//					ExcludeKeys: pulumi.StringArray{
//						pulumi.String("t"),
//					},
//				},
//				Keys:         pulumi.String(json0),
//				LogstoreName: defaultStore.LogstoreName,
//				ProjectName:  pulumi.String(projectName),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Log Service (SLS) Index can be imported using the id, e.g.
//
// ```sh
// $ pulumi import alicloud:sls/index:Index example <project_name>:<logstore_name>
// ```
type Index struct {
	pulumi.CustomResourceState

	// Field index
	Keys pulumi.StringPtrOutput `pulumi:"keys"`
	// Full-text index See `line` below.
	Line IndexLinePtrOutput `pulumi:"line"`
	// Whether log clustering is enabled
	LogReduce pulumi.BoolPtrOutput `pulumi:"logReduce"`
	// The blacklist of the cluster fields of log clustering is filtered only when log clustering is enabled.
	LogReduceBlackLists pulumi.StringArrayOutput `pulumi:"logReduceBlackLists"`
	// The whitelist of the cluster fields for log clustering. This filter is valid only when log clustering is enabled.
	LogReduceWhiteLists pulumi.StringArrayOutput `pulumi:"logReduceWhiteLists"`
	// Logstore name
	LogstoreName pulumi.StringOutput `pulumi:"logstoreName"`
	// Maximum length of statistical field
	MaxTextLen pulumi.IntPtrOutput `pulumi:"maxTextLen"`
	// Project name
	ProjectName pulumi.StringOutput `pulumi:"projectName"`
}

// NewIndex registers a new resource with the given unique name, arguments, and options.
func NewIndex(ctx *pulumi.Context,
	name string, args *IndexArgs, opts ...pulumi.ResourceOption) (*Index, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LogstoreName == nil {
		return nil, errors.New("invalid value for required argument 'LogstoreName'")
	}
	if args.ProjectName == nil {
		return nil, errors.New("invalid value for required argument 'ProjectName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Index
	err := ctx.RegisterResource("alicloud:sls/index:Index", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIndex gets an existing Index resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIndex(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IndexState, opts ...pulumi.ResourceOption) (*Index, error) {
	var resource Index
	err := ctx.ReadResource("alicloud:sls/index:Index", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Index resources.
type indexState struct {
	// Field index
	Keys *string `pulumi:"keys"`
	// Full-text index See `line` below.
	Line *IndexLine `pulumi:"line"`
	// Whether log clustering is enabled
	LogReduce *bool `pulumi:"logReduce"`
	// The blacklist of the cluster fields of log clustering is filtered only when log clustering is enabled.
	LogReduceBlackLists []string `pulumi:"logReduceBlackLists"`
	// The whitelist of the cluster fields for log clustering. This filter is valid only when log clustering is enabled.
	LogReduceWhiteLists []string `pulumi:"logReduceWhiteLists"`
	// Logstore name
	LogstoreName *string `pulumi:"logstoreName"`
	// Maximum length of statistical field
	MaxTextLen *int `pulumi:"maxTextLen"`
	// Project name
	ProjectName *string `pulumi:"projectName"`
}

type IndexState struct {
	// Field index
	Keys pulumi.StringPtrInput
	// Full-text index See `line` below.
	Line IndexLinePtrInput
	// Whether log clustering is enabled
	LogReduce pulumi.BoolPtrInput
	// The blacklist of the cluster fields of log clustering is filtered only when log clustering is enabled.
	LogReduceBlackLists pulumi.StringArrayInput
	// The whitelist of the cluster fields for log clustering. This filter is valid only when log clustering is enabled.
	LogReduceWhiteLists pulumi.StringArrayInput
	// Logstore name
	LogstoreName pulumi.StringPtrInput
	// Maximum length of statistical field
	MaxTextLen pulumi.IntPtrInput
	// Project name
	ProjectName pulumi.StringPtrInput
}

func (IndexState) ElementType() reflect.Type {
	return reflect.TypeOf((*indexState)(nil)).Elem()
}

type indexArgs struct {
	// Field index
	Keys *string `pulumi:"keys"`
	// Full-text index See `line` below.
	Line *IndexLine `pulumi:"line"`
	// Whether log clustering is enabled
	LogReduce *bool `pulumi:"logReduce"`
	// The blacklist of the cluster fields of log clustering is filtered only when log clustering is enabled.
	LogReduceBlackLists []string `pulumi:"logReduceBlackLists"`
	// The whitelist of the cluster fields for log clustering. This filter is valid only when log clustering is enabled.
	LogReduceWhiteLists []string `pulumi:"logReduceWhiteLists"`
	// Logstore name
	LogstoreName string `pulumi:"logstoreName"`
	// Maximum length of statistical field
	MaxTextLen *int `pulumi:"maxTextLen"`
	// Project name
	ProjectName string `pulumi:"projectName"`
}

// The set of arguments for constructing a Index resource.
type IndexArgs struct {
	// Field index
	Keys pulumi.StringPtrInput
	// Full-text index See `line` below.
	Line IndexLinePtrInput
	// Whether log clustering is enabled
	LogReduce pulumi.BoolPtrInput
	// The blacklist of the cluster fields of log clustering is filtered only when log clustering is enabled.
	LogReduceBlackLists pulumi.StringArrayInput
	// The whitelist of the cluster fields for log clustering. This filter is valid only when log clustering is enabled.
	LogReduceWhiteLists pulumi.StringArrayInput
	// Logstore name
	LogstoreName pulumi.StringInput
	// Maximum length of statistical field
	MaxTextLen pulumi.IntPtrInput
	// Project name
	ProjectName pulumi.StringInput
}

func (IndexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*indexArgs)(nil)).Elem()
}

type IndexInput interface {
	pulumi.Input

	ToIndexOutput() IndexOutput
	ToIndexOutputWithContext(ctx context.Context) IndexOutput
}

func (*Index) ElementType() reflect.Type {
	return reflect.TypeOf((**Index)(nil)).Elem()
}

func (i *Index) ToIndexOutput() IndexOutput {
	return i.ToIndexOutputWithContext(context.Background())
}

func (i *Index) ToIndexOutputWithContext(ctx context.Context) IndexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexOutput)
}

// IndexArrayInput is an input type that accepts IndexArray and IndexArrayOutput values.
// You can construct a concrete instance of `IndexArrayInput` via:
//
//	IndexArray{ IndexArgs{...} }
type IndexArrayInput interface {
	pulumi.Input

	ToIndexArrayOutput() IndexArrayOutput
	ToIndexArrayOutputWithContext(context.Context) IndexArrayOutput
}

type IndexArray []IndexInput

func (IndexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Index)(nil)).Elem()
}

func (i IndexArray) ToIndexArrayOutput() IndexArrayOutput {
	return i.ToIndexArrayOutputWithContext(context.Background())
}

func (i IndexArray) ToIndexArrayOutputWithContext(ctx context.Context) IndexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexArrayOutput)
}

// IndexMapInput is an input type that accepts IndexMap and IndexMapOutput values.
// You can construct a concrete instance of `IndexMapInput` via:
//
//	IndexMap{ "key": IndexArgs{...} }
type IndexMapInput interface {
	pulumi.Input

	ToIndexMapOutput() IndexMapOutput
	ToIndexMapOutputWithContext(context.Context) IndexMapOutput
}

type IndexMap map[string]IndexInput

func (IndexMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Index)(nil)).Elem()
}

func (i IndexMap) ToIndexMapOutput() IndexMapOutput {
	return i.ToIndexMapOutputWithContext(context.Background())
}

func (i IndexMap) ToIndexMapOutputWithContext(ctx context.Context) IndexMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexMapOutput)
}

type IndexOutput struct{ *pulumi.OutputState }

func (IndexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Index)(nil)).Elem()
}

func (o IndexOutput) ToIndexOutput() IndexOutput {
	return o
}

func (o IndexOutput) ToIndexOutputWithContext(ctx context.Context) IndexOutput {
	return o
}

// Field index
func (o IndexOutput) Keys() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Index) pulumi.StringPtrOutput { return v.Keys }).(pulumi.StringPtrOutput)
}

// Full-text index See `line` below.
func (o IndexOutput) Line() IndexLinePtrOutput {
	return o.ApplyT(func(v *Index) IndexLinePtrOutput { return v.Line }).(IndexLinePtrOutput)
}

// Whether log clustering is enabled
func (o IndexOutput) LogReduce() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Index) pulumi.BoolPtrOutput { return v.LogReduce }).(pulumi.BoolPtrOutput)
}

// The blacklist of the cluster fields of log clustering is filtered only when log clustering is enabled.
func (o IndexOutput) LogReduceBlackLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Index) pulumi.StringArrayOutput { return v.LogReduceBlackLists }).(pulumi.StringArrayOutput)
}

// The whitelist of the cluster fields for log clustering. This filter is valid only when log clustering is enabled.
func (o IndexOutput) LogReduceWhiteLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Index) pulumi.StringArrayOutput { return v.LogReduceWhiteLists }).(pulumi.StringArrayOutput)
}

// Logstore name
func (o IndexOutput) LogstoreName() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.LogstoreName }).(pulumi.StringOutput)
}

// Maximum length of statistical field
func (o IndexOutput) MaxTextLen() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Index) pulumi.IntPtrOutput { return v.MaxTextLen }).(pulumi.IntPtrOutput)
}

// Project name
func (o IndexOutput) ProjectName() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.ProjectName }).(pulumi.StringOutput)
}

type IndexArrayOutput struct{ *pulumi.OutputState }

func (IndexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Index)(nil)).Elem()
}

func (o IndexArrayOutput) ToIndexArrayOutput() IndexArrayOutput {
	return o
}

func (o IndexArrayOutput) ToIndexArrayOutputWithContext(ctx context.Context) IndexArrayOutput {
	return o
}

func (o IndexArrayOutput) Index(i pulumi.IntInput) IndexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Index {
		return vs[0].([]*Index)[vs[1].(int)]
	}).(IndexOutput)
}

type IndexMapOutput struct{ *pulumi.OutputState }

func (IndexMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Index)(nil)).Elem()
}

func (o IndexMapOutput) ToIndexMapOutput() IndexMapOutput {
	return o
}

func (o IndexMapOutput) ToIndexMapOutputWithContext(ctx context.Context) IndexMapOutput {
	return o
}

func (o IndexMapOutput) MapIndex(k pulumi.StringInput) IndexOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Index {
		return vs[0].(map[string]*Index)[vs[1].(string)]
	}).(IndexOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IndexInput)(nil)).Elem(), &Index{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexArrayInput)(nil)).Elem(), IndexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexMapInput)(nil)).Elem(), IndexMap{})
	pulumi.RegisterOutputType(IndexOutput{})
	pulumi.RegisterOutputType(IndexArrayOutput{})
	pulumi.RegisterOutputType(IndexMapOutput{})
}
