// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pvtz

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Private Zone Rule Attachment resource.
//
// For information about Private Zone Rule Attachment and how to use it, see [What is Rule Attachment](https://www.alibabacloud.com/help/en/doc-detail/177601.htm).
//
// > **NOTE:** Available in v1.143.0+.
//
// ## Import
//
// Private Zone Rule Attachment can be imported using the id, e.g.
//
// ```sh
//  $ pulumi import alicloud:pvtz/ruleAttachment:RuleAttachment example <rule_id>
// ```
type RuleAttachment struct {
	pulumi.CustomResourceState

	// The ID of the rule.
	RuleId pulumi.StringOutput `pulumi:"ruleId"`
	// The List of the VPC. See the following `Block vpcs`.
	Vpcs RuleAttachmentVpcArrayOutput `pulumi:"vpcs"`
}

// NewRuleAttachment registers a new resource with the given unique name, arguments, and options.
func NewRuleAttachment(ctx *pulumi.Context,
	name string, args *RuleAttachmentArgs, opts ...pulumi.ResourceOption) (*RuleAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RuleId == nil {
		return nil, errors.New("invalid value for required argument 'RuleId'")
	}
	if args.Vpcs == nil {
		return nil, errors.New("invalid value for required argument 'Vpcs'")
	}
	var resource RuleAttachment
	err := ctx.RegisterResource("alicloud:pvtz/ruleAttachment:RuleAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRuleAttachment gets an existing RuleAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRuleAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RuleAttachmentState, opts ...pulumi.ResourceOption) (*RuleAttachment, error) {
	var resource RuleAttachment
	err := ctx.ReadResource("alicloud:pvtz/ruleAttachment:RuleAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RuleAttachment resources.
type ruleAttachmentState struct {
	// The ID of the rule.
	RuleId *string `pulumi:"ruleId"`
	// The List of the VPC. See the following `Block vpcs`.
	Vpcs []RuleAttachmentVpc `pulumi:"vpcs"`
}

type RuleAttachmentState struct {
	// The ID of the rule.
	RuleId pulumi.StringPtrInput
	// The List of the VPC. See the following `Block vpcs`.
	Vpcs RuleAttachmentVpcArrayInput
}

func (RuleAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleAttachmentState)(nil)).Elem()
}

type ruleAttachmentArgs struct {
	// The ID of the rule.
	RuleId string `pulumi:"ruleId"`
	// The List of the VPC. See the following `Block vpcs`.
	Vpcs []RuleAttachmentVpc `pulumi:"vpcs"`
}

// The set of arguments for constructing a RuleAttachment resource.
type RuleAttachmentArgs struct {
	// The ID of the rule.
	RuleId pulumi.StringInput
	// The List of the VPC. See the following `Block vpcs`.
	Vpcs RuleAttachmentVpcArrayInput
}

func (RuleAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleAttachmentArgs)(nil)).Elem()
}

type RuleAttachmentInput interface {
	pulumi.Input

	ToRuleAttachmentOutput() RuleAttachmentOutput
	ToRuleAttachmentOutputWithContext(ctx context.Context) RuleAttachmentOutput
}

func (*RuleAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleAttachment)(nil)).Elem()
}

func (i *RuleAttachment) ToRuleAttachmentOutput() RuleAttachmentOutput {
	return i.ToRuleAttachmentOutputWithContext(context.Background())
}

func (i *RuleAttachment) ToRuleAttachmentOutputWithContext(ctx context.Context) RuleAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAttachmentOutput)
}

// RuleAttachmentArrayInput is an input type that accepts RuleAttachmentArray and RuleAttachmentArrayOutput values.
// You can construct a concrete instance of `RuleAttachmentArrayInput` via:
//
//          RuleAttachmentArray{ RuleAttachmentArgs{...} }
type RuleAttachmentArrayInput interface {
	pulumi.Input

	ToRuleAttachmentArrayOutput() RuleAttachmentArrayOutput
	ToRuleAttachmentArrayOutputWithContext(context.Context) RuleAttachmentArrayOutput
}

type RuleAttachmentArray []RuleAttachmentInput

func (RuleAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RuleAttachment)(nil)).Elem()
}

func (i RuleAttachmentArray) ToRuleAttachmentArrayOutput() RuleAttachmentArrayOutput {
	return i.ToRuleAttachmentArrayOutputWithContext(context.Background())
}

func (i RuleAttachmentArray) ToRuleAttachmentArrayOutputWithContext(ctx context.Context) RuleAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAttachmentArrayOutput)
}

// RuleAttachmentMapInput is an input type that accepts RuleAttachmentMap and RuleAttachmentMapOutput values.
// You can construct a concrete instance of `RuleAttachmentMapInput` via:
//
//          RuleAttachmentMap{ "key": RuleAttachmentArgs{...} }
type RuleAttachmentMapInput interface {
	pulumi.Input

	ToRuleAttachmentMapOutput() RuleAttachmentMapOutput
	ToRuleAttachmentMapOutputWithContext(context.Context) RuleAttachmentMapOutput
}

type RuleAttachmentMap map[string]RuleAttachmentInput

func (RuleAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RuleAttachment)(nil)).Elem()
}

func (i RuleAttachmentMap) ToRuleAttachmentMapOutput() RuleAttachmentMapOutput {
	return i.ToRuleAttachmentMapOutputWithContext(context.Background())
}

func (i RuleAttachmentMap) ToRuleAttachmentMapOutputWithContext(ctx context.Context) RuleAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAttachmentMapOutput)
}

type RuleAttachmentOutput struct{ *pulumi.OutputState }

func (RuleAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleAttachment)(nil)).Elem()
}

func (o RuleAttachmentOutput) ToRuleAttachmentOutput() RuleAttachmentOutput {
	return o
}

func (o RuleAttachmentOutput) ToRuleAttachmentOutputWithContext(ctx context.Context) RuleAttachmentOutput {
	return o
}

type RuleAttachmentArrayOutput struct{ *pulumi.OutputState }

func (RuleAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RuleAttachment)(nil)).Elem()
}

func (o RuleAttachmentArrayOutput) ToRuleAttachmentArrayOutput() RuleAttachmentArrayOutput {
	return o
}

func (o RuleAttachmentArrayOutput) ToRuleAttachmentArrayOutputWithContext(ctx context.Context) RuleAttachmentArrayOutput {
	return o
}

func (o RuleAttachmentArrayOutput) Index(i pulumi.IntInput) RuleAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RuleAttachment {
		return vs[0].([]*RuleAttachment)[vs[1].(int)]
	}).(RuleAttachmentOutput)
}

type RuleAttachmentMapOutput struct{ *pulumi.OutputState }

func (RuleAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RuleAttachment)(nil)).Elem()
}

func (o RuleAttachmentMapOutput) ToRuleAttachmentMapOutput() RuleAttachmentMapOutput {
	return o
}

func (o RuleAttachmentMapOutput) ToRuleAttachmentMapOutputWithContext(ctx context.Context) RuleAttachmentMapOutput {
	return o
}

func (o RuleAttachmentMapOutput) MapIndex(k pulumi.StringInput) RuleAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RuleAttachment {
		return vs[0].(map[string]*RuleAttachment)[vs[1].(string)]
	}).(RuleAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAttachmentInput)(nil)).Elem(), &RuleAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAttachmentArrayInput)(nil)).Elem(), RuleAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAttachmentMapInput)(nil)).Elem(), RuleAttachmentMap{})
	pulumi.RegisterOutputType(RuleAttachmentOutput{})
	pulumi.RegisterOutputType(RuleAttachmentArrayOutput{})
	pulumi.RegisterOutputType(RuleAttachmentMapOutput{})
}
