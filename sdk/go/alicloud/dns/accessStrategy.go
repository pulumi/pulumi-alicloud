// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dns

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a DNS Access Strategy resource.
//
// For information about DNS Access Strategy and how to use it, see [What is Access Strategy](https://www.alibabacloud.com/help/doc-detail/189620.html).
//
// > **NOTE:** Available in v1.152.0+.
//
// ## Import
//
// DNS Access Strategy can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import alicloud:dns/accessStrategy:AccessStrategy example <id>
//
// ```
type AccessStrategy struct {
	pulumi.CustomResourceState

	// The primary/secondary switchover policy for address pool groups. Valid values: `AUTO`, `DEFAULT`, `FAILOVER`.
	AccessMode pulumi.StringOutput `pulumi:"accessMode"`
	// The type of the primary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	DefaultAddrPoolType pulumi.StringOutput `pulumi:"defaultAddrPoolType"`
	// List of primary address pool collections. See the following `Block defaultAddrPools`.
	DefaultAddrPools AccessStrategyDefaultAddrPoolArrayOutput `pulumi:"defaultAddrPools"`
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values: `OPEN`, `CLOSE`.
	DefaultLatencyOptimization pulumi.StringPtrOutput `pulumi:"defaultLatencyOptimization"`
	// The load balancing policy of the primary address pool group. Valid values: `ALL_RR`, `RATIO`. **NOTE:** The `defaultLbaStrategy` is required under the condition that `strategyMode` is `GEO`.
	DefaultLbaStrategy pulumi.StringPtrOutput `pulumi:"defaultLbaStrategy"`
	// The maximum number of addresses returned by the primary address pool set. **NOTE:** The `defaultMaxReturnAddrNum` is required under the condition that `strategyMode` is `LATENCY`.
	DefaultMaxReturnAddrNum pulumi.IntPtrOutput `pulumi:"defaultMaxReturnAddrNum"`
	// The minimum number of available addresses for the primary address pool set.
	DefaultMinAvailableAddrNum pulumi.IntOutput `pulumi:"defaultMinAvailableAddrNum"`
	// The type of the secondary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	FailoverAddrPoolType pulumi.StringPtrOutput `pulumi:"failoverAddrPoolType"`
	// List of backup address pool sets. See the following `Block failoverAddrPools`.
	FailoverAddrPools AccessStrategyFailoverAddrPoolArrayOutput `pulumi:"failoverAddrPools"`
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values: `OPEN`, `CLOSE`.
	FailoverLatencyOptimization pulumi.StringPtrOutput `pulumi:"failoverLatencyOptimization"`
	// The load balancing policy of the secondary address pool group. Valid values: `ALL_RR`, `RATIO`.
	FailoverLbaStrategy pulumi.StringPtrOutput `pulumi:"failoverLbaStrategy"`
	// The maximum number of returned addresses in the standby address pool.
	FailoverMaxReturnAddrNum pulumi.IntPtrOutput `pulumi:"failoverMaxReturnAddrNum"`
	// The minimum number of available addresses in the standby address pool.
	FailoverMinAvailableAddrNum pulumi.IntPtrOutput `pulumi:"failoverMinAvailableAddrNum"`
	// The Id of the associated instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// The lang.
	Lang pulumi.StringPtrOutput `pulumi:"lang"`
	// The source regions. See the following `Block lines`. **NOTE:** The `lines` is required under the condition that `strategyMode` is `GEO`.
	Lines AccessStrategyLineArrayOutput `pulumi:"lines"`
	// The type of the access policy. Valid values: `GEO` or `LATENCY`. `GEO`: based on geographic location. `LATENCY`: Based on delay.
	StrategyMode pulumi.StringOutput `pulumi:"strategyMode"`
	// The name of the access policy.
	StrategyName pulumi.StringOutput `pulumi:"strategyName"`
}

// NewAccessStrategy registers a new resource with the given unique name, arguments, and options.
func NewAccessStrategy(ctx *pulumi.Context,
	name string, args *AccessStrategyArgs, opts ...pulumi.ResourceOption) (*AccessStrategy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DefaultAddrPoolType == nil {
		return nil, errors.New("invalid value for required argument 'DefaultAddrPoolType'")
	}
	if args.DefaultAddrPools == nil {
		return nil, errors.New("invalid value for required argument 'DefaultAddrPools'")
	}
	if args.DefaultMinAvailableAddrNum == nil {
		return nil, errors.New("invalid value for required argument 'DefaultMinAvailableAddrNum'")
	}
	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.StrategyMode == nil {
		return nil, errors.New("invalid value for required argument 'StrategyMode'")
	}
	if args.StrategyName == nil {
		return nil, errors.New("invalid value for required argument 'StrategyName'")
	}
	var resource AccessStrategy
	err := ctx.RegisterResource("alicloud:dns/accessStrategy:AccessStrategy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccessStrategy gets an existing AccessStrategy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccessStrategy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccessStrategyState, opts ...pulumi.ResourceOption) (*AccessStrategy, error) {
	var resource AccessStrategy
	err := ctx.ReadResource("alicloud:dns/accessStrategy:AccessStrategy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccessStrategy resources.
type accessStrategyState struct {
	// The primary/secondary switchover policy for address pool groups. Valid values: `AUTO`, `DEFAULT`, `FAILOVER`.
	AccessMode *string `pulumi:"accessMode"`
	// The type of the primary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	DefaultAddrPoolType *string `pulumi:"defaultAddrPoolType"`
	// List of primary address pool collections. See the following `Block defaultAddrPools`.
	DefaultAddrPools []AccessStrategyDefaultAddrPool `pulumi:"defaultAddrPools"`
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values: `OPEN`, `CLOSE`.
	DefaultLatencyOptimization *string `pulumi:"defaultLatencyOptimization"`
	// The load balancing policy of the primary address pool group. Valid values: `ALL_RR`, `RATIO`. **NOTE:** The `defaultLbaStrategy` is required under the condition that `strategyMode` is `GEO`.
	DefaultLbaStrategy *string `pulumi:"defaultLbaStrategy"`
	// The maximum number of addresses returned by the primary address pool set. **NOTE:** The `defaultMaxReturnAddrNum` is required under the condition that `strategyMode` is `LATENCY`.
	DefaultMaxReturnAddrNum *int `pulumi:"defaultMaxReturnAddrNum"`
	// The minimum number of available addresses for the primary address pool set.
	DefaultMinAvailableAddrNum *int `pulumi:"defaultMinAvailableAddrNum"`
	// The type of the secondary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	FailoverAddrPoolType *string `pulumi:"failoverAddrPoolType"`
	// List of backup address pool sets. See the following `Block failoverAddrPools`.
	FailoverAddrPools []AccessStrategyFailoverAddrPool `pulumi:"failoverAddrPools"`
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values: `OPEN`, `CLOSE`.
	FailoverLatencyOptimization *string `pulumi:"failoverLatencyOptimization"`
	// The load balancing policy of the secondary address pool group. Valid values: `ALL_RR`, `RATIO`.
	FailoverLbaStrategy *string `pulumi:"failoverLbaStrategy"`
	// The maximum number of returned addresses in the standby address pool.
	FailoverMaxReturnAddrNum *int `pulumi:"failoverMaxReturnAddrNum"`
	// The minimum number of available addresses in the standby address pool.
	FailoverMinAvailableAddrNum *int `pulumi:"failoverMinAvailableAddrNum"`
	// The Id of the associated instance.
	InstanceId *string `pulumi:"instanceId"`
	// The lang.
	Lang *string `pulumi:"lang"`
	// The source regions. See the following `Block lines`. **NOTE:** The `lines` is required under the condition that `strategyMode` is `GEO`.
	Lines []AccessStrategyLine `pulumi:"lines"`
	// The type of the access policy. Valid values: `GEO` or `LATENCY`. `GEO`: based on geographic location. `LATENCY`: Based on delay.
	StrategyMode *string `pulumi:"strategyMode"`
	// The name of the access policy.
	StrategyName *string `pulumi:"strategyName"`
}

type AccessStrategyState struct {
	// The primary/secondary switchover policy for address pool groups. Valid values: `AUTO`, `DEFAULT`, `FAILOVER`.
	AccessMode pulumi.StringPtrInput
	// The type of the primary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	DefaultAddrPoolType pulumi.StringPtrInput
	// List of primary address pool collections. See the following `Block defaultAddrPools`.
	DefaultAddrPools AccessStrategyDefaultAddrPoolArrayInput
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values: `OPEN`, `CLOSE`.
	DefaultLatencyOptimization pulumi.StringPtrInput
	// The load balancing policy of the primary address pool group. Valid values: `ALL_RR`, `RATIO`. **NOTE:** The `defaultLbaStrategy` is required under the condition that `strategyMode` is `GEO`.
	DefaultLbaStrategy pulumi.StringPtrInput
	// The maximum number of addresses returned by the primary address pool set. **NOTE:** The `defaultMaxReturnAddrNum` is required under the condition that `strategyMode` is `LATENCY`.
	DefaultMaxReturnAddrNum pulumi.IntPtrInput
	// The minimum number of available addresses for the primary address pool set.
	DefaultMinAvailableAddrNum pulumi.IntPtrInput
	// The type of the secondary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	FailoverAddrPoolType pulumi.StringPtrInput
	// List of backup address pool sets. See the following `Block failoverAddrPools`.
	FailoverAddrPools AccessStrategyFailoverAddrPoolArrayInput
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values: `OPEN`, `CLOSE`.
	FailoverLatencyOptimization pulumi.StringPtrInput
	// The load balancing policy of the secondary address pool group. Valid values: `ALL_RR`, `RATIO`.
	FailoverLbaStrategy pulumi.StringPtrInput
	// The maximum number of returned addresses in the standby address pool.
	FailoverMaxReturnAddrNum pulumi.IntPtrInput
	// The minimum number of available addresses in the standby address pool.
	FailoverMinAvailableAddrNum pulumi.IntPtrInput
	// The Id of the associated instance.
	InstanceId pulumi.StringPtrInput
	// The lang.
	Lang pulumi.StringPtrInput
	// The source regions. See the following `Block lines`. **NOTE:** The `lines` is required under the condition that `strategyMode` is `GEO`.
	Lines AccessStrategyLineArrayInput
	// The type of the access policy. Valid values: `GEO` or `LATENCY`. `GEO`: based on geographic location. `LATENCY`: Based on delay.
	StrategyMode pulumi.StringPtrInput
	// The name of the access policy.
	StrategyName pulumi.StringPtrInput
}

func (AccessStrategyState) ElementType() reflect.Type {
	return reflect.TypeOf((*accessStrategyState)(nil)).Elem()
}

type accessStrategyArgs struct {
	// The primary/secondary switchover policy for address pool groups. Valid values: `AUTO`, `DEFAULT`, `FAILOVER`.
	AccessMode *string `pulumi:"accessMode"`
	// The type of the primary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	DefaultAddrPoolType string `pulumi:"defaultAddrPoolType"`
	// List of primary address pool collections. See the following `Block defaultAddrPools`.
	DefaultAddrPools []AccessStrategyDefaultAddrPool `pulumi:"defaultAddrPools"`
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values: `OPEN`, `CLOSE`.
	DefaultLatencyOptimization *string `pulumi:"defaultLatencyOptimization"`
	// The load balancing policy of the primary address pool group. Valid values: `ALL_RR`, `RATIO`. **NOTE:** The `defaultLbaStrategy` is required under the condition that `strategyMode` is `GEO`.
	DefaultLbaStrategy *string `pulumi:"defaultLbaStrategy"`
	// The maximum number of addresses returned by the primary address pool set. **NOTE:** The `defaultMaxReturnAddrNum` is required under the condition that `strategyMode` is `LATENCY`.
	DefaultMaxReturnAddrNum *int `pulumi:"defaultMaxReturnAddrNum"`
	// The minimum number of available addresses for the primary address pool set.
	DefaultMinAvailableAddrNum int `pulumi:"defaultMinAvailableAddrNum"`
	// The type of the secondary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	FailoverAddrPoolType *string `pulumi:"failoverAddrPoolType"`
	// List of backup address pool sets. See the following `Block failoverAddrPools`.
	FailoverAddrPools []AccessStrategyFailoverAddrPool `pulumi:"failoverAddrPools"`
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values: `OPEN`, `CLOSE`.
	FailoverLatencyOptimization *string `pulumi:"failoverLatencyOptimization"`
	// The load balancing policy of the secondary address pool group. Valid values: `ALL_RR`, `RATIO`.
	FailoverLbaStrategy *string `pulumi:"failoverLbaStrategy"`
	// The maximum number of returned addresses in the standby address pool.
	FailoverMaxReturnAddrNum *int `pulumi:"failoverMaxReturnAddrNum"`
	// The minimum number of available addresses in the standby address pool.
	FailoverMinAvailableAddrNum *int `pulumi:"failoverMinAvailableAddrNum"`
	// The Id of the associated instance.
	InstanceId string `pulumi:"instanceId"`
	// The lang.
	Lang *string `pulumi:"lang"`
	// The source regions. See the following `Block lines`. **NOTE:** The `lines` is required under the condition that `strategyMode` is `GEO`.
	Lines []AccessStrategyLine `pulumi:"lines"`
	// The type of the access policy. Valid values: `GEO` or `LATENCY`. `GEO`: based on geographic location. `LATENCY`: Based on delay.
	StrategyMode string `pulumi:"strategyMode"`
	// The name of the access policy.
	StrategyName string `pulumi:"strategyName"`
}

// The set of arguments for constructing a AccessStrategy resource.
type AccessStrategyArgs struct {
	// The primary/secondary switchover policy for address pool groups. Valid values: `AUTO`, `DEFAULT`, `FAILOVER`.
	AccessMode pulumi.StringPtrInput
	// The type of the primary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	DefaultAddrPoolType pulumi.StringInput
	// List of primary address pool collections. See the following `Block defaultAddrPools`.
	DefaultAddrPools AccessStrategyDefaultAddrPoolArrayInput
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values: `OPEN`, `CLOSE`.
	DefaultLatencyOptimization pulumi.StringPtrInput
	// The load balancing policy of the primary address pool group. Valid values: `ALL_RR`, `RATIO`. **NOTE:** The `defaultLbaStrategy` is required under the condition that `strategyMode` is `GEO`.
	DefaultLbaStrategy pulumi.StringPtrInput
	// The maximum number of addresses returned by the primary address pool set. **NOTE:** The `defaultMaxReturnAddrNum` is required under the condition that `strategyMode` is `LATENCY`.
	DefaultMaxReturnAddrNum pulumi.IntPtrInput
	// The minimum number of available addresses for the primary address pool set.
	DefaultMinAvailableAddrNum pulumi.IntInput
	// The type of the secondary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
	FailoverAddrPoolType pulumi.StringPtrInput
	// List of backup address pool sets. See the following `Block failoverAddrPools`.
	FailoverAddrPools AccessStrategyFailoverAddrPoolArrayInput
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values: `OPEN`, `CLOSE`.
	FailoverLatencyOptimization pulumi.StringPtrInput
	// The load balancing policy of the secondary address pool group. Valid values: `ALL_RR`, `RATIO`.
	FailoverLbaStrategy pulumi.StringPtrInput
	// The maximum number of returned addresses in the standby address pool.
	FailoverMaxReturnAddrNum pulumi.IntPtrInput
	// The minimum number of available addresses in the standby address pool.
	FailoverMinAvailableAddrNum pulumi.IntPtrInput
	// The Id of the associated instance.
	InstanceId pulumi.StringInput
	// The lang.
	Lang pulumi.StringPtrInput
	// The source regions. See the following `Block lines`. **NOTE:** The `lines` is required under the condition that `strategyMode` is `GEO`.
	Lines AccessStrategyLineArrayInput
	// The type of the access policy. Valid values: `GEO` or `LATENCY`. `GEO`: based on geographic location. `LATENCY`: Based on delay.
	StrategyMode pulumi.StringInput
	// The name of the access policy.
	StrategyName pulumi.StringInput
}

func (AccessStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accessStrategyArgs)(nil)).Elem()
}

type AccessStrategyInput interface {
	pulumi.Input

	ToAccessStrategyOutput() AccessStrategyOutput
	ToAccessStrategyOutputWithContext(ctx context.Context) AccessStrategyOutput
}

func (*AccessStrategy) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessStrategy)(nil)).Elem()
}

func (i *AccessStrategy) ToAccessStrategyOutput() AccessStrategyOutput {
	return i.ToAccessStrategyOutputWithContext(context.Background())
}

func (i *AccessStrategy) ToAccessStrategyOutputWithContext(ctx context.Context) AccessStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessStrategyOutput)
}

// AccessStrategyArrayInput is an input type that accepts AccessStrategyArray and AccessStrategyArrayOutput values.
// You can construct a concrete instance of `AccessStrategyArrayInput` via:
//
//	AccessStrategyArray{ AccessStrategyArgs{...} }
type AccessStrategyArrayInput interface {
	pulumi.Input

	ToAccessStrategyArrayOutput() AccessStrategyArrayOutput
	ToAccessStrategyArrayOutputWithContext(context.Context) AccessStrategyArrayOutput
}

type AccessStrategyArray []AccessStrategyInput

func (AccessStrategyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccessStrategy)(nil)).Elem()
}

func (i AccessStrategyArray) ToAccessStrategyArrayOutput() AccessStrategyArrayOutput {
	return i.ToAccessStrategyArrayOutputWithContext(context.Background())
}

func (i AccessStrategyArray) ToAccessStrategyArrayOutputWithContext(ctx context.Context) AccessStrategyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessStrategyArrayOutput)
}

// AccessStrategyMapInput is an input type that accepts AccessStrategyMap and AccessStrategyMapOutput values.
// You can construct a concrete instance of `AccessStrategyMapInput` via:
//
//	AccessStrategyMap{ "key": AccessStrategyArgs{...} }
type AccessStrategyMapInput interface {
	pulumi.Input

	ToAccessStrategyMapOutput() AccessStrategyMapOutput
	ToAccessStrategyMapOutputWithContext(context.Context) AccessStrategyMapOutput
}

type AccessStrategyMap map[string]AccessStrategyInput

func (AccessStrategyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccessStrategy)(nil)).Elem()
}

func (i AccessStrategyMap) ToAccessStrategyMapOutput() AccessStrategyMapOutput {
	return i.ToAccessStrategyMapOutputWithContext(context.Background())
}

func (i AccessStrategyMap) ToAccessStrategyMapOutputWithContext(ctx context.Context) AccessStrategyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessStrategyMapOutput)
}

type AccessStrategyOutput struct{ *pulumi.OutputState }

func (AccessStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessStrategy)(nil)).Elem()
}

func (o AccessStrategyOutput) ToAccessStrategyOutput() AccessStrategyOutput {
	return o
}

func (o AccessStrategyOutput) ToAccessStrategyOutputWithContext(ctx context.Context) AccessStrategyOutput {
	return o
}

// The primary/secondary switchover policy for address pool groups. Valid values: `AUTO`, `DEFAULT`, `FAILOVER`.
func (o AccessStrategyOutput) AccessMode() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringOutput { return v.AccessMode }).(pulumi.StringOutput)
}

// The type of the primary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
func (o AccessStrategyOutput) DefaultAddrPoolType() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringOutput { return v.DefaultAddrPoolType }).(pulumi.StringOutput)
}

// List of primary address pool collections. See the following `Block defaultAddrPools`.
func (o AccessStrategyOutput) DefaultAddrPools() AccessStrategyDefaultAddrPoolArrayOutput {
	return o.ApplyT(func(v *AccessStrategy) AccessStrategyDefaultAddrPoolArrayOutput { return v.DefaultAddrPools }).(AccessStrategyDefaultAddrPoolArrayOutput)
}

// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values: `OPEN`, `CLOSE`.
func (o AccessStrategyOutput) DefaultLatencyOptimization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringPtrOutput { return v.DefaultLatencyOptimization }).(pulumi.StringPtrOutput)
}

// The load balancing policy of the primary address pool group. Valid values: `ALL_RR`, `RATIO`. **NOTE:** The `defaultLbaStrategy` is required under the condition that `strategyMode` is `GEO`.
func (o AccessStrategyOutput) DefaultLbaStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringPtrOutput { return v.DefaultLbaStrategy }).(pulumi.StringPtrOutput)
}

// The maximum number of addresses returned by the primary address pool set. **NOTE:** The `defaultMaxReturnAddrNum` is required under the condition that `strategyMode` is `LATENCY`.
func (o AccessStrategyOutput) DefaultMaxReturnAddrNum() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.IntPtrOutput { return v.DefaultMaxReturnAddrNum }).(pulumi.IntPtrOutput)
}

// The minimum number of available addresses for the primary address pool set.
func (o AccessStrategyOutput) DefaultMinAvailableAddrNum() pulumi.IntOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.IntOutput { return v.DefaultMinAvailableAddrNum }).(pulumi.IntOutput)
}

// The type of the secondary address pool. Valid values: `IPV4`, `IPV6`, `DOMAIN`.
func (o AccessStrategyOutput) FailoverAddrPoolType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringPtrOutput { return v.FailoverAddrPoolType }).(pulumi.StringPtrOutput)
}

// List of backup address pool sets. See the following `Block failoverAddrPools`.
func (o AccessStrategyOutput) FailoverAddrPools() AccessStrategyFailoverAddrPoolArrayOutput {
	return o.ApplyT(func(v *AccessStrategy) AccessStrategyFailoverAddrPoolArrayOutput { return v.FailoverAddrPools }).(AccessStrategyFailoverAddrPoolArrayOutput)
}

// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values: `OPEN`, `CLOSE`.
func (o AccessStrategyOutput) FailoverLatencyOptimization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringPtrOutput { return v.FailoverLatencyOptimization }).(pulumi.StringPtrOutput)
}

// The load balancing policy of the secondary address pool group. Valid values: `ALL_RR`, `RATIO`.
func (o AccessStrategyOutput) FailoverLbaStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringPtrOutput { return v.FailoverLbaStrategy }).(pulumi.StringPtrOutput)
}

// The maximum number of returned addresses in the standby address pool.
func (o AccessStrategyOutput) FailoverMaxReturnAddrNum() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.IntPtrOutput { return v.FailoverMaxReturnAddrNum }).(pulumi.IntPtrOutput)
}

// The minimum number of available addresses in the standby address pool.
func (o AccessStrategyOutput) FailoverMinAvailableAddrNum() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.IntPtrOutput { return v.FailoverMinAvailableAddrNum }).(pulumi.IntPtrOutput)
}

// The Id of the associated instance.
func (o AccessStrategyOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// The lang.
func (o AccessStrategyOutput) Lang() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringPtrOutput { return v.Lang }).(pulumi.StringPtrOutput)
}

// The source regions. See the following `Block lines`. **NOTE:** The `lines` is required under the condition that `strategyMode` is `GEO`.
func (o AccessStrategyOutput) Lines() AccessStrategyLineArrayOutput {
	return o.ApplyT(func(v *AccessStrategy) AccessStrategyLineArrayOutput { return v.Lines }).(AccessStrategyLineArrayOutput)
}

// The type of the access policy. Valid values: `GEO` or `LATENCY`. `GEO`: based on geographic location. `LATENCY`: Based on delay.
func (o AccessStrategyOutput) StrategyMode() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringOutput { return v.StrategyMode }).(pulumi.StringOutput)
}

// The name of the access policy.
func (o AccessStrategyOutput) StrategyName() pulumi.StringOutput {
	return o.ApplyT(func(v *AccessStrategy) pulumi.StringOutput { return v.StrategyName }).(pulumi.StringOutput)
}

type AccessStrategyArrayOutput struct{ *pulumi.OutputState }

func (AccessStrategyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccessStrategy)(nil)).Elem()
}

func (o AccessStrategyArrayOutput) ToAccessStrategyArrayOutput() AccessStrategyArrayOutput {
	return o
}

func (o AccessStrategyArrayOutput) ToAccessStrategyArrayOutputWithContext(ctx context.Context) AccessStrategyArrayOutput {
	return o
}

func (o AccessStrategyArrayOutput) Index(i pulumi.IntInput) AccessStrategyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AccessStrategy {
		return vs[0].([]*AccessStrategy)[vs[1].(int)]
	}).(AccessStrategyOutput)
}

type AccessStrategyMapOutput struct{ *pulumi.OutputState }

func (AccessStrategyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccessStrategy)(nil)).Elem()
}

func (o AccessStrategyMapOutput) ToAccessStrategyMapOutput() AccessStrategyMapOutput {
	return o
}

func (o AccessStrategyMapOutput) ToAccessStrategyMapOutputWithContext(ctx context.Context) AccessStrategyMapOutput {
	return o
}

func (o AccessStrategyMapOutput) MapIndex(k pulumi.StringInput) AccessStrategyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AccessStrategy {
		return vs[0].(map[string]*AccessStrategy)[vs[1].(string)]
	}).(AccessStrategyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccessStrategyInput)(nil)).Elem(), &AccessStrategy{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessStrategyArrayInput)(nil)).Elem(), AccessStrategyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessStrategyMapInput)(nil)).Elem(), AccessStrategyMap{})
	pulumi.RegisterOutputType(AccessStrategyOutput{})
	pulumi.RegisterOutputType(AccessStrategyArrayOutput{})
	pulumi.RegisterOutputType(AccessStrategyMapOutput{})
}
