// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sae

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Serverless App Engine (SAE) Application Scaling Rule resource.
//
// For information about Serverless App Engine (SAE) Application Scaling Rule and how to use it, see [What is Application Scaling Rule](https://help.aliyun.com/document_detail/134120.html).
//
// > **NOTE:** Available in v1.159.0+.
//
// ## Example Usage
//
// # Basic Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/sae"
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/vpc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			defaultNetworks, err := vpc.GetNetworks(ctx, &vpc.GetNetworksArgs{
//				NameRegex: pulumi.StringRef("default-NODELETING"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			defaultSwitches, err := vpc.GetSwitches(ctx, &vpc.GetSwitchesArgs{
//				VpcId: pulumi.StringRef(defaultNetworks.Ids[0]),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			defaultNamespace, err := sae.NewNamespace(ctx, "defaultNamespace", &sae.NamespaceArgs{
//				NamespaceDescription: pulumi.String("example_value"),
//				NamespaceId:          pulumi.String("example_value"),
//				NamespaceName:        pulumi.String("example_value"),
//			})
//			if err != nil {
//				return err
//			}
//			defaultApplication, err := sae.NewApplication(ctx, "defaultApplication", &sae.ApplicationArgs{
//				AppDescription: pulumi.String("example_value"),
//				AppName:        pulumi.String("example_value"),
//				NamespaceId:    defaultNamespace.NamespaceId,
//				ImageUrl:       pulumi.String("registry-vpc.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5"),
//				PackageType:    pulumi.String("Image"),
//				Jdk:            pulumi.String("Open JDK 8"),
//				VswitchId:      *pulumi.String(defaultSwitches.Ids[0]),
//				VpcId:          *pulumi.String(defaultNetworks.Ids[0]),
//				Timezone:       pulumi.String("Asia/Shanghai"),
//				Replicas:       pulumi.Int(5),
//				Cpu:            pulumi.Int(500),
//				Memory:         pulumi.Int(2048),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = sae.NewApplicationScalingRule(ctx, "example", &sae.ApplicationScalingRuleArgs{
//				AppId:             defaultApplication.ID(),
//				ScalingRuleName:   pulumi.String("example-value"),
//				ScalingRuleEnable: pulumi.Bool(true),
//				ScalingRuleType:   pulumi.String("mix"),
//				ScalingRuleTimer: &sae.ApplicationScalingRuleScalingRuleTimerArgs{
//					BeginDate: pulumi.String("2022-02-25"),
//					EndDate:   pulumi.String("2022-03-25"),
//					Period:    pulumi.String("* * *"),
//					Schedules: sae.ApplicationScalingRuleScalingRuleTimerScheduleArray{
//						&sae.ApplicationScalingRuleScalingRuleTimerScheduleArgs{
//							AtTime:      pulumi.String("08:00"),
//							MaxReplicas: pulumi.Int(10),
//							MinReplicas: pulumi.Int(3),
//						},
//						&sae.ApplicationScalingRuleScalingRuleTimerScheduleArgs{
//							AtTime:      pulumi.String("20:00"),
//							MaxReplicas: pulumi.Int(50),
//							MinReplicas: pulumi.Int(3),
//						},
//					},
//				},
//				ScalingRuleMetric: &sae.ApplicationScalingRuleScalingRuleMetricArgs{
//					MaxReplicas: pulumi.Int(50),
//					MinReplicas: pulumi.Int(3),
//					Metrics: sae.ApplicationScalingRuleScalingRuleMetricMetricArray{
//						&sae.ApplicationScalingRuleScalingRuleMetricMetricArgs{
//							MetricType:                     pulumi.String("CPU"),
//							MetricTargetAverageUtilization: pulumi.Int(20),
//						},
//						&sae.ApplicationScalingRuleScalingRuleMetricMetricArgs{
//							MetricType:                     pulumi.String("MEMORY"),
//							MetricTargetAverageUtilization: pulumi.Int(30),
//						},
//						&sae.ApplicationScalingRuleScalingRuleMetricMetricArgs{
//							MetricType:                     pulumi.String("tcpActiveConn"),
//							MetricTargetAverageUtilization: pulumi.Int(20),
//						},
//					},
//					ScaleUpRules: &sae.ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs{
//						Step:                       pulumi.Int(10),
//						Disabled:                   pulumi.Bool(false),
//						StabilizationWindowSeconds: pulumi.Int(0),
//					},
//					ScaleDownRules: &sae.ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs{
//						Step:                       pulumi.Int(10),
//						Disabled:                   pulumi.Bool(false),
//						StabilizationWindowSeconds: pulumi.Int(10),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Serverless App Engine (SAE) Application Scaling Rule can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import alicloud:sae/applicationScalingRule:ApplicationScalingRule example <app_id>:<scaling_rule_name>
//
// ```
type ApplicationScalingRule struct {
	pulumi.CustomResourceState

	// Application ID.
	AppId pulumi.StringOutput `pulumi:"appId"`
	// The min ready instance ratio.
	MinReadyInstanceRatio pulumi.IntPtrOutput `pulumi:"minReadyInstanceRatio"`
	// The min ready instances.
	MinReadyInstances pulumi.IntPtrOutput `pulumi:"minReadyInstances"`
	// True whether the auto scaling policy is enabled. The value description is as follows: true: enabled state. false: disabled status. Valid values: `false`, `true`.
	ScalingRuleEnable pulumi.BoolOutput `pulumi:"scalingRuleEnable"`
	// Monitor the configuration of the indicator elasticity strategy. See the following `Block scalingRuleMetric`.
	ScalingRuleMetric ApplicationScalingRuleScalingRuleMetricPtrOutput `pulumi:"scalingRuleMetric"`
	// The name of a custom elastic scaling policy. In the application, the policy name cannot be repeated. It must start with a lowercase letter, and can only contain lowercase letters, numbers, and dashes (-), and no more than 32 characters. After the scaling policy is successfully created, the policy name cannot be modified.
	ScalingRuleName pulumi.StringOutput `pulumi:"scalingRuleName"`
	// Configuration of Timing Resilient Policies. See the following `Block scalingRuleTimer`.
	ScalingRuleTimer ApplicationScalingRuleScalingRuleTimerPtrOutput `pulumi:"scalingRuleTimer"`
	// Flexible strategy type. Valid values: `mix`, `timing` and `metric`.
	ScalingRuleType pulumi.StringOutput `pulumi:"scalingRuleType"`
}

// NewApplicationScalingRule registers a new resource with the given unique name, arguments, and options.
func NewApplicationScalingRule(ctx *pulumi.Context,
	name string, args *ApplicationScalingRuleArgs, opts ...pulumi.ResourceOption) (*ApplicationScalingRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppId == nil {
		return nil, errors.New("invalid value for required argument 'AppId'")
	}
	if args.ScalingRuleName == nil {
		return nil, errors.New("invalid value for required argument 'ScalingRuleName'")
	}
	if args.ScalingRuleType == nil {
		return nil, errors.New("invalid value for required argument 'ScalingRuleType'")
	}
	var resource ApplicationScalingRule
	err := ctx.RegisterResource("alicloud:sae/applicationScalingRule:ApplicationScalingRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApplicationScalingRule gets an existing ApplicationScalingRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApplicationScalingRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApplicationScalingRuleState, opts ...pulumi.ResourceOption) (*ApplicationScalingRule, error) {
	var resource ApplicationScalingRule
	err := ctx.ReadResource("alicloud:sae/applicationScalingRule:ApplicationScalingRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApplicationScalingRule resources.
type applicationScalingRuleState struct {
	// Application ID.
	AppId *string `pulumi:"appId"`
	// The min ready instance ratio.
	MinReadyInstanceRatio *int `pulumi:"minReadyInstanceRatio"`
	// The min ready instances.
	MinReadyInstances *int `pulumi:"minReadyInstances"`
	// True whether the auto scaling policy is enabled. The value description is as follows: true: enabled state. false: disabled status. Valid values: `false`, `true`.
	ScalingRuleEnable *bool `pulumi:"scalingRuleEnable"`
	// Monitor the configuration of the indicator elasticity strategy. See the following `Block scalingRuleMetric`.
	ScalingRuleMetric *ApplicationScalingRuleScalingRuleMetric `pulumi:"scalingRuleMetric"`
	// The name of a custom elastic scaling policy. In the application, the policy name cannot be repeated. It must start with a lowercase letter, and can only contain lowercase letters, numbers, and dashes (-), and no more than 32 characters. After the scaling policy is successfully created, the policy name cannot be modified.
	ScalingRuleName *string `pulumi:"scalingRuleName"`
	// Configuration of Timing Resilient Policies. See the following `Block scalingRuleTimer`.
	ScalingRuleTimer *ApplicationScalingRuleScalingRuleTimer `pulumi:"scalingRuleTimer"`
	// Flexible strategy type. Valid values: `mix`, `timing` and `metric`.
	ScalingRuleType *string `pulumi:"scalingRuleType"`
}

type ApplicationScalingRuleState struct {
	// Application ID.
	AppId pulumi.StringPtrInput
	// The min ready instance ratio.
	MinReadyInstanceRatio pulumi.IntPtrInput
	// The min ready instances.
	MinReadyInstances pulumi.IntPtrInput
	// True whether the auto scaling policy is enabled. The value description is as follows: true: enabled state. false: disabled status. Valid values: `false`, `true`.
	ScalingRuleEnable pulumi.BoolPtrInput
	// Monitor the configuration of the indicator elasticity strategy. See the following `Block scalingRuleMetric`.
	ScalingRuleMetric ApplicationScalingRuleScalingRuleMetricPtrInput
	// The name of a custom elastic scaling policy. In the application, the policy name cannot be repeated. It must start with a lowercase letter, and can only contain lowercase letters, numbers, and dashes (-), and no more than 32 characters. After the scaling policy is successfully created, the policy name cannot be modified.
	ScalingRuleName pulumi.StringPtrInput
	// Configuration of Timing Resilient Policies. See the following `Block scalingRuleTimer`.
	ScalingRuleTimer ApplicationScalingRuleScalingRuleTimerPtrInput
	// Flexible strategy type. Valid values: `mix`, `timing` and `metric`.
	ScalingRuleType pulumi.StringPtrInput
}

func (ApplicationScalingRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationScalingRuleState)(nil)).Elem()
}

type applicationScalingRuleArgs struct {
	// Application ID.
	AppId string `pulumi:"appId"`
	// The min ready instance ratio.
	MinReadyInstanceRatio *int `pulumi:"minReadyInstanceRatio"`
	// The min ready instances.
	MinReadyInstances *int `pulumi:"minReadyInstances"`
	// True whether the auto scaling policy is enabled. The value description is as follows: true: enabled state. false: disabled status. Valid values: `false`, `true`.
	ScalingRuleEnable *bool `pulumi:"scalingRuleEnable"`
	// Monitor the configuration of the indicator elasticity strategy. See the following `Block scalingRuleMetric`.
	ScalingRuleMetric *ApplicationScalingRuleScalingRuleMetric `pulumi:"scalingRuleMetric"`
	// The name of a custom elastic scaling policy. In the application, the policy name cannot be repeated. It must start with a lowercase letter, and can only contain lowercase letters, numbers, and dashes (-), and no more than 32 characters. After the scaling policy is successfully created, the policy name cannot be modified.
	ScalingRuleName string `pulumi:"scalingRuleName"`
	// Configuration of Timing Resilient Policies. See the following `Block scalingRuleTimer`.
	ScalingRuleTimer *ApplicationScalingRuleScalingRuleTimer `pulumi:"scalingRuleTimer"`
	// Flexible strategy type. Valid values: `mix`, `timing` and `metric`.
	ScalingRuleType string `pulumi:"scalingRuleType"`
}

// The set of arguments for constructing a ApplicationScalingRule resource.
type ApplicationScalingRuleArgs struct {
	// Application ID.
	AppId pulumi.StringInput
	// The min ready instance ratio.
	MinReadyInstanceRatio pulumi.IntPtrInput
	// The min ready instances.
	MinReadyInstances pulumi.IntPtrInput
	// True whether the auto scaling policy is enabled. The value description is as follows: true: enabled state. false: disabled status. Valid values: `false`, `true`.
	ScalingRuleEnable pulumi.BoolPtrInput
	// Monitor the configuration of the indicator elasticity strategy. See the following `Block scalingRuleMetric`.
	ScalingRuleMetric ApplicationScalingRuleScalingRuleMetricPtrInput
	// The name of a custom elastic scaling policy. In the application, the policy name cannot be repeated. It must start with a lowercase letter, and can only contain lowercase letters, numbers, and dashes (-), and no more than 32 characters. After the scaling policy is successfully created, the policy name cannot be modified.
	ScalingRuleName pulumi.StringInput
	// Configuration of Timing Resilient Policies. See the following `Block scalingRuleTimer`.
	ScalingRuleTimer ApplicationScalingRuleScalingRuleTimerPtrInput
	// Flexible strategy type. Valid values: `mix`, `timing` and `metric`.
	ScalingRuleType pulumi.StringInput
}

func (ApplicationScalingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationScalingRuleArgs)(nil)).Elem()
}

type ApplicationScalingRuleInput interface {
	pulumi.Input

	ToApplicationScalingRuleOutput() ApplicationScalingRuleOutput
	ToApplicationScalingRuleOutputWithContext(ctx context.Context) ApplicationScalingRuleOutput
}

func (*ApplicationScalingRule) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationScalingRule)(nil)).Elem()
}

func (i *ApplicationScalingRule) ToApplicationScalingRuleOutput() ApplicationScalingRuleOutput {
	return i.ToApplicationScalingRuleOutputWithContext(context.Background())
}

func (i *ApplicationScalingRule) ToApplicationScalingRuleOutputWithContext(ctx context.Context) ApplicationScalingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationScalingRuleOutput)
}

// ApplicationScalingRuleArrayInput is an input type that accepts ApplicationScalingRuleArray and ApplicationScalingRuleArrayOutput values.
// You can construct a concrete instance of `ApplicationScalingRuleArrayInput` via:
//
//	ApplicationScalingRuleArray{ ApplicationScalingRuleArgs{...} }
type ApplicationScalingRuleArrayInput interface {
	pulumi.Input

	ToApplicationScalingRuleArrayOutput() ApplicationScalingRuleArrayOutput
	ToApplicationScalingRuleArrayOutputWithContext(context.Context) ApplicationScalingRuleArrayOutput
}

type ApplicationScalingRuleArray []ApplicationScalingRuleInput

func (ApplicationScalingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationScalingRule)(nil)).Elem()
}

func (i ApplicationScalingRuleArray) ToApplicationScalingRuleArrayOutput() ApplicationScalingRuleArrayOutput {
	return i.ToApplicationScalingRuleArrayOutputWithContext(context.Background())
}

func (i ApplicationScalingRuleArray) ToApplicationScalingRuleArrayOutputWithContext(ctx context.Context) ApplicationScalingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationScalingRuleArrayOutput)
}

// ApplicationScalingRuleMapInput is an input type that accepts ApplicationScalingRuleMap and ApplicationScalingRuleMapOutput values.
// You can construct a concrete instance of `ApplicationScalingRuleMapInput` via:
//
//	ApplicationScalingRuleMap{ "key": ApplicationScalingRuleArgs{...} }
type ApplicationScalingRuleMapInput interface {
	pulumi.Input

	ToApplicationScalingRuleMapOutput() ApplicationScalingRuleMapOutput
	ToApplicationScalingRuleMapOutputWithContext(context.Context) ApplicationScalingRuleMapOutput
}

type ApplicationScalingRuleMap map[string]ApplicationScalingRuleInput

func (ApplicationScalingRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationScalingRule)(nil)).Elem()
}

func (i ApplicationScalingRuleMap) ToApplicationScalingRuleMapOutput() ApplicationScalingRuleMapOutput {
	return i.ToApplicationScalingRuleMapOutputWithContext(context.Background())
}

func (i ApplicationScalingRuleMap) ToApplicationScalingRuleMapOutputWithContext(ctx context.Context) ApplicationScalingRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationScalingRuleMapOutput)
}

type ApplicationScalingRuleOutput struct{ *pulumi.OutputState }

func (ApplicationScalingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationScalingRule)(nil)).Elem()
}

func (o ApplicationScalingRuleOutput) ToApplicationScalingRuleOutput() ApplicationScalingRuleOutput {
	return o
}

func (o ApplicationScalingRuleOutput) ToApplicationScalingRuleOutputWithContext(ctx context.Context) ApplicationScalingRuleOutput {
	return o
}

// Application ID.
func (o ApplicationScalingRuleOutput) AppId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) pulumi.StringOutput { return v.AppId }).(pulumi.StringOutput)
}

// The min ready instance ratio.
func (o ApplicationScalingRuleOutput) MinReadyInstanceRatio() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) pulumi.IntPtrOutput { return v.MinReadyInstanceRatio }).(pulumi.IntPtrOutput)
}

// The min ready instances.
func (o ApplicationScalingRuleOutput) MinReadyInstances() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) pulumi.IntPtrOutput { return v.MinReadyInstances }).(pulumi.IntPtrOutput)
}

// True whether the auto scaling policy is enabled. The value description is as follows: true: enabled state. false: disabled status. Valid values: `false`, `true`.
func (o ApplicationScalingRuleOutput) ScalingRuleEnable() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) pulumi.BoolOutput { return v.ScalingRuleEnable }).(pulumi.BoolOutput)
}

// Monitor the configuration of the indicator elasticity strategy. See the following `Block scalingRuleMetric`.
func (o ApplicationScalingRuleOutput) ScalingRuleMetric() ApplicationScalingRuleScalingRuleMetricPtrOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) ApplicationScalingRuleScalingRuleMetricPtrOutput {
		return v.ScalingRuleMetric
	}).(ApplicationScalingRuleScalingRuleMetricPtrOutput)
}

// The name of a custom elastic scaling policy. In the application, the policy name cannot be repeated. It must start with a lowercase letter, and can only contain lowercase letters, numbers, and dashes (-), and no more than 32 characters. After the scaling policy is successfully created, the policy name cannot be modified.
func (o ApplicationScalingRuleOutput) ScalingRuleName() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) pulumi.StringOutput { return v.ScalingRuleName }).(pulumi.StringOutput)
}

// Configuration of Timing Resilient Policies. See the following `Block scalingRuleTimer`.
func (o ApplicationScalingRuleOutput) ScalingRuleTimer() ApplicationScalingRuleScalingRuleTimerPtrOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) ApplicationScalingRuleScalingRuleTimerPtrOutput {
		return v.ScalingRuleTimer
	}).(ApplicationScalingRuleScalingRuleTimerPtrOutput)
}

// Flexible strategy type. Valid values: `mix`, `timing` and `metric`.
func (o ApplicationScalingRuleOutput) ScalingRuleType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationScalingRule) pulumi.StringOutput { return v.ScalingRuleType }).(pulumi.StringOutput)
}

type ApplicationScalingRuleArrayOutput struct{ *pulumi.OutputState }

func (ApplicationScalingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationScalingRule)(nil)).Elem()
}

func (o ApplicationScalingRuleArrayOutput) ToApplicationScalingRuleArrayOutput() ApplicationScalingRuleArrayOutput {
	return o
}

func (o ApplicationScalingRuleArrayOutput) ToApplicationScalingRuleArrayOutputWithContext(ctx context.Context) ApplicationScalingRuleArrayOutput {
	return o
}

func (o ApplicationScalingRuleArrayOutput) Index(i pulumi.IntInput) ApplicationScalingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApplicationScalingRule {
		return vs[0].([]*ApplicationScalingRule)[vs[1].(int)]
	}).(ApplicationScalingRuleOutput)
}

type ApplicationScalingRuleMapOutput struct{ *pulumi.OutputState }

func (ApplicationScalingRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationScalingRule)(nil)).Elem()
}

func (o ApplicationScalingRuleMapOutput) ToApplicationScalingRuleMapOutput() ApplicationScalingRuleMapOutput {
	return o
}

func (o ApplicationScalingRuleMapOutput) ToApplicationScalingRuleMapOutputWithContext(ctx context.Context) ApplicationScalingRuleMapOutput {
	return o
}

func (o ApplicationScalingRuleMapOutput) MapIndex(k pulumi.StringInput) ApplicationScalingRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApplicationScalingRule {
		return vs[0].(map[string]*ApplicationScalingRule)[vs[1].(string)]
	}).(ApplicationScalingRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationScalingRuleInput)(nil)).Elem(), &ApplicationScalingRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationScalingRuleArrayInput)(nil)).Elem(), ApplicationScalingRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationScalingRuleMapInput)(nil)).Elem(), ApplicationScalingRuleMap{})
	pulumi.RegisterOutputType(ApplicationScalingRuleOutput{})
	pulumi.RegisterOutputType(ApplicationScalingRuleArrayOutput{})
	pulumi.RegisterOutputType(ApplicationScalingRuleMapOutput{})
}
