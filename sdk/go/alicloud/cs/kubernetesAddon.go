// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cs

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource will help you to manage addon in Kubernetes Cluster.
//
// > **NOTE:** Available in 1.150.0+.
//
// ## Example Usage
//
// **Create a managed cluster**
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud"
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/cs"
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/ecs"
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/vpc"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		cfg := config.New(ctx, "")
// 		name := "tf-test"
// 		if param := cfg.Get("name"); param != "" {
// 			name = param
// 		}
// 		defaultZones, err := alicloud.GetZones(ctx, &GetZonesArgs{
// 			AvailableResourceCreation: pulumi.StringRef("VSwitch"),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceTypes, err := ecs.GetInstanceTypes(ctx, &ecs.GetInstanceTypesArgs{
// 			AvailabilityZone:   pulumi.StringRef(defaultZones.Zones[0].Id),
// 			CpuCoreCount:       pulumi.IntRef(2),
// 			MemorySize:         pulumi.Float64Ref(4),
// 			KubernetesNodeRole: pulumi.StringRef("Worker"),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		defaultNetwork, err := vpc.NewNetwork(ctx, "defaultNetwork", &vpc.NetworkArgs{
// 			VpcName:   pulumi.String(name),
// 			CidrBlock: pulumi.String("10.1.0.0/21"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultSwitch, err := vpc.NewSwitch(ctx, "defaultSwitch", &vpc.SwitchArgs{
// 			VswitchName: pulumi.String(name),
// 			VpcId:       defaultNetwork.ID(),
// 			CidrBlock:   pulumi.String("10.1.1.0/24"),
// 			ZoneId:      pulumi.String(defaultZones.Zones[0].Id),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = ecs.NewKeyPair(ctx, "defaultKeyPair", &ecs.KeyPairArgs{
// 			KeyPairName: pulumi.String(name),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		var defaultManagedKubernetes []*cs.ManagedKubernetes
// 		for key0, _ := range 1 == true {
// 			__res, err := cs.NewManagedKubernetes(ctx, fmt.Sprintf("defaultManagedKubernetes-%v", key0), &cs.ManagedKubernetesArgs{
// 				ClusterSpec:               pulumi.String("ack.pro.small"),
// 				IsEnterpriseSecurityGroup: pulumi.Bool(true),
// 				WorkerNumber:              pulumi.Int(2),
// 				Password:                  pulumi.String("Hello1234"),
// 				PodCidr:                   pulumi.String("172.20.0.0/16"),
// 				ServiceCidr:               pulumi.String("172.21.0.0/20"),
// 				WorkerVswitchIds: pulumi.StringArray{
// 					defaultSwitch.ID(),
// 				},
// 				WorkerInstanceTypes: pulumi.StringArray{
// 					pulumi.String(defaultInstanceTypes.InstanceTypes[0].Id),
// 				},
// 			})
// 			if err != nil {
// 				return err
// 			}
// 			defaultManagedKubernetes = append(defaultManagedKubernetes, __res)
// 		}
// 		return nil
// 	})
// }
// ```
// **Installing of addon**
// When a cluster is created, some system addons and those specified at the time of cluster creation will be installed, so when an addon resource is applied:
// * If the addon already exists in the cluster and its version is the same as the specified version, it will be skipped and will not be reinstalled.
// * If the addon already exists in the cluster and its version is different from the specified version, the addon will be upgraded.
// * If the addon does not exist in the cluster, it will be installed.
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/cs"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := cs.NewKubernetesAddon(ctx, "ack-node-problem-detector", &cs.KubernetesAddonArgs{
// 			ClusterId: pulumi.Any(alicloud_cs_managed_kubernetes.Default[0].Id),
// 			Version:   pulumi.String("1.2.7"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// **Upgrading of addon**
// First, check the `nextVersion` field of the addon that can be upgraded to through the `.tfstate file`, then overwrite the `version` field with the value of `nextVersion` and apply.
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/cs"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := cs.NewKubernetesAddon(ctx, "ack-node-problem-detector", &cs.KubernetesAddonArgs{
// 			ClusterId: pulumi.Any(alicloud_cs_managed_kubernetes.Default[0].Id),
// 			Version:   pulumi.String("1.2.8"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Cluster addon can be imported by cluster id and addon name. Then write the addon.tf file according to the result of `terraform plan`.
//
// ```sh
//  $ pulumi import alicloud:cs/kubernetesAddon:KubernetesAddon alicloud_cs_kubernetes_addon.my_addon <cluster_id>:<addon_name>
// ```
type KubernetesAddon struct {
	pulumi.CustomResourceState

	// Is the addon ready for upgrade.
	CanUpgrade pulumi.BoolOutput `pulumi:"canUpgrade"`
	// The id of kubernetes cluster.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// The name of addon.
	Name pulumi.StringOutput `pulumi:"name"`
	// The version which addon can be upgraded to.
	NextVersion pulumi.StringOutput `pulumi:"nextVersion"`
	// Is it a mandatory addon to be installed.
	Required pulumi.BoolOutput `pulumi:"required"`
	// The current version of addon.
	Version pulumi.StringOutput `pulumi:"version"`
}

// NewKubernetesAddon registers a new resource with the given unique name, arguments, and options.
func NewKubernetesAddon(ctx *pulumi.Context,
	name string, args *KubernetesAddonArgs, opts ...pulumi.ResourceOption) (*KubernetesAddon, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.Version == nil {
		return nil, errors.New("invalid value for required argument 'Version'")
	}
	var resource KubernetesAddon
	err := ctx.RegisterResource("alicloud:cs/kubernetesAddon:KubernetesAddon", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKubernetesAddon gets an existing KubernetesAddon resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKubernetesAddon(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KubernetesAddonState, opts ...pulumi.ResourceOption) (*KubernetesAddon, error) {
	var resource KubernetesAddon
	err := ctx.ReadResource("alicloud:cs/kubernetesAddon:KubernetesAddon", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KubernetesAddon resources.
type kubernetesAddonState struct {
	// Is the addon ready for upgrade.
	CanUpgrade *bool `pulumi:"canUpgrade"`
	// The id of kubernetes cluster.
	ClusterId *string `pulumi:"clusterId"`
	// The name of addon.
	Name *string `pulumi:"name"`
	// The version which addon can be upgraded to.
	NextVersion *string `pulumi:"nextVersion"`
	// Is it a mandatory addon to be installed.
	Required *bool `pulumi:"required"`
	// The current version of addon.
	Version *string `pulumi:"version"`
}

type KubernetesAddonState struct {
	// Is the addon ready for upgrade.
	CanUpgrade pulumi.BoolPtrInput
	// The id of kubernetes cluster.
	ClusterId pulumi.StringPtrInput
	// The name of addon.
	Name pulumi.StringPtrInput
	// The version which addon can be upgraded to.
	NextVersion pulumi.StringPtrInput
	// Is it a mandatory addon to be installed.
	Required pulumi.BoolPtrInput
	// The current version of addon.
	Version pulumi.StringPtrInput
}

func (KubernetesAddonState) ElementType() reflect.Type {
	return reflect.TypeOf((*kubernetesAddonState)(nil)).Elem()
}

type kubernetesAddonArgs struct {
	// The id of kubernetes cluster.
	ClusterId string `pulumi:"clusterId"`
	// The name of addon.
	Name *string `pulumi:"name"`
	// The current version of addon.
	Version string `pulumi:"version"`
}

// The set of arguments for constructing a KubernetesAddon resource.
type KubernetesAddonArgs struct {
	// The id of kubernetes cluster.
	ClusterId pulumi.StringInput
	// The name of addon.
	Name pulumi.StringPtrInput
	// The current version of addon.
	Version pulumi.StringInput
}

func (KubernetesAddonArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kubernetesAddonArgs)(nil)).Elem()
}

type KubernetesAddonInput interface {
	pulumi.Input

	ToKubernetesAddonOutput() KubernetesAddonOutput
	ToKubernetesAddonOutputWithContext(ctx context.Context) KubernetesAddonOutput
}

func (*KubernetesAddon) ElementType() reflect.Type {
	return reflect.TypeOf((**KubernetesAddon)(nil)).Elem()
}

func (i *KubernetesAddon) ToKubernetesAddonOutput() KubernetesAddonOutput {
	return i.ToKubernetesAddonOutputWithContext(context.Background())
}

func (i *KubernetesAddon) ToKubernetesAddonOutputWithContext(ctx context.Context) KubernetesAddonOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesAddonOutput)
}

// KubernetesAddonArrayInput is an input type that accepts KubernetesAddonArray and KubernetesAddonArrayOutput values.
// You can construct a concrete instance of `KubernetesAddonArrayInput` via:
//
//          KubernetesAddonArray{ KubernetesAddonArgs{...} }
type KubernetesAddonArrayInput interface {
	pulumi.Input

	ToKubernetesAddonArrayOutput() KubernetesAddonArrayOutput
	ToKubernetesAddonArrayOutputWithContext(context.Context) KubernetesAddonArrayOutput
}

type KubernetesAddonArray []KubernetesAddonInput

func (KubernetesAddonArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KubernetesAddon)(nil)).Elem()
}

func (i KubernetesAddonArray) ToKubernetesAddonArrayOutput() KubernetesAddonArrayOutput {
	return i.ToKubernetesAddonArrayOutputWithContext(context.Background())
}

func (i KubernetesAddonArray) ToKubernetesAddonArrayOutputWithContext(ctx context.Context) KubernetesAddonArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesAddonArrayOutput)
}

// KubernetesAddonMapInput is an input type that accepts KubernetesAddonMap and KubernetesAddonMapOutput values.
// You can construct a concrete instance of `KubernetesAddonMapInput` via:
//
//          KubernetesAddonMap{ "key": KubernetesAddonArgs{...} }
type KubernetesAddonMapInput interface {
	pulumi.Input

	ToKubernetesAddonMapOutput() KubernetesAddonMapOutput
	ToKubernetesAddonMapOutputWithContext(context.Context) KubernetesAddonMapOutput
}

type KubernetesAddonMap map[string]KubernetesAddonInput

func (KubernetesAddonMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KubernetesAddon)(nil)).Elem()
}

func (i KubernetesAddonMap) ToKubernetesAddonMapOutput() KubernetesAddonMapOutput {
	return i.ToKubernetesAddonMapOutputWithContext(context.Background())
}

func (i KubernetesAddonMap) ToKubernetesAddonMapOutputWithContext(ctx context.Context) KubernetesAddonMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesAddonMapOutput)
}

type KubernetesAddonOutput struct{ *pulumi.OutputState }

func (KubernetesAddonOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubernetesAddon)(nil)).Elem()
}

func (o KubernetesAddonOutput) ToKubernetesAddonOutput() KubernetesAddonOutput {
	return o
}

func (o KubernetesAddonOutput) ToKubernetesAddonOutputWithContext(ctx context.Context) KubernetesAddonOutput {
	return o
}

type KubernetesAddonArrayOutput struct{ *pulumi.OutputState }

func (KubernetesAddonArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KubernetesAddon)(nil)).Elem()
}

func (o KubernetesAddonArrayOutput) ToKubernetesAddonArrayOutput() KubernetesAddonArrayOutput {
	return o
}

func (o KubernetesAddonArrayOutput) ToKubernetesAddonArrayOutputWithContext(ctx context.Context) KubernetesAddonArrayOutput {
	return o
}

func (o KubernetesAddonArrayOutput) Index(i pulumi.IntInput) KubernetesAddonOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KubernetesAddon {
		return vs[0].([]*KubernetesAddon)[vs[1].(int)]
	}).(KubernetesAddonOutput)
}

type KubernetesAddonMapOutput struct{ *pulumi.OutputState }

func (KubernetesAddonMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KubernetesAddon)(nil)).Elem()
}

func (o KubernetesAddonMapOutput) ToKubernetesAddonMapOutput() KubernetesAddonMapOutput {
	return o
}

func (o KubernetesAddonMapOutput) ToKubernetesAddonMapOutputWithContext(ctx context.Context) KubernetesAddonMapOutput {
	return o
}

func (o KubernetesAddonMapOutput) MapIndex(k pulumi.StringInput) KubernetesAddonOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KubernetesAddon {
		return vs[0].(map[string]*KubernetesAddon)[vs[1].(string)]
	}).(KubernetesAddonOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesAddonInput)(nil)).Elem(), &KubernetesAddon{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesAddonArrayInput)(nil)).Elem(), KubernetesAddonArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesAddonMapInput)(nil)).Elem(), KubernetesAddonMap{})
	pulumi.RegisterOutputType(KubernetesAddonOutput{})
	pulumi.RegisterOutputType(KubernetesAddonArrayOutput{})
	pulumi.RegisterOutputType(KubernetesAddonMapOutput{})
}
