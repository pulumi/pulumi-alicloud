// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package ddos

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a DdosCoo Scheduler Rule resource. For information about DdosCoo Scheduler Rule and how to use it, see[What is DdosCoo Scheduler Rule](https://www.alibabacloud.com/help/en/doc-detail/157481.htm).
//
// > **NOTE:** Available in 1.86.0+
//
// ## Example Usage
//
// Basic Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/ddos"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := ddos.NewSchedulerRule(ctx, "example", &ddos.SchedulerRuleArgs{
// 			RuleName: pulumi.String("tf-testacc7929727******"),
// 			RuleType: pulumi.Int(3),
// 			Rules: ddos.SchedulerRuleRuleArray{
// 				&ddos.SchedulerRuleRuleArgs{
// 					Priority:  pulumi.Int(100),
// 					RegionId:  pulumi.String("cn-hangzhou"),
// 					Type:      pulumi.String("A"),
// 					Value:     pulumi.String("170.33.2.125"),
// 					ValueType: pulumi.Int(3),
// 				},
// 				&ddos.SchedulerRuleRuleArgs{
// 					Priority:  pulumi.Int(50),
// 					RegionId:  pulumi.String("cn-hangzhou"),
// 					Type:      pulumi.String("A"),
// 					Value:     pulumi.String("170.33.14.193"),
// 					ValueType: pulumi.Int(1),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// DdosCoo Scheduler Rule can be imported using the id or the rule name, e.g.
//
// ```sh
//  $ pulumi import alicloud:ddos/schedulerRule:SchedulerRule example fbb20dc77e8fc******
// ```
type SchedulerRule struct {
	pulumi.CustomResourceState

	// The cname is the traffic scheduler corresponding to rules.
	Cname pulumi.StringOutput    `pulumi:"cname"`
	Param pulumi.StringPtrOutput `pulumi:"param"`
	// The ID of the resource group to which the anti-DDoS pro instance belongs in resource management. By default, no value is specified, indicating that the domains in the default resource group are listed.
	ResourceGroupId pulumi.StringPtrOutput `pulumi:"resourceGroupId"`
	// The name of the rule.
	RuleName pulumi.StringOutput `pulumi:"ruleName"`
	// The rule type. Valid values:
	// `2`: tiered protection.
	// `3`: globalization acceleration.
	// `6`: Cloud product interaction.
	RuleType pulumi.IntOutput `pulumi:"ruleType"`
	// The details of the common filter interaction rule, expressed as a JSON string. The structure is as follows:
	// `Type`: String type, required, the address format of the linkage resource. Valid values:
	// `A`: IP address.
	// `CNAME`: Domain name.
	// `Value`: String type, required, link address of resource.
	// `Priority`: the priority of the rule. This parameter is required and of Integer type. Valid values: 0~100 the larger the value, the higher the priority.
	// `ValueType`: Required. The type of the linked resource. It is an Integer. Valid values:
	// `1`: Anti-DDoS Pro.
	// `2`: (Tiered protection) cloud resource IP.
	// `3`: (sea acceleration) MCA IP address.
	// `6`: (Cloud product linkage) cloud resource IP.
	// `RegionId`: String type, optional (Required when ValueType is 2) the ID of the region.
	Rules SchedulerRuleRuleArrayOutput `pulumi:"rules"`
}

// NewSchedulerRule registers a new resource with the given unique name, arguments, and options.
func NewSchedulerRule(ctx *pulumi.Context,
	name string, args *SchedulerRuleArgs, opts ...pulumi.ResourceOption) (*SchedulerRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RuleName == nil {
		return nil, errors.New("invalid value for required argument 'RuleName'")
	}
	if args.RuleType == nil {
		return nil, errors.New("invalid value for required argument 'RuleType'")
	}
	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	var resource SchedulerRule
	err := ctx.RegisterResource("alicloud:ddos/schedulerRule:SchedulerRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSchedulerRule gets an existing SchedulerRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSchedulerRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SchedulerRuleState, opts ...pulumi.ResourceOption) (*SchedulerRule, error) {
	var resource SchedulerRule
	err := ctx.ReadResource("alicloud:ddos/schedulerRule:SchedulerRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SchedulerRule resources.
type schedulerRuleState struct {
	// The cname is the traffic scheduler corresponding to rules.
	Cname *string `pulumi:"cname"`
	Param *string `pulumi:"param"`
	// The ID of the resource group to which the anti-DDoS pro instance belongs in resource management. By default, no value is specified, indicating that the domains in the default resource group are listed.
	ResourceGroupId *string `pulumi:"resourceGroupId"`
	// The name of the rule.
	RuleName *string `pulumi:"ruleName"`
	// The rule type. Valid values:
	// `2`: tiered protection.
	// `3`: globalization acceleration.
	// `6`: Cloud product interaction.
	RuleType *int `pulumi:"ruleType"`
	// The details of the common filter interaction rule, expressed as a JSON string. The structure is as follows:
	// `Type`: String type, required, the address format of the linkage resource. Valid values:
	// `A`: IP address.
	// `CNAME`: Domain name.
	// `Value`: String type, required, link address of resource.
	// `Priority`: the priority of the rule. This parameter is required and of Integer type. Valid values: 0~100 the larger the value, the higher the priority.
	// `ValueType`: Required. The type of the linked resource. It is an Integer. Valid values:
	// `1`: Anti-DDoS Pro.
	// `2`: (Tiered protection) cloud resource IP.
	// `3`: (sea acceleration) MCA IP address.
	// `6`: (Cloud product linkage) cloud resource IP.
	// `RegionId`: String type, optional (Required when ValueType is 2) the ID of the region.
	Rules []SchedulerRuleRule `pulumi:"rules"`
}

type SchedulerRuleState struct {
	// The cname is the traffic scheduler corresponding to rules.
	Cname pulumi.StringPtrInput
	Param pulumi.StringPtrInput
	// The ID of the resource group to which the anti-DDoS pro instance belongs in resource management. By default, no value is specified, indicating that the domains in the default resource group are listed.
	ResourceGroupId pulumi.StringPtrInput
	// The name of the rule.
	RuleName pulumi.StringPtrInput
	// The rule type. Valid values:
	// `2`: tiered protection.
	// `3`: globalization acceleration.
	// `6`: Cloud product interaction.
	RuleType pulumi.IntPtrInput
	// The details of the common filter interaction rule, expressed as a JSON string. The structure is as follows:
	// `Type`: String type, required, the address format of the linkage resource. Valid values:
	// `A`: IP address.
	// `CNAME`: Domain name.
	// `Value`: String type, required, link address of resource.
	// `Priority`: the priority of the rule. This parameter is required and of Integer type. Valid values: 0~100 the larger the value, the higher the priority.
	// `ValueType`: Required. The type of the linked resource. It is an Integer. Valid values:
	// `1`: Anti-DDoS Pro.
	// `2`: (Tiered protection) cloud resource IP.
	// `3`: (sea acceleration) MCA IP address.
	// `6`: (Cloud product linkage) cloud resource IP.
	// `RegionId`: String type, optional (Required when ValueType is 2) the ID of the region.
	Rules SchedulerRuleRuleArrayInput
}

func (SchedulerRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*schedulerRuleState)(nil)).Elem()
}

type schedulerRuleArgs struct {
	Param *string `pulumi:"param"`
	// The ID of the resource group to which the anti-DDoS pro instance belongs in resource management. By default, no value is specified, indicating that the domains in the default resource group are listed.
	ResourceGroupId *string `pulumi:"resourceGroupId"`
	// The name of the rule.
	RuleName string `pulumi:"ruleName"`
	// The rule type. Valid values:
	// `2`: tiered protection.
	// `3`: globalization acceleration.
	// `6`: Cloud product interaction.
	RuleType int `pulumi:"ruleType"`
	// The details of the common filter interaction rule, expressed as a JSON string. The structure is as follows:
	// `Type`: String type, required, the address format of the linkage resource. Valid values:
	// `A`: IP address.
	// `CNAME`: Domain name.
	// `Value`: String type, required, link address of resource.
	// `Priority`: the priority of the rule. This parameter is required and of Integer type. Valid values: 0~100 the larger the value, the higher the priority.
	// `ValueType`: Required. The type of the linked resource. It is an Integer. Valid values:
	// `1`: Anti-DDoS Pro.
	// `2`: (Tiered protection) cloud resource IP.
	// `3`: (sea acceleration) MCA IP address.
	// `6`: (Cloud product linkage) cloud resource IP.
	// `RegionId`: String type, optional (Required when ValueType is 2) the ID of the region.
	Rules []SchedulerRuleRule `pulumi:"rules"`
}

// The set of arguments for constructing a SchedulerRule resource.
type SchedulerRuleArgs struct {
	Param pulumi.StringPtrInput
	// The ID of the resource group to which the anti-DDoS pro instance belongs in resource management. By default, no value is specified, indicating that the domains in the default resource group are listed.
	ResourceGroupId pulumi.StringPtrInput
	// The name of the rule.
	RuleName pulumi.StringInput
	// The rule type. Valid values:
	// `2`: tiered protection.
	// `3`: globalization acceleration.
	// `6`: Cloud product interaction.
	RuleType pulumi.IntInput
	// The details of the common filter interaction rule, expressed as a JSON string. The structure is as follows:
	// `Type`: String type, required, the address format of the linkage resource. Valid values:
	// `A`: IP address.
	// `CNAME`: Domain name.
	// `Value`: String type, required, link address of resource.
	// `Priority`: the priority of the rule. This parameter is required and of Integer type. Valid values: 0~100 the larger the value, the higher the priority.
	// `ValueType`: Required. The type of the linked resource. It is an Integer. Valid values:
	// `1`: Anti-DDoS Pro.
	// `2`: (Tiered protection) cloud resource IP.
	// `3`: (sea acceleration) MCA IP address.
	// `6`: (Cloud product linkage) cloud resource IP.
	// `RegionId`: String type, optional (Required when ValueType is 2) the ID of the region.
	Rules SchedulerRuleRuleArrayInput
}

func (SchedulerRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*schedulerRuleArgs)(nil)).Elem()
}

type SchedulerRuleInput interface {
	pulumi.Input

	ToSchedulerRuleOutput() SchedulerRuleOutput
	ToSchedulerRuleOutputWithContext(ctx context.Context) SchedulerRuleOutput
}

func (*SchedulerRule) ElementType() reflect.Type {
	return reflect.TypeOf((*SchedulerRule)(nil))
}

func (i *SchedulerRule) ToSchedulerRuleOutput() SchedulerRuleOutput {
	return i.ToSchedulerRuleOutputWithContext(context.Background())
}

func (i *SchedulerRule) ToSchedulerRuleOutputWithContext(ctx context.Context) SchedulerRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchedulerRuleOutput)
}

func (i *SchedulerRule) ToSchedulerRulePtrOutput() SchedulerRulePtrOutput {
	return i.ToSchedulerRulePtrOutputWithContext(context.Background())
}

func (i *SchedulerRule) ToSchedulerRulePtrOutputWithContext(ctx context.Context) SchedulerRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchedulerRulePtrOutput)
}

type SchedulerRulePtrInput interface {
	pulumi.Input

	ToSchedulerRulePtrOutput() SchedulerRulePtrOutput
	ToSchedulerRulePtrOutputWithContext(ctx context.Context) SchedulerRulePtrOutput
}

type schedulerRulePtrType SchedulerRuleArgs

func (*schedulerRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchedulerRule)(nil))
}

func (i *schedulerRulePtrType) ToSchedulerRulePtrOutput() SchedulerRulePtrOutput {
	return i.ToSchedulerRulePtrOutputWithContext(context.Background())
}

func (i *schedulerRulePtrType) ToSchedulerRulePtrOutputWithContext(ctx context.Context) SchedulerRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchedulerRulePtrOutput)
}

// SchedulerRuleArrayInput is an input type that accepts SchedulerRuleArray and SchedulerRuleArrayOutput values.
// You can construct a concrete instance of `SchedulerRuleArrayInput` via:
//
//          SchedulerRuleArray{ SchedulerRuleArgs{...} }
type SchedulerRuleArrayInput interface {
	pulumi.Input

	ToSchedulerRuleArrayOutput() SchedulerRuleArrayOutput
	ToSchedulerRuleArrayOutputWithContext(context.Context) SchedulerRuleArrayOutput
}

type SchedulerRuleArray []SchedulerRuleInput

func (SchedulerRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*SchedulerRule)(nil))
}

func (i SchedulerRuleArray) ToSchedulerRuleArrayOutput() SchedulerRuleArrayOutput {
	return i.ToSchedulerRuleArrayOutputWithContext(context.Background())
}

func (i SchedulerRuleArray) ToSchedulerRuleArrayOutputWithContext(ctx context.Context) SchedulerRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchedulerRuleArrayOutput)
}

// SchedulerRuleMapInput is an input type that accepts SchedulerRuleMap and SchedulerRuleMapOutput values.
// You can construct a concrete instance of `SchedulerRuleMapInput` via:
//
//          SchedulerRuleMap{ "key": SchedulerRuleArgs{...} }
type SchedulerRuleMapInput interface {
	pulumi.Input

	ToSchedulerRuleMapOutput() SchedulerRuleMapOutput
	ToSchedulerRuleMapOutputWithContext(context.Context) SchedulerRuleMapOutput
}

type SchedulerRuleMap map[string]SchedulerRuleInput

func (SchedulerRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*SchedulerRule)(nil))
}

func (i SchedulerRuleMap) ToSchedulerRuleMapOutput() SchedulerRuleMapOutput {
	return i.ToSchedulerRuleMapOutputWithContext(context.Background())
}

func (i SchedulerRuleMap) ToSchedulerRuleMapOutputWithContext(ctx context.Context) SchedulerRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchedulerRuleMapOutput)
}

type SchedulerRuleOutput struct {
	*pulumi.OutputState
}

func (SchedulerRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchedulerRule)(nil))
}

func (o SchedulerRuleOutput) ToSchedulerRuleOutput() SchedulerRuleOutput {
	return o
}

func (o SchedulerRuleOutput) ToSchedulerRuleOutputWithContext(ctx context.Context) SchedulerRuleOutput {
	return o
}

func (o SchedulerRuleOutput) ToSchedulerRulePtrOutput() SchedulerRulePtrOutput {
	return o.ToSchedulerRulePtrOutputWithContext(context.Background())
}

func (o SchedulerRuleOutput) ToSchedulerRulePtrOutputWithContext(ctx context.Context) SchedulerRulePtrOutput {
	return o.ApplyT(func(v SchedulerRule) *SchedulerRule {
		return &v
	}).(SchedulerRulePtrOutput)
}

type SchedulerRulePtrOutput struct {
	*pulumi.OutputState
}

func (SchedulerRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchedulerRule)(nil))
}

func (o SchedulerRulePtrOutput) ToSchedulerRulePtrOutput() SchedulerRulePtrOutput {
	return o
}

func (o SchedulerRulePtrOutput) ToSchedulerRulePtrOutputWithContext(ctx context.Context) SchedulerRulePtrOutput {
	return o
}

type SchedulerRuleArrayOutput struct{ *pulumi.OutputState }

func (SchedulerRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SchedulerRule)(nil))
}

func (o SchedulerRuleArrayOutput) ToSchedulerRuleArrayOutput() SchedulerRuleArrayOutput {
	return o
}

func (o SchedulerRuleArrayOutput) ToSchedulerRuleArrayOutputWithContext(ctx context.Context) SchedulerRuleArrayOutput {
	return o
}

func (o SchedulerRuleArrayOutput) Index(i pulumi.IntInput) SchedulerRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SchedulerRule {
		return vs[0].([]SchedulerRule)[vs[1].(int)]
	}).(SchedulerRuleOutput)
}

type SchedulerRuleMapOutput struct{ *pulumi.OutputState }

func (SchedulerRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SchedulerRule)(nil))
}

func (o SchedulerRuleMapOutput) ToSchedulerRuleMapOutput() SchedulerRuleMapOutput {
	return o
}

func (o SchedulerRuleMapOutput) ToSchedulerRuleMapOutputWithContext(ctx context.Context) SchedulerRuleMapOutput {
	return o
}

func (o SchedulerRuleMapOutput) MapIndex(k pulumi.StringInput) SchedulerRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) SchedulerRule {
		return vs[0].(map[string]SchedulerRule)[vs[1].(string)]
	}).(SchedulerRuleOutput)
}

func init() {
	pulumi.RegisterOutputType(SchedulerRuleOutput{})
	pulumi.RegisterOutputType(SchedulerRulePtrOutput{})
	pulumi.RegisterOutputType(SchedulerRuleArrayOutput{})
	pulumi.RegisterOutputType(SchedulerRuleMapOutput{})
}
