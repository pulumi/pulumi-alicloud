// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package log

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Log alert is a unit of log service, which is used to monitor and alert the user's logstore status information.
// Log Service enables you to configure alerts based on the charts in a dashboard to monitor the service status in real time.
//
// > **NOTE:** Available in 1.78.0
//
// ## Example Usage
//
// Basic Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/log"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		exampleProject, err := log.NewProject(ctx, "exampleProject", &log.ProjectArgs{
// 			Description: pulumi.String("create by terraform"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = log.NewStore(ctx, "exampleStore", &log.StoreArgs{
// 			Project:            exampleProject.Name,
// 			RetentionPeriod:    pulumi.Int(3650),
// 			ShardCount:         pulumi.Int(3),
// 			AutoSplit:          pulumi.Bool(true),
// 			MaxSplitShardCount: pulumi.Int(60),
// 			AppendMeta:         pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = log.NewAlert(ctx, "exampleAlert", &log.AlertArgs{
// 			ProjectName:      exampleProject.Name,
// 			AlertName:        pulumi.String("tf-test-alert"),
// 			AlertDisplayname: pulumi.String("tf-test-alert-displayname"),
// 			Condition:        pulumi.String("count> 100"),
// 			Dashboard:        pulumi.String("tf-test-dashboard"),
// 			QueryLists: log.AlertQueryListArray{
// 				&log.AlertQueryListArgs{
// 					Logstore:   pulumi.String("tf-test-logstore"),
// 					ChartTitle: pulumi.String("chart_title"),
// 					Start:      pulumi.String("-60s"),
// 					End:        pulumi.String("20s"),
// 					Query:      pulumi.String("* AND aliyun"),
// 				},
// 			},
// 			NotificationLists: log.AlertNotificationListArray{
// 				&log.AlertNotificationListArgs{
// 					Type: pulumi.String("SMS"),
// 					MobileLists: pulumi.StringArray{
// 						pulumi.String("12345678"),
// 						pulumi.String("87654321"),
// 					},
// 					Content: pulumi.String("alert content"),
// 				},
// 				&log.AlertNotificationListArgs{
// 					Type: pulumi.String("Email"),
// 					EmailLists: pulumi.StringArray{
// 						pulumi.String("aliyun@alibaba-inc.com"),
// 						pulumi.String("tf-test@123.com"),
// 					},
// 					Content: pulumi.String("alert content"),
// 				},
// 				&log.AlertNotificationListArgs{
// 					Type:       pulumi.String("DingTalk"),
// 					ServiceUri: pulumi.String("www.aliyun.com"),
// 					Content:    pulumi.String("alert content"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Log alert can be imported using the id, e.g.
//
// ```sh
//  $ pulumi import alicloud:log/alert:Alert example tf-log:tf-log-alert
// ```
type Alert struct {
	pulumi.CustomResourceState

	// Alert description.
	AlertDescription pulumi.StringPtrOutput `pulumi:"alertDescription"`
	// Alert displayname.
	AlertDisplayname pulumi.StringOutput `pulumi:"alertDisplayname"`
	// Name of logstore for configuring alarm service.
	AlertName pulumi.StringOutput `pulumi:"alertName"`
	// Conditional expression, such as: count> 100.
	Condition pulumi.StringOutput `pulumi:"condition"`
	Dashboard pulumi.StringOutput `pulumi:"dashboard"`
	// Timestamp, notifications before closing again.
	MuteUntil pulumi.IntPtrOutput `pulumi:"muteUntil"`
	// Alarm information notification list.
	NotificationLists AlertNotificationListArrayOutput `pulumi:"notificationLists"`
	// Notification threshold, which is not notified until the number of triggers is reached. The default is 1.
	NotifyThreshold pulumi.IntPtrOutput `pulumi:"notifyThreshold"`
	// The project name.
	ProjectName pulumi.StringOutput `pulumi:"projectName"`
	// Multiple conditions for configured alarm query.
	QueryLists AlertQueryListArrayOutput `pulumi:"queryLists"`
	// Execution interval. 60 seconds minimum, such as 60s, 1h.
	ScheduleInterval pulumi.StringPtrOutput `pulumi:"scheduleInterval"`
	// Default FixedRate. No need to configure this parameter.
	ScheduleType pulumi.StringPtrOutput `pulumi:"scheduleType"`
	// Notification interval, default is no interval. Support number + unit type, for example 60s, 1h.
	Throttling pulumi.StringPtrOutput `pulumi:"throttling"`
}

// NewAlert registers a new resource with the given unique name, arguments, and options.
func NewAlert(ctx *pulumi.Context,
	name string, args *AlertArgs, opts ...pulumi.ResourceOption) (*Alert, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AlertDisplayname == nil {
		return nil, errors.New("invalid value for required argument 'AlertDisplayname'")
	}
	if args.AlertName == nil {
		return nil, errors.New("invalid value for required argument 'AlertName'")
	}
	if args.Condition == nil {
		return nil, errors.New("invalid value for required argument 'Condition'")
	}
	if args.Dashboard == nil {
		return nil, errors.New("invalid value for required argument 'Dashboard'")
	}
	if args.NotificationLists == nil {
		return nil, errors.New("invalid value for required argument 'NotificationLists'")
	}
	if args.ProjectName == nil {
		return nil, errors.New("invalid value for required argument 'ProjectName'")
	}
	if args.QueryLists == nil {
		return nil, errors.New("invalid value for required argument 'QueryLists'")
	}
	var resource Alert
	err := ctx.RegisterResource("alicloud:log/alert:Alert", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAlert gets an existing Alert resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAlert(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AlertState, opts ...pulumi.ResourceOption) (*Alert, error) {
	var resource Alert
	err := ctx.ReadResource("alicloud:log/alert:Alert", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Alert resources.
type alertState struct {
	// Alert description.
	AlertDescription *string `pulumi:"alertDescription"`
	// Alert displayname.
	AlertDisplayname *string `pulumi:"alertDisplayname"`
	// Name of logstore for configuring alarm service.
	AlertName *string `pulumi:"alertName"`
	// Conditional expression, such as: count> 100.
	Condition *string `pulumi:"condition"`
	Dashboard *string `pulumi:"dashboard"`
	// Timestamp, notifications before closing again.
	MuteUntil *int `pulumi:"muteUntil"`
	// Alarm information notification list.
	NotificationLists []AlertNotificationList `pulumi:"notificationLists"`
	// Notification threshold, which is not notified until the number of triggers is reached. The default is 1.
	NotifyThreshold *int `pulumi:"notifyThreshold"`
	// The project name.
	ProjectName *string `pulumi:"projectName"`
	// Multiple conditions for configured alarm query.
	QueryLists []AlertQueryList `pulumi:"queryLists"`
	// Execution interval. 60 seconds minimum, such as 60s, 1h.
	ScheduleInterval *string `pulumi:"scheduleInterval"`
	// Default FixedRate. No need to configure this parameter.
	ScheduleType *string `pulumi:"scheduleType"`
	// Notification interval, default is no interval. Support number + unit type, for example 60s, 1h.
	Throttling *string `pulumi:"throttling"`
}

type AlertState struct {
	// Alert description.
	AlertDescription pulumi.StringPtrInput
	// Alert displayname.
	AlertDisplayname pulumi.StringPtrInput
	// Name of logstore for configuring alarm service.
	AlertName pulumi.StringPtrInput
	// Conditional expression, such as: count> 100.
	Condition pulumi.StringPtrInput
	Dashboard pulumi.StringPtrInput
	// Timestamp, notifications before closing again.
	MuteUntil pulumi.IntPtrInput
	// Alarm information notification list.
	NotificationLists AlertNotificationListArrayInput
	// Notification threshold, which is not notified until the number of triggers is reached. The default is 1.
	NotifyThreshold pulumi.IntPtrInput
	// The project name.
	ProjectName pulumi.StringPtrInput
	// Multiple conditions for configured alarm query.
	QueryLists AlertQueryListArrayInput
	// Execution interval. 60 seconds minimum, such as 60s, 1h.
	ScheduleInterval pulumi.StringPtrInput
	// Default FixedRate. No need to configure this parameter.
	ScheduleType pulumi.StringPtrInput
	// Notification interval, default is no interval. Support number + unit type, for example 60s, 1h.
	Throttling pulumi.StringPtrInput
}

func (AlertState) ElementType() reflect.Type {
	return reflect.TypeOf((*alertState)(nil)).Elem()
}

type alertArgs struct {
	// Alert description.
	AlertDescription *string `pulumi:"alertDescription"`
	// Alert displayname.
	AlertDisplayname string `pulumi:"alertDisplayname"`
	// Name of logstore for configuring alarm service.
	AlertName string `pulumi:"alertName"`
	// Conditional expression, such as: count> 100.
	Condition string `pulumi:"condition"`
	Dashboard string `pulumi:"dashboard"`
	// Timestamp, notifications before closing again.
	MuteUntil *int `pulumi:"muteUntil"`
	// Alarm information notification list.
	NotificationLists []AlertNotificationList `pulumi:"notificationLists"`
	// Notification threshold, which is not notified until the number of triggers is reached. The default is 1.
	NotifyThreshold *int `pulumi:"notifyThreshold"`
	// The project name.
	ProjectName string `pulumi:"projectName"`
	// Multiple conditions for configured alarm query.
	QueryLists []AlertQueryList `pulumi:"queryLists"`
	// Execution interval. 60 seconds minimum, such as 60s, 1h.
	ScheduleInterval *string `pulumi:"scheduleInterval"`
	// Default FixedRate. No need to configure this parameter.
	ScheduleType *string `pulumi:"scheduleType"`
	// Notification interval, default is no interval. Support number + unit type, for example 60s, 1h.
	Throttling *string `pulumi:"throttling"`
}

// The set of arguments for constructing a Alert resource.
type AlertArgs struct {
	// Alert description.
	AlertDescription pulumi.StringPtrInput
	// Alert displayname.
	AlertDisplayname pulumi.StringInput
	// Name of logstore for configuring alarm service.
	AlertName pulumi.StringInput
	// Conditional expression, such as: count> 100.
	Condition pulumi.StringInput
	Dashboard pulumi.StringInput
	// Timestamp, notifications before closing again.
	MuteUntil pulumi.IntPtrInput
	// Alarm information notification list.
	NotificationLists AlertNotificationListArrayInput
	// Notification threshold, which is not notified until the number of triggers is reached. The default is 1.
	NotifyThreshold pulumi.IntPtrInput
	// The project name.
	ProjectName pulumi.StringInput
	// Multiple conditions for configured alarm query.
	QueryLists AlertQueryListArrayInput
	// Execution interval. 60 seconds minimum, such as 60s, 1h.
	ScheduleInterval pulumi.StringPtrInput
	// Default FixedRate. No need to configure this parameter.
	ScheduleType pulumi.StringPtrInput
	// Notification interval, default is no interval. Support number + unit type, for example 60s, 1h.
	Throttling pulumi.StringPtrInput
}

func (AlertArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*alertArgs)(nil)).Elem()
}

type AlertInput interface {
	pulumi.Input

	ToAlertOutput() AlertOutput
	ToAlertOutputWithContext(ctx context.Context) AlertOutput
}

func (*Alert) ElementType() reflect.Type {
	return reflect.TypeOf((**Alert)(nil)).Elem()
}

func (i *Alert) ToAlertOutput() AlertOutput {
	return i.ToAlertOutputWithContext(context.Background())
}

func (i *Alert) ToAlertOutputWithContext(ctx context.Context) AlertOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertOutput)
}

// AlertArrayInput is an input type that accepts AlertArray and AlertArrayOutput values.
// You can construct a concrete instance of `AlertArrayInput` via:
//
//          AlertArray{ AlertArgs{...} }
type AlertArrayInput interface {
	pulumi.Input

	ToAlertArrayOutput() AlertArrayOutput
	ToAlertArrayOutputWithContext(context.Context) AlertArrayOutput
}

type AlertArray []AlertInput

func (AlertArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Alert)(nil)).Elem()
}

func (i AlertArray) ToAlertArrayOutput() AlertArrayOutput {
	return i.ToAlertArrayOutputWithContext(context.Background())
}

func (i AlertArray) ToAlertArrayOutputWithContext(ctx context.Context) AlertArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertArrayOutput)
}

// AlertMapInput is an input type that accepts AlertMap and AlertMapOutput values.
// You can construct a concrete instance of `AlertMapInput` via:
//
//          AlertMap{ "key": AlertArgs{...} }
type AlertMapInput interface {
	pulumi.Input

	ToAlertMapOutput() AlertMapOutput
	ToAlertMapOutputWithContext(context.Context) AlertMapOutput
}

type AlertMap map[string]AlertInput

func (AlertMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Alert)(nil)).Elem()
}

func (i AlertMap) ToAlertMapOutput() AlertMapOutput {
	return i.ToAlertMapOutputWithContext(context.Background())
}

func (i AlertMap) ToAlertMapOutputWithContext(ctx context.Context) AlertMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertMapOutput)
}

type AlertOutput struct{ *pulumi.OutputState }

func (AlertOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Alert)(nil)).Elem()
}

func (o AlertOutput) ToAlertOutput() AlertOutput {
	return o
}

func (o AlertOutput) ToAlertOutputWithContext(ctx context.Context) AlertOutput {
	return o
}

type AlertArrayOutput struct{ *pulumi.OutputState }

func (AlertArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Alert)(nil)).Elem()
}

func (o AlertArrayOutput) ToAlertArrayOutput() AlertArrayOutput {
	return o
}

func (o AlertArrayOutput) ToAlertArrayOutputWithContext(ctx context.Context) AlertArrayOutput {
	return o
}

func (o AlertArrayOutput) Index(i pulumi.IntInput) AlertOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Alert {
		return vs[0].([]*Alert)[vs[1].(int)]
	}).(AlertOutput)
}

type AlertMapOutput struct{ *pulumi.OutputState }

func (AlertMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Alert)(nil)).Elem()
}

func (o AlertMapOutput) ToAlertMapOutput() AlertMapOutput {
	return o
}

func (o AlertMapOutput) ToAlertMapOutputWithContext(ctx context.Context) AlertMapOutput {
	return o
}

func (o AlertMapOutput) MapIndex(k pulumi.StringInput) AlertOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Alert {
		return vs[0].(map[string]*Alert)[vs[1].(string)]
	}).(AlertOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AlertInput)(nil)).Elem(), &Alert{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertArrayInput)(nil)).Elem(), AlertArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertMapInput)(nil)).Elem(), AlertMap{})
	pulumi.RegisterOutputType(AlertOutput{})
	pulumi.RegisterOutputType(AlertArrayOutput{})
	pulumi.RegisterOutputType(AlertMapOutput{})
}
