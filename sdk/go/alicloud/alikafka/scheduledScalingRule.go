// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package alikafka

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Alikafka Scheduled Scaling Rule resource.
//
// Elastic timing strategy.
//
// For information about Alikafka Scheduled Scaling Rule and how to use it, see [What is Scheduled Scaling Rule](https://next.api.alibabacloud.com/document/alikafka/2019-09-16/CreateScheduledScalingRule).
//
// > **NOTE:** Available since v1.269.0.
//
// ## Example Usage
//
// # Basic Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud"
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/alikafka"
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/ecs"
//	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/vpc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			name := "terraform-example"
//			if param := cfg.Get("name"); param != "" {
//				name = param
//			}
//			_default, err := alicloud.GetZones(ctx, &alicloud.GetZonesArgs{
//				AvailableResourceCreation: pulumi.StringRef("VSwitch"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			defaultNetwork, err := vpc.NewNetwork(ctx, "default", &vpc.NetworkArgs{
//				VpcName:   pulumi.String(name),
//				CidrBlock: pulumi.String("10.4.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			defaultSwitch, err := vpc.NewSwitch(ctx, "default", &vpc.SwitchArgs{
//				VswitchName: pulumi.String(name),
//				VpcId:       defaultNetwork.ID(),
//				CidrBlock:   pulumi.String("10.4.0.0/24"),
//				ZoneId:      pulumi.String(_default.Zones[0].Id),
//			})
//			if err != nil {
//				return err
//			}
//			defaultSecurityGroup, err := ecs.NewSecurityGroup(ctx, "default", &ecs.SecurityGroupArgs{
//				VpcId: defaultNetwork.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			defaultInstance, err := alikafka.NewInstance(ctx, "default", &alikafka.InstanceArgs{
//				DeployType:     pulumi.Int(4),
//				InstanceType:   pulumi.String("alikafka_serverless"),
//				VswitchId:      defaultSwitch.ID(),
//				SpecType:       pulumi.String("normal"),
//				ServiceVersion: pulumi.String("3.3.1"),
//				SecurityGroup:  defaultSecurityGroup.ID(),
//				Config:         pulumi.String("{\"enable.acl\":\"true\"}"),
//				ServerlessConfig: &alikafka.InstanceServerlessConfigArgs{
//					ReservedPublishCapacity:   pulumi.Int(60),
//					ReservedSubscribeCapacity: pulumi.Int(60),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = alikafka.NewScheduledScalingRule(ctx, "default", &alikafka.ScheduledScalingRuleArgs{
//				ScheduleType:       pulumi.String("repeat"),
//				ReservedSubFlow:    pulumi.Int(200),
//				ReservedPubFlow:    pulumi.Int(200),
//				TimeZone:           pulumi.String("GMT+8"),
//				DurationMinutes:    pulumi.Int(100),
//				FirstScheduledTime: pulumi.Int(1769578000000),
//				Enable:             pulumi.Bool(false),
//				RepeatType:         pulumi.String("Weekly"),
//				WeeklyTypes: pulumi.StringArray{
//					pulumi.String("Monday"),
//					pulumi.String("Tuesday"),
//					pulumi.String("Wednesday"),
//					pulumi.String("Thursday"),
//					pulumi.String("Friday"),
//				},
//				RuleName:   pulumi.String(name),
//				InstanceId: defaultInstance.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ðŸ“š Need more examples? VIEW MORE EXAMPLES
//
// ## Import
//
// Alikafka Scheduled Scaling Rule can be imported using the id, e.g.
//
// ```sh
// $ pulumi import alicloud:alikafka/scheduledScalingRule:ScheduledScalingRule example <instance_id>:<rule_name>
// ```
type ScheduledScalingRule struct {
	pulumi.CustomResourceState

	// The duration (unit: minutes) of a scheduled elastic task.
	//
	// > **NOTE:** The parameter value must be at least 15 minutes.
	DurationMinutes pulumi.IntOutput `pulumi:"durationMinutes"`
	// Enables or disables the scheduled task policy. Valid values:
	Enable pulumi.BoolPtrOutput `pulumi:"enable"`
	// The time when the scheduled policy starts to execute.
	FirstScheduledTime pulumi.IntOutput `pulumi:"firstScheduledTime"`
	// The instance ID.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// When `scheduleType` is `repeat`, the parameter is required. Valid values:
	// -`Daily`: Daily scheduled task.
	// -`Weekly`: Weekly scheduled task.
	RepeatType pulumi.StringPtrOutput `pulumi:"repeatType"`
	// The scheduled elastic reserved production specification (unit: MB/s).
	ReservedPubFlow pulumi.IntOutput `pulumi:"reservedPubFlow"`
	// The scheduled elastic reserved consumption specification (unit: MB/s).
	ReservedSubFlow pulumi.IntOutput `pulumi:"reservedSubFlow"`
	// The name of the scheduled policy rule.
	RuleName pulumi.StringOutput `pulumi:"ruleName"`
	// The schedule type. Valid values:
	ScheduleType pulumi.StringOutput `pulumi:"scheduleType"`
	// The time zone (Coordinated Universal Time).
	TimeZone pulumi.StringOutput `pulumi:"timeZone"`
	// The weekly types. Supports execution on multiple days. When `repeatType` is set to `Weekly`, you need to input this parameter. Valid values: `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeeklyTypes pulumi.StringArrayOutput `pulumi:"weeklyTypes"`
}

// NewScheduledScalingRule registers a new resource with the given unique name, arguments, and options.
func NewScheduledScalingRule(ctx *pulumi.Context,
	name string, args *ScheduledScalingRuleArgs, opts ...pulumi.ResourceOption) (*ScheduledScalingRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DurationMinutes == nil {
		return nil, errors.New("invalid value for required argument 'DurationMinutes'")
	}
	if args.FirstScheduledTime == nil {
		return nil, errors.New("invalid value for required argument 'FirstScheduledTime'")
	}
	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.ReservedPubFlow == nil {
		return nil, errors.New("invalid value for required argument 'ReservedPubFlow'")
	}
	if args.ReservedSubFlow == nil {
		return nil, errors.New("invalid value for required argument 'ReservedSubFlow'")
	}
	if args.RuleName == nil {
		return nil, errors.New("invalid value for required argument 'RuleName'")
	}
	if args.ScheduleType == nil {
		return nil, errors.New("invalid value for required argument 'ScheduleType'")
	}
	if args.TimeZone == nil {
		return nil, errors.New("invalid value for required argument 'TimeZone'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ScheduledScalingRule
	err := ctx.RegisterResource("alicloud:alikafka/scheduledScalingRule:ScheduledScalingRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetScheduledScalingRule gets an existing ScheduledScalingRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetScheduledScalingRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScheduledScalingRuleState, opts ...pulumi.ResourceOption) (*ScheduledScalingRule, error) {
	var resource ScheduledScalingRule
	err := ctx.ReadResource("alicloud:alikafka/scheduledScalingRule:ScheduledScalingRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ScheduledScalingRule resources.
type scheduledScalingRuleState struct {
	// The duration (unit: minutes) of a scheduled elastic task.
	//
	// > **NOTE:** The parameter value must be at least 15 minutes.
	DurationMinutes *int `pulumi:"durationMinutes"`
	// Enables or disables the scheduled task policy. Valid values:
	Enable *bool `pulumi:"enable"`
	// The time when the scheduled policy starts to execute.
	FirstScheduledTime *int `pulumi:"firstScheduledTime"`
	// The instance ID.
	InstanceId *string `pulumi:"instanceId"`
	// When `scheduleType` is `repeat`, the parameter is required. Valid values:
	// -`Daily`: Daily scheduled task.
	// -`Weekly`: Weekly scheduled task.
	RepeatType *string `pulumi:"repeatType"`
	// The scheduled elastic reserved production specification (unit: MB/s).
	ReservedPubFlow *int `pulumi:"reservedPubFlow"`
	// The scheduled elastic reserved consumption specification (unit: MB/s).
	ReservedSubFlow *int `pulumi:"reservedSubFlow"`
	// The name of the scheduled policy rule.
	RuleName *string `pulumi:"ruleName"`
	// The schedule type. Valid values:
	ScheduleType *string `pulumi:"scheduleType"`
	// The time zone (Coordinated Universal Time).
	TimeZone *string `pulumi:"timeZone"`
	// The weekly types. Supports execution on multiple days. When `repeatType` is set to `Weekly`, you need to input this parameter. Valid values: `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeeklyTypes []string `pulumi:"weeklyTypes"`
}

type ScheduledScalingRuleState struct {
	// The duration (unit: minutes) of a scheduled elastic task.
	//
	// > **NOTE:** The parameter value must be at least 15 minutes.
	DurationMinutes pulumi.IntPtrInput
	// Enables or disables the scheduled task policy. Valid values:
	Enable pulumi.BoolPtrInput
	// The time when the scheduled policy starts to execute.
	FirstScheduledTime pulumi.IntPtrInput
	// The instance ID.
	InstanceId pulumi.StringPtrInput
	// When `scheduleType` is `repeat`, the parameter is required. Valid values:
	// -`Daily`: Daily scheduled task.
	// -`Weekly`: Weekly scheduled task.
	RepeatType pulumi.StringPtrInput
	// The scheduled elastic reserved production specification (unit: MB/s).
	ReservedPubFlow pulumi.IntPtrInput
	// The scheduled elastic reserved consumption specification (unit: MB/s).
	ReservedSubFlow pulumi.IntPtrInput
	// The name of the scheduled policy rule.
	RuleName pulumi.StringPtrInput
	// The schedule type. Valid values:
	ScheduleType pulumi.StringPtrInput
	// The time zone (Coordinated Universal Time).
	TimeZone pulumi.StringPtrInput
	// The weekly types. Supports execution on multiple days. When `repeatType` is set to `Weekly`, you need to input this parameter. Valid values: `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeeklyTypes pulumi.StringArrayInput
}

func (ScheduledScalingRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduledScalingRuleState)(nil)).Elem()
}

type scheduledScalingRuleArgs struct {
	// The duration (unit: minutes) of a scheduled elastic task.
	//
	// > **NOTE:** The parameter value must be at least 15 minutes.
	DurationMinutes int `pulumi:"durationMinutes"`
	// Enables or disables the scheduled task policy. Valid values:
	Enable *bool `pulumi:"enable"`
	// The time when the scheduled policy starts to execute.
	FirstScheduledTime int `pulumi:"firstScheduledTime"`
	// The instance ID.
	InstanceId string `pulumi:"instanceId"`
	// When `scheduleType` is `repeat`, the parameter is required. Valid values:
	// -`Daily`: Daily scheduled task.
	// -`Weekly`: Weekly scheduled task.
	RepeatType *string `pulumi:"repeatType"`
	// The scheduled elastic reserved production specification (unit: MB/s).
	ReservedPubFlow int `pulumi:"reservedPubFlow"`
	// The scheduled elastic reserved consumption specification (unit: MB/s).
	ReservedSubFlow int `pulumi:"reservedSubFlow"`
	// The name of the scheduled policy rule.
	RuleName string `pulumi:"ruleName"`
	// The schedule type. Valid values:
	ScheduleType string `pulumi:"scheduleType"`
	// The time zone (Coordinated Universal Time).
	TimeZone string `pulumi:"timeZone"`
	// The weekly types. Supports execution on multiple days. When `repeatType` is set to `Weekly`, you need to input this parameter. Valid values: `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeeklyTypes []string `pulumi:"weeklyTypes"`
}

// The set of arguments for constructing a ScheduledScalingRule resource.
type ScheduledScalingRuleArgs struct {
	// The duration (unit: minutes) of a scheduled elastic task.
	//
	// > **NOTE:** The parameter value must be at least 15 minutes.
	DurationMinutes pulumi.IntInput
	// Enables or disables the scheduled task policy. Valid values:
	Enable pulumi.BoolPtrInput
	// The time when the scheduled policy starts to execute.
	FirstScheduledTime pulumi.IntInput
	// The instance ID.
	InstanceId pulumi.StringInput
	// When `scheduleType` is `repeat`, the parameter is required. Valid values:
	// -`Daily`: Daily scheduled task.
	// -`Weekly`: Weekly scheduled task.
	RepeatType pulumi.StringPtrInput
	// The scheduled elastic reserved production specification (unit: MB/s).
	ReservedPubFlow pulumi.IntInput
	// The scheduled elastic reserved consumption specification (unit: MB/s).
	ReservedSubFlow pulumi.IntInput
	// The name of the scheduled policy rule.
	RuleName pulumi.StringInput
	// The schedule type. Valid values:
	ScheduleType pulumi.StringInput
	// The time zone (Coordinated Universal Time).
	TimeZone pulumi.StringInput
	// The weekly types. Supports execution on multiple days. When `repeatType` is set to `Weekly`, you need to input this parameter. Valid values: `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
	WeeklyTypes pulumi.StringArrayInput
}

func (ScheduledScalingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduledScalingRuleArgs)(nil)).Elem()
}

type ScheduledScalingRuleInput interface {
	pulumi.Input

	ToScheduledScalingRuleOutput() ScheduledScalingRuleOutput
	ToScheduledScalingRuleOutputWithContext(ctx context.Context) ScheduledScalingRuleOutput
}

func (*ScheduledScalingRule) ElementType() reflect.Type {
	return reflect.TypeOf((**ScheduledScalingRule)(nil)).Elem()
}

func (i *ScheduledScalingRule) ToScheduledScalingRuleOutput() ScheduledScalingRuleOutput {
	return i.ToScheduledScalingRuleOutputWithContext(context.Background())
}

func (i *ScheduledScalingRule) ToScheduledScalingRuleOutputWithContext(ctx context.Context) ScheduledScalingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduledScalingRuleOutput)
}

// ScheduledScalingRuleArrayInput is an input type that accepts ScheduledScalingRuleArray and ScheduledScalingRuleArrayOutput values.
// You can construct a concrete instance of `ScheduledScalingRuleArrayInput` via:
//
//	ScheduledScalingRuleArray{ ScheduledScalingRuleArgs{...} }
type ScheduledScalingRuleArrayInput interface {
	pulumi.Input

	ToScheduledScalingRuleArrayOutput() ScheduledScalingRuleArrayOutput
	ToScheduledScalingRuleArrayOutputWithContext(context.Context) ScheduledScalingRuleArrayOutput
}

type ScheduledScalingRuleArray []ScheduledScalingRuleInput

func (ScheduledScalingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScheduledScalingRule)(nil)).Elem()
}

func (i ScheduledScalingRuleArray) ToScheduledScalingRuleArrayOutput() ScheduledScalingRuleArrayOutput {
	return i.ToScheduledScalingRuleArrayOutputWithContext(context.Background())
}

func (i ScheduledScalingRuleArray) ToScheduledScalingRuleArrayOutputWithContext(ctx context.Context) ScheduledScalingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduledScalingRuleArrayOutput)
}

// ScheduledScalingRuleMapInput is an input type that accepts ScheduledScalingRuleMap and ScheduledScalingRuleMapOutput values.
// You can construct a concrete instance of `ScheduledScalingRuleMapInput` via:
//
//	ScheduledScalingRuleMap{ "key": ScheduledScalingRuleArgs{...} }
type ScheduledScalingRuleMapInput interface {
	pulumi.Input

	ToScheduledScalingRuleMapOutput() ScheduledScalingRuleMapOutput
	ToScheduledScalingRuleMapOutputWithContext(context.Context) ScheduledScalingRuleMapOutput
}

type ScheduledScalingRuleMap map[string]ScheduledScalingRuleInput

func (ScheduledScalingRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScheduledScalingRule)(nil)).Elem()
}

func (i ScheduledScalingRuleMap) ToScheduledScalingRuleMapOutput() ScheduledScalingRuleMapOutput {
	return i.ToScheduledScalingRuleMapOutputWithContext(context.Background())
}

func (i ScheduledScalingRuleMap) ToScheduledScalingRuleMapOutputWithContext(ctx context.Context) ScheduledScalingRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduledScalingRuleMapOutput)
}

type ScheduledScalingRuleOutput struct{ *pulumi.OutputState }

func (ScheduledScalingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScheduledScalingRule)(nil)).Elem()
}

func (o ScheduledScalingRuleOutput) ToScheduledScalingRuleOutput() ScheduledScalingRuleOutput {
	return o
}

func (o ScheduledScalingRuleOutput) ToScheduledScalingRuleOutputWithContext(ctx context.Context) ScheduledScalingRuleOutput {
	return o
}

// The duration (unit: minutes) of a scheduled elastic task.
//
// > **NOTE:** The parameter value must be at least 15 minutes.
func (o ScheduledScalingRuleOutput) DurationMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.IntOutput { return v.DurationMinutes }).(pulumi.IntOutput)
}

// Enables or disables the scheduled task policy. Valid values:
func (o ScheduledScalingRuleOutput) Enable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.BoolPtrOutput { return v.Enable }).(pulumi.BoolPtrOutput)
}

// The time when the scheduled policy starts to execute.
func (o ScheduledScalingRuleOutput) FirstScheduledTime() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.IntOutput { return v.FirstScheduledTime }).(pulumi.IntOutput)
}

// The instance ID.
func (o ScheduledScalingRuleOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// When `scheduleType` is `repeat`, the parameter is required. Valid values:
// -`Daily`: Daily scheduled task.
// -`Weekly`: Weekly scheduled task.
func (o ScheduledScalingRuleOutput) RepeatType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.StringPtrOutput { return v.RepeatType }).(pulumi.StringPtrOutput)
}

// The scheduled elastic reserved production specification (unit: MB/s).
func (o ScheduledScalingRuleOutput) ReservedPubFlow() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.IntOutput { return v.ReservedPubFlow }).(pulumi.IntOutput)
}

// The scheduled elastic reserved consumption specification (unit: MB/s).
func (o ScheduledScalingRuleOutput) ReservedSubFlow() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.IntOutput { return v.ReservedSubFlow }).(pulumi.IntOutput)
}

// The name of the scheduled policy rule.
func (o ScheduledScalingRuleOutput) RuleName() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.StringOutput { return v.RuleName }).(pulumi.StringOutput)
}

// The schedule type. Valid values:
func (o ScheduledScalingRuleOutput) ScheduleType() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.StringOutput { return v.ScheduleType }).(pulumi.StringOutput)
}

// The time zone (Coordinated Universal Time).
func (o ScheduledScalingRuleOutput) TimeZone() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.StringOutput { return v.TimeZone }).(pulumi.StringOutput)
}

// The weekly types. Supports execution on multiple days. When `repeatType` is set to `Weekly`, you need to input this parameter. Valid values: `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
func (o ScheduledScalingRuleOutput) WeeklyTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ScheduledScalingRule) pulumi.StringArrayOutput { return v.WeeklyTypes }).(pulumi.StringArrayOutput)
}

type ScheduledScalingRuleArrayOutput struct{ *pulumi.OutputState }

func (ScheduledScalingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScheduledScalingRule)(nil)).Elem()
}

func (o ScheduledScalingRuleArrayOutput) ToScheduledScalingRuleArrayOutput() ScheduledScalingRuleArrayOutput {
	return o
}

func (o ScheduledScalingRuleArrayOutput) ToScheduledScalingRuleArrayOutputWithContext(ctx context.Context) ScheduledScalingRuleArrayOutput {
	return o
}

func (o ScheduledScalingRuleArrayOutput) Index(i pulumi.IntInput) ScheduledScalingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ScheduledScalingRule {
		return vs[0].([]*ScheduledScalingRule)[vs[1].(int)]
	}).(ScheduledScalingRuleOutput)
}

type ScheduledScalingRuleMapOutput struct{ *pulumi.OutputState }

func (ScheduledScalingRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScheduledScalingRule)(nil)).Elem()
}

func (o ScheduledScalingRuleMapOutput) ToScheduledScalingRuleMapOutput() ScheduledScalingRuleMapOutput {
	return o
}

func (o ScheduledScalingRuleMapOutput) ToScheduledScalingRuleMapOutputWithContext(ctx context.Context) ScheduledScalingRuleMapOutput {
	return o
}

func (o ScheduledScalingRuleMapOutput) MapIndex(k pulumi.StringInput) ScheduledScalingRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ScheduledScalingRule {
		return vs[0].(map[string]*ScheduledScalingRule)[vs[1].(string)]
	}).(ScheduledScalingRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduledScalingRuleInput)(nil)).Elem(), &ScheduledScalingRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduledScalingRuleArrayInput)(nil)).Elem(), ScheduledScalingRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduledScalingRuleMapInput)(nil)).Elem(), ScheduledScalingRuleMap{})
	pulumi.RegisterOutputType(ScheduledScalingRuleOutput{})
	pulumi.RegisterOutputType(ScheduledScalingRuleArrayOutput{})
	pulumi.RegisterOutputType(ScheduledScalingRuleMapOutput{})
}
