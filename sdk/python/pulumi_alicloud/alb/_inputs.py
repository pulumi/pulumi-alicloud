# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AScriptExtAttributeArgs',
    'AScriptExtAttributeArgsDict',
    'AclAclEntryArgs',
    'AclAclEntryArgsDict',
    'ListenerAccessLogTracingConfigArgs',
    'ListenerAccessLogTracingConfigArgsDict',
    'ListenerAclConfigArgs',
    'ListenerAclConfigArgsDict',
    'ListenerAclConfigAclRelationArgs',
    'ListenerAclConfigAclRelationArgsDict',
    'ListenerCaCertificateArgs',
    'ListenerCaCertificateArgsDict',
    'ListenerCertificatesArgs',
    'ListenerCertificatesArgsDict',
    'ListenerDefaultActionArgs',
    'ListenerDefaultActionArgsDict',
    'ListenerDefaultActionForwardGroupConfigArgs',
    'ListenerDefaultActionForwardGroupConfigArgsDict',
    'ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs',
    'ListenerDefaultActionForwardGroupConfigServerGroupTupleArgsDict',
    'ListenerQuicConfigArgs',
    'ListenerQuicConfigArgsDict',
    'ListenerXForwardedForConfigArgs',
    'ListenerXForwardedForConfigArgsDict',
    'LoadBalancerAccessLogConfigArgs',
    'LoadBalancerAccessLogConfigArgsDict',
    'LoadBalancerDeletionProtectionConfigArgs',
    'LoadBalancerDeletionProtectionConfigArgsDict',
    'LoadBalancerLoadBalancerBillingConfigArgs',
    'LoadBalancerLoadBalancerBillingConfigArgsDict',
    'LoadBalancerModificationProtectionConfigArgs',
    'LoadBalancerModificationProtectionConfigArgsDict',
    'LoadBalancerZoneMappingArgs',
    'LoadBalancerZoneMappingArgsDict',
    'LoadBalancerZoneMappingLoadBalancerAddressArgs',
    'LoadBalancerZoneMappingLoadBalancerAddressArgsDict',
    'RuleRuleActionArgs',
    'RuleRuleActionArgsDict',
    'RuleRuleActionCorsConfigArgs',
    'RuleRuleActionCorsConfigArgsDict',
    'RuleRuleActionFixedResponseConfigArgs',
    'RuleRuleActionFixedResponseConfigArgsDict',
    'RuleRuleActionForwardGroupConfigArgs',
    'RuleRuleActionForwardGroupConfigArgsDict',
    'RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs',
    'RuleRuleActionForwardGroupConfigServerGroupStickySessionArgsDict',
    'RuleRuleActionForwardGroupConfigServerGroupTupleArgs',
    'RuleRuleActionForwardGroupConfigServerGroupTupleArgsDict',
    'RuleRuleActionInsertHeaderConfigArgs',
    'RuleRuleActionInsertHeaderConfigArgsDict',
    'RuleRuleActionRedirectConfigArgs',
    'RuleRuleActionRedirectConfigArgsDict',
    'RuleRuleActionRemoveHeaderConfigArgs',
    'RuleRuleActionRemoveHeaderConfigArgsDict',
    'RuleRuleActionRewriteConfigArgs',
    'RuleRuleActionRewriteConfigArgsDict',
    'RuleRuleActionTrafficLimitConfigArgs',
    'RuleRuleActionTrafficLimitConfigArgsDict',
    'RuleRuleActionTrafficMirrorConfigArgs',
    'RuleRuleActionTrafficMirrorConfigArgsDict',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgsDict',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgsDict',
    'RuleRuleConditionArgs',
    'RuleRuleConditionArgsDict',
    'RuleRuleConditionCookieConfigArgs',
    'RuleRuleConditionCookieConfigArgsDict',
    'RuleRuleConditionCookieConfigValueArgs',
    'RuleRuleConditionCookieConfigValueArgsDict',
    'RuleRuleConditionHeaderConfigArgs',
    'RuleRuleConditionHeaderConfigArgsDict',
    'RuleRuleConditionHostConfigArgs',
    'RuleRuleConditionHostConfigArgsDict',
    'RuleRuleConditionMethodConfigArgs',
    'RuleRuleConditionMethodConfigArgsDict',
    'RuleRuleConditionPathConfigArgs',
    'RuleRuleConditionPathConfigArgsDict',
    'RuleRuleConditionQueryStringConfigArgs',
    'RuleRuleConditionQueryStringConfigArgsDict',
    'RuleRuleConditionQueryStringConfigValueArgs',
    'RuleRuleConditionQueryStringConfigValueArgsDict',
    'RuleRuleConditionResponseHeaderConfigArgs',
    'RuleRuleConditionResponseHeaderConfigArgsDict',
    'RuleRuleConditionResponseStatusCodeConfigArgs',
    'RuleRuleConditionResponseStatusCodeConfigArgsDict',
    'RuleRuleConditionSourceIpConfigArgs',
    'RuleRuleConditionSourceIpConfigArgsDict',
    'ServerGroupConnectionDrainConfigArgs',
    'ServerGroupConnectionDrainConfigArgsDict',
    'ServerGroupHealthCheckConfigArgs',
    'ServerGroupHealthCheckConfigArgsDict',
    'ServerGroupServerArgs',
    'ServerGroupServerArgsDict',
    'ServerGroupSlowStartConfigArgs',
    'ServerGroupSlowStartConfigArgsDict',
    'ServerGroupStickySessionConfigArgs',
    'ServerGroupStickySessionConfigArgsDict',
    'ServerGroupUchConfigArgs',
    'ServerGroupUchConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AScriptExtAttributeArgsDict(TypedDict):
        attribute_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key to extend attribute
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the extended attribute
        """
elif False:
    AScriptExtAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AScriptExtAttributeArgs:
    def __init__(__self__, *,
                 attribute_key: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_key: Key to extend attribute
        :param pulumi.Input[_builtins.str] attribute_value: The value of the extended attribute
        """
        if attribute_key is not None:
            pulumi.set(__self__, "attribute_key", attribute_key)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)

    @_builtins.property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key to extend attribute
        """
        return pulumi.get(self, "attribute_key")

    @attribute_key.setter
    def attribute_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_key", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the extended attribute
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)


if not MYPY:
    class AclAclEntryArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        """
        entry: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address for the ACL entry.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the ACL entry. Valid values:
        - `Adding`: The ACL entry is being added.
        - `Available`: The ACL entry is added and available.
        - `Removing`: The ACL entry is being removed.
        """
elif False:
    AclAclEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AclAclEntryArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 entry: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        :param pulumi.Input[_builtins.str] entry: The IP address for the ACL entry.
        :param pulumi.Input[_builtins.str] status: The status of the ACL entry. Valid values:
               - `Adding`: The ACL entry is being added.
               - `Available`: The ACL entry is added and available.
               - `Removing`: The ACL entry is being removed.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entry is not None:
            pulumi.set(__self__, "entry", entry)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def entry(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address for the ACL entry.
        """
        return pulumi.get(self, "entry")

    @entry.setter
    def entry(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the ACL entry. Valid values:
        - `Adding`: The ACL entry is being added.
        - `Available`: The ACL entry is added and available.
        - `Removing`: The ACL entry is being removed.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ListenerAccessLogTracingConfigArgsDict(TypedDict):
        tracing_enabled: pulumi.Input[_builtins.bool]
        """
        Xtrace Function. Valid values: `true`, `false`. Default Value: `false`.

        > **NOTE:**  Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the value `true`.
        """
        tracing_sample: NotRequired[pulumi.Input[_builtins.int]]
        """
        Xtrace Sampling Rate. Value: 1~10000. `tracingenabled` valued True When Effective.
        """
        tracing_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Xtrace Type Value Is `Zipkin`.

        > **NOTE:**  `tracingenabled` valued True When Effective.
        """
elif False:
    ListenerAccessLogTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerAccessLogTracingConfigArgs:
    def __init__(__self__, *,
                 tracing_enabled: pulumi.Input[_builtins.bool],
                 tracing_sample: Optional[pulumi.Input[_builtins.int]] = None,
                 tracing_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] tracing_enabled: Xtrace Function. Valid values: `true`, `false`. Default Value: `false`.
               
               > **NOTE:**  Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the value `true`.
        :param pulumi.Input[_builtins.int] tracing_sample: Xtrace Sampling Rate. Value: 1~10000. `tracingenabled` valued True When Effective.
        :param pulumi.Input[_builtins.str] tracing_type: Xtrace Type Value Is `Zipkin`.
               
               > **NOTE:**  `tracingenabled` valued True When Effective.
        """
        pulumi.set(__self__, "tracing_enabled", tracing_enabled)
        if tracing_sample is not None:
            pulumi.set(__self__, "tracing_sample", tracing_sample)
        if tracing_type is not None:
            pulumi.set(__self__, "tracing_type", tracing_type)

    @_builtins.property
    @pulumi.getter(name="tracingEnabled")
    def tracing_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Xtrace Function. Valid values: `true`, `false`. Default Value: `false`.

        > **NOTE:**  Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the value `true`.
        """
        return pulumi.get(self, "tracing_enabled")

    @tracing_enabled.setter
    def tracing_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "tracing_enabled", value)

    @_builtins.property
    @pulumi.getter(name="tracingSample")
    def tracing_sample(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Xtrace Sampling Rate. Value: 1~10000. `tracingenabled` valued True When Effective.
        """
        return pulumi.get(self, "tracing_sample")

    @tracing_sample.setter
    def tracing_sample(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tracing_sample", value)

    @_builtins.property
    @pulumi.getter(name="tracingType")
    def tracing_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Xtrace Type Value Is `Zipkin`.

        > **NOTE:**  `tracingenabled` valued True When Effective.
        """
        return pulumi.get(self, "tracing_type")

    @tracing_type.setter
    def tracing_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tracing_type", value)


if not MYPY:
    class ListenerAclConfigArgsDict(TypedDict):
        acl_relations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgsDict']]]]
        """
        The ACLs that are associated with the listener. See `acl_relations` below for details.
        """
        acl_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
elif False:
    ListenerAclConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerAclConfigArgs:
    def __init__(__self__, *,
                 acl_relations: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]]] = None,
                 acl_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]] acl_relations: The ACLs that are associated with the listener. See `acl_relations` below for details.
        :param pulumi.Input[_builtins.str] acl_type: The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        if acl_relations is not None:
            pulumi.set(__self__, "acl_relations", acl_relations)
        if acl_type is not None:
            pulumi.set(__self__, "acl_type", acl_type)

    @_builtins.property
    @pulumi.getter(name="aclRelations")
    def acl_relations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]]]:
        """
        The ACLs that are associated with the listener. See `acl_relations` below for details.
        """
        return pulumi.get(self, "acl_relations")

    @acl_relations.setter
    def acl_relations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]]]):
        pulumi.set(self, "acl_relations", value)

    @_builtins.property
    @pulumi.getter(name="aclType")
    def acl_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        return pulumi.get(self, "acl_type")

    @acl_type.setter
    def acl_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl_type", value)


if not MYPY:
    class ListenerAclConfigAclRelationArgsDict(TypedDict):
        acl_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Snooping Binding of the Access Policy Group ID List.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Current IP Address of the Listened State
        """
elif False:
    ListenerAclConfigAclRelationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerAclConfigAclRelationArgs:
    def __init__(__self__, *,
                 acl_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] acl_id: Snooping Binding of the Access Policy Group ID List.
        :param pulumi.Input[_builtins.str] status: The Current IP Address of the Listened State
        """
        if acl_id is not None:
            pulumi.set(__self__, "acl_id", acl_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="aclId")
    def acl_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Snooping Binding of the Access Policy Group ID List.
        """
        return pulumi.get(self, "acl_id")

    @acl_id.setter
    def acl_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Current IP Address of the Listened State
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ListenerCaCertificateArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the certificate. Currently, only server certificates are supported.
        """
elif False:
    ListenerCaCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerCaCertificateArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_id: The ID of the certificate. Currently, only server certificates are supported.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the certificate. Currently, only server certificates are supported.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class ListenerCertificatesArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the certificate. Currently, only server certificates are supported.
        """
elif False:
    ListenerCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerCertificatesArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_id: The ID of the certificate. Currently, only server certificates are supported.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the certificate. Currently, only server certificates are supported.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class ListenerDefaultActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The action type. Value: ForwardGroup, indicating forwarding to the server group.
        """
        forward_group_config: NotRequired[pulumi.Input['ListenerDefaultActionForwardGroupConfigArgsDict']]
        """
        Forwarding Action Configurations See `forward_group_config` below.
        """
elif False:
    ListenerDefaultActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 forward_group_config: Optional[pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: The action type. Value: ForwardGroup, indicating forwarding to the server group.
        :param pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs'] forward_group_config: Forwarding Action Configurations See `forward_group_config` below.
        """
        pulumi.set(__self__, "type", type)
        if forward_group_config is not None:
            pulumi.set(__self__, "forward_group_config", forward_group_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type. Value: ForwardGroup, indicating forwarding to the server group.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="forwardGroupConfig")
    def forward_group_config(self) -> Optional[pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs']]:
        """
        Forwarding Action Configurations See `forward_group_config` below.
        """
        return pulumi.get(self, "forward_group_config")

    @forward_group_config.setter
    def forward_group_config(self, value: Optional[pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs']]):
        pulumi.set(self, "forward_group_config", value)


if not MYPY:
    class ListenerDefaultActionForwardGroupConfigArgsDict(TypedDict):
        server_group_tuples: pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgsDict']]]
        """
        The Forwarding Destination Server Group See `server_group_tuples` below.
        """
elif False:
    ListenerDefaultActionForwardGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionForwardGroupConfigArgs:
    def __init__(__self__, *,
                 server_group_tuples: pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]] server_group_tuples: The Forwarding Destination Server Group See `server_group_tuples` below.
        """
        pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]]:
        """
        The Forwarding Destination Server Group See `server_group_tuples` below.
        """
        return pulumi.get(self, "server_group_tuples")

    @server_group_tuples.setter
    def server_group_tuples(self, value: pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]]):
        pulumi.set(self, "server_group_tuples", value)


if not MYPY:
    class ListenerDefaultActionForwardGroupConfigServerGroupTupleArgsDict(TypedDict):
        server_group_id: pulumi.Input[_builtins.str]
        """
        Forwarded to the Destination Server Group ID
        """
elif False:
    ListenerDefaultActionForwardGroupConfigServerGroupTupleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs:
    def __init__(__self__, *,
                 server_group_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] server_group_id: Forwarded to the Destination Server Group ID
        """
        pulumi.set(__self__, "server_group_id", server_group_id)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Forwarded to the Destination Server Group ID
        """
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_group_id", value)


if not MYPY:
    class ListenerQuicConfigArgsDict(TypedDict):
        quic_listener_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        """
        quic_upgrade_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether to Enable the QuIC Upgrade
        """
elif False:
    ListenerQuicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerQuicConfigArgs:
    def __init__(__self__, *,
                 quic_listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 quic_upgrade_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] quic_listener_id: There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        :param pulumi.Input[_builtins.bool] quic_upgrade_enabled: Indicates Whether to Enable the QuIC Upgrade
        """
        if quic_listener_id is not None:
            pulumi.set(__self__, "quic_listener_id", quic_listener_id)
        if quic_upgrade_enabled is not None:
            pulumi.set(__self__, "quic_upgrade_enabled", quic_upgrade_enabled)

    @_builtins.property
    @pulumi.getter(name="quicListenerId")
    def quic_listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        """
        return pulumi.get(self, "quic_listener_id")

    @quic_listener_id.setter
    def quic_listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quic_listener_id", value)

    @_builtins.property
    @pulumi.getter(name="quicUpgradeEnabled")
    def quic_upgrade_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether to Enable the QuIC Upgrade
        """
        return pulumi.get(self, "quic_upgrade_enabled")

    @quic_upgrade_enabled.setter
    def quic_upgrade_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "quic_upgrade_enabled", value)


if not MYPY:
    class ListenerXForwardedForConfigArgsDict(TypedDict):
        x_forwarded_for_client_cert_client_verify_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Custom Header Field Names Only When xforwardedforclientcertclientverifyenabled Has a Value of True, this Value Will Not Take Effect until.
        """
        x_forwarded_for_client_cert_client_verify_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Clientcert-clientverify Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        """
        x_forwarded_for_client_cert_finger_print_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Custom Header Field Names Only When xforwardedforclientcertfingerprintenabled, Which Evaluates to True When the Entry into Force of.
        """
        x_forwarded_for_client_cert_finger_print_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Clientcert-fingerprint Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        """
        x_forwarded_for_client_cert_issuer_dn_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Custom Header Field Names Only When xforwardedforclientcertsubjectdnenabled, Which Evaluates to True When the Entry into Force of.
        """
        x_forwarded_for_client_cert_issuer_dn_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Clientcert-issuerdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        """
        x_forwarded_for_client_cert_subject_dn_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Custom Header Field Name,
        """
        x_forwarded_for_client_cert_subject_dn_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Clientcert-subjectdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Owner Information.
        """
        x_forwarded_for_client_source_ips_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value:
        """
        x_forwarded_for_client_source_ips_trusted: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        """
        x_forwarded_for_client_src_port_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        """
        x_forwarded_for_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        """
        x_forwarded_for_host_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable the X-Forwarded-Host header field to obtain the domain name of the client accessing the Application Load Balancer. Value:
        """
        x_forwarded_for_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema for processing X-Forwarded-For header fields. This value takes effect only when XForwardedForEnabled is true. Value:
        """
        x_forwarded_for_proto_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        """
        x_forwarded_for_slb_id_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id
        """
        x_forwarded_for_slb_port_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port
        """
elif False:
    ListenerXForwardedForConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerXForwardedForConfigArgs:
    def __init__(__self__, *,
                 x_forwarded_for_client_cert_client_verify_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_for_client_cert_client_verify_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_client_cert_finger_print_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_for_client_cert_finger_print_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_client_cert_issuer_dn_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_for_client_cert_issuer_dn_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_client_cert_subject_dn_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_for_client_cert_subject_dn_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_client_source_ips_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_client_source_ips_trusted: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_for_client_src_port_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_host_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_processing_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_for_proto_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_slb_id_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 x_forwarded_for_slb_port_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] x_forwarded_for_client_cert_client_verify_alias: The Custom Header Field Names Only When xforwardedforclientcertclientverifyenabled Has a Value of True, this Value Will Not Take Effect until.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_client_cert_client_verify_enabled: Indicates Whether the X-Forwarded-Clientcert-clientverify Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        :param pulumi.Input[_builtins.str] x_forwarded_for_client_cert_finger_print_alias: The Custom Header Field Names Only When xforwardedforclientcertfingerprintenabled, Which Evaluates to True When the Entry into Force of.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_client_cert_finger_print_enabled: Indicates Whether the X-Forwarded-Clientcert-fingerprint Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        :param pulumi.Input[_builtins.str] x_forwarded_for_client_cert_issuer_dn_alias: The Custom Header Field Names Only When xforwardedforclientcertsubjectdnenabled, Which Evaluates to True When the Entry into Force of.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_client_cert_issuer_dn_enabled: Indicates Whether the X-Forwarded-Clientcert-issuerdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        :param pulumi.Input[_builtins.str] x_forwarded_for_client_cert_subject_dn_alias: The Custom Header Field Name,
        :param pulumi.Input[_builtins.bool] x_forwarded_for_client_cert_subject_dn_enabled: Indicates Whether the X-Forwarded-Clientcert-subjectdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Owner Information.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_client_source_ips_enabled: Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value:
        :param pulumi.Input[_builtins.str] x_forwarded_for_client_source_ips_trusted: Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_client_src_port_enabled: Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_enabled: Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_host_enabled: Whether to enable the X-Forwarded-Host header field to obtain the domain name of the client accessing the Application Load Balancer. Value:
        :param pulumi.Input[_builtins.str] x_forwarded_for_processing_mode: Schema for processing X-Forwarded-For header fields. This value takes effect only when XForwardedForEnabled is true. Value:
        :param pulumi.Input[_builtins.bool] x_forwarded_for_proto_enabled: Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        :param pulumi.Input[_builtins.bool] x_forwarded_for_slb_id_enabled: Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id
        :param pulumi.Input[_builtins.bool] x_forwarded_for_slb_port_enabled: Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port
        """
        if x_forwarded_for_client_cert_client_verify_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_client_verify_alias", x_forwarded_for_client_cert_client_verify_alias)
        if x_forwarded_for_client_cert_client_verify_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_client_verify_enabled", x_forwarded_for_client_cert_client_verify_enabled)
        if x_forwarded_for_client_cert_finger_print_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_finger_print_alias", x_forwarded_for_client_cert_finger_print_alias)
        if x_forwarded_for_client_cert_finger_print_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_finger_print_enabled", x_forwarded_for_client_cert_finger_print_enabled)
        if x_forwarded_for_client_cert_issuer_dn_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_issuer_dn_alias", x_forwarded_for_client_cert_issuer_dn_alias)
        if x_forwarded_for_client_cert_issuer_dn_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_issuer_dn_enabled", x_forwarded_for_client_cert_issuer_dn_enabled)
        if x_forwarded_for_client_cert_subject_dn_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_subject_dn_alias", x_forwarded_for_client_cert_subject_dn_alias)
        if x_forwarded_for_client_cert_subject_dn_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_subject_dn_enabled", x_forwarded_for_client_cert_subject_dn_enabled)
        if x_forwarded_for_client_source_ips_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_source_ips_enabled", x_forwarded_for_client_source_ips_enabled)
        if x_forwarded_for_client_source_ips_trusted is not None:
            pulumi.set(__self__, "x_forwarded_for_client_source_ips_trusted", x_forwarded_for_client_source_ips_trusted)
        if x_forwarded_for_client_src_port_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_src_port_enabled", x_forwarded_for_client_src_port_enabled)
        if x_forwarded_for_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_enabled", x_forwarded_for_enabled)
        if x_forwarded_for_host_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_host_enabled", x_forwarded_for_host_enabled)
        if x_forwarded_for_processing_mode is not None:
            pulumi.set(__self__, "x_forwarded_for_processing_mode", x_forwarded_for_processing_mode)
        if x_forwarded_for_proto_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_proto_enabled", x_forwarded_for_proto_enabled)
        if x_forwarded_for_slb_id_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_slb_id_enabled", x_forwarded_for_slb_id_enabled)
        if x_forwarded_for_slb_port_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_slb_port_enabled", x_forwarded_for_slb_port_enabled)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertClientVerifyAlias")
    def x_forwarded_for_client_cert_client_verify_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Custom Header Field Names Only When xforwardedforclientcertclientverifyenabled Has a Value of True, this Value Will Not Take Effect until.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_client_verify_alias")

    @x_forwarded_for_client_cert_client_verify_alias.setter
    def x_forwarded_for_client_cert_client_verify_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_client_verify_alias", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertClientVerifyEnabled")
    def x_forwarded_for_client_cert_client_verify_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Clientcert-clientverify Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_client_verify_enabled")

    @x_forwarded_for_client_cert_client_verify_enabled.setter
    def x_forwarded_for_client_cert_client_verify_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_client_verify_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertFingerPrintAlias")
    def x_forwarded_for_client_cert_finger_print_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Custom Header Field Names Only When xforwardedforclientcertfingerprintenabled, Which Evaluates to True When the Entry into Force of.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_finger_print_alias")

    @x_forwarded_for_client_cert_finger_print_alias.setter
    def x_forwarded_for_client_cert_finger_print_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_finger_print_alias", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertFingerPrintEnabled")
    def x_forwarded_for_client_cert_finger_print_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Clientcert-fingerprint Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_finger_print_enabled")

    @x_forwarded_for_client_cert_finger_print_enabled.setter
    def x_forwarded_for_client_cert_finger_print_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_finger_print_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertIssuerDnAlias")
    def x_forwarded_for_client_cert_issuer_dn_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Custom Header Field Names Only When xforwardedforclientcertsubjectdnenabled, Which Evaluates to True When the Entry into Force of.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_issuer_dn_alias")

    @x_forwarded_for_client_cert_issuer_dn_alias.setter
    def x_forwarded_for_client_cert_issuer_dn_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_issuer_dn_alias", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertIssuerDnEnabled")
    def x_forwarded_for_client_cert_issuer_dn_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Clientcert-issuerdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_issuer_dn_enabled")

    @x_forwarded_for_client_cert_issuer_dn_enabled.setter
    def x_forwarded_for_client_cert_issuer_dn_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_issuer_dn_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertSubjectDnAlias")
    def x_forwarded_for_client_cert_subject_dn_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Custom Header Field Name,
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_subject_dn_alias")

    @x_forwarded_for_client_cert_subject_dn_alias.setter
    def x_forwarded_for_client_cert_subject_dn_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_subject_dn_alias", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertSubjectDnEnabled")
    def x_forwarded_for_client_cert_subject_dn_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Clientcert-subjectdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Owner Information.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_subject_dn_enabled")

    @x_forwarded_for_client_cert_subject_dn_enabled.setter
    def x_forwarded_for_client_cert_subject_dn_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_subject_dn_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientSourceIpsEnabled")
    def x_forwarded_for_client_source_ips_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value:
        """
        return pulumi.get(self, "x_forwarded_for_client_source_ips_enabled")

    @x_forwarded_for_client_source_ips_enabled.setter
    def x_forwarded_for_client_source_ips_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_client_source_ips_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientSourceIpsTrusted")
    def x_forwarded_for_client_source_ips_trusted(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        """
        return pulumi.get(self, "x_forwarded_for_client_source_ips_trusted")

    @x_forwarded_for_client_source_ips_trusted.setter
    def x_forwarded_for_client_source_ips_trusted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for_client_source_ips_trusted", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientSrcPortEnabled")
    def x_forwarded_for_client_src_port_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        """
        return pulumi.get(self, "x_forwarded_for_client_src_port_enabled")

    @x_forwarded_for_client_src_port_enabled.setter
    def x_forwarded_for_client_src_port_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_client_src_port_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForEnabled")
    def x_forwarded_for_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        """
        return pulumi.get(self, "x_forwarded_for_enabled")

    @x_forwarded_for_enabled.setter
    def x_forwarded_for_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForHostEnabled")
    def x_forwarded_for_host_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable the X-Forwarded-Host header field to obtain the domain name of the client accessing the Application Load Balancer. Value:
        """
        return pulumi.get(self, "x_forwarded_for_host_enabled")

    @x_forwarded_for_host_enabled.setter
    def x_forwarded_for_host_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_host_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForProcessingMode")
    def x_forwarded_for_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema for processing X-Forwarded-For header fields. This value takes effect only when XForwardedForEnabled is true. Value:
        """
        return pulumi.get(self, "x_forwarded_for_processing_mode")

    @x_forwarded_for_processing_mode.setter
    def x_forwarded_for_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_for_processing_mode", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForProtoEnabled")
    def x_forwarded_for_proto_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        """
        return pulumi.get(self, "x_forwarded_for_proto_enabled")

    @x_forwarded_for_proto_enabled.setter
    def x_forwarded_for_proto_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_proto_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForSlbIdEnabled")
    def x_forwarded_for_slb_id_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id
        """
        return pulumi.get(self, "x_forwarded_for_slb_id_enabled")

    @x_forwarded_for_slb_id_enabled.setter
    def x_forwarded_for_slb_id_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_slb_id_enabled", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedForSlbPortEnabled")
    def x_forwarded_for_slb_port_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port
        """
        return pulumi.get(self, "x_forwarded_for_slb_port_enabled")

    @x_forwarded_for_slb_port_enabled.setter
    def x_forwarded_for_slb_port_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "x_forwarded_for_slb_port_enabled", value)


if not MYPY:
    class LoadBalancerAccessLogConfigArgsDict(TypedDict):
        log_project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project to which the access log is shipped.
        """
        log_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Logstore to which the access log is shipped.
        """
elif False:
    LoadBalancerAccessLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAccessLogConfigArgs:
    def __init__(__self__, *,
                 log_project: Optional[pulumi.Input[_builtins.str]] = None,
                 log_store: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_project: The project to which the access log is shipped.
        :param pulumi.Input[_builtins.str] log_store: The Logstore to which the access log is shipped.
        """
        if log_project is not None:
            pulumi.set(__self__, "log_project", log_project)
        if log_store is not None:
            pulumi.set(__self__, "log_store", log_store)

    @_builtins.property
    @pulumi.getter(name="logProject")
    def log_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project to which the access log is shipped.
        """
        return pulumi.get(self, "log_project")

    @log_project.setter
    def log_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_project", value)

    @_builtins.property
    @pulumi.getter(name="logStore")
    def log_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Logstore to which the access log is shipped.
        """
        return pulumi.get(self, "log_store")

    @log_store.setter
    def log_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_store", value)


if not MYPY:
    class LoadBalancerDeletionProtectionConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Remove the Protection Status
        """
        enabled_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm: SSZ
        """
elif False:
    LoadBalancerDeletionProtectionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerDeletionProtectionConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Remove the Protection Status
        :param pulumi.Input[_builtins.str] enabled_time: Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm: SSZ
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enabled_time is not None:
            pulumi.set(__self__, "enabled_time", enabled_time)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Remove the Protection Status
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm: SSZ
        """
        return pulumi.get(self, "enabled_time")

    @enabled_time.setter
    def enabled_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enabled_time", value)


if not MYPY:
    class LoadBalancerLoadBalancerBillingConfigArgsDict(TypedDict):
        pay_type: pulumi.Input[_builtins.str]
        """
        Pay Type
        """
elif False:
    LoadBalancerLoadBalancerBillingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerLoadBalancerBillingConfigArgs:
    def __init__(__self__, *,
                 pay_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] pay_type: Pay Type
        """
        pulumi.set(__self__, "pay_type", pay_type)

    @_builtins.property
    @pulumi.getter(name="payType")
    def pay_type(self) -> pulumi.Input[_builtins.str]:
        """
        Pay Type
        """
        return pulumi.get(self, "pay_type")

    @pay_type.setter
    def pay_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pay_type", value)


if not MYPY:
    class LoadBalancerModificationProtectionConfigArgsDict(TypedDict):
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Managed Instance
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Load Balancing Modify the Protection Status
        """
elif False:
    LoadBalancerModificationProtectionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerModificationProtectionConfigArgs:
    def __init__(__self__, *,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] reason: Managed Instance
        :param pulumi.Input[_builtins.str] status: Load Balancing Modify the Protection Status
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Managed Instance
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Load Balancing Modify the Protection Status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LoadBalancerZoneMappingArgsDict(TypedDict):
        vswitch_id: pulumi.Input[_builtins.str]
        """
        The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        """
        zone_id: pulumi.Input[_builtins.str]
        """
        The ID of the zone to which the SLB instance belongs.
        """
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        An IP address of the IPv4 type.
        """
        allocation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the EIP instance.
        """
        eip_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the EIP instance.
        """
        intranet_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 private network address.
        """
        ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        An IP address of the IPv6 type.
        """
        load_balancer_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgsDict']]]]
        """
        The instance address.
        """
elif False:
    LoadBalancerZoneMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerZoneMappingArgs:
    def __init__(__self__, *,
                 vswitch_id: pulumi.Input[_builtins.str],
                 zone_id: pulumi.Input[_builtins.str],
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 allocation_id: Optional[pulumi.Input[_builtins.str]] = None,
                 eip_type: Optional[pulumi.Input[_builtins.str]] = None,
                 intranet_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_address: Optional[pulumi.Input[_builtins.str]] = None,
                 load_balancer_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] vswitch_id: The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        :param pulumi.Input[_builtins.str] zone_id: The ID of the zone to which the SLB instance belongs.
        :param pulumi.Input[_builtins.str] address: An IP address of the IPv4 type.
        :param pulumi.Input[_builtins.str] allocation_id: The ID of the EIP instance.
        :param pulumi.Input[_builtins.str] eip_type: The type of the EIP instance.
        :param pulumi.Input[_builtins.str] intranet_address: IPv4 private network address.
        :param pulumi.Input[_builtins.str] ipv6_address: An IP address of the IPv6 type.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]] load_balancer_addresses: The instance address.
        """
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if eip_type is not None:
            pulumi.set(__self__, "eip_type", eip_type)
        if intranet_address is not None:
            pulumi.set(__self__, "intranet_address", intranet_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if load_balancer_addresses is not None:
            pulumi.set(__self__, "load_balancer_addresses", load_balancer_addresses)

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        """
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vswitch_id", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the zone to which the SLB instance belongs.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone_id", value)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An IP address of the IPv4 type.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the EIP instance.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allocation_id", value)

    @_builtins.property
    @pulumi.getter(name="eipType")
    def eip_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the EIP instance.
        """
        return pulumi.get(self, "eip_type")

    @eip_type.setter
    def eip_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip_type", value)

    @_builtins.property
    @pulumi.getter(name="intranetAddress")
    def intranet_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 private network address.
        """
        return pulumi.get(self, "intranet_address")

    @intranet_address.setter
    def intranet_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intranet_address", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An IP address of the IPv6 type.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerAddresses")
    def load_balancer_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]]]:
        """
        The instance address.
        """
        return pulumi.get(self, "load_balancer_addresses")

    @load_balancer_addresses.setter
    def load_balancer_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]]]):
        pulumi.set(self, "load_balancer_addresses", value)


if not MYPY:
    class LoadBalancerZoneMappingLoadBalancerAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        An IP address of the IPv4 type.
        """
        allocation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The elastic IP identifier.
        """
        eip_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the public EIP. Value:
        """
        intranet_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 private network address.
        """
        intranet_address_hc_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private network IPv4 address detection status of the application-oriented load balancing instance.
        """
        ipv4_local_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IPv4 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        An IP address of the IPv6 type.
        """
        ipv6_address_hc_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 address detection status of the application-based load balancing instance.
        """
        ipv6_local_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IPv6 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
elif False:
    LoadBalancerZoneMappingLoadBalancerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerZoneMappingLoadBalancerAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 allocation_id: Optional[pulumi.Input[_builtins.str]] = None,
                 eip_type: Optional[pulumi.Input[_builtins.str]] = None,
                 intranet_address: Optional[pulumi.Input[_builtins.str]] = None,
                 intranet_address_hc_status: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4_local_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ipv6_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_address_hc_status: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_local_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] address: An IP address of the IPv4 type.
        :param pulumi.Input[_builtins.str] allocation_id: The elastic IP identifier.
        :param pulumi.Input[_builtins.str] eip_type: The type of the public EIP. Value:
        :param pulumi.Input[_builtins.str] intranet_address: IPv4 private network address.
        :param pulumi.Input[_builtins.str] intranet_address_hc_status: The private network IPv4 address detection status of the application-oriented load balancing instance.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ipv4_local_addresses: IPv4 Local address list. The list of addresses used by ALB to interact with the backend service.
        :param pulumi.Input[_builtins.str] ipv6_address: An IP address of the IPv6 type.
        :param pulumi.Input[_builtins.str] ipv6_address_hc_status: The IPv6 address detection status of the application-based load balancing instance.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ipv6_local_addresses: IPv6 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if eip_type is not None:
            pulumi.set(__self__, "eip_type", eip_type)
        if intranet_address is not None:
            pulumi.set(__self__, "intranet_address", intranet_address)
        if intranet_address_hc_status is not None:
            pulumi.set(__self__, "intranet_address_hc_status", intranet_address_hc_status)
        if ipv4_local_addresses is not None:
            pulumi.set(__self__, "ipv4_local_addresses", ipv4_local_addresses)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_address_hc_status is not None:
            pulumi.set(__self__, "ipv6_address_hc_status", ipv6_address_hc_status)
        if ipv6_local_addresses is not None:
            pulumi.set(__self__, "ipv6_local_addresses", ipv6_local_addresses)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An IP address of the IPv4 type.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The elastic IP identifier.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allocation_id", value)

    @_builtins.property
    @pulumi.getter(name="eipType")
    def eip_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the public EIP. Value:
        """
        return pulumi.get(self, "eip_type")

    @eip_type.setter
    def eip_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip_type", value)

    @_builtins.property
    @pulumi.getter(name="intranetAddress")
    def intranet_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 private network address.
        """
        return pulumi.get(self, "intranet_address")

    @intranet_address.setter
    def intranet_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intranet_address", value)

    @_builtins.property
    @pulumi.getter(name="intranetAddressHcStatus")
    def intranet_address_hc_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private network IPv4 address detection status of the application-oriented load balancing instance.
        """
        return pulumi.get(self, "intranet_address_hc_status")

    @intranet_address_hc_status.setter
    def intranet_address_hc_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intranet_address_hc_status", value)

    @_builtins.property
    @pulumi.getter(name="ipv4LocalAddresses")
    def ipv4_local_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IPv4 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        return pulumi.get(self, "ipv4_local_addresses")

    @ipv4_local_addresses.setter
    def ipv4_local_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ipv4_local_addresses", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An IP address of the IPv6 type.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressHcStatus")
    def ipv6_address_hc_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 address detection status of the application-based load balancing instance.
        """
        return pulumi.get(self, "ipv6_address_hc_status")

    @ipv6_address_hc_status.setter
    def ipv6_address_hc_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address_hc_status", value)

    @_builtins.property
    @pulumi.getter(name="ipv6LocalAddresses")
    def ipv6_local_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IPv6 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        return pulumi.get(self, "ipv6_local_addresses")

    @ipv6_local_addresses.setter
    def ipv6_local_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ipv6_local_addresses", value)


if not MYPY:
    class RuleRuleActionArgsDict(TypedDict):
        order: pulumi.Input[_builtins.int]
        """
        The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        """
        type: pulumi.Input[_builtins.str]
        """
        The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
        **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
        **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
        **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        """
        cors_config: NotRequired[pulumi.Input['RuleRuleActionCorsConfigArgsDict']]
        """
        Request forwarding based on CORS. See `cors_config` below.
        """
        fixed_response_config: NotRequired[pulumi.Input['RuleRuleActionFixedResponseConfigArgsDict']]
        """
        The configuration of the fixed response. See `fixed_response_config` below.
        """
        forward_group_config: NotRequired[pulumi.Input['RuleRuleActionForwardGroupConfigArgsDict']]
        """
        The forward response action within ALB. See `forward_group_config` below.
        """
        insert_header_config: NotRequired[pulumi.Input['RuleRuleActionInsertHeaderConfigArgsDict']]
        """
        The configuration of the inserted header field. See `insert_header_config` below.
        """
        redirect_config: NotRequired[pulumi.Input['RuleRuleActionRedirectConfigArgsDict']]
        """
        The configuration of the external redirect action. See `redirect_config` below.
        """
        remove_header_config: NotRequired[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgsDict']]
        """
        The configuration of the inserted header field. See `remove_header_config` below.
        """
        rewrite_config: NotRequired[pulumi.Input['RuleRuleActionRewriteConfigArgsDict']]
        """
        The redirect action within ALB. See `rewrite_config` below.
        """
        traffic_limit_config: NotRequired[pulumi.Input['RuleRuleActionTrafficLimitConfigArgsDict']]
        """
        The Flow speed limit. See `traffic_limit_config` below.
        """
        traffic_mirror_config: NotRequired[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgsDict']]
        """
        The Traffic mirroring. See `traffic_mirror_config` below.
        """
elif False:
    RuleRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 cors_config: Optional[pulumi.Input['RuleRuleActionCorsConfigArgs']] = None,
                 fixed_response_config: Optional[pulumi.Input['RuleRuleActionFixedResponseConfigArgs']] = None,
                 forward_group_config: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigArgs']] = None,
                 insert_header_config: Optional[pulumi.Input['RuleRuleActionInsertHeaderConfigArgs']] = None,
                 redirect_config: Optional[pulumi.Input['RuleRuleActionRedirectConfigArgs']] = None,
                 remove_header_config: Optional[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs']] = None,
                 rewrite_config: Optional[pulumi.Input['RuleRuleActionRewriteConfigArgs']] = None,
                 traffic_limit_config: Optional[pulumi.Input['RuleRuleActionTrafficLimitConfigArgs']] = None,
                 traffic_mirror_config: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] order: The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        :param pulumi.Input[_builtins.str] type: The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
               **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
               **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
               **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        :param pulumi.Input['RuleRuleActionCorsConfigArgs'] cors_config: Request forwarding based on CORS. See `cors_config` below.
        :param pulumi.Input['RuleRuleActionFixedResponseConfigArgs'] fixed_response_config: The configuration of the fixed response. See `fixed_response_config` below.
        :param pulumi.Input['RuleRuleActionForwardGroupConfigArgs'] forward_group_config: The forward response action within ALB. See `forward_group_config` below.
        :param pulumi.Input['RuleRuleActionInsertHeaderConfigArgs'] insert_header_config: The configuration of the inserted header field. See `insert_header_config` below.
        :param pulumi.Input['RuleRuleActionRedirectConfigArgs'] redirect_config: The configuration of the external redirect action. See `redirect_config` below.
        :param pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs'] remove_header_config: The configuration of the inserted header field. See `remove_header_config` below.
        :param pulumi.Input['RuleRuleActionRewriteConfigArgs'] rewrite_config: The redirect action within ALB. See `rewrite_config` below.
        :param pulumi.Input['RuleRuleActionTrafficLimitConfigArgs'] traffic_limit_config: The Flow speed limit. See `traffic_limit_config` below.
        :param pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs'] traffic_mirror_config: The Traffic mirroring. See `traffic_mirror_config` below.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "type", type)
        if cors_config is not None:
            pulumi.set(__self__, "cors_config", cors_config)
        if fixed_response_config is not None:
            pulumi.set(__self__, "fixed_response_config", fixed_response_config)
        if forward_group_config is not None:
            pulumi.set(__self__, "forward_group_config", forward_group_config)
        if insert_header_config is not None:
            pulumi.set(__self__, "insert_header_config", insert_header_config)
        if redirect_config is not None:
            pulumi.set(__self__, "redirect_config", redirect_config)
        if remove_header_config is not None:
            pulumi.set(__self__, "remove_header_config", remove_header_config)
        if rewrite_config is not None:
            pulumi.set(__self__, "rewrite_config", rewrite_config)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)
        if traffic_mirror_config is not None:
            pulumi.set(__self__, "traffic_mirror_config", traffic_mirror_config)

    @_builtins.property
    @pulumi.getter
    def order(self) -> pulumi.Input[_builtins.int]:
        """
        The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
        **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
        **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
        **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="corsConfig")
    def cors_config(self) -> Optional[pulumi.Input['RuleRuleActionCorsConfigArgs']]:
        """
        Request forwarding based on CORS. See `cors_config` below.
        """
        return pulumi.get(self, "cors_config")

    @cors_config.setter
    def cors_config(self, value: Optional[pulumi.Input['RuleRuleActionCorsConfigArgs']]):
        pulumi.set(self, "cors_config", value)

    @_builtins.property
    @pulumi.getter(name="fixedResponseConfig")
    def fixed_response_config(self) -> Optional[pulumi.Input['RuleRuleActionFixedResponseConfigArgs']]:
        """
        The configuration of the fixed response. See `fixed_response_config` below.
        """
        return pulumi.get(self, "fixed_response_config")

    @fixed_response_config.setter
    def fixed_response_config(self, value: Optional[pulumi.Input['RuleRuleActionFixedResponseConfigArgs']]):
        pulumi.set(self, "fixed_response_config", value)

    @_builtins.property
    @pulumi.getter(name="forwardGroupConfig")
    def forward_group_config(self) -> Optional[pulumi.Input['RuleRuleActionForwardGroupConfigArgs']]:
        """
        The forward response action within ALB. See `forward_group_config` below.
        """
        return pulumi.get(self, "forward_group_config")

    @forward_group_config.setter
    def forward_group_config(self, value: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigArgs']]):
        pulumi.set(self, "forward_group_config", value)

    @_builtins.property
    @pulumi.getter(name="insertHeaderConfig")
    def insert_header_config(self) -> Optional[pulumi.Input['RuleRuleActionInsertHeaderConfigArgs']]:
        """
        The configuration of the inserted header field. See `insert_header_config` below.
        """
        return pulumi.get(self, "insert_header_config")

    @insert_header_config.setter
    def insert_header_config(self, value: Optional[pulumi.Input['RuleRuleActionInsertHeaderConfigArgs']]):
        pulumi.set(self, "insert_header_config", value)

    @_builtins.property
    @pulumi.getter(name="redirectConfig")
    def redirect_config(self) -> Optional[pulumi.Input['RuleRuleActionRedirectConfigArgs']]:
        """
        The configuration of the external redirect action. See `redirect_config` below.
        """
        return pulumi.get(self, "redirect_config")

    @redirect_config.setter
    def redirect_config(self, value: Optional[pulumi.Input['RuleRuleActionRedirectConfigArgs']]):
        pulumi.set(self, "redirect_config", value)

    @_builtins.property
    @pulumi.getter(name="removeHeaderConfig")
    def remove_header_config(self) -> Optional[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs']]:
        """
        The configuration of the inserted header field. See `remove_header_config` below.
        """
        return pulumi.get(self, "remove_header_config")

    @remove_header_config.setter
    def remove_header_config(self, value: Optional[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs']]):
        pulumi.set(self, "remove_header_config", value)

    @_builtins.property
    @pulumi.getter(name="rewriteConfig")
    def rewrite_config(self) -> Optional[pulumi.Input['RuleRuleActionRewriteConfigArgs']]:
        """
        The redirect action within ALB. See `rewrite_config` below.
        """
        return pulumi.get(self, "rewrite_config")

    @rewrite_config.setter
    def rewrite_config(self, value: Optional[pulumi.Input['RuleRuleActionRewriteConfigArgs']]):
        pulumi.set(self, "rewrite_config", value)

    @_builtins.property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional[pulumi.Input['RuleRuleActionTrafficLimitConfigArgs']]:
        """
        The Flow speed limit. See `traffic_limit_config` below.
        """
        return pulumi.get(self, "traffic_limit_config")

    @traffic_limit_config.setter
    def traffic_limit_config(self, value: Optional[pulumi.Input['RuleRuleActionTrafficLimitConfigArgs']]):
        pulumi.set(self, "traffic_limit_config", value)

    @_builtins.property
    @pulumi.getter(name="trafficMirrorConfig")
    def traffic_mirror_config(self) -> Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs']]:
        """
        The Traffic mirroring. See `traffic_mirror_config` below.
        """
        return pulumi.get(self, "traffic_mirror_config")

    @traffic_mirror_config.setter
    def traffic_mirror_config(self, value: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs']]):
        pulumi.set(self, "traffic_mirror_config", value)


if not MYPY:
    class RuleRuleActionCorsConfigArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether credentials can be passed during CORS operations. Valid values: `on`, `off`.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The allowed headers for CORS requests.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The allowed HTTP methods for CORS requests. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `PATCH`.
        """
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The allowed origins of CORS requests.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The headers that can be exposed.
        """
        max_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum cache time of preflight requests in the browser. Unit: seconds. Valid values: `-1` to `172800`.
        """
elif False:
    RuleRuleActionCorsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionCorsConfigArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] allow_credentials: Specifies whether credentials can be passed during CORS operations. Valid values: `on`, `off`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: The allowed headers for CORS requests.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: The allowed HTTP methods for CORS requests. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `PATCH`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_origins: The allowed origins of CORS requests.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: The headers that can be exposed.
        :param pulumi.Input[_builtins.int] max_age: The maximum cache time of preflight requests in the browser. Unit: seconds. Valid values: `-1` to `172800`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether credentials can be passed during CORS operations. Valid values: `on`, `off`.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed headers for CORS requests.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed HTTP methods for CORS requests. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `PATCH`.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The allowed origins of CORS requests.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The headers that can be exposed.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum cache time of preflight requests in the browser. Unit: seconds. Valid values: `-1` to `172800`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class RuleRuleActionFixedResponseConfigArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the fixed response. Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
        """
        http_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
elif False:
    RuleRuleActionFixedResponseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionFixedResponseConfigArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 http_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        :param pulumi.Input[_builtins.str] content_type: The format of the fixed response. Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
        :param pulumi.Input[_builtins.str] http_code: The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the fixed response. Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        return pulumi.get(self, "http_code")

    @http_code.setter
    def http_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_code", value)


if not MYPY:
    class RuleRuleActionForwardGroupConfigArgsDict(TypedDict):
        server_group_sticky_session: NotRequired[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgsDict']]
        """
        The configuration of session persistence for server groups. See `server_group_sticky_session` below.
        """
        server_group_tuples: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgsDict']]]]
        """
        The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
elif False:
    RuleRuleActionForwardGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionForwardGroupConfigArgs:
    def __init__(__self__, *,
                 server_group_sticky_session: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs']] = None,
                 server_group_tuples: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]]] = None):
        """
        :param pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs'] server_group_sticky_session: The configuration of session persistence for server groups. See `server_group_sticky_session` below.
        :param pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]] server_group_tuples: The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        if server_group_sticky_session is not None:
            pulumi.set(__self__, "server_group_sticky_session", server_group_sticky_session)
        if server_group_tuples is not None:
            pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupStickySession")
    def server_group_sticky_session(self) -> Optional[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs']]:
        """
        The configuration of session persistence for server groups. See `server_group_sticky_session` below.
        """
        return pulumi.get(self, "server_group_sticky_session")

    @server_group_sticky_session.setter
    def server_group_sticky_session(self, value: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs']]):
        pulumi.set(self, "server_group_sticky_session", value)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]]]:
        """
        The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        return pulumi.get(self, "server_group_tuples")

    @server_group_tuples.setter
    def server_group_tuples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]]]):
        pulumi.set(self, "server_group_tuples", value)


if not MYPY:
    class RuleRuleActionForwardGroupConfigServerGroupStickySessionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable session persistence.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout period. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
elif False:
    RuleRuleActionForwardGroupConfigServerGroupStickySessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable session persistence.
        :param pulumi.Input[_builtins.int] timeout: The timeout period. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable session persistence.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout period. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RuleRuleActionForwardGroupConfigServerGroupTupleArgsDict(TypedDict):
        server_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the destination server group to which requests are forwarded.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Weight of server group. Default value: `100`. **NOTE:** This attribute is required when the number of `server_group_tuples` is greater than 2.
        """
elif False:
    RuleRuleActionForwardGroupConfigServerGroupTupleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionForwardGroupConfigServerGroupTupleArgs:
    def __init__(__self__, *,
                 server_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] server_group_id: The ID of the destination server group to which requests are forwarded.
        :param pulumi.Input[_builtins.int] weight: The Weight of server group. Default value: `100`. **NOTE:** This attribute is required when the number of `server_group_tuples` is greater than 2.
        """
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_group_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Weight of server group. Default value: `100`. **NOTE:** This attribute is required when the number of `server_group_tuples` is greater than 2.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RuleRuleActionInsertHeaderConfigArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
        value_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value type of the inserted header field. Valid values:
        - `UserDefined`: a custom value
        - `ReferenceHeader`: uses a field of the user request header.
        - `SystemDefined`: a system value.
        """
elif False:
    RuleRuleActionInsertHeaderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionInsertHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value_type: The value type of the inserted header field. Valid values:
               - `UserDefined`: a custom value
               - `ReferenceHeader`: uses a field of the user request header.
               - `SystemDefined`: a system value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value type of the inserted header field. Valid values:
        - `UserDefined`: a custom value
        - `ReferenceHeader`: uses a field of the user request header.
        - `SystemDefined`: a system value.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class RuleRuleActionRedirectConfigArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        """
        http_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port of the destination to which requests are redirected. Valid values: 1 to 63335. Default value: ${port}. You cannot use this value together with other characters at the same time.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol of the requests to be redirected. Valid values: `HTTP` and `HTTPS`. Default value: `${protocol}`. You cannot use this value together with other characters at the same time. Note HTTPS listeners can redirect only HTTPS requests.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
elif False:
    RuleRuleActionRedirectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionRedirectConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_code: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        :param pulumi.Input[_builtins.str] http_code: The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        :param pulumi.Input[_builtins.str] path: The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        :param pulumi.Input[_builtins.str] port: The port of the destination to which requests are redirected. Valid values: 1 to 63335. Default value: ${port}. You cannot use this value together with other characters at the same time.
        :param pulumi.Input[_builtins.str] protocol: The protocol of the requests to be redirected. Valid values: `HTTP` and `HTTPS`. Default value: `${protocol}`. You cannot use this value together with other characters at the same time. Note HTTPS listeners can redirect only HTTPS requests.
        :param pulumi.Input[_builtins.str] query: The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        return pulumi.get(self, "http_code")

    @http_code.setter
    def http_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_code", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port of the destination to which requests are redirected. Valid values: 1 to 63335. Default value: ${port}. You cannot use this value together with other characters at the same time.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol of the requests to be redirected. Valid values: `HTTP` and `HTTPS`. Default value: `${protocol}`. You cannot use this value together with other characters at the same time. Note HTTPS listeners can redirect only HTTPS requests.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class RuleRuleActionRemoveHeaderConfigArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleRuleActionRemoveHeaderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionRemoveHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleRuleActionRewriteConfigArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
elif False:
    RuleRuleActionRewriteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionRewriteConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        :param pulumi.Input[_builtins.str] path: The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        :param pulumi.Input[_builtins.str] query: The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class RuleRuleActionTrafficLimitConfigArgsDict(TypedDict):
        per_ip_qps: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of requests per second for a single IP address. Value range: 1~1000000. Note: If the QPS parameter is also configured, the value of the PerIpQps parameter must be smaller than the value of the QPS parameter.
        """
        qps: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Number of requests per second. Valid values: `1` to `100000`.
        """
elif False:
    RuleRuleActionTrafficLimitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionTrafficLimitConfigArgs:
    def __init__(__self__, *,
                 per_ip_qps: Optional[pulumi.Input[_builtins.int]] = None,
                 qps: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] per_ip_qps: The number of requests per second for a single IP address. Value range: 1~1000000. Note: If the QPS parameter is also configured, the value of the PerIpQps parameter must be smaller than the value of the QPS parameter.
        :param pulumi.Input[_builtins.int] qps: The Number of requests per second. Valid values: `1` to `100000`.
        """
        if per_ip_qps is not None:
            pulumi.set(__self__, "per_ip_qps", per_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter(name="perIpQps")
    def per_ip_qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of requests per second for a single IP address. Value range: 1~1000000. Note: If the QPS parameter is also configured, the value of the PerIpQps parameter must be smaller than the value of the QPS parameter.
        """
        return pulumi.get(self, "per_ip_qps")

    @per_ip_qps.setter
    def per_ip_qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_ip_qps", value)

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Number of requests per second. Valid values: `1` to `100000`.
        """
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class RuleRuleActionTrafficMirrorConfigArgsDict(TypedDict):
        mirror_group_config: NotRequired[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgsDict']]
        """
        The Traffic is mirrored to the server group. See `mirror_group_config` below.
        """
        target_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Mirror target type.
        """
elif False:
    RuleRuleActionTrafficMirrorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionTrafficMirrorConfigArgs:
    def __init__(__self__, *,
                 mirror_group_config: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs']] = None,
                 target_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs'] mirror_group_config: The Traffic is mirrored to the server group. See `mirror_group_config` below.
        :param pulumi.Input[_builtins.str] target_type: The Mirror target type.
        """
        if mirror_group_config is not None:
            pulumi.set(__self__, "mirror_group_config", mirror_group_config)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @_builtins.property
    @pulumi.getter(name="mirrorGroupConfig")
    def mirror_group_config(self) -> Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs']]:
        """
        The Traffic is mirrored to the server group. See `mirror_group_config` below.
        """
        return pulumi.get(self, "mirror_group_config")

    @mirror_group_config.setter
    def mirror_group_config(self, value: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs']]):
        pulumi.set(self, "mirror_group_config", value)

    @_builtins.property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Mirror target type.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_type", value)


if not MYPY:
    class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgsDict(TypedDict):
        server_group_tuples: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgsDict']]]]
        """
        The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
elif False:
    RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs:
    def __init__(__self__, *,
                 server_group_tuples: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]] server_group_tuples: The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        if server_group_tuples is not None:
            pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]]]:
        """
        The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        return pulumi.get(self, "server_group_tuples")

    @server_group_tuples.setter
    def server_group_tuples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]]]):
        pulumi.set(self, "server_group_tuples", value)


if not MYPY:
    class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgsDict(TypedDict):
        server_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the destination server group to which requests are forwarded.
        """
elif False:
    RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs:
    def __init__(__self__, *,
                 server_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] server_group_id: The ID of the destination server group to which requests are forwarded.
        """
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_group_id", value)


if not MYPY:
    class RuleRuleConditionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the forwarding rule. Valid values:
        - `Host`: Requests are forwarded based on hosts.
        - `Path`: Requests are forwarded based on the path.
        - `Header`: Requests are forwarded based on the HTTP header field.
        - `QueryString`: Requests are forwarded based on the query string.
        - `Method`: Request are forwarded based on the request method.
        - `Cookie`: Requests are forwarded based on the cookie.
        - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
        - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
        - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        """
        cookie_config: NotRequired[pulumi.Input['RuleRuleConditionCookieConfigArgsDict']]
        """
        The configuration of the cookie. See See `cookie_config` below.
        """
        header_config: NotRequired[pulumi.Input['RuleRuleConditionHeaderConfigArgsDict']]
        """
        The configuration of the header field. See `header_config` below.
        """
        host_config: NotRequired[pulumi.Input['RuleRuleConditionHostConfigArgsDict']]
        """
        The configuration of the host field. See `host_config` below.
        """
        method_config: NotRequired[pulumi.Input['RuleRuleConditionMethodConfigArgsDict']]
        """
        The configuration of the request method. See `method_config` below.
        """
        path_config: NotRequired[pulumi.Input['RuleRuleConditionPathConfigArgsDict']]
        """
        The configuration of the path for the request to be forwarded. See `path_config` below.
        """
        query_string_config: NotRequired[pulumi.Input['RuleRuleConditionQueryStringConfigArgsDict']]
        """
        The configuration of the query string. See `query_string_config` below.
        """
        response_header_config: NotRequired[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgsDict']]
        """
        The configuration of the header field. See `response_header_config` below.
        """
        response_status_code_config: NotRequired[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgsDict']]
        """
        The configuration of the header field. See `response_status_code_config` below.
        """
        source_ip_config: NotRequired[pulumi.Input['RuleRuleConditionSourceIpConfigArgsDict']]
        """
        The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
elif False:
    RuleRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cookie_config: Optional[pulumi.Input['RuleRuleConditionCookieConfigArgs']] = None,
                 header_config: Optional[pulumi.Input['RuleRuleConditionHeaderConfigArgs']] = None,
                 host_config: Optional[pulumi.Input['RuleRuleConditionHostConfigArgs']] = None,
                 method_config: Optional[pulumi.Input['RuleRuleConditionMethodConfigArgs']] = None,
                 path_config: Optional[pulumi.Input['RuleRuleConditionPathConfigArgs']] = None,
                 query_string_config: Optional[pulumi.Input['RuleRuleConditionQueryStringConfigArgs']] = None,
                 response_header_config: Optional[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs']] = None,
                 response_status_code_config: Optional[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs']] = None,
                 source_ip_config: Optional[pulumi.Input['RuleRuleConditionSourceIpConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the forwarding rule. Valid values:
               - `Host`: Requests are forwarded based on hosts.
               - `Path`: Requests are forwarded based on the path.
               - `Header`: Requests are forwarded based on the HTTP header field.
               - `QueryString`: Requests are forwarded based on the query string.
               - `Method`: Request are forwarded based on the request method.
               - `Cookie`: Requests are forwarded based on the cookie.
               - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
               - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
               - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        :param pulumi.Input['RuleRuleConditionCookieConfigArgs'] cookie_config: The configuration of the cookie. See See `cookie_config` below.
        :param pulumi.Input['RuleRuleConditionHeaderConfigArgs'] header_config: The configuration of the header field. See `header_config` below.
        :param pulumi.Input['RuleRuleConditionHostConfigArgs'] host_config: The configuration of the host field. See `host_config` below.
        :param pulumi.Input['RuleRuleConditionMethodConfigArgs'] method_config: The configuration of the request method. See `method_config` below.
        :param pulumi.Input['RuleRuleConditionPathConfigArgs'] path_config: The configuration of the path for the request to be forwarded. See `path_config` below.
        :param pulumi.Input['RuleRuleConditionQueryStringConfigArgs'] query_string_config: The configuration of the query string. See `query_string_config` below.
        :param pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs'] response_header_config: The configuration of the header field. See `response_header_config` below.
        :param pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs'] response_status_code_config: The configuration of the header field. See `response_status_code_config` below.
        :param pulumi.Input['RuleRuleConditionSourceIpConfigArgs'] source_ip_config: The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
        pulumi.set(__self__, "type", type)
        if cookie_config is not None:
            pulumi.set(__self__, "cookie_config", cookie_config)
        if header_config is not None:
            pulumi.set(__self__, "header_config", header_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if method_config is not None:
            pulumi.set(__self__, "method_config", method_config)
        if path_config is not None:
            pulumi.set(__self__, "path_config", path_config)
        if query_string_config is not None:
            pulumi.set(__self__, "query_string_config", query_string_config)
        if response_header_config is not None:
            pulumi.set(__self__, "response_header_config", response_header_config)
        if response_status_code_config is not None:
            pulumi.set(__self__, "response_status_code_config", response_status_code_config)
        if source_ip_config is not None:
            pulumi.set(__self__, "source_ip_config", source_ip_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the forwarding rule. Valid values:
        - `Host`: Requests are forwarded based on hosts.
        - `Path`: Requests are forwarded based on the path.
        - `Header`: Requests are forwarded based on the HTTP header field.
        - `QueryString`: Requests are forwarded based on the query string.
        - `Method`: Request are forwarded based on the request method.
        - `Cookie`: Requests are forwarded based on the cookie.
        - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
        - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
        - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cookieConfig")
    def cookie_config(self) -> Optional[pulumi.Input['RuleRuleConditionCookieConfigArgs']]:
        """
        The configuration of the cookie. See See `cookie_config` below.
        """
        return pulumi.get(self, "cookie_config")

    @cookie_config.setter
    def cookie_config(self, value: Optional[pulumi.Input['RuleRuleConditionCookieConfigArgs']]):
        pulumi.set(self, "cookie_config", value)

    @_builtins.property
    @pulumi.getter(name="headerConfig")
    def header_config(self) -> Optional[pulumi.Input['RuleRuleConditionHeaderConfigArgs']]:
        """
        The configuration of the header field. See `header_config` below.
        """
        return pulumi.get(self, "header_config")

    @header_config.setter
    def header_config(self, value: Optional[pulumi.Input['RuleRuleConditionHeaderConfigArgs']]):
        pulumi.set(self, "header_config", value)

    @_builtins.property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional[pulumi.Input['RuleRuleConditionHostConfigArgs']]:
        """
        The configuration of the host field. See `host_config` below.
        """
        return pulumi.get(self, "host_config")

    @host_config.setter
    def host_config(self, value: Optional[pulumi.Input['RuleRuleConditionHostConfigArgs']]):
        pulumi.set(self, "host_config", value)

    @_builtins.property
    @pulumi.getter(name="methodConfig")
    def method_config(self) -> Optional[pulumi.Input['RuleRuleConditionMethodConfigArgs']]:
        """
        The configuration of the request method. See `method_config` below.
        """
        return pulumi.get(self, "method_config")

    @method_config.setter
    def method_config(self, value: Optional[pulumi.Input['RuleRuleConditionMethodConfigArgs']]):
        pulumi.set(self, "method_config", value)

    @_builtins.property
    @pulumi.getter(name="pathConfig")
    def path_config(self) -> Optional[pulumi.Input['RuleRuleConditionPathConfigArgs']]:
        """
        The configuration of the path for the request to be forwarded. See `path_config` below.
        """
        return pulumi.get(self, "path_config")

    @path_config.setter
    def path_config(self, value: Optional[pulumi.Input['RuleRuleConditionPathConfigArgs']]):
        pulumi.set(self, "path_config", value)

    @_builtins.property
    @pulumi.getter(name="queryStringConfig")
    def query_string_config(self) -> Optional[pulumi.Input['RuleRuleConditionQueryStringConfigArgs']]:
        """
        The configuration of the query string. See `query_string_config` below.
        """
        return pulumi.get(self, "query_string_config")

    @query_string_config.setter
    def query_string_config(self, value: Optional[pulumi.Input['RuleRuleConditionQueryStringConfigArgs']]):
        pulumi.set(self, "query_string_config", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaderConfig")
    def response_header_config(self) -> Optional[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs']]:
        """
        The configuration of the header field. See `response_header_config` below.
        """
        return pulumi.get(self, "response_header_config")

    @response_header_config.setter
    def response_header_config(self, value: Optional[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs']]):
        pulumi.set(self, "response_header_config", value)

    @_builtins.property
    @pulumi.getter(name="responseStatusCodeConfig")
    def response_status_code_config(self) -> Optional[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs']]:
        """
        The configuration of the header field. See `response_status_code_config` below.
        """
        return pulumi.get(self, "response_status_code_config")

    @response_status_code_config.setter
    def response_status_code_config(self, value: Optional[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs']]):
        pulumi.set(self, "response_status_code_config", value)

    @_builtins.property
    @pulumi.getter(name="sourceIpConfig")
    def source_ip_config(self) -> Optional[pulumi.Input['RuleRuleConditionSourceIpConfigArgs']]:
        """
        The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
        return pulumi.get(self, "source_ip_config")

    @source_ip_config.setter
    def source_ip_config(self, value: Optional[pulumi.Input['RuleRuleConditionSourceIpConfigArgs']]):
        pulumi.set(self, "source_ip_config", value)


if not MYPY:
    class RuleRuleConditionCookieConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgsDict']]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionCookieConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionCookieConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionCookieConfigValueArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleRuleConditionCookieConfigValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionCookieConfigValueArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleRuleConditionHeaderConfigArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionHeaderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionHostConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionHostConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionHostConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionMethodConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionMethodConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionMethodConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionPathConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionPathConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionPathConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionQueryStringConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgsDict']]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionQueryStringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionQueryStringConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionQueryStringConfigValueArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleRuleConditionQueryStringConfigValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionQueryStringConfigValueArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleRuleConditionResponseHeaderConfigArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionResponseHeaderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionResponseHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionResponseStatusCodeConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionResponseStatusCodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionResponseStatusCodeConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class RuleRuleConditionSourceIpConfigArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
elif False:
    RuleRuleConditionSourceIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRuleConditionSourceIpConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ServerGroupConnectionDrainConfigArgsDict(TypedDict):
        connection_drain_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable connection draining. Valid values:
        """
        connection_drain_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout period of connection draining.

        Valid values: `0` to `900`.

        Default value: `300`.
        """
elif False:
    ServerGroupConnectionDrainConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupConnectionDrainConfigArgs:
    def __init__(__self__, *,
                 connection_drain_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 connection_drain_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] connection_drain_enabled: Specifies whether to enable connection draining. Valid values:
        :param pulumi.Input[_builtins.int] connection_drain_timeout: The timeout period of connection draining.
               
               Valid values: `0` to `900`.
               
               Default value: `300`.
        """
        if connection_drain_enabled is not None:
            pulumi.set(__self__, "connection_drain_enabled", connection_drain_enabled)
        if connection_drain_timeout is not None:
            pulumi.set(__self__, "connection_drain_timeout", connection_drain_timeout)

    @_builtins.property
    @pulumi.getter(name="connectionDrainEnabled")
    def connection_drain_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable connection draining. Valid values:
        """
        return pulumi.get(self, "connection_drain_enabled")

    @connection_drain_enabled.setter
    def connection_drain_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connection_drain_enabled", value)

    @_builtins.property
    @pulumi.getter(name="connectionDrainTimeout")
    def connection_drain_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout period of connection draining.

        Valid values: `0` to `900`.

        Default value: `300`.
        """
        return pulumi.get(self, "connection_drain_timeout")

    @connection_drain_timeout.setter
    def connection_drain_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_drain_timeout", value)


if not MYPY:
    class ServerGroupHealthCheckConfigArgsDict(TypedDict):
        health_check_enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable the health check feature. Valid values:
        """
        health_check_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The status code for a successful health check
        """
        health_check_connect_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The backend port that is used for health checks.

        Valid values: `0` to `65535`.

        If you set the value to `0`, the backend port is used for health checks.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        health_check_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name that is used for health checks.

        *   **Backend Server Internal IP** (default): Use the internal IP address of backend servers as the health check domain name.

        *   **Custom Domain Name**: Enter a domain name.

        *   The domain name must be 1 to 80 characters in length.
        *   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
        *   The domain name must contain at least one period (.) but cannot start or end with a period (.).
        *   The rightmost domain label of the domain name can contain only letters, and cannot contain digits or hyphens (-).
        *   The domain name cannot start or end with a hyphen (-).

        > **NOTE:**   This parameter takes effect only if `HealthCheckProtocol` is set to `HTTP`, `HTTPS`, or `gRPC`.
        """
        health_check_http_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP version that is used for health checks. Valid values:

        *   **HTTP1.0**

        *   **HTTP1.1**

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        """
        health_check_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The interval at which health checks are performed. Unit: seconds.

        Valid values: `1` to `50`.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        health_check_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP method that is used for health checks. Valid values:

        *   `GET`: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.

        *   `POST`: gRPC health checks use the POST method by default.

        *   `HEAD`: HTTP and HTTPS health checks use the HEAD method by default.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP`, `HTTPS`, or `gRPC`.
        """
        health_check_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that is used for health checks.

        The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : ' , +`. The URL must start with a forward slash (`/`).

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true` and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        """
        health_check_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol that is used for health checks. Valid values:

        - `HTTP`: HTTP health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers.
        - `HTTPS`: HTTPS health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers. HTTPS provides higher security than HTTP because HTTPS supports data encryption.
        - `TCP`: TCP health checks send TCP SYN packets to a backend server to probe the availability of backend servers.
        - `gRPC`: gRPC health checks send POST or GET requests to a backend server to check whether the backend server is healthy.
        """
        health_check_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.

        Valid values: `1` to `300`.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        healthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health check status of the backend server changes from `fail` to `success`.

        Valid values: `2` to `10`.

        Default value: `3`.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health check status of the backend server changes from `success` to `fail`.

        Valid values: `2` to `10`.

        Default value: `3`.
        """
elif False:
    ServerGroupHealthCheckConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupHealthCheckConfigArgs:
    def __init__(__self__, *,
                 health_check_enabled: pulumi.Input[_builtins.bool],
                 health_check_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 health_check_connect_port: Optional[pulumi.Input[_builtins.int]] = None,
                 health_check_host: Optional[pulumi.Input[_builtins.str]] = None,
                 health_check_http_version: Optional[pulumi.Input[_builtins.str]] = None,
                 health_check_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 health_check_method: Optional[pulumi.Input[_builtins.str]] = None,
                 health_check_path: Optional[pulumi.Input[_builtins.str]] = None,
                 health_check_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 health_check_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 healthy_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] health_check_enabled: Specifies whether to enable the health check feature. Valid values:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] health_check_codes: The status code for a successful health check
        :param pulumi.Input[_builtins.int] health_check_connect_port: The backend port that is used for health checks.
               
               Valid values: `0` to `65535`.
               
               If you set the value to `0`, the backend port is used for health checks.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        :param pulumi.Input[_builtins.str] health_check_host: The domain name that is used for health checks.
               
               *   **Backend Server Internal IP** (default): Use the internal IP address of backend servers as the health check domain name.
               
               *   **Custom Domain Name**: Enter a domain name.
               
               *   The domain name must be 1 to 80 characters in length.
               *   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
               *   The domain name must contain at least one period (.) but cannot start or end with a period (.).
               *   The rightmost domain label of the domain name can contain only letters, and cannot contain digits or hyphens (-).
               *   The domain name cannot start or end with a hyphen (-).
               
               > **NOTE:**   This parameter takes effect only if `HealthCheckProtocol` is set to `HTTP`, `HTTPS`, or `gRPC`.
        :param pulumi.Input[_builtins.str] health_check_http_version: The HTTP version that is used for health checks. Valid values:
               
               *   **HTTP1.0**
               
               *   **HTTP1.1**
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        :param pulumi.Input[_builtins.int] health_check_interval: The interval at which health checks are performed. Unit: seconds.
               
               Valid values: `1` to `50`.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        :param pulumi.Input[_builtins.str] health_check_method: The HTTP method that is used for health checks. Valid values:
               
               *   `GET`: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
               
               *   `POST`: gRPC health checks use the POST method by default.
               
               *   `HEAD`: HTTP and HTTPS health checks use the HEAD method by default.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP`, `HTTPS`, or `gRPC`.
        :param pulumi.Input[_builtins.str] health_check_path: The URL that is used for health checks.
               
               The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : ' , +`. The URL must start with a forward slash (`/`).
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true` and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        :param pulumi.Input[_builtins.str] health_check_protocol: The protocol that is used for health checks. Valid values:
               
               - `HTTP`: HTTP health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers.
               - `HTTPS`: HTTPS health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers. HTTPS provides higher security than HTTP because HTTPS supports data encryption.
               - `TCP`: TCP health checks send TCP SYN packets to a backend server to probe the availability of backend servers.
               - `gRPC`: gRPC health checks send POST or GET requests to a backend server to check whether the backend server is healthy.
        :param pulumi.Input[_builtins.int] health_check_timeout: The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.
               
               Valid values: `1` to `300`.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        :param pulumi.Input[_builtins.int] healthy_threshold: The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health check status of the backend server changes from `fail` to `success`.
               
               Valid values: `2` to `10`.
               
               Default value: `3`.
        :param pulumi.Input[_builtins.int] unhealthy_threshold: The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health check status of the backend server changes from `success` to `fail`.
               
               Valid values: `2` to `10`.
               
               Default value: `3`.
        """
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if health_check_codes is not None:
            pulumi.set(__self__, "health_check_codes", health_check_codes)
        if health_check_connect_port is not None:
            pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        if health_check_host is not None:
            pulumi.set(__self__, "health_check_host", health_check_host)
        if health_check_http_version is not None:
            pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_method is not None:
            pulumi.set(__self__, "health_check_method", health_check_method)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if health_check_protocol is not None:
            pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        if health_check_timeout is not None:
            pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable the health check feature. Valid values:
        """
        return pulumi.get(self, "health_check_enabled")

    @health_check_enabled.setter
    def health_check_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "health_check_enabled", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The status code for a successful health check
        """
        return pulumi.get(self, "health_check_codes")

    @health_check_codes.setter
    def health_check_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "health_check_codes", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The backend port that is used for health checks.

        Valid values: `0` to `65535`.

        If you set the value to `0`, the backend port is used for health checks.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        return pulumi.get(self, "health_check_connect_port")

    @health_check_connect_port.setter
    def health_check_connect_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "health_check_connect_port", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name that is used for health checks.

        *   **Backend Server Internal IP** (default): Use the internal IP address of backend servers as the health check domain name.

        *   **Custom Domain Name**: Enter a domain name.

        *   The domain name must be 1 to 80 characters in length.
        *   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
        *   The domain name must contain at least one period (.) but cannot start or end with a period (.).
        *   The rightmost domain label of the domain name can contain only letters, and cannot contain digits or hyphens (-).
        *   The domain name cannot start or end with a hyphen (-).

        > **NOTE:**   This parameter takes effect only if `HealthCheckProtocol` is set to `HTTP`, `HTTPS`, or `gRPC`.
        """
        return pulumi.get(self, "health_check_host")

    @health_check_host.setter
    def health_check_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check_host", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP version that is used for health checks. Valid values:

        *   **HTTP1.0**

        *   **HTTP1.1**

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "health_check_http_version")

    @health_check_http_version.setter
    def health_check_http_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check_http_version", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The interval at which health checks are performed. Unit: seconds.

        Valid values: `1` to `50`.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        return pulumi.get(self, "health_check_interval")

    @health_check_interval.setter
    def health_check_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "health_check_interval", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP method that is used for health checks. Valid values:

        *   `GET`: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.

        *   `POST`: gRPC health checks use the POST method by default.

        *   `HEAD`: HTTP and HTTPS health checks use the HEAD method by default.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP`, `HTTPS`, or `gRPC`.
        """
        return pulumi.get(self, "health_check_method")

    @health_check_method.setter
    def health_check_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check_method", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that is used for health checks.

        The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : ' , +`. The URL must start with a forward slash (`/`).

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true` and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check_path", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol that is used for health checks. Valid values:

        - `HTTP`: HTTP health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers.
        - `HTTPS`: HTTPS health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers. HTTPS provides higher security than HTTP because HTTPS supports data encryption.
        - `TCP`: TCP health checks send TCP SYN packets to a backend server to probe the availability of backend servers.
        - `gRPC`: gRPC health checks send POST or GET requests to a backend server to check whether the backend server is healthy.
        """
        return pulumi.get(self, "health_check_protocol")

    @health_check_protocol.setter
    def health_check_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check_protocol", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.

        Valid values: `1` to `300`.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        return pulumi.get(self, "health_check_timeout")

    @health_check_timeout.setter
    def health_check_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "health_check_timeout", value)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health check status of the backend server changes from `fail` to `success`.

        Valid values: `2` to `10`.

        Default value: `3`.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "healthy_threshold", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health check status of the backend server changes from `success` to `fail`.

        Valid values: `2` to `10`.

        Default value: `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class ServerGroupServerArgsDict(TypedDict):
        server_id: pulumi.Input[_builtins.str]
        """
        The ID of the backend server. You can specify at most 200 servers in each call.

        *   If the server group is of the `Instance` type, set ServerId to the ID of a resource of the `Ecs`, `Eni`, or `Eci` type.

        *   If the server group is of the `Ip` type, set ServerId to IP addresses.

        > **NOTE:**   You cannot perform this operation on a server group of the Function Compute type. You can call the [ListServerGroups](https://www.alibabacloud.com/help/en/doc-detail/213627.html) operation to query the type of server groups.
        """
        server_type: pulumi.Input[_builtins.str]
        """
        The type of the backend server. You can specify at most 200 servers in each call. Default values:

        - `Ecs`: Elastic Compute Service (ECS) instance
        - `Eni`: elastic network interface (ENI)
        - `Eci`: elastic container instance
        - `Ip`: IP address
        - `Fc`: Function Compute
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the backend server. The description must be 2 to 256 characters in length, and cannot start with http:// or https://.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port that is used by the backend server. Valid values: `1` to `65535`. You can specify at most 200 servers in each call.

        > **NOTE:**   This parameter is required if you set `ServerType` to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to set this parameter if `ServerType` is set to `Fc`.
        """
        remote_ip_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the remote IP feature. You can specify at most 200 servers in each call. Default values:
        """
        server_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the server group.
        """
        server_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the backend server. You can specify at most 200 servers in each call.

        > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the resource
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The weight of the backend server. Valid values: `0` to `100`. Default value: `0`. If the value is set to `0`, no requests are forwarded to the server. You can specify at most 200 servers in each call.

        > **NOTE:**   Default value: `0`. We strongly recommend specifying this parameter.
        > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
elif False:
    ServerGroupServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupServerArgs:
    def __init__(__self__, *,
                 server_id: pulumi.Input[_builtins.str],
                 server_type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 remote_ip_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 server_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 server_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] server_id: The ID of the backend server. You can specify at most 200 servers in each call.
               
               *   If the server group is of the `Instance` type, set ServerId to the ID of a resource of the `Ecs`, `Eni`, or `Eci` type.
               
               *   If the server group is of the `Ip` type, set ServerId to IP addresses.
               
               > **NOTE:**   You cannot perform this operation on a server group of the Function Compute type. You can call the [ListServerGroups](https://www.alibabacloud.com/help/en/doc-detail/213627.html) operation to query the type of server groups.
        :param pulumi.Input[_builtins.str] server_type: The type of the backend server. You can specify at most 200 servers in each call. Default values:
               
               - `Ecs`: Elastic Compute Service (ECS) instance
               - `Eni`: elastic network interface (ENI)
               - `Eci`: elastic container instance
               - `Ip`: IP address
               - `Fc`: Function Compute
        :param pulumi.Input[_builtins.str] description: The description of the backend server. The description must be 2 to 256 characters in length, and cannot start with http:// or https://.
        :param pulumi.Input[_builtins.int] port: The port that is used by the backend server. Valid values: `1` to `65535`. You can specify at most 200 servers in each call.
               
               > **NOTE:**   This parameter is required if you set `ServerType` to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to set this parameter if `ServerType` is set to `Fc`.
        :param pulumi.Input[_builtins.bool] remote_ip_enabled: Specifies whether to enable the remote IP feature. You can specify at most 200 servers in each call. Default values:
        :param pulumi.Input[_builtins.str] server_group_id: The ID of the server group.
        :param pulumi.Input[_builtins.str] server_ip: The IP address of the backend server. You can specify at most 200 servers in each call.
               
               > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        :param pulumi.Input[_builtins.str] status: The status of the resource
        :param pulumi.Input[_builtins.int] weight: The weight of the backend server. Valid values: `0` to `100`. Default value: `0`. If the value is set to `0`, no requests are forwarded to the server. You can specify at most 200 servers in each call.
               
               > **NOTE:**   Default value: `0`. We strongly recommend specifying this parameter.
               > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_type", server_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if remote_ip_enabled is not None:
            pulumi.set(__self__, "remote_ip_enabled", remote_ip_enabled)
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)
        if server_ip is not None:
            pulumi.set(__self__, "server_ip", server_ip)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the backend server. You can specify at most 200 servers in each call.

        *   If the server group is of the `Instance` type, set ServerId to the ID of a resource of the `Ecs`, `Eni`, or `Eci` type.

        *   If the server group is of the `Ip` type, set ServerId to IP addresses.

        > **NOTE:**   You cannot perform this operation on a server group of the Function Compute type. You can call the [ListServerGroups](https://www.alibabacloud.com/help/en/doc-detail/213627.html) operation to query the type of server groups.
        """
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_id", value)

    @_builtins.property
    @pulumi.getter(name="serverType")
    def server_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the backend server. You can specify at most 200 servers in each call. Default values:

        - `Ecs`: Elastic Compute Service (ECS) instance
        - `Eni`: elastic network interface (ENI)
        - `Eci`: elastic container instance
        - `Ip`: IP address
        - `Fc`: Function Compute
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the backend server. The description must be 2 to 256 characters in length, and cannot start with http:// or https://.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port that is used by the backend server. Valid values: `1` to `65535`. You can specify at most 200 servers in each call.

        > **NOTE:**   This parameter is required if you set `ServerType` to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to set this parameter if `ServerType` is set to `Fc`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="remoteIpEnabled")
    def remote_ip_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the remote IP feature. You can specify at most 200 servers in each call. Default values:
        """
        return pulumi.get(self, "remote_ip_enabled")

    @remote_ip_enabled.setter
    def remote_ip_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "remote_ip_enabled", value)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the server group.
        """
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_group_id", value)

    @_builtins.property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the backend server. You can specify at most 200 servers in each call.

        > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        return pulumi.get(self, "server_ip")

    @server_ip.setter
    def server_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_ip", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the resource
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The weight of the backend server. Valid values: `0` to `100`. Default value: `0`. If the value is set to `0`, no requests are forwarded to the server. You can specify at most 200 servers in each call.

        > **NOTE:**   Default value: `0`. We strongly recommend specifying this parameter.
        > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ServerGroupSlowStartConfigArgsDict(TypedDict):
        slow_start_duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration of a slow start.

        Valid values: 30 to 900.

        Default value: 30.
        """
        slow_start_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether slow starts are enabled. Valid values:
        """
elif False:
    ServerGroupSlowStartConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupSlowStartConfigArgs:
    def __init__(__self__, *,
                 slow_start_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 slow_start_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] slow_start_duration: The duration of a slow start.
               
               Valid values: 30 to 900.
               
               Default value: 30.
        :param pulumi.Input[_builtins.bool] slow_start_enabled: Indicates whether slow starts are enabled. Valid values:
        """
        if slow_start_duration is not None:
            pulumi.set(__self__, "slow_start_duration", slow_start_duration)
        if slow_start_enabled is not None:
            pulumi.set(__self__, "slow_start_enabled", slow_start_enabled)

    @_builtins.property
    @pulumi.getter(name="slowStartDuration")
    def slow_start_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration of a slow start.

        Valid values: 30 to 900.

        Default value: 30.
        """
        return pulumi.get(self, "slow_start_duration")

    @slow_start_duration.setter
    def slow_start_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "slow_start_duration", value)

    @_builtins.property
    @pulumi.getter(name="slowStartEnabled")
    def slow_start_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether slow starts are enabled. Valid values:
        """
        return pulumi.get(self, "slow_start_enabled")

    @slow_start_enabled.setter
    def slow_start_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "slow_start_enabled", value)


if not MYPY:
    class ServerGroupStickySessionConfigArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cookie to be configured on the server.

        The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).

        > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` and the `StickySessionType` parameter is set to `Server`.
        """
        cookie_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of time to wait before the session cookie expires. Unit: seconds.

        Valid values: `1` to `86400`.

        Default value: `1000`.

        > **NOTE:**   This parameter takes effect only when `StickySessionEnabled` is set to `true` and `StickySessionType` is set to `Insert`.
        """
        sticky_session_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable session persistence. Valid values:
        """
        sticky_session_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The method that is used to handle a cookie. Valid values:

        *   `Insert`: inserts a cookie.

        ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.

        *   `Server`: rewrites a cookie.

        When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.

        > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` for the server group.
        """
elif False:
    ServerGroupStickySessionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupStickySessionConfigArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input[_builtins.str]] = None,
                 cookie_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 sticky_session_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 sticky_session_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cookie: The cookie to be configured on the server.
               
               The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).
               
               > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` and the `StickySessionType` parameter is set to `Server`.
        :param pulumi.Input[_builtins.int] cookie_timeout: The maximum amount of time to wait before the session cookie expires. Unit: seconds.
               
               Valid values: `1` to `86400`.
               
               Default value: `1000`.
               
               > **NOTE:**   This parameter takes effect only when `StickySessionEnabled` is set to `true` and `StickySessionType` is set to `Insert`.
        :param pulumi.Input[_builtins.bool] sticky_session_enabled: Specifies whether to enable session persistence. Valid values:
        :param pulumi.Input[_builtins.str] sticky_session_type: The method that is used to handle a cookie. Valid values:
               
               *   `Insert`: inserts a cookie.
               
               ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.
               
               *   `Server`: rewrites a cookie.
               
               When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.
               
               > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` for the server group.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if cookie_timeout is not None:
            pulumi.set(__self__, "cookie_timeout", cookie_timeout)
        if sticky_session_enabled is not None:
            pulumi.set(__self__, "sticky_session_enabled", sticky_session_enabled)
        if sticky_session_type is not None:
            pulumi.set(__self__, "sticky_session_type", sticky_session_type)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cookie to be configured on the server.

        The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).

        > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` and the `StickySessionType` parameter is set to `Server`.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie", value)

    @_builtins.property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of time to wait before the session cookie expires. Unit: seconds.

        Valid values: `1` to `86400`.

        Default value: `1000`.

        > **NOTE:**   This parameter takes effect only when `StickySessionEnabled` is set to `true` and `StickySessionType` is set to `Insert`.
        """
        return pulumi.get(self, "cookie_timeout")

    @cookie_timeout.setter
    def cookie_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cookie_timeout", value)

    @_builtins.property
    @pulumi.getter(name="stickySessionEnabled")
    def sticky_session_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable session persistence. Valid values:
        """
        return pulumi.get(self, "sticky_session_enabled")

    @sticky_session_enabled.setter
    def sticky_session_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sticky_session_enabled", value)

    @_builtins.property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The method that is used to handle a cookie. Valid values:

        *   `Insert`: inserts a cookie.

        ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.

        *   `Server`: rewrites a cookie.

        When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.

        > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` for the server group.
        """
        return pulumi.get(self, "sticky_session_type")

    @sticky_session_type.setter
    def sticky_session_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sticky_session_type", value)


if not MYPY:
    class ServerGroupUchConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The parameter type. Only QueryString can be filled.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Consistency hash parameter value
        """
elif False:
    ServerGroupUchConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupUchConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The parameter type. Only QueryString can be filled.
        :param pulumi.Input[_builtins.str] value: Consistency hash parameter value
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The parameter type. Only QueryString can be filled.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Consistency hash parameter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


