# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AScriptExtAttributeArgs',
    'AclAclEntryArgs',
    'ListenerAccessLogTracingConfigArgs',
    'ListenerAclConfigArgs',
    'ListenerAclConfigAclRelationArgs',
    'ListenerCertificatesArgs',
    'ListenerDefaultActionArgs',
    'ListenerDefaultActionForwardGroupConfigArgs',
    'ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs',
    'ListenerQuicConfigArgs',
    'ListenerXForwardedForConfigArgs',
    'LoadBalancerAccessLogConfigArgs',
    'LoadBalancerLoadBalancerBillingConfigArgs',
    'LoadBalancerModificationProtectionConfigArgs',
    'LoadBalancerZoneMappingArgs',
    'LoadBalancerZoneMappingLoadBalancerAddressArgs',
    'RuleRuleActionArgs',
    'RuleRuleActionCorsConfigArgs',
    'RuleRuleActionFixedResponseConfigArgs',
    'RuleRuleActionForwardGroupConfigArgs',
    'RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs',
    'RuleRuleActionForwardGroupConfigServerGroupTupleArgs',
    'RuleRuleActionInsertHeaderConfigArgs',
    'RuleRuleActionRedirectConfigArgs',
    'RuleRuleActionRemoveHeaderConfigArgs',
    'RuleRuleActionRewriteConfigArgs',
    'RuleRuleActionTrafficLimitConfigArgs',
    'RuleRuleActionTrafficMirrorConfigArgs',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs',
    'RuleRuleConditionArgs',
    'RuleRuleConditionCookieConfigArgs',
    'RuleRuleConditionCookieConfigValueArgs',
    'RuleRuleConditionHeaderConfigArgs',
    'RuleRuleConditionHostConfigArgs',
    'RuleRuleConditionMethodConfigArgs',
    'RuleRuleConditionPathConfigArgs',
    'RuleRuleConditionQueryStringConfigArgs',
    'RuleRuleConditionQueryStringConfigValueArgs',
    'RuleRuleConditionResponseHeaderConfigArgs',
    'RuleRuleConditionResponseStatusCodeConfigArgs',
    'RuleRuleConditionSourceIpConfigArgs',
    'ServerGroupHealthCheckConfigArgs',
    'ServerGroupServerArgs',
    'ServerGroupStickySessionConfigArgs',
]

@pulumi.input_type
class AScriptExtAttributeArgs:
    def __init__(__self__, *,
                 attribute_key: Optional[pulumi.Input[str]] = None,
                 attribute_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_key: The key of the extended attribute.
        :param pulumi.Input[str] attribute_value: The value of the extended attribute.
        """
        if attribute_key is not None:
            pulumi.set(__self__, "attribute_key", attribute_key)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the extended attribute.
        """
        return pulumi.get(self, "attribute_key")

    @attribute_key.setter
    def attribute_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_key", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the extended attribute.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_value", value)


@pulumi.input_type
class AclAclEntryArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 entry: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        :param pulumi.Input[str] entry: The IP address for the ACL entry.
        :param pulumi.Input[str] status: The status of the ACL entry. Valid values:
               - `Adding`: The ACL entry is being added.
               - `Available`: The ACL entry is added and available.
               - `Removing`: The ACL entry is being removed.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entry is not None:
            pulumi.set(__self__, "entry", entry)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entry(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address for the ACL entry.
        """
        return pulumi.get(self, "entry")

    @entry.setter
    def entry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the ACL entry. Valid values:
        - `Adding`: The ACL entry is being added.
        - `Available`: The ACL entry is added and available.
        - `Removing`: The ACL entry is being removed.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class ListenerAccessLogTracingConfigArgs:
    def __init__(__self__, *,
                 tracing_enabled: Optional[pulumi.Input[bool]] = None,
                 tracing_sample: Optional[pulumi.Input[int]] = None,
                 tracing_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] tracing_enabled: Xtrace Function. Value: `True` Or `False` . Default Value: `False`.
               
               > **NOTE:** Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the `True`.
        :param pulumi.Input[int] tracing_sample: Xtrace Sampling Rate. Value: `1` to `10000`.
               
               > **NOTE:** This attribute is valid when `tracingenabled` is `true`.
        :param pulumi.Input[str] tracing_type: Xtrace Type Value Is `Zipkin`.
               
               > **NOTE:** This attribute is valid when `tracingenabled` is `true`.
        """
        if tracing_enabled is not None:
            pulumi.set(__self__, "tracing_enabled", tracing_enabled)
        if tracing_sample is not None:
            pulumi.set(__self__, "tracing_sample", tracing_sample)
        if tracing_type is not None:
            pulumi.set(__self__, "tracing_type", tracing_type)

    @property
    @pulumi.getter(name="tracingEnabled")
    def tracing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Xtrace Function. Value: `True` Or `False` . Default Value: `False`.

        > **NOTE:** Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the `True`.
        """
        return pulumi.get(self, "tracing_enabled")

    @tracing_enabled.setter
    def tracing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tracing_enabled", value)

    @property
    @pulumi.getter(name="tracingSample")
    def tracing_sample(self) -> Optional[pulumi.Input[int]]:
        """
        Xtrace Sampling Rate. Value: `1` to `10000`.

        > **NOTE:** This attribute is valid when `tracingenabled` is `true`.
        """
        return pulumi.get(self, "tracing_sample")

    @tracing_sample.setter
    def tracing_sample(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tracing_sample", value)

    @property
    @pulumi.getter(name="tracingType")
    def tracing_type(self) -> Optional[pulumi.Input[str]]:
        """
        Xtrace Type Value Is `Zipkin`.

        > **NOTE:** This attribute is valid when `tracingenabled` is `true`.
        """
        return pulumi.get(self, "tracing_type")

    @tracing_type.setter
    def tracing_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tracing_type", value)


@pulumi.input_type
class ListenerAclConfigArgs:
    def __init__(__self__, *,
                 acl_relations: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]]] = None,
                 acl_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]] acl_relations: The ACLs that are associated with the listener. See `acl_relations` below for details.
        :param pulumi.Input[str] acl_type: The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        if acl_relations is not None:
            pulumi.set(__self__, "acl_relations", acl_relations)
        if acl_type is not None:
            pulumi.set(__self__, "acl_type", acl_type)

    @property
    @pulumi.getter(name="aclRelations")
    def acl_relations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]]]:
        """
        The ACLs that are associated with the listener. See `acl_relations` below for details.
        """
        return pulumi.get(self, "acl_relations")

    @acl_relations.setter
    def acl_relations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerAclConfigAclRelationArgs']]]]):
        pulumi.set(self, "acl_relations", value)

    @property
    @pulumi.getter(name="aclType")
    def acl_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        return pulumi.get(self, "acl_type")

    @acl_type.setter
    def acl_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acl_type", value)


@pulumi.input_type
class ListenerAclConfigAclRelationArgs:
    def __init__(__self__, *,
                 acl_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: The state of the listener. Valid Values: `Running` Or `Stopped`. Valid values: `Running`: The listener is running. `Stopped`: The listener is stopped.
        """
        if acl_id is not None:
            pulumi.set(__self__, "acl_id", acl_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="aclId")
    def acl_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "acl_id")

    @acl_id.setter
    def acl_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acl_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the listener. Valid Values: `Running` Or `Stopped`. Valid values: `Running`: The listener is running. `Stopped`: The listener is stopped.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class ListenerCertificatesArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_id: The ID of the Certificate.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)


@pulumi.input_type
class ListenerDefaultActionArgs:
    def __init__(__self__, *,
                 forward_group_config: pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs'],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs'] forward_group_config: The configurations of the actions. This parameter is required if Type is set to FowardGroup. See `forward_group_config` below for details.
        :param pulumi.Input[str] type: Action Type.
        """
        pulumi.set(__self__, "forward_group_config", forward_group_config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="forwardGroupConfig")
    def forward_group_config(self) -> pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs']:
        """
        The configurations of the actions. This parameter is required if Type is set to FowardGroup. See `forward_group_config` below for details.
        """
        return pulumi.get(self, "forward_group_config")

    @forward_group_config.setter
    def forward_group_config(self, value: pulumi.Input['ListenerDefaultActionForwardGroupConfigArgs']):
        pulumi.set(self, "forward_group_config", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Action Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ListenerDefaultActionForwardGroupConfigArgs:
    def __init__(__self__, *,
                 server_group_tuples: pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]]):
        pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]]:
        return pulumi.get(self, "server_group_tuples")

    @server_group_tuples.setter
    def server_group_tuples(self, value: pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs']]]):
        pulumi.set(self, "server_group_tuples", value)


@pulumi.input_type
class ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs:
    def __init__(__self__, *,
                 server_group_id: pulumi.Input[str]):
        pulumi.set(__self__, "server_group_id", server_group_id)

    @property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_group_id", value)


@pulumi.input_type
class ListenerQuicConfigArgs:
    def __init__(__self__, *,
                 quic_listener_id: Optional[pulumi.Input[str]] = None,
                 quic_upgrade_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] quic_listener_id: There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        :param pulumi.Input[bool] quic_upgrade_enabled: Indicates Whether to Enable the QuIC Upgrade.
               
               > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
        """
        if quic_listener_id is not None:
            pulumi.set(__self__, "quic_listener_id", quic_listener_id)
        if quic_upgrade_enabled is not None:
            pulumi.set(__self__, "quic_upgrade_enabled", quic_upgrade_enabled)

    @property
    @pulumi.getter(name="quicListenerId")
    def quic_listener_id(self) -> Optional[pulumi.Input[str]]:
        """
        There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        """
        return pulumi.get(self, "quic_listener_id")

    @quic_listener_id.setter
    def quic_listener_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quic_listener_id", value)

    @property
    @pulumi.getter(name="quicUpgradeEnabled")
    def quic_upgrade_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether to Enable the QuIC Upgrade.

        > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
        """
        return pulumi.get(self, "quic_upgrade_enabled")

    @quic_upgrade_enabled.setter
    def quic_upgrade_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "quic_upgrade_enabled", value)


@pulumi.input_type
class ListenerXForwardedForConfigArgs:
    def __init__(__self__, *,
                 x_forwarded_for_client_cert_client_verify_alias: Optional[pulumi.Input[str]] = None,
                 x_forwarded_for_client_cert_client_verify_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_client_cert_finger_print_alias: Optional[pulumi.Input[str]] = None,
                 x_forwarded_for_client_cert_finger_print_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_client_cert_issuer_dn_alias: Optional[pulumi.Input[str]] = None,
                 x_forwarded_for_client_cert_issuer_dn_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_client_cert_subject_dn_alias: Optional[pulumi.Input[str]] = None,
                 x_forwarded_for_client_cert_subject_dn_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_client_source_ips_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_client_source_ips_trusted: Optional[pulumi.Input[str]] = None,
                 x_forwarded_for_client_src_port_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_proto_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_slb_id_enabled: Optional[pulumi.Input[bool]] = None,
                 x_forwarded_for_slb_port_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] x_forwarded_for_client_cert_client_verify_alias: The Custom Header Field Names Only When `x_forwarded_for_client_cert_client_verify_enabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        :param pulumi.Input[bool] x_forwarded_for_client_cert_client_verify_enabled: Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        :param pulumi.Input[str] x_forwarded_for_client_cert_finger_print_alias: The Custom Header Field Names Only When `x_forwarded_for_client_certfingerprint_enabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        :param pulumi.Input[bool] x_forwarded_for_client_cert_finger_print_enabled: Indicates Whether the `X-Forwarded-client_cert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        :param pulumi.Input[str] x_forwarded_for_client_cert_issuer_dn_alias: The Custom Header Field Names Only When `x_forwarded_for_client_cert_issuer_dn_enabled`, Which Evaluates to True When the Entry into Force of.
        :param pulumi.Input[bool] x_forwarded_for_client_cert_issuer_dn_enabled: Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        :param pulumi.Input[str] x_forwarded_for_client_cert_subject_dn_alias: The name of the custom header. This parameter is valid only if `x_forwarded_for_client_certsubjectdn_enabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        :param pulumi.Input[bool] x_forwarded_for_client_cert_subject_dn_enabled: Specifies whether to use the `X-Forwarded-client_cert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
        :param pulumi.Input[bool] x_forwarded_for_client_source_ips_enabled: Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value: true, false. Note HTTP, HTTPS, and QUIC listeners support this parameter. The function corresponding to this parameter is not open by default. Please contact the account manager if you need to use it.
        :param pulumi.Input[str] x_forwarded_for_client_source_ips_trusted: Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        :param pulumi.Input[bool] x_forwarded_for_client_src_port_enabled: Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        :param pulumi.Input[bool] x_forwarded_for_enabled: Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        :param pulumi.Input[bool] x_forwarded_for_proto_enabled: Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        :param pulumi.Input[bool] x_forwarded_for_slb_id_enabled: Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id.
        :param pulumi.Input[bool] x_forwarded_for_slb_port_enabled: Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
        """
        if x_forwarded_for_client_cert_client_verify_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_client_verify_alias", x_forwarded_for_client_cert_client_verify_alias)
        if x_forwarded_for_client_cert_client_verify_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_client_verify_enabled", x_forwarded_for_client_cert_client_verify_enabled)
        if x_forwarded_for_client_cert_finger_print_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_finger_print_alias", x_forwarded_for_client_cert_finger_print_alias)
        if x_forwarded_for_client_cert_finger_print_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_finger_print_enabled", x_forwarded_for_client_cert_finger_print_enabled)
        if x_forwarded_for_client_cert_issuer_dn_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_issuer_dn_alias", x_forwarded_for_client_cert_issuer_dn_alias)
        if x_forwarded_for_client_cert_issuer_dn_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_issuer_dn_enabled", x_forwarded_for_client_cert_issuer_dn_enabled)
        if x_forwarded_for_client_cert_subject_dn_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_subject_dn_alias", x_forwarded_for_client_cert_subject_dn_alias)
        if x_forwarded_for_client_cert_subject_dn_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_subject_dn_enabled", x_forwarded_for_client_cert_subject_dn_enabled)
        if x_forwarded_for_client_source_ips_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_source_ips_enabled", x_forwarded_for_client_source_ips_enabled)
        if x_forwarded_for_client_source_ips_trusted is not None:
            pulumi.set(__self__, "x_forwarded_for_client_source_ips_trusted", x_forwarded_for_client_source_ips_trusted)
        if x_forwarded_for_client_src_port_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_src_port_enabled", x_forwarded_for_client_src_port_enabled)
        if x_forwarded_for_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_enabled", x_forwarded_for_enabled)
        if x_forwarded_for_proto_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_proto_enabled", x_forwarded_for_proto_enabled)
        if x_forwarded_for_slb_id_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_slb_id_enabled", x_forwarded_for_slb_id_enabled)
        if x_forwarded_for_slb_port_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_slb_port_enabled", x_forwarded_for_slb_port_enabled)

    @property
    @pulumi.getter(name="xForwardedForClientCertClientVerifyAlias")
    def x_forwarded_for_client_cert_client_verify_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The Custom Header Field Names Only When `x_forwarded_for_client_cert_client_verify_enabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_client_verify_alias")

    @x_forwarded_for_client_cert_client_verify_alias.setter
    def x_forwarded_for_client_cert_client_verify_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_client_verify_alias", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertClientVerifyEnabled")
    def x_forwarded_for_client_cert_client_verify_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_client_verify_enabled")

    @x_forwarded_for_client_cert_client_verify_enabled.setter
    def x_forwarded_for_client_cert_client_verify_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_client_verify_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertFingerPrintAlias")
    def x_forwarded_for_client_cert_finger_print_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The Custom Header Field Names Only When `x_forwarded_for_client_certfingerprint_enabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_finger_print_alias")

    @x_forwarded_for_client_cert_finger_print_alias.setter
    def x_forwarded_for_client_cert_finger_print_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_finger_print_alias", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertFingerPrintEnabled")
    def x_forwarded_for_client_cert_finger_print_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the `X-Forwarded-client_cert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_finger_print_enabled")

    @x_forwarded_for_client_cert_finger_print_enabled.setter
    def x_forwarded_for_client_cert_finger_print_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_finger_print_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertIssuerDnAlias")
    def x_forwarded_for_client_cert_issuer_dn_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The Custom Header Field Names Only When `x_forwarded_for_client_cert_issuer_dn_enabled`, Which Evaluates to True When the Entry into Force of.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_issuer_dn_alias")

    @x_forwarded_for_client_cert_issuer_dn_alias.setter
    def x_forwarded_for_client_cert_issuer_dn_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_issuer_dn_alias", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertIssuerDnEnabled")
    def x_forwarded_for_client_cert_issuer_dn_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_issuer_dn_enabled")

    @x_forwarded_for_client_cert_issuer_dn_enabled.setter
    def x_forwarded_for_client_cert_issuer_dn_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_issuer_dn_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertSubjectDnAlias")
    def x_forwarded_for_client_cert_subject_dn_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header. This parameter is valid only if `x_forwarded_for_client_certsubjectdn_enabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_subject_dn_alias")

    @x_forwarded_for_client_cert_subject_dn_alias.setter
    def x_forwarded_for_client_cert_subject_dn_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_forwarded_for_client_cert_subject_dn_alias", value)

    @property
    @pulumi.getter(name="xForwardedForClientCertSubjectDnEnabled")
    def x_forwarded_for_client_cert_subject_dn_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to use the `X-Forwarded-client_cert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_subject_dn_enabled")

    @x_forwarded_for_client_cert_subject_dn_enabled.setter
    def x_forwarded_for_client_cert_subject_dn_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_client_cert_subject_dn_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForClientSourceIpsEnabled")
    def x_forwarded_for_client_source_ips_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value: true, false. Note HTTP, HTTPS, and QUIC listeners support this parameter. The function corresponding to this parameter is not open by default. Please contact the account manager if you need to use it.
        """
        return pulumi.get(self, "x_forwarded_for_client_source_ips_enabled")

    @x_forwarded_for_client_source_ips_enabled.setter
    def x_forwarded_for_client_source_ips_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_client_source_ips_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForClientSourceIpsTrusted")
    def x_forwarded_for_client_source_ips_trusted(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        """
        return pulumi.get(self, "x_forwarded_for_client_source_ips_trusted")

    @x_forwarded_for_client_source_ips_trusted.setter
    def x_forwarded_for_client_source_ips_trusted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_forwarded_for_client_source_ips_trusted", value)

    @property
    @pulumi.getter(name="xForwardedForClientSrcPortEnabled")
    def x_forwarded_for_client_src_port_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        """
        return pulumi.get(self, "x_forwarded_for_client_src_port_enabled")

    @x_forwarded_for_client_src_port_enabled.setter
    def x_forwarded_for_client_src_port_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_client_src_port_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForEnabled")
    def x_forwarded_for_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        """
        return pulumi.get(self, "x_forwarded_for_enabled")

    @x_forwarded_for_enabled.setter
    def x_forwarded_for_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForProtoEnabled")
    def x_forwarded_for_proto_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        """
        return pulumi.get(self, "x_forwarded_for_proto_enabled")

    @x_forwarded_for_proto_enabled.setter
    def x_forwarded_for_proto_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_proto_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForSlbIdEnabled")
    def x_forwarded_for_slb_id_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id.
        """
        return pulumi.get(self, "x_forwarded_for_slb_id_enabled")

    @x_forwarded_for_slb_id_enabled.setter
    def x_forwarded_for_slb_id_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_slb_id_enabled", value)

    @property
    @pulumi.getter(name="xForwardedForSlbPortEnabled")
    def x_forwarded_for_slb_port_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
        """
        return pulumi.get(self, "x_forwarded_for_slb_port_enabled")

    @x_forwarded_for_slb_port_enabled.setter
    def x_forwarded_for_slb_port_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_forwarded_for_slb_port_enabled", value)


@pulumi.input_type
class LoadBalancerAccessLogConfigArgs:
    def __init__(__self__, *,
                 log_project: pulumi.Input[str],
                 log_store: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_project: This Log Storage Project.
        :param pulumi.Input[str] log_store: This Log Storage Method Is Increased.
        """
        pulumi.set(__self__, "log_project", log_project)
        pulumi.set(__self__, "log_store", log_store)

    @property
    @pulumi.getter(name="logProject")
    def log_project(self) -> pulumi.Input[str]:
        """
        This Log Storage Project.
        """
        return pulumi.get(self, "log_project")

    @log_project.setter
    def log_project(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_project", value)

    @property
    @pulumi.getter(name="logStore")
    def log_store(self) -> pulumi.Input[str]:
        """
        This Log Storage Method Is Increased.
        """
        return pulumi.get(self, "log_store")

    @log_store.setter
    def log_store(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_store", value)


@pulumi.input_type
class LoadBalancerLoadBalancerBillingConfigArgs:
    def __init__(__self__, *,
                 pay_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] pay_type: Pay Type. Valid values: `PayAsYouGo`. **Note:** provider changes the payment type to `PayAsYouGo`, while the actual parameter on api is `PostPay`.
        """
        pulumi.set(__self__, "pay_type", pay_type)

    @property
    @pulumi.getter(name="payType")
    def pay_type(self) -> pulumi.Input[str]:
        """
        Pay Type. Valid values: `PayAsYouGo`. **Note:** provider changes the payment type to `PayAsYouGo`, while the actual parameter on api is `PostPay`.
        """
        return pulumi.get(self, "pay_type")

    @pay_type.setter
    def pay_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "pay_type", value)


@pulumi.input_type
class LoadBalancerModificationProtectionConfigArgs:
    def __init__(__self__, *,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] reason: Managed Instance.
        :param pulumi.Input[str] status: Load Balancing Modify the Protection Status.
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        Managed Instance.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Load Balancing Modify the Protection Status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class LoadBalancerZoneMappingArgs:
    def __init__(__self__, *,
                 vswitch_id: pulumi.Input[str],
                 zone_id: pulumi.Input[str],
                 load_balancer_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]]] = None):
        """
        :param pulumi.Input[str] vswitch_id: The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        :param pulumi.Input[str] zone_id: The ID of the zone to which the SLB instance belongs.
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]] load_balancer_addresses: The SLB Instance Address.
        """
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if load_balancer_addresses is not None:
            pulumi.set(__self__, "load_balancer_addresses", load_balancer_addresses)

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> pulumi.Input[str]:
        """
        The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        """
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vswitch_id", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> pulumi.Input[str]:
        """
        The ID of the zone to which the SLB instance belongs.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="loadBalancerAddresses")
    def load_balancer_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]]]:
        """
        The SLB Instance Address.
        """
        return pulumi.get(self, "load_balancer_addresses")

    @load_balancer_addresses.setter
    def load_balancer_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerZoneMappingLoadBalancerAddressArgs']]]]):
        pulumi.set(self, "load_balancer_addresses", value)


@pulumi.input_type
class LoadBalancerZoneMappingLoadBalancerAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 allocation_id: Optional[pulumi.Input[str]] = None,
                 eip_type: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: IP Address. The Public IP Address, and Private IP Address from the Address Type.
        :param pulumi.Input[str] allocation_id: The ID of the EIP instance.
        :param pulumi.Input[str] eip_type: The type of the EIP instance.
        :param pulumi.Input[str] ipv6_address: Ipv6 address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if eip_type is not None:
            pulumi.set(__self__, "eip_type", eip_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        IP Address. The Public IP Address, and Private IP Address from the Address Type.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the EIP instance.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)

    @property
    @pulumi.getter(name="eipType")
    def eip_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the EIP instance.
        """
        return pulumi.get(self, "eip_type")

    @eip_type.setter
    def eip_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eip_type", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        Ipv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)


@pulumi.input_type
class RuleRuleActionArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[int],
                 type: pulumi.Input[str],
                 cors_config: Optional[pulumi.Input['RuleRuleActionCorsConfigArgs']] = None,
                 fixed_response_config: Optional[pulumi.Input['RuleRuleActionFixedResponseConfigArgs']] = None,
                 forward_group_config: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigArgs']] = None,
                 insert_header_config: Optional[pulumi.Input['RuleRuleActionInsertHeaderConfigArgs']] = None,
                 redirect_config: Optional[pulumi.Input['RuleRuleActionRedirectConfigArgs']] = None,
                 remove_header_config: Optional[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs']] = None,
                 rewrite_config: Optional[pulumi.Input['RuleRuleActionRewriteConfigArgs']] = None,
                 traffic_limit_config: Optional[pulumi.Input['RuleRuleActionTrafficLimitConfigArgs']] = None,
                 traffic_mirror_config: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs']] = None):
        """
        :param pulumi.Input[int] order: The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        :param pulumi.Input[str] type: The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
               **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
               **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
               **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        :param pulumi.Input['RuleRuleActionCorsConfigArgs'] cors_config: Request forwarding based on CORS. See `cors_config` below.
        :param pulumi.Input['RuleRuleActionFixedResponseConfigArgs'] fixed_response_config: The configuration of the fixed response. See `fixed_response_config` below.
        :param pulumi.Input['RuleRuleActionForwardGroupConfigArgs'] forward_group_config: The forward response action within ALB. See `forward_group_config` below.
        :param pulumi.Input['RuleRuleActionInsertHeaderConfigArgs'] insert_header_config: The configuration of the inserted header field. See `insert_header_config` below.
        :param pulumi.Input['RuleRuleActionRedirectConfigArgs'] redirect_config: The configuration of the external redirect action. See `redirect_config` below.
        :param pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs'] remove_header_config: The configuration of the inserted header field. See `remove_header_config` below.
        :param pulumi.Input['RuleRuleActionRewriteConfigArgs'] rewrite_config: The redirect action within ALB. See `rewrite_config` below.
        :param pulumi.Input['RuleRuleActionTrafficLimitConfigArgs'] traffic_limit_config: The Flow speed limit. See `traffic_limit_config` below.
        :param pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs'] traffic_mirror_config: The Traffic mirroring. See `traffic_mirror_config` below.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "type", type)
        if cors_config is not None:
            pulumi.set(__self__, "cors_config", cors_config)
        if fixed_response_config is not None:
            pulumi.set(__self__, "fixed_response_config", fixed_response_config)
        if forward_group_config is not None:
            pulumi.set(__self__, "forward_group_config", forward_group_config)
        if insert_header_config is not None:
            pulumi.set(__self__, "insert_header_config", insert_header_config)
        if redirect_config is not None:
            pulumi.set(__self__, "redirect_config", redirect_config)
        if remove_header_config is not None:
            pulumi.set(__self__, "remove_header_config", remove_header_config)
        if rewrite_config is not None:
            pulumi.set(__self__, "rewrite_config", rewrite_config)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)
        if traffic_mirror_config is not None:
            pulumi.set(__self__, "traffic_mirror_config", traffic_mirror_config)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        """
        The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
        **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
        **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
        **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="corsConfig")
    def cors_config(self) -> Optional[pulumi.Input['RuleRuleActionCorsConfigArgs']]:
        """
        Request forwarding based on CORS. See `cors_config` below.
        """
        return pulumi.get(self, "cors_config")

    @cors_config.setter
    def cors_config(self, value: Optional[pulumi.Input['RuleRuleActionCorsConfigArgs']]):
        pulumi.set(self, "cors_config", value)

    @property
    @pulumi.getter(name="fixedResponseConfig")
    def fixed_response_config(self) -> Optional[pulumi.Input['RuleRuleActionFixedResponseConfigArgs']]:
        """
        The configuration of the fixed response. See `fixed_response_config` below.
        """
        return pulumi.get(self, "fixed_response_config")

    @fixed_response_config.setter
    def fixed_response_config(self, value: Optional[pulumi.Input['RuleRuleActionFixedResponseConfigArgs']]):
        pulumi.set(self, "fixed_response_config", value)

    @property
    @pulumi.getter(name="forwardGroupConfig")
    def forward_group_config(self) -> Optional[pulumi.Input['RuleRuleActionForwardGroupConfigArgs']]:
        """
        The forward response action within ALB. See `forward_group_config` below.
        """
        return pulumi.get(self, "forward_group_config")

    @forward_group_config.setter
    def forward_group_config(self, value: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigArgs']]):
        pulumi.set(self, "forward_group_config", value)

    @property
    @pulumi.getter(name="insertHeaderConfig")
    def insert_header_config(self) -> Optional[pulumi.Input['RuleRuleActionInsertHeaderConfigArgs']]:
        """
        The configuration of the inserted header field. See `insert_header_config` below.
        """
        return pulumi.get(self, "insert_header_config")

    @insert_header_config.setter
    def insert_header_config(self, value: Optional[pulumi.Input['RuleRuleActionInsertHeaderConfigArgs']]):
        pulumi.set(self, "insert_header_config", value)

    @property
    @pulumi.getter(name="redirectConfig")
    def redirect_config(self) -> Optional[pulumi.Input['RuleRuleActionRedirectConfigArgs']]:
        """
        The configuration of the external redirect action. See `redirect_config` below.
        """
        return pulumi.get(self, "redirect_config")

    @redirect_config.setter
    def redirect_config(self, value: Optional[pulumi.Input['RuleRuleActionRedirectConfigArgs']]):
        pulumi.set(self, "redirect_config", value)

    @property
    @pulumi.getter(name="removeHeaderConfig")
    def remove_header_config(self) -> Optional[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs']]:
        """
        The configuration of the inserted header field. See `remove_header_config` below.
        """
        return pulumi.get(self, "remove_header_config")

    @remove_header_config.setter
    def remove_header_config(self, value: Optional[pulumi.Input['RuleRuleActionRemoveHeaderConfigArgs']]):
        pulumi.set(self, "remove_header_config", value)

    @property
    @pulumi.getter(name="rewriteConfig")
    def rewrite_config(self) -> Optional[pulumi.Input['RuleRuleActionRewriteConfigArgs']]:
        """
        The redirect action within ALB. See `rewrite_config` below.
        """
        return pulumi.get(self, "rewrite_config")

    @rewrite_config.setter
    def rewrite_config(self, value: Optional[pulumi.Input['RuleRuleActionRewriteConfigArgs']]):
        pulumi.set(self, "rewrite_config", value)

    @property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional[pulumi.Input['RuleRuleActionTrafficLimitConfigArgs']]:
        """
        The Flow speed limit. See `traffic_limit_config` below.
        """
        return pulumi.get(self, "traffic_limit_config")

    @traffic_limit_config.setter
    def traffic_limit_config(self, value: Optional[pulumi.Input['RuleRuleActionTrafficLimitConfigArgs']]):
        pulumi.set(self, "traffic_limit_config", value)

    @property
    @pulumi.getter(name="trafficMirrorConfig")
    def traffic_mirror_config(self) -> Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs']]:
        """
        The Traffic mirroring. See `traffic_mirror_config` below.
        """
        return pulumi.get(self, "traffic_mirror_config")

    @traffic_mirror_config.setter
    def traffic_mirror_config(self, value: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigArgs']]):
        pulumi.set(self, "traffic_mirror_config", value)


@pulumi.input_type
class RuleRuleActionCorsConfigArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[str]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class RuleRuleActionFixedResponseConfigArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 http_code: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_code")

    @http_code.setter
    def http_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_code", value)


@pulumi.input_type
class RuleRuleActionForwardGroupConfigArgs:
    def __init__(__self__, *,
                 server_group_sticky_session: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs']] = None,
                 server_group_tuples: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]]] = None):
        if server_group_sticky_session is not None:
            pulumi.set(__self__, "server_group_sticky_session", server_group_sticky_session)
        if server_group_tuples is not None:
            pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @property
    @pulumi.getter(name="serverGroupStickySession")
    def server_group_sticky_session(self) -> Optional[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs']]:
        return pulumi.get(self, "server_group_sticky_session")

    @server_group_sticky_session.setter
    def server_group_sticky_session(self, value: Optional[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs']]):
        pulumi.set(self, "server_group_sticky_session", value)

    @property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]]]:
        return pulumi.get(self, "server_group_tuples")

    @server_group_tuples.setter
    def server_group_tuples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionForwardGroupConfigServerGroupTupleArgs']]]]):
        pulumi.set(self, "server_group_tuples", value)


@pulumi.input_type
class RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class RuleRuleActionForwardGroupConfigServerGroupTupleArgs:
    def __init__(__self__, *,
                 server_group_id: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_group_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class RuleRuleActionInsertHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 value_type: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_type", value)


@pulumi.input_type
class RuleRuleActionRedirectConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 http_code: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_code")

    @http_code.setter
    def http_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_code", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class RuleRuleActionRemoveHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class RuleRuleActionRewriteConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class RuleRuleActionTrafficLimitConfigArgs:
    def __init__(__self__, *,
                 per_ip_qps: Optional[pulumi.Input[int]] = None,
                 qps: Optional[pulumi.Input[int]] = None):
        if per_ip_qps is not None:
            pulumi.set(__self__, "per_ip_qps", per_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @property
    @pulumi.getter(name="perIpQps")
    def per_ip_qps(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "per_ip_qps")

    @per_ip_qps.setter
    def per_ip_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "per_ip_qps", value)

    @property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qps", value)


@pulumi.input_type
class RuleRuleActionTrafficMirrorConfigArgs:
    def __init__(__self__, *,
                 mirror_group_config: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs']] = None,
                 target_type: Optional[pulumi.Input[str]] = None):
        if mirror_group_config is not None:
            pulumi.set(__self__, "mirror_group_config", mirror_group_config)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="mirrorGroupConfig")
    def mirror_group_config(self) -> Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs']]:
        return pulumi.get(self, "mirror_group_config")

    @mirror_group_config.setter
    def mirror_group_config(self, value: Optional[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs']]):
        pulumi.set(self, "mirror_group_config", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_type", value)


@pulumi.input_type
class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs:
    def __init__(__self__, *,
                 server_group_tuples: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]]] = None):
        if server_group_tuples is not None:
            pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]]]:
        return pulumi.get(self, "server_group_tuples")

    @server_group_tuples.setter
    def server_group_tuples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs']]]]):
        pulumi.set(self, "server_group_tuples", value)


@pulumi.input_type
class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs:
    def __init__(__self__, *,
                 server_group_id: Optional[pulumi.Input[str]] = None):
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)

    @property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_group_id")

    @server_group_id.setter
    def server_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_group_id", value)


@pulumi.input_type
class RuleRuleConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cookie_config: Optional[pulumi.Input['RuleRuleConditionCookieConfigArgs']] = None,
                 header_config: Optional[pulumi.Input['RuleRuleConditionHeaderConfigArgs']] = None,
                 host_config: Optional[pulumi.Input['RuleRuleConditionHostConfigArgs']] = None,
                 method_config: Optional[pulumi.Input['RuleRuleConditionMethodConfigArgs']] = None,
                 path_config: Optional[pulumi.Input['RuleRuleConditionPathConfigArgs']] = None,
                 query_string_config: Optional[pulumi.Input['RuleRuleConditionQueryStringConfigArgs']] = None,
                 response_header_config: Optional[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs']] = None,
                 response_status_code_config: Optional[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs']] = None,
                 source_ip_config: Optional[pulumi.Input['RuleRuleConditionSourceIpConfigArgs']] = None):
        """
        :param pulumi.Input[str] type: The type of the forwarding rule. Valid values:
               - `Host`: Requests are forwarded based on hosts.
               - `Path`: Requests are forwarded based on the path.
               - `Header`: Requests are forwarded based on the HTTP header field.
               - `QueryString`: Requests are forwarded based on the query string.
               - `Method`: Request are forwarded based on the request method.
               - `Cookie`: Requests are forwarded based on the cookie.
               - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
               - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
               - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        :param pulumi.Input['RuleRuleConditionCookieConfigArgs'] cookie_config: The configuration of the cookie. See See `cookie_config` below.
        :param pulumi.Input['RuleRuleConditionHeaderConfigArgs'] header_config: The configuration of the header field. See `header_config` below.
        :param pulumi.Input['RuleRuleConditionHostConfigArgs'] host_config: The configuration of the host field. See `host_config` below.
        :param pulumi.Input['RuleRuleConditionMethodConfigArgs'] method_config: The configuration of the request method. See `method_config` below.
        :param pulumi.Input['RuleRuleConditionPathConfigArgs'] path_config: The configuration of the path for the request to be forwarded. See `path_config` below.
        :param pulumi.Input['RuleRuleConditionQueryStringConfigArgs'] query_string_config: The configuration of the query string. See `query_string_config` below.
        :param pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs'] response_header_config: The configuration of the header field. See `response_header_config` below.
        :param pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs'] response_status_code_config: The configuration of the header field. See `response_status_code_config` below.
        :param pulumi.Input['RuleRuleConditionSourceIpConfigArgs'] source_ip_config: The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
        pulumi.set(__self__, "type", type)
        if cookie_config is not None:
            pulumi.set(__self__, "cookie_config", cookie_config)
        if header_config is not None:
            pulumi.set(__self__, "header_config", header_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if method_config is not None:
            pulumi.set(__self__, "method_config", method_config)
        if path_config is not None:
            pulumi.set(__self__, "path_config", path_config)
        if query_string_config is not None:
            pulumi.set(__self__, "query_string_config", query_string_config)
        if response_header_config is not None:
            pulumi.set(__self__, "response_header_config", response_header_config)
        if response_status_code_config is not None:
            pulumi.set(__self__, "response_status_code_config", response_status_code_config)
        if source_ip_config is not None:
            pulumi.set(__self__, "source_ip_config", source_ip_config)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the forwarding rule. Valid values:
        - `Host`: Requests are forwarded based on hosts.
        - `Path`: Requests are forwarded based on the path.
        - `Header`: Requests are forwarded based on the HTTP header field.
        - `QueryString`: Requests are forwarded based on the query string.
        - `Method`: Request are forwarded based on the request method.
        - `Cookie`: Requests are forwarded based on the cookie.
        - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
        - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
        - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cookieConfig")
    def cookie_config(self) -> Optional[pulumi.Input['RuleRuleConditionCookieConfigArgs']]:
        """
        The configuration of the cookie. See See `cookie_config` below.
        """
        return pulumi.get(self, "cookie_config")

    @cookie_config.setter
    def cookie_config(self, value: Optional[pulumi.Input['RuleRuleConditionCookieConfigArgs']]):
        pulumi.set(self, "cookie_config", value)

    @property
    @pulumi.getter(name="headerConfig")
    def header_config(self) -> Optional[pulumi.Input['RuleRuleConditionHeaderConfigArgs']]:
        """
        The configuration of the header field. See `header_config` below.
        """
        return pulumi.get(self, "header_config")

    @header_config.setter
    def header_config(self, value: Optional[pulumi.Input['RuleRuleConditionHeaderConfigArgs']]):
        pulumi.set(self, "header_config", value)

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional[pulumi.Input['RuleRuleConditionHostConfigArgs']]:
        """
        The configuration of the host field. See `host_config` below.
        """
        return pulumi.get(self, "host_config")

    @host_config.setter
    def host_config(self, value: Optional[pulumi.Input['RuleRuleConditionHostConfigArgs']]):
        pulumi.set(self, "host_config", value)

    @property
    @pulumi.getter(name="methodConfig")
    def method_config(self) -> Optional[pulumi.Input['RuleRuleConditionMethodConfigArgs']]:
        """
        The configuration of the request method. See `method_config` below.
        """
        return pulumi.get(self, "method_config")

    @method_config.setter
    def method_config(self, value: Optional[pulumi.Input['RuleRuleConditionMethodConfigArgs']]):
        pulumi.set(self, "method_config", value)

    @property
    @pulumi.getter(name="pathConfig")
    def path_config(self) -> Optional[pulumi.Input['RuleRuleConditionPathConfigArgs']]:
        """
        The configuration of the path for the request to be forwarded. See `path_config` below.
        """
        return pulumi.get(self, "path_config")

    @path_config.setter
    def path_config(self, value: Optional[pulumi.Input['RuleRuleConditionPathConfigArgs']]):
        pulumi.set(self, "path_config", value)

    @property
    @pulumi.getter(name="queryStringConfig")
    def query_string_config(self) -> Optional[pulumi.Input['RuleRuleConditionQueryStringConfigArgs']]:
        """
        The configuration of the query string. See `query_string_config` below.
        """
        return pulumi.get(self, "query_string_config")

    @query_string_config.setter
    def query_string_config(self, value: Optional[pulumi.Input['RuleRuleConditionQueryStringConfigArgs']]):
        pulumi.set(self, "query_string_config", value)

    @property
    @pulumi.getter(name="responseHeaderConfig")
    def response_header_config(self) -> Optional[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs']]:
        """
        The configuration of the header field. See `response_header_config` below.
        """
        return pulumi.get(self, "response_header_config")

    @response_header_config.setter
    def response_header_config(self, value: Optional[pulumi.Input['RuleRuleConditionResponseHeaderConfigArgs']]):
        pulumi.set(self, "response_header_config", value)

    @property
    @pulumi.getter(name="responseStatusCodeConfig")
    def response_status_code_config(self) -> Optional[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs']]:
        """
        The configuration of the header field. See `response_status_code_config` below.
        """
        return pulumi.get(self, "response_status_code_config")

    @response_status_code_config.setter
    def response_status_code_config(self, value: Optional[pulumi.Input['RuleRuleConditionResponseStatusCodeConfigArgs']]):
        pulumi.set(self, "response_status_code_config", value)

    @property
    @pulumi.getter(name="sourceIpConfig")
    def source_ip_config(self) -> Optional[pulumi.Input['RuleRuleConditionSourceIpConfigArgs']]:
        """
        The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
        return pulumi.get(self, "source_ip_config")

    @source_ip_config.setter
    def source_ip_config(self, value: Optional[pulumi.Input['RuleRuleConditionSourceIpConfigArgs']]):
        pulumi.set(self, "source_ip_config", value)


@pulumi.input_type
class RuleRuleConditionCookieConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionCookieConfigValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionCookieConfigValueArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleRuleConditionHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionHostConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionMethodConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionPathConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionQueryStringConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRuleConditionQueryStringConfigValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionQueryStringConfigValueArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleRuleConditionResponseHeaderConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionResponseStatusCodeConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RuleRuleConditionSourceIpConfigArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ServerGroupHealthCheckConfigArgs:
    def __init__(__self__, *,
                 health_check_enabled: pulumi.Input[bool],
                 health_check_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 health_check_connect_port: Optional[pulumi.Input[int]] = None,
                 health_check_host: Optional[pulumi.Input[str]] = None,
                 health_check_http_version: Optional[pulumi.Input[str]] = None,
                 health_check_interval: Optional[pulumi.Input[int]] = None,
                 health_check_method: Optional[pulumi.Input[str]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 health_check_protocol: Optional[pulumi.Input[str]] = None,
                 health_check_timeout: Optional[pulumi.Input[int]] = None,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] health_check_enabled: Specifies whether to enable the health check feature. Valid values: `true`, `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] health_check_codes: The HTTP status codes that are used to indicate whether the backend server passes the health check. Valid values:
               - If `health_check_protocol` is set to `HTTP` or `HTTPS`. Valid values: `http_2xx`, `http_3xx`, `http_4xx`, and `http_5xx`. Default value: `http_2xx`.
               - If `health_check_protocol` is set to `gRPC`. Valid values: `0` to `99`. Default value: `0`.
        :param pulumi.Input[int] health_check_connect_port: The backend port that is used for health checks. Default value: `0`. Valid values: `0` to `65535`. A value of 0 indicates that a backend server port is used for health checks.
        :param pulumi.Input[str] health_check_host: The domain name that is used for health checks.
        :param pulumi.Input[str] health_check_http_version: The version of the HTTP protocol. Default value: `HTTP1.1`. Valid values: `HTTP1.0` and `HTTP1.1`. **NOTE:** This parameter takes effect only when `health_check_protocol` is set to `HTTP` or `HTTPS`.
        :param pulumi.Input[int] health_check_interval: The interval at which health checks are performed. Unit: seconds. Default value: `2`. Valid values: `1` to `50`.
        :param pulumi.Input[str] health_check_method: The HTTP method that is used for health checks. Default value: `GET`. Valid values: `GET`, `POST`, `HEAD`. **NOTE:** This parameter takes effect only when `health_check_protocol` is set to `HTTP`, `HTTPS`, or `gRPC`. From version 1.215.0, `health_check_method` can be set to `POST`.
        :param pulumi.Input[str] health_check_path: The path that is used for health checks. **NOTE:** This parameter takes effect only when `health_check_protocol` is set to `HTTP` or `HTTPS`.
        :param pulumi.Input[str] health_check_protocol: The protocol that is used for health checks. Valid values: `HTTP`, `HTTPS`, `TCP` and `gRPC`.
        :param pulumi.Input[int] health_check_timeout: The timeout period for a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Default value: `5`. Valid values: `1` to `300`. **NOTE:** If the value of `health_check_timeout` is smaller than the value of `health_check_interval`, the value of `health_check_timeout` is ignored and the value of `health_check_interval` is used.
        :param pulumi.Input[int] healthy_threshold: The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. Default value: `3`. Valid values: `2` to `10`.
        :param pulumi.Input[int] unhealthy_threshold: The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. Default value: `3`. Valid values: `2` to `10`.
        """
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if health_check_codes is not None:
            pulumi.set(__self__, "health_check_codes", health_check_codes)
        if health_check_connect_port is not None:
            pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        if health_check_host is not None:
            pulumi.set(__self__, "health_check_host", health_check_host)
        if health_check_http_version is not None:
            pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_method is not None:
            pulumi.set(__self__, "health_check_method", health_check_method)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if health_check_protocol is not None:
            pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        if health_check_timeout is not None:
            pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether to enable the health check feature. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "health_check_enabled")

    @health_check_enabled.setter
    def health_check_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "health_check_enabled", value)

    @property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP status codes that are used to indicate whether the backend server passes the health check. Valid values:
        - If `health_check_protocol` is set to `HTTP` or `HTTPS`. Valid values: `http_2xx`, `http_3xx`, `http_4xx`, and `http_5xx`. Default value: `http_2xx`.
        - If `health_check_protocol` is set to `gRPC`. Valid values: `0` to `99`. Default value: `0`.
        """
        return pulumi.get(self, "health_check_codes")

    @health_check_codes.setter
    def health_check_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "health_check_codes", value)

    @property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> Optional[pulumi.Input[int]]:
        """
        The backend port that is used for health checks. Default value: `0`. Valid values: `0` to `65535`. A value of 0 indicates that a backend server port is used for health checks.
        """
        return pulumi.get(self, "health_check_connect_port")

    @health_check_connect_port.setter
    def health_check_connect_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_connect_port", value)

    @property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name that is used for health checks.
        """
        return pulumi.get(self, "health_check_host")

    @health_check_host.setter
    def health_check_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_host", value)

    @property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the HTTP protocol. Default value: `HTTP1.1`. Valid values: `HTTP1.0` and `HTTP1.1`. **NOTE:** This parameter takes effect only when `health_check_protocol` is set to `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "health_check_http_version")

    @health_check_http_version.setter
    def health_check_http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_http_version", value)

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which health checks are performed. Unit: seconds. Default value: `2`. Valid values: `1` to `50`.
        """
        return pulumi.get(self, "health_check_interval")

    @health_check_interval.setter
    def health_check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_interval", value)

    @property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method that is used for health checks. Default value: `GET`. Valid values: `GET`, `POST`, `HEAD`. **NOTE:** This parameter takes effect only when `health_check_protocol` is set to `HTTP`, `HTTPS`, or `gRPC`. From version 1.215.0, `health_check_method` can be set to `POST`.
        """
        return pulumi.get(self, "health_check_method")

    @health_check_method.setter
    def health_check_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_method", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path that is used for health checks. **NOTE:** This parameter takes effect only when `health_check_protocol` is set to `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol that is used for health checks. Valid values: `HTTP`, `HTTPS`, `TCP` and `gRPC`.
        """
        return pulumi.get(self, "health_check_protocol")

    @health_check_protocol.setter
    def health_check_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_protocol", value)

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout period for a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Default value: `5`. Valid values: `1` to `300`. **NOTE:** If the value of `health_check_timeout` is smaller than the value of `health_check_interval`, the value of `health_check_timeout` is ignored and the value of `health_check_interval` is used.
        """
        return pulumi.get(self, "health_check_timeout")

    @health_check_timeout.setter
    def health_check_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_timeout", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. Default value: `3`. Valid values: `2` to `10`.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. Default value: `3`. Valid values: `2` to `10`.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


@pulumi.input_type
class ServerGroupServerArgs:
    def __init__(__self__, *,
                 server_id: pulumi.Input[str],
                 server_type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 remote_ip_enabled: Optional[pulumi.Input[bool]] = None,
                 server_ip: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] server_id: The ID of the backend server.
               - If `server_group_type` is set to `Instance`, set the parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by Ecs, Eni, or Eci.
               - If `server_group_type` is set to `Ip`, set the parameter to an IP address specified in the server group.
               - If `server_group_type` is set to `Fc`, set the parameter to the Alibaba Cloud Resource Name (ARN) of a function specified in the server group.
        :param pulumi.Input[str] server_type: The type of the server. The type of the server. Valid values:
               - `Ecs`: an ECS instance.
               - `Eni`: an ENI.
               - `Eci`: an elastic container instance.
               - `Ip`(Available since v1.194.0): an IP address.
               - `Fc`(Available since v1.194.0): a function.
        :param pulumi.Input[str] description: The description of the backend server.
        :param pulumi.Input[int] port: The port used by the backend server. Valid values: `1` to `65535`. **Note:** This parameter is required if the `server_type` parameter is set to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to configure this parameter if you set `server_type` to `Fc`.
        :param pulumi.Input[bool] remote_ip_enabled: Specifies whether to enable the remote IP address feature. You can specify up to 40 servers in each call. **Note:** If `server_type` is set to `Ip`, this parameter is available.
        :param pulumi.Input[str] server_ip: The IP address of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. **Note:** If `server_group_type` is set to `Fc`, you do not need to configure parameters, otherwise this attribute is required. If `server_group_type` is set to `Ip`, the value of this property is the same as the `server_id` value.
        :param pulumi.Input[str] status: The status of the backend server.
        :param pulumi.Input[int] weight: The weight of the server. Default value: `100`. Valid values: `0` to `100`. If the value is set to `0`, no requests are forwarded to the server. **Note:** You do not need to set this parameter if you set `server_type` to `Fc`.
        """
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_type", server_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if remote_ip_enabled is not None:
            pulumi.set(__self__, "remote_ip_enabled", remote_ip_enabled)
        if server_ip is not None:
            pulumi.set(__self__, "server_ip", server_ip)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> pulumi.Input[str]:
        """
        The ID of the backend server.
        - If `server_group_type` is set to `Instance`, set the parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by Ecs, Eni, or Eci.
        - If `server_group_type` is set to `Ip`, set the parameter to an IP address specified in the server group.
        - If `server_group_type` is set to `Fc`, set the parameter to the Alibaba Cloud Resource Name (ARN) of a function specified in the server group.
        """
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_id", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> pulumi.Input[str]:
        """
        The type of the server. The type of the server. Valid values:
        - `Ecs`: an ECS instance.
        - `Eni`: an ENI.
        - `Eci`: an elastic container instance.
        - `Ip`(Available since v1.194.0): an IP address.
        - `Fc`(Available since v1.194.0): a function.
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the backend server.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port used by the backend server. Valid values: `1` to `65535`. **Note:** This parameter is required if the `server_type` parameter is set to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to configure this parameter if you set `server_type` to `Fc`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="remoteIpEnabled")
    def remote_ip_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to enable the remote IP address feature. You can specify up to 40 servers in each call. **Note:** If `server_type` is set to `Ip`, this parameter is available.
        """
        return pulumi.get(self, "remote_ip_enabled")

    @remote_ip_enabled.setter
    def remote_ip_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_ip_enabled", value)

    @property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. **Note:** If `server_group_type` is set to `Fc`, you do not need to configure parameters, otherwise this attribute is required. If `server_group_type` is set to `Ip`, the value of this property is the same as the `server_id` value.
        """
        return pulumi.get(self, "server_ip")

    @server_ip.setter
    def server_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_ip", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the backend server.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The weight of the server. Default value: `100`. Valid values: `0` to `100`. If the value is set to `0`, no requests are forwarded to the server. **Note:** You do not need to set this parameter if you set `server_type` to `Fc`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class ServerGroupStickySessionConfigArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input[str]] = None,
                 cookie_timeout: Optional[pulumi.Input[int]] = None,
                 sticky_session_enabled: Optional[pulumi.Input[bool]] = None,
                 sticky_session_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cookie: The cookie to be configured on the server. **NOTE:** This parameter takes effect when the `sticky_session_enabled` parameter is set to `true` and the `sticky_session_type` parameter is set to `Server`.
        :param pulumi.Input[int] cookie_timeout: The timeout period of a cookie. Unit: seconds. Default value: `1000`. Valid values: `1` to `86400`. **NOTE:** This parameter takes effect when the `sticky_session_enabled` parameter is set to `true` and the `sticky_session_type` parameter is set to `Insert`.
        :param pulumi.Input[bool] sticky_session_enabled: Specifies whether to enable session persistence. Default value: `false`. Valid values: `true`, `false`. **NOTE:** This parameter takes effect when the `server_group_type` parameter is set to `Instance` or `Ip`.
        :param pulumi.Input[str] sticky_session_type: The method that is used to handle a cookie. Valid values: `Server`, `Insert`.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if cookie_timeout is not None:
            pulumi.set(__self__, "cookie_timeout", cookie_timeout)
        if sticky_session_enabled is not None:
            pulumi.set(__self__, "sticky_session_enabled", sticky_session_enabled)
        if sticky_session_type is not None:
            pulumi.set(__self__, "sticky_session_type", sticky_session_type)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input[str]]:
        """
        The cookie to be configured on the server. **NOTE:** This parameter takes effect when the `sticky_session_enabled` parameter is set to `true` and the `sticky_session_type` parameter is set to `Server`.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout period of a cookie. Unit: seconds. Default value: `1000`. Valid values: `1` to `86400`. **NOTE:** This parameter takes effect when the `sticky_session_enabled` parameter is set to `true` and the `sticky_session_type` parameter is set to `Insert`.
        """
        return pulumi.get(self, "cookie_timeout")

    @cookie_timeout.setter
    def cookie_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cookie_timeout", value)

    @property
    @pulumi.getter(name="stickySessionEnabled")
    def sticky_session_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to enable session persistence. Default value: `false`. Valid values: `true`, `false`. **NOTE:** This parameter takes effect when the `server_group_type` parameter is set to `Instance` or `Ip`.
        """
        return pulumi.get(self, "sticky_session_enabled")

    @sticky_session_enabled.setter
    def sticky_session_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sticky_session_enabled", value)

    @property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> Optional[pulumi.Input[str]]:
        """
        The method that is used to handle a cookie. Valid values: `Server`, `Insert`.
        """
        return pulumi.get(self, "sticky_session_type")

    @sticky_session_type.setter
    def sticky_session_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sticky_session_type", value)


