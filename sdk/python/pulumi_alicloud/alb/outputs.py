# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AScriptExtAttribute',
    'AclAclEntry',
    'ListenerAccessLogTracingConfig',
    'ListenerAclConfig',
    'ListenerAclConfigAclRelation',
    'ListenerCaCertificate',
    'ListenerCertificates',
    'ListenerDefaultAction',
    'ListenerDefaultActionForwardGroupConfig',
    'ListenerDefaultActionForwardGroupConfigServerGroupTuple',
    'ListenerQuicConfig',
    'ListenerXForwardedForConfig',
    'LoadBalancerAccessLogConfig',
    'LoadBalancerDeletionProtectionConfig',
    'LoadBalancerLoadBalancerBillingConfig',
    'LoadBalancerModificationProtectionConfig',
    'LoadBalancerZoneMapping',
    'LoadBalancerZoneMappingLoadBalancerAddress',
    'RuleRuleAction',
    'RuleRuleActionCorsConfig',
    'RuleRuleActionFixedResponseConfig',
    'RuleRuleActionForwardGroupConfig',
    'RuleRuleActionForwardGroupConfigServerGroupStickySession',
    'RuleRuleActionForwardGroupConfigServerGroupTuple',
    'RuleRuleActionInsertHeaderConfig',
    'RuleRuleActionRedirectConfig',
    'RuleRuleActionRemoveHeaderConfig',
    'RuleRuleActionRewriteConfig',
    'RuleRuleActionTrafficLimitConfig',
    'RuleRuleActionTrafficMirrorConfig',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfig',
    'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple',
    'RuleRuleCondition',
    'RuleRuleConditionCookieConfig',
    'RuleRuleConditionCookieConfigValue',
    'RuleRuleConditionHeaderConfig',
    'RuleRuleConditionHostConfig',
    'RuleRuleConditionMethodConfig',
    'RuleRuleConditionPathConfig',
    'RuleRuleConditionQueryStringConfig',
    'RuleRuleConditionQueryStringConfigValue',
    'RuleRuleConditionResponseHeaderConfig',
    'RuleRuleConditionResponseStatusCodeConfig',
    'RuleRuleConditionSourceIpConfig',
    'ServerGroupConnectionDrainConfig',
    'ServerGroupHealthCheckConfig',
    'ServerGroupServer',
    'ServerGroupSlowStartConfig',
    'ServerGroupStickySessionConfig',
    'ServerGroupUchConfig',
    'GetAclsAclResult',
    'GetAclsAclAclEntryResult',
    'GetAscriptsAscriptResult',
    'GetAscriptsAscriptExtAttributeResult',
    'GetHealthCheckTemplatesTemplateResult',
    'GetListenersListenerResult',
    'GetListenersListenerAccessLogTracingConfigResult',
    'GetListenersListenerAclConfigResult',
    'GetListenersListenerAclConfigAclRelationResult',
    'GetListenersListenerCertificateResult',
    'GetListenersListenerDefaultActionResult',
    'GetListenersListenerDefaultActionForwardGroupConfigResult',
    'GetListenersListenerDefaultActionForwardGroupConfigServerGroupTupleResult',
    'GetListenersListenerQuicConfigResult',
    'GetListenersListenerXforwardedForConfigResult',
    'GetLoadBalancersBalancerResult',
    'GetLoadBalancersBalancerAccessLogConfigResult',
    'GetLoadBalancersBalancerDeletionProtectionConfigResult',
    'GetLoadBalancersBalancerLoadBalancerBillingConfigResult',
    'GetLoadBalancersBalancerLoadBalancerOperationLockResult',
    'GetLoadBalancersBalancerModificationProtectionConfigResult',
    'GetLoadBalancersBalancerZoneMappingResult',
    'GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult',
    'GetRulesRuleResult',
    'GetRulesRuleRuleActionResult',
    'GetRulesRuleRuleActionFixedResponseConfigResult',
    'GetRulesRuleRuleActionForwardGroupConfigResult',
    'GetRulesRuleRuleActionForwardGroupConfigServerGroupTupleResult',
    'GetRulesRuleRuleActionInsertHeaderConfigResult',
    'GetRulesRuleRuleActionRedirectConfigResult',
    'GetRulesRuleRuleActionRewriteConfigResult',
    'GetRulesRuleRuleActionTrafficLimitConfigResult',
    'GetRulesRuleRuleActionTrafficMirrorConfigResult',
    'GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigResult',
    'GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleResult',
    'GetRulesRuleRuleConditionResult',
    'GetRulesRuleRuleConditionCookieConfigResult',
    'GetRulesRuleRuleConditionCookieConfigValueResult',
    'GetRulesRuleRuleConditionHeaderConfigResult',
    'GetRulesRuleRuleConditionHostConfigResult',
    'GetRulesRuleRuleConditionMethodConfigResult',
    'GetRulesRuleRuleConditionPathConfigResult',
    'GetRulesRuleRuleConditionQueryStringConfigResult',
    'GetRulesRuleRuleConditionQueryStringConfigValueResult',
    'GetRulesRuleRuleConditionSourceIpConfigResult',
    'GetSecurityPoliciesPolicyResult',
    'GetServerGroupsGroupResult',
    'GetServerGroupsGroupHealthCheckConfigResult',
    'GetServerGroupsGroupServerResult',
    'GetServerGroupsGroupStickySessionConfigResult',
    'GetSystemSecurityPoliciesPolicyResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class AScriptExtAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"
        elif key == "attributeValue":
            suggest = "attribute_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AScriptExtAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AScriptExtAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AScriptExtAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: Optional[_builtins.str] = None,
                 attribute_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute_key: Key to extend attribute
        :param _builtins.str attribute_value: The value of the extended attribute
        """
        if attribute_key is not None:
            pulumi.set(__self__, "attribute_key", attribute_key)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)

    @_builtins.property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> Optional[_builtins.str]:
        """
        Key to extend attribute
        """
        return pulumi.get(self, "attribute_key")

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[_builtins.str]:
        """
        The value of the extended attribute
        """
        return pulumi.get(self, "attribute_value")


@pulumi.output_type
class AclAclEntry(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 entry: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        :param _builtins.str entry: The IP address for the ACL entry.
        :param _builtins.str status: The status of the ACL entry. Valid values:
               - `Adding`: The ACL entry is being added.
               - `Available`: The ACL entry is added and available.
               - `Removing`: The ACL entry is being removed.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entry is not None:
            pulumi.set(__self__, "entry", entry)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the ACL entry. The description must be `1` to `256` characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (_). It can also contain Chinese characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def entry(self) -> Optional[_builtins.str]:
        """
        The IP address for the ACL entry.
        """
        return pulumi.get(self, "entry")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the ACL entry. Valid values:
        - `Adding`: The ACL entry is being added.
        - `Available`: The ACL entry is added and available.
        - `Removing`: The ACL entry is being removed.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ListenerAccessLogTracingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tracingEnabled":
            suggest = "tracing_enabled"
        elif key == "tracingSample":
            suggest = "tracing_sample"
        elif key == "tracingType":
            suggest = "tracing_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerAccessLogTracingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerAccessLogTracingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerAccessLogTracingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tracing_enabled: _builtins.bool,
                 tracing_sample: Optional[_builtins.int] = None,
                 tracing_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool tracing_enabled: Xtrace Function. Valid values: `true`, `false`. Default Value: `false`.
               
               > **NOTE:**  Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the value `true`.
        :param _builtins.int tracing_sample: Xtrace Sampling Rate. Value: 1~10000. `tracingenabled` valued True When Effective.
        :param _builtins.str tracing_type: Xtrace Type Value Is `Zipkin`.
               
               > **NOTE:**  `tracingenabled` valued True When Effective.
        """
        pulumi.set(__self__, "tracing_enabled", tracing_enabled)
        if tracing_sample is not None:
            pulumi.set(__self__, "tracing_sample", tracing_sample)
        if tracing_type is not None:
            pulumi.set(__self__, "tracing_type", tracing_type)

    @_builtins.property
    @pulumi.getter(name="tracingEnabled")
    def tracing_enabled(self) -> _builtins.bool:
        """
        Xtrace Function. Valid values: `true`, `false`. Default Value: `false`.

        > **NOTE:**  Only Instances outside the Security Group to Access the Log Switch `accesslogenabled` Open, in Order to Set This Parameter to the value `true`.
        """
        return pulumi.get(self, "tracing_enabled")

    @_builtins.property
    @pulumi.getter(name="tracingSample")
    def tracing_sample(self) -> Optional[_builtins.int]:
        """
        Xtrace Sampling Rate. Value: 1~10000. `tracingenabled` valued True When Effective.
        """
        return pulumi.get(self, "tracing_sample")

    @_builtins.property
    @pulumi.getter(name="tracingType")
    def tracing_type(self) -> Optional[_builtins.str]:
        """
        Xtrace Type Value Is `Zipkin`.

        > **NOTE:**  `tracingenabled` valued True When Effective.
        """
        return pulumi.get(self, "tracing_type")


@pulumi.output_type
class ListenerAclConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRelations":
            suggest = "acl_relations"
        elif key == "aclType":
            suggest = "acl_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerAclConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerAclConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerAclConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_relations: Optional[Sequence['outputs.ListenerAclConfigAclRelation']] = None,
                 acl_type: Optional[_builtins.str] = None):
        """
        :param Sequence['ListenerAclConfigAclRelationArgs'] acl_relations: The ACLs that are associated with the listener. See `acl_relations` below for details.
        :param _builtins.str acl_type: The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        if acl_relations is not None:
            pulumi.set(__self__, "acl_relations", acl_relations)
        if acl_type is not None:
            pulumi.set(__self__, "acl_type", acl_type)

    @_builtins.property
    @pulumi.getter(name="aclRelations")
    def acl_relations(self) -> Optional[Sequence['outputs.ListenerAclConfigAclRelation']]:
        """
        The ACLs that are associated with the listener. See `acl_relations` below for details.
        """
        return pulumi.get(self, "acl_relations")

    @_builtins.property
    @pulumi.getter(name="aclType")
    def acl_type(self) -> Optional[_builtins.str]:
        """
        The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        return pulumi.get(self, "acl_type")


@pulumi.output_type
class ListenerAclConfigAclRelation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclId":
            suggest = "acl_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerAclConfigAclRelation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerAclConfigAclRelation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerAclConfigAclRelation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_id: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str acl_id: Snooping Binding of the Access Policy Group ID List.
        :param _builtins.str status: The Current IP Address of the Listened State
        """
        if acl_id is not None:
            pulumi.set(__self__, "acl_id", acl_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="aclId")
    def acl_id(self) -> Optional[_builtins.str]:
        """
        Snooping Binding of the Access Policy Group ID List.
        """
        return pulumi.get(self, "acl_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The Current IP Address of the Listened State
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ListenerCaCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerCaCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerCaCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerCaCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_id: The ID of the certificate. Currently, only server certificates are supported.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        The ID of the certificate. Currently, only server certificates are supported.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class ListenerCertificates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerCertificates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerCertificates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerCertificates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_id: The ID of the certificate. Currently, only server certificates are supported.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        The ID of the certificate. Currently, only server certificates are supported.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class ListenerDefaultAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardGroupConfig":
            suggest = "forward_group_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerDefaultAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerDefaultAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerDefaultAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 forward_group_config: Optional['outputs.ListenerDefaultActionForwardGroupConfig'] = None):
        """
        :param _builtins.str type: The action type. Value: ForwardGroup, indicating forwarding to the server group.
        :param 'ListenerDefaultActionForwardGroupConfigArgs' forward_group_config: Forwarding Action Configurations See `forward_group_config` below.
        """
        pulumi.set(__self__, "type", type)
        if forward_group_config is not None:
            pulumi.set(__self__, "forward_group_config", forward_group_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The action type. Value: ForwardGroup, indicating forwarding to the server group.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="forwardGroupConfig")
    def forward_group_config(self) -> Optional['outputs.ListenerDefaultActionForwardGroupConfig']:
        """
        Forwarding Action Configurations See `forward_group_config` below.
        """
        return pulumi.get(self, "forward_group_config")


@pulumi.output_type
class ListenerDefaultActionForwardGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverGroupTuples":
            suggest = "server_group_tuples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerDefaultActionForwardGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerDefaultActionForwardGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerDefaultActionForwardGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_group_tuples: Sequence['outputs.ListenerDefaultActionForwardGroupConfigServerGroupTuple']):
        """
        :param Sequence['ListenerDefaultActionForwardGroupConfigServerGroupTupleArgs'] server_group_tuples: The Forwarding Destination Server Group See `server_group_tuples` below.
        """
        pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Sequence['outputs.ListenerDefaultActionForwardGroupConfigServerGroupTuple']:
        """
        The Forwarding Destination Server Group See `server_group_tuples` below.
        """
        return pulumi.get(self, "server_group_tuples")


@pulumi.output_type
class ListenerDefaultActionForwardGroupConfigServerGroupTuple(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverGroupId":
            suggest = "server_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerDefaultActionForwardGroupConfigServerGroupTuple. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerDefaultActionForwardGroupConfigServerGroupTuple.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerDefaultActionForwardGroupConfigServerGroupTuple.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_group_id: _builtins.str):
        """
        :param _builtins.str server_group_id: Forwarded to the Destination Server Group ID
        """
        pulumi.set(__self__, "server_group_id", server_group_id)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> _builtins.str:
        """
        Forwarded to the Destination Server Group ID
        """
        return pulumi.get(self, "server_group_id")


@pulumi.output_type
class ListenerQuicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quicListenerId":
            suggest = "quic_listener_id"
        elif key == "quicUpgradeEnabled":
            suggest = "quic_upgrade_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerQuicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerQuicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerQuicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quic_listener_id: Optional[_builtins.str] = None,
                 quic_upgrade_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str quic_listener_id: There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        :param _builtins.bool quic_upgrade_enabled: Indicates Whether to Enable the QuIC Upgrade
        """
        if quic_listener_id is not None:
            pulumi.set(__self__, "quic_listener_id", quic_listener_id)
        if quic_upgrade_enabled is not None:
            pulumi.set(__self__, "quic_upgrade_enabled", quic_upgrade_enabled)

    @_builtins.property
    @pulumi.getter(name="quicListenerId")
    def quic_listener_id(self) -> Optional[_builtins.str]:
        """
        There Is a Need to Correlate the QuIC Listener ID. The Https Listener, in Effect at the Time. quicupgradeenabled True When Required.
        """
        return pulumi.get(self, "quic_listener_id")

    @_builtins.property
    @pulumi.getter(name="quicUpgradeEnabled")
    def quic_upgrade_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether to Enable the QuIC Upgrade
        """
        return pulumi.get(self, "quic_upgrade_enabled")


@pulumi.output_type
class ListenerXForwardedForConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xForwardedForClientCertClientVerifyAlias":
            suggest = "x_forwarded_for_client_cert_client_verify_alias"
        elif key == "xForwardedForClientCertClientVerifyEnabled":
            suggest = "x_forwarded_for_client_cert_client_verify_enabled"
        elif key == "xForwardedForClientCertFingerPrintAlias":
            suggest = "x_forwarded_for_client_cert_finger_print_alias"
        elif key == "xForwardedForClientCertFingerPrintEnabled":
            suggest = "x_forwarded_for_client_cert_finger_print_enabled"
        elif key == "xForwardedForClientCertIssuerDnAlias":
            suggest = "x_forwarded_for_client_cert_issuer_dn_alias"
        elif key == "xForwardedForClientCertIssuerDnEnabled":
            suggest = "x_forwarded_for_client_cert_issuer_dn_enabled"
        elif key == "xForwardedForClientCertSubjectDnAlias":
            suggest = "x_forwarded_for_client_cert_subject_dn_alias"
        elif key == "xForwardedForClientCertSubjectDnEnabled":
            suggest = "x_forwarded_for_client_cert_subject_dn_enabled"
        elif key == "xForwardedForClientSourceIpsEnabled":
            suggest = "x_forwarded_for_client_source_ips_enabled"
        elif key == "xForwardedForClientSourceIpsTrusted":
            suggest = "x_forwarded_for_client_source_ips_trusted"
        elif key == "xForwardedForClientSrcPortEnabled":
            suggest = "x_forwarded_for_client_src_port_enabled"
        elif key == "xForwardedForEnabled":
            suggest = "x_forwarded_for_enabled"
        elif key == "xForwardedForHostEnabled":
            suggest = "x_forwarded_for_host_enabled"
        elif key == "xForwardedForProcessingMode":
            suggest = "x_forwarded_for_processing_mode"
        elif key == "xForwardedForProtoEnabled":
            suggest = "x_forwarded_for_proto_enabled"
        elif key == "xForwardedForSlbIdEnabled":
            suggest = "x_forwarded_for_slb_id_enabled"
        elif key == "xForwardedForSlbPortEnabled":
            suggest = "x_forwarded_for_slb_port_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerXForwardedForConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerXForwardedForConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerXForwardedForConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_forwarded_for_client_cert_client_verify_alias: Optional[_builtins.str] = None,
                 x_forwarded_for_client_cert_client_verify_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_client_cert_finger_print_alias: Optional[_builtins.str] = None,
                 x_forwarded_for_client_cert_finger_print_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_client_cert_issuer_dn_alias: Optional[_builtins.str] = None,
                 x_forwarded_for_client_cert_issuer_dn_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_client_cert_subject_dn_alias: Optional[_builtins.str] = None,
                 x_forwarded_for_client_cert_subject_dn_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_client_source_ips_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_client_source_ips_trusted: Optional[_builtins.str] = None,
                 x_forwarded_for_client_src_port_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_host_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_processing_mode: Optional[_builtins.str] = None,
                 x_forwarded_for_proto_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_slb_id_enabled: Optional[_builtins.bool] = None,
                 x_forwarded_for_slb_port_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str x_forwarded_for_client_cert_client_verify_alias: The Custom Header Field Names Only When xforwardedforclientcertclientverifyenabled Has a Value of True, this Value Will Not Take Effect until.
        :param _builtins.bool x_forwarded_for_client_cert_client_verify_enabled: Indicates Whether the X-Forwarded-Clientcert-clientverify Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        :param _builtins.str x_forwarded_for_client_cert_finger_print_alias: The Custom Header Field Names Only When xforwardedforclientcertfingerprintenabled, Which Evaluates to True When the Entry into Force of.
        :param _builtins.bool x_forwarded_for_client_cert_finger_print_enabled: Indicates Whether the X-Forwarded-Clientcert-fingerprint Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        :param _builtins.str x_forwarded_for_client_cert_issuer_dn_alias: The Custom Header Field Names Only When xforwardedforclientcertsubjectdnenabled, Which Evaluates to True When the Entry into Force of.
        :param _builtins.bool x_forwarded_for_client_cert_issuer_dn_enabled: Indicates Whether the X-Forwarded-Clientcert-issuerdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        :param _builtins.str x_forwarded_for_client_cert_subject_dn_alias: The Custom Header Field Name,
        :param _builtins.bool x_forwarded_for_client_cert_subject_dn_enabled: Indicates Whether the X-Forwarded-Clientcert-subjectdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Owner Information.
        :param _builtins.bool x_forwarded_for_client_source_ips_enabled: Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value:
        :param _builtins.str x_forwarded_for_client_source_ips_trusted: Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        :param _builtins.bool x_forwarded_for_client_src_port_enabled: Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        :param _builtins.bool x_forwarded_for_enabled: Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        :param _builtins.bool x_forwarded_for_host_enabled: Whether to enable the X-Forwarded-Host header field to obtain the domain name of the client accessing the Application Load Balancer. Value:
        :param _builtins.str x_forwarded_for_processing_mode: Schema for processing X-Forwarded-For header fields. This value takes effect only when XForwardedForEnabled is true. Value:
        :param _builtins.bool x_forwarded_for_proto_enabled: Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        :param _builtins.bool x_forwarded_for_slb_id_enabled: Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id
        :param _builtins.bool x_forwarded_for_slb_port_enabled: Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port
        """
        if x_forwarded_for_client_cert_client_verify_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_client_verify_alias", x_forwarded_for_client_cert_client_verify_alias)
        if x_forwarded_for_client_cert_client_verify_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_client_verify_enabled", x_forwarded_for_client_cert_client_verify_enabled)
        if x_forwarded_for_client_cert_finger_print_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_finger_print_alias", x_forwarded_for_client_cert_finger_print_alias)
        if x_forwarded_for_client_cert_finger_print_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_finger_print_enabled", x_forwarded_for_client_cert_finger_print_enabled)
        if x_forwarded_for_client_cert_issuer_dn_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_issuer_dn_alias", x_forwarded_for_client_cert_issuer_dn_alias)
        if x_forwarded_for_client_cert_issuer_dn_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_issuer_dn_enabled", x_forwarded_for_client_cert_issuer_dn_enabled)
        if x_forwarded_for_client_cert_subject_dn_alias is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_subject_dn_alias", x_forwarded_for_client_cert_subject_dn_alias)
        if x_forwarded_for_client_cert_subject_dn_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_cert_subject_dn_enabled", x_forwarded_for_client_cert_subject_dn_enabled)
        if x_forwarded_for_client_source_ips_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_source_ips_enabled", x_forwarded_for_client_source_ips_enabled)
        if x_forwarded_for_client_source_ips_trusted is not None:
            pulumi.set(__self__, "x_forwarded_for_client_source_ips_trusted", x_forwarded_for_client_source_ips_trusted)
        if x_forwarded_for_client_src_port_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_client_src_port_enabled", x_forwarded_for_client_src_port_enabled)
        if x_forwarded_for_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_enabled", x_forwarded_for_enabled)
        if x_forwarded_for_host_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_host_enabled", x_forwarded_for_host_enabled)
        if x_forwarded_for_processing_mode is not None:
            pulumi.set(__self__, "x_forwarded_for_processing_mode", x_forwarded_for_processing_mode)
        if x_forwarded_for_proto_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_proto_enabled", x_forwarded_for_proto_enabled)
        if x_forwarded_for_slb_id_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_slb_id_enabled", x_forwarded_for_slb_id_enabled)
        if x_forwarded_for_slb_port_enabled is not None:
            pulumi.set(__self__, "x_forwarded_for_slb_port_enabled", x_forwarded_for_slb_port_enabled)

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertClientVerifyAlias")
    def x_forwarded_for_client_cert_client_verify_alias(self) -> Optional[_builtins.str]:
        """
        The Custom Header Field Names Only When xforwardedforclientcertclientverifyenabled Has a Value of True, this Value Will Not Take Effect until.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_client_verify_alias")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertClientVerifyEnabled")
    def x_forwarded_for_client_cert_client_verify_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Clientcert-clientverify Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_client_verify_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertFingerPrintAlias")
    def x_forwarded_for_client_cert_finger_print_alias(self) -> Optional[_builtins.str]:
        """
        The Custom Header Field Names Only When xforwardedforclientcertfingerprintenabled, Which Evaluates to True When the Entry into Force of.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_finger_print_alias")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertFingerPrintEnabled")
    def x_forwarded_for_client_cert_finger_print_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Clientcert-fingerprint Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_finger_print_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertIssuerDnAlias")
    def x_forwarded_for_client_cert_issuer_dn_alias(self) -> Optional[_builtins.str]:
        """
        The Custom Header Field Names Only When xforwardedforclientcertsubjectdnenabled, Which Evaluates to True When the Entry into Force of.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_issuer_dn_alias")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertIssuerDnEnabled")
    def x_forwarded_for_client_cert_issuer_dn_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Clientcert-issuerdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_issuer_dn_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertSubjectDnAlias")
    def x_forwarded_for_client_cert_subject_dn_alias(self) -> Optional[_builtins.str]:
        """
        The Custom Header Field Name,
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_subject_dn_alias")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientCertSubjectDnEnabled")
    def x_forwarded_for_client_cert_subject_dn_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Clientcert-subjectdn Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Owner Information.
        """
        return pulumi.get(self, "x_forwarded_for_client_cert_subject_dn_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientSourceIpsEnabled")
    def x_forwarded_for_client_source_ips_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to use the X-Forwarded-Client-Ip header to obtain the source IP address of the server load balancer instance. Value:
        """
        return pulumi.get(self, "x_forwarded_for_client_source_ips_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientSourceIpsTrusted")
    def x_forwarded_for_client_source_ips_trusted(self) -> Optional[_builtins.str]:
        """
        Specify the trusted proxy IP. Application-oriented load balancing ALB will traverse the X-Forwarded-For from back to front, and select the first IP that is not in the trusted IP list as the real client IP, which will be used for the source IP speed limit.
        """
        return pulumi.get(self, "x_forwarded_for_client_source_ips_trusted")

    @_builtins.property
    @pulumi.getter(name="xForwardedForClientSrcPortEnabled")
    def x_forwarded_for_client_src_port_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        """
        return pulumi.get(self, "x_forwarded_for_client_src_port_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForEnabled")
    def x_forwarded_for_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to Enable by X-Forwarded-For Header Field Is Used to Obtain the Client IP Addresses.
        """
        return pulumi.get(self, "x_forwarded_for_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForHostEnabled")
    def x_forwarded_for_host_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable the X-Forwarded-Host header field to obtain the domain name of the client accessing the Application Load Balancer. Value:
        """
        return pulumi.get(self, "x_forwarded_for_host_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForProcessingMode")
    def x_forwarded_for_processing_mode(self) -> Optional[_builtins.str]:
        """
        Schema for processing X-Forwarded-For header fields. This value takes effect only when XForwardedForEnabled is true. Value:
        """
        return pulumi.get(self, "x_forwarded_for_processing_mode")

    @_builtins.property
    @pulumi.getter(name="xForwardedForProtoEnabled")
    def x_forwarded_for_proto_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        """
        return pulumi.get(self, "x_forwarded_for_proto_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForSlbIdEnabled")
    def x_forwarded_for_slb_id_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the SLB-ID Header Field Is Used to Obtain the Load Balancing Instance Id
        """
        return pulumi.get(self, "x_forwarded_for_slb_id_enabled")

    @_builtins.property
    @pulumi.getter(name="xForwardedForSlbPortEnabled")
    def x_forwarded_for_slb_port_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port
        """
        return pulumi.get(self, "x_forwarded_for_slb_port_enabled")


@pulumi.output_type
class LoadBalancerAccessLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logProject":
            suggest = "log_project"
        elif key == "logStore":
            suggest = "log_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerAccessLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerAccessLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerAccessLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_project: Optional[_builtins.str] = None,
                 log_store: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_project: The project to which the access log is shipped.
        :param _builtins.str log_store: The Logstore to which the access log is shipped.
        """
        if log_project is not None:
            pulumi.set(__self__, "log_project", log_project)
        if log_store is not None:
            pulumi.set(__self__, "log_store", log_store)

    @_builtins.property
    @pulumi.getter(name="logProject")
    def log_project(self) -> Optional[_builtins.str]:
        """
        The project to which the access log is shipped.
        """
        return pulumi.get(self, "log_project")

    @_builtins.property
    @pulumi.getter(name="logStore")
    def log_store(self) -> Optional[_builtins.str]:
        """
        The Logstore to which the access log is shipped.
        """
        return pulumi.get(self, "log_store")


@pulumi.output_type
class LoadBalancerDeletionProtectionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledTime":
            suggest = "enabled_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerDeletionProtectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerDeletionProtectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerDeletionProtectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 enabled_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Remove the Protection Status
        :param _builtins.str enabled_time: Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm: SSZ
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enabled_time is not None:
            pulumi.set(__self__, "enabled_time", enabled_time)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Remove the Protection Status
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> Optional[_builtins.str]:
        """
        Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm: SSZ
        """
        return pulumi.get(self, "enabled_time")


@pulumi.output_type
class LoadBalancerLoadBalancerBillingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payType":
            suggest = "pay_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerLoadBalancerBillingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerLoadBalancerBillingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerLoadBalancerBillingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pay_type: _builtins.str):
        """
        :param _builtins.str pay_type: Pay Type
        """
        pulumi.set(__self__, "pay_type", pay_type)

    @_builtins.property
    @pulumi.getter(name="payType")
    def pay_type(self) -> _builtins.str:
        """
        Pay Type
        """
        return pulumi.get(self, "pay_type")


@pulumi.output_type
class LoadBalancerModificationProtectionConfig(dict):
    def __init__(__self__, *,
                 reason: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str reason: Managed Instance
        :param _builtins.str status: Load Balancing Modify the Protection Status
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        Managed Instance
        """
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Load Balancing Modify the Protection Status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LoadBalancerZoneMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vswitchId":
            suggest = "vswitch_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "allocationId":
            suggest = "allocation_id"
        elif key == "eipType":
            suggest = "eip_type"
        elif key == "intranetAddress":
            suggest = "intranet_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "loadBalancerAddresses":
            suggest = "load_balancer_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerZoneMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerZoneMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerZoneMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vswitch_id: _builtins.str,
                 zone_id: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 allocation_id: Optional[_builtins.str] = None,
                 eip_type: Optional[_builtins.str] = None,
                 intranet_address: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 load_balancer_addresses: Optional[Sequence['outputs.LoadBalancerZoneMappingLoadBalancerAddress']] = None):
        """
        :param _builtins.str vswitch_id: The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        :param _builtins.str zone_id: The ID of the zone to which the SLB instance belongs.
        :param _builtins.str address: An IP address of the IPv4 type.
        :param _builtins.str allocation_id: The ID of the EIP instance.
        :param _builtins.str eip_type: The type of the EIP instance.
        :param _builtins.str intranet_address: IPv4 private network address.
        :param _builtins.str ipv6_address: An IP address of the IPv6 type.
        :param Sequence['LoadBalancerZoneMappingLoadBalancerAddressArgs'] load_balancer_addresses: The instance address.
        """
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if eip_type is not None:
            pulumi.set(__self__, "eip_type", eip_type)
        if intranet_address is not None:
            pulumi.set(__self__, "intranet_address", intranet_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if load_balancer_addresses is not None:
            pulumi.set(__self__, "load_balancer_addresses", load_balancer_addresses)

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> _builtins.str:
        """
        The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        """
        return pulumi.get(self, "vswitch_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The ID of the zone to which the SLB instance belongs.
        """
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        An IP address of the IPv4 type.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[_builtins.str]:
        """
        The ID of the EIP instance.
        """
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="eipType")
    def eip_type(self) -> Optional[_builtins.str]:
        """
        The type of the EIP instance.
        """
        return pulumi.get(self, "eip_type")

    @_builtins.property
    @pulumi.getter(name="intranetAddress")
    def intranet_address(self) -> Optional[_builtins.str]:
        """
        IPv4 private network address.
        """
        return pulumi.get(self, "intranet_address")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IP address of the IPv6 type.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="loadBalancerAddresses")
    def load_balancer_addresses(self) -> Optional[Sequence['outputs.LoadBalancerZoneMappingLoadBalancerAddress']]:
        """
        The instance address.
        """
        return pulumi.get(self, "load_balancer_addresses")


@pulumi.output_type
class LoadBalancerZoneMappingLoadBalancerAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"
        elif key == "eipType":
            suggest = "eip_type"
        elif key == "intranetAddress":
            suggest = "intranet_address"
        elif key == "intranetAddressHcStatus":
            suggest = "intranet_address_hc_status"
        elif key == "ipv4LocalAddresses":
            suggest = "ipv4_local_addresses"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6AddressHcStatus":
            suggest = "ipv6_address_hc_status"
        elif key == "ipv6LocalAddresses":
            suggest = "ipv6_local_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerZoneMappingLoadBalancerAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerZoneMappingLoadBalancerAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerZoneMappingLoadBalancerAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 allocation_id: Optional[_builtins.str] = None,
                 eip_type: Optional[_builtins.str] = None,
                 intranet_address: Optional[_builtins.str] = None,
                 intranet_address_hc_status: Optional[_builtins.str] = None,
                 ipv4_local_addresses: Optional[Sequence[_builtins.str]] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 ipv6_address_hc_status: Optional[_builtins.str] = None,
                 ipv6_local_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str address: An IP address of the IPv4 type.
        :param _builtins.str allocation_id: The elastic IP identifier.
        :param _builtins.str eip_type: The type of the public EIP. Value:
        :param _builtins.str intranet_address: IPv4 private network address.
        :param _builtins.str intranet_address_hc_status: The private network IPv4 address detection status of the application-oriented load balancing instance.
        :param Sequence[_builtins.str] ipv4_local_addresses: IPv4 Local address list. The list of addresses used by ALB to interact with the backend service.
        :param _builtins.str ipv6_address: An IP address of the IPv6 type.
        :param _builtins.str ipv6_address_hc_status: The IPv6 address detection status of the application-based load balancing instance.
        :param Sequence[_builtins.str] ipv6_local_addresses: IPv6 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if eip_type is not None:
            pulumi.set(__self__, "eip_type", eip_type)
        if intranet_address is not None:
            pulumi.set(__self__, "intranet_address", intranet_address)
        if intranet_address_hc_status is not None:
            pulumi.set(__self__, "intranet_address_hc_status", intranet_address_hc_status)
        if ipv4_local_addresses is not None:
            pulumi.set(__self__, "ipv4_local_addresses", ipv4_local_addresses)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_address_hc_status is not None:
            pulumi.set(__self__, "ipv6_address_hc_status", ipv6_address_hc_status)
        if ipv6_local_addresses is not None:
            pulumi.set(__self__, "ipv6_local_addresses", ipv6_local_addresses)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        An IP address of the IPv4 type.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[_builtins.str]:
        """
        The elastic IP identifier.
        """
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="eipType")
    def eip_type(self) -> Optional[_builtins.str]:
        """
        The type of the public EIP. Value:
        """
        return pulumi.get(self, "eip_type")

    @_builtins.property
    @pulumi.getter(name="intranetAddress")
    def intranet_address(self) -> Optional[_builtins.str]:
        """
        IPv4 private network address.
        """
        return pulumi.get(self, "intranet_address")

    @_builtins.property
    @pulumi.getter(name="intranetAddressHcStatus")
    def intranet_address_hc_status(self) -> Optional[_builtins.str]:
        """
        The private network IPv4 address detection status of the application-oriented load balancing instance.
        """
        return pulumi.get(self, "intranet_address_hc_status")

    @_builtins.property
    @pulumi.getter(name="ipv4LocalAddresses")
    def ipv4_local_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv4 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        return pulumi.get(self, "ipv4_local_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        An IP address of the IPv6 type.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressHcStatus")
    def ipv6_address_hc_status(self) -> Optional[_builtins.str]:
        """
        The IPv6 address detection status of the application-based load balancing instance.
        """
        return pulumi.get(self, "ipv6_address_hc_status")

    @_builtins.property
    @pulumi.getter(name="ipv6LocalAddresses")
    def ipv6_local_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPv6 Local address list. The list of addresses used by ALB to interact with the backend service.
        """
        return pulumi.get(self, "ipv6_local_addresses")


@pulumi.output_type
class RuleRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsConfig":
            suggest = "cors_config"
        elif key == "fixedResponseConfig":
            suggest = "fixed_response_config"
        elif key == "forwardGroupConfig":
            suggest = "forward_group_config"
        elif key == "insertHeaderConfig":
            suggest = "insert_header_config"
        elif key == "redirectConfig":
            suggest = "redirect_config"
        elif key == "removeHeaderConfig":
            suggest = "remove_header_config"
        elif key == "rewriteConfig":
            suggest = "rewrite_config"
        elif key == "trafficLimitConfig":
            suggest = "traffic_limit_config"
        elif key == "trafficMirrorConfig":
            suggest = "traffic_mirror_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 order: _builtins.int,
                 type: _builtins.str,
                 cors_config: Optional['outputs.RuleRuleActionCorsConfig'] = None,
                 fixed_response_config: Optional['outputs.RuleRuleActionFixedResponseConfig'] = None,
                 forward_group_config: Optional['outputs.RuleRuleActionForwardGroupConfig'] = None,
                 insert_header_config: Optional['outputs.RuleRuleActionInsertHeaderConfig'] = None,
                 redirect_config: Optional['outputs.RuleRuleActionRedirectConfig'] = None,
                 remove_header_config: Optional['outputs.RuleRuleActionRemoveHeaderConfig'] = None,
                 rewrite_config: Optional['outputs.RuleRuleActionRewriteConfig'] = None,
                 traffic_limit_config: Optional['outputs.RuleRuleActionTrafficLimitConfig'] = None,
                 traffic_mirror_config: Optional['outputs.RuleRuleActionTrafficMirrorConfig'] = None):
        """
        :param _builtins.int order: The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        :param _builtins.str type: The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
               **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
               **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
               **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        :param 'RuleRuleActionCorsConfigArgs' cors_config: Request forwarding based on CORS. See `cors_config` below.
        :param 'RuleRuleActionFixedResponseConfigArgs' fixed_response_config: The configuration of the fixed response. See `fixed_response_config` below.
        :param 'RuleRuleActionForwardGroupConfigArgs' forward_group_config: The forward response action within ALB. See `forward_group_config` below.
        :param 'RuleRuleActionInsertHeaderConfigArgs' insert_header_config: The configuration of the inserted header field. See `insert_header_config` below.
        :param 'RuleRuleActionRedirectConfigArgs' redirect_config: The configuration of the external redirect action. See `redirect_config` below.
        :param 'RuleRuleActionRemoveHeaderConfigArgs' remove_header_config: The configuration of the inserted header field. See `remove_header_config` below.
        :param 'RuleRuleActionRewriteConfigArgs' rewrite_config: The redirect action within ALB. See `rewrite_config` below.
        :param 'RuleRuleActionTrafficLimitConfigArgs' traffic_limit_config: The Flow speed limit. See `traffic_limit_config` below.
        :param 'RuleRuleActionTrafficMirrorConfigArgs' traffic_mirror_config: The Traffic mirroring. See `traffic_mirror_config` below.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "type", type)
        if cors_config is not None:
            pulumi.set(__self__, "cors_config", cors_config)
        if fixed_response_config is not None:
            pulumi.set(__self__, "fixed_response_config", fixed_response_config)
        if forward_group_config is not None:
            pulumi.set(__self__, "forward_group_config", forward_group_config)
        if insert_header_config is not None:
            pulumi.set(__self__, "insert_header_config", insert_header_config)
        if redirect_config is not None:
            pulumi.set(__self__, "redirect_config", redirect_config)
        if remove_header_config is not None:
            pulumi.set(__self__, "remove_header_config", remove_header_config)
        if rewrite_config is not None:
            pulumi.set(__self__, "rewrite_config", rewrite_config)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)
        if traffic_mirror_config is not None:
            pulumi.set(__self__, "traffic_mirror_config", traffic_mirror_config)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        """
        The order of the forwarding rule actions. Valid values: `1` to `50000`. The actions are performed in ascending order. You cannot leave this parameter empty. Each value must be unique.
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The action type. Valid values: `ForwardGroup`, `Redirect`, `FixedResponse`, `Rewrite`, `InsertHeader`, `RemoveHeader`, `TrafficLimit`, `TrafficMirror` and `Cors`.
        **Note:** The preceding actions can be classified into two types:  `FinalType`: A forwarding rule can contain only one `FinalType` action, which is executed last. This type of action can contain only one `ForwardGroup`, `Redirect` or `FixedResponse` action. `ExtType`: A forwarding rule can contain one or more `ExtType` actions, which are executed before `FinalType` actions and need to coexist with the `FinalType` actions. This type of action can contain multiple `InsertHeader` actions or one `Rewrite` action.
        **NOTE:** The `TrafficLimit` and `TrafficMirror` option is available since 1.162.0.
        **NOTE:** From version 1.205.0, `type` can be set to `Cors`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="corsConfig")
    def cors_config(self) -> Optional['outputs.RuleRuleActionCorsConfig']:
        """
        Request forwarding based on CORS. See `cors_config` below.
        """
        return pulumi.get(self, "cors_config")

    @_builtins.property
    @pulumi.getter(name="fixedResponseConfig")
    def fixed_response_config(self) -> Optional['outputs.RuleRuleActionFixedResponseConfig']:
        """
        The configuration of the fixed response. See `fixed_response_config` below.
        """
        return pulumi.get(self, "fixed_response_config")

    @_builtins.property
    @pulumi.getter(name="forwardGroupConfig")
    def forward_group_config(self) -> Optional['outputs.RuleRuleActionForwardGroupConfig']:
        """
        The forward response action within ALB. See `forward_group_config` below.
        """
        return pulumi.get(self, "forward_group_config")

    @_builtins.property
    @pulumi.getter(name="insertHeaderConfig")
    def insert_header_config(self) -> Optional['outputs.RuleRuleActionInsertHeaderConfig']:
        """
        The configuration of the inserted header field. See `insert_header_config` below.
        """
        return pulumi.get(self, "insert_header_config")

    @_builtins.property
    @pulumi.getter(name="redirectConfig")
    def redirect_config(self) -> Optional['outputs.RuleRuleActionRedirectConfig']:
        """
        The configuration of the external redirect action. See `redirect_config` below.
        """
        return pulumi.get(self, "redirect_config")

    @_builtins.property
    @pulumi.getter(name="removeHeaderConfig")
    def remove_header_config(self) -> Optional['outputs.RuleRuleActionRemoveHeaderConfig']:
        """
        The configuration of the inserted header field. See `remove_header_config` below.
        """
        return pulumi.get(self, "remove_header_config")

    @_builtins.property
    @pulumi.getter(name="rewriteConfig")
    def rewrite_config(self) -> Optional['outputs.RuleRuleActionRewriteConfig']:
        """
        The redirect action within ALB. See `rewrite_config` below.
        """
        return pulumi.get(self, "rewrite_config")

    @_builtins.property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional['outputs.RuleRuleActionTrafficLimitConfig']:
        """
        The Flow speed limit. See `traffic_limit_config` below.
        """
        return pulumi.get(self, "traffic_limit_config")

    @_builtins.property
    @pulumi.getter(name="trafficMirrorConfig")
    def traffic_mirror_config(self) -> Optional['outputs.RuleRuleActionTrafficMirrorConfig']:
        """
        The Traffic mirroring. See `traffic_mirror_config` below.
        """
        return pulumi.get(self, "traffic_mirror_config")


@pulumi.output_type
class RuleRuleActionCorsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionCorsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionCorsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionCorsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.str] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.str allow_credentials: Specifies whether credentials can be passed during CORS operations. Valid values: `on`, `off`.
        :param Sequence[_builtins.str] allow_headers: The allowed headers for CORS requests.
        :param Sequence[_builtins.str] allow_methods: The allowed HTTP methods for CORS requests. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `PATCH`.
        :param Sequence[_builtins.str] allow_origins: The allowed origins of CORS requests.
        :param Sequence[_builtins.str] expose_headers: The headers that can be exposed.
        :param _builtins.int max_age: The maximum cache time of preflight requests in the browser. Unit: seconds. Valid values: `-1` to `172800`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.str]:
        """
        Specifies whether credentials can be passed during CORS operations. Valid values: `on`, `off`.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed headers for CORS requests.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed HTTP methods for CORS requests. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `PATCH`.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed origins of CORS requests.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The headers that can be exposed.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        The maximum cache time of preflight requests in the browser. Unit: seconds. Valid values: `-1` to `172800`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class RuleRuleActionFixedResponseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "httpCode":
            suggest = "http_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionFixedResponseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionFixedResponseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionFixedResponseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 content_type: Optional[_builtins.str] = None,
                 http_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        :param _builtins.str content_type: The format of the fixed response. Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
        :param _builtins.str http_code: The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        The format of the fixed response. Valid values: `text/plain`, `text/css`, `text/html`, `application/javascript`, and `application/json`.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[_builtins.str]:
        """
        The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        return pulumi.get(self, "http_code")


@pulumi.output_type
class RuleRuleActionForwardGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverGroupStickySession":
            suggest = "server_group_sticky_session"
        elif key == "serverGroupTuples":
            suggest = "server_group_tuples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionForwardGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionForwardGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionForwardGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_group_sticky_session: Optional['outputs.RuleRuleActionForwardGroupConfigServerGroupStickySession'] = None,
                 server_group_tuples: Optional[Sequence['outputs.RuleRuleActionForwardGroupConfigServerGroupTuple']] = None):
        """
        :param 'RuleRuleActionForwardGroupConfigServerGroupStickySessionArgs' server_group_sticky_session: The configuration of session persistence for server groups. See `server_group_sticky_session` below.
        :param Sequence['RuleRuleActionForwardGroupConfigServerGroupTupleArgs'] server_group_tuples: The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        if server_group_sticky_session is not None:
            pulumi.set(__self__, "server_group_sticky_session", server_group_sticky_session)
        if server_group_tuples is not None:
            pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupStickySession")
    def server_group_sticky_session(self) -> Optional['outputs.RuleRuleActionForwardGroupConfigServerGroupStickySession']:
        """
        The configuration of session persistence for server groups. See `server_group_sticky_session` below.
        """
        return pulumi.get(self, "server_group_sticky_session")

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Optional[Sequence['outputs.RuleRuleActionForwardGroupConfigServerGroupTuple']]:
        """
        The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        return pulumi.get(self, "server_group_tuples")


@pulumi.output_type
class RuleRuleActionForwardGroupConfigServerGroupStickySession(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Whether to enable session persistence.
        :param _builtins.int timeout: The timeout period. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable session persistence.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        The timeout period. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RuleRuleActionForwardGroupConfigServerGroupTuple(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverGroupId":
            suggest = "server_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionForwardGroupConfigServerGroupTuple. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionForwardGroupConfigServerGroupTuple.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionForwardGroupConfigServerGroupTuple.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_group_id: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str server_group_id: The ID of the destination server group to which requests are forwarded.
        :param _builtins.int weight: The Weight of server group. Default value: `100`. **NOTE:** This attribute is required when the number of `server_group_tuples` is greater than 2.
        """
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        The Weight of server group. Default value: `100`. **NOTE:** This attribute is required when the number of `server_group_tuples` is greater than 2.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RuleRuleActionInsertHeaderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionInsertHeaderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionInsertHeaderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionInsertHeaderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str value_type: The value type of the inserted header field. Valid values:
               - `UserDefined`: a custom value
               - `ReferenceHeader`: uses a field of the user request header.
               - `SystemDefined`: a system value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        The value type of the inserted header field. Valid values:
        - `UserDefined`: a custom value
        - `ReferenceHeader`: uses a field of the user request header.
        - `SystemDefined`: a system value.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class RuleRuleActionRedirectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpCode":
            suggest = "http_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionRedirectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionRedirectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionRedirectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 http_code: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        :param _builtins.str http_code: The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        :param _builtins.str path: The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        :param _builtins.str port: The port of the destination to which requests are redirected. Valid values: 1 to 63335. Default value: ${port}. You cannot use this value together with other characters at the same time.
        :param _builtins.str protocol: The protocol of the requests to be redirected. Valid values: `HTTP` and `HTTPS`. Default value: `${protocol}`. You cannot use this value together with other characters at the same time. Note HTTPS listeners can redirect only HTTPS requests.
        :param _builtins.str query: The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[_builtins.str]:
        """
        The redirect method. Valid values: `301`, `302`, `303`, `307`, and `308`.
        """
        return pulumi.get(self, "http_code")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        The port of the destination to which requests are redirected. Valid values: 1 to 63335. Default value: ${port}. You cannot use this value together with other characters at the same time.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The protocol of the requests to be redirected. Valid values: `HTTP` and `HTTPS`. Default value: `${protocol}`. You cannot use this value together with other characters at the same time. Note HTTPS listeners can redirect only HTTPS requests.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class RuleRuleActionRemoveHeaderConfig(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class RuleRuleActionRewriteConfig(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        :param _builtins.str path: The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        :param _builtins.str query: The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The host name of the destination to which requests are redirected within ALB. Valid values:  The host name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), periods (.), asterisks (*), and question marks (?). The host name must contain at least one period (.), and cannot start or end with a period (.). The rightmost domain label can contain only letters, asterisks (*) and question marks (?) and cannot contain digits or hyphens (-). Other domain labels cannot start or end with a hyphen (-). You can include asterisks (*) and question marks (?) anywhere in a domain label. Default value: ${host}. You cannot use this value with other characters at the same time.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path to which requests are to be redirected within ALB. Valid values: The path must be 1 to 128 characters in length, and start with a forward slash (/). The path can contain letters, digits, asterisks (*), question marks (?)and the following special characters: $ - _ . + / & ~ @ :. It cannot contain the following special characters: " % # ; ! ( ) [ ] ^ , . The path is case-sensitive. Default value: ${path}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        The query string of the request to be redirected within ALB. The query string must be 1 to 128 characters in length, can contain letters and printable characters. It cannot contain the following special characters: # [ ] { } \\ | < > &. Default value: ${query}. This value can be used only once. You can use it with a valid string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class RuleRuleActionTrafficLimitConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perIpQps":
            suggest = "per_ip_qps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionTrafficLimitConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionTrafficLimitConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionTrafficLimitConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_ip_qps: Optional[_builtins.int] = None,
                 qps: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_ip_qps: The number of requests per second for a single IP address. Value range: 1~1000000. Note: If the QPS parameter is also configured, the value of the PerIpQps parameter must be smaller than the value of the QPS parameter.
        :param _builtins.int qps: The Number of requests per second. Valid values: `1` to `100000`.
        """
        if per_ip_qps is not None:
            pulumi.set(__self__, "per_ip_qps", per_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter(name="perIpQps")
    def per_ip_qps(self) -> Optional[_builtins.int]:
        """
        The number of requests per second for a single IP address. Value range: 1~1000000. Note: If the QPS parameter is also configured, the value of the PerIpQps parameter must be smaller than the value of the QPS parameter.
        """
        return pulumi.get(self, "per_ip_qps")

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[_builtins.int]:
        """
        The Number of requests per second. Valid values: `1` to `100000`.
        """
        return pulumi.get(self, "qps")


@pulumi.output_type
class RuleRuleActionTrafficMirrorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mirrorGroupConfig":
            suggest = "mirror_group_config"
        elif key == "targetType":
            suggest = "target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionTrafficMirrorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionTrafficMirrorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionTrafficMirrorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mirror_group_config: Optional['outputs.RuleRuleActionTrafficMirrorConfigMirrorGroupConfig'] = None,
                 target_type: Optional[_builtins.str] = None):
        """
        :param 'RuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs' mirror_group_config: The Traffic is mirrored to the server group. See `mirror_group_config` below.
        :param _builtins.str target_type: The Mirror target type.
        """
        if mirror_group_config is not None:
            pulumi.set(__self__, "mirror_group_config", mirror_group_config)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @_builtins.property
    @pulumi.getter(name="mirrorGroupConfig")
    def mirror_group_config(self) -> Optional['outputs.RuleRuleActionTrafficMirrorConfigMirrorGroupConfig']:
        """
        The Traffic is mirrored to the server group. See `mirror_group_config` below.
        """
        return pulumi.get(self, "mirror_group_config")

    @_builtins.property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[_builtins.str]:
        """
        The Mirror target type.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class RuleRuleActionTrafficMirrorConfigMirrorGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverGroupTuples":
            suggest = "server_group_tuples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionTrafficMirrorConfigMirrorGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionTrafficMirrorConfigMirrorGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionTrafficMirrorConfigMirrorGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_group_tuples: Optional[Sequence['outputs.RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple']] = None):
        """
        :param Sequence['RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs'] server_group_tuples: The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        if server_group_tuples is not None:
            pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Optional[Sequence['outputs.RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple']]:
        """
        The destination server group to which requests are forwarded. See `server_group_tuples` below.
        """
        return pulumi.get(self, "server_group_tuples")


@pulumi.output_type
class RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverGroupId":
            suggest = "server_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str server_group_id: The ID of the destination server group to which requests are forwarded.
        """
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")


@pulumi.output_type
class RuleRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieConfig":
            suggest = "cookie_config"
        elif key == "headerConfig":
            suggest = "header_config"
        elif key == "hostConfig":
            suggest = "host_config"
        elif key == "methodConfig":
            suggest = "method_config"
        elif key == "pathConfig":
            suggest = "path_config"
        elif key == "queryStringConfig":
            suggest = "query_string_config"
        elif key == "responseHeaderConfig":
            suggest = "response_header_config"
        elif key == "responseStatusCodeConfig":
            suggest = "response_status_code_config"
        elif key == "sourceIpConfig":
            suggest = "source_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 cookie_config: Optional['outputs.RuleRuleConditionCookieConfig'] = None,
                 header_config: Optional['outputs.RuleRuleConditionHeaderConfig'] = None,
                 host_config: Optional['outputs.RuleRuleConditionHostConfig'] = None,
                 method_config: Optional['outputs.RuleRuleConditionMethodConfig'] = None,
                 path_config: Optional['outputs.RuleRuleConditionPathConfig'] = None,
                 query_string_config: Optional['outputs.RuleRuleConditionQueryStringConfig'] = None,
                 response_header_config: Optional['outputs.RuleRuleConditionResponseHeaderConfig'] = None,
                 response_status_code_config: Optional['outputs.RuleRuleConditionResponseStatusCodeConfig'] = None,
                 source_ip_config: Optional['outputs.RuleRuleConditionSourceIpConfig'] = None):
        """
        :param _builtins.str type: The type of the forwarding rule. Valid values:
               - `Host`: Requests are forwarded based on hosts.
               - `Path`: Requests are forwarded based on the path.
               - `Header`: Requests are forwarded based on the HTTP header field.
               - `QueryString`: Requests are forwarded based on the query string.
               - `Method`: Request are forwarded based on the request method.
               - `Cookie`: Requests are forwarded based on the cookie.
               - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
               - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
               - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        :param 'RuleRuleConditionCookieConfigArgs' cookie_config: The configuration of the cookie. See See `cookie_config` below.
        :param 'RuleRuleConditionHeaderConfigArgs' header_config: The configuration of the header field. See `header_config` below.
        :param 'RuleRuleConditionHostConfigArgs' host_config: The configuration of the host field. See `host_config` below.
        :param 'RuleRuleConditionMethodConfigArgs' method_config: The configuration of the request method. See `method_config` below.
        :param 'RuleRuleConditionPathConfigArgs' path_config: The configuration of the path for the request to be forwarded. See `path_config` below.
        :param 'RuleRuleConditionQueryStringConfigArgs' query_string_config: The configuration of the query string. See `query_string_config` below.
        :param 'RuleRuleConditionResponseHeaderConfigArgs' response_header_config: The configuration of the header field. See `response_header_config` below.
        :param 'RuleRuleConditionResponseStatusCodeConfigArgs' response_status_code_config: The configuration of the header field. See `response_status_code_config` below.
        :param 'RuleRuleConditionSourceIpConfigArgs' source_ip_config: The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
        pulumi.set(__self__, "type", type)
        if cookie_config is not None:
            pulumi.set(__self__, "cookie_config", cookie_config)
        if header_config is not None:
            pulumi.set(__self__, "header_config", header_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if method_config is not None:
            pulumi.set(__self__, "method_config", method_config)
        if path_config is not None:
            pulumi.set(__self__, "path_config", path_config)
        if query_string_config is not None:
            pulumi.set(__self__, "query_string_config", query_string_config)
        if response_header_config is not None:
            pulumi.set(__self__, "response_header_config", response_header_config)
        if response_status_code_config is not None:
            pulumi.set(__self__, "response_status_code_config", response_status_code_config)
        if source_ip_config is not None:
            pulumi.set(__self__, "source_ip_config", source_ip_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the forwarding rule. Valid values:
        - `Host`: Requests are forwarded based on hosts.
        - `Path`: Requests are forwarded based on the path.
        - `Header`: Requests are forwarded based on the HTTP header field.
        - `QueryString`: Requests are forwarded based on the query string.
        - `Method`: Request are forwarded based on the request method.
        - `Cookie`: Requests are forwarded based on the cookie.
        - `SourceIp`: Requests are forwarded based on the source ip. **NOTE:** The `SourceIp` option is available since 1.162.0.
        - `ResponseHeader`: Response header. **NOTE:** The `SourceIp` option is available since 1.213.1.
        - `ResponseStatusCode`: Response status code. **NOTE:** The `SourceIp` option is available since 1.213.1.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="cookieConfig")
    def cookie_config(self) -> Optional['outputs.RuleRuleConditionCookieConfig']:
        """
        The configuration of the cookie. See See `cookie_config` below.
        """
        return pulumi.get(self, "cookie_config")

    @_builtins.property
    @pulumi.getter(name="headerConfig")
    def header_config(self) -> Optional['outputs.RuleRuleConditionHeaderConfig']:
        """
        The configuration of the header field. See `header_config` below.
        """
        return pulumi.get(self, "header_config")

    @_builtins.property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional['outputs.RuleRuleConditionHostConfig']:
        """
        The configuration of the host field. See `host_config` below.
        """
        return pulumi.get(self, "host_config")

    @_builtins.property
    @pulumi.getter(name="methodConfig")
    def method_config(self) -> Optional['outputs.RuleRuleConditionMethodConfig']:
        """
        The configuration of the request method. See `method_config` below.
        """
        return pulumi.get(self, "method_config")

    @_builtins.property
    @pulumi.getter(name="pathConfig")
    def path_config(self) -> Optional['outputs.RuleRuleConditionPathConfig']:
        """
        The configuration of the path for the request to be forwarded. See `path_config` below.
        """
        return pulumi.get(self, "path_config")

    @_builtins.property
    @pulumi.getter(name="queryStringConfig")
    def query_string_config(self) -> Optional['outputs.RuleRuleConditionQueryStringConfig']:
        """
        The configuration of the query string. See `query_string_config` below.
        """
        return pulumi.get(self, "query_string_config")

    @_builtins.property
    @pulumi.getter(name="responseHeaderConfig")
    def response_header_config(self) -> Optional['outputs.RuleRuleConditionResponseHeaderConfig']:
        """
        The configuration of the header field. See `response_header_config` below.
        """
        return pulumi.get(self, "response_header_config")

    @_builtins.property
    @pulumi.getter(name="responseStatusCodeConfig")
    def response_status_code_config(self) -> Optional['outputs.RuleRuleConditionResponseStatusCodeConfig']:
        """
        The configuration of the header field. See `response_status_code_config` below.
        """
        return pulumi.get(self, "response_status_code_config")

    @_builtins.property
    @pulumi.getter(name="sourceIpConfig")
    def source_ip_config(self) -> Optional['outputs.RuleRuleConditionSourceIpConfig']:
        """
        The Based on source IP traffic matching. Required and valid when Type is SourceIP. See `source_ip_config` below.
        """
        return pulumi.get(self, "source_ip_config")


@pulumi.output_type
class RuleRuleConditionCookieConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.RuleRuleConditionCookieConfigValue']] = None):
        """
        :param Sequence['RuleRuleConditionCookieConfigValueArgs'] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.RuleRuleConditionCookieConfigValue']]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionCookieConfigValue(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleRuleConditionHeaderConfig(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionHostConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionMethodConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionPathConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionQueryStringConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.RuleRuleConditionQueryStringConfigValue']] = None):
        """
        :param Sequence['RuleRuleConditionQueryStringConfigValueArgs'] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.RuleRuleConditionQueryStringConfigValue']]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionQueryStringConfigValue(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleRuleConditionResponseHeaderConfig(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionResponseStatusCodeConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RuleRuleConditionSourceIpConfig(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add one or more IP addresses or IP address segments. You can add up to 5 forwarding rules in a SourceIp.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ServerGroupConnectionDrainConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionDrainEnabled":
            suggest = "connection_drain_enabled"
        elif key == "connectionDrainTimeout":
            suggest = "connection_drain_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupConnectionDrainConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupConnectionDrainConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupConnectionDrainConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_drain_enabled: Optional[_builtins.bool] = None,
                 connection_drain_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool connection_drain_enabled: Specifies whether to enable connection draining. Valid values:
        :param _builtins.int connection_drain_timeout: The timeout period of connection draining.
               
               Valid values: `0` to `900`.
               
               Default value: `300`.
        """
        if connection_drain_enabled is not None:
            pulumi.set(__self__, "connection_drain_enabled", connection_drain_enabled)
        if connection_drain_timeout is not None:
            pulumi.set(__self__, "connection_drain_timeout", connection_drain_timeout)

    @_builtins.property
    @pulumi.getter(name="connectionDrainEnabled")
    def connection_drain_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable connection draining. Valid values:
        """
        return pulumi.get(self, "connection_drain_enabled")

    @_builtins.property
    @pulumi.getter(name="connectionDrainTimeout")
    def connection_drain_timeout(self) -> Optional[_builtins.int]:
        """
        The timeout period of connection draining.

        Valid values: `0` to `900`.

        Default value: `300`.
        """
        return pulumi.get(self, "connection_drain_timeout")


@pulumi.output_type
class ServerGroupHealthCheckConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckEnabled":
            suggest = "health_check_enabled"
        elif key == "healthCheckCodes":
            suggest = "health_check_codes"
        elif key == "healthCheckConnectPort":
            suggest = "health_check_connect_port"
        elif key == "healthCheckHost":
            suggest = "health_check_host"
        elif key == "healthCheckHttpVersion":
            suggest = "health_check_http_version"
        elif key == "healthCheckInterval":
            suggest = "health_check_interval"
        elif key == "healthCheckMethod":
            suggest = "health_check_method"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "healthCheckProtocol":
            suggest = "health_check_protocol"
        elif key == "healthCheckTimeout":
            suggest = "health_check_timeout"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupHealthCheckConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupHealthCheckConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupHealthCheckConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_enabled: _builtins.bool,
                 health_check_codes: Optional[Sequence[_builtins.str]] = None,
                 health_check_connect_port: Optional[_builtins.int] = None,
                 health_check_host: Optional[_builtins.str] = None,
                 health_check_http_version: Optional[_builtins.str] = None,
                 health_check_interval: Optional[_builtins.int] = None,
                 health_check_method: Optional[_builtins.str] = None,
                 health_check_path: Optional[_builtins.str] = None,
                 health_check_protocol: Optional[_builtins.str] = None,
                 health_check_timeout: Optional[_builtins.int] = None,
                 healthy_threshold: Optional[_builtins.int] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.bool health_check_enabled: Specifies whether to enable the health check feature. Valid values:
        :param Sequence[_builtins.str] health_check_codes: The status code for a successful health check
        :param _builtins.int health_check_connect_port: The backend port that is used for health checks.
               
               Valid values: `0` to `65535`.
               
               If you set the value to `0`, the backend port is used for health checks.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        :param _builtins.str health_check_host: The domain name that is used for health checks.
               
               *   **Backend Server Internal IP** (default): Use the internal IP address of backend servers as the health check domain name.
               
               *   **Custom Domain Name**: Enter a domain name.
               
               *   The domain name must be 1 to 80 characters in length.
               *   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
               *   The domain name must contain at least one period (.) but cannot start or end with a period (.).
               *   The rightmost domain label of the domain name can contain only letters, and cannot contain digits or hyphens (-).
               *   The domain name cannot start or end with a hyphen (-).
               
               > **NOTE:**   This parameter takes effect only if `HealthCheckProtocol` is set to `HTTP`, `HTTPS`, or `gRPC`.
        :param _builtins.str health_check_http_version: The HTTP version that is used for health checks. Valid values:
               
               *   **HTTP1.0**
               
               *   **HTTP1.1**
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        :param _builtins.int health_check_interval: The interval at which health checks are performed. Unit: seconds.
               
               Valid values: `1` to `50`.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        :param _builtins.str health_check_method: The HTTP method that is used for health checks. Valid values:
               
               *   `GET`: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
               
               *   `POST`: gRPC health checks use the POST method by default.
               
               *   `HEAD`: HTTP and HTTPS health checks use the HEAD method by default.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP`, `HTTPS`, or `gRPC`.
        :param _builtins.str health_check_path: The URL that is used for health checks.
               
               The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : ' , +`. The URL must start with a forward slash (`/`).
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true` and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        :param _builtins.str health_check_protocol: The protocol that is used for health checks. Valid values:
               
               - `HTTP`: HTTP health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers.
               - `HTTPS`: HTTPS health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers. HTTPS provides higher security than HTTP because HTTPS supports data encryption.
               - `TCP`: TCP health checks send TCP SYN packets to a backend server to probe the availability of backend servers.
               - `gRPC`: gRPC health checks send POST or GET requests to a backend server to check whether the backend server is healthy.
        :param _builtins.int health_check_timeout: The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.
               
               Valid values: `1` to `300`.
               
               > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        :param _builtins.int healthy_threshold: The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health check status of the backend server changes from `fail` to `success`.
               
               Valid values: `2` to `10`.
               
               Default value: `3`.
        :param _builtins.int unhealthy_threshold: The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health check status of the backend server changes from `success` to `fail`.
               
               Valid values: `2` to `10`.
               
               Default value: `3`.
        """
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if health_check_codes is not None:
            pulumi.set(__self__, "health_check_codes", health_check_codes)
        if health_check_connect_port is not None:
            pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        if health_check_host is not None:
            pulumi.set(__self__, "health_check_host", health_check_host)
        if health_check_http_version is not None:
            pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_method is not None:
            pulumi.set(__self__, "health_check_method", health_check_method)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if health_check_protocol is not None:
            pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        if health_check_timeout is not None:
            pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable the health check feature. Valid values:
        """
        return pulumi.get(self, "health_check_enabled")

    @_builtins.property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The status code for a successful health check
        """
        return pulumi.get(self, "health_check_codes")

    @_builtins.property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> Optional[_builtins.int]:
        """
        The backend port that is used for health checks.

        Valid values: `0` to `65535`.

        If you set the value to `0`, the backend port is used for health checks.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        return pulumi.get(self, "health_check_connect_port")

    @_builtins.property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> Optional[_builtins.str]:
        """
        The domain name that is used for health checks.

        *   **Backend Server Internal IP** (default): Use the internal IP address of backend servers as the health check domain name.

        *   **Custom Domain Name**: Enter a domain name.

        *   The domain name must be 1 to 80 characters in length.
        *   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
        *   The domain name must contain at least one period (.) but cannot start or end with a period (.).
        *   The rightmost domain label of the domain name can contain only letters, and cannot contain digits or hyphens (-).
        *   The domain name cannot start or end with a hyphen (-).

        > **NOTE:**   This parameter takes effect only if `HealthCheckProtocol` is set to `HTTP`, `HTTPS`, or `gRPC`.
        """
        return pulumi.get(self, "health_check_host")

    @_builtins.property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> Optional[_builtins.str]:
        """
        The HTTP version that is used for health checks. Valid values:

        *   **HTTP1.0**

        *   **HTTP1.1**

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "health_check_http_version")

    @_builtins.property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[_builtins.int]:
        """
        The interval at which health checks are performed. Unit: seconds.

        Valid values: `1` to `50`.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        return pulumi.get(self, "health_check_interval")

    @_builtins.property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> Optional[_builtins.str]:
        """
        The HTTP method that is used for health checks. Valid values:

        *   `GET`: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.

        *   `POST`: gRPC health checks use the POST method by default.

        *   `HEAD`: HTTP and HTTPS health checks use the HEAD method by default.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to true and `HealthCheckProtocol` to `HTTP`, `HTTPS`, or `gRPC`.
        """
        return pulumi.get(self, "health_check_method")

    @_builtins.property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[_builtins.str]:
        """
        The URL that is used for health checks.

        The URL must be 1 to 80 characters in length, and can contain letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : ' , +`. The URL must start with a forward slash (`/`).

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true` and `HealthCheckProtocol` to `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "health_check_path")

    @_builtins.property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> Optional[_builtins.str]:
        """
        The protocol that is used for health checks. Valid values:

        - `HTTP`: HTTP health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers.
        - `HTTPS`: HTTPS health checks simulate browser behaviors by sending HEAD or GET requests to probe the availability of backend servers. HTTPS provides higher security than HTTP because HTTPS supports data encryption.
        - `TCP`: TCP health checks send TCP SYN packets to a backend server to probe the availability of backend servers.
        - `gRPC`: gRPC health checks send POST or GET requests to a backend server to check whether the backend server is healthy.
        """
        return pulumi.get(self, "health_check_protocol")

    @_builtins.property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[_builtins.int]:
        """
        The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.

        Valid values: `1` to `300`.

        > **NOTE:**   This parameter takes effect only if you set `HealthCheckEnabled` to `true`.
        """
        return pulumi.get(self, "health_check_timeout")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health check status of the backend server changes from `fail` to `success`.

        Valid values: `2` to `10`.

        Default value: `3`.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health check status of the backend server changes from `success` to `fail`.

        Valid values: `2` to `10`.

        Default value: `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class ServerGroupServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverId":
            suggest = "server_id"
        elif key == "serverType":
            suggest = "server_type"
        elif key == "remoteIpEnabled":
            suggest = "remote_ip_enabled"
        elif key == "serverGroupId":
            suggest = "server_group_id"
        elif key == "serverIp":
            suggest = "server_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_id: _builtins.str,
                 server_type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 remote_ip_enabled: Optional[_builtins.bool] = None,
                 server_group_id: Optional[_builtins.str] = None,
                 server_ip: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str server_id: The ID of the backend server. You can specify at most 200 servers in each call.
               
               *   If the server group is of the `Instance` type, set ServerId to the ID of a resource of the `Ecs`, `Eni`, or `Eci` type.
               
               *   If the server group is of the `Ip` type, set ServerId to IP addresses.
               
               > **NOTE:**   You cannot perform this operation on a server group of the Function Compute type. You can call the [ListServerGroups](https://www.alibabacloud.com/help/en/doc-detail/213627.html) operation to query the type of server groups.
        :param _builtins.str server_type: The type of the backend server. You can specify at most 200 servers in each call. Default values:
               
               - `Ecs`: Elastic Compute Service (ECS) instance
               - `Eni`: elastic network interface (ENI)
               - `Eci`: elastic container instance
               - `Ip`: IP address
               - `Fc`: Function Compute
        :param _builtins.str description: The description of the backend server. The description must be 2 to 256 characters in length, and cannot start with http:// or https://.
        :param _builtins.int port: The port that is used by the backend server. Valid values: `1` to `65535`. You can specify at most 200 servers in each call.
               
               > **NOTE:**   This parameter is required if you set `ServerType` to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to set this parameter if `ServerType` is set to `Fc`.
        :param _builtins.bool remote_ip_enabled: Specifies whether to enable the remote IP feature. You can specify at most 200 servers in each call. Default values:
        :param _builtins.str server_group_id: The ID of the server group.
        :param _builtins.str server_ip: The IP address of the backend server. You can specify at most 200 servers in each call.
               
               > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        :param _builtins.str status: The status of the resource
        :param _builtins.int weight: The weight of the backend server. Valid values: `0` to `100`. Default value: `0`. If the value is set to `0`, no requests are forwarded to the server. You can specify at most 200 servers in each call.
               
               > **NOTE:**   Default value: `0`. We strongly recommend specifying this parameter.
               > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_type", server_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if remote_ip_enabled is not None:
            pulumi.set(__self__, "remote_ip_enabled", remote_ip_enabled)
        if server_group_id is not None:
            pulumi.set(__self__, "server_group_id", server_group_id)
        if server_ip is not None:
            pulumi.set(__self__, "server_ip", server_ip)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> _builtins.str:
        """
        The ID of the backend server. You can specify at most 200 servers in each call.

        *   If the server group is of the `Instance` type, set ServerId to the ID of a resource of the `Ecs`, `Eni`, or `Eci` type.

        *   If the server group is of the `Ip` type, set ServerId to IP addresses.

        > **NOTE:**   You cannot perform this operation on a server group of the Function Compute type. You can call the [ListServerGroups](https://www.alibabacloud.com/help/en/doc-detail/213627.html) operation to query the type of server groups.
        """
        return pulumi.get(self, "server_id")

    @_builtins.property
    @pulumi.getter(name="serverType")
    def server_type(self) -> _builtins.str:
        """
        The type of the backend server. You can specify at most 200 servers in each call. Default values:

        - `Ecs`: Elastic Compute Service (ECS) instance
        - `Eni`: elastic network interface (ENI)
        - `Eci`: elastic container instance
        - `Ip`: IP address
        - `Fc`: Function Compute
        """
        return pulumi.get(self, "server_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the backend server. The description must be 2 to 256 characters in length, and cannot start with http:// or https://.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port that is used by the backend server. Valid values: `1` to `65535`. You can specify at most 200 servers in each call.

        > **NOTE:**   This parameter is required if you set `ServerType` to `Ecs`, `Eni`, `Eci`, or `Ip`. You do not need to set this parameter if `ServerType` is set to `Fc`.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="remoteIpEnabled")
    def remote_ip_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable the remote IP feature. You can specify at most 200 servers in each call. Default values:
        """
        return pulumi.get(self, "remote_ip_enabled")

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the server group.
        """
        return pulumi.get(self, "server_group_id")

    @_builtins.property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> Optional[_builtins.str]:
        """
        The IP address of the backend server. You can specify at most 200 servers in each call.

        > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        return pulumi.get(self, "server_ip")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the resource
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        The weight of the backend server. Valid values: `0` to `100`. Default value: `0`. If the value is set to `0`, no requests are forwarded to the server. You can specify at most 200 servers in each call.

        > **NOTE:**   Default value: `0`. We strongly recommend specifying this parameter.
        > **NOTE:**   You do not need to set this parameter if you set `ServerType` to `Fc`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class ServerGroupSlowStartConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowStartDuration":
            suggest = "slow_start_duration"
        elif key == "slowStartEnabled":
            suggest = "slow_start_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupSlowStartConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupSlowStartConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupSlowStartConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slow_start_duration: Optional[_builtins.int] = None,
                 slow_start_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int slow_start_duration: The duration of a slow start.
               
               Valid values: 30 to 900.
               
               Default value: 30.
        :param _builtins.bool slow_start_enabled: Indicates whether slow starts are enabled. Valid values:
        """
        if slow_start_duration is not None:
            pulumi.set(__self__, "slow_start_duration", slow_start_duration)
        if slow_start_enabled is not None:
            pulumi.set(__self__, "slow_start_enabled", slow_start_enabled)

    @_builtins.property
    @pulumi.getter(name="slowStartDuration")
    def slow_start_duration(self) -> Optional[_builtins.int]:
        """
        The duration of a slow start.

        Valid values: 30 to 900.

        Default value: 30.
        """
        return pulumi.get(self, "slow_start_duration")

    @_builtins.property
    @pulumi.getter(name="slowStartEnabled")
    def slow_start_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether slow starts are enabled. Valid values:
        """
        return pulumi.get(self, "slow_start_enabled")


@pulumi.output_type
class ServerGroupStickySessionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieTimeout":
            suggest = "cookie_timeout"
        elif key == "stickySessionEnabled":
            suggest = "sticky_session_enabled"
        elif key == "stickySessionType":
            suggest = "sticky_session_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupStickySessionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupStickySessionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupStickySessionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional[_builtins.str] = None,
                 cookie_timeout: Optional[_builtins.int] = None,
                 sticky_session_enabled: Optional[_builtins.bool] = None,
                 sticky_session_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cookie: The cookie to be configured on the server.
               
               The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).
               
               > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` and the `StickySessionType` parameter is set to `Server`.
        :param _builtins.int cookie_timeout: The maximum amount of time to wait before the session cookie expires. Unit: seconds.
               
               Valid values: `1` to `86400`.
               
               Default value: `1000`.
               
               > **NOTE:**   This parameter takes effect only when `StickySessionEnabled` is set to `true` and `StickySessionType` is set to `Insert`.
        :param _builtins.bool sticky_session_enabled: Specifies whether to enable session persistence. Valid values:
        :param _builtins.str sticky_session_type: The method that is used to handle a cookie. Valid values:
               
               *   `Insert`: inserts a cookie.
               
               ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.
               
               *   `Server`: rewrites a cookie.
               
               When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.
               
               > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` for the server group.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if cookie_timeout is not None:
            pulumi.set(__self__, "cookie_timeout", cookie_timeout)
        if sticky_session_enabled is not None:
            pulumi.set(__self__, "sticky_session_enabled", sticky_session_enabled)
        if sticky_session_type is not None:
            pulumi.set(__self__, "sticky_session_type", sticky_session_type)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[_builtins.str]:
        """
        The cookie to be configured on the server.

        The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).

        > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` and the `StickySessionType` parameter is set to `Server`.
        """
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> Optional[_builtins.int]:
        """
        The maximum amount of time to wait before the session cookie expires. Unit: seconds.

        Valid values: `1` to `86400`.

        Default value: `1000`.

        > **NOTE:**   This parameter takes effect only when `StickySessionEnabled` is set to `true` and `StickySessionType` is set to `Insert`.
        """
        return pulumi.get(self, "cookie_timeout")

    @_builtins.property
    @pulumi.getter(name="stickySessionEnabled")
    def sticky_session_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable session persistence. Valid values:
        """
        return pulumi.get(self, "sticky_session_enabled")

    @_builtins.property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> Optional[_builtins.str]:
        """
        The method that is used to handle a cookie. Valid values:

        *   `Insert`: inserts a cookie.

        ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.

        *   `Server`: rewrites a cookie.

        When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.

        > **NOTE:**  This parameter takes effect when the `StickySessionEnabled` parameter is set to `true` for the server group.
        """
        return pulumi.get(self, "sticky_session_type")


@pulumi.output_type
class ServerGroupUchConfig(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The parameter type. Only QueryString can be filled.
        :param _builtins.str value: Consistency hash parameter value
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The parameter type. Only QueryString can be filled.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Consistency hash parameter value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAclsAclResult(dict):
    def __init__(__self__, *,
                 acl_entries: Sequence['outputs.GetAclsAclAclEntryResult'],
                 acl_id: _builtins.str,
                 acl_name: _builtins.str,
                 address_ip_version: _builtins.str,
                 id: _builtins.str,
                 resource_group_id: _builtins.str,
                 status: _builtins.str):
        """
        :param Sequence['GetAclsAclAclEntryArgs'] acl_entries: ACL Entries.
        :param _builtins.str acl_id: Access Control Policy ID.
        :param _builtins.str acl_name: The ACL Name.
        :param _builtins.str address_ip_version: Address Protocol Version.
        :param _builtins.str id: The ID of the Acl.
        :param _builtins.str resource_group_id: Resource Group to Which the Number.
        :param _builtins.str status: The state of the ACL. Valid values:`Provisioning` , `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
        """
        pulumi.set(__self__, "acl_entries", acl_entries)
        pulumi.set(__self__, "acl_id", acl_id)
        pulumi.set(__self__, "acl_name", acl_name)
        pulumi.set(__self__, "address_ip_version", address_ip_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="aclEntries")
    def acl_entries(self) -> Sequence['outputs.GetAclsAclAclEntryResult']:
        """
        ACL Entries.
        """
        return pulumi.get(self, "acl_entries")

    @_builtins.property
    @pulumi.getter(name="aclId")
    def acl_id(self) -> _builtins.str:
        """
        Access Control Policy ID.
        """
        return pulumi.get(self, "acl_id")

    @_builtins.property
    @pulumi.getter(name="aclName")
    def acl_name(self) -> _builtins.str:
        """
        The ACL Name.
        """
        return pulumi.get(self, "acl_name")

    @_builtins.property
    @pulumi.getter(name="addressIpVersion")
    def address_ip_version(self) -> _builtins.str:
        """
        Address Protocol Version.
        """
        return pulumi.get(self, "address_ip_version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Acl.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> _builtins.str:
        """
        Resource Group to Which the Number.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The state of the ACL. Valid values:`Provisioning` , `Available` and `Configuring`. `Provisioning`: The ACL is being created. `Available`: The ACL is available. `Configuring`: The ACL is being configured.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAclsAclAclEntryResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 entry: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str description: Access Control Entries Note Description Length Is Limited to 1 to 256 Characters, Letters, digital, the Dash (-), a Forward Slash (/), Half a Period (.) and Underscores (_), Support Chinese Characters.
        :param _builtins.str status: The status of the ACL entry. Valid values: `Adding` , `Available` and `Removing`. `Adding`: The entry is being added. `Available`: The entry is added and available. `Removing`: The entry is being removed.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "entry", entry)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Access Control Entries Note Description Length Is Limited to 1 to 256 Characters, Letters, digital, the Dash (-), a Forward Slash (/), Half a Period (.) and Underscores (_), Support Chinese Characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def entry(self) -> _builtins.str:
        return pulumi.get(self, "entry")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the ACL entry. Valid values: `Adding` , `Available` and `Removing`. `Adding`: The entry is being added. `Available`: The entry is added and available. `Removing`: The entry is being removed.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAscriptsAscriptResult(dict):
    def __init__(__self__, *,
                 ascript_id: _builtins.str,
                 ascript_name: _builtins.str,
                 enabled: _builtins.bool,
                 ext_attribute_enabled: _builtins.bool,
                 ext_attributes: Sequence['outputs.GetAscriptsAscriptExtAttributeResult'],
                 id: _builtins.str,
                 listener_id: _builtins.str,
                 load_balancer_id: _builtins.str,
                 position: _builtins.str,
                 script_content: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str ascript_id: Script identification.
        :param _builtins.str ascript_name: Script name.
        :param _builtins.bool enabled: Whether scripts are enabled.
        :param _builtins.bool ext_attribute_enabled: Whether extension parameters are enabled.
        :param Sequence['GetAscriptsAscriptExtAttributeArgs'] ext_attributes: Extended attribute list.
        :param _builtins.str listener_id: Listener ID of script attribution
        :param _builtins.str position: Script execution location.
        :param _builtins.str script_content: Script content.
        :param _builtins.str status: Script status.
        """
        pulumi.set(__self__, "ascript_id", ascript_id)
        pulumi.set(__self__, "ascript_name", ascript_name)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ext_attribute_enabled", ext_attribute_enabled)
        pulumi.set(__self__, "ext_attributes", ext_attributes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "script_content", script_content)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="ascriptId")
    def ascript_id(self) -> _builtins.str:
        """
        Script identification.
        """
        return pulumi.get(self, "ascript_id")

    @_builtins.property
    @pulumi.getter(name="ascriptName")
    def ascript_name(self) -> _builtins.str:
        """
        Script name.
        """
        return pulumi.get(self, "ascript_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether scripts are enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="extAttributeEnabled")
    def ext_attribute_enabled(self) -> _builtins.bool:
        """
        Whether extension parameters are enabled.
        """
        return pulumi.get(self, "ext_attribute_enabled")

    @_builtins.property
    @pulumi.getter(name="extAttributes")
    def ext_attributes(self) -> Sequence['outputs.GetAscriptsAscriptExtAttributeResult']:
        """
        Extended attribute list.
        """
        return pulumi.get(self, "ext_attributes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        Listener ID of script attribution
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> _builtins.str:
        return pulumi.get(self, "load_balancer_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        """
        Script execution location.
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="scriptContent")
    def script_content(self) -> _builtins.str:
        """
        Script content.
        """
        return pulumi.get(self, "script_content")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Script status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAscriptsAscriptExtAttributeResult(dict):
    def __init__(__self__, *,
                 attribute_key: _builtins.str,
                 attribute_value: _builtins.str):
        """
        :param _builtins.str attribute_key: The key of the extended attribute.
        :param _builtins.str attribute_value: The value of the extended attribute.
        """
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "attribute_value", attribute_value)

    @_builtins.property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> _builtins.str:
        """
        The key of the extended attribute.
        """
        return pulumi.get(self, "attribute_key")

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> _builtins.str:
        """
        The value of the extended attribute.
        """
        return pulumi.get(self, "attribute_value")


@pulumi.output_type
class GetHealthCheckTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 health_check_codes: Sequence[_builtins.str],
                 health_check_connect_port: _builtins.int,
                 health_check_host: _builtins.str,
                 health_check_http_version: _builtins.str,
                 health_check_interval: _builtins.int,
                 health_check_method: _builtins.str,
                 health_check_path: _builtins.str,
                 health_check_protocol: _builtins.str,
                 health_check_template_id: _builtins.str,
                 health_check_template_name: _builtins.str,
                 health_check_timeout: _builtins.int,
                 healthy_threshold: _builtins.int,
                 id: _builtins.str,
                 unhealthy_threshold: _builtins.int):
        """
        :param Sequence[_builtins.str] health_check_codes: The HTTP status code that indicates a successful health check.
        :param _builtins.int health_check_connect_port: The number of the port that is used for health checks.  Valid values: `0` to `65535`.  Default value:` 0`. This default value indicates that the backend server is used for health checks.
        :param _builtins.str health_check_host: The domain name that is used for health checks. Default value:  `$SERVER_IP`. The domain name must be 1 to 80 characters in length.
        :param _builtins.str health_check_http_version: The version of the HTTP protocol.  Valid values: `HTTP1.0` and `HTTP1.1`.  Default value: `HTTP1.1`.
        :param _builtins.int health_check_interval: The time interval between two consecutive health checks.  Valid values: `1` to `50`. Unit: seconds.  Default value: `2`.
        :param _builtins.str health_check_method: The health check method.  Valid values: `GET` and `HEAD`.  Default value: `HEAD`.
        :param _builtins.str health_check_path: The URL that is used for health checks.  The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: ` _ ; ~ ! ( )* [ ] @ $ ^ : ' , +. The URL must start with a forward slash (/)`.
        :param _builtins.str health_check_protocol: The protocol that is used for health checks.  Valid values: HTTP and TCP.  Default value: HTTP.
        :param _builtins.str health_check_template_id: The ID of the resource.
        :param _builtins.str health_check_template_name: The name of the health check template.  The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.
        :param _builtins.int health_check_timeout: The timeout period of a health check response. If the backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the health check fails.  Valid values: `1` to `300`. Unit: seconds.  Default value: `5`.
        :param _builtins.int healthy_threshold: The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy (from fail to success). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
        :param _builtins.str id: The ID of the Health Check Template.
        :param _builtins.int unhealthy_threshold: The number of times that an healthy backend server must consecutively fail health checks before it is declared unhealthy (from success to fail). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
        """
        pulumi.set(__self__, "health_check_codes", health_check_codes)
        pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        pulumi.set(__self__, "health_check_host", health_check_host)
        pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        pulumi.set(__self__, "health_check_interval", health_check_interval)
        pulumi.set(__self__, "health_check_method", health_check_method)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        pulumi.set(__self__, "health_check_template_id", health_check_template_id)
        pulumi.set(__self__, "health_check_template_name", health_check_template_name)
        pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Sequence[_builtins.str]:
        """
        The HTTP status code that indicates a successful health check.
        """
        return pulumi.get(self, "health_check_codes")

    @_builtins.property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> _builtins.int:
        """
        The number of the port that is used for health checks.  Valid values: `0` to `65535`.  Default value:` 0`. This default value indicates that the backend server is used for health checks.
        """
        return pulumi.get(self, "health_check_connect_port")

    @_builtins.property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> _builtins.str:
        """
        The domain name that is used for health checks. Default value:  `$SERVER_IP`. The domain name must be 1 to 80 characters in length.
        """
        return pulumi.get(self, "health_check_host")

    @_builtins.property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> _builtins.str:
        """
        The version of the HTTP protocol.  Valid values: `HTTP1.0` and `HTTP1.1`.  Default value: `HTTP1.1`.
        """
        return pulumi.get(self, "health_check_http_version")

    @_builtins.property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> _builtins.int:
        """
        The time interval between two consecutive health checks.  Valid values: `1` to `50`. Unit: seconds.  Default value: `2`.
        """
        return pulumi.get(self, "health_check_interval")

    @_builtins.property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> _builtins.str:
        """
        The health check method.  Valid values: `GET` and `HEAD`.  Default value: `HEAD`.
        """
        return pulumi.get(self, "health_check_method")

    @_builtins.property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> _builtins.str:
        """
        The URL that is used for health checks.  The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: ` _ ; ~ ! ( )* [ ] @ $ ^ : ' , +. The URL must start with a forward slash (/)`.
        """
        return pulumi.get(self, "health_check_path")

    @_builtins.property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> _builtins.str:
        """
        The protocol that is used for health checks.  Valid values: HTTP and TCP.  Default value: HTTP.
        """
        return pulumi.get(self, "health_check_protocol")

    @_builtins.property
    @pulumi.getter(name="healthCheckTemplateId")
    def health_check_template_id(self) -> _builtins.str:
        """
        The ID of the resource.
        """
        return pulumi.get(self, "health_check_template_id")

    @_builtins.property
    @pulumi.getter(name="healthCheckTemplateName")
    def health_check_template_name(self) -> _builtins.str:
        """
        The name of the health check template.  The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (_), and hyphens (-). The name must start with a letter.
        """
        return pulumi.get(self, "health_check_template_name")

    @_builtins.property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> _builtins.int:
        """
        The timeout period of a health check response. If the backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the health check fails.  Valid values: `1` to `300`. Unit: seconds.  Default value: `5`.
        """
        return pulumi.get(self, "health_check_timeout")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy (from fail to success). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Health Check Template.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        The number of times that an healthy backend server must consecutively fail health checks before it is declared unhealthy (from success to fail). Valid values: `2` to `10`.  Default value: `3`. Unit: seconds.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetListenersListenerResult(dict):
    def __init__(__self__, *,
                 access_log_record_customized_headers_enabled: _builtins.bool,
                 access_log_tracing_configs: Sequence['outputs.GetListenersListenerAccessLogTracingConfigResult'],
                 acl_configs: Sequence['outputs.GetListenersListenerAclConfigResult'],
                 certificates: Sequence['outputs.GetListenersListenerCertificateResult'],
                 default_actions: Sequence['outputs.GetListenersListenerDefaultActionResult'],
                 gzip_enabled: _builtins.bool,
                 http2_enabled: _builtins.bool,
                 id: _builtins.str,
                 idle_timeout: _builtins.int,
                 listener_description: _builtins.str,
                 listener_id: _builtins.str,
                 listener_port: _builtins.int,
                 listener_protocol: _builtins.str,
                 load_balancer_id: _builtins.str,
                 max_results: _builtins.str,
                 next_token: _builtins.str,
                 quic_configs: Sequence['outputs.GetListenersListenerQuicConfigResult'],
                 request_timeout: _builtins.int,
                 security_policy_id: _builtins.str,
                 status: _builtins.str,
                 xforwarded_for_configs: Sequence['outputs.GetListenersListenerXforwardedForConfigResult']):
        """
        :param _builtins.bool access_log_record_customized_headers_enabled: Indicates whether the access log has a custom header field. Valid values: true and false. Default value: false.
               
               > **NOTE:** Only Instances outside the Security Group to Access the Log Switch **accesslogenabled** Open, in Order to Set This Parameter to the **True**.
        :param Sequence['GetListenersListenerAccessLogTracingConfigArgs'] access_log_tracing_configs: Xtrace Configuration Information.
        :param Sequence['GetListenersListenerAclConfigArgs'] acl_configs: The configurations of the access control lists (ACLs).
        :param Sequence['GetListenersListenerCertificateArgs'] certificates: The Certificate List.
        :param Sequence['GetListenersListenerDefaultActionArgs'] default_actions: The Default Rule Action List.
        :param _builtins.bool gzip_enabled: Whether to Enable Gzip Compression, as a Specific File Type on a Compression. Valid Values: `True` Or `False`. Default Value: `True`.
        :param _builtins.bool http2_enabled: Whether to Enable HTTP/2 Features. Valid Values: `True` Or `False`. Default Value: `True`.
               
               > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
        :param _builtins.str id: The ID of the Listener.
        :param _builtins.int idle_timeout: Specify the Connection Idle Timeout Value: `1` to `60`. Unit: Seconds.
        :param _builtins.str listener_description: Set the IP Address of the Listened Description. Length Is from 2 to 256 Characters.
        :param _builtins.str listener_id: on Behalf of the Resource Level Id of the Resources Property Fields.
        :param _builtins.int listener_port: The ALB Instance Front-End, and Those of the Ports Used. Value: `1~65535`.
        :param _builtins.str listener_protocol: Snooping Protocols. Valid Values: `HTTP`, `HTTPS` Or `QUIC`.
        :param _builtins.str load_balancer_id: The ALB Instance Id.
        :param _builtins.str max_results: This Request Returned by the Maximum Number of Records.
        :param _builtins.str next_token: The Current Call Returns to the Position of the Set to Null Represents the Data Has Been Read to the End of.
        :param Sequence['GetListenersListenerQuicConfigArgs'] quic_configs: Configuration Associated with the QuIC Listening.
        :param _builtins.int request_timeout: The Specified Request Timeout Time. Value: `1` to `180`. Unit: Seconds. Default Value: 60. If the Timeout Time Within the Back-End Server Has Not Answered the ALB Will Give up Waiting, the Client Returns the HTTP 504 Error Code.
        :param _builtins.str security_policy_id: Security Policy.
               
               > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
        :param _builtins.str status: The state of the listener. Valid Values: `Running` Or `Stopped`. `Running`: The listener is running. `Stopped`: The listener is stopped.
        :param Sequence['GetListenersListenerXforwardedForConfigArgs'] xforwarded_for_configs: xforwardfor Related Attribute Configuration.
        """
        pulumi.set(__self__, "access_log_record_customized_headers_enabled", access_log_record_customized_headers_enabled)
        pulumi.set(__self__, "access_log_tracing_configs", access_log_tracing_configs)
        pulumi.set(__self__, "acl_configs", acl_configs)
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "default_actions", default_actions)
        pulumi.set(__self__, "gzip_enabled", gzip_enabled)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "listener_description", listener_description)
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "listener_port", listener_port)
        pulumi.set(__self__, "listener_protocol", listener_protocol)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "max_results", max_results)
        pulumi.set(__self__, "next_token", next_token)
        pulumi.set(__self__, "quic_configs", quic_configs)
        pulumi.set(__self__, "request_timeout", request_timeout)
        pulumi.set(__self__, "security_policy_id", security_policy_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "xforwarded_for_configs", xforwarded_for_configs)

    @_builtins.property
    @pulumi.getter(name="accessLogRecordCustomizedHeadersEnabled")
    def access_log_record_customized_headers_enabled(self) -> _builtins.bool:
        """
        Indicates whether the access log has a custom header field. Valid values: true and false. Default value: false.

        > **NOTE:** Only Instances outside the Security Group to Access the Log Switch **accesslogenabled** Open, in Order to Set This Parameter to the **True**.
        """
        return pulumi.get(self, "access_log_record_customized_headers_enabled")

    @_builtins.property
    @pulumi.getter(name="accessLogTracingConfigs")
    def access_log_tracing_configs(self) -> Sequence['outputs.GetListenersListenerAccessLogTracingConfigResult']:
        """
        Xtrace Configuration Information.
        """
        return pulumi.get(self, "access_log_tracing_configs")

    @_builtins.property
    @pulumi.getter(name="aclConfigs")
    def acl_configs(self) -> Sequence['outputs.GetListenersListenerAclConfigResult']:
        """
        The configurations of the access control lists (ACLs).
        """
        return pulumi.get(self, "acl_configs")

    @_builtins.property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetListenersListenerCertificateResult']:
        """
        The Certificate List.
        """
        return pulumi.get(self, "certificates")

    @_builtins.property
    @pulumi.getter(name="defaultActions")
    def default_actions(self) -> Sequence['outputs.GetListenersListenerDefaultActionResult']:
        """
        The Default Rule Action List.
        """
        return pulumi.get(self, "default_actions")

    @_builtins.property
    @pulumi.getter(name="gzipEnabled")
    def gzip_enabled(self) -> _builtins.bool:
        """
        Whether to Enable Gzip Compression, as a Specific File Type on a Compression. Valid Values: `True` Or `False`. Default Value: `True`.
        """
        return pulumi.get(self, "gzip_enabled")

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> _builtins.bool:
        """
        Whether to Enable HTTP/2 Features. Valid Values: `True` Or `False`. Default Value: `True`.

        > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
        """
        return pulumi.get(self, "http2_enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Listener.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.int:
        """
        Specify the Connection Idle Timeout Value: `1` to `60`. Unit: Seconds.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="listenerDescription")
    def listener_description(self) -> _builtins.str:
        """
        Set the IP Address of the Listened Description. Length Is from 2 to 256 Characters.
        """
        return pulumi.get(self, "listener_description")

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        on Behalf of the Resource Level Id of the Resources Property Fields.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> _builtins.int:
        """
        The ALB Instance Front-End, and Those of the Ports Used. Value: `1~65535`.
        """
        return pulumi.get(self, "listener_port")

    @_builtins.property
    @pulumi.getter(name="listenerProtocol")
    def listener_protocol(self) -> _builtins.str:
        """
        Snooping Protocols. Valid Values: `HTTP`, `HTTPS` Or `QUIC`.
        """
        return pulumi.get(self, "listener_protocol")

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> _builtins.str:
        """
        The ALB Instance Id.
        """
        return pulumi.get(self, "load_balancer_id")

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> _builtins.str:
        """
        This Request Returned by the Maximum Number of Records.
        """
        return pulumi.get(self, "max_results")

    @_builtins.property
    @pulumi.getter(name="nextToken")
    def next_token(self) -> _builtins.str:
        """
        The Current Call Returns to the Position of the Set to Null Represents the Data Has Been Read to the End of.
        """
        return pulumi.get(self, "next_token")

    @_builtins.property
    @pulumi.getter(name="quicConfigs")
    def quic_configs(self) -> Sequence['outputs.GetListenersListenerQuicConfigResult']:
        """
        Configuration Associated with the QuIC Listening.
        """
        return pulumi.get(self, "quic_configs")

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> _builtins.int:
        """
        The Specified Request Timeout Time. Value: `1` to `180`. Unit: Seconds. Default Value: 60. If the Timeout Time Within the Back-End Server Has Not Answered the ALB Will Give up Waiting, the Client Returns the HTTP 504 Error Code.
        """
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="securityPolicyId")
    def security_policy_id(self) -> _builtins.str:
        """
        Security Policy.

        > **NOTE:** The attribute is valid when the attribute `ListenerProtocol` is `HTTPS`.
        """
        return pulumi.get(self, "security_policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The state of the listener. Valid Values: `Running` Or `Stopped`. `Running`: The listener is running. `Stopped`: The listener is stopped.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="xforwardedForConfigs")
    def xforwarded_for_configs(self) -> Sequence['outputs.GetListenersListenerXforwardedForConfigResult']:
        """
        xforwardfor Related Attribute Configuration.
        """
        return pulumi.get(self, "xforwarded_for_configs")


@pulumi.output_type
class GetListenersListenerAccessLogTracingConfigResult(dict):
    def __init__(__self__, *,
                 tracing_enabled: _builtins.bool,
                 tracing_sample: _builtins.int,
                 tracing_type: _builtins.str):
        """
        :param _builtins.bool tracing_enabled: Xtrace Function. Value: True Or False. Default Value: False.
               
               > **NOTE:** Only Instances outside the Security Group to Access the Log Switch **accesslogenabled** Open, in Order to Set This Parameter to the **True**.
        :param _builtins.int tracing_sample: Xtrace Sampling Rate. Value: **1~10000**.
               
               > **NOTE:** This attribute is valid when **tracingenabled** is **true**.
        :param _builtins.str tracing_type: Xtrace Type Value Is **Zipkin**.
               
               > **NOTE:** This attribute is valid when **tracingenabled** is **true**.
        """
        pulumi.set(__self__, "tracing_enabled", tracing_enabled)
        pulumi.set(__self__, "tracing_sample", tracing_sample)
        pulumi.set(__self__, "tracing_type", tracing_type)

    @_builtins.property
    @pulumi.getter(name="tracingEnabled")
    def tracing_enabled(self) -> _builtins.bool:
        """
        Xtrace Function. Value: True Or False. Default Value: False.

        > **NOTE:** Only Instances outside the Security Group to Access the Log Switch **accesslogenabled** Open, in Order to Set This Parameter to the **True**.
        """
        return pulumi.get(self, "tracing_enabled")

    @_builtins.property
    @pulumi.getter(name="tracingSample")
    def tracing_sample(self) -> _builtins.int:
        """
        Xtrace Sampling Rate. Value: **1~10000**.

        > **NOTE:** This attribute is valid when **tracingenabled** is **true**.
        """
        return pulumi.get(self, "tracing_sample")

    @_builtins.property
    @pulumi.getter(name="tracingType")
    def tracing_type(self) -> _builtins.str:
        """
        Xtrace Type Value Is **Zipkin**.

        > **NOTE:** This attribute is valid when **tracingenabled** is **true**.
        """
        return pulumi.get(self, "tracing_type")


@pulumi.output_type
class GetListenersListenerAclConfigResult(dict):
    def __init__(__self__, *,
                 acl_relations: Sequence['outputs.GetListenersListenerAclConfigAclRelationResult'],
                 acl_type: _builtins.str):
        """
        :param Sequence['GetListenersListenerAclConfigAclRelationArgs'] acl_relations: The ACLs that are associated with the listener.
        :param _builtins.str acl_type: The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        pulumi.set(__self__, "acl_relations", acl_relations)
        pulumi.set(__self__, "acl_type", acl_type)

    @_builtins.property
    @pulumi.getter(name="aclRelations")
    def acl_relations(self) -> Sequence['outputs.GetListenersListenerAclConfigAclRelationResult']:
        """
        The ACLs that are associated with the listener.
        """
        return pulumi.get(self, "acl_relations")

    @_builtins.property
    @pulumi.getter(name="aclType")
    def acl_type(self) -> _builtins.str:
        """
        The type of the ACL. Valid values: `White` Or `Black`. `White`: specifies the ACL as a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios where only specific IP addresses are allowed to access an application. Risks may occur if the whitelist is improperly set. After you set a whitelist for an Application Load Balancer (ALB) listener, only requests from IP addresses that are added to the whitelist are distributed by the listener. If the whitelist is enabled without IP addresses specified, the ALB listener does not forward requests. `Black`: All requests from the IP addresses or CIDR blocks in the ACL are denied. The blacklist is used to prevent specified IP addresses from accessing an application. If the blacklist is enabled but the corresponding ACL does not contain IP addresses, the ALB listener forwards all requests.
        """
        return pulumi.get(self, "acl_type")


@pulumi.output_type
class GetListenersListenerAclConfigAclRelationResult(dict):
    def __init__(__self__, *,
                 acl_id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str acl_id: Snooping Binding of the Access Policy Group ID List.
        :param _builtins.str status: The association status between the ACL and the listener.  Valid values: `Associating`, `Associated` Or `Dissociating`. `Associating`: The ACL is being associated with the listener. `Associated`: The ACL is associated with the listener. `Dissociating`: The ACL is being disassociated from the listener.
        """
        pulumi.set(__self__, "acl_id", acl_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="aclId")
    def acl_id(self) -> _builtins.str:
        """
        Snooping Binding of the Access Policy Group ID List.
        """
        return pulumi.get(self, "acl_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The association status between the ACL and the listener.  Valid values: `Associating`, `Associated` Or `Dissociating`. `Associating`: The ACL is being associated with the listener. `Associated`: The ACL is associated with the listener. `Dissociating`: The ACL is being disassociated from the listener.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetListenersListenerCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_id: _builtins.str):
        """
        :param _builtins.str certificate_id: The ID of the Certificate.
        """
        pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        The ID of the Certificate.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class GetListenersListenerDefaultActionResult(dict):
    def __init__(__self__, *,
                 forward_group_configs: Sequence['outputs.GetListenersListenerDefaultActionForwardGroupConfigResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetListenersListenerDefaultActionForwardGroupConfigArgs'] forward_group_configs: The configuration of the forwarding rule action. This parameter is required if the Type parameter is set to FowardGroup.
        :param _builtins.str type: Action Type. The value is set to ForwardGroup. It indicates that requests are forwarded to multiple vServer groups.
        """
        pulumi.set(__self__, "forward_group_configs", forward_group_configs)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="forwardGroupConfigs")
    def forward_group_configs(self) -> Sequence['outputs.GetListenersListenerDefaultActionForwardGroupConfigResult']:
        """
        The configuration of the forwarding rule action. This parameter is required if the Type parameter is set to FowardGroup.
        """
        return pulumi.get(self, "forward_group_configs")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Action Type. The value is set to ForwardGroup. It indicates that requests are forwarded to multiple vServer groups.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetListenersListenerDefaultActionForwardGroupConfigResult(dict):
    def __init__(__self__, *,
                 server_group_tuples: Sequence['outputs.GetListenersListenerDefaultActionForwardGroupConfigServerGroupTupleResult']):
        """
        :param Sequence['GetListenersListenerDefaultActionForwardGroupConfigServerGroupTupleArgs'] server_group_tuples: The destination server group to which requests are forwarded.
        """
        pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Sequence['outputs.GetListenersListenerDefaultActionForwardGroupConfigServerGroupTupleResult']:
        """
        The destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_tuples")


@pulumi.output_type
class GetListenersListenerDefaultActionForwardGroupConfigServerGroupTupleResult(dict):
    def __init__(__self__, *,
                 server_group_id: _builtins.str):
        """
        :param _builtins.str server_group_id: The ID of the destination server group to which requests are forwarded.
        """
        pulumi.set(__self__, "server_group_id", server_group_id)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> _builtins.str:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")


@pulumi.output_type
class GetListenersListenerQuicConfigResult(dict):
    def __init__(__self__, *,
                 quic_listener_id: _builtins.str,
                 quic_upgrade_enabled: _builtins.bool):
        """
        :param _builtins.str quic_listener_id: The ID of the QUIC listener to be associated. If QuicUpgradeEnabled is set to true, this parameter is required. Only HTTPS listeners support this parameter.
        :param _builtins.bool quic_upgrade_enabled: Indicates whether quic upgrade is enabled. Valid values: true and false. Default value: false.
        """
        pulumi.set(__self__, "quic_listener_id", quic_listener_id)
        pulumi.set(__self__, "quic_upgrade_enabled", quic_upgrade_enabled)

    @_builtins.property
    @pulumi.getter(name="quicListenerId")
    def quic_listener_id(self) -> _builtins.str:
        """
        The ID of the QUIC listener to be associated. If QuicUpgradeEnabled is set to true, this parameter is required. Only HTTPS listeners support this parameter.
        """
        return pulumi.get(self, "quic_listener_id")

    @_builtins.property
    @pulumi.getter(name="quicUpgradeEnabled")
    def quic_upgrade_enabled(self) -> _builtins.bool:
        """
        Indicates whether quic upgrade is enabled. Valid values: true and false. Default value: false.
        """
        return pulumi.get(self, "quic_upgrade_enabled")


@pulumi.output_type
class GetListenersListenerXforwardedForConfigResult(dict):
    def __init__(__self__, *,
                 xforwardedforclientcert_issuerdnalias: _builtins.str,
                 xforwardedforclientcert_issuerdnenabled: _builtins.bool,
                 xforwardedforclientcertclientverifyalias: _builtins.str,
                 xforwardedforclientcertclientverifyenabled: _builtins.bool,
                 xforwardedforclientcertfingerprintalias: _builtins.str,
                 xforwardedforclientcertfingerprintenabled: _builtins.bool,
                 xforwardedforclientcertsubjectdnalias: _builtins.str,
                 xforwardedforclientcertsubjectdnenabled: _builtins.bool,
                 xforwardedforclientsrcportenabled: _builtins.bool,
                 xforwardedforenabled: _builtins.bool,
                 xforwardedforprotoenabled: _builtins.bool,
                 xforwardedforslbidenabled: _builtins.bool,
                 xforwardedforslbportenabled: _builtins.bool):
        """
        :param _builtins.str xforwardedforclientcert_issuerdnalias: The Custom Header Field Names Only When `xforwardedforclientcert_issuerdnenabled`, Which Evaluates to True When the Entry into Force of.
        :param _builtins.bool xforwardedforclientcert_issuerdnenabled: Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        :param _builtins.str xforwardedforclientcertclientverifyalias: The Custom Header Field Names Only When `xforwardedforclientcertclientverifyenabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        :param _builtins.bool xforwardedforclientcertclientverifyenabled: Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        :param _builtins.str xforwardedforclientcertfingerprintalias: The Custom Header Field Names Only When `xforwardedforclientcertfingerprintenabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        :param _builtins.bool xforwardedforclientcertfingerprintenabled: Indicates Whether the `X-Forwarded-Clientcert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        :param _builtins.str xforwardedforclientcertsubjectdnalias: The name of the custom header. This parameter is valid only if `xforwardedforclientcertsubjectdnenabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        :param _builtins.bool xforwardedforclientcertsubjectdnenabled: Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
        :param _builtins.bool xforwardedforclientsrcportenabled: Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        :param _builtins.bool xforwardedforenabled: Indicates whether the X-Forwarded-For header field is used to obtain the real IP address of tqhe client. Valid values: true and false. Default value: true.
        :param _builtins.bool xforwardedforprotoenabled: Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        :param _builtins.bool xforwardedforslbidenabled: Indicates whether the SLB-ID header field is used to obtain the ID of the ALB instance. Valid values: true and false. Default value: false.
        :param _builtins.bool xforwardedforslbportenabled: Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
        """
        pulumi.set(__self__, "xforwardedforclientcert_issuerdnalias", xforwardedforclientcert_issuerdnalias)
        pulumi.set(__self__, "xforwardedforclientcert_issuerdnenabled", xforwardedforclientcert_issuerdnenabled)
        pulumi.set(__self__, "xforwardedforclientcertclientverifyalias", xforwardedforclientcertclientverifyalias)
        pulumi.set(__self__, "xforwardedforclientcertclientverifyenabled", xforwardedforclientcertclientverifyenabled)
        pulumi.set(__self__, "xforwardedforclientcertfingerprintalias", xforwardedforclientcertfingerprintalias)
        pulumi.set(__self__, "xforwardedforclientcertfingerprintenabled", xforwardedforclientcertfingerprintenabled)
        pulumi.set(__self__, "xforwardedforclientcertsubjectdnalias", xforwardedforclientcertsubjectdnalias)
        pulumi.set(__self__, "xforwardedforclientcertsubjectdnenabled", xforwardedforclientcertsubjectdnenabled)
        pulumi.set(__self__, "xforwardedforclientsrcportenabled", xforwardedforclientsrcportenabled)
        pulumi.set(__self__, "xforwardedforenabled", xforwardedforenabled)
        pulumi.set(__self__, "xforwardedforprotoenabled", xforwardedforprotoenabled)
        pulumi.set(__self__, "xforwardedforslbidenabled", xforwardedforslbidenabled)
        pulumi.set(__self__, "xforwardedforslbportenabled", xforwardedforslbportenabled)

    @_builtins.property
    @pulumi.getter(name="xforwardedforclientcertIssuerdnalias")
    def xforwardedforclientcert_issuerdnalias(self) -> _builtins.str:
        """
        The Custom Header Field Names Only When `xforwardedforclientcert_issuerdnenabled`, Which Evaluates to True When the Entry into Force of.
        """
        return pulumi.get(self, "xforwardedforclientcert_issuerdnalias")

    @_builtins.property
    @pulumi.getter(name="xforwardedforclientcertIssuerdnenabled")
    def xforwardedforclientcert_issuerdnenabled(self) -> _builtins.bool:
        """
        Indicates Whether the `X-Forwarded-Clientcert-issuerdn` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate after the Manifests Are Signed, the Publisher Information.
        """
        return pulumi.get(self, "xforwardedforclientcert_issuerdnenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientcertclientverifyalias(self) -> _builtins.str:
        """
        The Custom Header Field Names Only When `xforwardedforclientcertclientverifyenabled` Has a Value of True, this Value Will Not Take Effect until.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        """
        return pulumi.get(self, "xforwardedforclientcertclientverifyalias")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientcertclientverifyenabled(self) -> _builtins.bool:
        """
        Indicates Whether the `X-Forwarded-Clientcert-clientverify` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate to Verify the Results.
        """
        return pulumi.get(self, "xforwardedforclientcertclientverifyenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientcertfingerprintalias(self) -> _builtins.str:
        """
        The Custom Header Field Names Only When `xforwardedforclientcertfingerprintenabled`, Which Evaluates to True When the Entry into Force of.The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        """
        return pulumi.get(self, "xforwardedforclientcertfingerprintalias")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientcertfingerprintenabled(self) -> _builtins.bool:
        """
        Indicates Whether the `X-Forwarded-Clientcert-fingerprint` Header Field Is Used to Obtain Access to the Server Load Balancer Instance of the Client Certificate Fingerprint Value.
        """
        return pulumi.get(self, "xforwardedforclientcertfingerprintenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientcertsubjectdnalias(self) -> _builtins.str:
        """
        The name of the custom header. This parameter is valid only if `xforwardedforclientcertsubjectdnenabled` is set to true. The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (_), and digits.
        """
        return pulumi.get(self, "xforwardedforclientcertsubjectdnalias")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientcertsubjectdnenabled(self) -> _builtins.bool:
        """
        Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header field to obtain information about the owner of the ALB client certificate. Valid values: true and false. Default value: false.
        """
        return pulumi.get(self, "xforwardedforclientcertsubjectdnenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforclientsrcportenabled(self) -> _builtins.bool:
        """
        Indicates Whether the X-Forwarded-Client-Port Header Field Is Used to Obtain Access to Server Load Balancer Instances to the Client, and Those of the Ports.
        """
        return pulumi.get(self, "xforwardedforclientsrcportenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforenabled(self) -> _builtins.bool:
        """
        Indicates whether the X-Forwarded-For header field is used to obtain the real IP address of tqhe client. Valid values: true and false. Default value: true.
        """
        return pulumi.get(self, "xforwardedforenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforprotoenabled(self) -> _builtins.bool:
        """
        Indicates Whether the X-Forwarded-Proto Header Field Is Used to Obtain the Server Load Balancer Instance Snooping Protocols.
        """
        return pulumi.get(self, "xforwardedforprotoenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforslbidenabled(self) -> _builtins.bool:
        """
        Indicates whether the SLB-ID header field is used to obtain the ID of the ALB instance. Valid values: true and false. Default value: false.
        """
        return pulumi.get(self, "xforwardedforslbidenabled")

    @_builtins.property
    @pulumi.getter
    def xforwardedforslbportenabled(self) -> _builtins.bool:
        """
        Indicates Whether the X-Forwarded-Port Header Field Is Used to Obtain the Server Load Balancer Instance Listening Port.
        """
        return pulumi.get(self, "xforwardedforslbportenabled")


@pulumi.output_type
class GetLoadBalancersBalancerResult(dict):
    def __init__(__self__, *,
                 access_log_configs: Sequence['outputs.GetLoadBalancersBalancerAccessLogConfigResult'],
                 address_allocated_mode: _builtins.str,
                 address_type: _builtins.str,
                 bandwidth_package_id: _builtins.str,
                 create_time: _builtins.str,
                 deletion_protection_configs: Sequence['outputs.GetLoadBalancersBalancerDeletionProtectionConfigResult'],
                 dns_name: _builtins.str,
                 id: _builtins.str,
                 load_balancer_billing_configs: Sequence['outputs.GetLoadBalancersBalancerLoadBalancerBillingConfigResult'],
                 load_balancer_business_status: _builtins.str,
                 load_balancer_bussiness_status: _builtins.str,
                 load_balancer_edition: _builtins.str,
                 load_balancer_id: _builtins.str,
                 load_balancer_name: _builtins.str,
                 load_balancer_operation_locks: Sequence['outputs.GetLoadBalancersBalancerLoadBalancerOperationLockResult'],
                 modification_protection_configs: Sequence['outputs.GetLoadBalancersBalancerModificationProtectionConfigResult'],
                 resource_group_id: _builtins.str,
                 status: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 vpc_id: _builtins.str,
                 zone_mappings: Sequence['outputs.GetLoadBalancersBalancerZoneMappingResult']):
        """
        :param Sequence['GetLoadBalancersBalancerAccessLogConfigArgs'] access_log_configs: The Access Logging Configuration Structure.
        :param _builtins.str address_allocated_mode: The method in which IP addresses are assigned.
        :param _builtins.str address_type: The type of IP address that the ALB instance uses to provide services. Valid values: `Intranet`, `Internet`.
        :param _builtins.str bandwidth_package_id: The ID of the EIP bandwidth plan which is associated with an ALB instance that uses a
               public IP address.
        :param _builtins.str create_time: The creation time of the resource.
        :param Sequence['GetLoadBalancersBalancerDeletionProtectionConfigArgs'] deletion_protection_configs: Remove the Protection Configuration.
        :param _builtins.str dns_name: DNS Domain Name.
        :param _builtins.str id: The ID of the Load Balancer.
        :param Sequence['GetLoadBalancersBalancerLoadBalancerBillingConfigArgs'] load_balancer_billing_configs: The configuration of the billing method.
        :param _builtins.str load_balancer_business_status: Load Balancing of the Service Status. Valid Values: `Abnormal`and `Normal`.
        :param _builtins.str load_balancer_bussiness_status: Field `load_balancer_bussiness_status` has been deprecated from provider version 1.142.0. New field `load_balancer_business_status` instead.
        :param _builtins.str load_balancer_edition: The edition of the ALB instance.
        :param _builtins.str load_balancer_id: The first ID of the resource.
        :param _builtins.str load_balancer_name: The name of the resource.
        :param Sequence['GetLoadBalancersBalancerLoadBalancerOperationLockArgs'] load_balancer_operation_locks: The Load Balancing Operations Lock Configuration.
        :param Sequence['GetLoadBalancersBalancerModificationProtectionConfigArgs'] modification_protection_configs: Modify the Protection Configuration.
        :param _builtins.str resource_group_id: The ID of the resource group.
        :param _builtins.str status: The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.str vpc_id: The ID of the virtual private cloud (VPC) where the ALB instance is deployed.
        :param Sequence['GetLoadBalancersBalancerZoneMappingArgs'] zone_mappings: The zones and vSwitches.
        """
        pulumi.set(__self__, "access_log_configs", access_log_configs)
        pulumi.set(__self__, "address_allocated_mode", address_allocated_mode)
        pulumi.set(__self__, "address_type", address_type)
        pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "deletion_protection_configs", deletion_protection_configs)
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "load_balancer_billing_configs", load_balancer_billing_configs)
        pulumi.set(__self__, "load_balancer_business_status", load_balancer_business_status)
        pulumi.set(__self__, "load_balancer_bussiness_status", load_balancer_bussiness_status)
        pulumi.set(__self__, "load_balancer_edition", load_balancer_edition)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "load_balancer_operation_locks", load_balancer_operation_locks)
        pulumi.set(__self__, "modification_protection_configs", modification_protection_configs)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone_mappings", zone_mappings)

    @_builtins.property
    @pulumi.getter(name="accessLogConfigs")
    def access_log_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerAccessLogConfigResult']:
        """
        The Access Logging Configuration Structure.
        """
        return pulumi.get(self, "access_log_configs")

    @_builtins.property
    @pulumi.getter(name="addressAllocatedMode")
    def address_allocated_mode(self) -> _builtins.str:
        """
        The method in which IP addresses are assigned.
        """
        return pulumi.get(self, "address_allocated_mode")

    @_builtins.property
    @pulumi.getter(name="addressType")
    def address_type(self) -> _builtins.str:
        """
        The type of IP address that the ALB instance uses to provide services. Valid values: `Intranet`, `Internet`.
        """
        return pulumi.get(self, "address_type")

    @_builtins.property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> _builtins.str:
        """
        The ID of the EIP bandwidth plan which is associated with an ALB instance that uses a
        public IP address.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="deletionProtectionConfigs")
    def deletion_protection_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerDeletionProtectionConfigResult']:
        """
        Remove the Protection Configuration.
        """
        return pulumi.get(self, "deletion_protection_configs")

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        """
        DNS Domain Name.
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="loadBalancerBillingConfigs")
    def load_balancer_billing_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerLoadBalancerBillingConfigResult']:
        """
        The configuration of the billing method.
        """
        return pulumi.get(self, "load_balancer_billing_configs")

    @_builtins.property
    @pulumi.getter(name="loadBalancerBusinessStatus")
    def load_balancer_business_status(self) -> _builtins.str:
        """
        Load Balancing of the Service Status. Valid Values: `Abnormal`and `Normal`.
        """
        return pulumi.get(self, "load_balancer_business_status")

    @_builtins.property
    @pulumi.getter(name="loadBalancerBussinessStatus")
    @_utilities.deprecated("""Field 'load_balancer_bussiness_status' has been deprecated from provider version 1.142.0 and it will be removed in the future version. Please use the new parameter 'load_balancer_business_status' instead.""")
    def load_balancer_bussiness_status(self) -> _builtins.str:
        """
        Field `load_balancer_bussiness_status` has been deprecated from provider version 1.142.0. New field `load_balancer_business_status` instead.
        """
        return pulumi.get(self, "load_balancer_bussiness_status")

    @_builtins.property
    @pulumi.getter(name="loadBalancerEdition")
    def load_balancer_edition(self) -> _builtins.str:
        """
        The edition of the ALB instance.
        """
        return pulumi.get(self, "load_balancer_edition")

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "load_balancer_id")

    @_builtins.property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "load_balancer_name")

    @_builtins.property
    @pulumi.getter(name="loadBalancerOperationLocks")
    def load_balancer_operation_locks(self) -> Sequence['outputs.GetLoadBalancersBalancerLoadBalancerOperationLockResult']:
        """
        The Load Balancing Operations Lock Configuration.
        """
        return pulumi.get(self, "load_balancer_operation_locks")

    @_builtins.property
    @pulumi.getter(name="modificationProtectionConfigs")
    def modification_protection_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerModificationProtectionConfigResult']:
        """
        Modify the Protection Configuration.
        """
        return pulumi.get(self, "modification_protection_configs")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> _builtins.str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the virtual private cloud (VPC) where the ALB instance is deployed.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="zoneMappings")
    def zone_mappings(self) -> Sequence['outputs.GetLoadBalancersBalancerZoneMappingResult']:
        """
        The zones and vSwitches.
        """
        return pulumi.get(self, "zone_mappings")


@pulumi.output_type
class GetLoadBalancersBalancerAccessLogConfigResult(dict):
    def __init__(__self__, *,
                 log_project: _builtins.str,
                 log_store: _builtins.str):
        """
        :param _builtins.str log_project: The log service that access logs are shipped to.
        :param _builtins.str log_store: The logstore that access logs are shipped to.
        """
        pulumi.set(__self__, "log_project", log_project)
        pulumi.set(__self__, "log_store", log_store)

    @_builtins.property
    @pulumi.getter(name="logProject")
    def log_project(self) -> _builtins.str:
        """
        The log service that access logs are shipped to.
        """
        return pulumi.get(self, "log_project")

    @_builtins.property
    @pulumi.getter(name="logStore")
    def log_store(self) -> _builtins.str:
        """
        The logstore that access logs are shipped to.
        """
        return pulumi.get(self, "log_store")


@pulumi.output_type
class GetLoadBalancersBalancerDeletionProtectionConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 enabled_time: _builtins.str):
        """
        :param _builtins.bool enabled: Remove the Protection Status.
        :param _builtins.str enabled_time: Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm:SSZ.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "enabled_time", enabled_time)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Remove the Protection Status.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> _builtins.str:
        """
        Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm:SSZ.
        """
        return pulumi.get(self, "enabled_time")


@pulumi.output_type
class GetLoadBalancersBalancerLoadBalancerBillingConfigResult(dict):
    def __init__(__self__, *,
                 pay_type: _builtins.str):
        """
        :param _builtins.str pay_type: The billing method of the ALB instance.
        """
        pulumi.set(__self__, "pay_type", pay_type)

    @_builtins.property
    @pulumi.getter(name="payType")
    def pay_type(self) -> _builtins.str:
        """
        The billing method of the ALB instance.
        """
        return pulumi.get(self, "pay_type")


@pulumi.output_type
class GetLoadBalancersBalancerLoadBalancerOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: _builtins.str,
                 lock_type: _builtins.str):
        """
        :param _builtins.str lock_reason: The Locking of the Reasons.
        :param _builtins.str lock_type: The Locking of the Type.
        """
        pulumi.set(__self__, "lock_reason", lock_reason)
        pulumi.set(__self__, "lock_type", lock_type)

    @_builtins.property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> _builtins.str:
        """
        The Locking of the Reasons.
        """
        return pulumi.get(self, "lock_reason")

    @_builtins.property
    @pulumi.getter(name="lockType")
    def lock_type(self) -> _builtins.str:
        """
        The Locking of the Type.
        """
        return pulumi.get(self, "lock_type")


@pulumi.output_type
class GetLoadBalancersBalancerModificationProtectionConfigResult(dict):
    def __init__(__self__, *,
                 reason: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str reason: The reason for modification protection.
        :param _builtins.str status: The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> _builtins.str:
        """
        The reason for modification protection.
        """
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLoadBalancersBalancerZoneMappingResult(dict):
    def __init__(__self__, *,
                 load_balancer_addresses: Sequence['outputs.GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult'],
                 status: _builtins.str,
                 vswitch_id: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param Sequence['GetLoadBalancersBalancerZoneMappingLoadBalancerAddressArgs'] load_balancer_addresses: (Available since v1.250.0) The address of the ALB instance.
        :param _builtins.str status: The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        :param _builtins.str vswitch_id: The ID of the vSwitch that corresponds to the zone.
        :param _builtins.str zone_id: The zone ID of the resource.
        """
        pulumi.set(__self__, "load_balancer_addresses", load_balancer_addresses)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="loadBalancerAddresses")
    def load_balancer_addresses(self) -> Sequence['outputs.GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult']:
        """
        (Available since v1.250.0) The address of the ALB instance.
        """
        return pulumi.get(self, "load_balancer_addresses")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> _builtins.str:
        """
        The ID of the vSwitch that corresponds to the zone.
        """
        return pulumi.get(self, "vswitch_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The zone ID of the resource.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 allocation_id: _builtins.str,
                 eip_type: _builtins.str,
                 intranet_address: _builtins.str,
                 intranet_address_hc_status: _builtins.str,
                 ipv4_local_addresses: Sequence[_builtins.str],
                 ipv6_address: _builtins.str,
                 ipv6_address_hc_status: _builtins.str,
                 ipv6_local_addresses: Sequence[_builtins.str]):
        """
        :param _builtins.str address: IPv4 address.
        :param _builtins.str allocation_id: The elastic IP address (EIP).
        :param _builtins.str eip_type: The type of EIP.
        :param _builtins.str intranet_address: The private IPv4 address.
        :param _builtins.str intranet_address_hc_status: The health status of the private IPv4 address of the ALB instance.
        :param Sequence[_builtins.str] ipv4_local_addresses: The IPv4 link-local addresses.
        :param _builtins.str ipv6_address: IPv6 address.
        :param _builtins.str ipv6_address_hc_status: The health status of the private IPv6 address of the ALB instance.
        :param Sequence[_builtins.str] ipv6_local_addresses: The IPv6 link-local addresses.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "eip_type", eip_type)
        pulumi.set(__self__, "intranet_address", intranet_address)
        pulumi.set(__self__, "intranet_address_hc_status", intranet_address_hc_status)
        pulumi.set(__self__, "ipv4_local_addresses", ipv4_local_addresses)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_address_hc_status", ipv6_address_hc_status)
        pulumi.set(__self__, "ipv6_local_addresses", ipv6_local_addresses)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IPv4 address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> _builtins.str:
        """
        The elastic IP address (EIP).
        """
        return pulumi.get(self, "allocation_id")

    @_builtins.property
    @pulumi.getter(name="eipType")
    def eip_type(self) -> _builtins.str:
        """
        The type of EIP.
        """
        return pulumi.get(self, "eip_type")

    @_builtins.property
    @pulumi.getter(name="intranetAddress")
    def intranet_address(self) -> _builtins.str:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "intranet_address")

    @_builtins.property
    @pulumi.getter(name="intranetAddressHcStatus")
    def intranet_address_hc_status(self) -> _builtins.str:
        """
        The health status of the private IPv4 address of the ALB instance.
        """
        return pulumi.get(self, "intranet_address_hc_status")

    @_builtins.property
    @pulumi.getter(name="ipv4LocalAddresses")
    def ipv4_local_addresses(self) -> Sequence[_builtins.str]:
        """
        The IPv4 link-local addresses.
        """
        return pulumi.get(self, "ipv4_local_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressHcStatus")
    def ipv6_address_hc_status(self) -> _builtins.str:
        """
        The health status of the private IPv6 address of the ALB instance.
        """
        return pulumi.get(self, "ipv6_address_hc_status")

    @_builtins.property
    @pulumi.getter(name="ipv6LocalAddresses")
    def ipv6_local_addresses(self) -> Sequence[_builtins.str]:
        """
        The IPv6 link-local addresses.
        """
        return pulumi.get(self, "ipv6_local_addresses")


@pulumi.output_type
class GetRulesRuleResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 listener_id: _builtins.str,
                 load_balancer_id: _builtins.str,
                 priority: _builtins.int,
                 rule_actions: Sequence['outputs.GetRulesRuleRuleActionResult'],
                 rule_conditions: Sequence['outputs.GetRulesRuleRuleConditionResult'],
                 rule_id: _builtins.str,
                 rule_name: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str id: The ID of the Rule.
        :param _builtins.str listener_id: The ID of the listener to which the forwarding rule belongs.
        :param _builtins.str load_balancer_id: The ID of the Application Load Balancer (ALB) instance to which the forwarding rule belongs.
        :param _builtins.int priority: The priority of the rule.
        :param Sequence['GetRulesRuleRuleActionArgs'] rule_actions: The actions of the forwarding rules.
        :param Sequence['GetRulesRuleRuleConditionArgs'] rule_conditions: The conditions of the forwarding rule.
        :param _builtins.str rule_id: The ID of the Rule.
        :param _builtins.str rule_name: The name of the forwarding rule.
        :param _builtins.str status: The status of the forwarding rule. Valid values: `Provisioning`, `Configuring`, `Available`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rule_actions", rule_actions)
        pulumi.set(__self__, "rule_conditions", rule_conditions)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        The ID of the listener to which the forwarding rule belongs.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> _builtins.str:
        """
        The ID of the Application Load Balancer (ALB) instance to which the forwarding rule belongs.
        """
        return pulumi.get(self, "load_balancer_id")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of the rule.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="ruleActions")
    def rule_actions(self) -> Sequence['outputs.GetRulesRuleRuleActionResult']:
        """
        The actions of the forwarding rules.
        """
        return pulumi.get(self, "rule_actions")

    @_builtins.property
    @pulumi.getter(name="ruleConditions")
    def rule_conditions(self) -> Sequence['outputs.GetRulesRuleRuleConditionResult']:
        """
        The conditions of the forwarding rule.
        """
        return pulumi.get(self, "rule_conditions")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.str:
        """
        The ID of the Rule.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> _builtins.str:
        """
        The name of the forwarding rule.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the forwarding rule. Valid values: `Provisioning`, `Configuring`, `Available`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesRuleRuleActionResult(dict):
    def __init__(__self__, *,
                 fixed_response_configs: Sequence['outputs.GetRulesRuleRuleActionFixedResponseConfigResult'],
                 forward_group_configs: Sequence['outputs.GetRulesRuleRuleActionForwardGroupConfigResult'],
                 insert_header_configs: Sequence['outputs.GetRulesRuleRuleActionInsertHeaderConfigResult'],
                 order: _builtins.int,
                 redirect_configs: Sequence['outputs.GetRulesRuleRuleActionRedirectConfigResult'],
                 rewrite_configs: Sequence['outputs.GetRulesRuleRuleActionRewriteConfigResult'],
                 traffic_limit_configs: Sequence['outputs.GetRulesRuleRuleActionTrafficLimitConfigResult'],
                 traffic_mirror_configs: Sequence['outputs.GetRulesRuleRuleActionTrafficMirrorConfigResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetRulesRuleRuleActionFixedResponseConfigArgs'] fixed_response_configs: The configuration of the fixed response.
        :param Sequence['GetRulesRuleRuleActionForwardGroupConfigArgs'] forward_group_configs: The configurations of the destination server groups.
        :param Sequence['GetRulesRuleRuleActionInsertHeaderConfigArgs'] insert_header_configs: The configuration of the inserted header field.
        :param _builtins.int order: The order of the forwarding rule actions.
        :param Sequence['GetRulesRuleRuleActionRedirectConfigArgs'] redirect_configs: The configuration of the external redirect action.
        :param Sequence['GetRulesRuleRuleActionRewriteConfigArgs'] rewrite_configs: The redirect action within ALB.
        :param Sequence['GetRulesRuleRuleActionTrafficLimitConfigArgs'] traffic_limit_configs: The Flow speed limit.
        :param Sequence['GetRulesRuleRuleActionTrafficMirrorConfigArgs'] traffic_mirror_configs: The Traffic mirroring.
        :param _builtins.str type: The type of the forwarding rule.
        """
        pulumi.set(__self__, "fixed_response_configs", fixed_response_configs)
        pulumi.set(__self__, "forward_group_configs", forward_group_configs)
        pulumi.set(__self__, "insert_header_configs", insert_header_configs)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "redirect_configs", redirect_configs)
        pulumi.set(__self__, "rewrite_configs", rewrite_configs)
        pulumi.set(__self__, "traffic_limit_configs", traffic_limit_configs)
        pulumi.set(__self__, "traffic_mirror_configs", traffic_mirror_configs)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="fixedResponseConfigs")
    def fixed_response_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionFixedResponseConfigResult']:
        """
        The configuration of the fixed response.
        """
        return pulumi.get(self, "fixed_response_configs")

    @_builtins.property
    @pulumi.getter(name="forwardGroupConfigs")
    def forward_group_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionForwardGroupConfigResult']:
        """
        The configurations of the destination server groups.
        """
        return pulumi.get(self, "forward_group_configs")

    @_builtins.property
    @pulumi.getter(name="insertHeaderConfigs")
    def insert_header_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionInsertHeaderConfigResult']:
        """
        The configuration of the inserted header field.
        """
        return pulumi.get(self, "insert_header_configs")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        """
        The order of the forwarding rule actions.
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="redirectConfigs")
    def redirect_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionRedirectConfigResult']:
        """
        The configuration of the external redirect action.
        """
        return pulumi.get(self, "redirect_configs")

    @_builtins.property
    @pulumi.getter(name="rewriteConfigs")
    def rewrite_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionRewriteConfigResult']:
        """
        The redirect action within ALB.
        """
        return pulumi.get(self, "rewrite_configs")

    @_builtins.property
    @pulumi.getter(name="trafficLimitConfigs")
    def traffic_limit_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionTrafficLimitConfigResult']:
        """
        The Flow speed limit.
        """
        return pulumi.get(self, "traffic_limit_configs")

    @_builtins.property
    @pulumi.getter(name="trafficMirrorConfigs")
    def traffic_mirror_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionTrafficMirrorConfigResult']:
        """
        The Traffic mirroring.
        """
        return pulumi.get(self, "traffic_mirror_configs")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the forwarding rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRulesRuleRuleActionFixedResponseConfigResult(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 content_type: _builtins.str,
                 http_code: _builtins.str):
        """
        :param _builtins.str content: The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        :param _builtins.str content_type: The format of the fixed response.
        :param _builtins.str http_code: The redirect method.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "http_code", http_code)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The fixed response. The response cannot exceed 1 KB in size and can contain only ASCII characters.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        """
        The format of the fixed response.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> _builtins.str:
        """
        The redirect method.
        """
        return pulumi.get(self, "http_code")


@pulumi.output_type
class GetRulesRuleRuleActionForwardGroupConfigResult(dict):
    def __init__(__self__, *,
                 server_group_tuples: Sequence['outputs.GetRulesRuleRuleActionForwardGroupConfigServerGroupTupleResult']):
        """
        :param Sequence['GetRulesRuleRuleActionForwardGroupConfigServerGroupTupleArgs'] server_group_tuples: The destination server group to which requests are forwarded.
        """
        pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Sequence['outputs.GetRulesRuleRuleActionForwardGroupConfigServerGroupTupleResult']:
        """
        The destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_tuples")


@pulumi.output_type
class GetRulesRuleRuleActionForwardGroupConfigServerGroupTupleResult(dict):
    def __init__(__self__, *,
                 server_group_id: _builtins.str,
                 weight: _builtins.int):
        """
        :param _builtins.str server_group_id: The ID of the destination server group to which requests are forwarded.
        :param _builtins.int weight: The Weight of server group.
        """
        pulumi.set(__self__, "server_group_id", server_group_id)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> _builtins.str:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The Weight of server group.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRulesRuleRuleActionInsertHeaderConfigResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 value_type: _builtins.str):
        """
        :param _builtins.str key: The key of the query string.
        :param _builtins.str value: The value of the query string.
        :param _builtins.str value_type: The value type of the inserted header field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the query string.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the query string.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> _builtins.str:
        """
        The value type of the inserted header field.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetRulesRuleRuleActionRedirectConfigResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 http_code: _builtins.str,
                 path: _builtins.str,
                 port: _builtins.str,
                 protocol: _builtins.str,
                 query: _builtins.str):
        """
        :param _builtins.str host: The host name of the destination to which requests are redirected within ALB.
        :param _builtins.str http_code: The redirect method.
        :param _builtins.str path: The path to which requests are to be redirected within ALB.
        :param _builtins.str port: The port of the destination to which requests are redirected.
        :param _builtins.str protocol: The protocol of the requests to be redirected.
        :param _builtins.str query: The query string of the request to be redirected within ALB.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_code", http_code)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The host name of the destination to which requests are redirected within ALB.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> _builtins.str:
        """
        The redirect method.
        """
        return pulumi.get(self, "http_code")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to which requests are to be redirected within ALB.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        The port of the destination to which requests are redirected.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol of the requests to be redirected.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        """
        The query string of the request to be redirected within ALB.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetRulesRuleRuleActionRewriteConfigResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 path: _builtins.str,
                 query: _builtins.str):
        """
        :param _builtins.str host: The host name of the destination to which requests are redirected within ALB.
        :param _builtins.str path: The path to which requests are to be redirected within ALB.
        :param _builtins.str query: The query string of the request to be redirected within ALB.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The host name of the destination to which requests are redirected within ALB.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to which requests are to be redirected within ALB.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        """
        The query string of the request to be redirected within ALB.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetRulesRuleRuleActionTrafficLimitConfigResult(dict):
    def __init__(__self__, *,
                 qps: _builtins.int):
        """
        :param _builtins.int qps: The Number of requests per second.
        """
        pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def qps(self) -> _builtins.int:
        """
        The Number of requests per second.
        """
        return pulumi.get(self, "qps")


@pulumi.output_type
class GetRulesRuleRuleActionTrafficMirrorConfigResult(dict):
    def __init__(__self__, *,
                 mirror_group_configs: Sequence['outputs.GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigResult'],
                 target_type: _builtins.str):
        """
        :param Sequence['GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigArgs'] mirror_group_configs: The Traffic is mirrored to the server group.
        :param _builtins.str target_type: The Mirror target type.
        """
        pulumi.set(__self__, "mirror_group_configs", mirror_group_configs)
        pulumi.set(__self__, "target_type", target_type)

    @_builtins.property
    @pulumi.getter(name="mirrorGroupConfigs")
    def mirror_group_configs(self) -> Sequence['outputs.GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigResult']:
        """
        The Traffic is mirrored to the server group.
        """
        return pulumi.get(self, "mirror_group_configs")

    @_builtins.property
    @pulumi.getter(name="targetType")
    def target_type(self) -> _builtins.str:
        """
        The Mirror target type.
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigResult(dict):
    def __init__(__self__, *,
                 server_group_tuples: Sequence['outputs.GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleResult']):
        """
        :param Sequence['GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleArgs'] server_group_tuples: The destination server group to which requests are forwarded.
        """
        pulumi.set(__self__, "server_group_tuples", server_group_tuples)

    @_builtins.property
    @pulumi.getter(name="serverGroupTuples")
    def server_group_tuples(self) -> Sequence['outputs.GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleResult']:
        """
        The destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_tuples")


@pulumi.output_type
class GetRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTupleResult(dict):
    def __init__(__self__, *,
                 server_group_id: _builtins.str):
        """
        :param _builtins.str server_group_id: The ID of the destination server group to which requests are forwarded.
        """
        pulumi.set(__self__, "server_group_id", server_group_id)

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> _builtins.str:
        """
        The ID of the destination server group to which requests are forwarded.
        """
        return pulumi.get(self, "server_group_id")


@pulumi.output_type
class GetRulesRuleRuleConditionResult(dict):
    def __init__(__self__, *,
                 cookie_configs: Sequence['outputs.GetRulesRuleRuleConditionCookieConfigResult'],
                 header_configs: Sequence['outputs.GetRulesRuleRuleConditionHeaderConfigResult'],
                 host_configs: Sequence['outputs.GetRulesRuleRuleConditionHostConfigResult'],
                 method_configs: Sequence['outputs.GetRulesRuleRuleConditionMethodConfigResult'],
                 path_configs: Sequence['outputs.GetRulesRuleRuleConditionPathConfigResult'],
                 query_string_configs: Sequence['outputs.GetRulesRuleRuleConditionQueryStringConfigResult'],
                 source_ip_configs: Sequence['outputs.GetRulesRuleRuleConditionSourceIpConfigResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetRulesRuleRuleConditionCookieConfigArgs'] cookie_configs: The configuration of the cookie.
        :param Sequence['GetRulesRuleRuleConditionHeaderConfigArgs'] header_configs: The configuration of the header field.
        :param Sequence['GetRulesRuleRuleConditionHostConfigArgs'] host_configs: The configuration of the host.
        :param Sequence['GetRulesRuleRuleConditionMethodConfigArgs'] method_configs: The configuration of the request method.
        :param Sequence['GetRulesRuleRuleConditionPathConfigArgs'] path_configs: The configuration of the path for the request to be forwarded.
        :param Sequence['GetRulesRuleRuleConditionQueryStringConfigArgs'] query_string_configs: The configuration of the query string.
        :param Sequence['GetRulesRuleRuleConditionSourceIpConfigArgs'] source_ip_configs: The Based on source IP traffic matching.
        :param _builtins.str type: The type of the forwarding rule.
        """
        pulumi.set(__self__, "cookie_configs", cookie_configs)
        pulumi.set(__self__, "header_configs", header_configs)
        pulumi.set(__self__, "host_configs", host_configs)
        pulumi.set(__self__, "method_configs", method_configs)
        pulumi.set(__self__, "path_configs", path_configs)
        pulumi.set(__self__, "query_string_configs", query_string_configs)
        pulumi.set(__self__, "source_ip_configs", source_ip_configs)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cookieConfigs")
    def cookie_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionCookieConfigResult']:
        """
        The configuration of the cookie.
        """
        return pulumi.get(self, "cookie_configs")

    @_builtins.property
    @pulumi.getter(name="headerConfigs")
    def header_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionHeaderConfigResult']:
        """
        The configuration of the header field.
        """
        return pulumi.get(self, "header_configs")

    @_builtins.property
    @pulumi.getter(name="hostConfigs")
    def host_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionHostConfigResult']:
        """
        The configuration of the host.
        """
        return pulumi.get(self, "host_configs")

    @_builtins.property
    @pulumi.getter(name="methodConfigs")
    def method_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionMethodConfigResult']:
        """
        The configuration of the request method.
        """
        return pulumi.get(self, "method_configs")

    @_builtins.property
    @pulumi.getter(name="pathConfigs")
    def path_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionPathConfigResult']:
        """
        The configuration of the path for the request to be forwarded.
        """
        return pulumi.get(self, "path_configs")

    @_builtins.property
    @pulumi.getter(name="queryStringConfigs")
    def query_string_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionQueryStringConfigResult']:
        """
        The configuration of the query string.
        """
        return pulumi.get(self, "query_string_configs")

    @_builtins.property
    @pulumi.getter(name="sourceIpConfigs")
    def source_ip_configs(self) -> Sequence['outputs.GetRulesRuleRuleConditionSourceIpConfigResult']:
        """
        The Based on source IP traffic matching.
        """
        return pulumi.get(self, "source_ip_configs")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the forwarding rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRulesRuleRuleConditionCookieConfigResult(dict):
    def __init__(__self__, *,
                 values: Sequence['outputs.GetRulesRuleRuleConditionCookieConfigValueResult']):
        """
        :param Sequence['GetRulesRuleRuleConditionCookieConfigValueArgs'] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetRulesRuleRuleConditionCookieConfigValueResult']:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesRuleRuleConditionCookieConfigValueResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of the query string.
        :param _builtins.str value: The value of the query string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the query string.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the query string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesRuleRuleConditionHeaderConfigResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key of the query string.
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the query string.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesRuleRuleConditionHostConfigResult(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesRuleRuleConditionMethodConfigResult(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesRuleRuleConditionPathConfigResult(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesRuleRuleConditionQueryStringConfigResult(dict):
    def __init__(__self__, *,
                 values: Sequence['outputs.GetRulesRuleRuleConditionQueryStringConfigValueResult']):
        """
        :param Sequence['GetRulesRuleRuleConditionQueryStringConfigValueArgs'] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetRulesRuleRuleConditionQueryStringConfigValueResult']:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRulesRuleRuleConditionQueryStringConfigValueResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of the query string.
        :param _builtins.str value: The value of the query string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the query string.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the query string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRulesRuleRuleConditionSourceIpConfigResult(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] values: Add one or more IP addresses or IP address segments.
        """
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Add one or more IP addresses or IP address segments.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecurityPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 ciphers: Sequence[_builtins.str],
                 id: _builtins.str,
                 resource_group_id: _builtins.str,
                 security_policy_id: _builtins.str,
                 security_policy_name: _builtins.str,
                 status: _builtins.str,
                 tls_versions: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] ciphers: The supported cipher suites, which are determined by the TLS protocol version.
        :param _builtins.str id: The ID of the Security Policy.
        :param _builtins.str resource_group_id: The ID of the resource group.
        :param _builtins.str security_policy_id: The first ID of the resource.
        :param _builtins.str security_policy_name: The name of the resource. The name must be 2 to 128 characters in length and must start with a letter. It can contain digits, periods (.), underscores (_), and hyphens (-).
        :param _builtins.str status: The status of the resource.
        :param Sequence[_builtins.str] tls_versions: The TLS protocol versions that are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
        """
        pulumi.set(__self__, "ciphers", ciphers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "security_policy_id", security_policy_id)
        pulumi.set(__self__, "security_policy_name", security_policy_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tls_versions", tls_versions)

    @_builtins.property
    @pulumi.getter
    def ciphers(self) -> Sequence[_builtins.str]:
        """
        The supported cipher suites, which are determined by the TLS protocol version.
        """
        return pulumi.get(self, "ciphers")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Security Policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> _builtins.str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter(name="securityPolicyId")
    def security_policy_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "security_policy_id")

    @_builtins.property
    @pulumi.getter(name="securityPolicyName")
    def security_policy_name(self) -> _builtins.str:
        """
        The name of the resource. The name must be 2 to 128 characters in length and must start with a letter. It can contain digits, periods (.), underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "security_policy_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="tlsVersions")
    def tls_versions(self) -> Sequence[_builtins.str]:
        """
        The TLS protocol versions that are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
        """
        return pulumi.get(self, "tls_versions")


@pulumi.output_type
class GetServerGroupsGroupResult(dict):
    def __init__(__self__, *,
                 health_check_configs: Sequence['outputs.GetServerGroupsGroupHealthCheckConfigResult'],
                 id: _builtins.str,
                 protocol: _builtins.str,
                 scheduler: _builtins.str,
                 server_group_id: _builtins.str,
                 server_group_name: _builtins.str,
                 servers: Sequence['outputs.GetServerGroupsGroupServerResult'],
                 status: _builtins.str,
                 sticky_session_configs: Sequence['outputs.GetServerGroupsGroupStickySessionConfigResult'],
                 tags: Mapping[str, _builtins.str],
                 vpc_id: _builtins.str):
        """
        :param Sequence['GetServerGroupsGroupHealthCheckConfigArgs'] health_check_configs: The configuration of health checks. **Note:** `health_check_config` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str id: The ID of the Server Group.
        :param _builtins.str protocol: The backend protocol.
        :param _builtins.str scheduler: The scheduling algorithm.
        :param _builtins.str server_group_id: The ID of the Server Group.
        :param _builtins.str server_group_name: The names of the Server Group.
        :param Sequence['GetServerGroupsGroupServerArgs'] servers: The backend server. **Note:** `servers` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str status: The status of the Server Group. Valid values: `Available`, `Configuring`, `Provisioning`.
        :param Sequence['GetServerGroupsGroupStickySessionConfigArgs'] sticky_session_configs: The configuration of the sticky session. **Note:** `sticky_session_config` takes effect only if `enable_details` is set to `true`.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.str vpc_id: The ID of the virtual private cloud (VPC).
        """
        pulumi.set(__self__, "health_check_configs", health_check_configs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "scheduler", scheduler)
        pulumi.set(__self__, "server_group_id", server_group_id)
        pulumi.set(__self__, "server_group_name", server_group_name)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "sticky_session_configs", sticky_session_configs)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="healthCheckConfigs")
    def health_check_configs(self) -> Sequence['outputs.GetServerGroupsGroupHealthCheckConfigResult']:
        """
        The configuration of health checks. **Note:** `health_check_config` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "health_check_configs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Server Group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The backend protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> _builtins.str:
        """
        The scheduling algorithm.
        """
        return pulumi.get(self, "scheduler")

    @_builtins.property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> _builtins.str:
        """
        The ID of the Server Group.
        """
        return pulumi.get(self, "server_group_id")

    @_builtins.property
    @pulumi.getter(name="serverGroupName")
    def server_group_name(self) -> _builtins.str:
        """
        The names of the Server Group.
        """
        return pulumi.get(self, "server_group_name")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetServerGroupsGroupServerResult']:
        """
        The backend server. **Note:** `servers` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the Server Group. Valid values: `Available`, `Configuring`, `Provisioning`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="stickySessionConfigs")
    def sticky_session_configs(self) -> Sequence['outputs.GetServerGroupsGroupStickySessionConfigResult']:
        """
        The configuration of the sticky session. **Note:** `sticky_session_config` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "sticky_session_configs")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the virtual private cloud (VPC).
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetServerGroupsGroupHealthCheckConfigResult(dict):
    def __init__(__self__, *,
                 health_check_codes: Sequence[_builtins.str],
                 health_check_connect_port: _builtins.int,
                 health_check_enabled: _builtins.bool,
                 health_check_host: _builtins.str,
                 health_check_http_version: _builtins.str,
                 health_check_interval: _builtins.int,
                 health_check_method: _builtins.str,
                 health_check_path: _builtins.str,
                 health_check_protocol: _builtins.str,
                 health_check_timeout: _builtins.int,
                 healthy_threshold: _builtins.int,
                 unhealthy_threshold: _builtins.int):
        """
        :param Sequence[_builtins.str] health_check_codes: The status code for a successful health check. Multiple status codes can be specified as a list.
        :param _builtins.int health_check_connect_port: The port of the backend server that is used for health checks.
        :param _builtins.bool health_check_enabled: Indicates whether health checks are enabled.
        :param _builtins.str health_check_host: The domain name that is used for health checks.
        :param _builtins.str health_check_http_version: HTTP protocol version.
        :param _builtins.int health_check_interval: The time interval between two consecutive health checks.
        :param _builtins.str health_check_method: Health check method.
        :param _builtins.str health_check_path: The forwarding rule path of health checks.
        :param _builtins.str health_check_protocol: Health check protocol.
        :param _builtins.int health_check_timeout: The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy.
        :param _builtins.int healthy_threshold: The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success.
        :param _builtins.int unhealthy_threshold: The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail.
        """
        pulumi.set(__self__, "health_check_codes", health_check_codes)
        pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        pulumi.set(__self__, "health_check_host", health_check_host)
        pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        pulumi.set(__self__, "health_check_interval", health_check_interval)
        pulumi.set(__self__, "health_check_method", health_check_method)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Sequence[_builtins.str]:
        """
        The status code for a successful health check. Multiple status codes can be specified as a list.
        """
        return pulumi.get(self, "health_check_codes")

    @_builtins.property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> _builtins.int:
        """
        The port of the backend server that is used for health checks.
        """
        return pulumi.get(self, "health_check_connect_port")

    @_builtins.property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> _builtins.bool:
        """
        Indicates whether health checks are enabled.
        """
        return pulumi.get(self, "health_check_enabled")

    @_builtins.property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> _builtins.str:
        """
        The domain name that is used for health checks.
        """
        return pulumi.get(self, "health_check_host")

    @_builtins.property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> _builtins.str:
        """
        HTTP protocol version.
        """
        return pulumi.get(self, "health_check_http_version")

    @_builtins.property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> _builtins.int:
        """
        The time interval between two consecutive health checks.
        """
        return pulumi.get(self, "health_check_interval")

    @_builtins.property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> _builtins.str:
        """
        Health check method.
        """
        return pulumi.get(self, "health_check_method")

    @_builtins.property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> _builtins.str:
        """
        The forwarding rule path of health checks.
        """
        return pulumi.get(self, "health_check_path")

    @_builtins.property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> _builtins.str:
        """
        Health check protocol.
        """
        return pulumi.get(self, "health_check_protocol")

    @_builtins.property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> _builtins.int:
        """
        The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy.
        """
        return pulumi.get(self, "health_check_timeout")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetServerGroupsGroupServerResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 port: _builtins.int,
                 server_id: _builtins.str,
                 server_ip: _builtins.str,
                 server_type: _builtins.str,
                 status: _builtins.str,
                 weight: _builtins.int):
        """
        :param _builtins.str description: The description of the server.
        :param _builtins.int port: The port that is used by the server.
        :param _builtins.str server_id: The ID of the ECS instance, ENI instance or ECI instance.
        :param _builtins.str server_ip: The IP address of the ENI instance when it is in the inclusive ENI mode.
        :param _builtins.str server_type: The type of the server. The type of the server.
        :param _builtins.str status: The status of the Server Group. Valid values: `Available`, `Configuring`, `Provisioning`.
        :param _builtins.int weight: The weight of the server.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_ip", server_ip)
        pulumi.set(__self__, "server_type", server_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the server.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port that is used by the server.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> _builtins.str:
        """
        The ID of the ECS instance, ENI instance or ECI instance.
        """
        return pulumi.get(self, "server_id")

    @_builtins.property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> _builtins.str:
        """
        The IP address of the ENI instance when it is in the inclusive ENI mode.
        """
        return pulumi.get(self, "server_ip")

    @_builtins.property
    @pulumi.getter(name="serverType")
    def server_type(self) -> _builtins.str:
        """
        The type of the server. The type of the server.
        """
        return pulumi.get(self, "server_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the Server Group. Valid values: `Available`, `Configuring`, `Provisioning`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight of the server.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetServerGroupsGroupStickySessionConfigResult(dict):
    def __init__(__self__, *,
                 cookie: _builtins.str,
                 cookie_timeout: _builtins.int,
                 sticky_session_enabled: _builtins.bool,
                 sticky_session_type: _builtins.str):
        """
        :param _builtins.str cookie: the cookie that is configured on the server.
        :param _builtins.int cookie_timeout: The timeout period of a cookie. The timeout period of a cookie.
        :param _builtins.bool sticky_session_enabled: Indicates whether sticky session is enabled.
        :param _builtins.str sticky_session_type: The method that is used to handle a cookie.
        """
        pulumi.set(__self__, "cookie", cookie)
        pulumi.set(__self__, "cookie_timeout", cookie_timeout)
        pulumi.set(__self__, "sticky_session_enabled", sticky_session_enabled)
        pulumi.set(__self__, "sticky_session_type", sticky_session_type)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> _builtins.str:
        """
        the cookie that is configured on the server.
        """
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> _builtins.int:
        """
        The timeout period of a cookie. The timeout period of a cookie.
        """
        return pulumi.get(self, "cookie_timeout")

    @_builtins.property
    @pulumi.getter(name="stickySessionEnabled")
    def sticky_session_enabled(self) -> _builtins.bool:
        """
        Indicates whether sticky session is enabled.
        """
        return pulumi.get(self, "sticky_session_enabled")

    @_builtins.property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> _builtins.str:
        """
        The method that is used to handle a cookie.
        """
        return pulumi.get(self, "sticky_session_type")


@pulumi.output_type
class GetSystemSecurityPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 ciphers: Sequence[_builtins.str],
                 id: _builtins.str,
                 security_policy_id: _builtins.str,
                 tls_versions: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] ciphers: The supported cipher suites, which are determined by the TLS protocol version.
        :param _builtins.str id: The ID of the Security Policy.
        :param _builtins.str security_policy_id: The first ID of the resource.
        :param Sequence[_builtins.str] tls_versions: The TLS protocol versions are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
        """
        pulumi.set(__self__, "ciphers", ciphers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "security_policy_id", security_policy_id)
        pulumi.set(__self__, "tls_versions", tls_versions)

    @_builtins.property
    @pulumi.getter
    def ciphers(self) -> Sequence[_builtins.str]:
        """
        The supported cipher suites, which are determined by the TLS protocol version.
        """
        return pulumi.get(self, "ciphers")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Security Policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="securityPolicyId")
    def security_policy_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "security_policy_id")

    @_builtins.property
    @pulumi.getter(name="tlsVersions")
    def tls_versions(self) -> Sequence[_builtins.str]:
        """
        The TLS protocol versions are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
        """
        return pulumi.get(self, "tls_versions")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 local_name: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.str id: The ID of zone.
        :param _builtins.str local_name: The local name.
        :param _builtins.str zone_id: The zone ID.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "local_name", local_name)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of zone.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="localName")
    def local_name(self) -> _builtins.str:
        """
        The local name.
        """
        return pulumi.get(self, "local_name")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The zone ID.
        """
        return pulumi.get(self, "zone_id")


