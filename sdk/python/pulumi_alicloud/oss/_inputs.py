# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BucketAccessMonitorArgs',
    'BucketAccessMonitorArgsDict',
    'BucketCnameCertificateArgs',
    'BucketCnameCertificateArgsDict',
    'BucketCorsCorsRuleArgs',
    'BucketCorsCorsRuleArgsDict',
    'BucketCorsRuleArgs',
    'BucketCorsRuleArgsDict',
    'BucketLifecycleRuleArgs',
    'BucketLifecycleRuleArgsDict',
    'BucketLifecycleRuleAbortMultipartUploadArgs',
    'BucketLifecycleRuleAbortMultipartUploadArgsDict',
    'BucketLifecycleRuleExpirationArgs',
    'BucketLifecycleRuleExpirationArgsDict',
    'BucketLifecycleRuleFilterArgs',
    'BucketLifecycleRuleFilterArgsDict',
    'BucketLifecycleRuleFilterNotArgs',
    'BucketLifecycleRuleFilterNotArgsDict',
    'BucketLifecycleRuleFilterNotTagArgs',
    'BucketLifecycleRuleFilterNotTagArgsDict',
    'BucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'BucketLifecycleRuleNoncurrentVersionExpirationArgsDict',
    'BucketLifecycleRuleNoncurrentVersionTransitionArgs',
    'BucketLifecycleRuleNoncurrentVersionTransitionArgsDict',
    'BucketLifecycleRuleTransitionArgs',
    'BucketLifecycleRuleTransitionArgsDict',
    'BucketLoggingArgs',
    'BucketLoggingArgsDict',
    'BucketRefererConfigArgs',
    'BucketRefererConfigArgsDict',
    'BucketReplicationDestinationArgs',
    'BucketReplicationDestinationArgsDict',
    'BucketReplicationEncryptionConfigurationArgs',
    'BucketReplicationEncryptionConfigurationArgsDict',
    'BucketReplicationPrefixSetArgs',
    'BucketReplicationPrefixSetArgsDict',
    'BucketReplicationProgressArgs',
    'BucketReplicationProgressArgsDict',
    'BucketReplicationSourceSelectionCriteriaArgs',
    'BucketReplicationSourceSelectionCriteriaArgsDict',
    'BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgs',
    'BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict',
    'BucketServerSideEncryptionRuleArgs',
    'BucketServerSideEncryptionRuleArgsDict',
    'BucketTransferAccelerationArgs',
    'BucketTransferAccelerationArgsDict',
    'BucketVersioningArgs',
    'BucketVersioningArgsDict',
    'BucketWebsiteArgs',
    'BucketWebsiteArgsDict',
    'BucketWebsiteErrorDocumentArgs',
    'BucketWebsiteErrorDocumentArgsDict',
    'BucketWebsiteIndexDocumentArgs',
    'BucketWebsiteIndexDocumentArgsDict',
    'BucketWebsiteRoutingRulesArgs',
    'BucketWebsiteRoutingRulesArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleArgs',
    'BucketWebsiteRoutingRulesRoutingRuleArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleConditionArgs',
    'BucketWebsiteRoutingRulesRoutingRuleConditionArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgs',
    'BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgs',
    'BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgsDict',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgs',
    'BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgsDict',
]

MYPY = False

if not MYPY:
    class BucketAccessMonitorArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        The access monitor state of a bucket. If you want to manage objects based on the last access time of the objects, specifies the status to `Enabled`. Valid values: `Enabled` and `Disabled`.
        """
elif False:
    BucketAccessMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAccessMonitorArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: The access monitor state of a bucket. If you want to manage objects based on the last access time of the objects, specifies the status to `Enabled`. Valid values: `Enabled` and `Disabled`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The access monitor state of a bucket. If you want to manage objects based on the last access time of the objects, specifies the status to `Enabled`. Valid values: `Enabled` and `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketCnameCertificateArgsDict(TypedDict):
        cert_id: NotRequired[pulumi.Input[str]]
        """
        Certificate Identifier
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        The certificate public key.
        """
        creation_date: NotRequired[pulumi.Input[str]]
        """
        Certificate creation time
        """
        fingerprint: NotRequired[pulumi.Input[str]]
        """
        Certificate Fingerprint
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        The certificate private key.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Cname status
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Certificate Type
        """
        valid_end_date: NotRequired[pulumi.Input[str]]
        """
        Certificate validity period end time
        """
        valid_start_date: NotRequired[pulumi.Input[str]]
        """
        Certificate validity period start time
        """
elif False:
    BucketCnameCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCnameCertificateArgs:
    def __init__(__self__, *,
                 cert_id: Optional[pulumi.Input[str]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 creation_date: Optional[pulumi.Input[str]] = None,
                 fingerprint: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 valid_end_date: Optional[pulumi.Input[str]] = None,
                 valid_start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cert_id: Certificate Identifier
        :param pulumi.Input[str] certificate: The certificate public key.
        :param pulumi.Input[str] creation_date: Certificate creation time
        :param pulumi.Input[str] fingerprint: Certificate Fingerprint
        :param pulumi.Input[str] private_key: The certificate private key.
        :param pulumi.Input[str] status: Cname status
        :param pulumi.Input[str] type: Certificate Type
        :param pulumi.Input[str] valid_end_date: Certificate validity period end time
        :param pulumi.Input[str] valid_start_date: Certificate validity period start time
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_end_date is not None:
            pulumi.set(__self__, "valid_end_date", valid_end_date)
        if valid_start_date is not None:
            pulumi.set(__self__, "valid_start_date", valid_start_date)

    @property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate Identifier
        """
        return pulumi.get(self, "cert_id")

    @cert_id.setter
    def cert_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert_id", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate public key.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate creation time
        """
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_date", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate Fingerprint
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Cname status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="validEndDate")
    def valid_end_date(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate validity period end time
        """
        return pulumi.get(self, "valid_end_date")

    @valid_end_date.setter
    def valid_end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_end_date", value)

    @property
    @pulumi.getter(name="validStartDate")
    def valid_start_date(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate validity period start time
        """
        return pulumi.get(self, "valid_start_date")

    @valid_start_date.setter
    def valid_start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_start_date", value)


if not MYPY:
    class BucketCorsCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The cross-origin request method that is allowed. Valid values: GET, PUT, DELETE, POST, and HEAD.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies whether the headers specified by Access-Control-Request-Headers in the OPTIONS preflight request are allowed. You can use only one asterisk (*) as the wildcard for allowed header. .
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The origins from which cross-origin requests are allowed. .
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The response headers for allowed access requests from applications, such as an XMLHttpRequest object in JavaScript. .
        """
        max_age_seconds: NotRequired[pulumi.Input[int]]
        """
        The period of time within which the browser can cache the response to an OPTIONS preflight request for the specified resource. Unit: seconds.
        """
elif False:
    BucketCorsCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCorsCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: The cross-origin request method that is allowed. Valid values: GET, PUT, DELETE, POST, and HEAD.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Specifies whether the headers specified by Access-Control-Request-Headers in the OPTIONS preflight request are allowed. You can use only one asterisk (*) as the wildcard for allowed header. .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: The origins from which cross-origin requests are allowed. .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The response headers for allowed access requests from applications, such as an XMLHttpRequest object in JavaScript. .
        :param pulumi.Input[int] max_age_seconds: The period of time within which the browser can cache the response to an OPTIONS preflight request for the specified resource. Unit: seconds.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The cross-origin request method that is allowed. Valid values: GET, PUT, DELETE, POST, and HEAD.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies whether the headers specified by Access-Control-Request-Headers in the OPTIONS preflight request are allowed. You can use only one asterisk (*) as the wildcard for allowed header. .
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The origins from which cross-origin requests are allowed. .
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The response headers for allowed access requests from applications, such as an XMLHttpRequest object in JavaScript. .
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The period of time within which the browser can cache the response to an OPTIONS preflight request for the specified resource. Unit: seconds.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class BucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies which origins are allowed.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies which headers are allowed.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies expose header in the response.
        """
        max_age_seconds: NotRequired[pulumi.Input[int]]
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
elif False:
    BucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies which origins are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Specifies which headers are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Specifies expose header in the response.
        :param pulumi.Input[int] max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies which methods are allowed. Can be GET, PUT, POST, DELETE or HEAD.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies expose header in the response.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class BucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Specifies lifecycle rule status.
        """
        abort_multipart_uploads: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleAbortMultipartUploadArgsDict']]]]
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed. See `abort_multipart_upload` below.
        """
        expirations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleExpirationArgsDict']]]]
        """
        Specifies a period in the object's expire. See `expiration` below.
        """
        filter: NotRequired[pulumi.Input['BucketLifecycleRuleFilterArgsDict']]
        """
        Configuration block used to identify objects that a Lifecycle rule applies to. See `filter` below.

        `NOTE`: At least one of expiration, transitions, abort_multipart_upload, noncurrent_version_expiration and noncurrent_version_transition should be configured.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the rule. If omitted, OSS bucket will assign a unique name.
        """
        noncurrent_version_expirations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgsDict']]]]
        """
        Specifies when noncurrent object versions expire. See `noncurrent_version_expiration` below.
        """
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgsDict']]]]
        """
        Specifies when noncurrent object versions transitions. See `noncurrent_version_transition` below.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix in the names of the objects to which the lifecycle rule does not apply.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgsDict']]]]
        """
        Specifies the time when an object is converted to the IA or archive storage class during a valid life cycle. See `transitions` below.
        """
elif False:
    BucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 abort_multipart_uploads: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleAbortMultipartUploadArgs']]]] = None,
                 expirations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleExpirationArgs']]]] = None,
                 filter: Optional[pulumi.Input['BucketLifecycleRuleFilterArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 noncurrent_version_expirations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']]]] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleAbortMultipartUploadArgs']]] abort_multipart_uploads: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed. See `abort_multipart_upload` below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleExpirationArgs']]] expirations: Specifies a period in the object's expire. See `expiration` below.
        :param pulumi.Input['BucketLifecycleRuleFilterArgs'] filter: Configuration block used to identify objects that a Lifecycle rule applies to. See `filter` below.
               
               `NOTE`: At least one of expiration, transitions, abort_multipart_upload, noncurrent_version_expiration and noncurrent_version_transition should be configured.
        :param pulumi.Input[str] id: Unique identifier for the rule. If omitted, OSS bucket will assign a unique name.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']]] noncurrent_version_expirations: Specifies when noncurrent object versions expire. See `noncurrent_version_expiration` below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]] noncurrent_version_transitions: Specifies when noncurrent object versions transitions. See `noncurrent_version_transition` below.
        :param pulumi.Input[str] prefix: The prefix in the names of the objects to which the lifecycle rule does not apply.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]] transitions: Specifies the time when an object is converted to the IA or archive storage class during a valid life cycle. See `transitions` below.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_multipart_uploads is not None:
            pulumi.set(__self__, "abort_multipart_uploads", abort_multipart_uploads)
        if expirations is not None:
            pulumi.set(__self__, "expirations", expirations)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expirations is not None:
            pulumi.set(__self__, "noncurrent_version_expirations", noncurrent_version_expirations)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="abortMultipartUploads")
    def abort_multipart_uploads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleAbortMultipartUploadArgs']]]]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed. See `abort_multipart_upload` below.
        """
        return pulumi.get(self, "abort_multipart_uploads")

    @abort_multipart_uploads.setter
    def abort_multipart_uploads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleAbortMultipartUploadArgs']]]]):
        pulumi.set(self, "abort_multipart_uploads", value)

    @property
    @pulumi.getter
    def expirations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleExpirationArgs']]]]:
        """
        Specifies a period in the object's expire. See `expiration` below.
        """
        return pulumi.get(self, "expirations")

    @expirations.setter
    def expirations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleExpirationArgs']]]]):
        pulumi.set(self, "expirations", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketLifecycleRuleFilterArgs']]:
        """
        Configuration block used to identify objects that a Lifecycle rule applies to. See `filter` below.

        `NOTE`: At least one of expiration, transitions, abort_multipart_upload, noncurrent_version_expiration and noncurrent_version_transition should be configured.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketLifecycleRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the rule. If omitted, OSS bucket will assign a unique name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpirations")
    def noncurrent_version_expirations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']]]]:
        """
        Specifies when noncurrent object versions expire. See `noncurrent_version_expiration` below.
        """
        return pulumi.get(self, "noncurrent_version_expirations")

    @noncurrent_version_expirations.setter
    def noncurrent_version_expirations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']]]]):
        pulumi.set(self, "noncurrent_version_expirations", value)

    @property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]:
        """
        Specifies when noncurrent object versions transitions. See `noncurrent_version_transition` below.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix in the names of the objects to which the lifecycle rule does not apply.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]]]:
        """
        Specifies the time when an object is converted to the IA or archive storage class during a valid life cycle. See `transitions` below.
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class BucketLifecycleRuleAbortMultipartUploadArgsDict(TypedDict):
        created_before_date: NotRequired[pulumi.Input[str]]
        """
        Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days noncurrent object versions transition.
        """
elif False:
    BucketLifecycleRuleAbortMultipartUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleAbortMultipartUploadArgs:
    def __init__(__self__, *,
                 created_before_date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] created_before_date: Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions transition.
        """
        if created_before_date is not None:
            pulumi.set(__self__, "created_before_date", created_before_date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="createdBeforeDate")
    def created_before_date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        """
        return pulumi.get(self, "created_before_date")

    @created_before_date.setter
    def created_before_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_before_date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleRuleExpirationArgsDict(TypedDict):
        created_before_date: NotRequired[pulumi.Input[str]]
        """
        Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        """
        date: NotRequired[pulumi.Input[str]]
        """
        Specifies the date after which you want the corresponding action to take effect. The value obeys ISO8601 format like `2017-03-09`.
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days noncurrent object versions transition.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[bool]]
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct OSS to delete expired object delete markers. This cannot be specified with Days, Date or CreatedBeforeDate in a Lifecycle Expiration Policy.

        `NOTE`: One and only one of "date", "days", "created_before_date" and "expired_object_delete_marker" can be specified in one expiration configuration.
        """
elif False:
    BucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 created_before_date: Optional[pulumi.Input[str]] = None,
                 date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] created_before_date: Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        :param pulumi.Input[str] date: Specifies the date after which you want the corresponding action to take effect. The value obeys ISO8601 format like `2017-03-09`.
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions transition.
        :param pulumi.Input[bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct OSS to delete expired object delete markers. This cannot be specified with Days, Date or CreatedBeforeDate in a Lifecycle Expiration Policy.
               
               `NOTE`: One and only one of "date", "days", "created_before_date" and "expired_object_delete_marker" can be specified in one expiration configuration.
        """
        if created_before_date is not None:
            pulumi.set(__self__, "created_before_date", created_before_date)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter(name="createdBeforeDate")
    def created_before_date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        """
        return pulumi.get(self, "created_before_date")

    @created_before_date.setter
    def created_before_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_before_date", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the date after which you want the corresponding action to take effect. The value obeys ISO8601 format like `2017-03-09`.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct OSS to delete expired object delete markers. This cannot be specified with Days, Date or CreatedBeforeDate in a Lifecycle Expiration Policy.

        `NOTE`: One and only one of "date", "days", "created_before_date" and "expired_object_delete_marker" can be specified in one expiration configuration.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class BucketLifecycleRuleFilterArgsDict(TypedDict):
        not_: NotRequired[pulumi.Input['BucketLifecycleRuleFilterNotArgsDict']]
        """
        The condition that is matched by objects to which the lifecycle rule does not apply. See `not` below.
        """
        object_size_greater_than: NotRequired[pulumi.Input[int]]
        """
        Minimum object size (in bytes) to which the rule applies.
        """
        object_size_less_than: NotRequired[pulumi.Input[int]]
        """
        Maximum object size (in bytes) to which the rule applies.
        """
elif False:
    BucketLifecycleRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleFilterArgs:
    def __init__(__self__, *,
                 not_: Optional[pulumi.Input['BucketLifecycleRuleFilterNotArgs']] = None,
                 object_size_greater_than: Optional[pulumi.Input[int]] = None,
                 object_size_less_than: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['BucketLifecycleRuleFilterNotArgs'] not_: The condition that is matched by objects to which the lifecycle rule does not apply. See `not` below.
        :param pulumi.Input[int] object_size_greater_than: Minimum object size (in bytes) to which the rule applies.
        :param pulumi.Input[int] object_size_less_than: Maximum object size (in bytes) to which the rule applies.
        """
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['BucketLifecycleRuleFilterNotArgs']]:
        """
        The condition that is matched by objects to which the lifecycle rule does not apply. See `not` below.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['BucketLifecycleRuleFilterNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum object size (in bytes) to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum object size (in bytes) to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_size_less_than", value)


if not MYPY:
    class BucketLifecycleRuleFilterNotArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix in the names of the objects to which the lifecycle rule does not apply.
        """
        tag: NotRequired[pulumi.Input['BucketLifecycleRuleFilterNotTagArgsDict']]
        """
        The tag of the objects to which the lifecycle rule does not apply. See `tag` below.
        """
elif False:
    BucketLifecycleRuleFilterNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleFilterNotArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input['BucketLifecycleRuleFilterNotTagArgs']] = None):
        """
        :param pulumi.Input[str] prefix: The prefix in the names of the objects to which the lifecycle rule does not apply.
        :param pulumi.Input['BucketLifecycleRuleFilterNotTagArgs'] tag: The tag of the objects to which the lifecycle rule does not apply. See `tag` below.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix in the names of the objects to which the lifecycle rule does not apply.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BucketLifecycleRuleFilterNotTagArgs']]:
        """
        The tag of the objects to which the lifecycle rule does not apply. See `tag` below.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BucketLifecycleRuleFilterNotTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BucketLifecycleRuleFilterNotTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the tag that is specified for the objects.
        """
        value: pulumi.Input[str]
        """
        The value of the tag that is specified for the objects.
        """
elif False:
    BucketLifecycleRuleFilterNotTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleFilterNotTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the tag that is specified for the objects.
        :param pulumi.Input[str] value: The value of the tag that is specified for the objects.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the tag that is specified for the objects.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the tag that is specified for the objects.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BucketLifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: pulumi.Input[int]
        """
        Specifies the number of days noncurrent object versions transition.
        """
elif False:
    BucketLifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions transition.
        """
        pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[int]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleRuleNoncurrentVersionTransitionArgsDict(TypedDict):
        days: pulumi.Input[int]
        """
        Specifies the number of days noncurrent object versions transition.
        """
        storage_class: pulumi.Input[str]
        """
        The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive", "ColdArchive" and "DeepColdArchive". Defaults to "Standard". "ColdArchive" is available since 1.203.0. "DeepColdArchive" is available since 1.209.0.
        """
        is_access_time: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the lifecycle rule applies to objects based on their last access time. If set to `true`, the rule applies to objects based on their last access time; if set to `false`, the rule applies to objects based on their last modified time. If configure the rule based on the last access time, please enable `access_monitor` first.
        """
        return_to_std_when_visit: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether to convert the storage class of non-Standard objects back to Standard after the objects are accessed. It takes effect only when the IsAccessTime parameter is set to true. If set to `true`, converts the storage class of the objects to Standard; if set to `false`, does not convert the storage class of the objects to Standard.
        """
elif False:
    BucketLifecycleRuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[int],
                 storage_class: pulumi.Input[str],
                 is_access_time: Optional[pulumi.Input[bool]] = None,
                 return_to_std_when_visit: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions transition.
        :param pulumi.Input[str] storage_class: The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive", "ColdArchive" and "DeepColdArchive". Defaults to "Standard". "ColdArchive" is available since 1.203.0. "DeepColdArchive" is available since 1.209.0.
        :param pulumi.Input[bool] is_access_time: Specifies whether the lifecycle rule applies to objects based on their last access time. If set to `true`, the rule applies to objects based on their last access time; if set to `false`, the rule applies to objects based on their last modified time. If configure the rule based on the last access time, please enable `access_monitor` first.
        :param pulumi.Input[bool] return_to_std_when_visit: Specifies whether to convert the storage class of non-Standard objects back to Standard after the objects are accessed. It takes effect only when the IsAccessTime parameter is set to true. If set to `true`, converts the storage class of the objects to Standard; if set to `false`, does not convert the storage class of the objects to Standard.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "storage_class", storage_class)
        if is_access_time is not None:
            pulumi.set(__self__, "is_access_time", is_access_time)
        if return_to_std_when_visit is not None:
            pulumi.set(__self__, "return_to_std_when_visit", return_to_std_when_visit)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[int]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[int]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive", "ColdArchive" and "DeepColdArchive". Defaults to "Standard". "ColdArchive" is available since 1.203.0. "DeepColdArchive" is available since 1.209.0.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter(name="isAccessTime")
    def is_access_time(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the lifecycle rule applies to objects based on their last access time. If set to `true`, the rule applies to objects based on their last access time; if set to `false`, the rule applies to objects based on their last modified time. If configure the rule based on the last access time, please enable `access_monitor` first.
        """
        return pulumi.get(self, "is_access_time")

    @is_access_time.setter
    def is_access_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_access_time", value)

    @property
    @pulumi.getter(name="returnToStdWhenVisit")
    def return_to_std_when_visit(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to convert the storage class of non-Standard objects back to Standard after the objects are accessed. It takes effect only when the IsAccessTime parameter is set to true. If set to `true`, converts the storage class of the objects to Standard; if set to `false`, does not convert the storage class of the objects to Standard.
        """
        return pulumi.get(self, "return_to_std_when_visit")

    @return_to_std_when_visit.setter
    def return_to_std_when_visit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_to_std_when_visit", value)


if not MYPY:
    class BucketLifecycleRuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[str]
        """
        The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive", "ColdArchive" and "DeepColdArchive". Defaults to "Standard". "ColdArchive" is available since 1.203.0. "DeepColdArchive" is available since 1.209.0.
        """
        created_before_date: NotRequired[pulumi.Input[str]]
        """
        Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days noncurrent object versions transition.
        """
        is_access_time: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the lifecycle rule applies to objects based on their last access time. If set to `true`, the rule applies to objects based on their last access time; if set to `false`, the rule applies to objects based on their last modified time. If configure the rule based on the last access time, please enable `access_monitor` first.
        """
        return_to_std_when_visit: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether to convert the storage class of non-Standard objects back to Standard after the objects are accessed. It takes effect only when the IsAccessTime parameter is set to true. If set to `true`, converts the storage class of the objects to Standard; if set to `false`, does not convert the storage class of the objects to Standard.
        """
elif False:
    BucketLifecycleRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[str],
                 created_before_date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[int]] = None,
                 is_access_time: Optional[pulumi.Input[bool]] = None,
                 return_to_std_when_visit: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] storage_class: The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive", "ColdArchive" and "DeepColdArchive". Defaults to "Standard". "ColdArchive" is available since 1.203.0. "DeepColdArchive" is available since 1.209.0.
        :param pulumi.Input[str] created_before_date: Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        :param pulumi.Input[int] days: Specifies the number of days noncurrent object versions transition.
        :param pulumi.Input[bool] is_access_time: Specifies whether the lifecycle rule applies to objects based on their last access time. If set to `true`, the rule applies to objects based on their last access time; if set to `false`, the rule applies to objects based on their last modified time. If configure the rule based on the last access time, please enable `access_monitor` first.
        :param pulumi.Input[bool] return_to_std_when_visit: Specifies whether to convert the storage class of non-Standard objects back to Standard after the objects are accessed. It takes effect only when the IsAccessTime parameter is set to true. If set to `true`, converts the storage class of the objects to Standard; if set to `false`, does not convert the storage class of the objects to Standard.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if created_before_date is not None:
            pulumi.set(__self__, "created_before_date", created_before_date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if is_access_time is not None:
            pulumi.set(__self__, "is_access_time", is_access_time)
        if return_to_std_when_visit is not None:
            pulumi.set(__self__, "return_to_std_when_visit", return_to_std_when_visit)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The [storage class](https://www.alibabacloud.com/help/doc-detail/51374.htm) to apply. Can be "Standard", "IA", "Archive", "ColdArchive" and "DeepColdArchive". Defaults to "Standard". "ColdArchive" is available since 1.203.0. "DeepColdArchive" is available since 1.209.0.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter(name="createdBeforeDate")
    def created_before_date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time before which the rules take effect. The date must conform to the ISO8601 format and always be UTC 00:00. For example: 2002-10-11T00:00:00.000Z indicates that parts created before 2002-10-11T00:00:00.000Z are deleted, and parts created after this time (including this time) are not deleted.
        """
        return pulumi.get(self, "created_before_date")

    @created_before_date.setter
    def created_before_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_before_date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="isAccessTime")
    def is_access_time(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the lifecycle rule applies to objects based on their last access time. If set to `true`, the rule applies to objects based on their last access time; if set to `false`, the rule applies to objects based on their last modified time. If configure the rule based on the last access time, please enable `access_monitor` first.
        """
        return pulumi.get(self, "is_access_time")

    @is_access_time.setter
    def is_access_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_access_time", value)

    @property
    @pulumi.getter(name="returnToStdWhenVisit")
    def return_to_std_when_visit(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to convert the storage class of non-Standard objects back to Standard after the objects are accessed. It takes effect only when the IsAccessTime parameter is set to true. If set to `true`, converts the storage class of the objects to Standard; if set to `false`, does not convert the storage class of the objects to Standard.
        """
        return pulumi.get(self, "return_to_std_when_visit")

    @return_to_std_when_visit.setter
    def return_to_std_when_visit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_to_std_when_visit", value)


if not MYPY:
    class BucketLoggingArgsDict(TypedDict):
        target_bucket: pulumi.Input[str]
        """
        The name of the bucket that will receive the log objects.
        """
        target_prefix: NotRequired[pulumi.Input[str]]
        """
        To specify a key prefix for log objects.
        """
elif False:
    BucketLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingArgs:
    def __init__(__self__, *,
                 target_bucket: pulumi.Input[str],
                 target_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_bucket: The name of the bucket that will receive the log objects.
        :param pulumi.Input[str] target_prefix: To specify a key prefix for log objects.
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> pulumi.Input[str]:
        """
        The name of the bucket that will receive the log objects.
        """
        return pulumi.get(self, "target_bucket")

    @target_bucket.setter
    def target_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_bucket", value)

    @property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        To specify a key prefix for log objects.
        """
        return pulumi.get(self, "target_prefix")

    @target_prefix.setter
    def target_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_prefix", value)


if not MYPY:
    class BucketRefererConfigArgsDict(TypedDict):
        referers: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of referer.
        """
        allow_empty: NotRequired[pulumi.Input[bool]]
        """
        Allows referer to be empty. Defaults false.
        """
elif False:
    BucketRefererConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketRefererConfigArgs:
    def __init__(__self__, *,
                 referers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allow_empty: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] referers: The list of referer.
        :param pulumi.Input[bool] allow_empty: Allows referer to be empty. Defaults false.
        """
        pulumi.set(__self__, "referers", referers)
        if allow_empty is not None:
            pulumi.set(__self__, "allow_empty", allow_empty)

    @property
    @pulumi.getter
    def referers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of referer.
        """
        return pulumi.get(self, "referers")

    @referers.setter
    def referers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "referers", value)

    @property
    @pulumi.getter(name="allowEmpty")
    def allow_empty(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows referer to be empty. Defaults false.
        """
        return pulumi.get(self, "allow_empty")

    @allow_empty.setter
    def allow_empty(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_empty", value)


if not MYPY:
    class BucketReplicationDestinationArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        The destination bucket to which the data is replicated.
        """
        location: pulumi.Input[str]
        """
        The region in which the destination bucket is located.
        """
        transfer_type: NotRequired[pulumi.Input[str]]
        """
        The link used to transfer data in data replication.. Can be `internal` or `oss_acc`. Defaults to `internal`.

        `NOTE`: You can set transfer_type to oss_acc only when you create cross-region replication (CRR) rules.
        """
elif False:
    BucketReplicationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationDestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 location: pulumi.Input[str],
                 transfer_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The destination bucket to which the data is replicated.
        :param pulumi.Input[str] location: The region in which the destination bucket is located.
        :param pulumi.Input[str] transfer_type: The link used to transfer data in data replication.. Can be `internal` or `oss_acc`. Defaults to `internal`.
               
               `NOTE`: You can set transfer_type to oss_acc only when you create cross-region replication (CRR) rules.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location", location)
        if transfer_type is not None:
            pulumi.set(__self__, "transfer_type", transfer_type)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The destination bucket to which the data is replicated.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        The region in which the destination bucket is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="transferType")
    def transfer_type(self) -> Optional[pulumi.Input[str]]:
        """
        The link used to transfer data in data replication.. Can be `internal` or `oss_acc`. Defaults to `internal`.

        `NOTE`: You can set transfer_type to oss_acc only when you create cross-region replication (CRR) rules.
        """
        return pulumi.get(self, "transfer_type")

    @transfer_type.setter
    def transfer_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transfer_type", value)


if not MYPY:
    class BucketReplicationEncryptionConfigurationArgsDict(TypedDict):
        replica_kms_key_id: pulumi.Input[str]
        """
        The CMK ID used in SSE-KMS.

        `NOTE`: If the status of sse_kms_encrypted_objects is set to Enabled, you must specify the replica_kms_key_id.
        """
elif False:
    BucketReplicationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 replica_kms_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] replica_kms_key_id: The CMK ID used in SSE-KMS.
               
               `NOTE`: If the status of sse_kms_encrypted_objects is set to Enabled, you must specify the replica_kms_key_id.
        """
        pulumi.set(__self__, "replica_kms_key_id", replica_kms_key_id)

    @property
    @pulumi.getter(name="replicaKmsKeyId")
    def replica_kms_key_id(self) -> pulumi.Input[str]:
        """
        The CMK ID used in SSE-KMS.

        `NOTE`: If the status of sse_kms_encrypted_objects is set to Enabled, you must specify the replica_kms_key_id.
        """
        return pulumi.get(self, "replica_kms_key_id")

    @replica_kms_key_id.setter
    def replica_kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "replica_kms_key_id", value)


if not MYPY:
    class BucketReplicationPrefixSetArgsDict(TypedDict):
        prefixes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of object key name prefix identifying one or more objects to which the rule applies.

        `NOTE`: The prefix must be less than or equal to 1024 characters in length.
        """
elif False:
    BucketReplicationPrefixSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationPrefixSetArgs:
    def __init__(__self__, *,
                 prefixes: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefixes: The list of object key name prefix identifying one or more objects to which the rule applies.
               
               `NOTE`: The prefix must be less than or equal to 1024 characters in length.
        """
        pulumi.set(__self__, "prefixes", prefixes)

    @property
    @pulumi.getter
    def prefixes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of object key name prefix identifying one or more objects to which the rule applies.

        `NOTE`: The prefix must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "prefixes", value)


if not MYPY:
    class BucketReplicationProgressArgsDict(TypedDict):
        historical_object: NotRequired[pulumi.Input[str]]
        """
        The percentage of the replicated historical data. This element is valid only when historical_object_replication is set to enabled.
        """
        new_object: NotRequired[pulumi.Input[str]]
        """
        The time used to distinguish new data from historical data. Data that is written to the source bucket before the time is replicated to the destination bucket as new data. The value of this element is in GMT.
        """
elif False:
    BucketReplicationProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationProgressArgs:
    def __init__(__self__, *,
                 historical_object: Optional[pulumi.Input[str]] = None,
                 new_object: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] historical_object: The percentage of the replicated historical data. This element is valid only when historical_object_replication is set to enabled.
        :param pulumi.Input[str] new_object: The time used to distinguish new data from historical data. Data that is written to the source bucket before the time is replicated to the destination bucket as new data. The value of this element is in GMT.
        """
        if historical_object is not None:
            pulumi.set(__self__, "historical_object", historical_object)
        if new_object is not None:
            pulumi.set(__self__, "new_object", new_object)

    @property
    @pulumi.getter(name="historicalObject")
    def historical_object(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of the replicated historical data. This element is valid only when historical_object_replication is set to enabled.
        """
        return pulumi.get(self, "historical_object")

    @historical_object.setter
    def historical_object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "historical_object", value)

    @property
    @pulumi.getter(name="newObject")
    def new_object(self) -> Optional[pulumi.Input[str]]:
        """
        The time used to distinguish new data from historical data. Data that is written to the source bucket before the time is replicated to the destination bucket as new data. The value of this element is in GMT.
        """
        return pulumi.get(self, "new_object")

    @new_object.setter
    def new_object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_object", value)


if not MYPY:
    class BucketReplicationSourceSelectionCriteriaArgsDict(TypedDict):
        sse_kms_encrypted_objects: NotRequired[pulumi.Input['BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict']]
        """
        Filter source objects encrypted by using SSE-KMS. See `sse_kms_encrypted_objects` below.
        """
elif False:
    BucketReplicationSourceSelectionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationSourceSelectionCriteriaArgs:
    def __init__(__self__, *,
                 sse_kms_encrypted_objects: Optional[pulumi.Input['BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']] = None):
        """
        :param pulumi.Input['BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgs'] sse_kms_encrypted_objects: Filter source objects encrypted by using SSE-KMS. See `sse_kms_encrypted_objects` below.
        """
        if sse_kms_encrypted_objects is not None:
            pulumi.set(__self__, "sse_kms_encrypted_objects", sse_kms_encrypted_objects)

    @property
    @pulumi.getter(name="sseKmsEncryptedObjects")
    def sse_kms_encrypted_objects(self) -> Optional[pulumi.Input['BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']]:
        """
        Filter source objects encrypted by using SSE-KMS. See `sse_kms_encrypted_objects` below.
        """
        return pulumi.get(self, "sse_kms_encrypted_objects")

    @sse_kms_encrypted_objects.setter
    def sse_kms_encrypted_objects(self, value: Optional[pulumi.Input['BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']]):
        pulumi.set(self, "sse_kms_encrypted_objects", value)


if not MYPY:
    class BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        The status of the data replication task. Can be starting, doing and closing.
        """
elif False:
    BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjectsArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: The status of the data replication task. Can be starting, doing and closing.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the data replication task. Can be starting, doing and closing.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketServerSideEncryptionRuleArgsDict(TypedDict):
        sse_algorithm: pulumi.Input[str]
        """
        The server-side encryption algorithm to use. Possible values: `AES256` and `KMS`.
        """
        kms_master_key_id: NotRequired[pulumi.Input[str]]
        """
        The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
        """
elif False:
    BucketServerSideEncryptionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketServerSideEncryptionRuleArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input[str],
                 kms_master_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] sse_algorithm: The server-side encryption algorithm to use. Possible values: `AES256` and `KMS`.
        :param pulumi.Input[str] kms_master_key_id: The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)

    @property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[str]:
        """
        The server-side encryption algorithm to use. Possible values: `AES256` and `KMS`.
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "sse_algorithm", value)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The alibaba cloud KMS master key ID used for the SSE-KMS encryption.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_master_key_id", value)


if not MYPY:
    class BucketTransferAccelerationArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Specifies the accelerate status of a bucket.
        """
elif False:
    BucketTransferAccelerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketTransferAccelerationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Specifies the accelerate status of a bucket.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies the accelerate status of a bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BucketVersioningArgsDict(TypedDict):
        status: pulumi.Input[str]
        """
        Specifies the versioning state of a bucket. Valid values: `Enabled` and `Suspended`.
        """
elif False:
    BucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketVersioningArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str]):
        """
        :param pulumi.Input[str] status: Specifies the versioning state of a bucket. Valid values: `Enabled` and `Suspended`.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Specifies the versioning state of a bucket. Valid values: `Enabled` and `Suspended`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketWebsiteArgsDict(TypedDict):
        index_document: pulumi.Input[str]
        """
        Alicloud OSS returns this index document when requests are made to the root domain or any of the subfolders.
        """
        error_document: NotRequired[pulumi.Input[str]]
        """
        An absolute path to the document to return in case of a 4XX error.
        """
elif False:
    BucketWebsiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteArgs:
    def __init__(__self__, *,
                 index_document: pulumi.Input[str],
                 error_document: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index_document: Alicloud OSS returns this index document when requests are made to the root domain or any of the subfolders.
        :param pulumi.Input[str] error_document: An absolute path to the document to return in case of a 4XX error.
        """
        pulumi.set(__self__, "index_document", index_document)
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> pulumi.Input[str]:
        """
        Alicloud OSS returns this index document when requests are made to the root domain or any of the subfolders.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_document", value)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[str]]:
        """
        An absolute path to the document to return in case of a 4XX error.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_document", value)


if not MYPY:
    class BucketWebsiteErrorDocumentArgsDict(TypedDict):
        http_status: NotRequired[pulumi.Input[int]]
        """
        The HTTP status code when the error page is returned. The default 404.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        The error page file. If the Object accessed does not exist, this error page is returned.
        """
elif False:
    BucketWebsiteErrorDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteErrorDocumentArgs:
    def __init__(__self__, *,
                 http_status: Optional[pulumi.Input[int]] = None,
                 key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] http_status: The HTTP status code when the error page is returned. The default 404.
        :param pulumi.Input[str] key: The error page file. If the Object accessed does not exist, this error page is returned.
        """
        if http_status is not None:
            pulumi.set(__self__, "http_status", http_status)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="httpStatus")
    def http_status(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP status code when the error page is returned. The default 404.
        """
        return pulumi.get(self, "http_status")

    @http_status.setter
    def http_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_status", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The error page file. If the Object accessed does not exist, this error page is returned.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class BucketWebsiteIndexDocumentArgsDict(TypedDict):
        suffix: NotRequired[pulumi.Input[str]]
        """
        The default home page.
        """
        support_sub_dir: NotRequired[pulumi.Input[bool]]
        """
        Whether to jump to the default home page of a subdirectory when accessing a subdirectory.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        After the default homepage is set, the behavior when an Object that ends with a non-forward slash (/) is accessed and the Object does not exist.
        """
elif False:
    BucketWebsiteIndexDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteIndexDocumentArgs:
    def __init__(__self__, *,
                 suffix: Optional[pulumi.Input[str]] = None,
                 support_sub_dir: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] suffix: The default home page.
        :param pulumi.Input[bool] support_sub_dir: Whether to jump to the default home page of a subdirectory when accessing a subdirectory.
        :param pulumi.Input[str] type: After the default homepage is set, the behavior when an Object that ends with a non-forward slash (/) is accessed and the Object does not exist.
        """
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if support_sub_dir is not None:
            pulumi.set(__self__, "support_sub_dir", support_sub_dir)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The default home page.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)

    @property
    @pulumi.getter(name="supportSubDir")
    def support_sub_dir(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to jump to the default home page of a subdirectory when accessing a subdirectory.
        """
        return pulumi.get(self, "support_sub_dir")

    @support_sub_dir.setter
    def support_sub_dir(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_sub_dir", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        After the default homepage is set, the behavior when an Object that ends with a non-forward slash (/) is accessed and the Object does not exist.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class BucketWebsiteRoutingRulesArgsDict(TypedDict):
        routing_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleArgsDict']]]]
        """
        Specify a jump rule or a mirroring back-to-origin rule, with a maximum of 20 routing rules. See `routing_rule` below.
        """
elif False:
    BucketWebsiteRoutingRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesArgs:
    def __init__(__self__, *,
                 routing_rules: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleArgs']]] routing_rules: Specify a jump rule or a mirroring back-to-origin rule, with a maximum of 20 routing rules. See `routing_rule` below.
        """
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleArgs']]]]:
        """
        Specify a jump rule or a mirroring back-to-origin rule, with a maximum of 20 routing rules. See `routing_rule` below.
        """
        return pulumi.get(self, "routing_rules")

    @routing_rules.setter
    def routing_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleArgs']]]]):
        pulumi.set(self, "routing_rules", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionArgsDict']]
        """
        Save the criteria that the rule needs to match. See `condition` below.
        """
        lua_config: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgsDict']]
        """
        The Lua script configuration to be executed. See `lua_config` below.
        """
        redirect: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectArgsDict']]
        """
        Specifies the action to perform after this rule is matched. See `redirect` below.
        """
        rule_number: NotRequired[pulumi.Input[int]]
        """
        The sequence number of the matching and executing jump rules. OSS matches rules according to this sequence number. If the match is successful, the rule is executed and subsequent rules are not executed.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionArgs']] = None,
                 lua_config: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgs']] = None,
                 redirect: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectArgs']] = None,
                 rule_number: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionArgs'] condition: Save the criteria that the rule needs to match. See `condition` below.
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgs'] lua_config: The Lua script configuration to be executed. See `lua_config` below.
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectArgs'] redirect: Specifies the action to perform after this rule is matched. See `redirect` below.
        :param pulumi.Input[int] rule_number: The sequence number of the matching and executing jump rules. OSS matches rules according to this sequence number. If the match is successful, the rule is executed and subsequent rules are not executed.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if lua_config is not None:
            pulumi.set(__self__, "lua_config", lua_config)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionArgs']]:
        """
        Save the criteria that the rule needs to match. See `condition` below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="luaConfig")
    def lua_config(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgs']]:
        """
        The Lua script configuration to be executed. See `lua_config` below.
        """
        return pulumi.get(self, "lua_config")

    @lua_config.setter
    def lua_config(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgs']]):
        pulumi.set(self, "lua_config", value)

    @property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectArgs']]:
        """
        Specifies the action to perform after this rule is matched. See `redirect` below.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectArgs']]):
        pulumi.set(self, "redirect", value)

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[pulumi.Input[int]]:
        """
        The sequence number of the matching and executing jump rules. OSS matches rules according to this sequence number. If the match is successful, the rule is executed and subsequent rules are not executed.
        """
        return pulumi.get(self, "rule_number")

    @rule_number.setter
    def rule_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rule_number", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleConditionArgsDict(TypedDict):
        http_error_code_returned_equals: NotRequired[pulumi.Input[str]]
        """
        When the specified Object is accessed, this status is returned to match this rule. This field must be 404 when the jump rule is mirrored back to the source.
        """
        include_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgsDict']]]]
        """
        This rule can only be matched if the request contains the specified Header and the value is the specified value. You can specify up to 10 containers. See `include_headers` below.
        """
        key_prefix_equals: NotRequired[pulumi.Input[str]]
        """
        Only objects that match this prefix can match this rule.
        """
        key_suffix_equals: NotRequired[pulumi.Input[str]]
        """
        Only objects that match this suffix can match this rule.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleConditionArgs:
    def __init__(__self__, *,
                 http_error_code_returned_equals: Optional[pulumi.Input[str]] = None,
                 include_headers: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgs']]]] = None,
                 key_prefix_equals: Optional[pulumi.Input[str]] = None,
                 key_suffix_equals: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_error_code_returned_equals: When the specified Object is accessed, this status is returned to match this rule. This field must be 404 when the jump rule is mirrored back to the source.
        :param pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgs']]] include_headers: This rule can only be matched if the request contains the specified Header and the value is the specified value. You can specify up to 10 containers. See `include_headers` below.
        :param pulumi.Input[str] key_prefix_equals: Only objects that match this prefix can match this rule.
        :param pulumi.Input[str] key_suffix_equals: Only objects that match this suffix can match this rule.
        """
        if http_error_code_returned_equals is not None:
            pulumi.set(__self__, "http_error_code_returned_equals", http_error_code_returned_equals)
        if include_headers is not None:
            pulumi.set(__self__, "include_headers", include_headers)
        if key_prefix_equals is not None:
            pulumi.set(__self__, "key_prefix_equals", key_prefix_equals)
        if key_suffix_equals is not None:
            pulumi.set(__self__, "key_suffix_equals", key_suffix_equals)

    @property
    @pulumi.getter(name="httpErrorCodeReturnedEquals")
    def http_error_code_returned_equals(self) -> Optional[pulumi.Input[str]]:
        """
        When the specified Object is accessed, this status is returned to match this rule. This field must be 404 when the jump rule is mirrored back to the source.
        """
        return pulumi.get(self, "http_error_code_returned_equals")

    @http_error_code_returned_equals.setter
    def http_error_code_returned_equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_error_code_returned_equals", value)

    @property
    @pulumi.getter(name="includeHeaders")
    def include_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgs']]]]:
        """
        This rule can only be matched if the request contains the specified Header and the value is the specified value. You can specify up to 10 containers. See `include_headers` below.
        """
        return pulumi.get(self, "include_headers")

    @include_headers.setter
    def include_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgs']]]]):
        pulumi.set(self, "include_headers", value)

    @property
    @pulumi.getter(name="keyPrefixEquals")
    def key_prefix_equals(self) -> Optional[pulumi.Input[str]]:
        """
        Only objects that match this prefix can match this rule.
        """
        return pulumi.get(self, "key_prefix_equals")

    @key_prefix_equals.setter
    def key_prefix_equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_prefix_equals", value)

    @property
    @pulumi.getter(name="keySuffixEquals")
    def key_suffix_equals(self) -> Optional[pulumi.Input[str]]:
        """
        Only objects that match this suffix can match this rule.
        """
        return pulumi.get(self, "key_suffix_equals")

    @key_suffix_equals.setter
    def key_suffix_equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_suffix_equals", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgsDict(TypedDict):
        ends_with: NotRequired[pulumi.Input[str]]
        """
        This rule can only be matched if the request contains the Header specified by Key and the value ends with this value.
        """
        equals: NotRequired[pulumi.Input[str]]
        """
        This rule can only be matched if the request contains the Header specified by Key and the value is the specified value.
        """
        key: NotRequired[pulumi.Input[str]]
        starts_with: NotRequired[pulumi.Input[str]]
        """
        This rule can only be matched if the request contains the Header specified by Key and the value starts with this value.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleConditionIncludeHeaderArgs:
    def __init__(__self__, *,
                 ends_with: Optional[pulumi.Input[str]] = None,
                 equals: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 starts_with: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ends_with: This rule can only be matched if the request contains the Header specified by Key and the value ends with this value.
        :param pulumi.Input[str] equals: This rule can only be matched if the request contains the Header specified by Key and the value is the specified value.
        :param pulumi.Input[str] starts_with: This rule can only be matched if the request contains the Header specified by Key and the value starts with this value.
        """
        if ends_with is not None:
            pulumi.set(__self__, "ends_with", ends_with)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)

    @property
    @pulumi.getter(name="endsWith")
    def ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        This rule can only be matched if the request contains the Header specified by Key and the value ends with this value.
        """
        return pulumi.get(self, "ends_with")

    @ends_with.setter
    def ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ends_with", value)

    @property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[str]]:
        """
        This rule can only be matched if the request contains the Header specified by Key and the value is the specified value.
        """
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "equals", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[pulumi.Input[str]]:
        """
        This rule can only be matched if the request contains the Header specified by Key and the value starts with this value.
        """
        return pulumi.get(self, "starts_with")

    @starts_with.setter
    def starts_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starts_with", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgsDict(TypedDict):
        script: NotRequired[pulumi.Input[str]]
        """
        The Lua script name.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleLuaConfigArgs:
    def __init__(__self__, *,
                 script: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] script: The Lua script name.
        """
        if script is not None:
            pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        The Lua script name.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectArgsDict(TypedDict):
        enable_replace_prefix: NotRequired[pulumi.Input[bool]]
        """
        If this field is set to true, the prefix of Object is replaced with the value specified by ReplaceKeyPrefixWith. If this field is not specified or is blank, the Object prefix is truncated.
        """
        host_name: NotRequired[pulumi.Input[str]]
        """
        The domain name during the jump. The domain name must comply with the domain name specification.
        """
        http_redirect_code: NotRequired[pulumi.Input[str]]
        """
        The status code returned during the jump. It takes effect only when the RedirectType is set to External or AliCDN.
        """
        mirror_allow_get_image_info: NotRequired[pulumi.Input[bool]]
        """
        Image back-to-source allows getting Image information
        """
        mirror_allow_head_object: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow HeadObject in image back-to-source
        """
        mirror_allow_video_snapshot: NotRequired[pulumi.Input[bool]]
        """
        Mirror back-to-source allows support for video frame truncation
        """
        mirror_async_status: NotRequired[pulumi.Input[int]]
        """
        The status code of the mirror back-to-source trigger asynchronous pull mode.
        """
        mirror_auth: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgsDict']]
        """
        Image back Source station authentication information See `mirror_auth` below.
        """
        mirror_check_md5: NotRequired[pulumi.Input[bool]]
        """
        Whether to check the MD5 of the source body. It takes effect only when the RedirectType is set to Mirror.
        """
        mirror_dst_region: NotRequired[pulumi.Input[str]]
        """
        Mirrored back-to-source high-speed Channel vpregion
        """
        mirror_dst_slave_vpc_id: NotRequired[pulumi.Input[str]]
        """
        Mirroring back-to-source high-speed Channel standby station VpcId
        """
        mirror_dst_vpc_id: NotRequired[pulumi.Input[str]]
        """
        Mirror back-to-source high-speed Channel VpcId
        """
        mirror_follow_redirect: NotRequired[pulumi.Input[bool]]
        """
        If the result of the image back-to-source acquisition is 3xx, whether to continue to jump to the specified Location to obtain data. It takes effect only when the RedirectType is set to Mirror.
        """
        mirror_headers: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgsDict']]
        """
        Specifies the Header carried when the image returns to the source. It takes effect only when the RedirectType is set to Mirror. See `mirror_headers` below.
        """
        mirror_is_express_tunnel: NotRequired[pulumi.Input[bool]]
        """
        Whether it is a mirror back-to-source high-speed Channel
        """
        mirror_multi_alternates: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgsDict']]
        """
        Mirror back-to-source multi-source station configuration container. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_multi_alternates` below.
        """
        mirror_pass_original_slashes: NotRequired[pulumi.Input[bool]]
        """
        Transparent transmission/to source Station
        """
        mirror_pass_query_string: NotRequired[pulumi.Input[bool]]
        """
        Same as PassQueryString and takes precedence over PassQueryString. It takes effect only when the RedirectType is set to Mirror.
        """
        mirror_proxy_pass: NotRequired[pulumi.Input[bool]]
        """
        Whether mirroring back to source does not save data
        """
        mirror_return_headers: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgsDict']]
        """
        The container that saves the image back to the source and returns the response header rule. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_return_headers` below.
        """
        mirror_role: NotRequired[pulumi.Input[str]]
        """
        Roles used when mirroring back-to-source
        """
        mirror_save_oss_meta: NotRequired[pulumi.Input[bool]]
        """
        Mirror back-to-source back-to-source OSS automatically saves user metadata
        """
        mirror_sni: NotRequired[pulumi.Input[bool]]
        """
        Transparent transmission of SNI
        """
        mirror_switch_all_errors: NotRequired[pulumi.Input[bool]]
        """
        It is used to judge the status of active-standby switching. The judgment logic of active-standby switching is that the source station returns an error. If MirrorSwitchAllErrors is true, it is considered a failure except the following status code: 200,206,301,302,303,307,404; If false, only the source Station Returns 5xx or times out is considered a failure.
        """
        mirror_taggings: NotRequired[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgsDict']]
        """
        Save the label according to the parameters when saving the file from the mirror back to the source. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_taggings` below.
        """
        mirror_tunnel_id: NotRequired[pulumi.Input[str]]
        """
        Mirror back-to-source leased line back-to-source tunnel ID
        """
        mirror_url: NotRequired[pulumi.Input[str]]
        """
        The address of the origin of the image. It takes effect only when the RedirectType is set to Mirror. The origin address must start with http:// or https:// and end with a forward slash (/). OSS takes the Object name after the Origin address to form the origin URL.
        """
        mirror_url_probe: NotRequired[pulumi.Input[str]]
        """
        Mirror back-to-source Master-backup back-to-source switching decision URL
        """
        mirror_url_slave: NotRequired[pulumi.Input[str]]
        """
        Mirror back-to-source primary backup back-to-source backup station URL
        """
        mirror_user_last_modified: NotRequired[pulumi.Input[bool]]
        """
        Whether the source station LastModifiedTime is used for the image back-to-source save file.
        """
        mirror_using_role: NotRequired[pulumi.Input[bool]]
        """
        Whether to use role for mirroring back to source
        """
        pass_query_string: NotRequired[pulumi.Input[bool]]
        """
        Whether to carry the request parameters when executing the jump or mirror back-to-source rule. Did the user carry the request parameters when requesting OSS? a = B & c = d, and set PassQueryString to true. If the rule is a 302 jump, this request parameter is added to the Location header of the jump. For example Location:example.com? a = B & c = d, and the jump type is mirrored back-to-origin, this request parameter is also carried in the back-to-origin request initiated. Values: true, false (default)
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        The protocol at the time of the jump. It takes effect only when the RedirectType is set to External or AliCDN.
        """
        redirect_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the type of jump. The value range is as follows: Mirror: Mirror back to the source. External: External redirects, that is, OSS returns a 3xx request to redirect to another address. AliCDN: Alibaba Cloud CDN jump, mainly used for Alibaba Cloud CDN. Unlike External, OSS adds an additional Header. After recognizing this Header, Alibaba Cloud CDN redirects the data to the specified address and returns the obtained data to the user instead of returning the 3xx Redirection request to the user.
        """
        replace_key_prefix_with: NotRequired[pulumi.Input[str]]
        """
        The prefix of the Object name will be replaced with this value during Redirect. If the prefix is empty, this string is inserted in front of the Object name.
        """
        replace_key_with: NotRequired[pulumi.Input[str]]
        """
        During redirection, the Object name is replaced with the value specified by ReplaceKeyWith. You can set variables in ReplaceKeyWith. Currently, the supported variable is ${key}, which indicates the name of the Object in the request.
        """
        transparent_mirror_response_codes: NotRequired[pulumi.Input[str]]
        """
        Mirror back-to-source transparent source station response code list
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectArgs:
    def __init__(__self__, *,
                 enable_replace_prefix: Optional[pulumi.Input[bool]] = None,
                 host_name: Optional[pulumi.Input[str]] = None,
                 http_redirect_code: Optional[pulumi.Input[str]] = None,
                 mirror_allow_get_image_info: Optional[pulumi.Input[bool]] = None,
                 mirror_allow_head_object: Optional[pulumi.Input[bool]] = None,
                 mirror_allow_video_snapshot: Optional[pulumi.Input[bool]] = None,
                 mirror_async_status: Optional[pulumi.Input[int]] = None,
                 mirror_auth: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgs']] = None,
                 mirror_check_md5: Optional[pulumi.Input[bool]] = None,
                 mirror_dst_region: Optional[pulumi.Input[str]] = None,
                 mirror_dst_slave_vpc_id: Optional[pulumi.Input[str]] = None,
                 mirror_dst_vpc_id: Optional[pulumi.Input[str]] = None,
                 mirror_follow_redirect: Optional[pulumi.Input[bool]] = None,
                 mirror_headers: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgs']] = None,
                 mirror_is_express_tunnel: Optional[pulumi.Input[bool]] = None,
                 mirror_multi_alternates: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgs']] = None,
                 mirror_pass_original_slashes: Optional[pulumi.Input[bool]] = None,
                 mirror_pass_query_string: Optional[pulumi.Input[bool]] = None,
                 mirror_proxy_pass: Optional[pulumi.Input[bool]] = None,
                 mirror_return_headers: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgs']] = None,
                 mirror_role: Optional[pulumi.Input[str]] = None,
                 mirror_save_oss_meta: Optional[pulumi.Input[bool]] = None,
                 mirror_sni: Optional[pulumi.Input[bool]] = None,
                 mirror_switch_all_errors: Optional[pulumi.Input[bool]] = None,
                 mirror_taggings: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgs']] = None,
                 mirror_tunnel_id: Optional[pulumi.Input[str]] = None,
                 mirror_url: Optional[pulumi.Input[str]] = None,
                 mirror_url_probe: Optional[pulumi.Input[str]] = None,
                 mirror_url_slave: Optional[pulumi.Input[str]] = None,
                 mirror_user_last_modified: Optional[pulumi.Input[bool]] = None,
                 mirror_using_role: Optional[pulumi.Input[bool]] = None,
                 pass_query_string: Optional[pulumi.Input[bool]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 redirect_type: Optional[pulumi.Input[str]] = None,
                 replace_key_prefix_with: Optional[pulumi.Input[str]] = None,
                 replace_key_with: Optional[pulumi.Input[str]] = None,
                 transparent_mirror_response_codes: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_replace_prefix: If this field is set to true, the prefix of Object is replaced with the value specified by ReplaceKeyPrefixWith. If this field is not specified or is blank, the Object prefix is truncated.
        :param pulumi.Input[str] host_name: The domain name during the jump. The domain name must comply with the domain name specification.
        :param pulumi.Input[str] http_redirect_code: The status code returned during the jump. It takes effect only when the RedirectType is set to External or AliCDN.
        :param pulumi.Input[bool] mirror_allow_get_image_info: Image back-to-source allows getting Image information
        :param pulumi.Input[bool] mirror_allow_head_object: Whether to allow HeadObject in image back-to-source
        :param pulumi.Input[bool] mirror_allow_video_snapshot: Mirror back-to-source allows support for video frame truncation
        :param pulumi.Input[int] mirror_async_status: The status code of the mirror back-to-source trigger asynchronous pull mode.
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgs'] mirror_auth: Image back Source station authentication information See `mirror_auth` below.
        :param pulumi.Input[bool] mirror_check_md5: Whether to check the MD5 of the source body. It takes effect only when the RedirectType is set to Mirror.
        :param pulumi.Input[str] mirror_dst_region: Mirrored back-to-source high-speed Channel vpregion
        :param pulumi.Input[str] mirror_dst_slave_vpc_id: Mirroring back-to-source high-speed Channel standby station VpcId
        :param pulumi.Input[str] mirror_dst_vpc_id: Mirror back-to-source high-speed Channel VpcId
        :param pulumi.Input[bool] mirror_follow_redirect: If the result of the image back-to-source acquisition is 3xx, whether to continue to jump to the specified Location to obtain data. It takes effect only when the RedirectType is set to Mirror.
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgs'] mirror_headers: Specifies the Header carried when the image returns to the source. It takes effect only when the RedirectType is set to Mirror. See `mirror_headers` below.
        :param pulumi.Input[bool] mirror_is_express_tunnel: Whether it is a mirror back-to-source high-speed Channel
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgs'] mirror_multi_alternates: Mirror back-to-source multi-source station configuration container. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_multi_alternates` below.
        :param pulumi.Input[bool] mirror_pass_original_slashes: Transparent transmission/to source Station
        :param pulumi.Input[bool] mirror_pass_query_string: Same as PassQueryString and takes precedence over PassQueryString. It takes effect only when the RedirectType is set to Mirror.
        :param pulumi.Input[bool] mirror_proxy_pass: Whether mirroring back to source does not save data
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgs'] mirror_return_headers: The container that saves the image back to the source and returns the response header rule. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_return_headers` below.
        :param pulumi.Input[str] mirror_role: Roles used when mirroring back-to-source
        :param pulumi.Input[bool] mirror_save_oss_meta: Mirror back-to-source back-to-source OSS automatically saves user metadata
        :param pulumi.Input[bool] mirror_sni: Transparent transmission of SNI
        :param pulumi.Input[bool] mirror_switch_all_errors: It is used to judge the status of active-standby switching. The judgment logic of active-standby switching is that the source station returns an error. If MirrorSwitchAllErrors is true, it is considered a failure except the following status code: 200,206,301,302,303,307,404; If false, only the source Station Returns 5xx or times out is considered a failure.
        :param pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgs'] mirror_taggings: Save the label according to the parameters when saving the file from the mirror back to the source. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_taggings` below.
        :param pulumi.Input[str] mirror_tunnel_id: Mirror back-to-source leased line back-to-source tunnel ID
        :param pulumi.Input[str] mirror_url: The address of the origin of the image. It takes effect only when the RedirectType is set to Mirror. The origin address must start with http:// or https:// and end with a forward slash (/). OSS takes the Object name after the Origin address to form the origin URL.
        :param pulumi.Input[str] mirror_url_probe: Mirror back-to-source Master-backup back-to-source switching decision URL
        :param pulumi.Input[str] mirror_url_slave: Mirror back-to-source primary backup back-to-source backup station URL
        :param pulumi.Input[bool] mirror_user_last_modified: Whether the source station LastModifiedTime is used for the image back-to-source save file.
        :param pulumi.Input[bool] mirror_using_role: Whether to use role for mirroring back to source
        :param pulumi.Input[bool] pass_query_string: Whether to carry the request parameters when executing the jump or mirror back-to-source rule. Did the user carry the request parameters when requesting OSS? a = B & c = d, and set PassQueryString to true. If the rule is a 302 jump, this request parameter is added to the Location header of the jump. For example Location:example.com? a = B & c = d, and the jump type is mirrored back-to-origin, this request parameter is also carried in the back-to-origin request initiated. Values: true, false (default)
        :param pulumi.Input[str] protocol: The protocol at the time of the jump. It takes effect only when the RedirectType is set to External or AliCDN.
        :param pulumi.Input[str] redirect_type: Specifies the type of jump. The value range is as follows: Mirror: Mirror back to the source. External: External redirects, that is, OSS returns a 3xx request to redirect to another address. AliCDN: Alibaba Cloud CDN jump, mainly used for Alibaba Cloud CDN. Unlike External, OSS adds an additional Header. After recognizing this Header, Alibaba Cloud CDN redirects the data to the specified address and returns the obtained data to the user instead of returning the 3xx Redirection request to the user.
        :param pulumi.Input[str] replace_key_prefix_with: The prefix of the Object name will be replaced with this value during Redirect. If the prefix is empty, this string is inserted in front of the Object name.
        :param pulumi.Input[str] replace_key_with: During redirection, the Object name is replaced with the value specified by ReplaceKeyWith. You can set variables in ReplaceKeyWith. Currently, the supported variable is ${key}, which indicates the name of the Object in the request.
        :param pulumi.Input[str] transparent_mirror_response_codes: Mirror back-to-source transparent source station response code list
        """
        if enable_replace_prefix is not None:
            pulumi.set(__self__, "enable_replace_prefix", enable_replace_prefix)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if http_redirect_code is not None:
            pulumi.set(__self__, "http_redirect_code", http_redirect_code)
        if mirror_allow_get_image_info is not None:
            pulumi.set(__self__, "mirror_allow_get_image_info", mirror_allow_get_image_info)
        if mirror_allow_head_object is not None:
            pulumi.set(__self__, "mirror_allow_head_object", mirror_allow_head_object)
        if mirror_allow_video_snapshot is not None:
            pulumi.set(__self__, "mirror_allow_video_snapshot", mirror_allow_video_snapshot)
        if mirror_async_status is not None:
            pulumi.set(__self__, "mirror_async_status", mirror_async_status)
        if mirror_auth is not None:
            pulumi.set(__self__, "mirror_auth", mirror_auth)
        if mirror_check_md5 is not None:
            pulumi.set(__self__, "mirror_check_md5", mirror_check_md5)
        if mirror_dst_region is not None:
            pulumi.set(__self__, "mirror_dst_region", mirror_dst_region)
        if mirror_dst_slave_vpc_id is not None:
            pulumi.set(__self__, "mirror_dst_slave_vpc_id", mirror_dst_slave_vpc_id)
        if mirror_dst_vpc_id is not None:
            pulumi.set(__self__, "mirror_dst_vpc_id", mirror_dst_vpc_id)
        if mirror_follow_redirect is not None:
            pulumi.set(__self__, "mirror_follow_redirect", mirror_follow_redirect)
        if mirror_headers is not None:
            pulumi.set(__self__, "mirror_headers", mirror_headers)
        if mirror_is_express_tunnel is not None:
            pulumi.set(__self__, "mirror_is_express_tunnel", mirror_is_express_tunnel)
        if mirror_multi_alternates is not None:
            pulumi.set(__self__, "mirror_multi_alternates", mirror_multi_alternates)
        if mirror_pass_original_slashes is not None:
            pulumi.set(__self__, "mirror_pass_original_slashes", mirror_pass_original_slashes)
        if mirror_pass_query_string is not None:
            pulumi.set(__self__, "mirror_pass_query_string", mirror_pass_query_string)
        if mirror_proxy_pass is not None:
            pulumi.set(__self__, "mirror_proxy_pass", mirror_proxy_pass)
        if mirror_return_headers is not None:
            pulumi.set(__self__, "mirror_return_headers", mirror_return_headers)
        if mirror_role is not None:
            pulumi.set(__self__, "mirror_role", mirror_role)
        if mirror_save_oss_meta is not None:
            pulumi.set(__self__, "mirror_save_oss_meta", mirror_save_oss_meta)
        if mirror_sni is not None:
            pulumi.set(__self__, "mirror_sni", mirror_sni)
        if mirror_switch_all_errors is not None:
            pulumi.set(__self__, "mirror_switch_all_errors", mirror_switch_all_errors)
        if mirror_taggings is not None:
            pulumi.set(__self__, "mirror_taggings", mirror_taggings)
        if mirror_tunnel_id is not None:
            pulumi.set(__self__, "mirror_tunnel_id", mirror_tunnel_id)
        if mirror_url is not None:
            pulumi.set(__self__, "mirror_url", mirror_url)
        if mirror_url_probe is not None:
            pulumi.set(__self__, "mirror_url_probe", mirror_url_probe)
        if mirror_url_slave is not None:
            pulumi.set(__self__, "mirror_url_slave", mirror_url_slave)
        if mirror_user_last_modified is not None:
            pulumi.set(__self__, "mirror_user_last_modified", mirror_user_last_modified)
        if mirror_using_role is not None:
            pulumi.set(__self__, "mirror_using_role", mirror_using_role)
        if pass_query_string is not None:
            pulumi.set(__self__, "pass_query_string", pass_query_string)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if redirect_type is not None:
            pulumi.set(__self__, "redirect_type", redirect_type)
        if replace_key_prefix_with is not None:
            pulumi.set(__self__, "replace_key_prefix_with", replace_key_prefix_with)
        if replace_key_with is not None:
            pulumi.set(__self__, "replace_key_with", replace_key_with)
        if transparent_mirror_response_codes is not None:
            pulumi.set(__self__, "transparent_mirror_response_codes", transparent_mirror_response_codes)

    @property
    @pulumi.getter(name="enableReplacePrefix")
    def enable_replace_prefix(self) -> Optional[pulumi.Input[bool]]:
        """
        If this field is set to true, the prefix of Object is replaced with the value specified by ReplaceKeyPrefixWith. If this field is not specified or is blank, the Object prefix is truncated.
        """
        return pulumi.get(self, "enable_replace_prefix")

    @enable_replace_prefix.setter
    def enable_replace_prefix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_replace_prefix", value)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name during the jump. The domain name must comply with the domain name specification.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="httpRedirectCode")
    def http_redirect_code(self) -> Optional[pulumi.Input[str]]:
        """
        The status code returned during the jump. It takes effect only when the RedirectType is set to External or AliCDN.
        """
        return pulumi.get(self, "http_redirect_code")

    @http_redirect_code.setter
    def http_redirect_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_redirect_code", value)

    @property
    @pulumi.getter(name="mirrorAllowGetImageInfo")
    def mirror_allow_get_image_info(self) -> Optional[pulumi.Input[bool]]:
        """
        Image back-to-source allows getting Image information
        """
        return pulumi.get(self, "mirror_allow_get_image_info")

    @mirror_allow_get_image_info.setter
    def mirror_allow_get_image_info(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_allow_get_image_info", value)

    @property
    @pulumi.getter(name="mirrorAllowHeadObject")
    def mirror_allow_head_object(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow HeadObject in image back-to-source
        """
        return pulumi.get(self, "mirror_allow_head_object")

    @mirror_allow_head_object.setter
    def mirror_allow_head_object(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_allow_head_object", value)

    @property
    @pulumi.getter(name="mirrorAllowVideoSnapshot")
    def mirror_allow_video_snapshot(self) -> Optional[pulumi.Input[bool]]:
        """
        Mirror back-to-source allows support for video frame truncation
        """
        return pulumi.get(self, "mirror_allow_video_snapshot")

    @mirror_allow_video_snapshot.setter
    def mirror_allow_video_snapshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_allow_video_snapshot", value)

    @property
    @pulumi.getter(name="mirrorAsyncStatus")
    def mirror_async_status(self) -> Optional[pulumi.Input[int]]:
        """
        The status code of the mirror back-to-source trigger asynchronous pull mode.
        """
        return pulumi.get(self, "mirror_async_status")

    @mirror_async_status.setter
    def mirror_async_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mirror_async_status", value)

    @property
    @pulumi.getter(name="mirrorAuth")
    def mirror_auth(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgs']]:
        """
        Image back Source station authentication information See `mirror_auth` below.
        """
        return pulumi.get(self, "mirror_auth")

    @mirror_auth.setter
    def mirror_auth(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgs']]):
        pulumi.set(self, "mirror_auth", value)

    @property
    @pulumi.getter(name="mirrorCheckMd5")
    def mirror_check_md5(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to check the MD5 of the source body. It takes effect only when the RedirectType is set to Mirror.
        """
        return pulumi.get(self, "mirror_check_md5")

    @mirror_check_md5.setter
    def mirror_check_md5(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_check_md5", value)

    @property
    @pulumi.getter(name="mirrorDstRegion")
    def mirror_dst_region(self) -> Optional[pulumi.Input[str]]:
        """
        Mirrored back-to-source high-speed Channel vpregion
        """
        return pulumi.get(self, "mirror_dst_region")

    @mirror_dst_region.setter
    def mirror_dst_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_dst_region", value)

    @property
    @pulumi.getter(name="mirrorDstSlaveVpcId")
    def mirror_dst_slave_vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Mirroring back-to-source high-speed Channel standby station VpcId
        """
        return pulumi.get(self, "mirror_dst_slave_vpc_id")

    @mirror_dst_slave_vpc_id.setter
    def mirror_dst_slave_vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_dst_slave_vpc_id", value)

    @property
    @pulumi.getter(name="mirrorDstVpcId")
    def mirror_dst_vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Mirror back-to-source high-speed Channel VpcId
        """
        return pulumi.get(self, "mirror_dst_vpc_id")

    @mirror_dst_vpc_id.setter
    def mirror_dst_vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_dst_vpc_id", value)

    @property
    @pulumi.getter(name="mirrorFollowRedirect")
    def mirror_follow_redirect(self) -> Optional[pulumi.Input[bool]]:
        """
        If the result of the image back-to-source acquisition is 3xx, whether to continue to jump to the specified Location to obtain data. It takes effect only when the RedirectType is set to Mirror.
        """
        return pulumi.get(self, "mirror_follow_redirect")

    @mirror_follow_redirect.setter
    def mirror_follow_redirect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_follow_redirect", value)

    @property
    @pulumi.getter(name="mirrorHeaders")
    def mirror_headers(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgs']]:
        """
        Specifies the Header carried when the image returns to the source. It takes effect only when the RedirectType is set to Mirror. See `mirror_headers` below.
        """
        return pulumi.get(self, "mirror_headers")

    @mirror_headers.setter
    def mirror_headers(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgs']]):
        pulumi.set(self, "mirror_headers", value)

    @property
    @pulumi.getter(name="mirrorIsExpressTunnel")
    def mirror_is_express_tunnel(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether it is a mirror back-to-source high-speed Channel
        """
        return pulumi.get(self, "mirror_is_express_tunnel")

    @mirror_is_express_tunnel.setter
    def mirror_is_express_tunnel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_is_express_tunnel", value)

    @property
    @pulumi.getter(name="mirrorMultiAlternates")
    def mirror_multi_alternates(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgs']]:
        """
        Mirror back-to-source multi-source station configuration container. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_multi_alternates` below.
        """
        return pulumi.get(self, "mirror_multi_alternates")

    @mirror_multi_alternates.setter
    def mirror_multi_alternates(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgs']]):
        pulumi.set(self, "mirror_multi_alternates", value)

    @property
    @pulumi.getter(name="mirrorPassOriginalSlashes")
    def mirror_pass_original_slashes(self) -> Optional[pulumi.Input[bool]]:
        """
        Transparent transmission/to source Station
        """
        return pulumi.get(self, "mirror_pass_original_slashes")

    @mirror_pass_original_slashes.setter
    def mirror_pass_original_slashes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_pass_original_slashes", value)

    @property
    @pulumi.getter(name="mirrorPassQueryString")
    def mirror_pass_query_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Same as PassQueryString and takes precedence over PassQueryString. It takes effect only when the RedirectType is set to Mirror.
        """
        return pulumi.get(self, "mirror_pass_query_string")

    @mirror_pass_query_string.setter
    def mirror_pass_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_pass_query_string", value)

    @property
    @pulumi.getter(name="mirrorProxyPass")
    def mirror_proxy_pass(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether mirroring back to source does not save data
        """
        return pulumi.get(self, "mirror_proxy_pass")

    @mirror_proxy_pass.setter
    def mirror_proxy_pass(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_proxy_pass", value)

    @property
    @pulumi.getter(name="mirrorReturnHeaders")
    def mirror_return_headers(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgs']]:
        """
        The container that saves the image back to the source and returns the response header rule. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_return_headers` below.
        """
        return pulumi.get(self, "mirror_return_headers")

    @mirror_return_headers.setter
    def mirror_return_headers(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgs']]):
        pulumi.set(self, "mirror_return_headers", value)

    @property
    @pulumi.getter(name="mirrorRole")
    def mirror_role(self) -> Optional[pulumi.Input[str]]:
        """
        Roles used when mirroring back-to-source
        """
        return pulumi.get(self, "mirror_role")

    @mirror_role.setter
    def mirror_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_role", value)

    @property
    @pulumi.getter(name="mirrorSaveOssMeta")
    def mirror_save_oss_meta(self) -> Optional[pulumi.Input[bool]]:
        """
        Mirror back-to-source back-to-source OSS automatically saves user metadata
        """
        return pulumi.get(self, "mirror_save_oss_meta")

    @mirror_save_oss_meta.setter
    def mirror_save_oss_meta(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_save_oss_meta", value)

    @property
    @pulumi.getter(name="mirrorSni")
    def mirror_sni(self) -> Optional[pulumi.Input[bool]]:
        """
        Transparent transmission of SNI
        """
        return pulumi.get(self, "mirror_sni")

    @mirror_sni.setter
    def mirror_sni(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_sni", value)

    @property
    @pulumi.getter(name="mirrorSwitchAllErrors")
    def mirror_switch_all_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        It is used to judge the status of active-standby switching. The judgment logic of active-standby switching is that the source station returns an error. If MirrorSwitchAllErrors is true, it is considered a failure except the following status code: 200,206,301,302,303,307,404; If false, only the source Station Returns 5xx or times out is considered a failure.
        """
        return pulumi.get(self, "mirror_switch_all_errors")

    @mirror_switch_all_errors.setter
    def mirror_switch_all_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_switch_all_errors", value)

    @property
    @pulumi.getter(name="mirrorTaggings")
    def mirror_taggings(self) -> Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgs']]:
        """
        Save the label according to the parameters when saving the file from the mirror back to the source. **NOTE:**: If you want to clean one configuration, you must set the configuration to empty value, removing from code cannot make effect. See `mirror_taggings` below.
        """
        return pulumi.get(self, "mirror_taggings")

    @mirror_taggings.setter
    def mirror_taggings(self, value: Optional[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgs']]):
        pulumi.set(self, "mirror_taggings", value)

    @property
    @pulumi.getter(name="mirrorTunnelId")
    def mirror_tunnel_id(self) -> Optional[pulumi.Input[str]]:
        """
        Mirror back-to-source leased line back-to-source tunnel ID
        """
        return pulumi.get(self, "mirror_tunnel_id")

    @mirror_tunnel_id.setter
    def mirror_tunnel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_tunnel_id", value)

    @property
    @pulumi.getter(name="mirrorUrl")
    def mirror_url(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the origin of the image. It takes effect only when the RedirectType is set to Mirror. The origin address must start with http:// or https:// and end with a forward slash (/). OSS takes the Object name after the Origin address to form the origin URL.
        """
        return pulumi.get(self, "mirror_url")

    @mirror_url.setter
    def mirror_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_url", value)

    @property
    @pulumi.getter(name="mirrorUrlProbe")
    def mirror_url_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Mirror back-to-source Master-backup back-to-source switching decision URL
        """
        return pulumi.get(self, "mirror_url_probe")

    @mirror_url_probe.setter
    def mirror_url_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_url_probe", value)

    @property
    @pulumi.getter(name="mirrorUrlSlave")
    def mirror_url_slave(self) -> Optional[pulumi.Input[str]]:
        """
        Mirror back-to-source primary backup back-to-source backup station URL
        """
        return pulumi.get(self, "mirror_url_slave")

    @mirror_url_slave.setter
    def mirror_url_slave(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_url_slave", value)

    @property
    @pulumi.getter(name="mirrorUserLastModified")
    def mirror_user_last_modified(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source station LastModifiedTime is used for the image back-to-source save file.
        """
        return pulumi.get(self, "mirror_user_last_modified")

    @mirror_user_last_modified.setter
    def mirror_user_last_modified(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_user_last_modified", value)

    @property
    @pulumi.getter(name="mirrorUsingRole")
    def mirror_using_role(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use role for mirroring back to source
        """
        return pulumi.get(self, "mirror_using_role")

    @mirror_using_role.setter
    def mirror_using_role(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirror_using_role", value)

    @property
    @pulumi.getter(name="passQueryString")
    def pass_query_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to carry the request parameters when executing the jump or mirror back-to-source rule. Did the user carry the request parameters when requesting OSS? a = B & c = d, and set PassQueryString to true. If the rule is a 302 jump, this request parameter is added to the Location header of the jump. For example Location:example.com? a = B & c = d, and the jump type is mirrored back-to-origin, this request parameter is also carried in the back-to-origin request initiated. Values: true, false (default)
        """
        return pulumi.get(self, "pass_query_string")

    @pass_query_string.setter
    def pass_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pass_query_string", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol at the time of the jump. It takes effect only when the RedirectType is set to External or AliCDN.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of jump. The value range is as follows: Mirror: Mirror back to the source. External: External redirects, that is, OSS returns a 3xx request to redirect to another address. AliCDN: Alibaba Cloud CDN jump, mainly used for Alibaba Cloud CDN. Unlike External, OSS adds an additional Header. After recognizing this Header, Alibaba Cloud CDN redirects the data to the specified address and returns the obtained data to the user instead of returning the 3xx Redirection request to the user.
        """
        return pulumi.get(self, "redirect_type")

    @redirect_type.setter
    def redirect_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_type", value)

    @property
    @pulumi.getter(name="replaceKeyPrefixWith")
    def replace_key_prefix_with(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix of the Object name will be replaced with this value during Redirect. If the prefix is empty, this string is inserted in front of the Object name.
        """
        return pulumi.get(self, "replace_key_prefix_with")

    @replace_key_prefix_with.setter
    def replace_key_prefix_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_key_prefix_with", value)

    @property
    @pulumi.getter(name="replaceKeyWith")
    def replace_key_with(self) -> Optional[pulumi.Input[str]]:
        """
        During redirection, the Object name is replaced with the value specified by ReplaceKeyWith. You can set variables in ReplaceKeyWith. Currently, the supported variable is ${key}, which indicates the name of the Object in the request.
        """
        return pulumi.get(self, "replace_key_with")

    @replace_key_with.setter
    def replace_key_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_key_with", value)

    @property
    @pulumi.getter(name="transparentMirrorResponseCodes")
    def transparent_mirror_response_codes(self) -> Optional[pulumi.Input[str]]:
        """
        Mirror back-to-source transparent source station response code list
        """
        return pulumi.get(self, "transparent_mirror_response_codes")

    @transparent_mirror_response_codes.setter
    def transparent_mirror_response_codes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transparent_mirror_response_codes", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[str]]
        """
        Mirror back-to-source source Station back-to-source AK
        """
        access_key_secret: NotRequired[pulumi.Input[str]]
        """
        Mirroring back to the source station back to the source SK will be automatically desensitized when obtaining the configuration.
        """
        auth_type: NotRequired[pulumi.Input[str]]
        """
        Authentication type of mirror return Source
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Signature Region
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorAuthArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 access_key_secret: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: Mirror back-to-source source Station back-to-source AK
        :param pulumi.Input[str] access_key_secret: Mirroring back to the source station back to the source SK will be automatically desensitized when obtaining the configuration.
        :param pulumi.Input[str] auth_type: Authentication type of mirror return Source
        :param pulumi.Input[str] region: Signature Region
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if access_key_secret is not None:
            pulumi.set(__self__, "access_key_secret", access_key_secret)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Mirror back-to-source source Station back-to-source AK
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="accessKeySecret")
    def access_key_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Mirroring back to the source station back to the source SK will be automatically desensitized when obtaining the configuration.
        """
        return pulumi.get(self, "access_key_secret")

    @access_key_secret.setter
    def access_key_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_secret", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication type of mirror return Source
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Signature Region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgsDict(TypedDict):
        pass_all: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether other headers except the following headers are transmitted to the source site. It takes effect only when the RedirectType is set to Mirror. content-length, authorization2, authorization, range, date, and other headers Headers whose names start with oss-/x-oss-/x-drs-
        """
        passes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Pass through the specified Header to the source site. It takes effect only when the RedirectType is set to Mirror. Each Header is up to 1024 bytes in length and has A character set of 0 to 9, a to Z, A to z, and dashes (-).
        """
        removes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Do not pass the specified Header to the source site. It takes effect only when the RedirectType is set to Mirror. Each Header is up to 1024 bytes in length and has A character set of 0 to 9, a to Z, A to z, and dashes (-).
        """
        sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgsDict']]]]
        """
        Set a Header to send to the source site. Regardless of whether the request contains the specified Header, these headers will be set when returning to the source site. It takes effect only when the RedirectType is set to Mirror. See `set` below.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersArgs:
    def __init__(__self__, *,
                 pass_all: Optional[pulumi.Input[bool]] = None,
                 passes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 removes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sets: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgs']]]] = None):
        """
        :param pulumi.Input[bool] pass_all: Indicates whether other headers except the following headers are transmitted to the source site. It takes effect only when the RedirectType is set to Mirror. content-length, authorization2, authorization, range, date, and other headers Headers whose names start with oss-/x-oss-/x-drs-
        :param pulumi.Input[Sequence[pulumi.Input[str]]] passes: Pass through the specified Header to the source site. It takes effect only when the RedirectType is set to Mirror. Each Header is up to 1024 bytes in length and has A character set of 0 to 9, a to Z, A to z, and dashes (-).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] removes: Do not pass the specified Header to the source site. It takes effect only when the RedirectType is set to Mirror. Each Header is up to 1024 bytes in length and has A character set of 0 to 9, a to Z, A to z, and dashes (-).
        :param pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgs']]] sets: Set a Header to send to the source site. Regardless of whether the request contains the specified Header, these headers will be set when returning to the source site. It takes effect only when the RedirectType is set to Mirror. See `set` below.
        """
        if pass_all is not None:
            pulumi.set(__self__, "pass_all", pass_all)
        if passes is not None:
            pulumi.set(__self__, "passes", passes)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @property
    @pulumi.getter(name="passAll")
    def pass_all(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether other headers except the following headers are transmitted to the source site. It takes effect only when the RedirectType is set to Mirror. content-length, authorization2, authorization, range, date, and other headers Headers whose names start with oss-/x-oss-/x-drs-
        """
        return pulumi.get(self, "pass_all")

    @pass_all.setter
    def pass_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pass_all", value)

    @property
    @pulumi.getter
    def passes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pass through the specified Header to the source site. It takes effect only when the RedirectType is set to Mirror. Each Header is up to 1024 bytes in length and has A character set of 0 to 9, a to Z, A to z, and dashes (-).
        """
        return pulumi.get(self, "passes")

    @passes.setter
    def passes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "passes", value)

    @property
    @pulumi.getter
    def removes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Do not pass the specified Header to the source site. It takes effect only when the RedirectType is set to Mirror. Each Header is up to 1024 bytes in length and has A character set of 0 to 9, a to Z, A to z, and dashes (-).
        """
        return pulumi.get(self, "removes")

    @removes.setter
    def removes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "removes", value)

    @property
    @pulumi.getter
    def sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgs']]]]:
        """
        Set a Header to send to the source site. Regardless of whether the request contains the specified Header, these headers will be set when returning to the source site. It takes effect only when the RedirectType is set to Mirror. See `set` below.
        """
        return pulumi.get(self, "sets")

    @sets.setter
    def sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgs']]]]):
        pulumi.set(self, "sets", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorHeadersSetArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgsDict(TypedDict):
        mirror_multi_alternates: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgsDict']]]]
        """
        Mirror back-to-source multi-source station configuration list See `mirror_multi_alternate` below.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesArgs:
    def __init__(__self__, *,
                 mirror_multi_alternates: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgs']]] mirror_multi_alternates: Mirror back-to-source multi-source station configuration list See `mirror_multi_alternate` below.
        """
        if mirror_multi_alternates is not None:
            pulumi.set(__self__, "mirror_multi_alternates", mirror_multi_alternates)

    @property
    @pulumi.getter(name="mirrorMultiAlternates")
    def mirror_multi_alternates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgs']]]]:
        """
        Mirror back-to-source multi-source station configuration list See `mirror_multi_alternate` below.
        """
        return pulumi.get(self, "mirror_multi_alternates")

    @mirror_multi_alternates.setter
    def mirror_multi_alternates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgs']]]]):
        pulumi.set(self, "mirror_multi_alternates", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgsDict(TypedDict):
        mirror_multi_alternate_dst_region: NotRequired[pulumi.Input[str]]
        """
        Mirroring back-to-source multi-station Region
        """
        mirror_multi_alternate_number: NotRequired[pulumi.Input[int]]
        """
        Image back-to-source multi-source station serial number
        """
        mirror_multi_alternate_url: NotRequired[pulumi.Input[str]]
        """
        Mirroring back-to-source multi-source site URL
        """
        mirror_multi_alternate_vpc_id: NotRequired[pulumi.Input[str]]
        """
        Mirroring back-to-source multi-source VpcId
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorMultiAlternatesMirrorMultiAlternateArgs:
    def __init__(__self__, *,
                 mirror_multi_alternate_dst_region: Optional[pulumi.Input[str]] = None,
                 mirror_multi_alternate_number: Optional[pulumi.Input[int]] = None,
                 mirror_multi_alternate_url: Optional[pulumi.Input[str]] = None,
                 mirror_multi_alternate_vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mirror_multi_alternate_dst_region: Mirroring back-to-source multi-station Region
        :param pulumi.Input[int] mirror_multi_alternate_number: Image back-to-source multi-source station serial number
        :param pulumi.Input[str] mirror_multi_alternate_url: Mirroring back-to-source multi-source site URL
        :param pulumi.Input[str] mirror_multi_alternate_vpc_id: Mirroring back-to-source multi-source VpcId
        """
        if mirror_multi_alternate_dst_region is not None:
            pulumi.set(__self__, "mirror_multi_alternate_dst_region", mirror_multi_alternate_dst_region)
        if mirror_multi_alternate_number is not None:
            pulumi.set(__self__, "mirror_multi_alternate_number", mirror_multi_alternate_number)
        if mirror_multi_alternate_url is not None:
            pulumi.set(__self__, "mirror_multi_alternate_url", mirror_multi_alternate_url)
        if mirror_multi_alternate_vpc_id is not None:
            pulumi.set(__self__, "mirror_multi_alternate_vpc_id", mirror_multi_alternate_vpc_id)

    @property
    @pulumi.getter(name="mirrorMultiAlternateDstRegion")
    def mirror_multi_alternate_dst_region(self) -> Optional[pulumi.Input[str]]:
        """
        Mirroring back-to-source multi-station Region
        """
        return pulumi.get(self, "mirror_multi_alternate_dst_region")

    @mirror_multi_alternate_dst_region.setter
    def mirror_multi_alternate_dst_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_multi_alternate_dst_region", value)

    @property
    @pulumi.getter(name="mirrorMultiAlternateNumber")
    def mirror_multi_alternate_number(self) -> Optional[pulumi.Input[int]]:
        """
        Image back-to-source multi-source station serial number
        """
        return pulumi.get(self, "mirror_multi_alternate_number")

    @mirror_multi_alternate_number.setter
    def mirror_multi_alternate_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mirror_multi_alternate_number", value)

    @property
    @pulumi.getter(name="mirrorMultiAlternateUrl")
    def mirror_multi_alternate_url(self) -> Optional[pulumi.Input[str]]:
        """
        Mirroring back-to-source multi-source site URL
        """
        return pulumi.get(self, "mirror_multi_alternate_url")

    @mirror_multi_alternate_url.setter
    def mirror_multi_alternate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_multi_alternate_url", value)

    @property
    @pulumi.getter(name="mirrorMultiAlternateVpcId")
    def mirror_multi_alternate_vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        Mirroring back-to-source multi-source VpcId
        """
        return pulumi.get(self, "mirror_multi_alternate_vpc_id")

    @mirror_multi_alternate_vpc_id.setter
    def mirror_multi_alternate_vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirror_multi_alternate_vpc_id", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgsDict(TypedDict):
        return_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgsDict']]]]
        """
        The list of response header rules for mirroring back-to-source return. See `return_header` below.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersArgs:
    def __init__(__self__, *,
                 return_headers: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgs']]] return_headers: The list of response header rules for mirroring back-to-source return. See `return_header` below.
        """
        if return_headers is not None:
            pulumi.set(__self__, "return_headers", return_headers)

    @property
    @pulumi.getter(name="returnHeaders")
    def return_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgs']]]]:
        """
        The list of response header rules for mirroring back-to-source return. See `return_header` below.
        """
        return pulumi.get(self, "return_headers")

    @return_headers.setter
    def return_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgs']]]]):
        pulumi.set(self, "return_headers", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorReturnHeadersReturnHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgsDict(TypedDict):
        taggings: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgsDict']]]]
        """
        Image back-to-source save label rule list See `taggings` below.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsArgs:
    def __init__(__self__, *,
                 taggings: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgs']]] taggings: Image back-to-source save label rule list See `taggings` below.
        """
        if taggings is not None:
            pulumi.set(__self__, "taggings", taggings)

    @property
    @pulumi.getter
    def taggings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgs']]]]:
        """
        Image back-to-source save label rule list See `taggings` below.
        """
        return pulumi.get(self, "taggings")

    @taggings.setter
    def taggings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgs']]]]):
        pulumi.set(self, "taggings", value)


if not MYPY:
    class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
elif False:
    BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteRoutingRulesRoutingRuleRedirectMirrorTaggingsTaggingArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Set the value of the Header to 1024 bytes at most. \\r\\n. It takes effect only when the RedirectType is set to Mirror.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


