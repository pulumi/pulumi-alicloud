# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DispatchRuleGroupRule',
    'DispatchRuleLabelMatchExpressionGrid',
    'DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup',
    'DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression',
    'DispatchRuleNotifyRule',
    'DispatchRuleNotifyRuleNotifyObject',
    'DispatchRuleNotifyTemplate',
    'PrometheusAlertRuleAnnotation',
    'PrometheusAlertRuleLabel',
    'SyntheticTaskAvailableAssertion',
    'SyntheticTaskCommonSetting',
    'SyntheticTaskCommonSettingCustomHost',
    'SyntheticTaskCommonSettingCustomHostHost',
    'SyntheticTaskCustomPeriod',
    'SyntheticTaskMonitor',
    'SyntheticTaskMonitorConf',
    'SyntheticTaskMonitorConfApiHttp',
    'SyntheticTaskMonitorConfApiHttpRequestBody',
    'SyntheticTaskMonitorConfFileDownload',
    'SyntheticTaskMonitorConfNetDns',
    'SyntheticTaskMonitorConfNetIcmp',
    'SyntheticTaskMonitorConfNetTcp',
    'SyntheticTaskMonitorConfStream',
    'SyntheticTaskMonitorConfWebsite',
    'GetAddonReleasesReleaseResult',
    'GetAlertContactGroupsGroupResult',
    'GetAlertContactsContactResult',
    'GetAlertRobotsRobotResult',
    'GetDispatchRulesRuleResult',
    'GetDispatchRulesRuleGroupRuleResult',
    'GetDispatchRulesRuleLabelMatchExpressionGridResult',
    'GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult',
    'GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult',
    'GetDispatchRulesRuleNotifyRuleResult',
    'GetDispatchRulesRuleNotifyRuleNotifyObjectResult',
    'GetDispatchRulesRuleNotifyTemplateResult',
    'GetEnvCustomJobsJobResult',
    'GetEnvFeaturesFeatureResult',
    'GetEnvPodMonitorsMonitorResult',
    'GetEnvServiceMonitorsMonitorResult',
    'GetEnvironmentsEnvironmentResult',
    'GetIntegrationExportersIntegrationExporterResult',
    'GetPrometheisPrometheiResult',
    'GetPrometheusAlertRulesRuleResult',
    'GetPrometheusAlertRulesRuleAnnotationResult',
    'GetPrometheusAlertRulesRuleLabelResult',
    'GetPrometheusMonitoringsPrometheusMonitoringResult',
    'GetPrometheusPrometheiResult',
    'GetRemoteWritesRemoteWriteResult',
]

@pulumi.output_type
class DispatchRuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWaitTime":
            suggest = "group_wait_time"
        elif key == "groupingFields":
            suggest = "grouping_fields"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_interval: _builtins.int,
                 group_wait_time: _builtins.int,
                 grouping_fields: Sequence[_builtins.str],
                 group_id: Optional[_builtins.int] = None,
                 repeat_interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int group_interval: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param _builtins.int group_wait_time: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param Sequence[_builtins.str] grouping_fields: The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        :param _builtins.int group_id: The ID of the group rule.
        :param _builtins.int repeat_interval: The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        pulumi.set(__self__, "group_interval", group_interval)
        pulumi.set(__self__, "group_wait_time", group_wait_time)
        pulumi.set(__self__, "grouping_fields", grouping_fields)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> _builtins.int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWaitTime")
    def group_wait_time(self) -> _builtins.int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_wait_time")

    @_builtins.property
    @pulumi.getter(name="groupingFields")
    def grouping_fields(self) -> Sequence[_builtins.str]:
        """
        The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        """
        return pulumi.get(self, "grouping_fields")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of the group rule.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[_builtins.int]:
        """
        The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class DispatchRuleLabelMatchExpressionGrid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelMatchExpressionGroups":
            suggest = "label_match_expression_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleLabelMatchExpressionGrid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleLabelMatchExpressionGrid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleLabelMatchExpressionGrid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_match_expression_groups: Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup']):
        """
        :param Sequence['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs'] label_match_expression_groups: Sets the dispatch rule. See `label_match_expression_groups` below.
        """
        pulumi.set(__self__, "label_match_expression_groups", label_match_expression_groups)

    @_builtins.property
    @pulumi.getter(name="labelMatchExpressionGroups")
    def label_match_expression_groups(self) -> Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup']:
        """
        Sets the dispatch rule. See `label_match_expression_groups` below.
        """
        return pulumi.get(self, "label_match_expression_groups")


@pulumi.output_type
class DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelMatchExpressions":
            suggest = "label_match_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_match_expressions: Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression']):
        """
        :param Sequence['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs'] label_match_expressions: Sets the dispatch rule. See `label_match_expressions` below.
        """
        pulumi.set(__self__, "label_match_expressions", label_match_expressions)

    @_builtins.property
    @pulumi.getter(name="labelMatchExpressions")
    def label_match_expressions(self) -> Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression']:
        """
        Sets the dispatch rule. See `label_match_expressions` below.
        """
        return pulumi.get(self, "label_match_expressions")


@pulumi.output_type
class DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of the tag of the dispatch rule. Valid values:
               * _aliyun_arms_userid: user ID
               * _aliyun_arms_involvedObject_kind: type of the associated object
               * _aliyun_arms_involvedObject_id: ID of the associated object
               * _aliyun_arms_involvedObject_name: name of the associated object
               * _aliyun_arms_alert_name: alert name
               * _aliyun_arms_alert_rule_id: alert rule ID
               * _aliyun_arms_alert_type: alert type
               * _aliyun_arms_alert_level: alert severity
        :param _builtins.str operator: The operator used in the dispatch rule. Valid values: 
               * eq: equals to.
               * re: matches a regular expression.
        :param _builtins.str value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the tag of the dispatch rule. Valid values:
        * _aliyun_arms_userid: user ID
        * _aliyun_arms_involvedObject_kind: type of the associated object
        * _aliyun_arms_involvedObject_id: ID of the associated object
        * _aliyun_arms_involvedObject_name: name of the associated object
        * _aliyun_arms_alert_name: alert name
        * _aliyun_arms_alert_rule_id: alert rule ID
        * _aliyun_arms_alert_type: alert type
        * _aliyun_arms_alert_level: alert severity
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator used in the dispatch rule. Valid values: 
        * eq: equals to.
        * re: matches a regular expression.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DispatchRuleNotifyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyChannels":
            suggest = "notify_channels"
        elif key == "notifyEndTime":
            suggest = "notify_end_time"
        elif key == "notifyObjects":
            suggest = "notify_objects"
        elif key == "notifyStartTime":
            suggest = "notify_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleNotifyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleNotifyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleNotifyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_channels: Sequence[_builtins.str],
                 notify_end_time: _builtins.str,
                 notify_objects: Sequence['outputs.DispatchRuleNotifyRuleNotifyObject'],
                 notify_start_time: _builtins.str):
        """
        :param Sequence[_builtins.str] notify_channels: The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
        :param _builtins.str notify_end_time: End time of notification.
        :param Sequence['DispatchRuleNotifyRuleNotifyObjectArgs'] notify_objects: Sets the notification object. See `notify_objects` below.
        :param _builtins.str notify_start_time: Start time of notification.
        """
        pulumi.set(__self__, "notify_channels", notify_channels)
        pulumi.set(__self__, "notify_end_time", notify_end_time)
        pulumi.set(__self__, "notify_objects", notify_objects)
        pulumi.set(__self__, "notify_start_time", notify_start_time)

    @_builtins.property
    @pulumi.getter(name="notifyChannels")
    def notify_channels(self) -> Sequence[_builtins.str]:
        """
        The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
        """
        return pulumi.get(self, "notify_channels")

    @_builtins.property
    @pulumi.getter(name="notifyEndTime")
    def notify_end_time(self) -> _builtins.str:
        """
        End time of notification.
        """
        return pulumi.get(self, "notify_end_time")

    @_builtins.property
    @pulumi.getter(name="notifyObjects")
    def notify_objects(self) -> Sequence['outputs.DispatchRuleNotifyRuleNotifyObject']:
        """
        Sets the notification object. See `notify_objects` below.
        """
        return pulumi.get(self, "notify_objects")

    @_builtins.property
    @pulumi.getter(name="notifyStartTime")
    def notify_start_time(self) -> _builtins.str:
        """
        Start time of notification.
        """
        return pulumi.get(self, "notify_start_time")


@pulumi.output_type
class DispatchRuleNotifyRuleNotifyObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyObjectId":
            suggest = "notify_object_id"
        elif key == "notifyType":
            suggest = "notify_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleNotifyRuleNotifyObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleNotifyRuleNotifyObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleNotifyRuleNotifyObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 notify_object_id: _builtins.str,
                 notify_type: _builtins.str):
        """
        :param _builtins.str name: The name of the contact or contact group.
        :param _builtins.str notify_object_id: The ID of the contact or contact group.
        :param _builtins.str notify_type: The type of the alert contact. Valid values: ARMS_ROBOT: robot. ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_object_id", notify_object_id)
        pulumi.set(__self__, "notify_type", notify_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the contact or contact group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifyObjectId")
    def notify_object_id(self) -> _builtins.str:
        """
        The ID of the contact or contact group.
        """
        return pulumi.get(self, "notify_object_id")

    @_builtins.property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> _builtins.str:
        """
        The type of the alert contact. Valid values: ARMS_ROBOT: robot. ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
        """
        return pulumi.get(self, "notify_type")


@pulumi.output_type
class DispatchRuleNotifyTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailContent":
            suggest = "email_content"
        elif key == "emailRecoverContent":
            suggest = "email_recover_content"
        elif key == "emailRecoverTitle":
            suggest = "email_recover_title"
        elif key == "emailTitle":
            suggest = "email_title"
        elif key == "robotContent":
            suggest = "robot_content"
        elif key == "smsContent":
            suggest = "sms_content"
        elif key == "smsRecoverContent":
            suggest = "sms_recover_content"
        elif key == "ttsContent":
            suggest = "tts_content"
        elif key == "ttsRecoverContent":
            suggest = "tts_recover_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleNotifyTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleNotifyTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleNotifyTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_content: _builtins.str,
                 email_recover_content: _builtins.str,
                 email_recover_title: _builtins.str,
                 email_title: _builtins.str,
                 robot_content: _builtins.str,
                 sms_content: _builtins.str,
                 sms_recover_content: _builtins.str,
                 tts_content: _builtins.str,
                 tts_recover_content: _builtins.str):
        """
        :param _builtins.str email_content: The content of the email notification.
        :param _builtins.str email_recover_content: The content of the email notification for restored alerts.
        :param _builtins.str email_recover_title: The title of the email notification for restored alerts.
        :param _builtins.str email_title: The title of the email notification.
        :param _builtins.str robot_content: The content of the robot notification.
        :param _builtins.str sms_content: The content of the SMS notification.
        :param _builtins.str sms_recover_content: The content of the SMS notification for restored alerts.
        :param _builtins.str tts_content: The content of the TTS notification.
        :param _builtins.str tts_recover_content: The content of the TTS notification for restored alerts.
        """
        pulumi.set(__self__, "email_content", email_content)
        pulumi.set(__self__, "email_recover_content", email_recover_content)
        pulumi.set(__self__, "email_recover_title", email_recover_title)
        pulumi.set(__self__, "email_title", email_title)
        pulumi.set(__self__, "robot_content", robot_content)
        pulumi.set(__self__, "sms_content", sms_content)
        pulumi.set(__self__, "sms_recover_content", sms_recover_content)
        pulumi.set(__self__, "tts_content", tts_content)
        pulumi.set(__self__, "tts_recover_content", tts_recover_content)

    @_builtins.property
    @pulumi.getter(name="emailContent")
    def email_content(self) -> _builtins.str:
        """
        The content of the email notification.
        """
        return pulumi.get(self, "email_content")

    @_builtins.property
    @pulumi.getter(name="emailRecoverContent")
    def email_recover_content(self) -> _builtins.str:
        """
        The content of the email notification for restored alerts.
        """
        return pulumi.get(self, "email_recover_content")

    @_builtins.property
    @pulumi.getter(name="emailRecoverTitle")
    def email_recover_title(self) -> _builtins.str:
        """
        The title of the email notification for restored alerts.
        """
        return pulumi.get(self, "email_recover_title")

    @_builtins.property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> _builtins.str:
        """
        The title of the email notification.
        """
        return pulumi.get(self, "email_title")

    @_builtins.property
    @pulumi.getter(name="robotContent")
    def robot_content(self) -> _builtins.str:
        """
        The content of the robot notification.
        """
        return pulumi.get(self, "robot_content")

    @_builtins.property
    @pulumi.getter(name="smsContent")
    def sms_content(self) -> _builtins.str:
        """
        The content of the SMS notification.
        """
        return pulumi.get(self, "sms_content")

    @_builtins.property
    @pulumi.getter(name="smsRecoverContent")
    def sms_recover_content(self) -> _builtins.str:
        """
        The content of the SMS notification for restored alerts.
        """
        return pulumi.get(self, "sms_recover_content")

    @_builtins.property
    @pulumi.getter(name="ttsContent")
    def tts_content(self) -> _builtins.str:
        """
        The content of the TTS notification.
        """
        return pulumi.get(self, "tts_content")

    @_builtins.property
    @pulumi.getter(name="ttsRecoverContent")
    def tts_recover_content(self) -> _builtins.str:
        """
        The content of the TTS notification for restored alerts.
        """
        return pulumi.get(self, "tts_recover_content")


@pulumi.output_type
class PrometheusAlertRuleAnnotation(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the annotation.
        :param _builtins.str value: The value of the annotation.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the annotation.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the annotation.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PrometheusAlertRuleLabel(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the label.
        :param _builtins.str value: The value of the label.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticTaskAvailableAssertion(dict):
    def __init__(__self__, *,
                 expect: _builtins.str,
                 operator: _builtins.str,
                 type: _builtins.str,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str expect: Expected value.
        :param _builtins.str operator: Condition: gt: greater than; gte: greater than or equal to; lt: less than; te: less than or equal to; eq: equal to; neq: not equal to; ctn: contains; nctn: does not contain; exist: exists; n_exist: does not exist; belong: belongs to; reg_match: regular matching.
        :param _builtins.str type: Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        :param _builtins.str target: Check the target. If the target is HttpResCode, HttpResBody, or httpressetime, you do not need to specify the target. If the target is HttpResHead, you need to specify the key in the header. If the target is HttpResHead, you need to use jsonPath.
        """
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def expect(self) -> _builtins.str:
        """
        Expected value.
        """
        return pulumi.get(self, "expect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Condition: gt: greater than; gte: greater than or equal to; lt: less than; te: less than or equal to; eq: equal to; neq: not equal to; ctn: contains; nctn: does not contain; exist: exists; n_exist: does not exist; belong: belongs to; reg_match: regular matching.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Check the target. If the target is HttpResCode, HttpResBody, or httpressetime, you do not need to specify the target. If the target is HttpResHead, you need to specify the key in the header. If the target is HttpResHead, you need to use jsonPath.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class SyntheticTaskCommonSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHost":
            suggest = "custom_host"
        elif key == "ipType":
            suggest = "ip_type"
        elif key == "isOpenTrace":
            suggest = "is_open_trace"
        elif key == "monitorSamples":
            suggest = "monitor_samples"
        elif key == "traceClientType":
            suggest = "trace_client_type"
        elif key == "xtraceRegion":
            suggest = "xtrace_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCommonSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCommonSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCommonSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_host: Optional['outputs.SyntheticTaskCommonSettingCustomHost'] = None,
                 ip_type: Optional[_builtins.int] = None,
                 is_open_trace: Optional[_builtins.bool] = None,
                 monitor_samples: Optional[_builtins.int] = None,
                 trace_client_type: Optional[_builtins.int] = None,
                 xtrace_region: Optional[_builtins.str] = None):
        """
        :param 'SyntheticTaskCommonSettingCustomHostArgs' custom_host: Custom host. See `custom_host` below.
        :param _builtins.int ip_type: IpType.
        :param _builtins.bool is_open_trace: Whether to enable link tracking.
        :param _builtins.int monitor_samples: Whether the monitoring samples are evenly distributed:
               - 0: No
               1: Yes.
        :param _builtins.int trace_client_type: Link trace client type:
               - 0:ARMS Agent
               - 1:OpenTelemetry
               - 2:Jaeger.
        :param _builtins.str xtrace_region: The link data is reported to the region.
        """
        if custom_host is not None:
            pulumi.set(__self__, "custom_host", custom_host)
        if ip_type is not None:
            pulumi.set(__self__, "ip_type", ip_type)
        if is_open_trace is not None:
            pulumi.set(__self__, "is_open_trace", is_open_trace)
        if monitor_samples is not None:
            pulumi.set(__self__, "monitor_samples", monitor_samples)
        if trace_client_type is not None:
            pulumi.set(__self__, "trace_client_type", trace_client_type)
        if xtrace_region is not None:
            pulumi.set(__self__, "xtrace_region", xtrace_region)

    @_builtins.property
    @pulumi.getter(name="customHost")
    def custom_host(self) -> Optional['outputs.SyntheticTaskCommonSettingCustomHost']:
        """
        Custom host. See `custom_host` below.
        """
        return pulumi.get(self, "custom_host")

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> Optional[_builtins.int]:
        """
        IpType.
        """
        return pulumi.get(self, "ip_type")

    @_builtins.property
    @pulumi.getter(name="isOpenTrace")
    def is_open_trace(self) -> Optional[_builtins.bool]:
        """
        Whether to enable link tracking.
        """
        return pulumi.get(self, "is_open_trace")

    @_builtins.property
    @pulumi.getter(name="monitorSamples")
    def monitor_samples(self) -> Optional[_builtins.int]:
        """
        Whether the monitoring samples are evenly distributed:
        - 0: No
        1: Yes.
        """
        return pulumi.get(self, "monitor_samples")

    @_builtins.property
    @pulumi.getter(name="traceClientType")
    def trace_client_type(self) -> Optional[_builtins.int]:
        """
        Link trace client type:
        - 0:ARMS Agent
        - 1:OpenTelemetry
        - 2:Jaeger.
        """
        return pulumi.get(self, "trace_client_type")

    @_builtins.property
    @pulumi.getter(name="xtraceRegion")
    def xtrace_region(self) -> Optional[_builtins.str]:
        """
        The link data is reported to the region.
        """
        return pulumi.get(self, "xtrace_region")


@pulumi.output_type
class SyntheticTaskCommonSettingCustomHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectType":
            suggest = "select_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCommonSettingCustomHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCommonSettingCustomHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCommonSettingCustomHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence['outputs.SyntheticTaskCommonSettingCustomHostHost'],
                 select_type: _builtins.int):
        """
        :param Sequence['SyntheticTaskCommonSettingCustomHostHostArgs'] hosts: The host list. See `hosts` below.
        :param _builtins.int select_type: Selection method:
               - 0: Random
               - 1: Polling.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "select_type", select_type)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence['outputs.SyntheticTaskCommonSettingCustomHostHost']:
        """
        The host list. See `hosts` below.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="selectType")
    def select_type(self) -> _builtins.int:
        """
        Selection method:
        - 0: Random
        - 1: Polling.
        """
        return pulumi.get(self, "select_type")


@pulumi.output_type
class SyntheticTaskCommonSettingCustomHostHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCommonSettingCustomHostHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCommonSettingCustomHostHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCommonSettingCustomHostHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: _builtins.str,
                 ip_type: _builtins.int,
                 ips: Sequence[_builtins.str]):
        """
        :param _builtins.str domain: Domain Name.
        :param _builtins.int ip_type: IpType.
        :param Sequence[_builtins.str] ips: The IP list.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "ip_type", ip_type)
        pulumi.set(__self__, "ips", ips)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain Name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> _builtins.int:
        """
        IpType.
        """
        return pulumi.get(self, "ip_type")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        The IP list.
        """
        return pulumi.get(self, "ips")


@pulumi.output_type
class SyntheticTaskCustomPeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "startHour":
            suggest = "start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCustomPeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCustomPeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCustomPeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour: Optional[_builtins.int] = None,
                 start_hour: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_hour: End hours, 0-24.
        :param _builtins.int start_hour: Starting hours, 0-24.
        """
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)

    @_builtins.property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[_builtins.int]:
        """
        End hours, 0-24.
        """
        return pulumi.get(self, "end_hour")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[_builtins.int]:
        """
        Starting hours, 0-24.
        """
        return pulumi.get(self, "start_hour")


@pulumi.output_type
class SyntheticTaskMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cityCode":
            suggest = "city_code"
        elif key == "clientType":
            suggest = "client_type"
        elif key == "operatorCode":
            suggest = "operator_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 city_code: _builtins.str,
                 client_type: _builtins.int,
                 operator_code: _builtins.str):
        """
        :param _builtins.str city_code: The city code of monitor.
        :param _builtins.int client_type: The type of monitor.
        :param _builtins.str operator_code: The operator code of monitor.
        """
        pulumi.set(__self__, "city_code", city_code)
        pulumi.set(__self__, "client_type", client_type)
        pulumi.set(__self__, "operator_code", operator_code)

    @_builtins.property
    @pulumi.getter(name="cityCode")
    def city_code(self) -> _builtins.str:
        """
        The city code of monitor.
        """
        return pulumi.get(self, "city_code")

    @_builtins.property
    @pulumi.getter(name="clientType")
    def client_type(self) -> _builtins.int:
        """
        The type of monitor.
        """
        return pulumi.get(self, "client_type")

    @_builtins.property
    @pulumi.getter(name="operatorCode")
    def operator_code(self) -> _builtins.str:
        """
        The operator code of monitor.
        """
        return pulumi.get(self, "operator_code")


@pulumi.output_type
class SyntheticTaskMonitorConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiHttp":
            suggest = "api_http"
        elif key == "fileDownload":
            suggest = "file_download"
        elif key == "netDns":
            suggest = "net_dns"
        elif key == "netIcmp":
            suggest = "net_icmp"
        elif key == "netTcp":
            suggest = "net_tcp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_http: Optional['outputs.SyntheticTaskMonitorConfApiHttp'] = None,
                 file_download: Optional['outputs.SyntheticTaskMonitorConfFileDownload'] = None,
                 net_dns: Optional['outputs.SyntheticTaskMonitorConfNetDns'] = None,
                 net_icmp: Optional['outputs.SyntheticTaskMonitorConfNetIcmp'] = None,
                 net_tcp: Optional['outputs.SyntheticTaskMonitorConfNetTcp'] = None,
                 stream: Optional['outputs.SyntheticTaskMonitorConfStream'] = None,
                 website: Optional['outputs.SyntheticTaskMonitorConfWebsite'] = None):
        """
        :param 'SyntheticTaskMonitorConfApiHttpArgs' api_http: HTTP(S) task configuration information. See `api_http` below.
        :param 'SyntheticTaskMonitorConfFileDownloadArgs' file_download: File download type task configuration. See `file_download` below.
        :param 'SyntheticTaskMonitorConfNetDnsArgs' net_dns: The configuration parameters of the DNS dial test. Required when TaskType is 3. See `net_dns` below.
        :param 'SyntheticTaskMonitorConfNetIcmpArgs' net_icmp: ICMP dialing configuration parameters. Required when TaskType is 1. See `net_icmp` below.
        :param 'SyntheticTaskMonitorConfNetTcpArgs' net_tcp: The configuration parameters of TCP dial test. Required when TaskType is 2. See `net_tcp` below.
        :param 'SyntheticTaskMonitorConfStreamArgs' stream: Streaming Media Dial Test Configuration. See `stream` below.
        :param 'SyntheticTaskMonitorConfWebsiteArgs' website: Website speed measurement type task configuration. See `website` below.
        """
        if api_http is not None:
            pulumi.set(__self__, "api_http", api_http)
        if file_download is not None:
            pulumi.set(__self__, "file_download", file_download)
        if net_dns is not None:
            pulumi.set(__self__, "net_dns", net_dns)
        if net_icmp is not None:
            pulumi.set(__self__, "net_icmp", net_icmp)
        if net_tcp is not None:
            pulumi.set(__self__, "net_tcp", net_tcp)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if website is not None:
            pulumi.set(__self__, "website", website)

    @_builtins.property
    @pulumi.getter(name="apiHttp")
    def api_http(self) -> Optional['outputs.SyntheticTaskMonitorConfApiHttp']:
        """
        HTTP(S) task configuration information. See `api_http` below.
        """
        return pulumi.get(self, "api_http")

    @_builtins.property
    @pulumi.getter(name="fileDownload")
    def file_download(self) -> Optional['outputs.SyntheticTaskMonitorConfFileDownload']:
        """
        File download type task configuration. See `file_download` below.
        """
        return pulumi.get(self, "file_download")

    @_builtins.property
    @pulumi.getter(name="netDns")
    def net_dns(self) -> Optional['outputs.SyntheticTaskMonitorConfNetDns']:
        """
        The configuration parameters of the DNS dial test. Required when TaskType is 3. See `net_dns` below.
        """
        return pulumi.get(self, "net_dns")

    @_builtins.property
    @pulumi.getter(name="netIcmp")
    def net_icmp(self) -> Optional['outputs.SyntheticTaskMonitorConfNetIcmp']:
        """
        ICMP dialing configuration parameters. Required when TaskType is 1. See `net_icmp` below.
        """
        return pulumi.get(self, "net_icmp")

    @_builtins.property
    @pulumi.getter(name="netTcp")
    def net_tcp(self) -> Optional['outputs.SyntheticTaskMonitorConfNetTcp']:
        """
        The configuration parameters of TCP dial test. Required when TaskType is 2. See `net_tcp` below.
        """
        return pulumi.get(self, "net_tcp")

    @_builtins.property
    @pulumi.getter
    def stream(self) -> Optional['outputs.SyntheticTaskMonitorConfStream']:
        """
        Streaming Media Dial Test Configuration. See `stream` below.
        """
        return pulumi.get(self, "stream")

    @_builtins.property
    @pulumi.getter
    def website(self) -> Optional['outputs.SyntheticTaskMonitorConfWebsite']:
        """
        Website speed measurement type task configuration. See `website` below.
        """
        return pulumi.get(self, "website")


@pulumi.output_type
class SyntheticTaskMonitorConfApiHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "requestBody":
            suggest = "request_body"
        elif key == "requestHeaders":
            suggest = "request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfApiHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfApiHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfApiHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: _builtins.str,
                 connect_timeout: Optional[_builtins.int] = None,
                 method: Optional[_builtins.str] = None,
                 request_body: Optional['outputs.SyntheticTaskMonitorConfApiHttpRequestBody'] = None,
                 request_headers: Optional[Mapping[str, _builtins.str]] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str target_url: The target URL.
        :param _builtins.int connect_timeout: Connection timeout, in ms. Default 5000. Optional range: 1000-300000ms.
        :param _builtins.str method: HTTP method, GET or POST.
        :param 'SyntheticTaskMonitorConfApiHttpRequestBodyArgs' request_body: HTTP request body. See `request_body` below.
        :param Mapping[str, _builtins.str] request_headers: HTTP request header.
        :param _builtins.int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[_builtins.int]:
        """
        Connection timeout, in ms. Default 5000. Optional range: 1000-300000ms.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        HTTP method, GET or POST.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional['outputs.SyntheticTaskMonitorConfApiHttpRequestBody']:
        """
        HTTP request body. See `request_body` below.
        """
        return pulumi.get(self, "request_body")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP request header.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfApiHttpRequestBody(dict):
    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The request body content, in JSON string format. When the type is text/plain,application/json,application/xml,text/html, the content can be converted to a JSON string.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        The request body content, in JSON string format. When the type is text/plain,application/json,application/xml,text/html, the content can be converted to a JSON string.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SyntheticTaskMonitorConfFileDownload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "customHeaderContent":
            suggest = "custom_header_content"
        elif key == "downloadKernel":
            suggest = "download_kernel"
        elif key == "ignoreCertificateAuthError":
            suggest = "ignore_certificate_auth_error"
        elif key == "ignoreCertificateCanceledError":
            suggest = "ignore_certificate_canceled_error"
        elif key == "ignoreCertificateOutOfDateError":
            suggest = "ignore_certificate_out_of_date_error"
        elif key == "ignoreCertificateStatusError":
            suggest = "ignore_certificate_status_error"
        elif key == "ignoreCertificateUntrustworthyError":
            suggest = "ignore_certificate_untrustworthy_error"
        elif key == "ignoreCertificateUsingError":
            suggest = "ignore_certificate_using_error"
        elif key == "ignoreInvalidHostError":
            suggest = "ignore_invalid_host_error"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "quickProtocol":
            suggest = "quick_protocol"
        elif key == "transmissionSize":
            suggest = "transmission_size"
        elif key == "validateKeywords":
            suggest = "validate_keywords"
        elif key == "verifyWay":
            suggest = "verify_way"
        elif key == "whiteList":
            suggest = "white_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfFileDownload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfFileDownload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfFileDownload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: _builtins.str,
                 connection_timeout: Optional[_builtins.int] = None,
                 custom_header_content: Optional[Mapping[str, _builtins.str]] = None,
                 download_kernel: Optional[_builtins.int] = None,
                 ignore_certificate_auth_error: Optional[_builtins.int] = None,
                 ignore_certificate_canceled_error: Optional[_builtins.int] = None,
                 ignore_certificate_out_of_date_error: Optional[_builtins.int] = None,
                 ignore_certificate_status_error: Optional[_builtins.int] = None,
                 ignore_certificate_untrustworthy_error: Optional[_builtins.int] = None,
                 ignore_certificate_using_error: Optional[_builtins.int] = None,
                 ignore_invalid_host_error: Optional[_builtins.int] = None,
                 monitor_timeout: Optional[_builtins.int] = None,
                 quick_protocol: Optional[_builtins.int] = None,
                 redirection: Optional[_builtins.int] = None,
                 transmission_size: Optional[_builtins.int] = None,
                 validate_keywords: Optional[_builtins.str] = None,
                 verify_way: Optional[_builtins.int] = None,
                 white_list: Optional[_builtins.str] = None):
        """
        :param _builtins.str target_url: The target URL.
        :param _builtins.int connection_timeout: Connection timeout time, in ms. Default 5000. Optional range: 1000-120000ms.
        :param Mapping[str, _builtins.str] custom_header_content: Custom header, in JSON Map format.
        :param _builtins.int download_kernel: Download the kernel.
               - 1:curl
               - 0:WinInet
               Default 1.
        :param _builtins.int ignore_certificate_auth_error: Ignore CA Certificate authorization error 0: Do not ignore, 1: ignore, default 1.
        :param _builtins.int ignore_certificate_canceled_error: Ignore certificate revocation error 0: Do not ignore, 1: ignore, default 1.
        :param _builtins.int ignore_certificate_out_of_date_error: Ignore certificate expiration error 0: not ignored, 1: Ignored, default 1.
        :param _builtins.int ignore_certificate_status_error: The certificate status error is ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        :param _builtins.int ignore_certificate_untrustworthy_error: The certificate cannot be trusted and ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        :param _builtins.int ignore_certificate_using_error: Ignore certificate usage error 0: Do not ignore, 1: ignore, default 1.
        :param _builtins.int ignore_invalid_host_error: Invalid host error ignored, 0: not ignored, 1: Ignored, default 1.
        :param _builtins.int monitor_timeout: Monitoring timeout, in ms. Not required, 20000 by default.
        :param _builtins.int quick_protocol: Quick agreement
               - 1:http1
               - 2:http2
               - 3:http3
               Default 1.
        :param _builtins.int redirection: When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        :param _builtins.int transmission_size: The transmission size, in KB. The default value is 2048KB. The transmission size of the downloaded file must be between 1 and 20480KB.
        :param _builtins.str validate_keywords: Verify keywords.
        :param _builtins.int verify_way: The verification method.
               - 0: Do not validate
               - 1: Validation string
               - 2:MD5 validation.
        :param _builtins.str white_list: DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if download_kernel is not None:
            pulumi.set(__self__, "download_kernel", download_kernel)
        if ignore_certificate_auth_error is not None:
            pulumi.set(__self__, "ignore_certificate_auth_error", ignore_certificate_auth_error)
        if ignore_certificate_canceled_error is not None:
            pulumi.set(__self__, "ignore_certificate_canceled_error", ignore_certificate_canceled_error)
        if ignore_certificate_out_of_date_error is not None:
            pulumi.set(__self__, "ignore_certificate_out_of_date_error", ignore_certificate_out_of_date_error)
        if ignore_certificate_status_error is not None:
            pulumi.set(__self__, "ignore_certificate_status_error", ignore_certificate_status_error)
        if ignore_certificate_untrustworthy_error is not None:
            pulumi.set(__self__, "ignore_certificate_untrustworthy_error", ignore_certificate_untrustworthy_error)
        if ignore_certificate_using_error is not None:
            pulumi.set(__self__, "ignore_certificate_using_error", ignore_certificate_using_error)
        if ignore_invalid_host_error is not None:
            pulumi.set(__self__, "ignore_invalid_host_error", ignore_invalid_host_error)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if quick_protocol is not None:
            pulumi.set(__self__, "quick_protocol", quick_protocol)
        if redirection is not None:
            pulumi.set(__self__, "redirection", redirection)
        if transmission_size is not None:
            pulumi.set(__self__, "transmission_size", transmission_size)
        if validate_keywords is not None:
            pulumi.set(__self__, "validate_keywords", validate_keywords)
        if verify_way is not None:
            pulumi.set(__self__, "verify_way", verify_way)
        if white_list is not None:
            pulumi.set(__self__, "white_list", white_list)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        Connection timeout time, in ms. Default 5000. Optional range: 1000-120000ms.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @_builtins.property
    @pulumi.getter(name="downloadKernel")
    def download_kernel(self) -> Optional[_builtins.int]:
        """
        Download the kernel.
        - 1:curl
        - 0:WinInet
        Default 1.
        """
        return pulumi.get(self, "download_kernel")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateAuthError")
    def ignore_certificate_auth_error(self) -> Optional[_builtins.int]:
        """
        Ignore CA Certificate authorization error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_auth_error")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateCanceledError")
    def ignore_certificate_canceled_error(self) -> Optional[_builtins.int]:
        """
        Ignore certificate revocation error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_canceled_error")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateOutOfDateError")
    def ignore_certificate_out_of_date_error(self) -> Optional[_builtins.int]:
        """
        Ignore certificate expiration error 0: not ignored, 1: Ignored, default 1.
        """
        return pulumi.get(self, "ignore_certificate_out_of_date_error")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateStatusError")
    def ignore_certificate_status_error(self) -> Optional[_builtins.int]:
        """
        The certificate status error is ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_status_error")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateUntrustworthyError")
    def ignore_certificate_untrustworthy_error(self) -> Optional[_builtins.int]:
        """
        The certificate cannot be trusted and ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_untrustworthy_error")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateUsingError")
    def ignore_certificate_using_error(self) -> Optional[_builtins.int]:
        """
        Ignore certificate usage error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_using_error")

    @_builtins.property
    @pulumi.getter(name="ignoreInvalidHostError")
    def ignore_invalid_host_error(self) -> Optional[_builtins.int]:
        """
        Invalid host error ignored, 0: not ignored, 1: Ignored, default 1.
        """
        return pulumi.get(self, "ignore_invalid_host_error")

    @_builtins.property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[_builtins.int]:
        """
        Monitoring timeout, in ms. Not required, 20000 by default.
        """
        return pulumi.get(self, "monitor_timeout")

    @_builtins.property
    @pulumi.getter(name="quickProtocol")
    def quick_protocol(self) -> Optional[_builtins.int]:
        """
        Quick agreement
        - 1:http1
        - 2:http2
        - 3:http3
        Default 1.
        """
        return pulumi.get(self, "quick_protocol")

    @_builtins.property
    @pulumi.getter
    def redirection(self) -> Optional[_builtins.int]:
        """
        When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        """
        return pulumi.get(self, "redirection")

    @_builtins.property
    @pulumi.getter(name="transmissionSize")
    def transmission_size(self) -> Optional[_builtins.int]:
        """
        The transmission size, in KB. The default value is 2048KB. The transmission size of the downloaded file must be between 1 and 20480KB.
        """
        return pulumi.get(self, "transmission_size")

    @_builtins.property
    @pulumi.getter(name="validateKeywords")
    def validate_keywords(self) -> Optional[_builtins.str]:
        """
        Verify keywords.
        """
        return pulumi.get(self, "validate_keywords")

    @_builtins.property
    @pulumi.getter(name="verifyWay")
    def verify_way(self) -> Optional[_builtins.int]:
        """
        The verification method.
        - 0: Do not validate
        - 1: Validation string
        - 2:MD5 validation.
        """
        return pulumi.get(self, "verify_way")

    @_builtins.property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> Optional[_builtins.str]:
        """
        DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "white_list")


@pulumi.output_type
class SyntheticTaskMonitorConfNetDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "dnsServerIpType":
            suggest = "dns_server_ip_type"
        elif key == "nsServer":
            suggest = "ns_server"
        elif key == "queryMethod":
            suggest = "query_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfNetDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfNetDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfNetDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: _builtins.str,
                 dns_server_ip_type: Optional[_builtins.int] = None,
                 ns_server: Optional[_builtins.str] = None,
                 query_method: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str target_url: The target URL.
        :param _builtins.int dns_server_ip_type: The IP address type of the DNS server.
               - 0 (default):ipv4
               - 1:ipv6
               2: Automatic.
        :param _builtins.str ns_server: The IP address of the NS server. The default value is 114.114.114.114.
        :param _builtins.int query_method: DNS query method.
               - 0 (default): Recursive
               - 1: Iteration.
        :param _builtins.int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if dns_server_ip_type is not None:
            pulumi.set(__self__, "dns_server_ip_type", dns_server_ip_type)
        if ns_server is not None:
            pulumi.set(__self__, "ns_server", ns_server)
        if query_method is not None:
            pulumi.set(__self__, "query_method", query_method)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="dnsServerIpType")
    def dns_server_ip_type(self) -> Optional[_builtins.int]:
        """
        The IP address type of the DNS server.
        - 0 (default):ipv4
        - 1:ipv6
        2: Automatic.
        """
        return pulumi.get(self, "dns_server_ip_type")

    @_builtins.property
    @pulumi.getter(name="nsServer")
    def ns_server(self) -> Optional[_builtins.str]:
        """
        The IP address of the NS server. The default value is 114.114.114.114.
        """
        return pulumi.get(self, "ns_server")

    @_builtins.property
    @pulumi.getter(name="queryMethod")
    def query_method(self) -> Optional[_builtins.int]:
        """
        DNS query method.
        - 0 (default): Recursive
        - 1: Iteration.
        """
        return pulumi.get(self, "query_method")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfNetIcmp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "packageNum":
            suggest = "package_num"
        elif key == "packageSize":
            suggest = "package_size"
        elif key == "splitPackage":
            suggest = "split_package"
        elif key == "tracertEnable":
            suggest = "tracert_enable"
        elif key == "tracertNumMax":
            suggest = "tracert_num_max"
        elif key == "tracertTimeout":
            suggest = "tracert_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfNetIcmp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfNetIcmp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfNetIcmp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: _builtins.str,
                 interval: Optional[_builtins.int] = None,
                 package_num: Optional[_builtins.int] = None,
                 package_size: Optional[_builtins.int] = None,
                 split_package: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None,
                 tracert_enable: Optional[_builtins.bool] = None,
                 tracert_num_max: Optional[_builtins.int] = None,
                 tracert_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str target_url: The target URL.
        :param _builtins.int interval: The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        :param _builtins.int package_num: Number of ICMP(Ping) packets sent. The minimum value is 1, the maximum value is 50, and the default is 4.
        :param _builtins.int package_size: The size of the sent ICMP(Ping) packet. The unit is byte. The ICMP(PING) packet size is limited to 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        :param _builtins.bool split_package: Whether to split ICMP(Ping) packets. The default is true.
        :param _builtins.int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        :param _builtins.bool tracert_enable: Whether to enable tracert. The default is true.
        :param _builtins.int tracert_num_max: The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        :param _builtins.int tracert_timeout: The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if package_num is not None:
            pulumi.set(__self__, "package_num", package_num)
        if package_size is not None:
            pulumi.set(__self__, "package_size", package_size)
        if split_package is not None:
            pulumi.set(__self__, "split_package", split_package)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracert_enable is not None:
            pulumi.set(__self__, "tracert_enable", tracert_enable)
        if tracert_num_max is not None:
            pulumi.set(__self__, "tracert_num_max", tracert_num_max)
        if tracert_timeout is not None:
            pulumi.set(__self__, "tracert_timeout", tracert_timeout)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="packageNum")
    def package_num(self) -> Optional[_builtins.int]:
        """
        Number of ICMP(Ping) packets sent. The minimum value is 1, the maximum value is 50, and the default is 4.
        """
        return pulumi.get(self, "package_num")

    @_builtins.property
    @pulumi.getter(name="packageSize")
    def package_size(self) -> Optional[_builtins.int]:
        """
        The size of the sent ICMP(Ping) packet. The unit is byte. The ICMP(PING) packet size is limited to 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        """
        return pulumi.get(self, "package_size")

    @_builtins.property
    @pulumi.getter(name="splitPackage")
    def split_package(self) -> Optional[_builtins.bool]:
        """
        Whether to split ICMP(Ping) packets. The default is true.
        """
        return pulumi.get(self, "split_package")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="tracertEnable")
    def tracert_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable tracert. The default is true.
        """
        return pulumi.get(self, "tracert_enable")

    @_builtins.property
    @pulumi.getter(name="tracertNumMax")
    def tracert_num_max(self) -> Optional[_builtins.int]:
        """
        The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        """
        return pulumi.get(self, "tracert_num_max")

    @_builtins.property
    @pulumi.getter(name="tracertTimeout")
    def tracert_timeout(self) -> Optional[_builtins.int]:
        """
        The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        return pulumi.get(self, "tracert_timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfNetTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "connectTimes":
            suggest = "connect_times"
        elif key == "tracertEnable":
            suggest = "tracert_enable"
        elif key == "tracertNumMax":
            suggest = "tracert_num_max"
        elif key == "tracertTimeout":
            suggest = "tracert_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfNetTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfNetTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfNetTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: _builtins.str,
                 connect_times: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None,
                 tracert_enable: Optional[_builtins.bool] = None,
                 tracert_num_max: Optional[_builtins.int] = None,
                 tracert_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str target_url: The target URL.
        :param _builtins.int connect_times: The number of TCP connections established. The minimum value is 1, the maximum value is 16, and the default is 4.
        :param _builtins.int interval: The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        :param _builtins.int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        :param _builtins.bool tracert_enable: Whether to enable tracert. The default is true.
        :param _builtins.int tracert_num_max: The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        :param _builtins.int tracert_timeout: The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connect_times is not None:
            pulumi.set(__self__, "connect_times", connect_times)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracert_enable is not None:
            pulumi.set(__self__, "tracert_enable", tracert_enable)
        if tracert_num_max is not None:
            pulumi.set(__self__, "tracert_num_max", tracert_num_max)
        if tracert_timeout is not None:
            pulumi.set(__self__, "tracert_timeout", tracert_timeout)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="connectTimes")
    def connect_times(self) -> Optional[_builtins.int]:
        """
        The number of TCP connections established. The minimum value is 1, the maximum value is 16, and the default is 4.
        """
        return pulumi.get(self, "connect_times")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="tracertEnable")
    def tracert_enable(self) -> Optional[_builtins.bool]:
        """
        Whether to enable tracert. The default is true.
        """
        return pulumi.get(self, "tracert_enable")

    @_builtins.property
    @pulumi.getter(name="tracertNumMax")
    def tracert_num_max(self) -> Optional[_builtins.int]:
        """
        The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        """
        return pulumi.get(self, "tracert_num_max")

    @_builtins.property
    @pulumi.getter(name="tracertTimeout")
    def tracert_timeout(self) -> Optional[_builtins.int]:
        """
        The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        return pulumi.get(self, "tracert_timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHeaderContent":
            suggest = "custom_header_content"
        elif key == "playerType":
            suggest = "player_type"
        elif key == "streamAddressType":
            suggest = "stream_address_type"
        elif key == "streamMonitorTimeout":
            suggest = "stream_monitor_timeout"
        elif key == "streamType":
            suggest = "stream_type"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "whiteList":
            suggest = "white_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_header_content: Optional[Mapping[str, _builtins.str]] = None,
                 player_type: Optional[_builtins.int] = None,
                 stream_address_type: Optional[_builtins.int] = None,
                 stream_monitor_timeout: Optional[_builtins.int] = None,
                 stream_type: Optional[_builtins.int] = None,
                 target_url: Optional[_builtins.str] = None,
                 white_list: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] custom_header_content: Custom header, in JSON Map format.
        :param _builtins.int player_type: Player, do not pass the default 12.
               - 12:VLC
               - 2:FlashPlayer.
        :param _builtins.int stream_address_type: Resource address type:
               - 1: Resource address.
               - 0: page address, not 0 by default.
        :param _builtins.int stream_monitor_timeout: Monitoring duration, in seconds, up to 60s, not 60 by default.
        :param _builtins.int stream_type: Audio and video flags: 0-video, 1-audio.
        :param _builtins.str target_url: The target URL.
        :param _builtins.str white_list: DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if player_type is not None:
            pulumi.set(__self__, "player_type", player_type)
        if stream_address_type is not None:
            pulumi.set(__self__, "stream_address_type", stream_address_type)
        if stream_monitor_timeout is not None:
            pulumi.set(__self__, "stream_monitor_timeout", stream_monitor_timeout)
        if stream_type is not None:
            pulumi.set(__self__, "stream_type", stream_type)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)
        if white_list is not None:
            pulumi.set(__self__, "white_list", white_list)

    @_builtins.property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @_builtins.property
    @pulumi.getter(name="playerType")
    def player_type(self) -> Optional[_builtins.int]:
        """
        Player, do not pass the default 12.
        - 12:VLC
        - 2:FlashPlayer.
        """
        return pulumi.get(self, "player_type")

    @_builtins.property
    @pulumi.getter(name="streamAddressType")
    def stream_address_type(self) -> Optional[_builtins.int]:
        """
        Resource address type:
        - 1: Resource address.
        - 0: page address, not 0 by default.
        """
        return pulumi.get(self, "stream_address_type")

    @_builtins.property
    @pulumi.getter(name="streamMonitorTimeout")
    def stream_monitor_timeout(self) -> Optional[_builtins.int]:
        """
        Monitoring duration, in seconds, up to 60s, not 60 by default.
        """
        return pulumi.get(self, "stream_monitor_timeout")

    @_builtins.property
    @pulumi.getter(name="streamType")
    def stream_type(self) -> Optional[_builtins.int]:
        """
        Audio and video flags: 0-video, 1-audio.
        """
        return pulumi.get(self, "stream_type")

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[_builtins.str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> Optional[_builtins.str]:
        """
        DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "white_list")


@pulumi.output_type
class SyntheticTaskMonitorConfWebsite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "automaticScrolling":
            suggest = "automatic_scrolling"
        elif key == "customHeader":
            suggest = "custom_header"
        elif key == "customHeaderContent":
            suggest = "custom_header_content"
        elif key == "disableCache":
            suggest = "disable_cache"
        elif key == "disableCompression":
            suggest = "disable_compression"
        elif key == "dnsHijackWhitelist":
            suggest = "dns_hijack_whitelist"
        elif key == "elementBlacklist":
            suggest = "element_blacklist"
        elif key == "filterInvalidIp":
            suggest = "filter_invalid_ip"
        elif key == "flowHijackJumpTimes":
            suggest = "flow_hijack_jump_times"
        elif key == "flowHijackLogo":
            suggest = "flow_hijack_logo"
        elif key == "ignoreCertificateError":
            suggest = "ignore_certificate_error"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "pageTamper":
            suggest = "page_tamper"
        elif key == "slowElementThreshold":
            suggest = "slow_element_threshold"
        elif key == "verifyStringBlacklist":
            suggest = "verify_string_blacklist"
        elif key == "verifyStringWhitelist":
            suggest = "verify_string_whitelist"
        elif key == "waitCompletionTime":
            suggest = "wait_completion_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfWebsite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfWebsite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfWebsite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: _builtins.str,
                 automatic_scrolling: Optional[_builtins.int] = None,
                 custom_header: Optional[_builtins.int] = None,
                 custom_header_content: Optional[Mapping[str, _builtins.str]] = None,
                 disable_cache: Optional[_builtins.int] = None,
                 disable_compression: Optional[_builtins.int] = None,
                 dns_hijack_whitelist: Optional[_builtins.str] = None,
                 element_blacklist: Optional[_builtins.str] = None,
                 filter_invalid_ip: Optional[_builtins.int] = None,
                 flow_hijack_jump_times: Optional[_builtins.int] = None,
                 flow_hijack_logo: Optional[_builtins.str] = None,
                 ignore_certificate_error: Optional[_builtins.int] = None,
                 monitor_timeout: Optional[_builtins.int] = None,
                 page_tamper: Optional[_builtins.str] = None,
                 redirection: Optional[_builtins.int] = None,
                 slow_element_threshold: Optional[_builtins.int] = None,
                 verify_string_blacklist: Optional[_builtins.str] = None,
                 verify_string_whitelist: Optional[_builtins.str] = None,
                 wait_completion_time: Optional[_builtins.int] = None):
        """
        :param _builtins.str target_url: The target URL.
        :param _builtins.int automatic_scrolling: Whether to support automatic scrolling screen, loading page.
               - 0 (default): No
               1: Yes.
        :param _builtins.int custom_header: Custom header.
               - 0 (default): Off
               - 1: Modify the first package
               - 2: Modify all packages.
        :param Mapping[str, _builtins.str] custom_header_content: Custom header, in JSON Map format.
        :param _builtins.int disable_cache: Whether to disable caching.
               - 0: not disabled
               - 1 (default): Disabled.
        :param _builtins.int disable_compression: The Accept-Encoding field is used to determine whether to Accept compressed files. 0-do not disable, 1-disable, the default is 0.
        :param _builtins.str dns_hijack_whitelist: When a domain name (such as www.aliyun.com) is resolved, if the resolved IP address or CNAME is not in the DNS hijacking white list, the user will fail to access or return a target IP address that is not Aliyun. If the IP or CNAME in the resolution result is in the DNS white list, it will be determined that DNS hijacking has not occurred.  Fill in the format: Domain name: matching rules. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        :param _builtins.str element_blacklist: If an element configured in the element blacklist appears during page loading, the element is not requested to be loaded.
        :param _builtins.int filter_invalid_ip: Whether to filter invalid IP parameters. 0: filter, 1: do not filter. The default value is 0.
        :param _builtins.int flow_hijack_jump_times: Identify elements: Set the total number of elements on the Browse page.
        :param _builtins.str flow_hijack_logo: Hijacking ID: Set the matching key information. Enter the hijacking keyword or key element, with an asterisk (*) allowed.
        :param _builtins.int ignore_certificate_error: Whether to ignore certificate errors during certificate verification in SSL Handshake and continue browsing. 0-do not ignore, 1-ignore. The default value is 1.
        :param _builtins.int monitor_timeout: Monitoring timeout, in ms. Not required, 20000 by default.
        :param _builtins.str page_tamper: Monitoring the page appears to be tampered with elements other than the domain settings that belong to the page. Common manifestations are pop-up advertisements, floating advertisements, jumps, etc.  Fill in the format: Domain name: Element. You can fill multiple elements separated by a vertical bar (|). For example, www.aliyun.com:|/cc/bb/a.gif |/vv/bb/cc.jpg indicates that all the other elements of the www.aliyun.com domain name except the basic document,/cc/bb/a.gif, and/vv/bb/cc.jpg are tampered.
        :param _builtins.int redirection: When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        :param _builtins.int slow_element_threshold: The slow element threshold, in ms, is 5000 by default and can be selected from 1 to 300000ms.
        :param _builtins.str verify_string_blacklist: The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any of the blacklisted strings, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        :param _builtins.str verify_string_whitelist: The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist. Otherwise, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        :param _builtins.int wait_completion_time: The maximum waiting time, in ms, is 5000 by default and can be selected from 5000 ms to 300000ms.
        """
        pulumi.set(__self__, "target_url", target_url)
        if automatic_scrolling is not None:
            pulumi.set(__self__, "automatic_scrolling", automatic_scrolling)
        if custom_header is not None:
            pulumi.set(__self__, "custom_header", custom_header)
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_compression is not None:
            pulumi.set(__self__, "disable_compression", disable_compression)
        if dns_hijack_whitelist is not None:
            pulumi.set(__self__, "dns_hijack_whitelist", dns_hijack_whitelist)
        if element_blacklist is not None:
            pulumi.set(__self__, "element_blacklist", element_blacklist)
        if filter_invalid_ip is not None:
            pulumi.set(__self__, "filter_invalid_ip", filter_invalid_ip)
        if flow_hijack_jump_times is not None:
            pulumi.set(__self__, "flow_hijack_jump_times", flow_hijack_jump_times)
        if flow_hijack_logo is not None:
            pulumi.set(__self__, "flow_hijack_logo", flow_hijack_logo)
        if ignore_certificate_error is not None:
            pulumi.set(__self__, "ignore_certificate_error", ignore_certificate_error)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if page_tamper is not None:
            pulumi.set(__self__, "page_tamper", page_tamper)
        if redirection is not None:
            pulumi.set(__self__, "redirection", redirection)
        if slow_element_threshold is not None:
            pulumi.set(__self__, "slow_element_threshold", slow_element_threshold)
        if verify_string_blacklist is not None:
            pulumi.set(__self__, "verify_string_blacklist", verify_string_blacklist)
        if verify_string_whitelist is not None:
            pulumi.set(__self__, "verify_string_whitelist", verify_string_whitelist)
        if wait_completion_time is not None:
            pulumi.set(__self__, "wait_completion_time", wait_completion_time)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="automaticScrolling")
    def automatic_scrolling(self) -> Optional[_builtins.int]:
        """
        Whether to support automatic scrolling screen, loading page.
        - 0 (default): No
        1: Yes.
        """
        return pulumi.get(self, "automatic_scrolling")

    @_builtins.property
    @pulumi.getter(name="customHeader")
    def custom_header(self) -> Optional[_builtins.int]:
        """
        Custom header.
        - 0 (default): Off
        - 1: Modify the first package
        - 2: Modify all packages.
        """
        return pulumi.get(self, "custom_header")

    @_builtins.property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @_builtins.property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[_builtins.int]:
        """
        Whether to disable caching.
        - 0: not disabled
        - 1 (default): Disabled.
        """
        return pulumi.get(self, "disable_cache")

    @_builtins.property
    @pulumi.getter(name="disableCompression")
    def disable_compression(self) -> Optional[_builtins.int]:
        """
        The Accept-Encoding field is used to determine whether to Accept compressed files. 0-do not disable, 1-disable, the default is 0.
        """
        return pulumi.get(self, "disable_compression")

    @_builtins.property
    @pulumi.getter(name="dnsHijackWhitelist")
    def dns_hijack_whitelist(self) -> Optional[_builtins.str]:
        """
        When a domain name (such as www.aliyun.com) is resolved, if the resolved IP address or CNAME is not in the DNS hijacking white list, the user will fail to access or return a target IP address that is not Aliyun. If the IP or CNAME in the resolution result is in the DNS white list, it will be determined that DNS hijacking has not occurred.  Fill in the format: Domain name: matching rules. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "dns_hijack_whitelist")

    @_builtins.property
    @pulumi.getter(name="elementBlacklist")
    def element_blacklist(self) -> Optional[_builtins.str]:
        """
        If an element configured in the element blacklist appears during page loading, the element is not requested to be loaded.
        """
        return pulumi.get(self, "element_blacklist")

    @_builtins.property
    @pulumi.getter(name="filterInvalidIp")
    def filter_invalid_ip(self) -> Optional[_builtins.int]:
        """
        Whether to filter invalid IP parameters. 0: filter, 1: do not filter. The default value is 0.
        """
        return pulumi.get(self, "filter_invalid_ip")

    @_builtins.property
    @pulumi.getter(name="flowHijackJumpTimes")
    def flow_hijack_jump_times(self) -> Optional[_builtins.int]:
        """
        Identify elements: Set the total number of elements on the Browse page.
        """
        return pulumi.get(self, "flow_hijack_jump_times")

    @_builtins.property
    @pulumi.getter(name="flowHijackLogo")
    def flow_hijack_logo(self) -> Optional[_builtins.str]:
        """
        Hijacking ID: Set the matching key information. Enter the hijacking keyword or key element, with an asterisk (*) allowed.
        """
        return pulumi.get(self, "flow_hijack_logo")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateError")
    def ignore_certificate_error(self) -> Optional[_builtins.int]:
        """
        Whether to ignore certificate errors during certificate verification in SSL Handshake and continue browsing. 0-do not ignore, 1-ignore. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_error")

    @_builtins.property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[_builtins.int]:
        """
        Monitoring timeout, in ms. Not required, 20000 by default.
        """
        return pulumi.get(self, "monitor_timeout")

    @_builtins.property
    @pulumi.getter(name="pageTamper")
    def page_tamper(self) -> Optional[_builtins.str]:
        """
        Monitoring the page appears to be tampered with elements other than the domain settings that belong to the page. Common manifestations are pop-up advertisements, floating advertisements, jumps, etc.  Fill in the format: Domain name: Element. You can fill multiple elements separated by a vertical bar (|). For example, www.aliyun.com:|/cc/bb/a.gif |/vv/bb/cc.jpg indicates that all the other elements of the www.aliyun.com domain name except the basic document,/cc/bb/a.gif, and/vv/bb/cc.jpg are tampered.
        """
        return pulumi.get(self, "page_tamper")

    @_builtins.property
    @pulumi.getter
    def redirection(self) -> Optional[_builtins.int]:
        """
        When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        """
        return pulumi.get(self, "redirection")

    @_builtins.property
    @pulumi.getter(name="slowElementThreshold")
    def slow_element_threshold(self) -> Optional[_builtins.int]:
        """
        The slow element threshold, in ms, is 5000 by default and can be selected from 1 to 300000ms.
        """
        return pulumi.get(self, "slow_element_threshold")

    @_builtins.property
    @pulumi.getter(name="verifyStringBlacklist")
    def verify_string_blacklist(self) -> Optional[_builtins.str]:
        """
        The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any of the blacklisted strings, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        """
        return pulumi.get(self, "verify_string_blacklist")

    @_builtins.property
    @pulumi.getter(name="verifyStringWhitelist")
    def verify_string_whitelist(self) -> Optional[_builtins.str]:
        """
        The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist. Otherwise, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        """
        return pulumi.get(self, "verify_string_whitelist")

    @_builtins.property
    @pulumi.getter(name="waitCompletionTime")
    def wait_completion_time(self) -> Optional[_builtins.int]:
        """
        The maximum waiting time, in ms, is 5000 by default and can be selected from 5000 ms to 300000ms.
        """
        return pulumi.get(self, "wait_completion_time")


@pulumi.output_type
class GetAddonReleasesReleaseResult(dict):
    def __init__(__self__, *,
                 addon_name: _builtins.str,
                 addon_release_name: _builtins.str,
                 addon_version: _builtins.str,
                 alert_rule_count: _builtins.int,
                 aliyun_lang: _builtins.str,
                 create_time: _builtins.str,
                 dashboard_count: _builtins.int,
                 environment_id: _builtins.str,
                 exporter_count: _builtins.int,
                 id: _builtins.str,
                 region_id: _builtins.str):
        """
        :param _builtins.str addon_name: The name of the add-on.
        :param _builtins.str addon_release_name: The name of the Addon Release.
        :param _builtins.str addon_version: The version of the add-on.
        :param _builtins.int alert_rule_count: The number of alert rules.
        :param _builtins.str aliyun_lang: The language.
        :param _builtins.str create_time: The time when the add-on was created.
        :param _builtins.int dashboard_count: The number of dashboards.
        :param _builtins.str environment_id: The environment ID.
        :param _builtins.int exporter_count: The number of exporters.
        :param _builtins.str id: The ID of the Addon Release. It formats as `<environment_id>:<addon_release_name>`.
        :param _builtins.str region_id: The region ID.
        """
        pulumi.set(__self__, "addon_name", addon_name)
        pulumi.set(__self__, "addon_release_name", addon_release_name)
        pulumi.set(__self__, "addon_version", addon_version)
        pulumi.set(__self__, "alert_rule_count", alert_rule_count)
        pulumi.set(__self__, "aliyun_lang", aliyun_lang)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "dashboard_count", dashboard_count)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "exporter_count", exporter_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "region_id", region_id)

    @_builtins.property
    @pulumi.getter(name="addonName")
    def addon_name(self) -> _builtins.str:
        """
        The name of the add-on.
        """
        return pulumi.get(self, "addon_name")

    @_builtins.property
    @pulumi.getter(name="addonReleaseName")
    def addon_release_name(self) -> _builtins.str:
        """
        The name of the Addon Release.
        """
        return pulumi.get(self, "addon_release_name")

    @_builtins.property
    @pulumi.getter(name="addonVersion")
    def addon_version(self) -> _builtins.str:
        """
        The version of the add-on.
        """
        return pulumi.get(self, "addon_version")

    @_builtins.property
    @pulumi.getter(name="alertRuleCount")
    def alert_rule_count(self) -> _builtins.int:
        """
        The number of alert rules.
        """
        return pulumi.get(self, "alert_rule_count")

    @_builtins.property
    @pulumi.getter(name="aliyunLang")
    def aliyun_lang(self) -> _builtins.str:
        """
        The language.
        """
        return pulumi.get(self, "aliyun_lang")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The time when the add-on was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dashboardCount")
    def dashboard_count(self) -> _builtins.int:
        """
        The number of dashboards.
        """
        return pulumi.get(self, "dashboard_count")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        The environment ID.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter(name="exporterCount")
    def exporter_count(self) -> _builtins.int:
        """
        The number of exporters.
        """
        return pulumi.get(self, "exporter_count")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Addon Release. It formats as `<environment_id>:<addon_release_name>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        """
        The region ID.
        """
        return pulumi.get(self, "region_id")


@pulumi.output_type
class GetAlertContactGroupsGroupResult(dict):
    def __init__(__self__, *,
                 alert_contact_group_id: _builtins.str,
                 alert_contact_group_name: _builtins.str,
                 contact_ids: Sequence[_builtins.str],
                 create_time: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str alert_contact_group_id: The first ID of the resource.
        :param _builtins.str alert_contact_group_name: The name of the resource.
        :param Sequence[_builtins.str] contact_ids: contact ids.
        :param _builtins.str create_time: The creation time of the resource.
        :param _builtins.str id: The ID of the Alert Contact Group.
        """
        pulumi.set(__self__, "alert_contact_group_id", alert_contact_group_id)
        pulumi.set(__self__, "alert_contact_group_name", alert_contact_group_name)
        pulumi.set(__self__, "contact_ids", contact_ids)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="alertContactGroupId")
    def alert_contact_group_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "alert_contact_group_id")

    @_builtins.property
    @pulumi.getter(name="alertContactGroupName")
    def alert_contact_group_name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "alert_contact_group_name")

    @_builtins.property
    @pulumi.getter(name="contactIds")
    def contact_ids(self) -> Sequence[_builtins.str]:
        """
        contact ids.
        """
        return pulumi.get(self, "contact_ids")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Alert Contact Group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAlertContactsContactResult(dict):
    def __init__(__self__, *,
                 alert_contact_id: _builtins.str,
                 alert_contact_name: _builtins.str,
                 create_time: _builtins.str,
                 ding_robot_webhook_url: _builtins.str,
                 email: _builtins.str,
                 id: _builtins.str,
                 phone_num: _builtins.str,
                 system_noc: _builtins.bool,
                 webhook: _builtins.str):
        """
        :param _builtins.str alert_contact_id: Contact ID.
        :param _builtins.str alert_contact_name: The name of the alert contact.
        :param _builtins.str create_time: The Creation Time Timestamp.
        :param _builtins.str ding_robot_webhook_url: The webhook URL of the DingTalk chatbot.
        :param _builtins.str email: The email address of the alert contact.
        :param _builtins.str id: The ID of the Alert Contact.
        :param _builtins.str phone_num: The mobile number of the alert contact.
        :param _builtins.bool system_noc: Specifies whether the alert contact receives system notifications.
        :param _builtins.str webhook: Webhook Information.
        """
        pulumi.set(__self__, "alert_contact_id", alert_contact_id)
        pulumi.set(__self__, "alert_contact_name", alert_contact_name)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "ding_robot_webhook_url", ding_robot_webhook_url)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "phone_num", phone_num)
        pulumi.set(__self__, "system_noc", system_noc)
        pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="alertContactId")
    def alert_contact_id(self) -> _builtins.str:
        """
        Contact ID.
        """
        return pulumi.get(self, "alert_contact_id")

    @_builtins.property
    @pulumi.getter(name="alertContactName")
    def alert_contact_name(self) -> _builtins.str:
        """
        The name of the alert contact.
        """
        return pulumi.get(self, "alert_contact_name")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The Creation Time Timestamp.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dingRobotWebhookUrl")
    def ding_robot_webhook_url(self) -> _builtins.str:
        """
        The webhook URL of the DingTalk chatbot.
        """
        return pulumi.get(self, "ding_robot_webhook_url")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email address of the alert contact.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Alert Contact.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="phoneNum")
    def phone_num(self) -> _builtins.str:
        """
        The mobile number of the alert contact.
        """
        return pulumi.get(self, "phone_num")

    @_builtins.property
    @pulumi.getter(name="systemNoc")
    def system_noc(self) -> _builtins.bool:
        """
        Specifies whether the alert contact receives system notifications.
        """
        return pulumi.get(self, "system_noc")

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> _builtins.str:
        """
        Webhook Information.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetAlertRobotsRobotResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 daily_noc: _builtins.str,
                 daily_noc_time: _builtins.str,
                 id: _builtins.str,
                 robot_addr: _builtins.str,
                 robot_id: _builtins.str,
                 robot_name: _builtins.str,
                 robot_type: _builtins.str):
        """
        :param _builtins.str create_time: The creation time of the resource.
        :param _builtins.str daily_noc: Specifies whether the alert robot receives daily notifications.
        :param _builtins.str daily_noc_time: The time of the daily notification.
        :param _builtins.str id: The ID of the Alert Robot.
        :param _builtins.str robot_addr: The webhook url of the robot.
        :param _builtins.str robot_id: The id of the robot.
        :param _builtins.str robot_name: The name of the robot.
        :param _builtins.str robot_type: The robot type.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "daily_noc", daily_noc)
        pulumi.set(__self__, "daily_noc_time", daily_noc_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "robot_addr", robot_addr)
        pulumi.set(__self__, "robot_id", robot_id)
        pulumi.set(__self__, "robot_name", robot_name)
        pulumi.set(__self__, "robot_type", robot_type)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dailyNoc")
    def daily_noc(self) -> _builtins.str:
        """
        Specifies whether the alert robot receives daily notifications.
        """
        return pulumi.get(self, "daily_noc")

    @_builtins.property
    @pulumi.getter(name="dailyNocTime")
    def daily_noc_time(self) -> _builtins.str:
        """
        The time of the daily notification.
        """
        return pulumi.get(self, "daily_noc_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Alert Robot.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="robotAddr")
    def robot_addr(self) -> _builtins.str:
        """
        The webhook url of the robot.
        """
        return pulumi.get(self, "robot_addr")

    @_builtins.property
    @pulumi.getter(name="robotId")
    def robot_id(self) -> _builtins.str:
        """
        The id of the robot.
        """
        return pulumi.get(self, "robot_id")

    @_builtins.property
    @pulumi.getter(name="robotName")
    def robot_name(self) -> _builtins.str:
        """
        The name of the robot.
        """
        return pulumi.get(self, "robot_name")

    @_builtins.property
    @pulumi.getter(name="robotType")
    def robot_type(self) -> _builtins.str:
        """
        The robot type.
        """
        return pulumi.get(self, "robot_type")


@pulumi.output_type
class GetDispatchRulesRuleResult(dict):
    def __init__(__self__, *,
                 dispatch_rule_id: _builtins.str,
                 dispatch_rule_name: _builtins.str,
                 group_rules: Sequence['outputs.GetDispatchRulesRuleGroupRuleResult'],
                 id: _builtins.str,
                 label_match_expression_grids: Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridResult'],
                 notify_rules: Sequence['outputs.GetDispatchRulesRuleNotifyRuleResult'],
                 notify_templates: Sequence['outputs.GetDispatchRulesRuleNotifyTemplateResult'],
                 status: _builtins.str):
        """
        :param _builtins.str dispatch_rule_id: Dispatch rule ID.
        :param _builtins.str dispatch_rule_name: The name of the dispatch rule.
        :param Sequence['GetDispatchRulesRuleGroupRuleArgs'] group_rules: Sets the event group.
        :param _builtins.str id: The ID of the Dispatch Rule.
        :param Sequence['GetDispatchRulesRuleLabelMatchExpressionGridArgs'] label_match_expression_grids: Sets the dispatch rule.
        :param Sequence['GetDispatchRulesRuleNotifyRuleArgs'] notify_rules: Sets the notification rule.
        :param Sequence['GetDispatchRulesRuleNotifyTemplateArgs'] notify_templates: (Available since v1.238.0) The notification method.
        :param _builtins.str status: The resource status of Alert Dispatch Rule.
        """
        pulumi.set(__self__, "dispatch_rule_id", dispatch_rule_id)
        pulumi.set(__self__, "dispatch_rule_name", dispatch_rule_name)
        pulumi.set(__self__, "group_rules", group_rules)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label_match_expression_grids", label_match_expression_grids)
        pulumi.set(__self__, "notify_rules", notify_rules)
        pulumi.set(__self__, "notify_templates", notify_templates)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="dispatchRuleId")
    def dispatch_rule_id(self) -> _builtins.str:
        """
        Dispatch rule ID.
        """
        return pulumi.get(self, "dispatch_rule_id")

    @_builtins.property
    @pulumi.getter(name="dispatchRuleName")
    def dispatch_rule_name(self) -> _builtins.str:
        """
        The name of the dispatch rule.
        """
        return pulumi.get(self, "dispatch_rule_name")

    @_builtins.property
    @pulumi.getter(name="groupRules")
    def group_rules(self) -> Sequence['outputs.GetDispatchRulesRuleGroupRuleResult']:
        """
        Sets the event group.
        """
        return pulumi.get(self, "group_rules")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Dispatch Rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="labelMatchExpressionGrids")
    def label_match_expression_grids(self) -> Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridResult']:
        """
        Sets the dispatch rule.
        """
        return pulumi.get(self, "label_match_expression_grids")

    @_builtins.property
    @pulumi.getter(name="notifyRules")
    def notify_rules(self) -> Sequence['outputs.GetDispatchRulesRuleNotifyRuleResult']:
        """
        Sets the notification rule.
        """
        return pulumi.get(self, "notify_rules")

    @_builtins.property
    @pulumi.getter(name="notifyTemplates")
    def notify_templates(self) -> Sequence['outputs.GetDispatchRulesRuleNotifyTemplateResult']:
        """
        (Available since v1.238.0) The notification method.
        """
        return pulumi.get(self, "notify_templates")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The resource status of Alert Dispatch Rule.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDispatchRulesRuleGroupRuleResult(dict):
    def __init__(__self__, *,
                 group_interval: _builtins.int,
                 group_wait_time: _builtins.int,
                 grouping_fields: Sequence[_builtins.str],
                 repeat_interval: _builtins.int):
        """
        :param _builtins.int group_interval: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param _builtins.int group_wait_time: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param Sequence[_builtins.str] grouping_fields: The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        :param _builtins.int repeat_interval: The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        pulumi.set(__self__, "group_interval", group_interval)
        pulumi.set(__self__, "group_wait_time", group_wait_time)
        pulumi.set(__self__, "grouping_fields", grouping_fields)
        pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> _builtins.int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupWaitTime")
    def group_wait_time(self) -> _builtins.int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_wait_time")

    @_builtins.property
    @pulumi.getter(name="groupingFields")
    def grouping_fields(self) -> Sequence[_builtins.str]:
        """
        The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        """
        return pulumi.get(self, "grouping_fields")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> _builtins.int:
        """
        The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class GetDispatchRulesRuleLabelMatchExpressionGridResult(dict):
    def __init__(__self__, *,
                 label_match_expression_groups: Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult']):
        """
        :param Sequence['GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs'] label_match_expression_groups: Sets the dispatch rule.
        """
        pulumi.set(__self__, "label_match_expression_groups", label_match_expression_groups)

    @_builtins.property
    @pulumi.getter(name="labelMatchExpressionGroups")
    def label_match_expression_groups(self) -> Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult']:
        """
        Sets the dispatch rule.
        """
        return pulumi.get(self, "label_match_expression_groups")


@pulumi.output_type
class GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult(dict):
    def __init__(__self__, *,
                 label_match_expressions: Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult']):
        """
        :param Sequence['GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs'] label_match_expressions: Sets the dispatch rule.
        """
        pulumi.set(__self__, "label_match_expressions", label_match_expressions)

    @_builtins.property
    @pulumi.getter(name="labelMatchExpressions")
    def label_match_expressions(self) -> Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult']:
        """
        Sets the dispatch rule.
        """
        return pulumi.get(self, "label_match_expressions")


@pulumi.output_type
class GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key of the tag of the dispatch rule.
        :param _builtins.str operator: The operator used in the dispatch rule.
        :param _builtins.str value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the tag of the dispatch rule.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator used in the dispatch rule.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDispatchRulesRuleNotifyRuleResult(dict):
    def __init__(__self__, *,
                 notify_channels: Sequence[_builtins.str],
                 notify_end_time: _builtins.str,
                 notify_objects: Sequence['outputs.GetDispatchRulesRuleNotifyRuleNotifyObjectResult'],
                 notify_start_time: _builtins.str):
        """
        :param Sequence[_builtins.str] notify_channels: A list of notification methods.
        :param _builtins.str notify_end_time: (Available since v1.237.0) End time of notification.
        :param Sequence['GetDispatchRulesRuleNotifyRuleNotifyObjectArgs'] notify_objects: Sets the notification object.
        :param _builtins.str notify_start_time: (Available since v1.237.0) Start time of notification.
        """
        pulumi.set(__self__, "notify_channels", notify_channels)
        pulumi.set(__self__, "notify_end_time", notify_end_time)
        pulumi.set(__self__, "notify_objects", notify_objects)
        pulumi.set(__self__, "notify_start_time", notify_start_time)

    @_builtins.property
    @pulumi.getter(name="notifyChannels")
    def notify_channels(self) -> Sequence[_builtins.str]:
        """
        A list of notification methods.
        """
        return pulumi.get(self, "notify_channels")

    @_builtins.property
    @pulumi.getter(name="notifyEndTime")
    def notify_end_time(self) -> _builtins.str:
        """
        (Available since v1.237.0) End time of notification.
        """
        return pulumi.get(self, "notify_end_time")

    @_builtins.property
    @pulumi.getter(name="notifyObjects")
    def notify_objects(self) -> Sequence['outputs.GetDispatchRulesRuleNotifyRuleNotifyObjectResult']:
        """
        Sets the notification object.
        """
        return pulumi.get(self, "notify_objects")

    @_builtins.property
    @pulumi.getter(name="notifyStartTime")
    def notify_start_time(self) -> _builtins.str:
        """
        (Available since v1.237.0) Start time of notification.
        """
        return pulumi.get(self, "notify_start_time")


@pulumi.output_type
class GetDispatchRulesRuleNotifyRuleNotifyObjectResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 notify_object_id: _builtins.str,
                 notify_type: _builtins.str):
        """
        :param _builtins.str name: The name of the contact or contact group.
        :param _builtins.str notify_object_id: The ID of the contact or contact group.
        :param _builtins.str notify_type: The type of the alert contact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_object_id", notify_object_id)
        pulumi.set(__self__, "notify_type", notify_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the contact or contact group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifyObjectId")
    def notify_object_id(self) -> _builtins.str:
        """
        The ID of the contact or contact group.
        """
        return pulumi.get(self, "notify_object_id")

    @_builtins.property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> _builtins.str:
        """
        The type of the alert contact.
        """
        return pulumi.get(self, "notify_type")


@pulumi.output_type
class GetDispatchRulesRuleNotifyTemplateResult(dict):
    def __init__(__self__, *,
                 email_content: _builtins.str,
                 email_recover_content: _builtins.str,
                 email_recover_title: _builtins.str,
                 email_title: _builtins.str,
                 robot_content: _builtins.str,
                 sms_content: _builtins.str,
                 sms_recover_content: _builtins.str,
                 tts_content: _builtins.str,
                 tts_recover_content: _builtins.str):
        """
        :param _builtins.str email_content: The content of the email.
        :param _builtins.str email_recover_content: The content of the email.
        :param _builtins.str email_recover_title: The title of the email.
        :param _builtins.str email_title: The title of the email.
        :param _builtins.str robot_content: The content of the robot.
        :param _builtins.str sms_content: The content of the SMS.
        :param _builtins.str sms_recover_content: The content of the SMS.
        :param _builtins.str tts_content: The content of the TTS.
        :param _builtins.str tts_recover_content: The content of the TTS.
        """
        pulumi.set(__self__, "email_content", email_content)
        pulumi.set(__self__, "email_recover_content", email_recover_content)
        pulumi.set(__self__, "email_recover_title", email_recover_title)
        pulumi.set(__self__, "email_title", email_title)
        pulumi.set(__self__, "robot_content", robot_content)
        pulumi.set(__self__, "sms_content", sms_content)
        pulumi.set(__self__, "sms_recover_content", sms_recover_content)
        pulumi.set(__self__, "tts_content", tts_content)
        pulumi.set(__self__, "tts_recover_content", tts_recover_content)

    @_builtins.property
    @pulumi.getter(name="emailContent")
    def email_content(self) -> _builtins.str:
        """
        The content of the email.
        """
        return pulumi.get(self, "email_content")

    @_builtins.property
    @pulumi.getter(name="emailRecoverContent")
    def email_recover_content(self) -> _builtins.str:
        """
        The content of the email.
        """
        return pulumi.get(self, "email_recover_content")

    @_builtins.property
    @pulumi.getter(name="emailRecoverTitle")
    def email_recover_title(self) -> _builtins.str:
        """
        The title of the email.
        """
        return pulumi.get(self, "email_recover_title")

    @_builtins.property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> _builtins.str:
        """
        The title of the email.
        """
        return pulumi.get(self, "email_title")

    @_builtins.property
    @pulumi.getter(name="robotContent")
    def robot_content(self) -> _builtins.str:
        """
        The content of the robot.
        """
        return pulumi.get(self, "robot_content")

    @_builtins.property
    @pulumi.getter(name="smsContent")
    def sms_content(self) -> _builtins.str:
        """
        The content of the SMS.
        """
        return pulumi.get(self, "sms_content")

    @_builtins.property
    @pulumi.getter(name="smsRecoverContent")
    def sms_recover_content(self) -> _builtins.str:
        """
        The content of the SMS.
        """
        return pulumi.get(self, "sms_recover_content")

    @_builtins.property
    @pulumi.getter(name="ttsContent")
    def tts_content(self) -> _builtins.str:
        """
        The content of the TTS.
        """
        return pulumi.get(self, "tts_content")

    @_builtins.property
    @pulumi.getter(name="ttsRecoverContent")
    def tts_recover_content(self) -> _builtins.str:
        """
        The content of the TTS.
        """
        return pulumi.get(self, "tts_recover_content")


@pulumi.output_type
class GetEnvCustomJobsJobResult(dict):
    def __init__(__self__, *,
                 config_yaml: _builtins.str,
                 env_custom_job_name: _builtins.str,
                 environment_id: _builtins.str,
                 id: _builtins.str,
                 region_id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str config_yaml: The YAML configuration string.
        :param _builtins.str env_custom_job_name: The name of the custom job.
        :param _builtins.str environment_id: The ID of the environment instance.
        :param _builtins.str id: The ID of the custom job. It formats as `<environment_id>:<env_custom_job_name>`.
        :param _builtins.str region_id: The region ID.
        :param _builtins.str status: The status of the custom job.
        """
        pulumi.set(__self__, "config_yaml", config_yaml)
        pulumi.set(__self__, "env_custom_job_name", env_custom_job_name)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "region_id", region_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="configYaml")
    def config_yaml(self) -> _builtins.str:
        """
        The YAML configuration string.
        """
        return pulumi.get(self, "config_yaml")

    @_builtins.property
    @pulumi.getter(name="envCustomJobName")
    def env_custom_job_name(self) -> _builtins.str:
        """
        The name of the custom job.
        """
        return pulumi.get(self, "env_custom_job_name")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        The ID of the environment instance.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the custom job. It formats as `<environment_id>:<env_custom_job_name>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        """
        The region ID.
        """
        return pulumi.get(self, "region_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the custom job.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEnvFeaturesFeatureResult(dict):
    def __init__(__self__, *,
                 aliyun_lang: _builtins.str,
                 env_feature_name: _builtins.str,
                 environment_id: _builtins.str,
                 feature_version: _builtins.str,
                 id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str aliyun_lang: The language.
        :param _builtins.str env_feature_name: The name of the feature.
        :param _builtins.str environment_id: The ID of the environment instance.
        :param _builtins.str feature_version: The version of the feature.
        :param _builtins.str id: The ID of the Env Feature. It formats as `<environment_id>:<env_feature_name>`.
        :param _builtins.str status: The status of the feature.
        """
        pulumi.set(__self__, "aliyun_lang", aliyun_lang)
        pulumi.set(__self__, "env_feature_name", env_feature_name)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "feature_version", feature_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="aliyunLang")
    def aliyun_lang(self) -> _builtins.str:
        """
        The language.
        """
        return pulumi.get(self, "aliyun_lang")

    @_builtins.property
    @pulumi.getter(name="envFeatureName")
    def env_feature_name(self) -> _builtins.str:
        """
        The name of the feature.
        """
        return pulumi.get(self, "env_feature_name")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        The ID of the environment instance.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter(name="featureVersion")
    def feature_version(self) -> _builtins.str:
        """
        The version of the feature.
        """
        return pulumi.get(self, "feature_version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Env Feature. It formats as `<environment_id>:<env_feature_name>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the feature.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEnvPodMonitorsMonitorResult(dict):
    def __init__(__self__, *,
                 config_yaml: _builtins.str,
                 env_pod_monitor_name: _builtins.str,
                 environment_id: _builtins.str,
                 id: _builtins.str,
                 namespace: _builtins.str,
                 region_id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str config_yaml: The YAML configuration string.
        :param _builtins.str env_pod_monitor_name: The name of the PodMonitor.
        :param _builtins.str environment_id: The environment ID.
        :param _builtins.str id: The ID of the PodMonitor. It formats as `<environment_id>:<namespace>:<env_pod_monitor_name>`.
        :param _builtins.str namespace: The namespace.
        :param _builtins.str region_id: The region ID.
        :param _builtins.str status: The status of the PodMonitor.
        """
        pulumi.set(__self__, "config_yaml", config_yaml)
        pulumi.set(__self__, "env_pod_monitor_name", env_pod_monitor_name)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "region_id", region_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="configYaml")
    def config_yaml(self) -> _builtins.str:
        """
        The YAML configuration string.
        """
        return pulumi.get(self, "config_yaml")

    @_builtins.property
    @pulumi.getter(name="envPodMonitorName")
    def env_pod_monitor_name(self) -> _builtins.str:
        """
        The name of the PodMonitor.
        """
        return pulumi.get(self, "env_pod_monitor_name")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        The environment ID.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the PodMonitor. It formats as `<environment_id>:<namespace>:<env_pod_monitor_name>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        """
        The region ID.
        """
        return pulumi.get(self, "region_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the PodMonitor.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEnvServiceMonitorsMonitorResult(dict):
    def __init__(__self__, *,
                 config_yaml: _builtins.str,
                 env_service_monitor_name: _builtins.str,
                 environment_id: _builtins.str,
                 id: _builtins.str,
                 namespace: _builtins.str,
                 region_id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str config_yaml: The YAML configuration string.
        :param _builtins.str env_service_monitor_name: The name of the ServiceMonitor.
        :param _builtins.str environment_id: The environment ID.
        :param _builtins.str id: The ID of the ServiceMonitor. It formats as `<environment_id>:<namespace>:<env_service_monitor_name>`.
        :param _builtins.str namespace: The namespace.
        :param _builtins.str region_id: The region ID.
        :param _builtins.str status: The status of the ServiceMonitor.
        """
        pulumi.set(__self__, "config_yaml", config_yaml)
        pulumi.set(__self__, "env_service_monitor_name", env_service_monitor_name)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "region_id", region_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="configYaml")
    def config_yaml(self) -> _builtins.str:
        """
        The YAML configuration string.
        """
        return pulumi.get(self, "config_yaml")

    @_builtins.property
    @pulumi.getter(name="envServiceMonitorName")
    def env_service_monitor_name(self) -> _builtins.str:
        """
        The name of the ServiceMonitor.
        """
        return pulumi.get(self, "env_service_monitor_name")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        The environment ID.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the ServiceMonitor. It formats as `<environment_id>:<namespace>:<env_service_monitor_name>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        """
        The region ID.
        """
        return pulumi.get(self, "region_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the ServiceMonitor.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEnvironmentsEnvironmentResult(dict):
    def __init__(__self__, *,
                 bind_resource_id: _builtins.str,
                 bind_resource_type: _builtins.str,
                 bind_vpc_cidr: _builtins.str,
                 environment_id: _builtins.str,
                 environment_name: _builtins.str,
                 environment_type: _builtins.str,
                 grafana_datasource_uid: _builtins.str,
                 grafana_folder_uid: _builtins.str,
                 id: _builtins.str,
                 managed_type: _builtins.str,
                 prometheus_instance_id: _builtins.str,
                 region_id: _builtins.str,
                 resource_group_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 user_id: _builtins.str):
        """
        :param _builtins.str bind_resource_id: The ID of the resource bound to the environment instance.
        :param _builtins.str bind_resource_type: The resource type.
        :param _builtins.str bind_vpc_cidr: The CIDR block that is bound to the VPC.
        :param _builtins.str environment_id: The ID of the environment instance.
        :param _builtins.str environment_name: The name of the environment instance.
        :param _builtins.str environment_type: The environment type. Valid values: `CS`, `ECS`, `Cloud`.
        :param _builtins.str grafana_datasource_uid: The unique ID of the Grafana data source.
        :param _builtins.str grafana_folder_uid: The unique ID of the Grafana directory.
        :param _builtins.str id: The ID of the environment instance.
        :param _builtins.str managed_type: Indicates whether agents or exporters are managed.
        :param _builtins.str prometheus_instance_id: The ID of the Prometheus instance.
        :param _builtins.str region_id: The region ID.
        :param _builtins.str resource_group_id: The ID of the resource group.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.str user_id: The user ID.
        """
        pulumi.set(__self__, "bind_resource_id", bind_resource_id)
        pulumi.set(__self__, "bind_resource_type", bind_resource_type)
        pulumi.set(__self__, "bind_vpc_cidr", bind_vpc_cidr)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "environment_name", environment_name)
        pulumi.set(__self__, "environment_type", environment_type)
        pulumi.set(__self__, "grafana_datasource_uid", grafana_datasource_uid)
        pulumi.set(__self__, "grafana_folder_uid", grafana_folder_uid)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "managed_type", managed_type)
        pulumi.set(__self__, "prometheus_instance_id", prometheus_instance_id)
        pulumi.set(__self__, "region_id", region_id)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="bindResourceId")
    def bind_resource_id(self) -> _builtins.str:
        """
        The ID of the resource bound to the environment instance.
        """
        return pulumi.get(self, "bind_resource_id")

    @_builtins.property
    @pulumi.getter(name="bindResourceType")
    def bind_resource_type(self) -> _builtins.str:
        """
        The resource type.
        """
        return pulumi.get(self, "bind_resource_type")

    @_builtins.property
    @pulumi.getter(name="bindVpcCidr")
    def bind_vpc_cidr(self) -> _builtins.str:
        """
        The CIDR block that is bound to the VPC.
        """
        return pulumi.get(self, "bind_vpc_cidr")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> _builtins.str:
        """
        The ID of the environment instance.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter(name="environmentName")
    def environment_name(self) -> _builtins.str:
        """
        The name of the environment instance.
        """
        return pulumi.get(self, "environment_name")

    @_builtins.property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> _builtins.str:
        """
        The environment type. Valid values: `CS`, `ECS`, `Cloud`.
        """
        return pulumi.get(self, "environment_type")

    @_builtins.property
    @pulumi.getter(name="grafanaDatasourceUid")
    def grafana_datasource_uid(self) -> _builtins.str:
        """
        The unique ID of the Grafana data source.
        """
        return pulumi.get(self, "grafana_datasource_uid")

    @_builtins.property
    @pulumi.getter(name="grafanaFolderUid")
    def grafana_folder_uid(self) -> _builtins.str:
        """
        The unique ID of the Grafana directory.
        """
        return pulumi.get(self, "grafana_folder_uid")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the environment instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="managedType")
    def managed_type(self) -> _builtins.str:
        """
        Indicates whether agents or exporters are managed.
        """
        return pulumi.get(self, "managed_type")

    @_builtins.property
    @pulumi.getter(name="prometheusInstanceId")
    def prometheus_instance_id(self) -> _builtins.str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "prometheus_instance_id")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        """
        The region ID.
        """
        return pulumi.get(self, "region_id")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> _builtins.str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        The user ID.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetIntegrationExportersIntegrationExporterResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 exporter_type: _builtins.str,
                 id: _builtins.str,
                 instance_id: _builtins.int,
                 instance_name: _builtins.str,
                 integration_type: _builtins.str,
                 param: _builtins.str,
                 target: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str cluster_id: The ID of the Prometheus instance.
        :param _builtins.str exporter_type: Integration Exporter Type.
        :param _builtins.str id: The ID of the Integration Exporter. It formats as `<cluster_id>:<integration_type>:<instance_id>`.
        :param _builtins.int instance_id: The ID of the Integration Exporter instance.
        :param _builtins.str instance_name: The name of the instance.
        :param _builtins.str integration_type: The type of prometheus integration.
        :param _builtins.str param: Exporter configuration parameter json string.
        :param _builtins.str target: Monitor the target address.
        :param _builtins.str version: The version information.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "exporter_type", exporter_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "param", param)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="exporterType")
    def exporter_type(self) -> _builtins.str:
        """
        Integration Exporter Type.
        """
        return pulumi.get(self, "exporter_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Integration Exporter. It formats as `<cluster_id>:<integration_type>:<instance_id>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.int:
        """
        The ID of the Integration Exporter instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The name of the instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> _builtins.str:
        """
        The type of prometheus integration.
        """
        return pulumi.get(self, "integration_type")

    @_builtins.property
    @pulumi.getter
    def param(self) -> _builtins.str:
        """
        Exporter configuration parameter json string.
        """
        return pulumi.get(self, "param")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Monitor the target address.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version information.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPrometheisPrometheiResult(dict):
    def __init__(__self__, *,
                 auth_token: _builtins.str,
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 cluster_type: _builtins.str,
                 grafana_instance_id: _builtins.str,
                 http_api_inter_url: _builtins.str,
                 http_api_intra_url: _builtins.str,
                 id: _builtins.str,
                 push_gate_way_inter_url: _builtins.str,
                 push_gate_way_intra_url: _builtins.str,
                 remote_read_inter_url: _builtins.str,
                 remote_read_intra_url: _builtins.str,
                 remote_write_inter_url: _builtins.str,
                 remote_write_intra_url: _builtins.str,
                 resource_group_id: _builtins.str,
                 security_group_id: _builtins.str,
                 sub_clusters_json: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 vpc_id: _builtins.str,
                 vswitch_id: _builtins.str):
        """
        :param _builtins.str auth_token: The token used to access the data source.
        :param _builtins.str cluster_id: The ID of the cluster.
        :param _builtins.str cluster_name: The name of the cluster.
        :param _builtins.str cluster_type: The type of the cluster.
        :param _builtins.str grafana_instance_id: The ID of the Grafana workspace.
        :param _builtins.str http_api_inter_url: Http api public network address.
        :param _builtins.str http_api_intra_url: Http api intranet address.
        :param _builtins.str id: The ID of the Prometheus.
        :param _builtins.str push_gate_way_inter_url: PushGateway public network Url.
        :param _builtins.str push_gate_way_intra_url: PushGateway intranet Url.
        :param _builtins.str remote_read_inter_url: Public Url of remoteRead.
        :param _builtins.str remote_read_intra_url: RemoteRead intranet Url.
        :param _builtins.str remote_write_inter_url: RemoteWrite public Url.
        :param _builtins.str remote_write_intra_url: RemoteWrite Intranet Url.
        :param _builtins.str resource_group_id: The ID of the resource group.
        :param _builtins.str security_group_id: The ID of the security group.
        :param _builtins.str sub_clusters_json: The child instance json string of the globalView instance.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.str vpc_id: The ID of the VPC.
        :param _builtins.str vswitch_id: The ID of the vSwitch.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "grafana_instance_id", grafana_instance_id)
        pulumi.set(__self__, "http_api_inter_url", http_api_inter_url)
        pulumi.set(__self__, "http_api_intra_url", http_api_intra_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "push_gate_way_inter_url", push_gate_way_inter_url)
        pulumi.set(__self__, "push_gate_way_intra_url", push_gate_way_intra_url)
        pulumi.set(__self__, "remote_read_inter_url", remote_read_inter_url)
        pulumi.set(__self__, "remote_read_intra_url", remote_read_intra_url)
        pulumi.set(__self__, "remote_write_inter_url", remote_write_inter_url)
        pulumi.set(__self__, "remote_write_intra_url", remote_write_intra_url)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "sub_clusters_json", sub_clusters_json)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vswitch_id", vswitch_id)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> _builtins.str:
        """
        The token used to access the data source.
        """
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        The type of the cluster.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="grafanaInstanceId")
    def grafana_instance_id(self) -> _builtins.str:
        """
        The ID of the Grafana workspace.
        """
        return pulumi.get(self, "grafana_instance_id")

    @_builtins.property
    @pulumi.getter(name="httpApiInterUrl")
    def http_api_inter_url(self) -> _builtins.str:
        """
        Http api public network address.
        """
        return pulumi.get(self, "http_api_inter_url")

    @_builtins.property
    @pulumi.getter(name="httpApiIntraUrl")
    def http_api_intra_url(self) -> _builtins.str:
        """
        Http api intranet address.
        """
        return pulumi.get(self, "http_api_intra_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Prometheus.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="pushGateWayInterUrl")
    def push_gate_way_inter_url(self) -> _builtins.str:
        """
        PushGateway public network Url.
        """
        return pulumi.get(self, "push_gate_way_inter_url")

    @_builtins.property
    @pulumi.getter(name="pushGateWayIntraUrl")
    def push_gate_way_intra_url(self) -> _builtins.str:
        """
        PushGateway intranet Url.
        """
        return pulumi.get(self, "push_gate_way_intra_url")

    @_builtins.property
    @pulumi.getter(name="remoteReadInterUrl")
    def remote_read_inter_url(self) -> _builtins.str:
        """
        Public Url of remoteRead.
        """
        return pulumi.get(self, "remote_read_inter_url")

    @_builtins.property
    @pulumi.getter(name="remoteReadIntraUrl")
    def remote_read_intra_url(self) -> _builtins.str:
        """
        RemoteRead intranet Url.
        """
        return pulumi.get(self, "remote_read_intra_url")

    @_builtins.property
    @pulumi.getter(name="remoteWriteInterUrl")
    def remote_write_inter_url(self) -> _builtins.str:
        """
        RemoteWrite public Url.
        """
        return pulumi.get(self, "remote_write_inter_url")

    @_builtins.property
    @pulumi.getter(name="remoteWriteIntraUrl")
    def remote_write_intra_url(self) -> _builtins.str:
        """
        RemoteWrite Intranet Url.
        """
        return pulumi.get(self, "remote_write_intra_url")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> _builtins.str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="subClustersJson")
    def sub_clusters_json(self) -> _builtins.str:
        """
        The child instance json string of the globalView instance.
        """
        return pulumi.get(self, "sub_clusters_json")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> _builtins.str:
        """
        The ID of the vSwitch.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetPrometheusAlertRulesRuleResult(dict):
    def __init__(__self__, *,
                 annotations: Sequence['outputs.GetPrometheusAlertRulesRuleAnnotationResult'],
                 cluster_id: _builtins.str,
                 dispatch_rule_id: _builtins.str,
                 duration: _builtins.str,
                 expression: _builtins.str,
                 id: _builtins.str,
                 labels: Sequence['outputs.GetPrometheusAlertRulesRuleLabelResult'],
                 message: _builtins.str,
                 notify_type: _builtins.str,
                 prometheus_alert_rule_id: _builtins.str,
                 prometheus_alert_rule_name: _builtins.str,
                 status: _builtins.int,
                 type: _builtins.str):
        """
        :param Sequence['GetPrometheusAlertRulesRuleAnnotationArgs'] annotations: The annotations of the alert rule.
        :param _builtins.str cluster_id: The ID of the cluster.
        :param _builtins.str dispatch_rule_id: The ID of the notification policy. This parameter is required when the `notify_type` parameter is set to `DISPATCH_RULE`.
        :param _builtins.str duration: The duration of the alert.
        :param _builtins.str expression: The alert rule expression that follows the PromQL syntax..
        :param _builtins.str id: The ID of the Prometheus Alert Rule.
        :param Sequence['GetPrometheusAlertRulesRuleLabelArgs'] labels: The labels of the resource.
        :param _builtins.str message: The message of the alert notification.
        :param _builtins.str notify_type: The method of sending the alert notification. Valid values: `ALERT_MANAGER`, `DISPATCH_RULE`.
        :param _builtins.str prometheus_alert_rule_id: The first ID of the resource.
        :param _builtins.str prometheus_alert_rule_name: The name of the resource.
        :param _builtins.int status: The status of the resource. Valid values: `0`, `1`.
        :param _builtins.str type: The type of the alert rule.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "dispatch_rule_id", dispatch_rule_id)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "notify_type", notify_type)
        pulumi.set(__self__, "prometheus_alert_rule_id", prometheus_alert_rule_id)
        pulumi.set(__self__, "prometheus_alert_rule_name", prometheus_alert_rule_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Sequence['outputs.GetPrometheusAlertRulesRuleAnnotationResult']:
        """
        The annotations of the alert rule.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="dispatchRuleId")
    def dispatch_rule_id(self) -> _builtins.str:
        """
        The ID of the notification policy. This parameter is required when the `notify_type` parameter is set to `DISPATCH_RULE`.
        """
        return pulumi.get(self, "dispatch_rule_id")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        The duration of the alert.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        The alert rule expression that follows the PromQL syntax..
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Prometheus Alert Rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetPrometheusAlertRulesRuleLabelResult']:
        """
        The labels of the resource.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The message of the alert notification.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> _builtins.str:
        """
        The method of sending the alert notification. Valid values: `ALERT_MANAGER`, `DISPATCH_RULE`.
        """
        return pulumi.get(self, "notify_type")

    @_builtins.property
    @pulumi.getter(name="prometheusAlertRuleId")
    def prometheus_alert_rule_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "prometheus_alert_rule_id")

    @_builtins.property
    @pulumi.getter(name="prometheusAlertRuleName")
    def prometheus_alert_rule_name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "prometheus_alert_rule_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        The status of the resource. Valid values: `0`, `1`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the alert rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrometheusAlertRulesRuleAnnotationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The value of the annotation.
        :param _builtins.str value: The name of the annotation name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The value of the annotation.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The name of the annotation name.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPrometheusAlertRulesRuleLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the label.
        :param _builtins.str value: The value of the label.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPrometheusMonitoringsPrometheusMonitoringResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 config_yaml: _builtins.str,
                 id: _builtins.str,
                 monitoring_name: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str cluster_id: The ID of the Prometheus instance.
        :param _builtins.str config_yaml: The monitoring configuration. The value is a YAML string.
        :param _builtins.str id: The ID of the Prometheus Monitoring. It formats as `<cluster_id>:<monitoring_name>:<type>`.
        :param _builtins.str monitoring_name: The name of the monitoring configuration.
        :param _builtins.str status: The status of the monitoring configuration. Valid values: `run`, `stop`.
        :param _builtins.str type: The type of the monitoring configuration. Valid values: `serviceMonitor`, `podMonitor`, `customJob`, `probe`.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "config_yaml", config_yaml)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "monitoring_name", monitoring_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="configYaml")
    def config_yaml(self) -> _builtins.str:
        """
        The monitoring configuration. The value is a YAML string.
        """
        return pulumi.get(self, "config_yaml")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Prometheus Monitoring. It formats as `<cluster_id>:<monitoring_name>:<type>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="monitoringName")
    def monitoring_name(self) -> _builtins.str:
        """
        The name of the monitoring configuration.
        """
        return pulumi.get(self, "monitoring_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the monitoring configuration. Valid values: `run`, `stop`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the monitoring configuration. Valid values: `serviceMonitor`, `podMonitor`, `customJob`, `probe`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrometheusPrometheiResult(dict):
    def __init__(__self__, *,
                 auth_token: _builtins.str,
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 cluster_type: _builtins.str,
                 grafana_instance_id: _builtins.str,
                 http_api_inter_url: _builtins.str,
                 http_api_intra_url: _builtins.str,
                 id: _builtins.str,
                 push_gate_way_inter_url: _builtins.str,
                 push_gate_way_intra_url: _builtins.str,
                 remote_read_inter_url: _builtins.str,
                 remote_read_intra_url: _builtins.str,
                 remote_write_inter_url: _builtins.str,
                 remote_write_intra_url: _builtins.str,
                 resource_group_id: _builtins.str,
                 security_group_id: _builtins.str,
                 sub_clusters_json: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 vpc_id: _builtins.str,
                 vswitch_id: _builtins.str):
        """
        :param _builtins.str auth_token: (Available since v1.214.0) The authorization token. **Note:** `auth_token` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str cluster_id: The ID of the cluster.
        :param _builtins.str cluster_name: The name of the cluster.
        :param _builtins.str cluster_type: The type of the cluster.
        :param _builtins.str grafana_instance_id: The ID of the Grafana workspace.
        :param _builtins.str http_api_inter_url: (Available since v1.214.0) The public URL for the HTTP API. **Note:** `http_api_inter_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str http_api_intra_url: (Available since v1.214.0) The internal URL for the HTTP API. **Note:** `http_api_intra_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str id: The ID of the Prometheus.
        :param _builtins.str push_gate_way_inter_url: (Available since v1.214.0) The public URL for Pushgateway. **Note:** `push_gate_way_inter_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str push_gate_way_intra_url: (Available since v1.214.0) The internal URL for Pushgateway. **Note:** `push_gate_way_intra_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str remote_read_inter_url: (Available since v1.214.0) The public URL for remote read. **Note:** `remote_read_inter_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str remote_read_intra_url: (Available since v1.214.0) The internal URL for remote read. **Note:** `remote_read_intra_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str remote_write_inter_url: (Available since v1.214.0) The public URL for remote write. **Note:** `remote_write_inter_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str remote_write_intra_url: (Available since v1.214.0) The internal URL for remote write. **Note:** `remote_write_intra_url` takes effect only if `enable_details` is set to `true`.
        :param _builtins.str resource_group_id: The ID of the resource group.
        :param _builtins.str security_group_id: The ID of the security group.
        :param _builtins.str sub_clusters_json: The child instance json string of the globalView instance.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.str vpc_id: The ID of the VPC.
        :param _builtins.str vswitch_id: The ID of the VSwitch.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "grafana_instance_id", grafana_instance_id)
        pulumi.set(__self__, "http_api_inter_url", http_api_inter_url)
        pulumi.set(__self__, "http_api_intra_url", http_api_intra_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "push_gate_way_inter_url", push_gate_way_inter_url)
        pulumi.set(__self__, "push_gate_way_intra_url", push_gate_way_intra_url)
        pulumi.set(__self__, "remote_read_inter_url", remote_read_inter_url)
        pulumi.set(__self__, "remote_read_intra_url", remote_read_intra_url)
        pulumi.set(__self__, "remote_write_inter_url", remote_write_inter_url)
        pulumi.set(__self__, "remote_write_intra_url", remote_write_intra_url)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "sub_clusters_json", sub_clusters_json)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vswitch_id", vswitch_id)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> _builtins.str:
        """
        (Available since v1.214.0) The authorization token. **Note:** `auth_token` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        The type of the cluster.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="grafanaInstanceId")
    def grafana_instance_id(self) -> _builtins.str:
        """
        The ID of the Grafana workspace.
        """
        return pulumi.get(self, "grafana_instance_id")

    @_builtins.property
    @pulumi.getter(name="httpApiInterUrl")
    def http_api_inter_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The public URL for the HTTP API. **Note:** `http_api_inter_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "http_api_inter_url")

    @_builtins.property
    @pulumi.getter(name="httpApiIntraUrl")
    def http_api_intra_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The internal URL for the HTTP API. **Note:** `http_api_intra_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "http_api_intra_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Prometheus.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="pushGateWayInterUrl")
    def push_gate_way_inter_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The public URL for Pushgateway. **Note:** `push_gate_way_inter_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "push_gate_way_inter_url")

    @_builtins.property
    @pulumi.getter(name="pushGateWayIntraUrl")
    def push_gate_way_intra_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The internal URL for Pushgateway. **Note:** `push_gate_way_intra_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "push_gate_way_intra_url")

    @_builtins.property
    @pulumi.getter(name="remoteReadInterUrl")
    def remote_read_inter_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The public URL for remote read. **Note:** `remote_read_inter_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "remote_read_inter_url")

    @_builtins.property
    @pulumi.getter(name="remoteReadIntraUrl")
    def remote_read_intra_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The internal URL for remote read. **Note:** `remote_read_intra_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "remote_read_intra_url")

    @_builtins.property
    @pulumi.getter(name="remoteWriteInterUrl")
    def remote_write_inter_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The public URL for remote write. **Note:** `remote_write_inter_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "remote_write_inter_url")

    @_builtins.property
    @pulumi.getter(name="remoteWriteIntraUrl")
    def remote_write_intra_url(self) -> _builtins.str:
        """
        (Available since v1.214.0) The internal URL for remote write. **Note:** `remote_write_intra_url` takes effect only if `enable_details` is set to `true`.
        """
        return pulumi.get(self, "remote_write_intra_url")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> _builtins.str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="subClustersJson")
    def sub_clusters_json(self) -> _builtins.str:
        """
        The child instance json string of the globalView instance.
        """
        return pulumi.get(self, "sub_clusters_json")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> _builtins.str:
        """
        The ID of the VSwitch.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetRemoteWritesRemoteWriteResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 id: _builtins.str,
                 remote_write_name: _builtins.str,
                 remote_write_yaml: _builtins.str):
        """
        :param _builtins.str cluster_id: The ID of the Prometheus instance.
        :param _builtins.str id: The ID of the Remote Write. It formats as `<cluster_id>:<remote_write_name>`.
        :param _builtins.str remote_write_name: The name of the Remote Write configuration item.
        :param _builtins.str remote_write_yaml: The details of the Remote Write configuration item. The value is in the YAML format.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "remote_write_name", remote_write_name)
        pulumi.set(__self__, "remote_write_yaml", remote_write_yaml)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Remote Write. It formats as `<cluster_id>:<remote_write_name>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="remoteWriteName")
    def remote_write_name(self) -> _builtins.str:
        """
        The name of the Remote Write configuration item.
        """
        return pulumi.get(self, "remote_write_name")

    @_builtins.property
    @pulumi.getter(name="remoteWriteYaml")
    def remote_write_yaml(self) -> _builtins.str:
        """
        The details of the Remote Write configuration item. The value is in the YAML format.
        """
        return pulumi.get(self, "remote_write_yaml")


