# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'DispatchRuleGroupRule',
    'DispatchRuleLabelMatchExpressionGrid',
    'DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup',
    'DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression',
    'DispatchRuleNotifyRule',
    'DispatchRuleNotifyRuleNotifyObject',
    'PrometheusAlertRuleAnnotation',
    'PrometheusAlertRuleLabel',
    'SyntheticTaskAvailableAssertion',
    'SyntheticTaskCommonSetting',
    'SyntheticTaskCommonSettingCustomHost',
    'SyntheticTaskCommonSettingCustomHostHost',
    'SyntheticTaskCustomPeriod',
    'SyntheticTaskMonitor',
    'SyntheticTaskMonitorConf',
    'SyntheticTaskMonitorConfApiHttp',
    'SyntheticTaskMonitorConfApiHttpRequestBody',
    'SyntheticTaskMonitorConfFileDownload',
    'SyntheticTaskMonitorConfNetDns',
    'SyntheticTaskMonitorConfNetIcmp',
    'SyntheticTaskMonitorConfNetTcp',
    'SyntheticTaskMonitorConfStream',
    'SyntheticTaskMonitorConfWebsite',
    'GetAlertContactGroupsGroupResult',
    'GetAlertContactsContactResult',
    'GetDispatchRulesRuleResult',
    'GetDispatchRulesRuleGroupRuleResult',
    'GetDispatchRulesRuleLabelMatchExpressionGridResult',
    'GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult',
    'GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult',
    'GetDispatchRulesRuleNotifyRuleResult',
    'GetDispatchRulesRuleNotifyRuleNotifyObjectResult',
    'GetIntegrationExportersIntegrationExporterResult',
    'GetPrometheisPrometheiResult',
    'GetPrometheusAlertRulesRuleResult',
    'GetPrometheusAlertRulesRuleAnnotationResult',
    'GetPrometheusAlertRulesRuleLabelResult',
    'GetPrometheusMonitoringsPrometheusMonitoringResult',
    'GetPrometheusPrometheiResult',
    'GetRemoteWritesRemoteWriteResult',
]

@pulumi.output_type
class DispatchRuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupInterval":
            suggest = "group_interval"
        elif key == "groupWaitTime":
            suggest = "group_wait_time"
        elif key == "groupingFields":
            suggest = "grouping_fields"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "repeatInterval":
            suggest = "repeat_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_interval: int,
                 group_wait_time: int,
                 grouping_fields: Sequence[str],
                 group_id: Optional[int] = None,
                 repeat_interval: Optional[int] = None):
        """
        :param int group_interval: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param int group_wait_time: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param Sequence[str] grouping_fields: The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        :param int group_id: The ID of the group rule.
        :param int repeat_interval: The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        pulumi.set(__self__, "group_interval", group_interval)
        pulumi.set(__self__, "group_wait_time", group_wait_time)
        pulumi.set(__self__, "grouping_fields", grouping_fields)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWaitTime")
    def group_wait_time(self) -> int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_wait_time")

    @property
    @pulumi.getter(name="groupingFields")
    def grouping_fields(self) -> Sequence[str]:
        """
        The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        """
        return pulumi.get(self, "grouping_fields")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[int]:
        """
        The ID of the group rule.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[int]:
        """
        The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class DispatchRuleLabelMatchExpressionGrid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelMatchExpressionGroups":
            suggest = "label_match_expression_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleLabelMatchExpressionGrid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleLabelMatchExpressionGrid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleLabelMatchExpressionGrid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_match_expression_groups: Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup']):
        """
        :param Sequence['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs'] label_match_expression_groups: Sets the dispatch rule. See `label_match_expression_groups` below.
        """
        pulumi.set(__self__, "label_match_expression_groups", label_match_expression_groups)

    @property
    @pulumi.getter(name="labelMatchExpressionGroups")
    def label_match_expression_groups(self) -> Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup']:
        """
        Sets the dispatch rule. See `label_match_expression_groups` below.
        """
        return pulumi.get(self, "label_match_expression_groups")


@pulumi.output_type
class DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelMatchExpressions":
            suggest = "label_match_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_match_expressions: Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression']):
        """
        :param Sequence['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs'] label_match_expressions: Sets the dispatch rule. See `label_match_expressions` below.
        """
        pulumi.set(__self__, "label_match_expressions", label_match_expressions)

    @property
    @pulumi.getter(name="labelMatchExpressions")
    def label_match_expressions(self) -> Sequence['outputs.DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression']:
        """
        Sets the dispatch rule. See `label_match_expressions` below.
        """
        return pulumi.get(self, "label_match_expressions")


@pulumi.output_type
class DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 value: str):
        """
        :param str key: The key of the tag of the dispatch rule. Valid values:
               * _aliyun_arms_userid: user ID
               * _aliyun_arms_involvedObject_kind: type of the associated object
               * _aliyun_arms_involvedObject_id: ID of the associated object
               * _aliyun_arms_involvedObject_name: name of the associated object
               * _aliyun_arms_alert_name: alert name
               * _aliyun_arms_alert_rule_id: alert rule ID
               * _aliyun_arms_alert_type: alert type
               * _aliyun_arms_alert_level: alert severity
        :param str operator: The operator used in the dispatch rule. Valid values: 
               * eq: equals to.
               * re: matches a regular expression.
        :param str value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag of the dispatch rule. Valid values:
        * _aliyun_arms_userid: user ID
        * _aliyun_arms_involvedObject_kind: type of the associated object
        * _aliyun_arms_involvedObject_id: ID of the associated object
        * _aliyun_arms_involvedObject_name: name of the associated object
        * _aliyun_arms_alert_name: alert name
        * _aliyun_arms_alert_rule_id: alert rule ID
        * _aliyun_arms_alert_type: alert type
        * _aliyun_arms_alert_level: alert severity
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator used in the dispatch rule. Valid values: 
        * eq: equals to.
        * re: matches a regular expression.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DispatchRuleNotifyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyChannels":
            suggest = "notify_channels"
        elif key == "notifyObjects":
            suggest = "notify_objects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleNotifyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleNotifyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleNotifyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_channels: Sequence[str],
                 notify_objects: Sequence['outputs.DispatchRuleNotifyRuleNotifyObject']):
        """
        :param Sequence[str] notify_channels: The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
        :param Sequence['DispatchRuleNotifyRuleNotifyObjectArgs'] notify_objects: Sets the notification object. See `notify_objects` below.
        """
        pulumi.set(__self__, "notify_channels", notify_channels)
        pulumi.set(__self__, "notify_objects", notify_objects)

    @property
    @pulumi.getter(name="notifyChannels")
    def notify_channels(self) -> Sequence[str]:
        """
        The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
        """
        return pulumi.get(self, "notify_channels")

    @property
    @pulumi.getter(name="notifyObjects")
    def notify_objects(self) -> Sequence['outputs.DispatchRuleNotifyRuleNotifyObject']:
        """
        Sets the notification object. See `notify_objects` below.
        """
        return pulumi.get(self, "notify_objects")


@pulumi.output_type
class DispatchRuleNotifyRuleNotifyObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyObjectId":
            suggest = "notify_object_id"
        elif key == "notifyType":
            suggest = "notify_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DispatchRuleNotifyRuleNotifyObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DispatchRuleNotifyRuleNotifyObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DispatchRuleNotifyRuleNotifyObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 notify_object_id: str,
                 notify_type: str):
        """
        :param str name: The name of the contact or contact group.
        :param str notify_object_id: The ID of the contact or contact group.
        :param str notify_type: The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_object_id", notify_object_id)
        pulumi.set(__self__, "notify_type", notify_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the contact or contact group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notifyObjectId")
    def notify_object_id(self) -> str:
        """
        The ID of the contact or contact group.
        """
        return pulumi.get(self, "notify_object_id")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        """
        The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
        """
        return pulumi.get(self, "notify_type")


@pulumi.output_type
class PrometheusAlertRuleAnnotation(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the annotation.
        :param str value: The value of the annotation.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the annotation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the annotation.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PrometheusAlertRuleLabel(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the label.
        :param str value: The value of the label.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticTaskAvailableAssertion(dict):
    def __init__(__self__, *,
                 expect: str,
                 operator: str,
                 type: str,
                 target: Optional[str] = None):
        """
        :param str expect: Expected value.
        :param str operator: Condition: gt: greater than; gte: greater than or equal to; lt: less than; te: less than or equal to; eq: equal to; neq: not equal to; ctn: contains; nctn: does not contain; exist: exists; n_exist: does not exist; belong: belongs to; reg_match: regular matching.
        :param str type: Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        :param str target: Check the target. If the target is HttpResCode, HttpResBody, or httpressetime, you do not need to specify the target. If the target is HttpResHead, you need to specify the key in the header. If the target is HttpResHead, you need to use jsonPath.
        """
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def expect(self) -> str:
        """
        Expected value.
        """
        return pulumi.get(self, "expect")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Condition: gt: greater than; gte: greater than or equal to; lt: less than; te: less than or equal to; eq: equal to; neq: not equal to; ctn: contains; nctn: does not contain; exist: exists; n_exist: does not exist; belong: belongs to; reg_match: regular matching.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Check the target. If the target is HttpResCode, HttpResBody, or httpressetime, you do not need to specify the target. If the target is HttpResHead, you need to specify the key in the header. If the target is HttpResHead, you need to use jsonPath.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class SyntheticTaskCommonSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHost":
            suggest = "custom_host"
        elif key == "ipType":
            suggest = "ip_type"
        elif key == "isOpenTrace":
            suggest = "is_open_trace"
        elif key == "monitorSamples":
            suggest = "monitor_samples"
        elif key == "traceClientType":
            suggest = "trace_client_type"
        elif key == "xtraceRegion":
            suggest = "xtrace_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCommonSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCommonSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCommonSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_host: Optional['outputs.SyntheticTaskCommonSettingCustomHost'] = None,
                 ip_type: Optional[int] = None,
                 is_open_trace: Optional[bool] = None,
                 monitor_samples: Optional[int] = None,
                 trace_client_type: Optional[int] = None,
                 xtrace_region: Optional[str] = None):
        """
        :param 'SyntheticTaskCommonSettingCustomHostArgs' custom_host: Custom host. See `custom_host` below.
        :param int ip_type: IpType.
        :param bool is_open_trace: Whether to enable link tracking.
        :param int monitor_samples: Whether the monitoring samples are evenly distributed:
               - 0: No
               1: Yes.
        :param int trace_client_type: Link trace client type:
               - 0:ARMS Agent
               - 1:OpenTelemetry
               - 2:Jaeger.
        :param str xtrace_region: The link data is reported to the region.
        """
        if custom_host is not None:
            pulumi.set(__self__, "custom_host", custom_host)
        if ip_type is not None:
            pulumi.set(__self__, "ip_type", ip_type)
        if is_open_trace is not None:
            pulumi.set(__self__, "is_open_trace", is_open_trace)
        if monitor_samples is not None:
            pulumi.set(__self__, "monitor_samples", monitor_samples)
        if trace_client_type is not None:
            pulumi.set(__self__, "trace_client_type", trace_client_type)
        if xtrace_region is not None:
            pulumi.set(__self__, "xtrace_region", xtrace_region)

    @property
    @pulumi.getter(name="customHost")
    def custom_host(self) -> Optional['outputs.SyntheticTaskCommonSettingCustomHost']:
        """
        Custom host. See `custom_host` below.
        """
        return pulumi.get(self, "custom_host")

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> Optional[int]:
        """
        IpType.
        """
        return pulumi.get(self, "ip_type")

    @property
    @pulumi.getter(name="isOpenTrace")
    def is_open_trace(self) -> Optional[bool]:
        """
        Whether to enable link tracking.
        """
        return pulumi.get(self, "is_open_trace")

    @property
    @pulumi.getter(name="monitorSamples")
    def monitor_samples(self) -> Optional[int]:
        """
        Whether the monitoring samples are evenly distributed:
        - 0: No
        1: Yes.
        """
        return pulumi.get(self, "monitor_samples")

    @property
    @pulumi.getter(name="traceClientType")
    def trace_client_type(self) -> Optional[int]:
        """
        Link trace client type:
        - 0:ARMS Agent
        - 1:OpenTelemetry
        - 2:Jaeger.
        """
        return pulumi.get(self, "trace_client_type")

    @property
    @pulumi.getter(name="xtraceRegion")
    def xtrace_region(self) -> Optional[str]:
        """
        The link data is reported to the region.
        """
        return pulumi.get(self, "xtrace_region")


@pulumi.output_type
class SyntheticTaskCommonSettingCustomHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectType":
            suggest = "select_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCommonSettingCustomHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCommonSettingCustomHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCommonSettingCustomHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence['outputs.SyntheticTaskCommonSettingCustomHostHost'],
                 select_type: int):
        """
        :param Sequence['SyntheticTaskCommonSettingCustomHostHostArgs'] hosts: The host list. See `hosts` below.
        :param int select_type: Selection method:
               - 0: Random
               - 1: Polling.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "select_type", select_type)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence['outputs.SyntheticTaskCommonSettingCustomHostHost']:
        """
        The host list. See `hosts` below.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="selectType")
    def select_type(self) -> int:
        """
        Selection method:
        - 0: Random
        - 1: Polling.
        """
        return pulumi.get(self, "select_type")


@pulumi.output_type
class SyntheticTaskCommonSettingCustomHostHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCommonSettingCustomHostHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCommonSettingCustomHostHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCommonSettingCustomHostHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 ip_type: int,
                 ips: Sequence[str]):
        """
        :param str domain: Domain Name.
        :param int ip_type: IpType.
        :param Sequence[str] ips: The IP list.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "ip_type", ip_type)
        pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain Name.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> int:
        """
        IpType.
        """
        return pulumi.get(self, "ip_type")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The IP list.
        """
        return pulumi.get(self, "ips")


@pulumi.output_type
class SyntheticTaskCustomPeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "startHour":
            suggest = "start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskCustomPeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskCustomPeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskCustomPeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour: Optional[int] = None,
                 start_hour: Optional[int] = None):
        """
        :param int end_hour: End hours, 0-24.
        :param int start_hour: Starting hours, 0-24.
        """
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[int]:
        """
        End hours, 0-24.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[int]:
        """
        Starting hours, 0-24.
        """
        return pulumi.get(self, "start_hour")


@pulumi.output_type
class SyntheticTaskMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cityCode":
            suggest = "city_code"
        elif key == "clientType":
            suggest = "client_type"
        elif key == "operatorCode":
            suggest = "operator_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 city_code: str,
                 client_type: int,
                 operator_code: str):
        """
        :param str city_code: The city code of monitor.
        :param int client_type: The type of monitor.
        :param str operator_code: The operator code of monitor.
        """
        pulumi.set(__self__, "city_code", city_code)
        pulumi.set(__self__, "client_type", client_type)
        pulumi.set(__self__, "operator_code", operator_code)

    @property
    @pulumi.getter(name="cityCode")
    def city_code(self) -> str:
        """
        The city code of monitor.
        """
        return pulumi.get(self, "city_code")

    @property
    @pulumi.getter(name="clientType")
    def client_type(self) -> int:
        """
        The type of monitor.
        """
        return pulumi.get(self, "client_type")

    @property
    @pulumi.getter(name="operatorCode")
    def operator_code(self) -> str:
        """
        The operator code of monitor.
        """
        return pulumi.get(self, "operator_code")


@pulumi.output_type
class SyntheticTaskMonitorConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiHttp":
            suggest = "api_http"
        elif key == "fileDownload":
            suggest = "file_download"
        elif key == "netDns":
            suggest = "net_dns"
        elif key == "netIcmp":
            suggest = "net_icmp"
        elif key == "netTcp":
            suggest = "net_tcp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_http: Optional['outputs.SyntheticTaskMonitorConfApiHttp'] = None,
                 file_download: Optional['outputs.SyntheticTaskMonitorConfFileDownload'] = None,
                 net_dns: Optional['outputs.SyntheticTaskMonitorConfNetDns'] = None,
                 net_icmp: Optional['outputs.SyntheticTaskMonitorConfNetIcmp'] = None,
                 net_tcp: Optional['outputs.SyntheticTaskMonitorConfNetTcp'] = None,
                 stream: Optional['outputs.SyntheticTaskMonitorConfStream'] = None,
                 website: Optional['outputs.SyntheticTaskMonitorConfWebsite'] = None):
        """
        :param 'SyntheticTaskMonitorConfApiHttpArgs' api_http: HTTP(S) task configuration information. See `api_http` below.
        :param 'SyntheticTaskMonitorConfFileDownloadArgs' file_download: File download type task configuration. See `file_download` below.
        :param 'SyntheticTaskMonitorConfNetDnsArgs' net_dns: The configuration parameters of the DNS dial test. Required when TaskType is 3. See `net_dns` below.
        :param 'SyntheticTaskMonitorConfNetIcmpArgs' net_icmp: ICMP dialing configuration parameters. Required when TaskType is 1. See `net_icmp` below.
        :param 'SyntheticTaskMonitorConfNetTcpArgs' net_tcp: The configuration parameters of TCP dial test. Required when TaskType is 2. See `net_tcp` below.
        :param 'SyntheticTaskMonitorConfStreamArgs' stream: Streaming Media Dial Test Configuration. See `stream` below.
        :param 'SyntheticTaskMonitorConfWebsiteArgs' website: Website speed measurement type task configuration. See `website` below.
        """
        if api_http is not None:
            pulumi.set(__self__, "api_http", api_http)
        if file_download is not None:
            pulumi.set(__self__, "file_download", file_download)
        if net_dns is not None:
            pulumi.set(__self__, "net_dns", net_dns)
        if net_icmp is not None:
            pulumi.set(__self__, "net_icmp", net_icmp)
        if net_tcp is not None:
            pulumi.set(__self__, "net_tcp", net_tcp)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if website is not None:
            pulumi.set(__self__, "website", website)

    @property
    @pulumi.getter(name="apiHttp")
    def api_http(self) -> Optional['outputs.SyntheticTaskMonitorConfApiHttp']:
        """
        HTTP(S) task configuration information. See `api_http` below.
        """
        return pulumi.get(self, "api_http")

    @property
    @pulumi.getter(name="fileDownload")
    def file_download(self) -> Optional['outputs.SyntheticTaskMonitorConfFileDownload']:
        """
        File download type task configuration. See `file_download` below.
        """
        return pulumi.get(self, "file_download")

    @property
    @pulumi.getter(name="netDns")
    def net_dns(self) -> Optional['outputs.SyntheticTaskMonitorConfNetDns']:
        """
        The configuration parameters of the DNS dial test. Required when TaskType is 3. See `net_dns` below.
        """
        return pulumi.get(self, "net_dns")

    @property
    @pulumi.getter(name="netIcmp")
    def net_icmp(self) -> Optional['outputs.SyntheticTaskMonitorConfNetIcmp']:
        """
        ICMP dialing configuration parameters. Required when TaskType is 1. See `net_icmp` below.
        """
        return pulumi.get(self, "net_icmp")

    @property
    @pulumi.getter(name="netTcp")
    def net_tcp(self) -> Optional['outputs.SyntheticTaskMonitorConfNetTcp']:
        """
        The configuration parameters of TCP dial test. Required when TaskType is 2. See `net_tcp` below.
        """
        return pulumi.get(self, "net_tcp")

    @property
    @pulumi.getter
    def stream(self) -> Optional['outputs.SyntheticTaskMonitorConfStream']:
        """
        Streaming Media Dial Test Configuration. See `stream` below.
        """
        return pulumi.get(self, "stream")

    @property
    @pulumi.getter
    def website(self) -> Optional['outputs.SyntheticTaskMonitorConfWebsite']:
        """
        Website speed measurement type task configuration. See `website` below.
        """
        return pulumi.get(self, "website")


@pulumi.output_type
class SyntheticTaskMonitorConfApiHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "requestBody":
            suggest = "request_body"
        elif key == "requestHeaders":
            suggest = "request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfApiHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfApiHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfApiHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: str,
                 connect_timeout: Optional[int] = None,
                 method: Optional[str] = None,
                 request_body: Optional['outputs.SyntheticTaskMonitorConfApiHttpRequestBody'] = None,
                 request_headers: Optional[Mapping[str, Any]] = None,
                 timeout: Optional[int] = None):
        """
        :param str target_url: The target URL.
        :param int connect_timeout: Connection timeout, in ms. Default 5000. Optional range: 1000-300000ms.
        :param str method: HTTP method, GET or POST.
        :param 'SyntheticTaskMonitorConfApiHttpRequestBodyArgs' request_body: HTTP request body. See `request_body` below.
        :param Mapping[str, Any] request_headers: HTTP request header.
        :param int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        Connection timeout, in ms. Default 5000. Optional range: 1000-300000ms.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        HTTP method, GET or POST.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional['outputs.SyntheticTaskMonitorConfApiHttpRequestBody']:
        """
        HTTP request body. See `request_body` below.
        """
        return pulumi.get(self, "request_body")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, Any]]:
        """
        HTTP request header.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfApiHttpRequestBody(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str content: The request body content, in JSON string format. When the type is text/plain,application/json,application/xml,text/html, the content can be converted to a JSON string.
        :param str type: Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The request body content, in JSON string format. When the type is text/plain,application/json,application/xml,text/html, the content can be converted to a JSON string.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SyntheticTaskMonitorConfFileDownload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "customHeaderContent":
            suggest = "custom_header_content"
        elif key == "downloadKernel":
            suggest = "download_kernel"
        elif key == "ignoreCertificateAuthError":
            suggest = "ignore_certificate_auth_error"
        elif key == "ignoreCertificateCanceledError":
            suggest = "ignore_certificate_canceled_error"
        elif key == "ignoreCertificateOutOfDateError":
            suggest = "ignore_certificate_out_of_date_error"
        elif key == "ignoreCertificateStatusError":
            suggest = "ignore_certificate_status_error"
        elif key == "ignoreCertificateUntrustworthyError":
            suggest = "ignore_certificate_untrustworthy_error"
        elif key == "ignoreCertificateUsingError":
            suggest = "ignore_certificate_using_error"
        elif key == "ignoreInvalidHostError":
            suggest = "ignore_invalid_host_error"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "quickProtocol":
            suggest = "quick_protocol"
        elif key == "transmissionSize":
            suggest = "transmission_size"
        elif key == "validateKeywords":
            suggest = "validate_keywords"
        elif key == "verifyWay":
            suggest = "verify_way"
        elif key == "whiteList":
            suggest = "white_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfFileDownload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfFileDownload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfFileDownload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: str,
                 connection_timeout: Optional[int] = None,
                 custom_header_content: Optional[Mapping[str, Any]] = None,
                 download_kernel: Optional[int] = None,
                 ignore_certificate_auth_error: Optional[int] = None,
                 ignore_certificate_canceled_error: Optional[int] = None,
                 ignore_certificate_out_of_date_error: Optional[int] = None,
                 ignore_certificate_status_error: Optional[int] = None,
                 ignore_certificate_untrustworthy_error: Optional[int] = None,
                 ignore_certificate_using_error: Optional[int] = None,
                 ignore_invalid_host_error: Optional[int] = None,
                 monitor_timeout: Optional[int] = None,
                 quick_protocol: Optional[int] = None,
                 redirection: Optional[int] = None,
                 transmission_size: Optional[int] = None,
                 validate_keywords: Optional[str] = None,
                 verify_way: Optional[int] = None,
                 white_list: Optional[str] = None):
        """
        :param str target_url: The target URL.
        :param int connection_timeout: Connection timeout time, in ms. Default 5000. Optional range: 1000-120000ms.
        :param Mapping[str, Any] custom_header_content: Custom header, in JSON Map format.
        :param int download_kernel: Download the kernel.
               - 1:curl
               - 0:WinInet
               Default 1.
        :param int ignore_certificate_auth_error: Ignore CA Certificate authorization error 0: Do not ignore, 1: ignore, default 1.
        :param int ignore_certificate_canceled_error: Ignore certificate revocation error 0: Do not ignore, 1: ignore, default 1.
        :param int ignore_certificate_out_of_date_error: Ignore certificate expiration error 0: not ignored, 1: Ignored, default 1.
        :param int ignore_certificate_status_error: The certificate status error is ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        :param int ignore_certificate_untrustworthy_error: The certificate cannot be trusted and ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        :param int ignore_certificate_using_error: Ignore certificate usage error 0: Do not ignore, 1: ignore, default 1.
        :param int ignore_invalid_host_error: Invalid host error ignored, 0: not ignored, 1: Ignored, default 1.
        :param int monitor_timeout: Monitoring timeout, in ms. Not required, 20000 by default.
        :param int quick_protocol: Quick agreement
               - 1:http1
               - 2:http2
               - 3:http3
               Default 1.
        :param int redirection: When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        :param int transmission_size: The transmission size, in KB. The default value is 2048KB. The transmission size of the downloaded file must be between 1 and 20480KB.
        :param str validate_keywords: Verify keywords.
        :param int verify_way: The verification method.
               - 0: Do not validate
               - 1: Validation string
               - 2:MD5 validation.
        :param str white_list: DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if download_kernel is not None:
            pulumi.set(__self__, "download_kernel", download_kernel)
        if ignore_certificate_auth_error is not None:
            pulumi.set(__self__, "ignore_certificate_auth_error", ignore_certificate_auth_error)
        if ignore_certificate_canceled_error is not None:
            pulumi.set(__self__, "ignore_certificate_canceled_error", ignore_certificate_canceled_error)
        if ignore_certificate_out_of_date_error is not None:
            pulumi.set(__self__, "ignore_certificate_out_of_date_error", ignore_certificate_out_of_date_error)
        if ignore_certificate_status_error is not None:
            pulumi.set(__self__, "ignore_certificate_status_error", ignore_certificate_status_error)
        if ignore_certificate_untrustworthy_error is not None:
            pulumi.set(__self__, "ignore_certificate_untrustworthy_error", ignore_certificate_untrustworthy_error)
        if ignore_certificate_using_error is not None:
            pulumi.set(__self__, "ignore_certificate_using_error", ignore_certificate_using_error)
        if ignore_invalid_host_error is not None:
            pulumi.set(__self__, "ignore_invalid_host_error", ignore_invalid_host_error)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if quick_protocol is not None:
            pulumi.set(__self__, "quick_protocol", quick_protocol)
        if redirection is not None:
            pulumi.set(__self__, "redirection", redirection)
        if transmission_size is not None:
            pulumi.set(__self__, "transmission_size", transmission_size)
        if validate_keywords is not None:
            pulumi.set(__self__, "validate_keywords", validate_keywords)
        if verify_way is not None:
            pulumi.set(__self__, "verify_way", verify_way)
        if white_list is not None:
            pulumi.set(__self__, "white_list", white_list)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[int]:
        """
        Connection timeout time, in ms. Default 5000. Optional range: 1000-120000ms.
        """
        return pulumi.get(self, "connection_timeout")

    @property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[Mapping[str, Any]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @property
    @pulumi.getter(name="downloadKernel")
    def download_kernel(self) -> Optional[int]:
        """
        Download the kernel.
        - 1:curl
        - 0:WinInet
        Default 1.
        """
        return pulumi.get(self, "download_kernel")

    @property
    @pulumi.getter(name="ignoreCertificateAuthError")
    def ignore_certificate_auth_error(self) -> Optional[int]:
        """
        Ignore CA Certificate authorization error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_auth_error")

    @property
    @pulumi.getter(name="ignoreCertificateCanceledError")
    def ignore_certificate_canceled_error(self) -> Optional[int]:
        """
        Ignore certificate revocation error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_canceled_error")

    @property
    @pulumi.getter(name="ignoreCertificateOutOfDateError")
    def ignore_certificate_out_of_date_error(self) -> Optional[int]:
        """
        Ignore certificate expiration error 0: not ignored, 1: Ignored, default 1.
        """
        return pulumi.get(self, "ignore_certificate_out_of_date_error")

    @property
    @pulumi.getter(name="ignoreCertificateStatusError")
    def ignore_certificate_status_error(self) -> Optional[int]:
        """
        The certificate status error is ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_status_error")

    @property
    @pulumi.getter(name="ignoreCertificateUntrustworthyError")
    def ignore_certificate_untrustworthy_error(self) -> Optional[int]:
        """
        The certificate cannot be trusted and ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_untrustworthy_error")

    @property
    @pulumi.getter(name="ignoreCertificateUsingError")
    def ignore_certificate_using_error(self) -> Optional[int]:
        """
        Ignore certificate usage error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_using_error")

    @property
    @pulumi.getter(name="ignoreInvalidHostError")
    def ignore_invalid_host_error(self) -> Optional[int]:
        """
        Invalid host error ignored, 0: not ignored, 1: Ignored, default 1.
        """
        return pulumi.get(self, "ignore_invalid_host_error")

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[int]:
        """
        Monitoring timeout, in ms. Not required, 20000 by default.
        """
        return pulumi.get(self, "monitor_timeout")

    @property
    @pulumi.getter(name="quickProtocol")
    def quick_protocol(self) -> Optional[int]:
        """
        Quick agreement
        - 1:http1
        - 2:http2
        - 3:http3
        Default 1.
        """
        return pulumi.get(self, "quick_protocol")

    @property
    @pulumi.getter
    def redirection(self) -> Optional[int]:
        """
        When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        """
        return pulumi.get(self, "redirection")

    @property
    @pulumi.getter(name="transmissionSize")
    def transmission_size(self) -> Optional[int]:
        """
        The transmission size, in KB. The default value is 2048KB. The transmission size of the downloaded file must be between 1 and 20480KB.
        """
        return pulumi.get(self, "transmission_size")

    @property
    @pulumi.getter(name="validateKeywords")
    def validate_keywords(self) -> Optional[str]:
        """
        Verify keywords.
        """
        return pulumi.get(self, "validate_keywords")

    @property
    @pulumi.getter(name="verifyWay")
    def verify_way(self) -> Optional[int]:
        """
        The verification method.
        - 0: Do not validate
        - 1: Validation string
        - 2:MD5 validation.
        """
        return pulumi.get(self, "verify_way")

    @property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> Optional[str]:
        """
        DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "white_list")


@pulumi.output_type
class SyntheticTaskMonitorConfNetDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "dnsServerIpType":
            suggest = "dns_server_ip_type"
        elif key == "nsServer":
            suggest = "ns_server"
        elif key == "queryMethod":
            suggest = "query_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfNetDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfNetDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfNetDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: str,
                 dns_server_ip_type: Optional[int] = None,
                 ns_server: Optional[str] = None,
                 query_method: Optional[int] = None,
                 timeout: Optional[int] = None):
        """
        :param str target_url: The target URL.
        :param int dns_server_ip_type: The IP address type of the DNS server.
               - 0 (default):ipv4
               - 1:ipv6
               2: Automatic.
        :param str ns_server: The IP address of the NS server. The default value is 114.114.114.114.
        :param int query_method: DNS query method.
               - 0 (default): Recursive
               - 1: Iteration.
        :param int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if dns_server_ip_type is not None:
            pulumi.set(__self__, "dns_server_ip_type", dns_server_ip_type)
        if ns_server is not None:
            pulumi.set(__self__, "ns_server", ns_server)
        if query_method is not None:
            pulumi.set(__self__, "query_method", query_method)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="dnsServerIpType")
    def dns_server_ip_type(self) -> Optional[int]:
        """
        The IP address type of the DNS server.
        - 0 (default):ipv4
        - 1:ipv6
        2: Automatic.
        """
        return pulumi.get(self, "dns_server_ip_type")

    @property
    @pulumi.getter(name="nsServer")
    def ns_server(self) -> Optional[str]:
        """
        The IP address of the NS server. The default value is 114.114.114.114.
        """
        return pulumi.get(self, "ns_server")

    @property
    @pulumi.getter(name="queryMethod")
    def query_method(self) -> Optional[int]:
        """
        DNS query method.
        - 0 (default): Recursive
        - 1: Iteration.
        """
        return pulumi.get(self, "query_method")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfNetIcmp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "packageNum":
            suggest = "package_num"
        elif key == "packageSize":
            suggest = "package_size"
        elif key == "splitPackage":
            suggest = "split_package"
        elif key == "tracertEnable":
            suggest = "tracert_enable"
        elif key == "tracertNumMax":
            suggest = "tracert_num_max"
        elif key == "tracertTimeout":
            suggest = "tracert_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfNetIcmp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfNetIcmp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfNetIcmp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: str,
                 interval: Optional[int] = None,
                 package_num: Optional[int] = None,
                 package_size: Optional[int] = None,
                 split_package: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 tracert_enable: Optional[bool] = None,
                 tracert_num_max: Optional[int] = None,
                 tracert_timeout: Optional[int] = None):
        """
        :param str target_url: The target URL.
        :param int interval: The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        :param int package_num: Number of ICMP(Ping) packets sent. The minimum value is 1, the maximum value is 50, and the default is 4.
        :param int package_size: The size of the sent ICMP(Ping) packet. The unit is byte. The ICMP(PING) packet size is limited to 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        :param bool split_package: Whether to split ICMP(Ping) packets. The default is true.
        :param int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        :param bool tracert_enable: Whether to enable tracert. The default is true.
        :param int tracert_num_max: The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        :param int tracert_timeout: The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if package_num is not None:
            pulumi.set(__self__, "package_num", package_num)
        if package_size is not None:
            pulumi.set(__self__, "package_size", package_size)
        if split_package is not None:
            pulumi.set(__self__, "split_package", split_package)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracert_enable is not None:
            pulumi.set(__self__, "tracert_enable", tracert_enable)
        if tracert_num_max is not None:
            pulumi.set(__self__, "tracert_num_max", tracert_num_max)
        if tracert_timeout is not None:
            pulumi.set(__self__, "tracert_timeout", tracert_timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="packageNum")
    def package_num(self) -> Optional[int]:
        """
        Number of ICMP(Ping) packets sent. The minimum value is 1, the maximum value is 50, and the default is 4.
        """
        return pulumi.get(self, "package_num")

    @property
    @pulumi.getter(name="packageSize")
    def package_size(self) -> Optional[int]:
        """
        The size of the sent ICMP(Ping) packet. The unit is byte. The ICMP(PING) packet size is limited to 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        """
        return pulumi.get(self, "package_size")

    @property
    @pulumi.getter(name="splitPackage")
    def split_package(self) -> Optional[bool]:
        """
        Whether to split ICMP(Ping) packets. The default is true.
        """
        return pulumi.get(self, "split_package")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tracertEnable")
    def tracert_enable(self) -> Optional[bool]:
        """
        Whether to enable tracert. The default is true.
        """
        return pulumi.get(self, "tracert_enable")

    @property
    @pulumi.getter(name="tracertNumMax")
    def tracert_num_max(self) -> Optional[int]:
        """
        The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        """
        return pulumi.get(self, "tracert_num_max")

    @property
    @pulumi.getter(name="tracertTimeout")
    def tracert_timeout(self) -> Optional[int]:
        """
        The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        return pulumi.get(self, "tracert_timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfNetTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "connectTimes":
            suggest = "connect_times"
        elif key == "tracertEnable":
            suggest = "tracert_enable"
        elif key == "tracertNumMax":
            suggest = "tracert_num_max"
        elif key == "tracertTimeout":
            suggest = "tracert_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfNetTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfNetTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfNetTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: str,
                 connect_times: Optional[int] = None,
                 interval: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tracert_enable: Optional[bool] = None,
                 tracert_num_max: Optional[int] = None,
                 tracert_timeout: Optional[int] = None):
        """
        :param str target_url: The target URL.
        :param int connect_times: The number of TCP connections established. The minimum value is 1, the maximum value is 16, and the default is 4.
        :param int interval: The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        :param int timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        :param bool tracert_enable: Whether to enable tracert. The default is true.
        :param int tracert_num_max: The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        :param int tracert_timeout: The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connect_times is not None:
            pulumi.set(__self__, "connect_times", connect_times)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracert_enable is not None:
            pulumi.set(__self__, "tracert_enable", tracert_enable)
        if tracert_num_max is not None:
            pulumi.set(__self__, "tracert_num_max", tracert_num_max)
        if tracert_timeout is not None:
            pulumi.set(__self__, "tracert_timeout", tracert_timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="connectTimes")
    def connect_times(self) -> Optional[int]:
        """
        The number of TCP connections established. The minimum value is 1, the maximum value is 16, and the default is 4.
        """
        return pulumi.get(self, "connect_times")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tracertEnable")
    def tracert_enable(self) -> Optional[bool]:
        """
        Whether to enable tracert. The default is true.
        """
        return pulumi.get(self, "tracert_enable")

    @property
    @pulumi.getter(name="tracertNumMax")
    def tracert_num_max(self) -> Optional[int]:
        """
        The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        """
        return pulumi.get(self, "tracert_num_max")

    @property
    @pulumi.getter(name="tracertTimeout")
    def tracert_timeout(self) -> Optional[int]:
        """
        The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        return pulumi.get(self, "tracert_timeout")


@pulumi.output_type
class SyntheticTaskMonitorConfStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHeaderContent":
            suggest = "custom_header_content"
        elif key == "playerType":
            suggest = "player_type"
        elif key == "streamAddressType":
            suggest = "stream_address_type"
        elif key == "streamMonitorTimeout":
            suggest = "stream_monitor_timeout"
        elif key == "streamType":
            suggest = "stream_type"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "whiteList":
            suggest = "white_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_header_content: Optional[Mapping[str, Any]] = None,
                 player_type: Optional[int] = None,
                 stream_address_type: Optional[int] = None,
                 stream_monitor_timeout: Optional[int] = None,
                 stream_type: Optional[int] = None,
                 target_url: Optional[str] = None,
                 white_list: Optional[str] = None):
        """
        :param Mapping[str, Any] custom_header_content: Custom header, in JSON Map format.
        :param int player_type: Player, do not pass the default 12.
               - 12:VLC
               - 2:FlashPlayer.
        :param int stream_address_type: Resource address type:
               - 1: Resource address.
               - 0: page address, not 0 by default.
        :param int stream_monitor_timeout: Monitoring duration, in seconds, up to 60s, not 60 by default.
        :param int stream_type: Audio and video flags: 0-video, 1-audio.
        :param str target_url: The target URL.
        :param str white_list: DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if player_type is not None:
            pulumi.set(__self__, "player_type", player_type)
        if stream_address_type is not None:
            pulumi.set(__self__, "stream_address_type", stream_address_type)
        if stream_monitor_timeout is not None:
            pulumi.set(__self__, "stream_monitor_timeout", stream_monitor_timeout)
        if stream_type is not None:
            pulumi.set(__self__, "stream_type", stream_type)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)
        if white_list is not None:
            pulumi.set(__self__, "white_list", white_list)

    @property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[Mapping[str, Any]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @property
    @pulumi.getter(name="playerType")
    def player_type(self) -> Optional[int]:
        """
        Player, do not pass the default 12.
        - 12:VLC
        - 2:FlashPlayer.
        """
        return pulumi.get(self, "player_type")

    @property
    @pulumi.getter(name="streamAddressType")
    def stream_address_type(self) -> Optional[int]:
        """
        Resource address type:
        - 1: Resource address.
        - 0: page address, not 0 by default.
        """
        return pulumi.get(self, "stream_address_type")

    @property
    @pulumi.getter(name="streamMonitorTimeout")
    def stream_monitor_timeout(self) -> Optional[int]:
        """
        Monitoring duration, in seconds, up to 60s, not 60 by default.
        """
        return pulumi.get(self, "stream_monitor_timeout")

    @property
    @pulumi.getter(name="streamType")
    def stream_type(self) -> Optional[int]:
        """
        Audio and video flags: 0-video, 1-audio.
        """
        return pulumi.get(self, "stream_type")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> Optional[str]:
        """
        DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "white_list")


@pulumi.output_type
class SyntheticTaskMonitorConfWebsite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"
        elif key == "automaticScrolling":
            suggest = "automatic_scrolling"
        elif key == "customHeader":
            suggest = "custom_header"
        elif key == "customHeaderContent":
            suggest = "custom_header_content"
        elif key == "disableCache":
            suggest = "disable_cache"
        elif key == "disableCompression":
            suggest = "disable_compression"
        elif key == "dnsHijackWhitelist":
            suggest = "dns_hijack_whitelist"
        elif key == "elementBlacklist":
            suggest = "element_blacklist"
        elif key == "filterInvalidIp":
            suggest = "filter_invalid_ip"
        elif key == "flowHijackJumpTimes":
            suggest = "flow_hijack_jump_times"
        elif key == "flowHijackLogo":
            suggest = "flow_hijack_logo"
        elif key == "ignoreCertificateError":
            suggest = "ignore_certificate_error"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "pageTamper":
            suggest = "page_tamper"
        elif key == "slowElementThreshold":
            suggest = "slow_element_threshold"
        elif key == "verifyStringBlacklist":
            suggest = "verify_string_blacklist"
        elif key == "verifyStringWhitelist":
            suggest = "verify_string_whitelist"
        elif key == "waitCompletionTime":
            suggest = "wait_completion_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticTaskMonitorConfWebsite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticTaskMonitorConfWebsite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticTaskMonitorConfWebsite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_url: str,
                 automatic_scrolling: Optional[int] = None,
                 custom_header: Optional[int] = None,
                 custom_header_content: Optional[Mapping[str, Any]] = None,
                 disable_cache: Optional[int] = None,
                 disable_compression: Optional[int] = None,
                 dns_hijack_whitelist: Optional[str] = None,
                 element_blacklist: Optional[str] = None,
                 filter_invalid_ip: Optional[int] = None,
                 flow_hijack_jump_times: Optional[int] = None,
                 flow_hijack_logo: Optional[str] = None,
                 ignore_certificate_error: Optional[int] = None,
                 monitor_timeout: Optional[int] = None,
                 page_tamper: Optional[str] = None,
                 redirection: Optional[int] = None,
                 slow_element_threshold: Optional[int] = None,
                 verify_string_blacklist: Optional[str] = None,
                 verify_string_whitelist: Optional[str] = None,
                 wait_completion_time: Optional[int] = None):
        """
        :param str target_url: The target URL.
        :param int automatic_scrolling: Whether to support automatic scrolling screen, loading page.
               - 0 (default): No
               1: Yes.
        :param int custom_header: Custom header.
               - 0 (default): Off
               - 1: Modify the first package
               - 2: Modify all packages.
        :param Mapping[str, Any] custom_header_content: Custom header, in JSON Map format.
        :param int disable_cache: Whether to disable caching.
               - 0: not disabled
               - 1 (default): Disabled.
        :param int disable_compression: The Accept-Encoding field is used to determine whether to Accept compressed files. 0-do not disable, 1-disable, the default is 0.
        :param str dns_hijack_whitelist: When a domain name (such as www.aliyun.com) is resolved, if the resolved IP address or CNAME is not in the DNS hijacking white list, the user will fail to access or return a target IP address that is not Aliyun. If the IP or CNAME in the resolution result is in the DNS white list, it will be determined that DNS hijacking has not occurred.  Fill in the format: Domain name: matching rules. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        :param str element_blacklist: If an element configured in the element blacklist appears during page loading, the element is not requested to be loaded.
        :param int filter_invalid_ip: Whether to filter invalid IP parameters. 0: filter, 1: do not filter. The default value is 0.
        :param int flow_hijack_jump_times: Identify elements: Set the total number of elements on the Browse page.
        :param str flow_hijack_logo: Hijacking ID: Set the matching key information. Enter the hijacking keyword or key element, with an asterisk (*) allowed.
        :param int ignore_certificate_error: Whether to ignore certificate errors during certificate verification in SSL Handshake and continue browsing. 0-do not ignore, 1-ignore. The default value is 1.
        :param int monitor_timeout: Monitoring timeout, in ms. Not required, 20000 by default.
        :param str page_tamper: Monitoring the page appears to be tampered with elements other than the domain settings that belong to the page. Common manifestations are pop-up advertisements, floating advertisements, jumps, etc.  Fill in the format: Domain name: Element. You can fill multiple elements separated by a vertical bar (|). For example, www.aliyun.com:|/cc/bb/a.gif |/vv/bb/cc.jpg indicates that all the other elements of the www.aliyun.com domain name except the basic document,/cc/bb/a.gif, and/vv/bb/cc.jpg are tampered.
        :param int redirection: When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        :param int slow_element_threshold: The slow element threshold, in ms, is 5000 by default and can be selected from 1 to 300000ms.
        :param str verify_string_blacklist: The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any of the blacklisted strings, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        :param str verify_string_whitelist: The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist. Otherwise, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        :param int wait_completion_time: The maximum waiting time, in ms, is 5000 by default and can be selected from 5000 ms to 300000ms.
        """
        pulumi.set(__self__, "target_url", target_url)
        if automatic_scrolling is not None:
            pulumi.set(__self__, "automatic_scrolling", automatic_scrolling)
        if custom_header is not None:
            pulumi.set(__self__, "custom_header", custom_header)
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_compression is not None:
            pulumi.set(__self__, "disable_compression", disable_compression)
        if dns_hijack_whitelist is not None:
            pulumi.set(__self__, "dns_hijack_whitelist", dns_hijack_whitelist)
        if element_blacklist is not None:
            pulumi.set(__self__, "element_blacklist", element_blacklist)
        if filter_invalid_ip is not None:
            pulumi.set(__self__, "filter_invalid_ip", filter_invalid_ip)
        if flow_hijack_jump_times is not None:
            pulumi.set(__self__, "flow_hijack_jump_times", flow_hijack_jump_times)
        if flow_hijack_logo is not None:
            pulumi.set(__self__, "flow_hijack_logo", flow_hijack_logo)
        if ignore_certificate_error is not None:
            pulumi.set(__self__, "ignore_certificate_error", ignore_certificate_error)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if page_tamper is not None:
            pulumi.set(__self__, "page_tamper", page_tamper)
        if redirection is not None:
            pulumi.set(__self__, "redirection", redirection)
        if slow_element_threshold is not None:
            pulumi.set(__self__, "slow_element_threshold", slow_element_threshold)
        if verify_string_blacklist is not None:
            pulumi.set(__self__, "verify_string_blacklist", verify_string_blacklist)
        if verify_string_whitelist is not None:
            pulumi.set(__self__, "verify_string_whitelist", verify_string_whitelist)
        if wait_completion_time is not None:
            pulumi.set(__self__, "wait_completion_time", wait_completion_time)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> str:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @property
    @pulumi.getter(name="automaticScrolling")
    def automatic_scrolling(self) -> Optional[int]:
        """
        Whether to support automatic scrolling screen, loading page.
        - 0 (default): No
        1: Yes.
        """
        return pulumi.get(self, "automatic_scrolling")

    @property
    @pulumi.getter(name="customHeader")
    def custom_header(self) -> Optional[int]:
        """
        Custom header.
        - 0 (default): Off
        - 1: Modify the first package
        - 2: Modify all packages.
        """
        return pulumi.get(self, "custom_header")

    @property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[Mapping[str, Any]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[int]:
        """
        Whether to disable caching.
        - 0: not disabled
        - 1 (default): Disabled.
        """
        return pulumi.get(self, "disable_cache")

    @property
    @pulumi.getter(name="disableCompression")
    def disable_compression(self) -> Optional[int]:
        """
        The Accept-Encoding field is used to determine whether to Accept compressed files. 0-do not disable, 1-disable, the default is 0.
        """
        return pulumi.get(self, "disable_compression")

    @property
    @pulumi.getter(name="dnsHijackWhitelist")
    def dns_hijack_whitelist(self) -> Optional[str]:
        """
        When a domain name (such as www.aliyun.com) is resolved, if the resolved IP address or CNAME is not in the DNS hijacking white list, the user will fail to access or return a target IP address that is not Aliyun. If the IP or CNAME in the resolution result is in the DNS white list, it will be determined that DNS hijacking has not occurred.  Fill in the format: Domain name: matching rules. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "dns_hijack_whitelist")

    @property
    @pulumi.getter(name="elementBlacklist")
    def element_blacklist(self) -> Optional[str]:
        """
        If an element configured in the element blacklist appears during page loading, the element is not requested to be loaded.
        """
        return pulumi.get(self, "element_blacklist")

    @property
    @pulumi.getter(name="filterInvalidIp")
    def filter_invalid_ip(self) -> Optional[int]:
        """
        Whether to filter invalid IP parameters. 0: filter, 1: do not filter. The default value is 0.
        """
        return pulumi.get(self, "filter_invalid_ip")

    @property
    @pulumi.getter(name="flowHijackJumpTimes")
    def flow_hijack_jump_times(self) -> Optional[int]:
        """
        Identify elements: Set the total number of elements on the Browse page.
        """
        return pulumi.get(self, "flow_hijack_jump_times")

    @property
    @pulumi.getter(name="flowHijackLogo")
    def flow_hijack_logo(self) -> Optional[str]:
        """
        Hijacking ID: Set the matching key information. Enter the hijacking keyword or key element, with an asterisk (*) allowed.
        """
        return pulumi.get(self, "flow_hijack_logo")

    @property
    @pulumi.getter(name="ignoreCertificateError")
    def ignore_certificate_error(self) -> Optional[int]:
        """
        Whether to ignore certificate errors during certificate verification in SSL Handshake and continue browsing. 0-do not ignore, 1-ignore. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_error")

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[int]:
        """
        Monitoring timeout, in ms. Not required, 20000 by default.
        """
        return pulumi.get(self, "monitor_timeout")

    @property
    @pulumi.getter(name="pageTamper")
    def page_tamper(self) -> Optional[str]:
        """
        Monitoring the page appears to be tampered with elements other than the domain settings that belong to the page. Common manifestations are pop-up advertisements, floating advertisements, jumps, etc.  Fill in the format: Domain name: Element. You can fill multiple elements separated by a vertical bar (|). For example, www.aliyun.com:|/cc/bb/a.gif |/vv/bb/cc.jpg indicates that all the other elements of the www.aliyun.com domain name except the basic document,/cc/bb/a.gif, and/vv/bb/cc.jpg are tampered.
        """
        return pulumi.get(self, "page_tamper")

    @property
    @pulumi.getter
    def redirection(self) -> Optional[int]:
        """
        When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        """
        return pulumi.get(self, "redirection")

    @property
    @pulumi.getter(name="slowElementThreshold")
    def slow_element_threshold(self) -> Optional[int]:
        """
        The slow element threshold, in ms, is 5000 by default and can be selected from 1 to 300000ms.
        """
        return pulumi.get(self, "slow_element_threshold")

    @property
    @pulumi.getter(name="verifyStringBlacklist")
    def verify_string_blacklist(self) -> Optional[str]:
        """
        The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any of the blacklisted strings, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        """
        return pulumi.get(self, "verify_string_blacklist")

    @property
    @pulumi.getter(name="verifyStringWhitelist")
    def verify_string_whitelist(self) -> Optional[str]:
        """
        The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist. Otherwise, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        """
        return pulumi.get(self, "verify_string_whitelist")

    @property
    @pulumi.getter(name="waitCompletionTime")
    def wait_completion_time(self) -> Optional[int]:
        """
        The maximum waiting time, in ms, is 5000 by default and can be selected from 5000 ms to 300000ms.
        """
        return pulumi.get(self, "wait_completion_time")


@pulumi.output_type
class GetAlertContactGroupsGroupResult(dict):
    def __init__(__self__, *,
                 alert_contact_group_id: str,
                 alert_contact_group_name: str,
                 contact_ids: Sequence[str],
                 create_time: str,
                 id: str):
        """
        :param str alert_contact_group_id: The first ID of the resource.
        :param str alert_contact_group_name: The name of the resource.
        :param Sequence[str] contact_ids: contact ids.
        :param str create_time: The creation time of the resource.
        :param str id: The ID of the Alert Contact Group.
        """
        pulumi.set(__self__, "alert_contact_group_id", alert_contact_group_id)
        pulumi.set(__self__, "alert_contact_group_name", alert_contact_group_name)
        pulumi.set(__self__, "contact_ids", contact_ids)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="alertContactGroupId")
    def alert_contact_group_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "alert_contact_group_id")

    @property
    @pulumi.getter(name="alertContactGroupName")
    def alert_contact_group_name(self) -> str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "alert_contact_group_name")

    @property
    @pulumi.getter(name="contactIds")
    def contact_ids(self) -> Sequence[str]:
        """
        contact ids.
        """
        return pulumi.get(self, "contact_ids")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Alert Contact Group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAlertContactsContactResult(dict):
    def __init__(__self__, *,
                 alert_contact_id: str,
                 alert_contact_name: str,
                 create_time: str,
                 ding_robot_webhook_url: str,
                 email: str,
                 id: str,
                 phone_num: str,
                 system_noc: bool,
                 webhook: str):
        """
        :param str alert_contact_id: Contact ID.
        :param str alert_contact_name: The name of the alert contact.
        :param str create_time: The Creation Time Timestamp.
        :param str ding_robot_webhook_url: The webhook URL of the DingTalk chatbot.
        :param str email: The email address of the alert contact.
        :param str id: The ID of the Alert Contact.
        :param str phone_num: The mobile number of the alert contact.
        :param bool system_noc: Specifies whether the alert contact receives system notifications.
        :param str webhook: Webhook Information.
        """
        pulumi.set(__self__, "alert_contact_id", alert_contact_id)
        pulumi.set(__self__, "alert_contact_name", alert_contact_name)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "ding_robot_webhook_url", ding_robot_webhook_url)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "phone_num", phone_num)
        pulumi.set(__self__, "system_noc", system_noc)
        pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="alertContactId")
    def alert_contact_id(self) -> str:
        """
        Contact ID.
        """
        return pulumi.get(self, "alert_contact_id")

    @property
    @pulumi.getter(name="alertContactName")
    def alert_contact_name(self) -> str:
        """
        The name of the alert contact.
        """
        return pulumi.get(self, "alert_contact_name")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The Creation Time Timestamp.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dingRobotWebhookUrl")
    def ding_robot_webhook_url(self) -> str:
        """
        The webhook URL of the DingTalk chatbot.
        """
        return pulumi.get(self, "ding_robot_webhook_url")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address of the alert contact.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Alert Contact.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="phoneNum")
    def phone_num(self) -> str:
        """
        The mobile number of the alert contact.
        """
        return pulumi.get(self, "phone_num")

    @property
    @pulumi.getter(name="systemNoc")
    def system_noc(self) -> bool:
        """
        Specifies whether the alert contact receives system notifications.
        """
        return pulumi.get(self, "system_noc")

    @property
    @pulumi.getter
    def webhook(self) -> str:
        """
        Webhook Information.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetDispatchRulesRuleResult(dict):
    def __init__(__self__, *,
                 dispatch_rule_id: str,
                 dispatch_rule_name: str,
                 dispatch_type: str,
                 group_rules: Sequence['outputs.GetDispatchRulesRuleGroupRuleResult'],
                 id: str,
                 label_match_expression_grids: Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridResult'],
                 notify_rules: Sequence['outputs.GetDispatchRulesRuleNotifyRuleResult'],
                 status: str):
        """
        :param str dispatch_rule_id: Dispatch rule ID.
        :param str dispatch_rule_name: The name of the dispatch rule.
        :param Sequence['GetDispatchRulesRuleGroupRuleArgs'] group_rules: Sets the event group.
        :param str id: The ID of the Dispatch Rule.
        :param Sequence['GetDispatchRulesRuleLabelMatchExpressionGridArgs'] label_match_expression_grids: Sets the dispatch rule.
        :param Sequence['GetDispatchRulesRuleNotifyRuleArgs'] notify_rules: Sets the notification rule.
        :param str status: The resource status of Alert Dispatch Rule.
        """
        pulumi.set(__self__, "dispatch_rule_id", dispatch_rule_id)
        pulumi.set(__self__, "dispatch_rule_name", dispatch_rule_name)
        pulumi.set(__self__, "dispatch_type", dispatch_type)
        pulumi.set(__self__, "group_rules", group_rules)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label_match_expression_grids", label_match_expression_grids)
        pulumi.set(__self__, "notify_rules", notify_rules)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dispatchRuleId")
    def dispatch_rule_id(self) -> str:
        """
        Dispatch rule ID.
        """
        return pulumi.get(self, "dispatch_rule_id")

    @property
    @pulumi.getter(name="dispatchRuleName")
    def dispatch_rule_name(self) -> str:
        """
        The name of the dispatch rule.
        """
        return pulumi.get(self, "dispatch_rule_name")

    @property
    @pulumi.getter(name="dispatchType")
    def dispatch_type(self) -> str:
        return pulumi.get(self, "dispatch_type")

    @property
    @pulumi.getter(name="groupRules")
    def group_rules(self) -> Sequence['outputs.GetDispatchRulesRuleGroupRuleResult']:
        """
        Sets the event group.
        """
        return pulumi.get(self, "group_rules")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Dispatch Rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="labelMatchExpressionGrids")
    def label_match_expression_grids(self) -> Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridResult']:
        """
        Sets the dispatch rule.
        """
        return pulumi.get(self, "label_match_expression_grids")

    @property
    @pulumi.getter(name="notifyRules")
    def notify_rules(self) -> Sequence['outputs.GetDispatchRulesRuleNotifyRuleResult']:
        """
        Sets the notification rule.
        """
        return pulumi.get(self, "notify_rules")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The resource status of Alert Dispatch Rule.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDispatchRulesRuleGroupRuleResult(dict):
    def __init__(__self__, *,
                 group_id: int,
                 group_interval: int,
                 group_wait_time: int,
                 grouping_fields: Sequence[str],
                 repeat_interval: int):
        """
        :param int group_interval: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param int group_wait_time: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param Sequence[str] grouping_fields: The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        :param int repeat_interval: The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_interval", group_interval)
        pulumi.set(__self__, "group_wait_time", group_wait_time)
        pulumi.set(__self__, "grouping_fields", grouping_fields)
        pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> int:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_interval")

    @property
    @pulumi.getter(name="groupWaitTime")
    def group_wait_time(self) -> int:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_wait_time")

    @property
    @pulumi.getter(name="groupingFields")
    def grouping_fields(self) -> Sequence[str]:
        """
        The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        """
        return pulumi.get(self, "grouping_fields")

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> int:
        """
        The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        return pulumi.get(self, "repeat_interval")


@pulumi.output_type
class GetDispatchRulesRuleLabelMatchExpressionGridResult(dict):
    def __init__(__self__, *,
                 label_match_expression_groups: Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult']):
        """
        :param Sequence['GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs'] label_match_expression_groups: Sets the dispatch rule.
        """
        pulumi.set(__self__, "label_match_expression_groups", label_match_expression_groups)

    @property
    @pulumi.getter(name="labelMatchExpressionGroups")
    def label_match_expression_groups(self) -> Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult']:
        """
        Sets the dispatch rule.
        """
        return pulumi.get(self, "label_match_expression_groups")


@pulumi.output_type
class GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupResult(dict):
    def __init__(__self__, *,
                 label_match_expressions: Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult']):
        """
        :param Sequence['GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs'] label_match_expressions: Sets the dispatch rule.
        """
        pulumi.set(__self__, "label_match_expressions", label_match_expressions)

    @property
    @pulumi.getter(name="labelMatchExpressions")
    def label_match_expressions(self) -> Sequence['outputs.GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult']:
        """
        Sets the dispatch rule.
        """
        return pulumi.get(self, "label_match_expressions")


@pulumi.output_type
class GetDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 value: str):
        """
        :param str key: The key of the tag of the dispatch rule.
        :param str operator: The operator used in the dispatch rule.
        :param str value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag of the dispatch rule.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator used in the dispatch rule.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDispatchRulesRuleNotifyRuleResult(dict):
    def __init__(__self__, *,
                 notify_channels: Sequence[str],
                 notify_objects: Sequence['outputs.GetDispatchRulesRuleNotifyRuleNotifyObjectResult']):
        """
        :param Sequence[str] notify_channels: The notification method.
        :param Sequence['GetDispatchRulesRuleNotifyRuleNotifyObjectArgs'] notify_objects: Sets the notification object.
        """
        pulumi.set(__self__, "notify_channels", notify_channels)
        pulumi.set(__self__, "notify_objects", notify_objects)

    @property
    @pulumi.getter(name="notifyChannels")
    def notify_channels(self) -> Sequence[str]:
        """
        The notification method.
        """
        return pulumi.get(self, "notify_channels")

    @property
    @pulumi.getter(name="notifyObjects")
    def notify_objects(self) -> Sequence['outputs.GetDispatchRulesRuleNotifyRuleNotifyObjectResult']:
        """
        Sets the notification object.
        """
        return pulumi.get(self, "notify_objects")


@pulumi.output_type
class GetDispatchRulesRuleNotifyRuleNotifyObjectResult(dict):
    def __init__(__self__, *,
                 name: str,
                 notify_object_id: str,
                 notify_type: str):
        """
        :param str name: The name of the contact or contact group.
        :param str notify_object_id: The ID of the contact or contact group.
        :param str notify_type: The type of the alert contact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_object_id", notify_object_id)
        pulumi.set(__self__, "notify_type", notify_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the contact or contact group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notifyObjectId")
    def notify_object_id(self) -> str:
        """
        The ID of the contact or contact group.
        """
        return pulumi.get(self, "notify_object_id")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        """
        The type of the alert contact.
        """
        return pulumi.get(self, "notify_type")


@pulumi.output_type
class GetIntegrationExportersIntegrationExporterResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 exporter_type: str,
                 id: str,
                 instance_id: int,
                 instance_name: str,
                 integration_type: str,
                 param: str,
                 target: str,
                 version: str):
        """
        :param str cluster_id: The ID of the Prometheus instance.
        :param str exporter_type: Integration Exporter Type.
        :param str id: The ID of the Integration Exporter. It formats as `<cluster_id>:<integration_type>:<instance_id>`.
        :param int instance_id: The ID of the Integration Exporter instance.
        :param str instance_name: The name of the instance.
        :param str integration_type: The type of prometheus integration.
        :param str param: Exporter configuration parameter json string.
        :param str target: Monitor the target address.
        :param str version: The version information.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "exporter_type", exporter_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "integration_type", integration_type)
        pulumi.set(__self__, "param", param)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="exporterType")
    def exporter_type(self) -> str:
        """
        Integration Exporter Type.
        """
        return pulumi.get(self, "exporter_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Integration Exporter. It formats as `<cluster_id>:<integration_type>:<instance_id>`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> int:
        """
        The ID of the Integration Exporter instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The name of the instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        The type of prometheus integration.
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter
    def param(self) -> str:
        """
        Exporter configuration parameter json string.
        """
        return pulumi.get(self, "param")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Monitor the target address.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version information.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPrometheisPrometheiResult(dict):
    def __init__(__self__, *,
                 auth_token: str,
                 cluster_id: str,
                 cluster_name: str,
                 cluster_type: str,
                 grafana_instance_id: str,
                 http_api_inter_url: str,
                 http_api_intra_url: str,
                 id: str,
                 push_gate_way_inter_url: str,
                 push_gate_way_intra_url: str,
                 remote_read_inter_url: str,
                 remote_read_intra_url: str,
                 remote_write_inter_url: str,
                 remote_write_intra_url: str,
                 resource_group_id: str,
                 security_group_id: str,
                 sub_clusters_json: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param str auth_token: The token used to access the data source.
        :param str cluster_id: The ID of the cluster.
        :param str cluster_name: The name of the cluster.
        :param str cluster_type: The type of the cluster.
        :param str grafana_instance_id: The ID of the Grafana workspace.
        :param str http_api_inter_url: Http api public network address.
        :param str http_api_intra_url: Http api intranet address.
        :param str id: The ID of the Prometheus.
        :param str push_gate_way_inter_url: PushGateway public network Url.
        :param str push_gate_way_intra_url: PushGateway intranet Url.
        :param str remote_read_inter_url: Public Url of remoteRead.
        :param str remote_read_intra_url: RemoteRead intranet Url.
        :param str remote_write_inter_url: RemoteWrite public Url.
        :param str remote_write_intra_url: RemoteWrite Intranet Url.
        :param str resource_group_id: The ID of the resource group.
        :param str security_group_id: The ID of the security group.
        :param str sub_clusters_json: The child instance json string of the globalView instance.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        :param str vpc_id: The ID of the VPC.
        :param str vswitch_id: The ID of the VSwitch.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "grafana_instance_id", grafana_instance_id)
        pulumi.set(__self__, "http_api_inter_url", http_api_inter_url)
        pulumi.set(__self__, "http_api_intra_url", http_api_intra_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "push_gate_way_inter_url", push_gate_way_inter_url)
        pulumi.set(__self__, "push_gate_way_intra_url", push_gate_way_intra_url)
        pulumi.set(__self__, "remote_read_inter_url", remote_read_inter_url)
        pulumi.set(__self__, "remote_read_intra_url", remote_read_intra_url)
        pulumi.set(__self__, "remote_write_inter_url", remote_write_inter_url)
        pulumi.set(__self__, "remote_write_intra_url", remote_write_intra_url)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "sub_clusters_json", sub_clusters_json)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        The token used to access the data source.
        """
        return pulumi.get(self, "auth_token")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        The type of the cluster.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="grafanaInstanceId")
    def grafana_instance_id(self) -> str:
        """
        The ID of the Grafana workspace.
        """
        return pulumi.get(self, "grafana_instance_id")

    @property
    @pulumi.getter(name="httpApiInterUrl")
    def http_api_inter_url(self) -> str:
        """
        Http api public network address.
        """
        return pulumi.get(self, "http_api_inter_url")

    @property
    @pulumi.getter(name="httpApiIntraUrl")
    def http_api_intra_url(self) -> str:
        """
        Http api intranet address.
        """
        return pulumi.get(self, "http_api_intra_url")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Prometheus.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="pushGateWayInterUrl")
    def push_gate_way_inter_url(self) -> str:
        """
        PushGateway public network Url.
        """
        return pulumi.get(self, "push_gate_way_inter_url")

    @property
    @pulumi.getter(name="pushGateWayIntraUrl")
    def push_gate_way_intra_url(self) -> str:
        """
        PushGateway intranet Url.
        """
        return pulumi.get(self, "push_gate_way_intra_url")

    @property
    @pulumi.getter(name="remoteReadInterUrl")
    def remote_read_inter_url(self) -> str:
        """
        Public Url of remoteRead.
        """
        return pulumi.get(self, "remote_read_inter_url")

    @property
    @pulumi.getter(name="remoteReadIntraUrl")
    def remote_read_intra_url(self) -> str:
        """
        RemoteRead intranet Url.
        """
        return pulumi.get(self, "remote_read_intra_url")

    @property
    @pulumi.getter(name="remoteWriteInterUrl")
    def remote_write_inter_url(self) -> str:
        """
        RemoteWrite public Url.
        """
        return pulumi.get(self, "remote_write_inter_url")

    @property
    @pulumi.getter(name="remoteWriteIntraUrl")
    def remote_write_intra_url(self) -> str:
        """
        RemoteWrite Intranet Url.
        """
        return pulumi.get(self, "remote_write_intra_url")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="subClustersJson")
    def sub_clusters_json(self) -> str:
        """
        The child instance json string of the globalView instance.
        """
        return pulumi.get(self, "sub_clusters_json")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetPrometheusAlertRulesRuleResult(dict):
    def __init__(__self__, *,
                 annotations: Sequence['outputs.GetPrometheusAlertRulesRuleAnnotationResult'],
                 cluster_id: str,
                 dispatch_rule_id: str,
                 duration: str,
                 expression: str,
                 id: str,
                 labels: Sequence['outputs.GetPrometheusAlertRulesRuleLabelResult'],
                 message: str,
                 notify_type: str,
                 prometheus_alert_rule_id: str,
                 prometheus_alert_rule_name: str,
                 status: int,
                 type: str):
        """
        :param Sequence['GetPrometheusAlertRulesRuleAnnotationArgs'] annotations: The annotations of the alert rule.
        :param str cluster_id: The ID of the cluster.
        :param str dispatch_rule_id: The ID of the notification policy. This parameter is required when the `notify_type` parameter is set to `DISPATCH_RULE`.
        :param str duration: The duration of the alert.
        :param str expression: The alert rule expression that follows the PromQL syntax..
        :param str id: The ID of the Prometheus Alert Rule.
        :param Sequence['GetPrometheusAlertRulesRuleLabelArgs'] labels: The labels of the resource.
        :param str message: The message of the alert notification.
        :param str notify_type: The method of sending the alert notification. Valid values: `ALERT_MANAGER`, `DISPATCH_RULE`.
        :param str prometheus_alert_rule_id: The first ID of the resource.
        :param str prometheus_alert_rule_name: The name of the resource.
        :param int status: The status of the resource. Valid values: `0`, `1`.
        :param str type: The type of the alert rule.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "dispatch_rule_id", dispatch_rule_id)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "notify_type", notify_type)
        pulumi.set(__self__, "prometheus_alert_rule_id", prometheus_alert_rule_id)
        pulumi.set(__self__, "prometheus_alert_rule_name", prometheus_alert_rule_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def annotations(self) -> Sequence['outputs.GetPrometheusAlertRulesRuleAnnotationResult']:
        """
        The annotations of the alert rule.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="dispatchRuleId")
    def dispatch_rule_id(self) -> str:
        """
        The ID of the notification policy. This parameter is required when the `notify_type` parameter is set to `DISPATCH_RULE`.
        """
        return pulumi.get(self, "dispatch_rule_id")

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The duration of the alert.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The alert rule expression that follows the PromQL syntax..
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Prometheus Alert Rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetPrometheusAlertRulesRuleLabelResult']:
        """
        The labels of the resource.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The message of the alert notification.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> str:
        """
        The method of sending the alert notification. Valid values: `ALERT_MANAGER`, `DISPATCH_RULE`.
        """
        return pulumi.get(self, "notify_type")

    @property
    @pulumi.getter(name="prometheusAlertRuleId")
    def prometheus_alert_rule_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "prometheus_alert_rule_id")

    @property
    @pulumi.getter(name="prometheusAlertRuleName")
    def prometheus_alert_rule_name(self) -> str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "prometheus_alert_rule_name")

    @property
    @pulumi.getter
    def status(self) -> int:
        """
        The status of the resource. Valid values: `0`, `1`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the alert rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrometheusAlertRulesRuleAnnotationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the label.
        :param str value: The value of the label.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPrometheusAlertRulesRuleLabelResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the label.
        :param str value: The value of the label.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPrometheusMonitoringsPrometheusMonitoringResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 config_yaml: str,
                 id: str,
                 monitoring_name: str,
                 status: str,
                 type: str):
        """
        :param str cluster_id: The ID of the Prometheus instance.
        :param str config_yaml: The monitoring configuration. The value is a YAML string.
        :param str id: The ID of the Prometheus Monitoring. It formats as `<cluster_id>:<monitoring_name>:<type>`.
        :param str monitoring_name: The name of the monitoring configuration.
        :param str status: The status of the monitoring configuration. Valid values: `run`, `stop`.
        :param str type: The type of the monitoring configuration. Valid values: `serviceMonitor`, `podMonitor`, `customJob`, `probe`.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "config_yaml", config_yaml)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "monitoring_name", monitoring_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="configYaml")
    def config_yaml(self) -> str:
        """
        The monitoring configuration. The value is a YAML string.
        """
        return pulumi.get(self, "config_yaml")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Prometheus Monitoring. It formats as `<cluster_id>:<monitoring_name>:<type>`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="monitoringName")
    def monitoring_name(self) -> str:
        """
        The name of the monitoring configuration.
        """
        return pulumi.get(self, "monitoring_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the monitoring configuration. Valid values: `run`, `stop`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the monitoring configuration. Valid values: `serviceMonitor`, `podMonitor`, `customJob`, `probe`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrometheusPrometheiResult(dict):
    def __init__(__self__, *,
                 auth_token: str,
                 cluster_id: str,
                 cluster_name: str,
                 cluster_type: str,
                 grafana_instance_id: str,
                 http_api_inter_url: str,
                 http_api_intra_url: str,
                 id: str,
                 push_gate_way_inter_url: str,
                 push_gate_way_intra_url: str,
                 remote_read_inter_url: str,
                 remote_read_intra_url: str,
                 remote_write_inter_url: str,
                 remote_write_intra_url: str,
                 resource_group_id: str,
                 security_group_id: str,
                 sub_clusters_json: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param str auth_token: The token used to access the data source.
        :param str cluster_id: The ID of the cluster.
        :param str cluster_name: The name of the cluster.
        :param str cluster_type: The type of the cluster.
        :param str grafana_instance_id: The ID of the Grafana workspace.
        :param str http_api_inter_url: Http api public network address.
        :param str http_api_intra_url: Http api intranet address.
        :param str id: The ID of the Prometheus.
        :param str push_gate_way_inter_url: PushGateway public network Url.
        :param str push_gate_way_intra_url: PushGateway intranet Url.
        :param str remote_read_inter_url: Public Url of remoteRead.
        :param str remote_read_intra_url: RemoteRead intranet Url.
        :param str remote_write_inter_url: RemoteWrite public Url.
        :param str remote_write_intra_url: RemoteWrite Intranet Url.
        :param str resource_group_id: The ID of the resource group.
        :param str security_group_id: The ID of the security group.
        :param str sub_clusters_json: The child instance json string of the globalView instance.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        :param str vpc_id: The ID of the VPC.
        :param str vswitch_id: The ID of the VSwitch.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "grafana_instance_id", grafana_instance_id)
        pulumi.set(__self__, "http_api_inter_url", http_api_inter_url)
        pulumi.set(__self__, "http_api_intra_url", http_api_intra_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "push_gate_way_inter_url", push_gate_way_inter_url)
        pulumi.set(__self__, "push_gate_way_intra_url", push_gate_way_intra_url)
        pulumi.set(__self__, "remote_read_inter_url", remote_read_inter_url)
        pulumi.set(__self__, "remote_read_intra_url", remote_read_intra_url)
        pulumi.set(__self__, "remote_write_inter_url", remote_write_inter_url)
        pulumi.set(__self__, "remote_write_intra_url", remote_write_intra_url)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "sub_clusters_json", sub_clusters_json)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        The token used to access the data source.
        """
        return pulumi.get(self, "auth_token")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        The type of the cluster.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="grafanaInstanceId")
    def grafana_instance_id(self) -> str:
        """
        The ID of the Grafana workspace.
        """
        return pulumi.get(self, "grafana_instance_id")

    @property
    @pulumi.getter(name="httpApiInterUrl")
    def http_api_inter_url(self) -> str:
        """
        Http api public network address.
        """
        return pulumi.get(self, "http_api_inter_url")

    @property
    @pulumi.getter(name="httpApiIntraUrl")
    def http_api_intra_url(self) -> str:
        """
        Http api intranet address.
        """
        return pulumi.get(self, "http_api_intra_url")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Prometheus.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="pushGateWayInterUrl")
    def push_gate_way_inter_url(self) -> str:
        """
        PushGateway public network Url.
        """
        return pulumi.get(self, "push_gate_way_inter_url")

    @property
    @pulumi.getter(name="pushGateWayIntraUrl")
    def push_gate_way_intra_url(self) -> str:
        """
        PushGateway intranet Url.
        """
        return pulumi.get(self, "push_gate_way_intra_url")

    @property
    @pulumi.getter(name="remoteReadInterUrl")
    def remote_read_inter_url(self) -> str:
        """
        Public Url of remoteRead.
        """
        return pulumi.get(self, "remote_read_inter_url")

    @property
    @pulumi.getter(name="remoteReadIntraUrl")
    def remote_read_intra_url(self) -> str:
        """
        RemoteRead intranet Url.
        """
        return pulumi.get(self, "remote_read_intra_url")

    @property
    @pulumi.getter(name="remoteWriteInterUrl")
    def remote_write_inter_url(self) -> str:
        """
        RemoteWrite public Url.
        """
        return pulumi.get(self, "remote_write_inter_url")

    @property
    @pulumi.getter(name="remoteWriteIntraUrl")
    def remote_write_intra_url(self) -> str:
        """
        RemoteWrite Intranet Url.
        """
        return pulumi.get(self, "remote_write_intra_url")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="subClustersJson")
    def sub_clusters_json(self) -> str:
        """
        The child instance json string of the globalView instance.
        """
        return pulumi.get(self, "sub_clusters_json")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetRemoteWritesRemoteWriteResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 id: str,
                 remote_write_name: str,
                 remote_write_yaml: str):
        """
        :param str cluster_id: The ID of the Prometheus instance.
        :param str id: The ID of the Remote Write. It formats as `<cluster_id>:<remote_write_name>`.
        :param str remote_write_name: The name of the Remote Write configuration item.
        :param str remote_write_yaml: The details of the Remote Write configuration item. The value is in the YAML format.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "remote_write_name", remote_write_name)
        pulumi.set(__self__, "remote_write_yaml", remote_write_yaml)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the Prometheus instance.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Remote Write. It formats as `<cluster_id>:<remote_write_name>`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="remoteWriteName")
    def remote_write_name(self) -> str:
        """
        The name of the Remote Write configuration item.
        """
        return pulumi.get(self, "remote_write_name")

    @property
    @pulumi.getter(name="remoteWriteYaml")
    def remote_write_yaml(self) -> str:
        """
        The details of the Remote Write configuration item. The value is in the YAML format.
        """
        return pulumi.get(self, "remote_write_yaml")


