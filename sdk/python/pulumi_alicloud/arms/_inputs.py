# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DispatchRuleGroupRuleArgs',
    'DispatchRuleLabelMatchExpressionGridArgs',
    'DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs',
    'DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs',
    'DispatchRuleNotifyRuleArgs',
    'DispatchRuleNotifyRuleNotifyObjectArgs',
    'PrometheusAlertRuleAnnotationArgs',
    'PrometheusAlertRuleLabelArgs',
    'SyntheticTaskAvailableAssertionArgs',
    'SyntheticTaskCommonSettingArgs',
    'SyntheticTaskCommonSettingCustomHostArgs',
    'SyntheticTaskCommonSettingCustomHostHostArgs',
    'SyntheticTaskCustomPeriodArgs',
    'SyntheticTaskMonitorArgs',
    'SyntheticTaskMonitorConfArgs',
    'SyntheticTaskMonitorConfApiHttpArgs',
    'SyntheticTaskMonitorConfApiHttpRequestBodyArgs',
    'SyntheticTaskMonitorConfFileDownloadArgs',
    'SyntheticTaskMonitorConfNetDnsArgs',
    'SyntheticTaskMonitorConfNetIcmpArgs',
    'SyntheticTaskMonitorConfNetTcpArgs',
    'SyntheticTaskMonitorConfStreamArgs',
    'SyntheticTaskMonitorConfWebsiteArgs',
]

@pulumi.input_type
class DispatchRuleGroupRuleArgs:
    def __init__(__self__, *,
                 group_interval: pulumi.Input[int],
                 group_wait_time: pulumi.Input[int],
                 grouping_fields: pulumi.Input[Sequence[pulumi.Input[str]]],
                 group_id: Optional[pulumi.Input[int]] = None,
                 repeat_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] group_interval: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param pulumi.Input[int] group_wait_time: The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] grouping_fields: The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        :param pulumi.Input[int] group_id: The ID of the group rule.
        :param pulumi.Input[int] repeat_interval: The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        pulumi.set(__self__, "group_interval", group_interval)
        pulumi.set(__self__, "group_wait_time", group_wait_time)
        pulumi.set(__self__, "grouping_fields", grouping_fields)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> pulumi.Input[int]:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_interval")

    @group_interval.setter
    def group_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "group_interval", value)

    @property
    @pulumi.getter(name="groupWaitTime")
    def group_wait_time(self) -> pulumi.Input[int]:
        """
        The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
        """
        return pulumi.get(self, "group_wait_time")

    @group_wait_time.setter
    def group_wait_time(self, value: pulumi.Input[int]):
        pulumi.set(self, "group_wait_time", value)

    @property
    @pulumi.getter(name="groupingFields")
    def grouping_fields(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
        """
        return pulumi.get(self, "grouping_fields")

    @grouping_fields.setter
    def grouping_fields(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "grouping_fields", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group rule.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared. The minimum value is 61. Default to 600.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "repeat_interval", value)


@pulumi.input_type
class DispatchRuleLabelMatchExpressionGridArgs:
    def __init__(__self__, *,
                 label_match_expression_groups: pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs']]] label_match_expression_groups: Sets the dispatch rule. See `label_match_expression_groups` below.
        """
        pulumi.set(__self__, "label_match_expression_groups", label_match_expression_groups)

    @property
    @pulumi.getter(name="labelMatchExpressionGroups")
    def label_match_expression_groups(self) -> pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs']]]:
        """
        Sets the dispatch rule. See `label_match_expression_groups` below.
        """
        return pulumi.get(self, "label_match_expression_groups")

    @label_match_expression_groups.setter
    def label_match_expression_groups(self, value: pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs']]]):
        pulumi.set(self, "label_match_expression_groups", value)


@pulumi.input_type
class DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupArgs:
    def __init__(__self__, *,
                 label_match_expressions: pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs']]] label_match_expressions: Sets the dispatch rule. See `label_match_expressions` below.
        """
        pulumi.set(__self__, "label_match_expressions", label_match_expressions)

    @property
    @pulumi.getter(name="labelMatchExpressions")
    def label_match_expressions(self) -> pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs']]]:
        """
        Sets the dispatch rule. See `label_match_expressions` below.
        """
        return pulumi.get(self, "label_match_expressions")

    @label_match_expressions.setter
    def label_match_expressions(self, value: pulumi.Input[Sequence[pulumi.Input['DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs']]]):
        pulumi.set(self, "label_match_expressions", value)


@pulumi.input_type
class DispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the tag of the dispatch rule. Valid values:
               * _aliyun_arms_userid: user ID
               * _aliyun_arms_involvedObject_kind: type of the associated object
               * _aliyun_arms_involvedObject_id: ID of the associated object
               * _aliyun_arms_involvedObject_name: name of the associated object
               * _aliyun_arms_alert_name: alert name
               * _aliyun_arms_alert_rule_id: alert rule ID
               * _aliyun_arms_alert_type: alert type
               * _aliyun_arms_alert_level: alert severity
        :param pulumi.Input[str] operator: The operator used in the dispatch rule. Valid values: 
               * eq: equals to.
               * re: matches a regular expression.
        :param pulumi.Input[str] value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the tag of the dispatch rule. Valid values:
        * _aliyun_arms_userid: user ID
        * _aliyun_arms_involvedObject_kind: type of the associated object
        * _aliyun_arms_involvedObject_id: ID of the associated object
        * _aliyun_arms_involvedObject_name: name of the associated object
        * _aliyun_arms_alert_name: alert name
        * _aliyun_arms_alert_rule_id: alert rule ID
        * _aliyun_arms_alert_type: alert type
        * _aliyun_arms_alert_level: alert severity
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator used in the dispatch rule. Valid values: 
        * eq: equals to.
        * re: matches a regular expression.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DispatchRuleNotifyRuleArgs:
    def __init__(__self__, *,
                 notify_channels: pulumi.Input[Sequence[pulumi.Input[str]]],
                 notify_objects: pulumi.Input[Sequence[pulumi.Input['DispatchRuleNotifyRuleNotifyObjectArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_channels: The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
        :param pulumi.Input[Sequence[pulumi.Input['DispatchRuleNotifyRuleNotifyObjectArgs']]] notify_objects: Sets the notification object. See `notify_objects` below.
        """
        pulumi.set(__self__, "notify_channels", notify_channels)
        pulumi.set(__self__, "notify_objects", notify_objects)

    @property
    @pulumi.getter(name="notifyChannels")
    def notify_channels(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
        """
        return pulumi.get(self, "notify_channels")

    @notify_channels.setter
    def notify_channels(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "notify_channels", value)

    @property
    @pulumi.getter(name="notifyObjects")
    def notify_objects(self) -> pulumi.Input[Sequence[pulumi.Input['DispatchRuleNotifyRuleNotifyObjectArgs']]]:
        """
        Sets the notification object. See `notify_objects` below.
        """
        return pulumi.get(self, "notify_objects")

    @notify_objects.setter
    def notify_objects(self, value: pulumi.Input[Sequence[pulumi.Input['DispatchRuleNotifyRuleNotifyObjectArgs']]]):
        pulumi.set(self, "notify_objects", value)


@pulumi.input_type
class DispatchRuleNotifyRuleNotifyObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 notify_object_id: pulumi.Input[str],
                 notify_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the contact or contact group.
        :param pulumi.Input[str] notify_object_id: The ID of the contact or contact group.
        :param pulumi.Input[str] notify_type: The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notify_object_id", notify_object_id)
        pulumi.set(__self__, "notify_type", notify_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the contact or contact group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notifyObjectId")
    def notify_object_id(self) -> pulumi.Input[str]:
        """
        The ID of the contact or contact group.
        """
        return pulumi.get(self, "notify_object_id")

    @notify_object_id.setter
    def notify_object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "notify_object_id", value)

    @property
    @pulumi.getter(name="notifyType")
    def notify_type(self) -> pulumi.Input[str]:
        """
        The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
        """
        return pulumi.get(self, "notify_type")

    @notify_type.setter
    def notify_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "notify_type", value)


@pulumi.input_type
class PrometheusAlertRuleAnnotationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the annotation.
        :param pulumi.Input[str] value: The value of the annotation.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the annotation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the annotation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PrometheusAlertRuleLabelArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the label.
        :param pulumi.Input[str] value: The value of the label.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the label.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SyntheticTaskAvailableAssertionArgs:
    def __init__(__self__, *,
                 expect: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 type: pulumi.Input[str],
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expect: Expected value.
        :param pulumi.Input[str] operator: Condition: gt: greater than; gte: greater than or equal to; lt: less than; te: less than or equal to; eq: equal to; neq: not equal to; ctn: contains; nctn: does not contain; exist: exists; n_exist: does not exist; belong: belongs to; reg_match: regular matching.
        :param pulumi.Input[str] type: Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        :param pulumi.Input[str] target: Check the target. If the target is HttpResCode, HttpResBody, or httpressetime, you do not need to specify the target. If the target is HttpResHead, you need to specify the key in the header. If the target is HttpResHead, you need to use jsonPath.
        """
        pulumi.set(__self__, "expect", expect)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def expect(self) -> pulumi.Input[str]:
        """
        Expected value.
        """
        return pulumi.get(self, "expect")

    @expect.setter
    def expect(self, value: pulumi.Input[str]):
        pulumi.set(self, "expect", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Condition: gt: greater than; gte: greater than or equal to; lt: less than; te: less than or equal to; eq: equal to; neq: not equal to; ctn: contains; nctn: does not contain; exist: exists; n_exist: does not exist; belong: belongs to; reg_match: regular matching.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Check the target. If the target is HttpResCode, HttpResBody, or httpressetime, you do not need to specify the target. If the target is HttpResHead, you need to specify the key in the header. If the target is HttpResHead, you need to use jsonPath.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class SyntheticTaskCommonSettingArgs:
    def __init__(__self__, *,
                 custom_host: Optional[pulumi.Input['SyntheticTaskCommonSettingCustomHostArgs']] = None,
                 ip_type: Optional[pulumi.Input[int]] = None,
                 is_open_trace: Optional[pulumi.Input[bool]] = None,
                 monitor_samples: Optional[pulumi.Input[int]] = None,
                 trace_client_type: Optional[pulumi.Input[int]] = None,
                 xtrace_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SyntheticTaskCommonSettingCustomHostArgs'] custom_host: Custom host. See `custom_host` below.
        :param pulumi.Input[int] ip_type: IpType.
        :param pulumi.Input[bool] is_open_trace: Whether to enable link tracking.
        :param pulumi.Input[int] monitor_samples: Whether the monitoring samples are evenly distributed:
               - 0: No
               1: Yes.
        :param pulumi.Input[int] trace_client_type: Link trace client type:
               - 0:ARMS Agent
               - 1:OpenTelemetry
               - 2:Jaeger.
        :param pulumi.Input[str] xtrace_region: The link data is reported to the region.
        """
        if custom_host is not None:
            pulumi.set(__self__, "custom_host", custom_host)
        if ip_type is not None:
            pulumi.set(__self__, "ip_type", ip_type)
        if is_open_trace is not None:
            pulumi.set(__self__, "is_open_trace", is_open_trace)
        if monitor_samples is not None:
            pulumi.set(__self__, "monitor_samples", monitor_samples)
        if trace_client_type is not None:
            pulumi.set(__self__, "trace_client_type", trace_client_type)
        if xtrace_region is not None:
            pulumi.set(__self__, "xtrace_region", xtrace_region)

    @property
    @pulumi.getter(name="customHost")
    def custom_host(self) -> Optional[pulumi.Input['SyntheticTaskCommonSettingCustomHostArgs']]:
        """
        Custom host. See `custom_host` below.
        """
        return pulumi.get(self, "custom_host")

    @custom_host.setter
    def custom_host(self, value: Optional[pulumi.Input['SyntheticTaskCommonSettingCustomHostArgs']]):
        pulumi.set(self, "custom_host", value)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> Optional[pulumi.Input[int]]:
        """
        IpType.
        """
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ip_type", value)

    @property
    @pulumi.getter(name="isOpenTrace")
    def is_open_trace(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable link tracking.
        """
        return pulumi.get(self, "is_open_trace")

    @is_open_trace.setter
    def is_open_trace(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_open_trace", value)

    @property
    @pulumi.getter(name="monitorSamples")
    def monitor_samples(self) -> Optional[pulumi.Input[int]]:
        """
        Whether the monitoring samples are evenly distributed:
        - 0: No
        1: Yes.
        """
        return pulumi.get(self, "monitor_samples")

    @monitor_samples.setter
    def monitor_samples(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_samples", value)

    @property
    @pulumi.getter(name="traceClientType")
    def trace_client_type(self) -> Optional[pulumi.Input[int]]:
        """
        Link trace client type:
        - 0:ARMS Agent
        - 1:OpenTelemetry
        - 2:Jaeger.
        """
        return pulumi.get(self, "trace_client_type")

    @trace_client_type.setter
    def trace_client_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "trace_client_type", value)

    @property
    @pulumi.getter(name="xtraceRegion")
    def xtrace_region(self) -> Optional[pulumi.Input[str]]:
        """
        The link data is reported to the region.
        """
        return pulumi.get(self, "xtrace_region")

    @xtrace_region.setter
    def xtrace_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "xtrace_region", value)


@pulumi.input_type
class SyntheticTaskCommonSettingCustomHostArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input['SyntheticTaskCommonSettingCustomHostHostArgs']]],
                 select_type: pulumi.Input[int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticTaskCommonSettingCustomHostHostArgs']]] hosts: The host list. See `hosts` below.
        :param pulumi.Input[int] select_type: Selection method:
               - 0: Random
               - 1: Polling.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "select_type", select_type)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input['SyntheticTaskCommonSettingCustomHostHostArgs']]]:
        """
        The host list. See `hosts` below.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input['SyntheticTaskCommonSettingCustomHostHostArgs']]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="selectType")
    def select_type(self) -> pulumi.Input[int]:
        """
        Selection method:
        - 0: Random
        - 1: Polling.
        """
        return pulumi.get(self, "select_type")

    @select_type.setter
    def select_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "select_type", value)


@pulumi.input_type
class SyntheticTaskCommonSettingCustomHostHostArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 ip_type: pulumi.Input[int],
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] domain: Domain Name.
        :param pulumi.Input[int] ip_type: IpType.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: The IP list.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "ip_type", ip_type)
        pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Domain Name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> pulumi.Input[int]:
        """
        IpType.
        """
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "ip_type", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The IP list.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)


@pulumi.input_type
class SyntheticTaskCustomPeriodArgs:
    def __init__(__self__, *,
                 end_hour: Optional[pulumi.Input[int]] = None,
                 start_hour: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] end_hour: End hours, 0-24.
        :param pulumi.Input[int] start_hour: Starting hours, 0-24.
        """
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[pulumi.Input[int]]:
        """
        End hours, 0-24.
        """
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Starting hours, 0-24.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_hour", value)


@pulumi.input_type
class SyntheticTaskMonitorArgs:
    def __init__(__self__, *,
                 city_code: pulumi.Input[str],
                 client_type: pulumi.Input[int],
                 operator_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] city_code: The city code of monitor.
        :param pulumi.Input[int] client_type: The type of monitor.
        :param pulumi.Input[str] operator_code: The operator code of monitor.
        """
        pulumi.set(__self__, "city_code", city_code)
        pulumi.set(__self__, "client_type", client_type)
        pulumi.set(__self__, "operator_code", operator_code)

    @property
    @pulumi.getter(name="cityCode")
    def city_code(self) -> pulumi.Input[str]:
        """
        The city code of monitor.
        """
        return pulumi.get(self, "city_code")

    @city_code.setter
    def city_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "city_code", value)

    @property
    @pulumi.getter(name="clientType")
    def client_type(self) -> pulumi.Input[int]:
        """
        The type of monitor.
        """
        return pulumi.get(self, "client_type")

    @client_type.setter
    def client_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "client_type", value)

    @property
    @pulumi.getter(name="operatorCode")
    def operator_code(self) -> pulumi.Input[str]:
        """
        The operator code of monitor.
        """
        return pulumi.get(self, "operator_code")

    @operator_code.setter
    def operator_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_code", value)


@pulumi.input_type
class SyntheticTaskMonitorConfArgs:
    def __init__(__self__, *,
                 api_http: Optional[pulumi.Input['SyntheticTaskMonitorConfApiHttpArgs']] = None,
                 file_download: Optional[pulumi.Input['SyntheticTaskMonitorConfFileDownloadArgs']] = None,
                 net_dns: Optional[pulumi.Input['SyntheticTaskMonitorConfNetDnsArgs']] = None,
                 net_icmp: Optional[pulumi.Input['SyntheticTaskMonitorConfNetIcmpArgs']] = None,
                 net_tcp: Optional[pulumi.Input['SyntheticTaskMonitorConfNetTcpArgs']] = None,
                 stream: Optional[pulumi.Input['SyntheticTaskMonitorConfStreamArgs']] = None,
                 website: Optional[pulumi.Input['SyntheticTaskMonitorConfWebsiteArgs']] = None):
        """
        :param pulumi.Input['SyntheticTaskMonitorConfApiHttpArgs'] api_http: HTTP(S) task configuration information. See `api_http` below.
        :param pulumi.Input['SyntheticTaskMonitorConfFileDownloadArgs'] file_download: File download type task configuration. See `file_download` below.
        :param pulumi.Input['SyntheticTaskMonitorConfNetDnsArgs'] net_dns: The configuration parameters of the DNS dial test. Required when TaskType is 3. See `net_dns` below.
        :param pulumi.Input['SyntheticTaskMonitorConfNetIcmpArgs'] net_icmp: ICMP dialing configuration parameters. Required when TaskType is 1. See `net_icmp` below.
        :param pulumi.Input['SyntheticTaskMonitorConfNetTcpArgs'] net_tcp: The configuration parameters of TCP dial test. Required when TaskType is 2. See `net_tcp` below.
        :param pulumi.Input['SyntheticTaskMonitorConfStreamArgs'] stream: Streaming Media Dial Test Configuration. See `stream` below.
        :param pulumi.Input['SyntheticTaskMonitorConfWebsiteArgs'] website: Website speed measurement type task configuration. See `website` below.
        """
        if api_http is not None:
            pulumi.set(__self__, "api_http", api_http)
        if file_download is not None:
            pulumi.set(__self__, "file_download", file_download)
        if net_dns is not None:
            pulumi.set(__self__, "net_dns", net_dns)
        if net_icmp is not None:
            pulumi.set(__self__, "net_icmp", net_icmp)
        if net_tcp is not None:
            pulumi.set(__self__, "net_tcp", net_tcp)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if website is not None:
            pulumi.set(__self__, "website", website)

    @property
    @pulumi.getter(name="apiHttp")
    def api_http(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfApiHttpArgs']]:
        """
        HTTP(S) task configuration information. See `api_http` below.
        """
        return pulumi.get(self, "api_http")

    @api_http.setter
    def api_http(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfApiHttpArgs']]):
        pulumi.set(self, "api_http", value)

    @property
    @pulumi.getter(name="fileDownload")
    def file_download(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfFileDownloadArgs']]:
        """
        File download type task configuration. See `file_download` below.
        """
        return pulumi.get(self, "file_download")

    @file_download.setter
    def file_download(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfFileDownloadArgs']]):
        pulumi.set(self, "file_download", value)

    @property
    @pulumi.getter(name="netDns")
    def net_dns(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfNetDnsArgs']]:
        """
        The configuration parameters of the DNS dial test. Required when TaskType is 3. See `net_dns` below.
        """
        return pulumi.get(self, "net_dns")

    @net_dns.setter
    def net_dns(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfNetDnsArgs']]):
        pulumi.set(self, "net_dns", value)

    @property
    @pulumi.getter(name="netIcmp")
    def net_icmp(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfNetIcmpArgs']]:
        """
        ICMP dialing configuration parameters. Required when TaskType is 1. See `net_icmp` below.
        """
        return pulumi.get(self, "net_icmp")

    @net_icmp.setter
    def net_icmp(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfNetIcmpArgs']]):
        pulumi.set(self, "net_icmp", value)

    @property
    @pulumi.getter(name="netTcp")
    def net_tcp(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfNetTcpArgs']]:
        """
        The configuration parameters of TCP dial test. Required when TaskType is 2. See `net_tcp` below.
        """
        return pulumi.get(self, "net_tcp")

    @net_tcp.setter
    def net_tcp(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfNetTcpArgs']]):
        pulumi.set(self, "net_tcp", value)

    @property
    @pulumi.getter
    def stream(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfStreamArgs']]:
        """
        Streaming Media Dial Test Configuration. See `stream` below.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfStreamArgs']]):
        pulumi.set(self, "stream", value)

    @property
    @pulumi.getter
    def website(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfWebsiteArgs']]:
        """
        Website speed measurement type task configuration. See `website` below.
        """
        return pulumi.get(self, "website")

    @website.setter
    def website(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfWebsiteArgs']]):
        pulumi.set(self, "website", value)


@pulumi.input_type
class SyntheticTaskMonitorConfApiHttpArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input[str],
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 request_body: Optional[pulumi.Input['SyntheticTaskMonitorConfApiHttpRequestBodyArgs']] = None,
                 request_headers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[int] connect_timeout: Connection timeout, in ms. Default 5000. Optional range: 1000-300000ms.
        :param pulumi.Input[str] method: HTTP method, GET or POST.
        :param pulumi.Input['SyntheticTaskMonitorConfApiHttpRequestBodyArgs'] request_body: HTTP request body. See `request_body` below.
        :param pulumi.Input[Mapping[str, Any]] request_headers: HTTP request header.
        :param pulumi.Input[int] timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Connection timeout, in ms. Default 5000. Optional range: 1000-300000ms.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP method, GET or POST.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[pulumi.Input['SyntheticTaskMonitorConfApiHttpRequestBodyArgs']]:
        """
        HTTP request body. See `request_body` below.
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[pulumi.Input['SyntheticTaskMonitorConfApiHttpRequestBodyArgs']]):
        pulumi.set(self, "request_body", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        HTTP request header.
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class SyntheticTaskMonitorConfApiHttpRequestBodyArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The request body content, in JSON string format. When the type is text/plain,application/json,application/xml,text/html, the content can be converted to a JSON string.
        :param pulumi.Input[str] type: Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        The request body content, in JSON string format. When the type is text/plain,application/json,application/xml,text/html, the content can be converted to a JSON string.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Assertion type, including: httpresead, httpresead, HttpResBody, HttpResBodyJson, httpressetime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet delay ms), icmppackwebscreen, fmppackavglatency (average delay rendering), TraceRouteHops (number of hops), dnsarecname, websiteOnload (full load time), see the supplement below for specific use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SyntheticTaskMonitorConfFileDownloadArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input[str],
                 connection_timeout: Optional[pulumi.Input[int]] = None,
                 custom_header_content: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 download_kernel: Optional[pulumi.Input[int]] = None,
                 ignore_certificate_auth_error: Optional[pulumi.Input[int]] = None,
                 ignore_certificate_canceled_error: Optional[pulumi.Input[int]] = None,
                 ignore_certificate_out_of_date_error: Optional[pulumi.Input[int]] = None,
                 ignore_certificate_status_error: Optional[pulumi.Input[int]] = None,
                 ignore_certificate_untrustworthy_error: Optional[pulumi.Input[int]] = None,
                 ignore_certificate_using_error: Optional[pulumi.Input[int]] = None,
                 ignore_invalid_host_error: Optional[pulumi.Input[int]] = None,
                 monitor_timeout: Optional[pulumi.Input[int]] = None,
                 quick_protocol: Optional[pulumi.Input[int]] = None,
                 redirection: Optional[pulumi.Input[int]] = None,
                 transmission_size: Optional[pulumi.Input[int]] = None,
                 validate_keywords: Optional[pulumi.Input[str]] = None,
                 verify_way: Optional[pulumi.Input[int]] = None,
                 white_list: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[int] connection_timeout: Connection timeout time, in ms. Default 5000. Optional range: 1000-120000ms.
        :param pulumi.Input[Mapping[str, Any]] custom_header_content: Custom header, in JSON Map format.
        :param pulumi.Input[int] download_kernel: Download the kernel.
               - 1:curl
               - 0:WinInet
               Default 1.
        :param pulumi.Input[int] ignore_certificate_auth_error: Ignore CA Certificate authorization error 0: Do not ignore, 1: ignore, default 1.
        :param pulumi.Input[int] ignore_certificate_canceled_error: Ignore certificate revocation error 0: Do not ignore, 1: ignore, default 1.
        :param pulumi.Input[int] ignore_certificate_out_of_date_error: Ignore certificate expiration error 0: not ignored, 1: Ignored, default 1.
        :param pulumi.Input[int] ignore_certificate_status_error: The certificate status error is ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        :param pulumi.Input[int] ignore_certificate_untrustworthy_error: The certificate cannot be trusted and ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        :param pulumi.Input[int] ignore_certificate_using_error: Ignore certificate usage error 0: Do not ignore, 1: ignore, default 1.
        :param pulumi.Input[int] ignore_invalid_host_error: Invalid host error ignored, 0: not ignored, 1: Ignored, default 1.
        :param pulumi.Input[int] monitor_timeout: Monitoring timeout, in ms. Not required, 20000 by default.
        :param pulumi.Input[int] quick_protocol: Quick agreement
               - 1:http1
               - 2:http2
               - 3:http3
               Default 1.
        :param pulumi.Input[int] redirection: When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        :param pulumi.Input[int] transmission_size: The transmission size, in KB. The default value is 2048KB. The transmission size of the downloaded file must be between 1 and 20480KB.
        :param pulumi.Input[str] validate_keywords: Verify keywords.
        :param pulumi.Input[int] verify_way: The verification method.
               - 0: Do not validate
               - 1: Validation string
               - 2:MD5 validation.
        :param pulumi.Input[str] white_list: DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if download_kernel is not None:
            pulumi.set(__self__, "download_kernel", download_kernel)
        if ignore_certificate_auth_error is not None:
            pulumi.set(__self__, "ignore_certificate_auth_error", ignore_certificate_auth_error)
        if ignore_certificate_canceled_error is not None:
            pulumi.set(__self__, "ignore_certificate_canceled_error", ignore_certificate_canceled_error)
        if ignore_certificate_out_of_date_error is not None:
            pulumi.set(__self__, "ignore_certificate_out_of_date_error", ignore_certificate_out_of_date_error)
        if ignore_certificate_status_error is not None:
            pulumi.set(__self__, "ignore_certificate_status_error", ignore_certificate_status_error)
        if ignore_certificate_untrustworthy_error is not None:
            pulumi.set(__self__, "ignore_certificate_untrustworthy_error", ignore_certificate_untrustworthy_error)
        if ignore_certificate_using_error is not None:
            pulumi.set(__self__, "ignore_certificate_using_error", ignore_certificate_using_error)
        if ignore_invalid_host_error is not None:
            pulumi.set(__self__, "ignore_invalid_host_error", ignore_invalid_host_error)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if quick_protocol is not None:
            pulumi.set(__self__, "quick_protocol", quick_protocol)
        if redirection is not None:
            pulumi.set(__self__, "redirection", redirection)
        if transmission_size is not None:
            pulumi.set(__self__, "transmission_size", transmission_size)
        if validate_keywords is not None:
            pulumi.set(__self__, "validate_keywords", validate_keywords)
        if verify_way is not None:
            pulumi.set(__self__, "verify_way", verify_way)
        if white_list is not None:
            pulumi.set(__self__, "white_list", white_list)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Connection timeout time, in ms. Default 5000. Optional range: 1000-120000ms.
        """
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connection_timeout", value)

    @property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @custom_header_content.setter
    def custom_header_content(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_header_content", value)

    @property
    @pulumi.getter(name="downloadKernel")
    def download_kernel(self) -> Optional[pulumi.Input[int]]:
        """
        Download the kernel.
        - 1:curl
        - 0:WinInet
        Default 1.
        """
        return pulumi.get(self, "download_kernel")

    @download_kernel.setter
    def download_kernel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "download_kernel", value)

    @property
    @pulumi.getter(name="ignoreCertificateAuthError")
    def ignore_certificate_auth_error(self) -> Optional[pulumi.Input[int]]:
        """
        Ignore CA Certificate authorization error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_auth_error")

    @ignore_certificate_auth_error.setter
    def ignore_certificate_auth_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_auth_error", value)

    @property
    @pulumi.getter(name="ignoreCertificateCanceledError")
    def ignore_certificate_canceled_error(self) -> Optional[pulumi.Input[int]]:
        """
        Ignore certificate revocation error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_canceled_error")

    @ignore_certificate_canceled_error.setter
    def ignore_certificate_canceled_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_canceled_error", value)

    @property
    @pulumi.getter(name="ignoreCertificateOutOfDateError")
    def ignore_certificate_out_of_date_error(self) -> Optional[pulumi.Input[int]]:
        """
        Ignore certificate expiration error 0: not ignored, 1: Ignored, default 1.
        """
        return pulumi.get(self, "ignore_certificate_out_of_date_error")

    @ignore_certificate_out_of_date_error.setter
    def ignore_certificate_out_of_date_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_out_of_date_error", value)

    @property
    @pulumi.getter(name="ignoreCertificateStatusError")
    def ignore_certificate_status_error(self) -> Optional[pulumi.Input[int]]:
        """
        The certificate status error is ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_status_error")

    @ignore_certificate_status_error.setter
    def ignore_certificate_status_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_status_error", value)

    @property
    @pulumi.getter(name="ignoreCertificateUntrustworthyError")
    def ignore_certificate_untrustworthy_error(self) -> Optional[pulumi.Input[int]]:
        """
        The certificate cannot be trusted and ignored. 0: Do not ignore, 1: IGNORE. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_untrustworthy_error")

    @ignore_certificate_untrustworthy_error.setter
    def ignore_certificate_untrustworthy_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_untrustworthy_error", value)

    @property
    @pulumi.getter(name="ignoreCertificateUsingError")
    def ignore_certificate_using_error(self) -> Optional[pulumi.Input[int]]:
        """
        Ignore certificate usage error 0: Do not ignore, 1: ignore, default 1.
        """
        return pulumi.get(self, "ignore_certificate_using_error")

    @ignore_certificate_using_error.setter
    def ignore_certificate_using_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_using_error", value)

    @property
    @pulumi.getter(name="ignoreInvalidHostError")
    def ignore_invalid_host_error(self) -> Optional[pulumi.Input[int]]:
        """
        Invalid host error ignored, 0: not ignored, 1: Ignored, default 1.
        """
        return pulumi.get(self, "ignore_invalid_host_error")

    @ignore_invalid_host_error.setter
    def ignore_invalid_host_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_invalid_host_error", value)

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Monitoring timeout, in ms. Not required, 20000 by default.
        """
        return pulumi.get(self, "monitor_timeout")

    @monitor_timeout.setter
    def monitor_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_timeout", value)

    @property
    @pulumi.getter(name="quickProtocol")
    def quick_protocol(self) -> Optional[pulumi.Input[int]]:
        """
        Quick agreement
        - 1:http1
        - 2:http2
        - 3:http3
        Default 1.
        """
        return pulumi.get(self, "quick_protocol")

    @quick_protocol.setter
    def quick_protocol(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quick_protocol", value)

    @property
    @pulumi.getter
    def redirection(self) -> Optional[pulumi.Input[int]]:
        """
        When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        """
        return pulumi.get(self, "redirection")

    @redirection.setter
    def redirection(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redirection", value)

    @property
    @pulumi.getter(name="transmissionSize")
    def transmission_size(self) -> Optional[pulumi.Input[int]]:
        """
        The transmission size, in KB. The default value is 2048KB. The transmission size of the downloaded file must be between 1 and 20480KB.
        """
        return pulumi.get(self, "transmission_size")

    @transmission_size.setter
    def transmission_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transmission_size", value)

    @property
    @pulumi.getter(name="validateKeywords")
    def validate_keywords(self) -> Optional[pulumi.Input[str]]:
        """
        Verify keywords.
        """
        return pulumi.get(self, "validate_keywords")

    @validate_keywords.setter
    def validate_keywords(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validate_keywords", value)

    @property
    @pulumi.getter(name="verifyWay")
    def verify_way(self) -> Optional[pulumi.Input[int]]:
        """
        The verification method.
        - 0: Do not validate
        - 1: Validation string
        - 2:MD5 validation.
        """
        return pulumi.get(self, "verify_way")

    @verify_way.setter
    def verify_way(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "verify_way", value)

    @property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> Optional[pulumi.Input[str]]:
        """
        DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "white_list")

    @white_list.setter
    def white_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "white_list", value)


@pulumi.input_type
class SyntheticTaskMonitorConfNetDnsArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input[str],
                 dns_server_ip_type: Optional[pulumi.Input[int]] = None,
                 ns_server: Optional[pulumi.Input[str]] = None,
                 query_method: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[int] dns_server_ip_type: The IP address type of the DNS server.
               - 0 (default):ipv4
               - 1:ipv6
               2: Automatic.
        :param pulumi.Input[str] ns_server: The IP address of the NS server. The default value is 114.114.114.114.
        :param pulumi.Input[int] query_method: DNS query method.
               - 0 (default): Recursive
               - 1: Iteration.
        :param pulumi.Input[int] timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if dns_server_ip_type is not None:
            pulumi.set(__self__, "dns_server_ip_type", dns_server_ip_type)
        if ns_server is not None:
            pulumi.set(__self__, "ns_server", ns_server)
        if query_method is not None:
            pulumi.set(__self__, "query_method", query_method)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="dnsServerIpType")
    def dns_server_ip_type(self) -> Optional[pulumi.Input[int]]:
        """
        The IP address type of the DNS server.
        - 0 (default):ipv4
        - 1:ipv6
        2: Automatic.
        """
        return pulumi.get(self, "dns_server_ip_type")

    @dns_server_ip_type.setter
    def dns_server_ip_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dns_server_ip_type", value)

    @property
    @pulumi.getter(name="nsServer")
    def ns_server(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the NS server. The default value is 114.114.114.114.
        """
        return pulumi.get(self, "ns_server")

    @ns_server.setter
    def ns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ns_server", value)

    @property
    @pulumi.getter(name="queryMethod")
    def query_method(self) -> Optional[pulumi.Input[int]]:
        """
        DNS query method.
        - 0 (default): Recursive
        - 1: Iteration.
        """
        return pulumi.get(self, "query_method")

    @query_method.setter
    def query_method(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_method", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class SyntheticTaskMonitorConfNetIcmpArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 package_num: Optional[pulumi.Input[int]] = None,
                 package_size: Optional[pulumi.Input[int]] = None,
                 split_package: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 tracert_enable: Optional[pulumi.Input[bool]] = None,
                 tracert_num_max: Optional[pulumi.Input[int]] = None,
                 tracert_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[int] interval: The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        :param pulumi.Input[int] package_num: Number of ICMP(Ping) packets sent. The minimum value is 1, the maximum value is 50, and the default is 4.
        :param pulumi.Input[int] package_size: The size of the sent ICMP(Ping) packet. The unit is byte. The ICMP(PING) packet size is limited to 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        :param pulumi.Input[bool] split_package: Whether to split ICMP(Ping) packets. The default is true.
        :param pulumi.Input[int] timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        :param pulumi.Input[bool] tracert_enable: Whether to enable tracert. The default is true.
        :param pulumi.Input[int] tracert_num_max: The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        :param pulumi.Input[int] tracert_timeout: The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if package_num is not None:
            pulumi.set(__self__, "package_num", package_num)
        if package_size is not None:
            pulumi.set(__self__, "package_size", package_size)
        if split_package is not None:
            pulumi.set(__self__, "split_package", split_package)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracert_enable is not None:
            pulumi.set(__self__, "tracert_enable", tracert_enable)
        if tracert_num_max is not None:
            pulumi.set(__self__, "tracert_num_max", tracert_num_max)
        if tracert_timeout is not None:
            pulumi.set(__self__, "tracert_timeout", tracert_timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="packageNum")
    def package_num(self) -> Optional[pulumi.Input[int]]:
        """
        Number of ICMP(Ping) packets sent. The minimum value is 1, the maximum value is 50, and the default is 4.
        """
        return pulumi.get(self, "package_num")

    @package_num.setter
    def package_num(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "package_num", value)

    @property
    @pulumi.getter(name="packageSize")
    def package_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the sent ICMP(Ping) packet. The unit is byte. The ICMP(PING) packet size is limited to 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        """
        return pulumi.get(self, "package_size")

    @package_size.setter
    def package_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "package_size", value)

    @property
    @pulumi.getter(name="splitPackage")
    def split_package(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to split ICMP(Ping) packets. The default is true.
        """
        return pulumi.get(self, "split_package")

    @split_package.setter
    def split_package(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "split_package", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tracertEnable")
    def tracert_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable tracert. The default is true.
        """
        return pulumi.get(self, "tracert_enable")

    @tracert_enable.setter
    def tracert_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tracert_enable", value)

    @property
    @pulumi.getter(name="tracertNumMax")
    def tracert_num_max(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        """
        return pulumi.get(self, "tracert_num_max")

    @tracert_num_max.setter
    def tracert_num_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tracert_num_max", value)

    @property
    @pulumi.getter(name="tracertTimeout")
    def tracert_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        return pulumi.get(self, "tracert_timeout")

    @tracert_timeout.setter
    def tracert_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tracert_timeout", value)


@pulumi.input_type
class SyntheticTaskMonitorConfNetTcpArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input[str],
                 connect_times: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 tracert_enable: Optional[pulumi.Input[bool]] = None,
                 tracert_num_max: Optional[pulumi.Input[int]] = None,
                 tracert_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[int] connect_times: The number of TCP connections established. The minimum value is 1, the maximum value is 16, and the default is 4.
        :param pulumi.Input[int] interval: The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        :param pulumi.Input[int] timeout: TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        :param pulumi.Input[bool] tracert_enable: Whether to enable tracert. The default is true.
        :param pulumi.Input[int] tracert_num_max: The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        :param pulumi.Input[int] tracert_timeout: The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        pulumi.set(__self__, "target_url", target_url)
        if connect_times is not None:
            pulumi.set(__self__, "connect_times", connect_times)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracert_enable is not None:
            pulumi.set(__self__, "tracert_enable", tracert_enable)
        if tracert_num_max is not None:
            pulumi.set(__self__, "tracert_num_max", tracert_num_max)
        if tracert_timeout is not None:
            pulumi.set(__self__, "tracert_timeout", tracert_timeout)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="connectTimes")
    def connect_times(self) -> Optional[pulumi.Input[int]]:
        """
        The number of TCP connections established. The minimum value is 1, the maximum value is 16, and the default is 4.
        """
        return pulumi.get(self, "connect_times")

    @connect_times.setter
    def connect_times(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_times", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The interval between TCP connections. The unit is milliseconds (ms), the minimum value is 200, the maximum value is 10000, and the default value is 200.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        TCP dial test timeout. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 20000.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="tracertEnable")
    def tracert_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable tracert. The default is true.
        """
        return pulumi.get(self, "tracert_enable")

    @tracert_enable.setter
    def tracert_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tracert_enable", value)

    @property
    @pulumi.getter(name="tracertNumMax")
    def tracert_num_max(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of hops for tracert. The minimum value is 1, the maximum value is 128, and the default value is 20.
        """
        return pulumi.get(self, "tracert_num_max")

    @tracert_num_max.setter
    def tracert_num_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tracert_num_max", value)

    @property
    @pulumi.getter(name="tracertTimeout")
    def tracert_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The time-out of tracert. The unit is milliseconds (ms), the minimum value is 1000, the maximum value is 300000, and the default value is 60000.
        """
        return pulumi.get(self, "tracert_timeout")

    @tracert_timeout.setter
    def tracert_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tracert_timeout", value)


@pulumi.input_type
class SyntheticTaskMonitorConfStreamArgs:
    def __init__(__self__, *,
                 custom_header_content: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 player_type: Optional[pulumi.Input[int]] = None,
                 stream_address_type: Optional[pulumi.Input[int]] = None,
                 stream_monitor_timeout: Optional[pulumi.Input[int]] = None,
                 stream_type: Optional[pulumi.Input[int]] = None,
                 target_url: Optional[pulumi.Input[str]] = None,
                 white_list: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] custom_header_content: Custom header, in JSON Map format.
        :param pulumi.Input[int] player_type: Player, do not pass the default 12.
               - 12:VLC
               - 2:FlashPlayer.
        :param pulumi.Input[int] stream_address_type: Resource address type:
               - 1: Resource address.
               - 0: page address, not 0 by default.
        :param pulumi.Input[int] stream_monitor_timeout: Monitoring duration, in seconds, up to 60s, not 60 by default.
        :param pulumi.Input[int] stream_type: Audio and video flags: 0-video, 1-audio.
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[str] white_list: DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if player_type is not None:
            pulumi.set(__self__, "player_type", player_type)
        if stream_address_type is not None:
            pulumi.set(__self__, "stream_address_type", stream_address_type)
        if stream_monitor_timeout is not None:
            pulumi.set(__self__, "stream_monitor_timeout", stream_monitor_timeout)
        if stream_type is not None:
            pulumi.set(__self__, "stream_type", stream_type)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)
        if white_list is not None:
            pulumi.set(__self__, "white_list", white_list)

    @property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @custom_header_content.setter
    def custom_header_content(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_header_content", value)

    @property
    @pulumi.getter(name="playerType")
    def player_type(self) -> Optional[pulumi.Input[int]]:
        """
        Player, do not pass the default 12.
        - 12:VLC
        - 2:FlashPlayer.
        """
        return pulumi.get(self, "player_type")

    @player_type.setter
    def player_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "player_type", value)

    @property
    @pulumi.getter(name="streamAddressType")
    def stream_address_type(self) -> Optional[pulumi.Input[int]]:
        """
        Resource address type:
        - 1: Resource address.
        - 0: page address, not 0 by default.
        """
        return pulumi.get(self, "stream_address_type")

    @stream_address_type.setter
    def stream_address_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_address_type", value)

    @property
    @pulumi.getter(name="streamMonitorTimeout")
    def stream_monitor_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Monitoring duration, in seconds, up to 60s, not 60 by default.
        """
        return pulumi.get(self, "stream_monitor_timeout")

    @stream_monitor_timeout.setter
    def stream_monitor_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_monitor_timeout", value)

    @property
    @pulumi.getter(name="streamType")
    def stream_type(self) -> Optional[pulumi.Input[int]]:
        """
        Audio and video flags: 0-video, 1-audio.
        """
        return pulumi.get(self, "stream_type")

    @stream_type.setter
    def stream_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_type", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[pulumi.Input[str]]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> Optional[pulumi.Input[str]]:
        """
        DNS hijack whitelist. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "white_list")

    @white_list.setter
    def white_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "white_list", value)


@pulumi.input_type
class SyntheticTaskMonitorConfWebsiteArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input[str],
                 automatic_scrolling: Optional[pulumi.Input[int]] = None,
                 custom_header: Optional[pulumi.Input[int]] = None,
                 custom_header_content: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 disable_cache: Optional[pulumi.Input[int]] = None,
                 disable_compression: Optional[pulumi.Input[int]] = None,
                 dns_hijack_whitelist: Optional[pulumi.Input[str]] = None,
                 element_blacklist: Optional[pulumi.Input[str]] = None,
                 filter_invalid_ip: Optional[pulumi.Input[int]] = None,
                 flow_hijack_jump_times: Optional[pulumi.Input[int]] = None,
                 flow_hijack_logo: Optional[pulumi.Input[str]] = None,
                 ignore_certificate_error: Optional[pulumi.Input[int]] = None,
                 monitor_timeout: Optional[pulumi.Input[int]] = None,
                 page_tamper: Optional[pulumi.Input[str]] = None,
                 redirection: Optional[pulumi.Input[int]] = None,
                 slow_element_threshold: Optional[pulumi.Input[int]] = None,
                 verify_string_blacklist: Optional[pulumi.Input[str]] = None,
                 verify_string_whitelist: Optional[pulumi.Input[str]] = None,
                 wait_completion_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] target_url: The target URL.
        :param pulumi.Input[int] automatic_scrolling: Whether to support automatic scrolling screen, loading page.
               - 0 (default): No
               1: Yes.
        :param pulumi.Input[int] custom_header: Custom header.
               - 0 (default): Off
               - 1: Modify the first package
               - 2: Modify all packages.
        :param pulumi.Input[Mapping[str, Any]] custom_header_content: Custom header, in JSON Map format.
        :param pulumi.Input[int] disable_cache: Whether to disable caching.
               - 0: not disabled
               - 1 (default): Disabled.
        :param pulumi.Input[int] disable_compression: The Accept-Encoding field is used to determine whether to Accept compressed files. 0-do not disable, 1-disable, the default is 0.
        :param pulumi.Input[str] dns_hijack_whitelist: When a domain name (such as www.aliyun.com) is resolved, if the resolved IP address or CNAME is not in the DNS hijacking white list, the user will fail to access or return a target IP address that is not Aliyun. If the IP or CNAME in the resolution result is in the DNS white list, it will be determined that DNS hijacking has not occurred.  Fill in the format: Domain name: matching rules. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        :param pulumi.Input[str] element_blacklist: If an element configured in the element blacklist appears during page loading, the element is not requested to be loaded.
        :param pulumi.Input[int] filter_invalid_ip: Whether to filter invalid IP parameters. 0: filter, 1: do not filter. The default value is 0.
        :param pulumi.Input[int] flow_hijack_jump_times: Identify elements: Set the total number of elements on the Browse page.
        :param pulumi.Input[str] flow_hijack_logo: Hijacking ID: Set the matching key information. Enter the hijacking keyword or key element, with an asterisk (*) allowed.
        :param pulumi.Input[int] ignore_certificate_error: Whether to ignore certificate errors during certificate verification in SSL Handshake and continue browsing. 0-do not ignore, 1-ignore. The default value is 1.
        :param pulumi.Input[int] monitor_timeout: Monitoring timeout, in ms. Not required, 20000 by default.
        :param pulumi.Input[str] page_tamper: Monitoring the page appears to be tampered with elements other than the domain settings that belong to the page. Common manifestations are pop-up advertisements, floating advertisements, jumps, etc.  Fill in the format: Domain name: Element. You can fill multiple elements separated by a vertical bar (|). For example, www.aliyun.com:|/cc/bb/a.gif |/vv/bb/cc.jpg indicates that all the other elements of the www.aliyun.com domain name except the basic document,/cc/bb/a.gif, and/vv/bb/cc.jpg are tampered.
        :param pulumi.Input[int] redirection: When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        :param pulumi.Input[int] slow_element_threshold: The slow element threshold, in ms, is 5000 by default and can be selected from 1 to 300000ms.
        :param pulumi.Input[str] verify_string_blacklist: The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any of the blacklisted strings, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        :param pulumi.Input[str] verify_string_whitelist: The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist. Otherwise, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        :param pulumi.Input[int] wait_completion_time: The maximum waiting time, in ms, is 5000 by default and can be selected from 5000 ms to 300000ms.
        """
        pulumi.set(__self__, "target_url", target_url)
        if automatic_scrolling is not None:
            pulumi.set(__self__, "automatic_scrolling", automatic_scrolling)
        if custom_header is not None:
            pulumi.set(__self__, "custom_header", custom_header)
        if custom_header_content is not None:
            pulumi.set(__self__, "custom_header_content", custom_header_content)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_compression is not None:
            pulumi.set(__self__, "disable_compression", disable_compression)
        if dns_hijack_whitelist is not None:
            pulumi.set(__self__, "dns_hijack_whitelist", dns_hijack_whitelist)
        if element_blacklist is not None:
            pulumi.set(__self__, "element_blacklist", element_blacklist)
        if filter_invalid_ip is not None:
            pulumi.set(__self__, "filter_invalid_ip", filter_invalid_ip)
        if flow_hijack_jump_times is not None:
            pulumi.set(__self__, "flow_hijack_jump_times", flow_hijack_jump_times)
        if flow_hijack_logo is not None:
            pulumi.set(__self__, "flow_hijack_logo", flow_hijack_logo)
        if ignore_certificate_error is not None:
            pulumi.set(__self__, "ignore_certificate_error", ignore_certificate_error)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if page_tamper is not None:
            pulumi.set(__self__, "page_tamper", page_tamper)
        if redirection is not None:
            pulumi.set(__self__, "redirection", redirection)
        if slow_element_threshold is not None:
            pulumi.set(__self__, "slow_element_threshold", slow_element_threshold)
        if verify_string_blacklist is not None:
            pulumi.set(__self__, "verify_string_blacklist", verify_string_blacklist)
        if verify_string_whitelist is not None:
            pulumi.set(__self__, "verify_string_whitelist", verify_string_whitelist)
        if wait_completion_time is not None:
            pulumi.set(__self__, "wait_completion_time", wait_completion_time)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        """
        The target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="automaticScrolling")
    def automatic_scrolling(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to support automatic scrolling screen, loading page.
        - 0 (default): No
        1: Yes.
        """
        return pulumi.get(self, "automatic_scrolling")

    @automatic_scrolling.setter
    def automatic_scrolling(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "automatic_scrolling", value)

    @property
    @pulumi.getter(name="customHeader")
    def custom_header(self) -> Optional[pulumi.Input[int]]:
        """
        Custom header.
        - 0 (default): Off
        - 1: Modify the first package
        - 2: Modify all packages.
        """
        return pulumi.get(self, "custom_header")

    @custom_header.setter
    def custom_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_header", value)

    @property
    @pulumi.getter(name="customHeaderContent")
    def custom_header_content(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom header, in JSON Map format.
        """
        return pulumi.get(self, "custom_header_content")

    @custom_header_content.setter
    def custom_header_content(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_header_content", value)

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to disable caching.
        - 0: not disabled
        - 1 (default): Disabled.
        """
        return pulumi.get(self, "disable_cache")

    @disable_cache.setter
    def disable_cache(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disable_cache", value)

    @property
    @pulumi.getter(name="disableCompression")
    def disable_compression(self) -> Optional[pulumi.Input[int]]:
        """
        The Accept-Encoding field is used to determine whether to Accept compressed files. 0-do not disable, 1-disable, the default is 0.
        """
        return pulumi.get(self, "disable_compression")

    @disable_compression.setter
    def disable_compression(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disable_compression", value)

    @property
    @pulumi.getter(name="dnsHijackWhitelist")
    def dns_hijack_whitelist(self) -> Optional[pulumi.Input[str]]:
        """
        When a domain name (such as www.aliyun.com) is resolved, if the resolved IP address or CNAME is not in the DNS hijacking white list, the user will fail to access or return a target IP address that is not Aliyun. If the IP or CNAME in the resolution result is in the DNS white list, it will be determined that DNS hijacking has not occurred.  Fill in the format: Domain name: matching rules. Match rules support IP, IP wildcard, subnet mask, and CNAME. Multiple match rules can be filled in. Multiple match rules are separated by vertical bars (|). For example, www.aliyun.com:203.0.3.55 | 203.3.44.67 indicates that all other IP addresses under the www.aliyun.com domain except 203.0.3.55 and 203.3.44.67 are hijacked.
        """
        return pulumi.get(self, "dns_hijack_whitelist")

    @dns_hijack_whitelist.setter
    def dns_hijack_whitelist(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_hijack_whitelist", value)

    @property
    @pulumi.getter(name="elementBlacklist")
    def element_blacklist(self) -> Optional[pulumi.Input[str]]:
        """
        If an element configured in the element blacklist appears during page loading, the element is not requested to be loaded.
        """
        return pulumi.get(self, "element_blacklist")

    @element_blacklist.setter
    def element_blacklist(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "element_blacklist", value)

    @property
    @pulumi.getter(name="filterInvalidIp")
    def filter_invalid_ip(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to filter invalid IP parameters. 0: filter, 1: do not filter. The default value is 0.
        """
        return pulumi.get(self, "filter_invalid_ip")

    @filter_invalid_ip.setter
    def filter_invalid_ip(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "filter_invalid_ip", value)

    @property
    @pulumi.getter(name="flowHijackJumpTimes")
    def flow_hijack_jump_times(self) -> Optional[pulumi.Input[int]]:
        """
        Identify elements: Set the total number of elements on the Browse page.
        """
        return pulumi.get(self, "flow_hijack_jump_times")

    @flow_hijack_jump_times.setter
    def flow_hijack_jump_times(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flow_hijack_jump_times", value)

    @property
    @pulumi.getter(name="flowHijackLogo")
    def flow_hijack_logo(self) -> Optional[pulumi.Input[str]]:
        """
        Hijacking ID: Set the matching key information. Enter the hijacking keyword or key element, with an asterisk (*) allowed.
        """
        return pulumi.get(self, "flow_hijack_logo")

    @flow_hijack_logo.setter
    def flow_hijack_logo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flow_hijack_logo", value)

    @property
    @pulumi.getter(name="ignoreCertificateError")
    def ignore_certificate_error(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to ignore certificate errors during certificate verification in SSL Handshake and continue browsing. 0-do not ignore, 1-ignore. The default value is 1.
        """
        return pulumi.get(self, "ignore_certificate_error")

    @ignore_certificate_error.setter
    def ignore_certificate_error(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_certificate_error", value)

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Monitoring timeout, in ms. Not required, 20000 by default.
        """
        return pulumi.get(self, "monitor_timeout")

    @monitor_timeout.setter
    def monitor_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_timeout", value)

    @property
    @pulumi.getter(name="pageTamper")
    def page_tamper(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring the page appears to be tampered with elements other than the domain settings that belong to the page. Common manifestations are pop-up advertisements, floating advertisements, jumps, etc.  Fill in the format: Domain name: Element. You can fill multiple elements separated by a vertical bar (|). For example, www.aliyun.com:|/cc/bb/a.gif |/vv/bb/cc.jpg indicates that all the other elements of the www.aliyun.com domain name except the basic document,/cc/bb/a.gif, and/vv/bb/cc.jpg are tampered.
        """
        return pulumi.get(self, "page_tamper")

    @page_tamper.setter
    def page_tamper(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_tamper", value)

    @property
    @pulumi.getter
    def redirection(self) -> Optional[pulumi.Input[int]]:
        """
        When redirection occurs, whether to continue browsing, 0-No, 1-Yes, the default is 1.
        """
        return pulumi.get(self, "redirection")

    @redirection.setter
    def redirection(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redirection", value)

    @property
    @pulumi.getter(name="slowElementThreshold")
    def slow_element_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The slow element threshold, in ms, is 5000 by default and can be selected from 1 to 300000ms.
        """
        return pulumi.get(self, "slow_element_threshold")

    @slow_element_threshold.setter
    def slow_element_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slow_element_threshold", value)

    @property
    @pulumi.getter(name="verifyStringBlacklist")
    def verify_string_blacklist(self) -> Optional[pulumi.Input[str]]:
        """
        The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any of the blacklisted strings, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        """
        return pulumi.get(self, "verify_string_blacklist")

    @verify_string_blacklist.setter
    def verify_string_blacklist(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verify_string_blacklist", value)

    @property
    @pulumi.getter(name="verifyStringWhitelist")
    def verify_string_whitelist(self) -> Optional[pulumi.Input[str]]:
        """
        The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist. Otherwise, 650 error is returned. Multiple strings are separated by a vertical bar (|).
        """
        return pulumi.get(self, "verify_string_whitelist")

    @verify_string_whitelist.setter
    def verify_string_whitelist(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verify_string_whitelist", value)

    @property
    @pulumi.getter(name="waitCompletionTime")
    def wait_completion_time(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum waiting time, in ms, is 5000 by default and can be selected from 5000 ms to 300000ms.
        """
        return pulumi.get(self, "wait_completion_time")

    @wait_completion_time.setter
    def wait_completion_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_completion_time", value)


