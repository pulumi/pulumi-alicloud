# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'HttpRequestHeaderModificationRuleRequestHeaderModificationArgs',
    'HttpRequestHeaderModificationRuleRequestHeaderModificationArgsDict',
    'HttpResponseHeaderModificationRuleResponseHeaderModificationArgs',
    'HttpResponseHeaderModificationRuleResponseHeaderModificationArgsDict',
    'LoadBalancerAdaptiveRoutingArgs',
    'LoadBalancerAdaptiveRoutingArgsDict',
    'LoadBalancerMonitorArgs',
    'LoadBalancerMonitorArgsDict',
    'LoadBalancerRandomSteeringArgs',
    'LoadBalancerRandomSteeringArgsDict',
    'LoadBalancerRuleArgs',
    'LoadBalancerRuleArgsDict',
    'LoadBalancerRuleFixedResponseArgs',
    'LoadBalancerRuleFixedResponseArgsDict',
    'OriginPoolOriginArgs',
    'OriginPoolOriginArgsDict',
    'OriginPoolOriginAuthConfArgs',
    'OriginPoolOriginAuthConfArgsDict',
    'RecordAuthConfArgs',
    'RecordAuthConfArgsDict',
    'RecordDataArgs',
    'RecordDataArgsDict',
    'SiteDeliveryTaskHttpDeliveryArgs',
    'SiteDeliveryTaskHttpDeliveryArgsDict',
    'SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs',
    'SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict',
    'SiteDeliveryTaskKafkaDeliveryArgs',
    'SiteDeliveryTaskKafkaDeliveryArgsDict',
    'SiteDeliveryTaskOssDeliveryArgs',
    'SiteDeliveryTaskOssDeliveryArgsDict',
    'SiteDeliveryTaskS3DeliveryArgs',
    'SiteDeliveryTaskS3DeliveryArgsDict',
    'SiteDeliveryTaskSlsDeliveryArgs',
    'SiteDeliveryTaskSlsDeliveryArgsDict',
    'TransportLayerApplicationRuleArgs',
    'TransportLayerApplicationRuleArgsDict',
    'WafRuleConfigArgs',
    'WafRuleConfigArgsDict',
    'WafRuleConfigActionsArgs',
    'WafRuleConfigActionsArgsDict',
    'WafRuleConfigActionsBypassArgs',
    'WafRuleConfigActionsBypassArgsDict',
    'WafRuleConfigActionsResponseArgs',
    'WafRuleConfigActionsResponseArgsDict',
    'WafRuleConfigAppPackageArgs',
    'WafRuleConfigAppPackageArgsDict',
    'WafRuleConfigAppPackagePackageSignArgs',
    'WafRuleConfigAppPackagePackageSignArgsDict',
    'WafRuleConfigAppSdkArgs',
    'WafRuleConfigAppSdkArgsDict',
    'WafRuleConfigAppSdkCustomSignArgs',
    'WafRuleConfigAppSdkCustomSignArgsDict',
    'WafRuleConfigManagedRulesetArgs',
    'WafRuleConfigManagedRulesetArgsDict',
    'WafRuleConfigManagedRulesetManagedRuleArgs',
    'WafRuleConfigManagedRulesetManagedRuleArgsDict',
    'WafRuleConfigRateLimitArgs',
    'WafRuleConfigRateLimitArgsDict',
    'WafRuleConfigRateLimitCharacteristicsArgs',
    'WafRuleConfigRateLimitCharacteristicsArgsDict',
    'WafRuleConfigRateLimitCharacteristicsCriteriaArgs',
    'WafRuleConfigRateLimitCharacteristicsCriteriaArgsDict',
    'WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgs',
    'WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgsDict',
    'WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgs',
    'WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgsDict',
    'WafRuleConfigRateLimitThresholdArgs',
    'WafRuleConfigRateLimitThresholdArgsDict',
    'WafRuleConfigRateLimitThresholdResponseStatusArgs',
    'WafRuleConfigRateLimitThresholdResponseStatusArgsDict',
    'WafRuleConfigSecurityLevelArgs',
    'WafRuleConfigSecurityLevelArgsDict',
    'WafRuleConfigTimerArgs',
    'WafRuleConfigTimerArgsDict',
    'WafRuleConfigTimerPeriodArgs',
    'WafRuleConfigTimerPeriodArgsDict',
    'WafRuleConfigTimerWeeklyPeriodArgs',
    'WafRuleConfigTimerWeeklyPeriodArgsDict',
    'WafRuleConfigTimerWeeklyPeriodDailyPeriodArgs',
    'WafRuleConfigTimerWeeklyPeriodDailyPeriodArgsDict',
    'WafRuleSharedArgs',
    'WafRuleSharedArgsDict',
    'WafRuleSharedActionsArgs',
    'WafRuleSharedActionsArgsDict',
    'WafRuleSharedActionsResponseArgs',
    'WafRuleSharedActionsResponseArgsDict',
    'WafRuleSharedMatchArgs',
    'WafRuleSharedMatchArgsDict',
    'WafRuleSharedMatchCriteriaArgs',
    'WafRuleSharedMatchCriteriaArgsDict',
    'WafRuleSharedMatchCriteriaCriteriaArgs',
    'WafRuleSharedMatchCriteriaCriteriaArgsDict',
    'WafRuleSharedMatchCriteriaCriteriaCriteriaArgs',
    'WafRuleSharedMatchCriteriaCriteriaCriteriaArgsDict',
    'WaitingRoomHostNameAndPathArgs',
    'WaitingRoomHostNameAndPathArgsDict',
]

MYPY = False

if not MYPY:
    class HttpRequestHeaderModificationRuleRequestHeaderModificationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Request Header Name.
        """
        operation: pulumi.Input[_builtins.str]
        """
        Mode of operation. Value range:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value type. Value range:
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Request header value
        """
elif False:
    HttpRequestHeaderModificationRuleRequestHeaderModificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRequestHeaderModificationRuleRequestHeaderModificationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Request Header Name.
        :param pulumi.Input[_builtins.str] operation: Mode of operation. Value range:
        :param pulumi.Input[_builtins.str] type: Value type. Value range:
        :param pulumi.Input[_builtins.str] value: Request header value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation", operation)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Request Header Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        Mode of operation. Value range:
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value type. Value range:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Request header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpResponseHeaderModificationRuleResponseHeaderModificationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The response header name.
        """
        operation: pulumi.Input[_builtins.str]
        """
        Operation method. Possible values:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value type. Value range:
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The response header value.
        """
elif False:
    HttpResponseHeaderModificationRuleResponseHeaderModificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpResponseHeaderModificationRuleResponseHeaderModificationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The response header name.
        :param pulumi.Input[_builtins.str] operation: Operation method. Possible values:
        :param pulumi.Input[_builtins.str] type: The value type. Value range:
        :param pulumi.Input[_builtins.str] value: The response header value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation", operation)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The response header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        Operation method. Possible values:
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value type. Value range:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The response header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadBalancerAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to failover across pools.
        """
elif False:
    LoadBalancerAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] failover_across_pools: Whether to failover across pools.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @_builtins.property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to failover across pools.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerMonitorArgsDict(TypedDict):
        consecutive_down: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive failed health checks before the backend is considered down, for example, 5.
        """
        consecutive_up: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive successful probes required to consider the target as up, e.g., 3.
        """
        expected_codes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expected status code, such as 200,202, successful HTTP response.
        """
        follow_redirects: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to follow the redirect.
        """
        header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP headers to be included in the health check request.
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The monitoring interval, such as 60 seconds, checks the frequency.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Monitor request methods, such as GET, methods in the HTTP protocol.
        """
        monitoring_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Probe Point Region, default to Global
        - `Global`: Global.
        - `ChineseMainland`: Chinese mainland.
        - `OutsideChineseMainland`: Global (excluding the Chinese mainland).
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The monitor checks the path, such as/healthcheck, the HTTP request path.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The target port.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout for the health check, in seconds. The value range is 1-10.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of monitor protocol, such as HTTP, used for health checks. When the value is off, it indicates that no check is performed.
        """
elif False:
    LoadBalancerMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerMonitorArgs:
    def __init__(__self__, *,
                 consecutive_down: Optional[pulumi.Input[_builtins.int]] = None,
                 consecutive_up: Optional[pulumi.Input[_builtins.int]] = None,
                 expected_codes: Optional[pulumi.Input[_builtins.str]] = None,
                 follow_redirects: Optional[pulumi.Input[_builtins.bool]] = None,
                 header: Optional[pulumi.Input[_builtins.str]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 monitoring_region: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] consecutive_down: The number of consecutive failed health checks before the backend is considered down, for example, 5.
        :param pulumi.Input[_builtins.int] consecutive_up: The number of consecutive successful probes required to consider the target as up, e.g., 3.
        :param pulumi.Input[_builtins.str] expected_codes: Expected status code, such as 200,202, successful HTTP response.
        :param pulumi.Input[_builtins.bool] follow_redirects: Whether to follow the redirect.
        :param pulumi.Input[_builtins.str] header: The HTTP headers to be included in the health check request.
        :param pulumi.Input[_builtins.int] interval: The monitoring interval, such as 60 seconds, checks the frequency.
        :param pulumi.Input[_builtins.str] method: Monitor request methods, such as GET, methods in the HTTP protocol.
        :param pulumi.Input[_builtins.str] monitoring_region: Probe Point Region, default to Global
               - `Global`: Global.
               - `ChineseMainland`: Chinese mainland.
               - `OutsideChineseMainland`: Global (excluding the Chinese mainland).
        :param pulumi.Input[_builtins.str] path: The monitor checks the path, such as/healthcheck, the HTTP request path.
        :param pulumi.Input[_builtins.int] port: The target port.
        :param pulumi.Input[_builtins.int] timeout: The timeout for the health check, in seconds. The value range is 1-10.
        :param pulumi.Input[_builtins.str] type: The type of monitor protocol, such as HTTP, used for health checks. When the value is off, it indicates that no check is performed.
        """
        if consecutive_down is not None:
            pulumi.set(__self__, "consecutive_down", consecutive_down)
        if consecutive_up is not None:
            pulumi.set(__self__, "consecutive_up", consecutive_up)
        if expected_codes is not None:
            pulumi.set(__self__, "expected_codes", expected_codes)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if monitoring_region is not None:
            pulumi.set(__self__, "monitoring_region", monitoring_region)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="consecutiveDown")
    def consecutive_down(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive failed health checks before the backend is considered down, for example, 5.
        """
        return pulumi.get(self, "consecutive_down")

    @consecutive_down.setter
    def consecutive_down(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "consecutive_down", value)

    @_builtins.property
    @pulumi.getter(name="consecutiveUp")
    def consecutive_up(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive successful probes required to consider the target as up, e.g., 3.
        """
        return pulumi.get(self, "consecutive_up")

    @consecutive_up.setter
    def consecutive_up(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "consecutive_up", value)

    @_builtins.property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expected status code, such as 200,202, successful HTTP response.
        """
        return pulumi.get(self, "expected_codes")

    @expected_codes.setter
    def expected_codes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_codes", value)

    @_builtins.property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to follow the redirect.
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "follow_redirects", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP headers to be included in the health check request.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The monitoring interval, such as 60 seconds, checks the frequency.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Monitor request methods, such as GET, methods in the HTTP protocol.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="monitoringRegion")
    def monitoring_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Probe Point Region, default to Global
        - `Global`: Global.
        - `ChineseMainland`: Chinese mainland.
        - `OutsideChineseMainland`: Global (excluding the Chinese mainland).
        """
        return pulumi.get(self, "monitoring_region")

    @monitoring_region.setter
    def monitoring_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monitoring_region", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The monitor checks the path, such as/healthcheck, the HTTP request path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The target port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout for the health check, in seconds. The value range is 1-10.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of monitor protocol, such as HTTP, used for health checks. When the value is off, it indicates that no check is performed.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadBalancerRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default round-robin weight, used for all pools that do not have individually specified weights. The value range is 0-100.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Weight configuration for each backend server pool, where the key is the pool ID and the value is the weight coefficient. The weight coefficient represents the proportion of relative traffic distribution.
        """
elif False:
    LoadBalancerRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[_builtins.int]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] default_weight: The default round-robin weight, used for all pools that do not have individually specified weights. The value range is 0-100.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] pool_weights: Weight configuration for each backend server pool, where the key is the pool ID and the value is the weight coefficient. The weight coefficient represents the proportion of relative traffic distribution.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @_builtins.property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default round-robin weight, used for all pools that do not have individually specified weights. The value range is 0-100.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_weight", value)

    @_builtins.property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Weight configuration for each backend server pool, where the key is the pool ID and the value is the weight coefficient. The weight coefficient represents the proportion of relative traffic distribution.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRuleArgsDict(TypedDict):
        fixed_response: NotRequired[pulumi.Input['LoadBalancerRuleFixedResponseArgsDict']]
        """
        Executes a specified response after matching the rule. See `fixed_response` below.
        """
        overrides: NotRequired[pulumi.Input[_builtins.str]]
        """
        Modifies the load balancer configuration for the corresponding request after matching the rule. The fields in this configuration will override the corresponding fields in the load balancer configuration.
        """
        rule: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule content, using conditional expressions to match user requests. When adding global configuration, this parameter does not need to be set. There are two usage scenarios:
        - Match all incoming requests: value set to true
        - Match specified request: Set the value to a custom expression, for example: (http.host eq \\"video.example.com\\")
        """
        rule_enable: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule switch. When adding global configuration, this parameter does not need to be set. Value range:
        - on: open.
        - off: close.
        """
        rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule name. When adding global configuration, this parameter does not need to be set.
        """
        sequence: NotRequired[pulumi.Input[_builtins.int]]
        """
        Order of rule execution. The smaller the value, the higher the priority for execution.
        """
        terminates: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to terminate the execution of subsequent rules.
        """
elif False:
    LoadBalancerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleArgs:
    def __init__(__self__, *,
                 fixed_response: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']] = None,
                 overrides: Optional[pulumi.Input[_builtins.str]] = None,
                 rule: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_enable: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sequence: Optional[pulumi.Input[_builtins.int]] = None,
                 terminates: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['LoadBalancerRuleFixedResponseArgs'] fixed_response: Executes a specified response after matching the rule. See `fixed_response` below.
        :param pulumi.Input[_builtins.str] overrides: Modifies the load balancer configuration for the corresponding request after matching the rule. The fields in this configuration will override the corresponding fields in the load balancer configuration.
        :param pulumi.Input[_builtins.str] rule: Rule content, using conditional expressions to match user requests. When adding global configuration, this parameter does not need to be set. There are two usage scenarios:
               - Match all incoming requests: value set to true
               - Match specified request: Set the value to a custom expression, for example: (http.host eq \\"video.example.com\\")
        :param pulumi.Input[_builtins.str] rule_enable: Rule switch. When adding global configuration, this parameter does not need to be set. Value range:
               - on: open.
               - off: close.
        :param pulumi.Input[_builtins.str] rule_name: Rule name. When adding global configuration, this parameter does not need to be set.
        :param pulumi.Input[_builtins.int] sequence: Order of rule execution. The smaller the value, the higher the priority for execution.
        :param pulumi.Input[_builtins.bool] terminates: Whether to terminate the execution of subsequent rules.
        """
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if rule_enable is not None:
            pulumi.set(__self__, "rule_enable", rule_enable)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if sequence is not None:
            pulumi.set(__self__, "sequence", sequence)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @_builtins.property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]:
        """
        Executes a specified response after matching the rule. See `fixed_response` below.
        """
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Modifies the load balancer configuration for the corresponding request after matching the rule. The fields in this configuration will override the corresponding fields in the load balancer configuration.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overrides", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule content, using conditional expressions to match user requests. When adding global configuration, this parameter does not need to be set. There are two usage scenarios:
        - Match all incoming requests: value set to true
        - Match specified request: Set the value to a custom expression, for example: (http.host eq \\"video.example.com\\")
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter(name="ruleEnable")
    def rule_enable(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule switch. When adding global configuration, this parameter does not need to be set. Value range:
        - on: open.
        - off: close.
        """
        return pulumi.get(self, "rule_enable")

    @rule_enable.setter
    def rule_enable(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_enable", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule name. When adding global configuration, this parameter does not need to be set.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_name", value)

    @_builtins.property
    @pulumi.getter
    def sequence(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Order of rule execution. The smaller the value, the higher the priority for execution.
        """
        return pulumi.get(self, "sequence")

    @sequence.setter
    def sequence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sequence", value)

    @_builtins.property
    @pulumi.getter
    def terminates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to terminate the execution of subsequent rules.
        """
        return pulumi.get(self, "terminates")

    @terminates.setter
    def terminates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "terminates", value)


if not MYPY:
    class LoadBalancerRuleFixedResponseArgsDict(TypedDict):
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Content-Type field in the HTTP Header.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The location field in the http return.
        """
        message_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The body value of the response.
        """
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Status Code.
        """
elif False:
    LoadBalancerRuleFixedResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleFixedResponseArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 message_body: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] content_type: The Content-Type field in the HTTP Header.
        :param pulumi.Input[_builtins.str] location: The location field in the http return.
        :param pulumi.Input[_builtins.str] message_body: The body value of the response.
        :param pulumi.Input[_builtins.int] status_code: Status Code.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Content-Type field in the HTTP Header.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The location field in the http return.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The body value of the response.
        """
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_body", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Status Code.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class OriginPoolOriginArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin Address.
        """
        auth_conf: NotRequired[pulumi.Input['OriginPoolOriginAuthConfArgsDict']]
        """
        The authentication information. When the source Station is an OSS or S3 and other source stations need to be authenticated, the authentication-related configuration information needs to be transmitted. See `auth_conf` below.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the source station is enabled:
        """
        header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request header that is sent when returning to the source. Only Host is supported.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin Name.
        """
        origin_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Origin ID.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source station type:
        ip_domain: ip or domain name type origin station;
        - `OSS`:OSS address source station;
        - `S3`:AWS S3 Source station.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight, 0-100.
        """
elif False:
    OriginPoolOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginPoolOriginArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_conf: Optional[pulumi.Input['OriginPoolOriginAuthConfArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 header: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_id: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Origin Address.
        :param pulumi.Input['OriginPoolOriginAuthConfArgs'] auth_conf: The authentication information. When the source Station is an OSS or S3 and other source stations need to be authenticated, the authentication-related configuration information needs to be transmitted. See `auth_conf` below.
        :param pulumi.Input[_builtins.bool] enabled: Whether the source station is enabled:
        :param pulumi.Input[_builtins.str] header: The request header that is sent when returning to the source. Only Host is supported.
        :param pulumi.Input[_builtins.str] name: Origin Name.
        :param pulumi.Input[_builtins.int] origin_id: Origin ID.
        :param pulumi.Input[_builtins.str] type: Source station type:
               ip_domain: ip or domain name type origin station;
               - `OSS`:OSS address source station;
               - `S3`:AWS S3 Source station.
        :param pulumi.Input[_builtins.int] weight: Weight, 0-100.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if auth_conf is not None:
            pulumi.set(__self__, "auth_conf", auth_conf)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin Address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="authConf")
    def auth_conf(self) -> Optional[pulumi.Input['OriginPoolOriginAuthConfArgs']]:
        """
        The authentication information. When the source Station is an OSS or S3 and other source stations need to be authenticated, the authentication-related configuration information needs to be transmitted. See `auth_conf` below.
        """
        return pulumi.get(self, "auth_conf")

    @auth_conf.setter
    def auth_conf(self, value: Optional[pulumi.Input['OriginPoolOriginAuthConfArgs']]):
        pulumi.set(self, "auth_conf", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the source station is enabled:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request header that is sent when returning to the source. Only Host is supported.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Origin ID.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source station type:
        ip_domain: ip or domain name type origin station;
        - `OSS`:OSS address source station;
        - `S3`:AWS S3 Source station.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight, 0-100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class OriginPoolOriginAuthConfArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AccessKey to be passed when AuthType is set to private_cross_account or private.
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication type.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Region of the source station to be transmitted when the source station is AWS S3.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SecretKey to be passed when AuthType is set to private_cross_account or private.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signature version to be transmitted when the source station is AWS S3.
        """
elif False:
    OriginPoolOriginAuthConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginPoolOriginAuthConfArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The AccessKey to be passed when AuthType is set to private_cross_account or private.
        :param pulumi.Input[_builtins.str] auth_type: Authentication type.
        :param pulumi.Input[_builtins.str] region: The Region of the source station to be transmitted when the source station is AWS S3.
        :param pulumi.Input[_builtins.str] secret_key: The SecretKey to be passed when AuthType is set to private_cross_account or private.
        :param pulumi.Input[_builtins.str] version: The signature version to be transmitted when the source station is AWS S3.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AccessKey to be passed when AuthType is set to private_cross_account or private.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication type.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Region of the source station to be transmitted when the source station is AWS S3.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SecretKey to be passed when AuthType is set to private_cross_account or private.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signature version to be transmitted when the source station is AWS S3.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RecordAuthConfArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
        """
elif False:
    RecordAuthConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordAuthConfArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
        :param pulumi.Input[_builtins.str] auth_type: The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
        :param pulumi.Input[_builtins.str] region: The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
        :param pulumi.Input[_builtins.str] secret_key: The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        :param pulumi.Input[_builtins.str] version: The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.int]]
        """
        The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
        """
        fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
        """
        flag: NotRequired[pulumi.Input[_builtins.int]]
        """
        The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
        """
        key_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
        """
        matching_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
        """
        selector: NotRequired[pulumi.Input[_builtins.int]]
        """
        The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record. Valid values:
        """
        type: NotRequired[pulumi.Input[_builtins.int]]
        """
        The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
        """
        usage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records:
        - `A/AAAA`: the IP address(es). Separate IP addresses with commas (,). You must have at least one IPv4 address.
        - `CNAME`: the target domain name.
        - `NS`: the name servers for the domain name.
        - `MX`: a valid domain name of the target mail server.
        - `TXT`: a valid text string.
        - `CAA`: a valid domain name of the certificate authority.
        - `SRV`: a valid domain name of the target host.
        - `URI`: a valid URI string.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
        """
elif False:
    RecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.int]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 flag: Optional[pulumi.Input[_builtins.int]] = None,
                 key_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 matching_type: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 selector: Optional[pulumi.Input[_builtins.int]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.int]] = None,
                 usage: Optional[pulumi.Input[_builtins.int]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] algorithm: The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
        :param pulumi.Input[_builtins.str] certificate: The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
        :param pulumi.Input[_builtins.str] fingerprint: The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
        :param pulumi.Input[_builtins.int] flag: The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
        :param pulumi.Input[_builtins.int] key_tag: The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
        :param pulumi.Input[_builtins.int] matching_type: The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        :param pulumi.Input[_builtins.int] port: The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
        :param pulumi.Input[_builtins.int] priority: The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
        :param pulumi.Input[_builtins.int] selector: The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        :param pulumi.Input[_builtins.str] tag: The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record. Valid values:
        :param pulumi.Input[_builtins.int] type: The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
        :param pulumi.Input[_builtins.int] usage: The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        :param pulumi.Input[_builtins.str] value: Record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records:
               - `A/AAAA`: the IP address(es). Separate IP addresses with commas (,). You must have at least one IPv4 address.
               - `CNAME`: the target domain name.
               - `NS`: the name servers for the domain name.
               - `MX`: a valid domain name of the target mail server.
               - `TXT`: a valid text string.
               - `CAA`: a valid domain name of the certificate authority.
               - `SRV`: a valid domain name of the target host.
               - `URI`: a valid URI string.
        :param pulumi.Input[_builtins.int] weight: The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flag is not None:
            pulumi.set(__self__, "flag", flag)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @_builtins.property
    @pulumi.getter
    def flag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
        """
        return pulumi.get(self, "flag")

    @flag.setter
    def flag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "flag", value)

    @_builtins.property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
        """
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_tag", value)

    @_builtins.property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "matching_type", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record. Valid values:
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "usage", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records:
        - `A/AAAA`: the IP address(es). Separate IP addresses with commas (,). You must have at least one IPv4 address.
        - `CNAME`: the target domain name.
        - `NS`: the name servers for the domain name.
        - `MX`: a valid domain name of the target mail server.
        - `TXT`: a valid text string.
        - `CAA`: a valid domain name of the certificate authority.
        - `SRV`: a valid domain name of the target host.
        - `URI`: a valid URI string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class SiteDeliveryTaskHttpDeliveryArgsDict(TypedDict):
        compress: NotRequired[pulumi.Input[_builtins.str]]
        dest_url: NotRequired[pulumi.Input[_builtins.str]]
        header_param: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        log_body_prefix: NotRequired[pulumi.Input[_builtins.str]]
        log_body_suffix: NotRequired[pulumi.Input[_builtins.str]]
        max_batch_mb: NotRequired[pulumi.Input[_builtins.int]]
        max_batch_size: NotRequired[pulumi.Input[_builtins.int]]
        max_retry: NotRequired[pulumi.Input[_builtins.int]]
        query_param: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        standard_auth_on: NotRequired[pulumi.Input[_builtins.bool]]
        standard_auth_param: NotRequired[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict']]
        """
        See `standard_auth_param` below.
        """
        transform_timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    SiteDeliveryTaskHttpDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskHttpDeliveryArgs:
    def __init__(__self__, *,
                 compress: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_url: Optional[pulumi.Input[_builtins.str]] = None,
                 header_param: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 log_body_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_body_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 max_batch_mb: Optional[pulumi.Input[_builtins.int]] = None,
                 max_batch_size: Optional[pulumi.Input[_builtins.int]] = None,
                 max_retry: Optional[pulumi.Input[_builtins.int]] = None,
                 query_param: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 standard_auth_on: Optional[pulumi.Input[_builtins.bool]] = None,
                 standard_auth_param: Optional[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs']] = None,
                 transform_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs'] standard_auth_param: See `standard_auth_param` below.
        """
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if dest_url is not None:
            pulumi.set(__self__, "dest_url", dest_url)
        if header_param is not None:
            pulumi.set(__self__, "header_param", header_param)
        if log_body_prefix is not None:
            pulumi.set(__self__, "log_body_prefix", log_body_prefix)
        if log_body_suffix is not None:
            pulumi.set(__self__, "log_body_suffix", log_body_suffix)
        if max_batch_mb is not None:
            pulumi.set(__self__, "max_batch_mb", max_batch_mb)
        if max_batch_size is not None:
            pulumi.set(__self__, "max_batch_size", max_batch_size)
        if max_retry is not None:
            pulumi.set(__self__, "max_retry", max_retry)
        if query_param is not None:
            pulumi.set(__self__, "query_param", query_param)
        if standard_auth_on is not None:
            pulumi.set(__self__, "standard_auth_on", standard_auth_on)
        if standard_auth_param is not None:
            pulumi.set(__self__, "standard_auth_param", standard_auth_param)
        if transform_timeout is not None:
            pulumi.set(__self__, "transform_timeout", transform_timeout)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="destUrl")
    def dest_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dest_url")

    @dest_url.setter
    def dest_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_url", value)

    @_builtins.property
    @pulumi.getter(name="headerParam")
    def header_param(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "header_param")

    @header_param.setter
    def header_param(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header_param", value)

    @_builtins.property
    @pulumi.getter(name="logBodyPrefix")
    def log_body_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_body_prefix")

    @log_body_prefix.setter
    def log_body_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_body_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logBodySuffix")
    def log_body_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_body_suffix")

    @log_body_suffix.setter
    def log_body_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_body_suffix", value)

    @_builtins.property
    @pulumi.getter(name="maxBatchMb")
    def max_batch_mb(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_batch_mb")

    @max_batch_mb.setter
    def max_batch_mb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_batch_mb", value)

    @_builtins.property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_batch_size")

    @max_batch_size.setter
    def max_batch_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_batch_size", value)

    @_builtins.property
    @pulumi.getter(name="maxRetry")
    def max_retry(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_retry")

    @max_retry.setter
    def max_retry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_retry", value)

    @_builtins.property
    @pulumi.getter(name="queryParam")
    def query_param(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "query_param")

    @query_param.setter
    def query_param(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_param", value)

    @_builtins.property
    @pulumi.getter(name="standardAuthOn")
    def standard_auth_on(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "standard_auth_on")

    @standard_auth_on.setter
    def standard_auth_on(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "standard_auth_on", value)

    @_builtins.property
    @pulumi.getter(name="standardAuthParam")
    def standard_auth_param(self) -> Optional[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs']]:
        """
        See `standard_auth_param` below.
        """
        return pulumi.get(self, "standard_auth_param")

    @standard_auth_param.setter
    def standard_auth_param(self, value: Optional[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs']]):
        pulumi.set(self, "standard_auth_param", value)

    @_builtins.property
    @pulumi.getter(name="transformTimeout")
    def transform_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "transform_timeout")

    @transform_timeout.setter
    def transform_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transform_timeout", value)


if not MYPY:
    class SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict(TypedDict):
        expired_time: NotRequired[pulumi.Input[_builtins.int]]
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        url_path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs:
    def __init__(__self__, *,
                 expired_time: Optional[pulumi.Input[_builtins.int]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 url_path: Optional[pulumi.Input[_builtins.str]] = None):
        if expired_time is not None:
            pulumi.set(__self__, "expired_time", expired_time)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @_builtins.property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expired_time")

    @expired_time.setter
    def expired_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expired_time", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "url_path")

    @url_path.setter
    def url_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_path", value)


if not MYPY:
    class SiteDeliveryTaskKafkaDeliveryArgsDict(TypedDict):
        balancer: NotRequired[pulumi.Input[_builtins.str]]
        brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        compress: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compression method. By default, data is not compressed.
        """
        machanism_type: NotRequired[pulumi.Input[_builtins.str]]
        password: NotRequired[pulumi.Input[_builtins.str]]
        topic: NotRequired[pulumi.Input[_builtins.str]]
        user_auth: NotRequired[pulumi.Input[_builtins.bool]]
        user_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteDeliveryTaskKafkaDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskKafkaDeliveryArgs:
    def __init__(__self__, *,
                 balancer: Optional[pulumi.Input[_builtins.str]] = None,
                 brokers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 compress: Optional[pulumi.Input[_builtins.str]] = None,
                 machanism_type: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None,
                 user_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compress: The compression method. By default, data is not compressed.
        """
        if balancer is not None:
            pulumi.set(__self__, "balancer", balancer)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if machanism_type is not None:
            pulumi.set(__self__, "machanism_type", machanism_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if user_auth is not None:
            pulumi.set(__self__, "user_auth", user_auth)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def balancer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "balancer")

    @balancer.setter
    def balancer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "balancer", value)

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "brokers", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compression method. By default, data is not compressed.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="machanismType")
    def machanism_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "machanism_type")

    @machanism_type.setter
    def machanism_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machanism_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="userAuth")
    def user_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "user_auth")

    @user_auth.setter
    def user_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "user_auth", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class SiteDeliveryTaskOssDeliveryArgsDict(TypedDict):
        aliuid: NotRequired[pulumi.Input[_builtins.str]]
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        prefix_path: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region ID of the service.
        """
elif False:
    SiteDeliveryTaskOssDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskOssDeliveryArgs:
    def __init__(__self__, *,
                 aliuid: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_path: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: The region ID of the service.
        """
        if aliuid is not None:
            pulumi.set(__self__, "aliuid", aliuid)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def aliuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aliuid")

    @aliuid.setter
    def aliuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aliuid", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix_path")

    @prefix_path.setter
    def prefix_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region ID of the service.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class SiteDeliveryTaskS3DeliveryArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        bucket_path: NotRequired[pulumi.Input[_builtins.str]]
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        prefix_path: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        s3_cmpt: NotRequired[pulumi.Input[_builtins.bool]]
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        server_side_encryption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Server-side encryption
        """
        vertify_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication Type
        """
elif False:
    SiteDeliveryTaskS3DeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskS3DeliveryArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_path: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_path: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_cmpt: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 server_side_encryption: Optional[pulumi.Input[_builtins.bool]] = None,
                 vertify_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] server_side_encryption: Server-side encryption
        :param pulumi.Input[_builtins.str] vertify_type: Authentication Type
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_path is not None:
            pulumi.set(__self__, "bucket_path", bucket_path)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if s3_cmpt is not None:
            pulumi.set(__self__, "s3_cmpt", s3_cmpt)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if vertify_type is not None:
            pulumi.set(__self__, "vertify_type", vertify_type)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_path")

    @bucket_path.setter
    def bucket_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_path", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix_path")

    @prefix_path.setter
    def prefix_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="s3Cmpt")
    def s3_cmpt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "s3_cmpt")

    @s3_cmpt.setter
    def s3_cmpt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "s3_cmpt", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Server-side encryption
        """
        return pulumi.get(self, "server_side_encryption")

    @server_side_encryption.setter
    def server_side_encryption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_side_encryption", value)

    @_builtins.property
    @pulumi.getter(name="vertifyType")
    def vertify_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication Type
        """
        return pulumi.get(self, "vertify_type")

    @vertify_type.setter
    def vertify_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vertify_type", value)


if not MYPY:
    class SiteDeliveryTaskSlsDeliveryArgsDict(TypedDict):
        sls_log_store: NotRequired[pulumi.Input[_builtins.str]]
        sls_project: NotRequired[pulumi.Input[_builtins.str]]
        sls_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteDeliveryTaskSlsDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskSlsDeliveryArgs:
    def __init__(__self__, *,
                 sls_log_store: Optional[pulumi.Input[_builtins.str]] = None,
                 sls_project: Optional[pulumi.Input[_builtins.str]] = None,
                 sls_region: Optional[pulumi.Input[_builtins.str]] = None):
        if sls_log_store is not None:
            pulumi.set(__self__, "sls_log_store", sls_log_store)
        if sls_project is not None:
            pulumi.set(__self__, "sls_project", sls_project)
        if sls_region is not None:
            pulumi.set(__self__, "sls_region", sls_region)

    @_builtins.property
    @pulumi.getter(name="slsLogStore")
    def sls_log_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sls_log_store")

    @sls_log_store.setter
    def sls_log_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_log_store", value)

    @_builtins.property
    @pulumi.getter(name="slsProject")
    def sls_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sls_project")

    @sls_project.setter
    def sls_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_project", value)

    @_builtins.property
    @pulumi.getter(name="slsRegion")
    def sls_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sls_region")

    @sls_region.setter
    def sls_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_region", value)


if not MYPY:
    class TransportLayerApplicationRuleArgsDict(TypedDict):
        client_ip_pass_through_mode: pulumi.Input[_builtins.str]
        """
        Client IP pass-through protocol, supporting:
        """
        edge_port: pulumi.Input[_builtins.str]
        """
        Edge port. Supports:
        - A single port, such as 80.
        - Port range, such as 81-85, representing ports 81, 82, 83, 84, and 85.
        - Combination of ports and port ranges, separated by commas, such as 80,81-85,90, representing ports 80, 81, 82, 83, 84, 85, and 90.

        Edge ports within a single rule and between multiple rules must not overlap.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Forwarding rule protocol, with values:
        - `TCP`: TCP protocol.
        - `UDP`: UDP protocol.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specific value of the origin, which needs to match the origin type.
        """
        source_port: pulumi.Input[_builtins.str]
        """
        Source Port
        """
        source_type: pulumi.Input[_builtins.str]
        """
        Origin type, supporting:
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment information for the rule (optional).
        """
        rule_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule ID
        """
elif False:
    TransportLayerApplicationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransportLayerApplicationRuleArgs:
    def __init__(__self__, *,
                 client_ip_pass_through_mode: pulumi.Input[_builtins.str],
                 edge_port: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 source_port: pulumi.Input[_builtins.str],
                 source_type: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] client_ip_pass_through_mode: Client IP pass-through protocol, supporting:
        :param pulumi.Input[_builtins.str] edge_port: Edge port. Supports:
               - A single port, such as 80.
               - Port range, such as 81-85, representing ports 81, 82, 83, 84, and 85.
               - Combination of ports and port ranges, separated by commas, such as 80,81-85,90, representing ports 80, 81, 82, 83, 84, 85, and 90.
               
               Edge ports within a single rule and between multiple rules must not overlap.
        :param pulumi.Input[_builtins.str] protocol: Forwarding rule protocol, with values:
               - `TCP`: TCP protocol.
               - `UDP`: UDP protocol.
        :param pulumi.Input[_builtins.str] source: Specific value of the origin, which needs to match the origin type.
        :param pulumi.Input[_builtins.str] source_port: Source Port
        :param pulumi.Input[_builtins.str] source_type: Origin type, supporting:
        :param pulumi.Input[_builtins.str] comment: Comment information for the rule (optional).
        :param pulumi.Input[_builtins.int] rule_id: Rule ID
        """
        pulumi.set(__self__, "client_ip_pass_through_mode", client_ip_pass_through_mode)
        pulumi.set(__self__, "edge_port", edge_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_port", source_port)
        pulumi.set(__self__, "source_type", source_type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @_builtins.property
    @pulumi.getter(name="clientIpPassThroughMode")
    def client_ip_pass_through_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Client IP pass-through protocol, supporting:
        """
        return pulumi.get(self, "client_ip_pass_through_mode")

    @client_ip_pass_through_mode.setter
    def client_ip_pass_through_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_ip_pass_through_mode", value)

    @_builtins.property
    @pulumi.getter(name="edgePort")
    def edge_port(self) -> pulumi.Input[_builtins.str]:
        """
        Edge port. Supports:
        - A single port, such as 80.
        - Port range, such as 81-85, representing ports 81, 82, 83, 84, and 85.
        - Combination of ports and port ranges, separated by commas, such as 80,81-85,90, representing ports 80, 81, 82, 83, 84, 85, and 90.

        Edge ports within a single rule and between multiple rules must not overlap.
        """
        return pulumi.get(self, "edge_port")

    @edge_port.setter
    def edge_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "edge_port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Forwarding rule protocol, with values:
        - `TCP`: TCP protocol.
        - `UDP`: UDP protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specific value of the origin, which needs to match the origin type.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[_builtins.str]:
        """
        Source Port
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_port", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        Origin type, supporting:
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment information for the rule (optional).
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule ID
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_id", value)


if not MYPY:
    class WafRuleConfigArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action performed on requests that match the managed rule.
        """
        actions: NotRequired[pulumi.Input['WafRuleConfigActionsArgsDict']]
        """
        Extended action configurations, including custom responses and bypass settings. See `actions` below.
        """
        app_package: NotRequired[pulumi.Input['WafRuleConfigAppPackageArgsDict']]
        """
        Security mechanism to prevent apps from being repackaged. See `app_package` below.
        """
        app_sdk: NotRequired[pulumi.Input['WafRuleConfigAppSdkArgsDict']]
        """
        Mobile app SDK-related configurations. See `app_sdk` below.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        The match expression used to evaluate incoming requests.
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the custom error page, which can be obtained by calling the ListPages operation.
        """
        managed_group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the managed rule group (deprecated).
        """
        managed_list: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the managed list applied to this rule.
        """
        managed_rulesets: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetArgsDict']]]]
        """
        The managed rulesets referenced by this rule and their configurations. See `managed_rulesets` below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The package name of an authorized application.
        """
        notes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional notes about this rule.
        """
        rate_limit: NotRequired[pulumi.Input['WafRuleConfigRateLimitArgsDict']]
        """
        Configuration of the rate limiting rule. See `rate_limit` below.
        """
        security_level: NotRequired[pulumi.Input['WafRuleConfigSecurityLevelArgsDict']]
        """
        The overall security protection level of WAF. See `security_level` below.
        """
        sigchls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Configuration items for token verification mechanisms.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the managed rule: whether it is enabled or disabled.
        """
        timer: NotRequired[pulumi.Input['WafRuleConfigTimerArgsDict']]
        """
        Configuration for the time schedule when the rule takes effect. See `timer` below.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type category of the WAF rule.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom signature field used for validation.
        """
elif False:
    WafRuleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 actions: Optional[pulumi.Input['WafRuleConfigActionsArgs']] = None,
                 app_package: Optional[pulumi.Input['WafRuleConfigAppPackageArgs']] = None,
                 app_sdk: Optional[pulumi.Input['WafRuleConfigAppSdkArgs']] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 managed_group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 managed_list: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_rulesets: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 rate_limit: Optional[pulumi.Input['WafRuleConfigRateLimitArgs']] = None,
                 security_level: Optional[pulumi.Input['WafRuleConfigSecurityLevelArgs']] = None,
                 sigchls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 timer: Optional[pulumi.Input['WafRuleConfigTimerArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action performed on requests that match the managed rule.
        :param pulumi.Input['WafRuleConfigActionsArgs'] actions: Extended action configurations, including custom responses and bypass settings. See `actions` below.
        :param pulumi.Input['WafRuleConfigAppPackageArgs'] app_package: Security mechanism to prevent apps from being repackaged. See `app_package` below.
        :param pulumi.Input['WafRuleConfigAppSdkArgs'] app_sdk: Mobile app SDK-related configurations. See `app_sdk` below.
        :param pulumi.Input[_builtins.str] expression: The match expression used to evaluate incoming requests.
        :param pulumi.Input[_builtins.int] id: The ID of the custom error page, which can be obtained by calling the ListPages operation.
        :param pulumi.Input[_builtins.int] managed_group_id: The ID of the managed rule group (deprecated).
        :param pulumi.Input[_builtins.str] managed_list: The name of the managed list applied to this rule.
        :param pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetArgs']]] managed_rulesets: The managed rulesets referenced by this rule and their configurations. See `managed_rulesets` below.
        :param pulumi.Input[_builtins.str] name: The package name of an authorized application.
        :param pulumi.Input[_builtins.str] notes: Additional notes about this rule.
        :param pulumi.Input['WafRuleConfigRateLimitArgs'] rate_limit: Configuration of the rate limiting rule. See `rate_limit` below.
        :param pulumi.Input['WafRuleConfigSecurityLevelArgs'] security_level: The overall security protection level of WAF. See `security_level` below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sigchls: Configuration items for token verification mechanisms.
        :param pulumi.Input[_builtins.str] status: The status of the managed rule: whether it is enabled or disabled.
        :param pulumi.Input['WafRuleConfigTimerArgs'] timer: Configuration for the time schedule when the rule takes effect. See `timer` below.
        :param pulumi.Input[_builtins.str] type: The type category of the WAF rule.
        :param pulumi.Input[_builtins.str] value: The value of the custom signature field used for validation.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if app_package is not None:
            pulumi.set(__self__, "app_package", app_package)
        if app_sdk is not None:
            pulumi.set(__self__, "app_sdk", app_sdk)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if managed_group_id is not None:
            pulumi.set(__self__, "managed_group_id", managed_group_id)
        if managed_list is not None:
            pulumi.set(__self__, "managed_list", managed_list)
        if managed_rulesets is not None:
            pulumi.set(__self__, "managed_rulesets", managed_rulesets)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if sigchls is not None:
            pulumi.set(__self__, "sigchls", sigchls)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timer is not None:
            pulumi.set(__self__, "timer", timer)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action performed on requests that match the managed rule.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['WafRuleConfigActionsArgs']]:
        """
        Extended action configurations, including custom responses and bypass settings. See `actions` below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['WafRuleConfigActionsArgs']]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="appPackage")
    def app_package(self) -> Optional[pulumi.Input['WafRuleConfigAppPackageArgs']]:
        """
        Security mechanism to prevent apps from being repackaged. See `app_package` below.
        """
        return pulumi.get(self, "app_package")

    @app_package.setter
    def app_package(self, value: Optional[pulumi.Input['WafRuleConfigAppPackageArgs']]):
        pulumi.set(self, "app_package", value)

    @_builtins.property
    @pulumi.getter(name="appSdk")
    def app_sdk(self) -> Optional[pulumi.Input['WafRuleConfigAppSdkArgs']]:
        """
        Mobile app SDK-related configurations. See `app_sdk` below.
        """
        return pulumi.get(self, "app_sdk")

    @app_sdk.setter
    def app_sdk(self, value: Optional[pulumi.Input['WafRuleConfigAppSdkArgs']]):
        pulumi.set(self, "app_sdk", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The match expression used to evaluate incoming requests.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the custom error page, which can be obtained by calling the ListPages operation.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="managedGroupId")
    def managed_group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the managed rule group (deprecated).
        """
        return pulumi.get(self, "managed_group_id")

    @managed_group_id.setter
    def managed_group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "managed_group_id", value)

    @_builtins.property
    @pulumi.getter(name="managedList")
    def managed_list(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the managed list applied to this rule.
        """
        return pulumi.get(self, "managed_list")

    @managed_list.setter
    def managed_list(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_list", value)

    @_builtins.property
    @pulumi.getter(name="managedRulesets")
    def managed_rulesets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetArgs']]]]:
        """
        The managed rulesets referenced by this rule and their configurations. See `managed_rulesets` below.
        """
        return pulumi.get(self, "managed_rulesets")

    @managed_rulesets.setter
    def managed_rulesets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetArgs']]]]):
        pulumi.set(self, "managed_rulesets", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The package name of an authorized application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional notes about this rule.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input['WafRuleConfigRateLimitArgs']]:
        """
        Configuration of the rate limiting rule. See `rate_limit` below.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input['WafRuleConfigRateLimitArgs']]):
        pulumi.set(self, "rate_limit", value)

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input['WafRuleConfigSecurityLevelArgs']]:
        """
        The overall security protection level of WAF. See `security_level` below.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input['WafRuleConfigSecurityLevelArgs']]):
        pulumi.set(self, "security_level", value)

    @_builtins.property
    @pulumi.getter
    def sigchls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Configuration items for token verification mechanisms.
        """
        return pulumi.get(self, "sigchls")

    @sigchls.setter
    def sigchls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sigchls", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the managed rule: whether it is enabled or disabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def timer(self) -> Optional[pulumi.Input['WafRuleConfigTimerArgs']]:
        """
        Configuration for the time schedule when the rule takes effect. See `timer` below.
        """
        return pulumi.get(self, "timer")

    @timer.setter
    def timer(self, value: Optional[pulumi.Input['WafRuleConfigTimerArgs']]):
        pulumi.set(self, "timer", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type category of the WAF rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom signature field used for validation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WafRuleConfigActionsArgsDict(TypedDict):
        bypass: NotRequired[pulumi.Input['WafRuleConfigActionsBypassArgsDict']]
        """
        The skip configuration specified by the whitelist rule. See `bypass` below.
        """
        response: NotRequired[pulumi.Input['WafRuleConfigActionsResponseArgsDict']]
elif False:
    WafRuleConfigActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigActionsArgs:
    def __init__(__self__, *,
                 bypass: Optional[pulumi.Input['WafRuleConfigActionsBypassArgs']] = None,
                 response: Optional[pulumi.Input['WafRuleConfigActionsResponseArgs']] = None):
        """
        :param pulumi.Input['WafRuleConfigActionsBypassArgs'] bypass: The skip configuration specified by the whitelist rule. See `bypass` below.
        """
        if bypass is not None:
            pulumi.set(__self__, "bypass", bypass)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def bypass(self) -> Optional[pulumi.Input['WafRuleConfigActionsBypassArgs']]:
        """
        The skip configuration specified by the whitelist rule. See `bypass` below.
        """
        return pulumi.get(self, "bypass")

    @bypass.setter
    def bypass(self, value: Optional[pulumi.Input['WafRuleConfigActionsBypassArgs']]):
        pulumi.set(self, "bypass", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['WafRuleConfigActionsResponseArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['WafRuleConfigActionsResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class WafRuleConfigActionsBypassArgsDict(TypedDict):
        custom_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The IDs of custom rules to skip.
        """
        regular_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The IDs of specific managed rules to skip.
        """
        regular_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The types of managed rules to skip.
        """
        skip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope that is skipped when requests match conditions defined in the whitelist rule.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The rule categories that are skipped when requests match conditions defined in the whitelist rule.
        """
elif False:
    WafRuleConfigActionsBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigActionsBypassArgs:
    def __init__(__self__, *,
                 custom_rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 regular_rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 regular_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 skip: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] custom_rules: The IDs of custom rules to skip.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] regular_rules: The IDs of specific managed rules to skip.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regular_types: The types of managed rules to skip.
        :param pulumi.Input[_builtins.str] skip: The scope that is skipped when requests match conditions defined in the whitelist rule.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: The rule categories that are skipped when requests match conditions defined in the whitelist rule.
        """
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if regular_rules is not None:
            pulumi.set(__self__, "regular_rules", regular_rules)
        if regular_types is not None:
            pulumi.set(__self__, "regular_types", regular_types)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The IDs of custom rules to skip.
        """
        return pulumi.get(self, "custom_rules")

    @custom_rules.setter
    def custom_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "custom_rules", value)

    @_builtins.property
    @pulumi.getter(name="regularRules")
    def regular_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The IDs of specific managed rules to skip.
        """
        return pulumi.get(self, "regular_rules")

    @regular_rules.setter
    def regular_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "regular_rules", value)

    @_builtins.property
    @pulumi.getter(name="regularTypes")
    def regular_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The types of managed rules to skip.
        """
        return pulumi.get(self, "regular_types")

    @regular_types.setter
    def regular_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regular_types", value)

    @_builtins.property
    @pulumi.getter
    def skip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope that is skipped when requests match conditions defined in the whitelist rule.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "skip", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The rule categories that are skipped when requests match conditions defined in the whitelist rule.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class WafRuleConfigActionsResponseArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The internal unique ID of the WAF rule.
        """
elif False:
    WafRuleConfigActionsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigActionsResponseArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The internal unique ID of the WAF rule.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The internal unique ID of the WAF rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WafRuleConfigAppPackageArgsDict(TypedDict):
        package_signs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigAppPackagePackageSignArgsDict']]]]
        """
        Security mechanism to prevent apps from being repackaged. See `package_signs` below.
        """
elif False:
    WafRuleConfigAppPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigAppPackageArgs:
    def __init__(__self__, *,
                 package_signs: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigAppPackagePackageSignArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WafRuleConfigAppPackagePackageSignArgs']]] package_signs: Security mechanism to prevent apps from being repackaged. See `package_signs` below.
        """
        if package_signs is not None:
            pulumi.set(__self__, "package_signs", package_signs)

    @_builtins.property
    @pulumi.getter(name="packageSigns")
    def package_signs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigAppPackagePackageSignArgs']]]]:
        """
        Security mechanism to prevent apps from being repackaged. See `package_signs` below.
        """
        return pulumi.get(self, "package_signs")

    @package_signs.setter
    def package_signs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigAppPackagePackageSignArgs']]]]):
        pulumi.set(self, "package_signs", value)


if not MYPY:
    class WafRuleConfigAppPackagePackageSignArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        sign: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digital signature of a legitimate app package.
        """
elif False:
    WafRuleConfigAppPackagePackageSignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigAppPackagePackageSignArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 sign: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sign: The digital signature of a legitimate app package.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sign is not None:
            pulumi.set(__self__, "sign", sign)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def sign(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digital signature of a legitimate app package.
        """
        return pulumi.get(self, "sign")

    @sign.setter
    def sign(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign", value)


if not MYPY:
    class WafRuleConfigAppSdkArgsDict(TypedDict):
        custom_sign: NotRequired[pulumi.Input['WafRuleConfigAppSdkCustomSignArgsDict']]
        """
        Custom fields used for mobile app signature validation. See `custom_sign` below.
        """
        custom_sign_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether the custom signature field validation is enabled.
        """
        feature_abnormals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Detected abnormal behaviors of the application.
        """
elif False:
    WafRuleConfigAppSdkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigAppSdkArgs:
    def __init__(__self__, *,
                 custom_sign: Optional[pulumi.Input['WafRuleConfigAppSdkCustomSignArgs']] = None,
                 custom_sign_status: Optional[pulumi.Input[_builtins.str]] = None,
                 feature_abnormals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['WafRuleConfigAppSdkCustomSignArgs'] custom_sign: Custom fields used for mobile app signature validation. See `custom_sign` below.
        :param pulumi.Input[_builtins.str] custom_sign_status: Indicates whether the custom signature field validation is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] feature_abnormals: Detected abnormal behaviors of the application.
        """
        if custom_sign is not None:
            pulumi.set(__self__, "custom_sign", custom_sign)
        if custom_sign_status is not None:
            pulumi.set(__self__, "custom_sign_status", custom_sign_status)
        if feature_abnormals is not None:
            pulumi.set(__self__, "feature_abnormals", feature_abnormals)

    @_builtins.property
    @pulumi.getter(name="customSign")
    def custom_sign(self) -> Optional[pulumi.Input['WafRuleConfigAppSdkCustomSignArgs']]:
        """
        Custom fields used for mobile app signature validation. See `custom_sign` below.
        """
        return pulumi.get(self, "custom_sign")

    @custom_sign.setter
    def custom_sign(self, value: Optional[pulumi.Input['WafRuleConfigAppSdkCustomSignArgs']]):
        pulumi.set(self, "custom_sign", value)

    @_builtins.property
    @pulumi.getter(name="customSignStatus")
    def custom_sign_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether the custom signature field validation is enabled.
        """
        return pulumi.get(self, "custom_sign_status")

    @custom_sign_status.setter
    def custom_sign_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_sign_status", value)

    @_builtins.property
    @pulumi.getter(name="featureAbnormals")
    def feature_abnormals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Detected abnormal behaviors of the application.
        """
        return pulumi.get(self, "feature_abnormals")

    @feature_abnormals.setter
    def feature_abnormals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "feature_abnormals", value)


if not MYPY:
    class WafRuleConfigAppSdkCustomSignArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom signature field used for validation.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom signature field used for validation.
        """
elif False:
    WafRuleConfigAppSdkCustomSignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigAppSdkCustomSignArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the custom signature field used for validation.
        :param pulumi.Input[_builtins.str] value: The value of the custom signature field used for validation.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom signature field used for validation.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom signature field used for validation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WafRuleConfigManagedRulesetArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        attack_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        The primary attack type targeted by this ruleset.
        """
        managed_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetManagedRuleArgsDict']]]]
        """
        The individual managed rules included in this ruleset. See `managed_rules` below.
        """
        number_enabled: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of rules currently enabled.
        """
        number_total: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of rules in this ruleset.
        """
        protection_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        The protection strength level assigned to this ruleset.
        """
elif False:
    WafRuleConfigManagedRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigManagedRulesetArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 attack_type: Optional[pulumi.Input[_builtins.int]] = None,
                 managed_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetManagedRuleArgs']]]] = None,
                 number_enabled: Optional[pulumi.Input[_builtins.int]] = None,
                 number_total: Optional[pulumi.Input[_builtins.int]] = None,
                 protection_level: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] attack_type: The primary attack type targeted by this ruleset.
        :param pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetManagedRuleArgs']]] managed_rules: The individual managed rules included in this ruleset. See `managed_rules` below.
        :param pulumi.Input[_builtins.int] number_enabled: Number of rules currently enabled.
        :param pulumi.Input[_builtins.int] number_total: Total number of rules in this ruleset.
        :param pulumi.Input[_builtins.int] protection_level: The protection strength level assigned to this ruleset.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if attack_type is not None:
            pulumi.set(__self__, "attack_type", attack_type)
        if managed_rules is not None:
            pulumi.set(__self__, "managed_rules", managed_rules)
        if number_enabled is not None:
            pulumi.set(__self__, "number_enabled", number_enabled)
        if number_total is not None:
            pulumi.set(__self__, "number_total", number_total)
        if protection_level is not None:
            pulumi.set(__self__, "protection_level", protection_level)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="attackType")
    def attack_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The primary attack type targeted by this ruleset.
        """
        return pulumi.get(self, "attack_type")

    @attack_type.setter
    def attack_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "attack_type", value)

    @_builtins.property
    @pulumi.getter(name="managedRules")
    def managed_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetManagedRuleArgs']]]]:
        """
        The individual managed rules included in this ruleset. See `managed_rules` below.
        """
        return pulumi.get(self, "managed_rules")

    @managed_rules.setter
    def managed_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigManagedRulesetManagedRuleArgs']]]]):
        pulumi.set(self, "managed_rules", value)

    @_builtins.property
    @pulumi.getter(name="numberEnabled")
    def number_enabled(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of rules currently enabled.
        """
        return pulumi.get(self, "number_enabled")

    @number_enabled.setter
    def number_enabled(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_enabled", value)

    @_builtins.property
    @pulumi.getter(name="numberTotal")
    def number_total(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of rules in this ruleset.
        """
        return pulumi.get(self, "number_total")

    @number_total.setter
    def number_total(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_total", value)

    @_builtins.property
    @pulumi.getter(name="protectionLevel")
    def protection_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The protection strength level assigned to this ruleset.
        """
        return pulumi.get(self, "protection_level")

    @protection_level.setter
    def protection_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protection_level", value)


if not MYPY:
    class WafRuleConfigManagedRulesetManagedRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The internal unique ID of the WAF rule.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the managed rule: whether it is enabled or disabled.
        """
elif False:
    WafRuleConfigManagedRulesetManagedRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigManagedRulesetManagedRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The internal unique ID of the WAF rule.
        :param pulumi.Input[_builtins.str] status: The status of the managed rule: whether it is enabled or disabled.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The internal unique ID of the WAF rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the managed rule: whether it is enabled or disabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class WafRuleConfigRateLimitArgsDict(TypedDict):
        characteristics: NotRequired[pulumi.Input['WafRuleConfigRateLimitCharacteristicsArgsDict']]
        """
        The statistical dimensions to which the rate limiting rule applies. See `characteristics` below.
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The statistical interval.
        """
        on_hit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the rule applies to requests that hit the cache.
        """
        threshold: NotRequired[pulumi.Input['WafRuleConfigRateLimitThresholdArgsDict']]
        """
        Threshold settings for the rate limiting rule. See `threshold` below.
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout period for creating the stack used in rate limiting.
        """
elif False:
    WafRuleConfigRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitArgs:
    def __init__(__self__, *,
                 characteristics: Optional[pulumi.Input['WafRuleConfigRateLimitCharacteristicsArgs']] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 on_hit: Optional[pulumi.Input[_builtins.bool]] = None,
                 threshold: Optional[pulumi.Input['WafRuleConfigRateLimitThresholdArgs']] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['WafRuleConfigRateLimitCharacteristicsArgs'] characteristics: The statistical dimensions to which the rate limiting rule applies. See `characteristics` below.
        :param pulumi.Input[_builtins.int] interval: The statistical interval.
        :param pulumi.Input[_builtins.bool] on_hit: Indicates whether the rule applies to requests that hit the cache.
        :param pulumi.Input['WafRuleConfigRateLimitThresholdArgs'] threshold: Threshold settings for the rate limiting rule. See `threshold` below.
        :param pulumi.Input[_builtins.int] ttl: The timeout period for creating the stack used in rate limiting.
        """
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if on_hit is not None:
            pulumi.set(__self__, "on_hit", on_hit)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def characteristics(self) -> Optional[pulumi.Input['WafRuleConfigRateLimitCharacteristicsArgs']]:
        """
        The statistical dimensions to which the rate limiting rule applies. See `characteristics` below.
        """
        return pulumi.get(self, "characteristics")

    @characteristics.setter
    def characteristics(self, value: Optional[pulumi.Input['WafRuleConfigRateLimitCharacteristicsArgs']]):
        pulumi.set(self, "characteristics", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The statistical interval.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="onHit")
    def on_hit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the rule applies to requests that hit the cache.
        """
        return pulumi.get(self, "on_hit")

    @on_hit.setter
    def on_hit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "on_hit", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['WafRuleConfigRateLimitThresholdArgs']]:
        """
        Threshold settings for the rate limiting rule. See `threshold` below.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['WafRuleConfigRateLimitThresholdArgs']]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout period for creating the stack used in rate limiting.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class WafRuleConfigRateLimitCharacteristicsArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaArgsDict']]]]
        logic: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleConfigRateLimitCharacteristicsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitCharacteristicsArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaArgs']]]] = None,
                 logic: Optional[pulumi.Input[_builtins.str]] = None):
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if logic is not None:
            pulumi.set(__self__, "logic", logic)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaArgs']]]]:
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logic", value)


if not MYPY:
    class WafRuleConfigRateLimitCharacteristicsCriteriaArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgsDict']]]]
        logic: NotRequired[pulumi.Input[_builtins.str]]
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleConfigRateLimitCharacteristicsCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitCharacteristicsCriteriaArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgs']]]] = None,
                 logic: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if logic is not None:
            pulumi.set(__self__, "logic", logic)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgs']]]]:
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logic", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgsDict']]]]
        logic: NotRequired[pulumi.Input[_builtins.str]]
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgs']]]] = None,
                 logic: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if logic is not None:
            pulumi.set(__self__, "logic", logic)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgs']]]]:
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logic", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitCharacteristicsCriteriaCriteriaCriteriaArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WafRuleConfigRateLimitThresholdArgsDict(TypedDict):
        distinct_managed_rules: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of distinct managed rules that can be triggered.
        """
        managed_rules_blocked: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of times that managed rules can be triggered.
        """
        request: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of allowed requests within a time interval.
        """
        response_status: NotRequired[pulumi.Input['WafRuleConfigRateLimitThresholdResponseStatusArgsDict']]
        """
        Limits on the frequency of returning specific HTTP status codes. See `response_status` below.
        """
        traffic: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum allowed traffic within a time interval (deprecated).
        """
elif False:
    WafRuleConfigRateLimitThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitThresholdArgs:
    def __init__(__self__, *,
                 distinct_managed_rules: Optional[pulumi.Input[_builtins.int]] = None,
                 managed_rules_blocked: Optional[pulumi.Input[_builtins.int]] = None,
                 request: Optional[pulumi.Input[_builtins.int]] = None,
                 response_status: Optional[pulumi.Input['WafRuleConfigRateLimitThresholdResponseStatusArgs']] = None,
                 traffic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] distinct_managed_rules: The maximum number of distinct managed rules that can be triggered.
        :param pulumi.Input[_builtins.int] managed_rules_blocked: The maximum number of times that managed rules can be triggered.
        :param pulumi.Input[_builtins.int] request: The maximum number of allowed requests within a time interval.
        :param pulumi.Input['WafRuleConfigRateLimitThresholdResponseStatusArgs'] response_status: Limits on the frequency of returning specific HTTP status codes. See `response_status` below.
        :param pulumi.Input[_builtins.str] traffic: The maximum allowed traffic within a time interval (deprecated).
        """
        if distinct_managed_rules is not None:
            pulumi.set(__self__, "distinct_managed_rules", distinct_managed_rules)
        if managed_rules_blocked is not None:
            pulumi.set(__self__, "managed_rules_blocked", managed_rules_blocked)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response_status is not None:
            pulumi.set(__self__, "response_status", response_status)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)

    @_builtins.property
    @pulumi.getter(name="distinctManagedRules")
    def distinct_managed_rules(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of distinct managed rules that can be triggered.
        """
        return pulumi.get(self, "distinct_managed_rules")

    @distinct_managed_rules.setter
    def distinct_managed_rules(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "distinct_managed_rules", value)

    @_builtins.property
    @pulumi.getter(name="managedRulesBlocked")
    def managed_rules_blocked(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of times that managed rules can be triggered.
        """
        return pulumi.get(self, "managed_rules_blocked")

    @managed_rules_blocked.setter
    def managed_rules_blocked(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "managed_rules_blocked", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of allowed requests within a time interval.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request", value)

    @_builtins.property
    @pulumi.getter(name="responseStatus")
    def response_status(self) -> Optional[pulumi.Input['WafRuleConfigRateLimitThresholdResponseStatusArgs']]:
        """
        Limits on the frequency of returning specific HTTP status codes. See `response_status` below.
        """
        return pulumi.get(self, "response_status")

    @response_status.setter
    def response_status(self, value: Optional[pulumi.Input['WafRuleConfigRateLimitThresholdResponseStatusArgs']]):
        pulumi.set(self, "response_status", value)

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum allowed traffic within a time interval (deprecated).
        """
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic", value)


if not MYPY:
    class WafRuleConfigRateLimitThresholdResponseStatusArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of times the specified status code can be returned.
        """
        ratio: NotRequired[pulumi.Input[_builtins.int]]
        """
        The upper limit of the percentage of occurrences of the specified status code among all responses.
        """
elif False:
    WafRuleConfigRateLimitThresholdResponseStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigRateLimitThresholdResponseStatusArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 ratio: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: The maximum number of times the specified status code can be returned.
        :param pulumi.Input[_builtins.int] ratio: The upper limit of the percentage of occurrences of the specified status code among all responses.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of times the specified status code can be returned.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def ratio(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The upper limit of the percentage of occurrences of the specified status code among all responses.
        """
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ratio", value)


if not MYPY:
    class WafRuleConfigSecurityLevelArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom signature field used for validation.
        """
elif False:
    WafRuleConfigSecurityLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigSecurityLevelArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The value of the custom signature field used for validation.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom signature field used for validation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WafRuleConfigTimerArgsDict(TypedDict):
        periods: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerPeriodArgsDict']]]]
        scopes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timing type:
        """
        weekly_periods: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodArgsDict']]]]
        """
        Weekly recurring time schedules. See `weekly_periods` below.
        """
        zone: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time zone. If it is not specified, the default value is UTC +00:00.  Example: 8 means East Zone 8,-8 means West Zone 8  Range:-12 -+14
        """
elif False:
    WafRuleConfigTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigTimerArgs:
    def __init__(__self__, *,
                 periods: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerPeriodArgs']]]] = None,
                 scopes: Optional[pulumi.Input[_builtins.str]] = None,
                 weekly_periods: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodArgs']]]] = None,
                 zone: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] scopes: Timing type:
        :param pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodArgs']]] weekly_periods: Weekly recurring time schedules. See `weekly_periods` below.
        :param pulumi.Input[_builtins.int] zone: The time zone. If it is not specified, the default value is UTC +00:00.  Example: 8 means East Zone 8,-8 means West Zone 8  Range:-12 -+14
        """
        if periods is not None:
            pulumi.set(__self__, "periods", periods)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if weekly_periods is not None:
            pulumi.set(__self__, "weekly_periods", weekly_periods)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def periods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerPeriodArgs']]]]:
        return pulumi.get(self, "periods")

    @periods.setter
    def periods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerPeriodArgs']]]]):
        pulumi.set(self, "periods", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timing type:
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="weeklyPeriods")
    def weekly_periods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodArgs']]]]:
        """
        Weekly recurring time schedules. See `weekly_periods` below.
        """
        return pulumi.get(self, "weekly_periods")

    @weekly_periods.setter
    def weekly_periods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodArgs']]]]):
        pulumi.set(self, "weekly_periods", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time zone. If it is not specified, the default value is UTC +00:00.  Example: 8 means East Zone 8,-8 means West Zone 8  Range:-12 -+14
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class WafRuleConfigTimerPeriodArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time in HH:mm:ss format
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time in HH:mm:ss format
        """
elif False:
    WafRuleConfigTimerPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigTimerPeriodArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end: End time in HH:mm:ss format
        :param pulumi.Input[_builtins.str] start: Start time in HH:mm:ss format
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time in HH:mm:ss format
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time in HH:mm:ss format
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class WafRuleConfigTimerWeeklyPeriodArgsDict(TypedDict):
        daily_periods: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodDailyPeriodArgsDict']]]]
        """
        Daily effective time periods within a weekly schedule. See `daily_periods` below.
        """
        days: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cycle, multiple use comma separated, 1-7 respectively represent Monday-Sunday.  Example: Monday, Wednesday value is "1,3"
        """
elif False:
    WafRuleConfigTimerWeeklyPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigTimerWeeklyPeriodArgs:
    def __init__(__self__, *,
                 daily_periods: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodDailyPeriodArgs']]]] = None,
                 days: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodDailyPeriodArgs']]] daily_periods: Daily effective time periods within a weekly schedule. See `daily_periods` below.
        :param pulumi.Input[_builtins.str] days: Cycle, multiple use comma separated, 1-7 respectively represent Monday-Sunday.  Example: Monday, Wednesday value is "1,3"
        """
        if daily_periods is not None:
            pulumi.set(__self__, "daily_periods", daily_periods)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="dailyPeriods")
    def daily_periods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodDailyPeriodArgs']]]]:
        """
        Daily effective time periods within a weekly schedule. See `daily_periods` below.
        """
        return pulumi.get(self, "daily_periods")

    @daily_periods.setter
    def daily_periods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleConfigTimerWeeklyPeriodDailyPeriodArgs']]]]):
        pulumi.set(self, "daily_periods", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cycle, multiple use comma separated, 1-7 respectively represent Monday-Sunday.  Example: Monday, Wednesday value is "1,3"
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class WafRuleConfigTimerWeeklyPeriodDailyPeriodArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time in HH:mm:ss format
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time in HH:mm:ss format
        """
elif False:
    WafRuleConfigTimerWeeklyPeriodDailyPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleConfigTimerWeeklyPeriodDailyPeriodArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end: End time in HH:mm:ss format
        :param pulumi.Input[_builtins.str] start: Start time in HH:mm:ss format
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time in HH:mm:ss format
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time in HH:mm:ss format
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class WafRuleSharedArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default action executed under shared configuration.
        """
        actions: NotRequired[pulumi.Input['WafRuleSharedActionsArgsDict']]
        """
        Extended action configurations under shared settings. See `actions` below.
        """
        cross_site_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify the cross-domain site ID.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        The match expression used in shared configuration.
        """
        match: NotRequired[pulumi.Input['WafRuleSharedMatchArgsDict']]
        """
        Configuration of the request matching logic engine. See `match` below.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The integration mode of the Web SDK:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the ruleset.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target type protected by this rule: web or app.
        """
elif False:
    WafRuleSharedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 actions: Optional[pulumi.Input['WafRuleSharedActionsArgs']] = None,
                 cross_site_id: Optional[pulumi.Input[_builtins.int]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 match: Optional[pulumi.Input['WafRuleSharedMatchArgs']] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The default action executed under shared configuration.
        :param pulumi.Input['WafRuleSharedActionsArgs'] actions: Extended action configurations under shared settings. See `actions` below.
        :param pulumi.Input[_builtins.int] cross_site_id: Specify the cross-domain site ID.
        :param pulumi.Input[_builtins.str] expression: The match expression used in shared configuration.
        :param pulumi.Input['WafRuleSharedMatchArgs'] match: Configuration of the request matching logic engine. See `match` below.
        :param pulumi.Input[_builtins.str] mode: The integration mode of the Web SDK:
        :param pulumi.Input[_builtins.str] name: The display name of the ruleset.
        :param pulumi.Input[_builtins.str] target: The target type protected by this rule: web or app.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if cross_site_id is not None:
            pulumi.set(__self__, "cross_site_id", cross_site_id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default action executed under shared configuration.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['WafRuleSharedActionsArgs']]:
        """
        Extended action configurations under shared settings. See `actions` below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['WafRuleSharedActionsArgs']]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="crossSiteId")
    def cross_site_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify the cross-domain site ID.
        """
        return pulumi.get(self, "cross_site_id")

    @cross_site_id.setter
    def cross_site_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cross_site_id", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The match expression used in shared configuration.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['WafRuleSharedMatchArgs']]:
        """
        Configuration of the request matching logic engine. See `match` below.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['WafRuleSharedMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The integration mode of the Web SDK:
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target type protected by this rule: web or app.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WafRuleSharedActionsArgsDict(TypedDict):
        response: NotRequired[pulumi.Input['WafRuleSharedActionsResponseArgsDict']]
elif False:
    WafRuleSharedActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedActionsArgs:
    def __init__(__self__, *,
                 response: Optional[pulumi.Input['WafRuleSharedActionsResponseArgs']] = None):
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['WafRuleSharedActionsResponseArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['WafRuleSharedActionsResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class WafRuleSharedActionsResponseArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The internal unique ID of the WAF rule.
        """
elif False:
    WafRuleSharedActionsResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedActionsResponseArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The internal unique ID of the WAF rule.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The internal unique ID of the WAF rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class WafRuleSharedMatchArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaArgsDict']]]]
        logic: NotRequired[pulumi.Input[_builtins.str]]
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleSharedMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedMatchArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaArgs']]]] = None,
                 logic: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if logic is not None:
            pulumi.set(__self__, "logic", logic)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaArgs']]]]:
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logic", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WafRuleSharedMatchCriteriaArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaArgsDict']]]]
        logic: NotRequired[pulumi.Input[_builtins.str]]
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleSharedMatchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedMatchCriteriaArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaArgs']]]] = None,
                 logic: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if logic is not None:
            pulumi.set(__self__, "logic", logic)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaArgs']]]]:
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logic", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WafRuleSharedMatchCriteriaCriteriaArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaCriteriaArgsDict']]]]
        logic: NotRequired[pulumi.Input[_builtins.str]]
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleSharedMatchCriteriaCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedMatchCriteriaCriteriaArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaCriteriaArgs']]]] = None,
                 logic: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if logic is not None:
            pulumi.set(__self__, "logic", logic)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaCriteriaArgs']]]]:
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafRuleSharedMatchCriteriaCriteriaCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logic", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WafRuleSharedMatchCriteriaCriteriaCriteriaArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WafRuleSharedMatchCriteriaCriteriaCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafRuleSharedMatchCriteriaCriteriaCriteriaArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class WaitingRoomHostNameAndPathArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The domain name.
        """
        path: pulumi.Input[_builtins.str]
        """
        The path.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        The subdomain.
        """
elif False:
    WaitingRoomHostNameAndPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomHostNameAndPathArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The domain name.
        :param pulumi.Input[_builtins.str] path: The path.
        :param pulumi.Input[_builtins.str] subdomain: The subdomain.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "subdomain", subdomain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        The subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)


