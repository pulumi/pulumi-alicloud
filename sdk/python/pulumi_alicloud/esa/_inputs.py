# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'HttpRequestHeaderModificationRuleRequestHeaderModificationArgs',
    'HttpRequestHeaderModificationRuleRequestHeaderModificationArgsDict',
    'HttpResponseHeaderModificationRuleResponseHeaderModificationArgs',
    'HttpResponseHeaderModificationRuleResponseHeaderModificationArgsDict',
    'OriginPoolOriginArgs',
    'OriginPoolOriginArgsDict',
    'OriginPoolOriginAuthConfArgs',
    'OriginPoolOriginAuthConfArgsDict',
    'RecordAuthConfArgs',
    'RecordAuthConfArgsDict',
    'RecordDataArgs',
    'RecordDataArgsDict',
    'SiteDeliveryTaskHttpDeliveryArgs',
    'SiteDeliveryTaskHttpDeliveryArgsDict',
    'SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs',
    'SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict',
    'SiteDeliveryTaskKafkaDeliveryArgs',
    'SiteDeliveryTaskKafkaDeliveryArgsDict',
    'SiteDeliveryTaskOssDeliveryArgs',
    'SiteDeliveryTaskOssDeliveryArgsDict',
    'SiteDeliveryTaskS3DeliveryArgs',
    'SiteDeliveryTaskS3DeliveryArgsDict',
    'SiteDeliveryTaskSlsDeliveryArgs',
    'SiteDeliveryTaskSlsDeliveryArgsDict',
    'TransportLayerApplicationRuleArgs',
    'TransportLayerApplicationRuleArgsDict',
    'WaitingRoomHostNameAndPathArgs',
    'WaitingRoomHostNameAndPathArgsDict',
]

MYPY = False

if not MYPY:
    class HttpRequestHeaderModificationRuleRequestHeaderModificationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Request Header Name.
        """
        operation: pulumi.Input[_builtins.str]
        """
        Mode of operation. Value range:
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Request header value
        """
elif False:
    HttpRequestHeaderModificationRuleRequestHeaderModificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRequestHeaderModificationRuleRequestHeaderModificationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Request Header Name.
        :param pulumi.Input[_builtins.str] operation: Mode of operation. Value range:
        :param pulumi.Input[_builtins.str] value: Request header value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Request Header Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        Mode of operation. Value range:
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Request header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HttpResponseHeaderModificationRuleResponseHeaderModificationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The response header name.
        """
        operation: pulumi.Input[_builtins.str]
        """
        Operation method. Possible values:
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The response header value.
        """
elif False:
    HttpResponseHeaderModificationRuleResponseHeaderModificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpResponseHeaderModificationRuleResponseHeaderModificationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The response header name.
        :param pulumi.Input[_builtins.str] operation: Operation method. Possible values:
        :param pulumi.Input[_builtins.str] value: The response header value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation", operation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The response header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        Operation method. Possible values:
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The response header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OriginPoolOriginArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin Address.
        """
        auth_conf: NotRequired[pulumi.Input['OriginPoolOriginAuthConfArgsDict']]
        """
        The authentication information. When the source Station is an OSS or S3 and other source stations need to be authenticated, the authentication-related configuration information needs to be transmitted. See `auth_conf` below.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the source station is enabled:
        """
        header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request header that is sent when returning to the source. Only Host is supported.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Origin Name.
        """
        origin_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Origin ID.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source station type:
        ip_domain: ip or domain name type origin station;
        - `OSS`:OSS address source station;
        - `S3`:AWS S3 Source station.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight, 0-100.
        """
elif False:
    OriginPoolOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginPoolOriginArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_conf: Optional[pulumi.Input['OriginPoolOriginAuthConfArgs']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 header: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_id: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Origin Address.
        :param pulumi.Input['OriginPoolOriginAuthConfArgs'] auth_conf: The authentication information. When the source Station is an OSS or S3 and other source stations need to be authenticated, the authentication-related configuration information needs to be transmitted. See `auth_conf` below.
        :param pulumi.Input[_builtins.bool] enabled: Whether the source station is enabled:
        :param pulumi.Input[_builtins.str] header: The request header that is sent when returning to the source. Only Host is supported.
        :param pulumi.Input[_builtins.str] name: Origin Name.
        :param pulumi.Input[_builtins.int] origin_id: Origin ID.
        :param pulumi.Input[_builtins.str] type: Source station type:
               ip_domain: ip or domain name type origin station;
               - `OSS`:OSS address source station;
               - `S3`:AWS S3 Source station.
        :param pulumi.Input[_builtins.int] weight: Weight, 0-100.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if auth_conf is not None:
            pulumi.set(__self__, "auth_conf", auth_conf)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin Address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="authConf")
    def auth_conf(self) -> Optional[pulumi.Input['OriginPoolOriginAuthConfArgs']]:
        """
        The authentication information. When the source Station is an OSS or S3 and other source stations need to be authenticated, the authentication-related configuration information needs to be transmitted. See `auth_conf` below.
        """
        return pulumi.get(self, "auth_conf")

    @auth_conf.setter
    def auth_conf(self, value: Optional[pulumi.Input['OriginPoolOriginAuthConfArgs']]):
        pulumi.set(self, "auth_conf", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the source station is enabled:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request header that is sent when returning to the source. Only Host is supported.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Origin Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Origin ID.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source station type:
        ip_domain: ip or domain name type origin station;
        - `OSS`:OSS address source station;
        - `S3`:AWS S3 Source station.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight, 0-100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class OriginPoolOriginAuthConfArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AccessKey to be passed when AuthType is set to private_cross_account or private.
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication type.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Region of the source station to be transmitted when the source station is AWS S3.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SecretKey to be passed when AuthType is set to private_cross_account or private.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signature version to be transmitted when the source station is AWS S3.
        """
elif False:
    OriginPoolOriginAuthConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginPoolOriginAuthConfArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The AccessKey to be passed when AuthType is set to private_cross_account or private.
        :param pulumi.Input[_builtins.str] auth_type: Authentication type.
        :param pulumi.Input[_builtins.str] region: The Region of the source station to be transmitted when the source station is AWS S3.
        :param pulumi.Input[_builtins.str] secret_key: The SecretKey to be passed when AuthType is set to private_cross_account or private.
        :param pulumi.Input[_builtins.str] version: The signature version to be transmitted when the source station is AWS S3.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AccessKey to be passed when AuthType is set to private_cross_account or private.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication type.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Region of the source station to be transmitted when the source station is AWS S3.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SecretKey to be passed when AuthType is set to private_cross_account or private.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signature version to be transmitted when the source station is AWS S3.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RecordAuthConfArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
        """
elif False:
    RecordAuthConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordAuthConfArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        :param pulumi.Input[_builtins.str] auth_type: The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
        :param pulumi.Input[_builtins.str] region: The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
        :param pulumi.Input[_builtins.str] secret_key: The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        :param pulumi.Input[_builtins.str] version: The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.int]]
        """
        The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
        """
        fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
        """
        flag: NotRequired[pulumi.Input[_builtins.int]]
        """
        The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
        """
        key_tag: NotRequired[pulumi.Input[_builtins.int]]
        """
        The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
        """
        matching_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
        """
        selector: NotRequired[pulumi.Input[_builtins.int]]
        """
        The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record.
        """
        type: NotRequired[pulumi.Input[_builtins.int]]
        """
        The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
        """
        usage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on different types of records:

        - **A/AAAA**: the IP address(es). Separate multiple IPs with commas (,). You must have at least one IPv4 address.
        - `CNAME`: the target domain name.
        - `NS`: the name servers for the domain name.
        - `MX`: a valid domain name of the target mail server.
        - `TXT`: a valid text string.
        - `CAA`: a valid domain name of the certificate authority.
        - `SRV`: a valid domain name of the target host.
        - `URI`: a valid URI string.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
        """
elif False:
    RecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.int]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 flag: Optional[pulumi.Input[_builtins.int]] = None,
                 key_tag: Optional[pulumi.Input[_builtins.int]] = None,
                 matching_type: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 selector: Optional[pulumi.Input[_builtins.int]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.int]] = None,
                 usage: Optional[pulumi.Input[_builtins.int]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] algorithm: The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
        :param pulumi.Input[_builtins.str] certificate: The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
        :param pulumi.Input[_builtins.str] fingerprint: The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
        :param pulumi.Input[_builtins.int] flag: The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
        :param pulumi.Input[_builtins.int] key_tag: The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
        :param pulumi.Input[_builtins.int] matching_type: The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        :param pulumi.Input[_builtins.int] port: The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
        :param pulumi.Input[_builtins.int] priority: The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
        :param pulumi.Input[_builtins.int] selector: The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        :param pulumi.Input[_builtins.str] tag: The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record.
        :param pulumi.Input[_builtins.int] type: The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
        :param pulumi.Input[_builtins.int] usage: The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        :param pulumi.Input[_builtins.str] value: The record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on different types of records:
               
               - **A/AAAA**: the IP address(es). Separate multiple IPs with commas (,). You must have at least one IPv4 address.
               - `CNAME`: the target domain name.
               - `NS`: the name servers for the domain name.
               - `MX`: a valid domain name of the target mail server.
               - `TXT`: a valid text string.
               - `CAA`: a valid domain name of the certificate authority.
               - `SRV`: a valid domain name of the target host.
               - `URI`: a valid URI string.
        :param pulumi.Input[_builtins.int] weight: The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flag is not None:
            pulumi.set(__self__, "flag", flag)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @_builtins.property
    @pulumi.getter
    def flag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
        """
        return pulumi.get(self, "flag")

    @flag.setter
    def flag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "flag", value)

    @_builtins.property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
        """
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_tag", value)

    @_builtins.property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "matching_type", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "usage", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on different types of records:

        - **A/AAAA**: the IP address(es). Separate multiple IPs with commas (,). You must have at least one IPv4 address.
        - `CNAME`: the target domain name.
        - `NS`: the name servers for the domain name.
        - `MX`: a valid domain name of the target mail server.
        - `TXT`: a valid text string.
        - `CAA`: a valid domain name of the certificate authority.
        - `SRV`: a valid domain name of the target host.
        - `URI`: a valid URI string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class SiteDeliveryTaskHttpDeliveryArgsDict(TypedDict):
        compress: NotRequired[pulumi.Input[_builtins.str]]
        dest_url: NotRequired[pulumi.Input[_builtins.str]]
        header_param: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        log_body_prefix: NotRequired[pulumi.Input[_builtins.str]]
        log_body_suffix: NotRequired[pulumi.Input[_builtins.str]]
        max_batch_mb: NotRequired[pulumi.Input[_builtins.int]]
        max_batch_size: NotRequired[pulumi.Input[_builtins.int]]
        max_retry: NotRequired[pulumi.Input[_builtins.int]]
        query_param: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        standard_auth_on: NotRequired[pulumi.Input[_builtins.bool]]
        standard_auth_param: NotRequired[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict']]
        """
        See `standard_auth_param` below.
        """
        transform_timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    SiteDeliveryTaskHttpDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskHttpDeliveryArgs:
    def __init__(__self__, *,
                 compress: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_url: Optional[pulumi.Input[_builtins.str]] = None,
                 header_param: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 log_body_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_body_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 max_batch_mb: Optional[pulumi.Input[_builtins.int]] = None,
                 max_batch_size: Optional[pulumi.Input[_builtins.int]] = None,
                 max_retry: Optional[pulumi.Input[_builtins.int]] = None,
                 query_param: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 standard_auth_on: Optional[pulumi.Input[_builtins.bool]] = None,
                 standard_auth_param: Optional[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs']] = None,
                 transform_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs'] standard_auth_param: See `standard_auth_param` below.
        """
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if dest_url is not None:
            pulumi.set(__self__, "dest_url", dest_url)
        if header_param is not None:
            pulumi.set(__self__, "header_param", header_param)
        if log_body_prefix is not None:
            pulumi.set(__self__, "log_body_prefix", log_body_prefix)
        if log_body_suffix is not None:
            pulumi.set(__self__, "log_body_suffix", log_body_suffix)
        if max_batch_mb is not None:
            pulumi.set(__self__, "max_batch_mb", max_batch_mb)
        if max_batch_size is not None:
            pulumi.set(__self__, "max_batch_size", max_batch_size)
        if max_retry is not None:
            pulumi.set(__self__, "max_retry", max_retry)
        if query_param is not None:
            pulumi.set(__self__, "query_param", query_param)
        if standard_auth_on is not None:
            pulumi.set(__self__, "standard_auth_on", standard_auth_on)
        if standard_auth_param is not None:
            pulumi.set(__self__, "standard_auth_param", standard_auth_param)
        if transform_timeout is not None:
            pulumi.set(__self__, "transform_timeout", transform_timeout)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="destUrl")
    def dest_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dest_url")

    @dest_url.setter
    def dest_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_url", value)

    @_builtins.property
    @pulumi.getter(name="headerParam")
    def header_param(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "header_param")

    @header_param.setter
    def header_param(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header_param", value)

    @_builtins.property
    @pulumi.getter(name="logBodyPrefix")
    def log_body_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_body_prefix")

    @log_body_prefix.setter
    def log_body_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_body_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logBodySuffix")
    def log_body_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_body_suffix")

    @log_body_suffix.setter
    def log_body_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_body_suffix", value)

    @_builtins.property
    @pulumi.getter(name="maxBatchMb")
    def max_batch_mb(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_batch_mb")

    @max_batch_mb.setter
    def max_batch_mb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_batch_mb", value)

    @_builtins.property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_batch_size")

    @max_batch_size.setter
    def max_batch_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_batch_size", value)

    @_builtins.property
    @pulumi.getter(name="maxRetry")
    def max_retry(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_retry")

    @max_retry.setter
    def max_retry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_retry", value)

    @_builtins.property
    @pulumi.getter(name="queryParam")
    def query_param(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "query_param")

    @query_param.setter
    def query_param(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_param", value)

    @_builtins.property
    @pulumi.getter(name="standardAuthOn")
    def standard_auth_on(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "standard_auth_on")

    @standard_auth_on.setter
    def standard_auth_on(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "standard_auth_on", value)

    @_builtins.property
    @pulumi.getter(name="standardAuthParam")
    def standard_auth_param(self) -> Optional[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs']]:
        """
        See `standard_auth_param` below.
        """
        return pulumi.get(self, "standard_auth_param")

    @standard_auth_param.setter
    def standard_auth_param(self, value: Optional[pulumi.Input['SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs']]):
        pulumi.set(self, "standard_auth_param", value)

    @_builtins.property
    @pulumi.getter(name="transformTimeout")
    def transform_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "transform_timeout")

    @transform_timeout.setter
    def transform_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transform_timeout", value)


if not MYPY:
    class SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict(TypedDict):
        expired_time: NotRequired[pulumi.Input[_builtins.int]]
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        url_path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteDeliveryTaskHttpDeliveryStandardAuthParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskHttpDeliveryStandardAuthParamArgs:
    def __init__(__self__, *,
                 expired_time: Optional[pulumi.Input[_builtins.int]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 url_path: Optional[pulumi.Input[_builtins.str]] = None):
        if expired_time is not None:
            pulumi.set(__self__, "expired_time", expired_time)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @_builtins.property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expired_time")

    @expired_time.setter
    def expired_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expired_time", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "url_path")

    @url_path.setter
    def url_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_path", value)


if not MYPY:
    class SiteDeliveryTaskKafkaDeliveryArgsDict(TypedDict):
        balancer: NotRequired[pulumi.Input[_builtins.str]]
        brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        compress: NotRequired[pulumi.Input[_builtins.str]]
        """
        The compression method. By default, data is not compressed.
        """
        machanism_type: NotRequired[pulumi.Input[_builtins.str]]
        password: NotRequired[pulumi.Input[_builtins.str]]
        topic: NotRequired[pulumi.Input[_builtins.str]]
        user_auth: NotRequired[pulumi.Input[_builtins.bool]]
        user_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteDeliveryTaskKafkaDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskKafkaDeliveryArgs:
    def __init__(__self__, *,
                 balancer: Optional[pulumi.Input[_builtins.str]] = None,
                 brokers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 compress: Optional[pulumi.Input[_builtins.str]] = None,
                 machanism_type: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None,
                 user_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compress: The compression method. By default, data is not compressed.
        """
        if balancer is not None:
            pulumi.set(__self__, "balancer", balancer)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if machanism_type is not None:
            pulumi.set(__self__, "machanism_type", machanism_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if user_auth is not None:
            pulumi.set(__self__, "user_auth", user_auth)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def balancer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "balancer")

    @balancer.setter
    def balancer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "balancer", value)

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "brokers", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The compression method. By default, data is not compressed.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="machanismType")
    def machanism_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "machanism_type")

    @machanism_type.setter
    def machanism_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machanism_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="userAuth")
    def user_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "user_auth")

    @user_auth.setter
    def user_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "user_auth", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class SiteDeliveryTaskOssDeliveryArgsDict(TypedDict):
        aliuid: NotRequired[pulumi.Input[_builtins.str]]
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        prefix_path: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region ID of the service.
        """
elif False:
    SiteDeliveryTaskOssDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskOssDeliveryArgs:
    def __init__(__self__, *,
                 aliuid: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_path: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: The region ID of the service.
        """
        if aliuid is not None:
            pulumi.set(__self__, "aliuid", aliuid)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def aliuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aliuid")

    @aliuid.setter
    def aliuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aliuid", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix_path")

    @prefix_path.setter
    def prefix_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region ID of the service.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class SiteDeliveryTaskS3DeliveryArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        bucket_path: NotRequired[pulumi.Input[_builtins.str]]
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        prefix_path: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        s3_cmpt: NotRequired[pulumi.Input[_builtins.bool]]
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        server_side_encryption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Server-side encryption
        """
        vertify_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication Type
        """
elif False:
    SiteDeliveryTaskS3DeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskS3DeliveryArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_path: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix_path: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_cmpt: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 server_side_encryption: Optional[pulumi.Input[_builtins.bool]] = None,
                 vertify_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] server_side_encryption: Server-side encryption
        :param pulumi.Input[_builtins.str] vertify_type: Authentication Type
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_path is not None:
            pulumi.set(__self__, "bucket_path", bucket_path)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if s3_cmpt is not None:
            pulumi.set(__self__, "s3_cmpt", s3_cmpt)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if vertify_type is not None:
            pulumi.set(__self__, "vertify_type", vertify_type)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_path")

    @bucket_path.setter
    def bucket_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_path", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix_path")

    @prefix_path.setter
    def prefix_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="s3Cmpt")
    def s3_cmpt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "s3_cmpt")

    @s3_cmpt.setter
    def s3_cmpt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "s3_cmpt", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Server-side encryption
        """
        return pulumi.get(self, "server_side_encryption")

    @server_side_encryption.setter
    def server_side_encryption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_side_encryption", value)

    @_builtins.property
    @pulumi.getter(name="vertifyType")
    def vertify_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication Type
        """
        return pulumi.get(self, "vertify_type")

    @vertify_type.setter
    def vertify_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vertify_type", value)


if not MYPY:
    class SiteDeliveryTaskSlsDeliveryArgsDict(TypedDict):
        sls_log_store: NotRequired[pulumi.Input[_builtins.str]]
        sls_project: NotRequired[pulumi.Input[_builtins.str]]
        sls_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SiteDeliveryTaskSlsDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDeliveryTaskSlsDeliveryArgs:
    def __init__(__self__, *,
                 sls_log_store: Optional[pulumi.Input[_builtins.str]] = None,
                 sls_project: Optional[pulumi.Input[_builtins.str]] = None,
                 sls_region: Optional[pulumi.Input[_builtins.str]] = None):
        if sls_log_store is not None:
            pulumi.set(__self__, "sls_log_store", sls_log_store)
        if sls_project is not None:
            pulumi.set(__self__, "sls_project", sls_project)
        if sls_region is not None:
            pulumi.set(__self__, "sls_region", sls_region)

    @_builtins.property
    @pulumi.getter(name="slsLogStore")
    def sls_log_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sls_log_store")

    @sls_log_store.setter
    def sls_log_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_log_store", value)

    @_builtins.property
    @pulumi.getter(name="slsProject")
    def sls_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sls_project")

    @sls_project.setter
    def sls_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_project", value)

    @_builtins.property
    @pulumi.getter(name="slsRegion")
    def sls_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sls_region")

    @sls_region.setter
    def sls_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_region", value)


if not MYPY:
    class TransportLayerApplicationRuleArgsDict(TypedDict):
        client_ip_pass_through_mode: pulumi.Input[_builtins.str]
        """
        Client IP pass-through protocol, supporting:
        """
        edge_port: pulumi.Input[_builtins.str]
        """
        Edge port. Supports:
        - A single port, such as 80.
        - Port range, such as 81-85, representing ports 81, 82, 83, 84, and 85.
        - Combination of ports and port ranges, separated by commas, such as 80,81-85,90, representing ports 80, 81, 82, 83, 84, 85, and 90.

        Edge ports within a single rule and between multiple rules must not overlap.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Forwarding rule protocol, with values:
        - `TCP`: TCP protocol.
        - `UDP`: UDP protocol.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specific value of the origin, which needs to match the origin type.
        """
        source_port: pulumi.Input[_builtins.str]
        """
        Source Port
        """
        source_type: pulumi.Input[_builtins.str]
        """
        Origin type, supporting:
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment information for the rule (optional).
        """
        rule_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rule ID
        """
elif False:
    TransportLayerApplicationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransportLayerApplicationRuleArgs:
    def __init__(__self__, *,
                 client_ip_pass_through_mode: pulumi.Input[_builtins.str],
                 edge_port: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 source_port: pulumi.Input[_builtins.str],
                 source_type: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] client_ip_pass_through_mode: Client IP pass-through protocol, supporting:
        :param pulumi.Input[_builtins.str] edge_port: Edge port. Supports:
               - A single port, such as 80.
               - Port range, such as 81-85, representing ports 81, 82, 83, 84, and 85.
               - Combination of ports and port ranges, separated by commas, such as 80,81-85,90, representing ports 80, 81, 82, 83, 84, 85, and 90.
               
               Edge ports within a single rule and between multiple rules must not overlap.
        :param pulumi.Input[_builtins.str] protocol: Forwarding rule protocol, with values:
               - `TCP`: TCP protocol.
               - `UDP`: UDP protocol.
        :param pulumi.Input[_builtins.str] source: Specific value of the origin, which needs to match the origin type.
        :param pulumi.Input[_builtins.str] source_port: Source Port
        :param pulumi.Input[_builtins.str] source_type: Origin type, supporting:
        :param pulumi.Input[_builtins.str] comment: Comment information for the rule (optional).
        :param pulumi.Input[_builtins.int] rule_id: Rule ID
        """
        pulumi.set(__self__, "client_ip_pass_through_mode", client_ip_pass_through_mode)
        pulumi.set(__self__, "edge_port", edge_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_port", source_port)
        pulumi.set(__self__, "source_type", source_type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @_builtins.property
    @pulumi.getter(name="clientIpPassThroughMode")
    def client_ip_pass_through_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Client IP pass-through protocol, supporting:
        """
        return pulumi.get(self, "client_ip_pass_through_mode")

    @client_ip_pass_through_mode.setter
    def client_ip_pass_through_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_ip_pass_through_mode", value)

    @_builtins.property
    @pulumi.getter(name="edgePort")
    def edge_port(self) -> pulumi.Input[_builtins.str]:
        """
        Edge port. Supports:
        - A single port, such as 80.
        - Port range, such as 81-85, representing ports 81, 82, 83, 84, and 85.
        - Combination of ports and port ranges, separated by commas, such as 80,81-85,90, representing ports 80, 81, 82, 83, 84, 85, and 90.

        Edge ports within a single rule and between multiple rules must not overlap.
        """
        return pulumi.get(self, "edge_port")

    @edge_port.setter
    def edge_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "edge_port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Forwarding rule protocol, with values:
        - `TCP`: TCP protocol.
        - `UDP`: UDP protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specific value of the origin, which needs to match the origin type.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[_builtins.str]:
        """
        Source Port
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_port", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        Origin type, supporting:
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment information for the rule (optional).
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rule ID
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_id", value)


if not MYPY:
    class WaitingRoomHostNameAndPathArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The domain name.
        """
        path: pulumi.Input[_builtins.str]
        """
        The path.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        The subdomain.
        """
elif False:
    WaitingRoomHostNameAndPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomHostNameAndPathArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The domain name.
        :param pulumi.Input[_builtins.str] path: The path.
        :param pulumi.Input[_builtins.str] subdomain: The subdomain.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "subdomain", subdomain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        The subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)


