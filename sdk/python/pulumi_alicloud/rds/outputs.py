# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'DbInstanceEndpointNodeItem',
    'DdrInstanceParameter',
    'DdrInstancePgHbaConf',
    'InstanceBabelfishConfig',
    'InstanceParameter',
    'InstancePgHbaConf',
    'InstanceServerlessConfig',
    'RdsCloneDbInstanceParameter',
    'RdsCloneDbInstancePgHbaConf',
    'RdsCloneDbInstanceServerlessConfig',
    'RdsDbProxyReadOnlyInstanceWeight',
    'RdsParameterGroupParamDetail',
    'RdsUpgradeDbInstanceParameter',
    'RdsUpgradeDbInstancePgHbaConf',
    'ReadOnlyInstanceParameter',
    'GetAccountsAccountResult',
    'GetAccountsAccountDatabasePrivilegeResult',
    'GetCollationTimeZonesCollationTimeZoneResult',
    'GetCrossRegionBackupsBackupResult',
    'GetCrossRegionsRegionResult',
    'GetInstanceClassInfosInfoResult',
    'GetInstanceClassesInstanceClassResult',
    'GetInstanceClassesInstanceClassStorageRangeResult',
    'GetInstanceClassesInstanceClassZoneIdResult',
    'GetInstanceEnginesInstanceEngineResult',
    'GetInstanceEnginesInstanceEngineZoneIdResult',
    'GetInstancesInstanceResult',
    'GetInstancesInstanceHostInstanceInfoResult',
    'GetInstancesInstanceParameterResult',
    'GetModifyParameterLogsLogResult',
    'GetRdsBackupsBackupResult',
    'GetRdsParameterGroupsGroupResult',
    'GetRdsParameterGroupsGroupParamDetailResult',
    'GetSlotsSlotResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class DbInstanceEndpointNodeItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeId":
            suggest = "node_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbInstanceEndpointNodeItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbInstanceEndpointNodeItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbInstanceEndpointNodeItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_id: str,
                 weight: int):
        """
        :param str node_id: The ID of the node.
        :param int weight: The weight of the node. Read requests are distributed based on the weight.Valid values: 0 to 100.
        """
        DbInstanceEndpointNodeItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_id=node_id,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_id: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("node_id", node_id)
        _setter("weight", weight)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        The ID of the node.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of the node. Read requests are distributed based on the weight.Valid values: 0 to 100.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DdrInstanceParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The parameter name.
        :param str value: The parameter value.
        """
        DdrInstanceParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DdrInstancePgHbaConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "priorityId":
            suggest = "priority_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdrInstancePgHbaConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdrInstancePgHbaConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdrInstancePgHbaConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 database: str,
                 method: str,
                 priority_id: int,
                 type: str,
                 user: str,
                 mask: Optional[str] = None,
                 option: Optional[str] = None):
        """
        :param str address: The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        :param str database: The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        :param str method: The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        :param int priority_id: The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        :param str type: The type of connection to the instance. Valid values:
               * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
               * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
               * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
               
               > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        :param str user: The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        :param str mask: The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        :param str option: Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        DdrInstancePgHbaConf._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            database=database,
            method=method,
            priority_id=priority_id,
            type=type,
            user=user,
            mask=mask,
            option=option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             database: Optional[str] = None,
             method: Optional[str] = None,
             priority_id: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             mask: Optional[str] = None,
             option: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if database is None:
            raise TypeError("Missing 'database' argument")
        if method is None:
            raise TypeError("Missing 'method' argument")
        if priority_id is None and 'priorityId' in kwargs:
            priority_id = kwargs['priorityId']
        if priority_id is None:
            raise TypeError("Missing 'priority_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")

        _setter("address", address)
        _setter("database", database)
        _setter("method", method)
        _setter("priority_id", priority_id)
        _setter("type", type)
        _setter("user", user)
        if mask is not None:
            _setter("mask", mask)
        if option is not None:
            _setter("option", option)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="priorityId")
    def priority_id(self) -> int:
        """
        The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        """
        return pulumi.get(self, "priority_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of connection to the instance. Valid values:
        * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
        * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
        * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.

        > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        """
        The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        """
        return pulumi.get(self, "mask")

    @property
    @pulumi.getter
    def option(self) -> Optional[str]:
        """
        Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        return pulumi.get(self, "option")


@pulumi.output_type
class InstanceBabelfishConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "babelfishEnabled":
            suggest = "babelfish_enabled"
        elif key == "masterUserPassword":
            suggest = "master_user_password"
        elif key == "masterUsername":
            suggest = "master_username"
        elif key == "migrationMode":
            suggest = "migration_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBabelfishConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBabelfishConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBabelfishConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 babelfish_enabled: str,
                 master_user_password: str,
                 master_username: str,
                 migration_mode: str):
        """
        :param str babelfish_enabled: specifies whether to enable the Babelfish for the instance. If you set this parameter to **true**, you enable Babelfish for the instance. If you leave this parameter empty, you disable Babelfish for the instance.
        :param str master_user_password: The password of the administrator account. The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. It must be 8 to 32 characters in length. The password can contain any of the following characters:! @ # $ % ^ & * () _ + - =
        :param str master_username: The name of the administrator account. The name can contain lowercase letters, digits, and underscores (_). It must start with a letter and end with a letter or digit. It can be up to 63 characters in length and cannot start with pg.
        :param str migration_mode: The migration mode of the instance. Valid values: **single-db** and **multi-db**.
        """
        InstanceBabelfishConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            babelfish_enabled=babelfish_enabled,
            master_user_password=master_user_password,
            master_username=master_username,
            migration_mode=migration_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             babelfish_enabled: Optional[str] = None,
             master_user_password: Optional[str] = None,
             master_username: Optional[str] = None,
             migration_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if babelfish_enabled is None and 'babelfishEnabled' in kwargs:
            babelfish_enabled = kwargs['babelfishEnabled']
        if babelfish_enabled is None:
            raise TypeError("Missing 'babelfish_enabled' argument")
        if master_user_password is None and 'masterUserPassword' in kwargs:
            master_user_password = kwargs['masterUserPassword']
        if master_user_password is None:
            raise TypeError("Missing 'master_user_password' argument")
        if master_username is None and 'masterUsername' in kwargs:
            master_username = kwargs['masterUsername']
        if master_username is None:
            raise TypeError("Missing 'master_username' argument")
        if migration_mode is None and 'migrationMode' in kwargs:
            migration_mode = kwargs['migrationMode']
        if migration_mode is None:
            raise TypeError("Missing 'migration_mode' argument")

        _setter("babelfish_enabled", babelfish_enabled)
        _setter("master_user_password", master_user_password)
        _setter("master_username", master_username)
        _setter("migration_mode", migration_mode)

    @property
    @pulumi.getter(name="babelfishEnabled")
    def babelfish_enabled(self) -> str:
        """
        specifies whether to enable the Babelfish for the instance. If you set this parameter to **true**, you enable Babelfish for the instance. If you leave this parameter empty, you disable Babelfish for the instance.
        """
        return pulumi.get(self, "babelfish_enabled")

    @property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> str:
        """
        The password of the administrator account. The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. It must be 8 to 32 characters in length. The password can contain any of the following characters:! @ # $ % ^ & * () _ + - =
        """
        return pulumi.get(self, "master_user_password")

    @property
    @pulumi.getter(name="masterUsername")
    def master_username(self) -> str:
        """
        The name of the administrator account. The name can contain lowercase letters, digits, and underscores (_). It must start with a letter and end with a letter or digit. It can be up to 63 characters in length and cannot start with pg.
        """
        return pulumi.get(self, "master_username")

    @property
    @pulumi.getter(name="migrationMode")
    def migration_mode(self) -> str:
        """
        The migration mode of the instance. Valid values: **single-db** and **multi-db**.
        """
        return pulumi.get(self, "migration_mode")


@pulumi.output_type
class InstanceParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The parameter name.
        :param str value: The parameter value.
        """
        InstanceParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstancePgHbaConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "priorityId":
            suggest = "priority_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePgHbaConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePgHbaConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePgHbaConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 database: str,
                 method: str,
                 priority_id: int,
                 type: str,
                 user: str,
                 mask: Optional[str] = None,
                 option: Optional[str] = None):
        """
        :param str address: The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        :param str database: The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        :param str method: The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        :param int priority_id: The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        :param str type: The type of connection to the instance. Valid values:
               * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
               * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
               * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
               
               > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        :param str user: The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        :param str mask: The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        :param str option: Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        InstancePgHbaConf._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            database=database,
            method=method,
            priority_id=priority_id,
            type=type,
            user=user,
            mask=mask,
            option=option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             database: Optional[str] = None,
             method: Optional[str] = None,
             priority_id: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             mask: Optional[str] = None,
             option: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if database is None:
            raise TypeError("Missing 'database' argument")
        if method is None:
            raise TypeError("Missing 'method' argument")
        if priority_id is None and 'priorityId' in kwargs:
            priority_id = kwargs['priorityId']
        if priority_id is None:
            raise TypeError("Missing 'priority_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")

        _setter("address", address)
        _setter("database", database)
        _setter("method", method)
        _setter("priority_id", priority_id)
        _setter("type", type)
        _setter("user", user)
        if mask is not None:
            _setter("mask", mask)
        if option is not None:
            _setter("option", option)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="priorityId")
    def priority_id(self) -> int:
        """
        The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        """
        return pulumi.get(self, "priority_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of connection to the instance. Valid values:
        * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
        * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
        * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.

        > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        """
        The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        """
        return pulumi.get(self, "mask")

    @property
    @pulumi.getter
    def option(self) -> Optional[str]:
        """
        Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        return pulumi.get(self, "option")


@pulumi.output_type
class InstanceServerlessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"
        elif key == "autoPause":
            suggest = "auto_pause"
        elif key == "switchForce":
            suggest = "switch_force"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceServerlessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceServerlessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceServerlessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: float,
                 min_capacity: float,
                 auto_pause: Optional[bool] = None,
                 switch_force: Optional[bool] = None):
        """
        :param float max_capacity: The maximum number of RDS Capacity Units (RCUs). The value of this parameter must be greater than or equal to `min_capacity` and only supports passing integers. Valid values:
               - MySQL: 1~8
               - SQLServer: 2~8
               - PostgreSQL: 1~12
        :param float min_capacity: The minimum number of RCUs. The value of this parameter must be less than or equal to `max_capacity`. Valid values:
               - MySQL: 0.5~8
               - SQLServer: 2~8 \\(Supports integers only\\).
               - PostgreSQL: 0.5~12
        :param bool auto_pause: Specifies whether to enable the smart startup and stop feature for the serverless instance. Valid values:
               - true: enables the feature.
               - false: disables the feature. This is the default value.
               > - Only MySQL Serverless instances need to set this parameter. If there is no connection within 10 minutes, it will enter a paused state and automatically wake up when the connection enters.
        :param bool switch_force: Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
               - true: enables the feature.
               - false: disables the feature. This is the default value.
               > - Only MySQL Serverless instances need to set this parameter. After enabling this parameter, there will be a flash break within 1 minute when the instance is forced to expand or shrink. Please use it with caution according to the actual situation.
               > - The elastic scaling of an instance RCU usually takes effect immediately, but in some special circumstances (such as during large transaction execution), it is not possible to complete scaling immediately. In this case, this parameter can be enabled to force scaling.
        """
        InstanceServerlessConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_capacity=max_capacity,
            min_capacity=min_capacity,
            auto_pause=auto_pause,
            switch_force=switch_force,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_capacity: Optional[float] = None,
             min_capacity: Optional[float] = None,
             auto_pause: Optional[bool] = None,
             switch_force: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_capacity is None and 'maxCapacity' in kwargs:
            max_capacity = kwargs['maxCapacity']
        if max_capacity is None:
            raise TypeError("Missing 'max_capacity' argument")
        if min_capacity is None and 'minCapacity' in kwargs:
            min_capacity = kwargs['minCapacity']
        if min_capacity is None:
            raise TypeError("Missing 'min_capacity' argument")
        if auto_pause is None and 'autoPause' in kwargs:
            auto_pause = kwargs['autoPause']
        if switch_force is None and 'switchForce' in kwargs:
            switch_force = kwargs['switchForce']

        _setter("max_capacity", max_capacity)
        _setter("min_capacity", min_capacity)
        if auto_pause is not None:
            _setter("auto_pause", auto_pause)
        if switch_force is not None:
            _setter("switch_force", switch_force)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> float:
        """
        The maximum number of RDS Capacity Units (RCUs). The value of this parameter must be greater than or equal to `min_capacity` and only supports passing integers. Valid values:
        - MySQL: 1~8
        - SQLServer: 2~8
        - PostgreSQL: 1~12
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> float:
        """
        The minimum number of RCUs. The value of this parameter must be less than or equal to `max_capacity`. Valid values:
        - MySQL: 0.5~8
        - SQLServer: 2~8 \\(Supports integers only\\).
        - PostgreSQL: 0.5~12
        """
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="autoPause")
    def auto_pause(self) -> Optional[bool]:
        """
        Specifies whether to enable the smart startup and stop feature for the serverless instance. Valid values:
        - true: enables the feature.
        - false: disables the feature. This is the default value.
        > - Only MySQL Serverless instances need to set this parameter. If there is no connection within 10 minutes, it will enter a paused state and automatically wake up when the connection enters.
        """
        return pulumi.get(self, "auto_pause")

    @property
    @pulumi.getter(name="switchForce")
    def switch_force(self) -> Optional[bool]:
        """
        Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
        - true: enables the feature.
        - false: disables the feature. This is the default value.
        > - Only MySQL Serverless instances need to set this parameter. After enabling this parameter, there will be a flash break within 1 minute when the instance is forced to expand or shrink. Please use it with caution according to the actual situation.
        > - The elastic scaling of an instance RCU usually takes effect immediately, but in some special circumstances (such as during large transaction execution), it is not possible to complete scaling immediately. In this case, this parameter can be enabled to force scaling.
        """
        return pulumi.get(self, "switch_force")


@pulumi.output_type
class RdsCloneDbInstanceParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The parameters name.
        :param str value: The parameters value.
        """
        RdsCloneDbInstanceParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The parameters name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The parameters value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RdsCloneDbInstancePgHbaConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "priorityId":
            suggest = "priority_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsCloneDbInstancePgHbaConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsCloneDbInstancePgHbaConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsCloneDbInstancePgHbaConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 database: str,
                 method: str,
                 priority_id: int,
                 type: str,
                 user: str,
                 mask: Optional[str] = None,
                 option: Optional[str] = None):
        """
        :param str address: The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        :param str database: The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        :param str method: The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        :param int priority_id: The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        :param str type: The type of connection to the instance. Valid values:
               * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
               * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
               * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
               
               > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        :param str user: The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        :param str mask: The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        :param str option: Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        RdsCloneDbInstancePgHbaConf._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            database=database,
            method=method,
            priority_id=priority_id,
            type=type,
            user=user,
            mask=mask,
            option=option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             database: Optional[str] = None,
             method: Optional[str] = None,
             priority_id: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             mask: Optional[str] = None,
             option: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if database is None:
            raise TypeError("Missing 'database' argument")
        if method is None:
            raise TypeError("Missing 'method' argument")
        if priority_id is None and 'priorityId' in kwargs:
            priority_id = kwargs['priorityId']
        if priority_id is None:
            raise TypeError("Missing 'priority_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")

        _setter("address", address)
        _setter("database", database)
        _setter("method", method)
        _setter("priority_id", priority_id)
        _setter("type", type)
        _setter("user", user)
        if mask is not None:
            _setter("mask", mask)
        if option is not None:
            _setter("option", option)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="priorityId")
    def priority_id(self) -> int:
        """
        The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        """
        return pulumi.get(self, "priority_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of connection to the instance. Valid values:
        * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
        * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
        * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.

        > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        """
        The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        """
        return pulumi.get(self, "mask")

    @property
    @pulumi.getter
    def option(self) -> Optional[str]:
        """
        Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        return pulumi.get(self, "option")


@pulumi.output_type
class RdsCloneDbInstanceServerlessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"
        elif key == "autoPause":
            suggest = "auto_pause"
        elif key == "switchForce":
            suggest = "switch_force"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsCloneDbInstanceServerlessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsCloneDbInstanceServerlessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsCloneDbInstanceServerlessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: float,
                 min_capacity: float,
                 auto_pause: Optional[bool] = None,
                 switch_force: Optional[bool] = None):
        """
        :param float max_capacity: The maximum number of RDS Capacity Units (RCUs). The value of this parameter must be greater than or equal to `min_capacity` and only supports passing integers. Valid values:
               - MySQL: 1~8
               - SQLServer: 2~8
               - PostgreSQL: 1~12
        :param float min_capacity: The minimum number of RCUs. The value of this parameter must be less than or equal to `max_capacity`. Valid values:
               - MySQL: 0.5~8
               - SQLServer: 2~8 \\(Supports integers only\\).
               - PostgreSQL: 0.5~12
        :param bool auto_pause: Specifies whether to enable the smart startup and stop feature for the serverless instance. Valid values:
               - true: enables the feature.
               - false: disables the feature. This is the default value.
               > - Only MySQL Serverless instances need to set this parameter. If there is no connection within 10 minutes, it will enter a paused state and automatically wake up when the connection enters.
        :param bool switch_force: Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
               - true: enables the feature.
               - false: disables the feature. This is the default value.
               > - Only MySQL Serverless instances need to set this parameter. After enabling this parameter, there will be a flash break within 1 minute when the instance is forced to expand or shrink. Please use it with caution according to the actual situation.
               > - The elastic scaling of an instance RCU usually takes effect immediately, but in some special circumstances (such as during large transaction execution), it is not possible to complete scaling immediately. In this case, this parameter can be enabled to force scaling.
        """
        RdsCloneDbInstanceServerlessConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_capacity=max_capacity,
            min_capacity=min_capacity,
            auto_pause=auto_pause,
            switch_force=switch_force,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_capacity: Optional[float] = None,
             min_capacity: Optional[float] = None,
             auto_pause: Optional[bool] = None,
             switch_force: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_capacity is None and 'maxCapacity' in kwargs:
            max_capacity = kwargs['maxCapacity']
        if max_capacity is None:
            raise TypeError("Missing 'max_capacity' argument")
        if min_capacity is None and 'minCapacity' in kwargs:
            min_capacity = kwargs['minCapacity']
        if min_capacity is None:
            raise TypeError("Missing 'min_capacity' argument")
        if auto_pause is None and 'autoPause' in kwargs:
            auto_pause = kwargs['autoPause']
        if switch_force is None and 'switchForce' in kwargs:
            switch_force = kwargs['switchForce']

        _setter("max_capacity", max_capacity)
        _setter("min_capacity", min_capacity)
        if auto_pause is not None:
            _setter("auto_pause", auto_pause)
        if switch_force is not None:
            _setter("switch_force", switch_force)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> float:
        """
        The maximum number of RDS Capacity Units (RCUs). The value of this parameter must be greater than or equal to `min_capacity` and only supports passing integers. Valid values:
        - MySQL: 1~8
        - SQLServer: 2~8
        - PostgreSQL: 1~12
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> float:
        """
        The minimum number of RCUs. The value of this parameter must be less than or equal to `max_capacity`. Valid values:
        - MySQL: 0.5~8
        - SQLServer: 2~8 \\(Supports integers only\\).
        - PostgreSQL: 0.5~12
        """
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="autoPause")
    def auto_pause(self) -> Optional[bool]:
        """
        Specifies whether to enable the smart startup and stop feature for the serverless instance. Valid values:
        - true: enables the feature.
        - false: disables the feature. This is the default value.
        > - Only MySQL Serverless instances need to set this parameter. If there is no connection within 10 minutes, it will enter a paused state and automatically wake up when the connection enters.
        """
        return pulumi.get(self, "auto_pause")

    @property
    @pulumi.getter(name="switchForce")
    def switch_force(self) -> Optional[bool]:
        """
        Specifies whether to enable the forced scaling feature for the serverless instance. Valid values:
        - true: enables the feature.
        - false: disables the feature. This is the default value.
        > - Only MySQL Serverless instances need to set this parameter. After enabling this parameter, there will be a flash break within 1 minute when the instance is forced to expand or shrink. Please use it with caution according to the actual situation.
        > - The elastic scaling of an instance RCU usually takes effect immediately, but in some special circumstances (such as during large transaction execution), it is not possible to complete scaling immediately. In this case, this parameter can be enabled to force scaling.
        """
        return pulumi.get(self, "switch_force")


@pulumi.output_type
class RdsDbProxyReadOnlyInstanceWeight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsDbProxyReadOnlyInstanceWeight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsDbProxyReadOnlyInstanceWeight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsDbProxyReadOnlyInstanceWeight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: str,
                 weight: str):
        """
        :param str instance_id: The Id of the instance and its read-only instances that can run database.
        :param str weight: Weight of instances that can run the database and their read-only instances. Read weights increase in increments of 100, and the maximum read weight is 10000.
        """
        RdsDbProxyReadOnlyInstanceWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_id=instance_id,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_id: Optional[str] = None,
             weight: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("instance_id", instance_id)
        _setter("weight", weight)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The Id of the instance and its read-only instances that can run database.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def weight(self) -> str:
        """
        Weight of instances that can run the database and their read-only instances. Read weights increase in increments of 100, and the maximum read weight is 10000.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class RdsParameterGroupParamDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramName":
            suggest = "param_name"
        elif key == "paramValue":
            suggest = "param_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsParameterGroupParamDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsParameterGroupParamDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsParameterGroupParamDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_name: str,
                 param_value: str):
        """
        :param str param_name: The name of a parameter.
        :param str param_value: The value of a parameter.
        """
        RdsParameterGroupParamDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            param_name=param_name,
            param_value=param_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             param_name: Optional[str] = None,
             param_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if param_name is None and 'paramName' in kwargs:
            param_name = kwargs['paramName']
        if param_name is None:
            raise TypeError("Missing 'param_name' argument")
        if param_value is None and 'paramValue' in kwargs:
            param_value = kwargs['paramValue']
        if param_value is None:
            raise TypeError("Missing 'param_value' argument")

        _setter("param_name", param_name)
        _setter("param_value", param_value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> str:
        """
        The name of a parameter.
        """
        return pulumi.get(self, "param_name")

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> str:
        """
        The value of a parameter.
        """
        return pulumi.get(self, "param_value")


@pulumi.output_type
class RdsUpgradeDbInstanceParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The parameter name.
        :param str value: The parameter value.
        """
        RdsUpgradeDbInstanceParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RdsUpgradeDbInstancePgHbaConf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "priorityId":
            suggest = "priority_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsUpgradeDbInstancePgHbaConf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsUpgradeDbInstancePgHbaConf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsUpgradeDbInstancePgHbaConf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 database: str,
                 method: str,
                 priority_id: int,
                 type: str,
                 user: str,
                 mask: Optional[str] = None,
                 option: Optional[str] = None):
        """
        :param str address: The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        :param str database: The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        :param str method: The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        :param int priority_id: The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        :param str type: The type of connection to the instance. Valid values:
               * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
               * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
               * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.
               
               > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        :param str user: The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        :param str mask: The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        :param str option: Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        RdsUpgradeDbInstancePgHbaConf._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            database=database,
            method=method,
            priority_id=priority_id,
            type=type,
            user=user,
            mask=mask,
            option=option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             database: Optional[str] = None,
             method: Optional[str] = None,
             priority_id: Optional[int] = None,
             type: Optional[str] = None,
             user: Optional[str] = None,
             mask: Optional[str] = None,
             option: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if database is None:
            raise TypeError("Missing 'database' argument")
        if method is None:
            raise TypeError("Missing 'method' argument")
        if priority_id is None and 'priorityId' in kwargs:
            priority_id = kwargs['priorityId']
        if priority_id is None:
            raise TypeError("Missing 'priority_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user is None:
            raise TypeError("Missing 'user' argument")

        _setter("address", address)
        _setter("database", database)
        _setter("method", method)
        _setter("priority_id", priority_id)
        _setter("type", type)
        _setter("user", user)
        if mask is not None:
            _setter("mask", mask)
        if option is not None:
            _setter("option", option)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP addresses from which the specified users can access the specified databases. If you set this parameter to 0.0.0.0/0, the specified users are allowed to access the specified databases from all IP addresses.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database that the specified users are allowed to access. If you set this parameter to all, the specified users are allowed to access all databases in the instance. If you specify multiple databases, separate the database names with commas (,).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The authentication method of Lightweight Directory Access Protocol (LDAP). Valid values: `trust`, `reject`, `scram-sha-256`, `md5`, `password`, `gss`, `sspi`, `ldap`, `radius`, `cert`, `pam`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="priorityId")
    def priority_id(self) -> int:
        """
        The priority of an AD domain. If you set this parameter to 0, the AD domain has the highest priority. Valid values: 0 to 10000. This parameter is used to identify each AD domain. When you add an AD domain, the value of the PriorityId parameter of the new AD domain cannot be the same as the value of the PriorityId parameter for any existing AD domain. When you modify or delete an AD domain, you must also modify or delete the value of the PriorityId parameter for this AD domain.
        """
        return pulumi.get(self, "priority_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of connection to the instance. Valid values:
        * **host**: specifies to verify TCP/IP connections, including SSL connections and non-SSL connections.
        * **hostssl**: specifies to verify only TCP/IP connections that are established over SSL connections.
        * **hostnossl**: specifies to verify only TCP/IP connections that are established over non-SSL connections.

        > **NOTE:** You can set this parameter to hostssl only when SSL encryption is enabled for the instance. For more information, see [Configure SSL encryption for an ApsaraDB RDS for PostgreSQL instance](https://www.alibabacloud.com/help/en/doc-detail/229518.htm).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The user that is allowed to access the instance. If you specify multiple users, separate the usernames with commas (,).
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        """
        The mask of the instance. If the value of the `Address` parameter is an IP address, you can use this parameter to specify the mask of the IP address.
        """
        return pulumi.get(self, "mask")

    @property
    @pulumi.getter
    def option(self) -> Optional[str]:
        """
        Optional. The value of this parameter is based on the value of the HbaItem.N.Method parameter. In this topic, LDAP is used as an example. You must configure this parameter. For more information, see [Authentication Methods](https://www.postgresql.org/docs/11/auth-methods.html).
        """
        return pulumi.get(self, "option")


@pulumi.output_type
class ReadOnlyInstanceParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The parameter name.
        :param str value: The parameter value.
        """
        ReadOnlyInstanceParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountsAccountResult(dict):
    def __init__(__self__, *,
                 account_description: str,
                 account_name: str,
                 account_type: str,
                 database_privileges: Sequence['outputs.GetAccountsAccountDatabasePrivilegeResult'],
                 id: str,
                 priv_exceeded: str,
                 status: str):
        """
        :param str account_description: Database description.
        :param str account_name: Name of database account.
        :param str account_type: Privilege type of account.
        :param Sequence['GetAccountsAccountDatabasePrivilegeArgs'] database_privileges: A list of database permissions the account has.
        :param str id: The ID of the Account.
        :param str priv_exceeded: Whether the maximum number of databases managed by the account is exceeded.
        :param str status: The status of the resource.
        """
        GetAccountsAccountResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_description=account_description,
            account_name=account_name,
            account_type=account_type,
            database_privileges=database_privileges,
            id=id,
            priv_exceeded=priv_exceeded,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_description: Optional[str] = None,
             account_name: Optional[str] = None,
             account_type: Optional[str] = None,
             database_privileges: Optional[Sequence['outputs.GetAccountsAccountDatabasePrivilegeResult']] = None,
             id: Optional[str] = None,
             priv_exceeded: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_description is None and 'accountDescription' in kwargs:
            account_description = kwargs['accountDescription']
        if account_description is None:
            raise TypeError("Missing 'account_description' argument")
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if account_type is None and 'accountType' in kwargs:
            account_type = kwargs['accountType']
        if account_type is None:
            raise TypeError("Missing 'account_type' argument")
        if database_privileges is None and 'databasePrivileges' in kwargs:
            database_privileges = kwargs['databasePrivileges']
        if database_privileges is None:
            raise TypeError("Missing 'database_privileges' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if priv_exceeded is None and 'privExceeded' in kwargs:
            priv_exceeded = kwargs['privExceeded']
        if priv_exceeded is None:
            raise TypeError("Missing 'priv_exceeded' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("account_description", account_description)
        _setter("account_name", account_name)
        _setter("account_type", account_type)
        _setter("database_privileges", database_privileges)
        _setter("id", id)
        _setter("priv_exceeded", priv_exceeded)
        _setter("status", status)

    @property
    @pulumi.getter(name="accountDescription")
    def account_description(self) -> str:
        """
        Database description.
        """
        return pulumi.get(self, "account_description")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Name of database account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="accountType")
    def account_type(self) -> str:
        """
        Privilege type of account.
        """
        return pulumi.get(self, "account_type")

    @property
    @pulumi.getter(name="databasePrivileges")
    def database_privileges(self) -> Sequence['outputs.GetAccountsAccountDatabasePrivilegeResult']:
        """
        A list of database permissions the account has.
        """
        return pulumi.get(self, "database_privileges")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Account.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privExceeded")
    def priv_exceeded(self) -> str:
        """
        Whether the maximum number of databases managed by the account is exceeded.
        """
        return pulumi.get(self, "priv_exceeded")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAccountsAccountDatabasePrivilegeResult(dict):
    def __init__(__self__, *,
                 account_privilege: str,
                 account_privilege_detail: str,
                 db_name: str):
        """
        :param str account_privilege: The type of permission for the account.
        :param str account_privilege_detail: The specific permissions corresponding to the type of account permissions.
        :param str db_name: Database name.
        """
        GetAccountsAccountDatabasePrivilegeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_privilege=account_privilege,
            account_privilege_detail=account_privilege_detail,
            db_name=db_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_privilege: Optional[str] = None,
             account_privilege_detail: Optional[str] = None,
             db_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_privilege is None and 'accountPrivilege' in kwargs:
            account_privilege = kwargs['accountPrivilege']
        if account_privilege is None:
            raise TypeError("Missing 'account_privilege' argument")
        if account_privilege_detail is None and 'accountPrivilegeDetail' in kwargs:
            account_privilege_detail = kwargs['accountPrivilegeDetail']
        if account_privilege_detail is None:
            raise TypeError("Missing 'account_privilege_detail' argument")
        if db_name is None and 'dbName' in kwargs:
            db_name = kwargs['dbName']
        if db_name is None:
            raise TypeError("Missing 'db_name' argument")

        _setter("account_privilege", account_privilege)
        _setter("account_privilege_detail", account_privilege_detail)
        _setter("db_name", db_name)

    @property
    @pulumi.getter(name="accountPrivilege")
    def account_privilege(self) -> str:
        """
        The type of permission for the account.
        """
        return pulumi.get(self, "account_privilege")

    @property
    @pulumi.getter(name="accountPrivilegeDetail")
    def account_privilege_detail(self) -> str:
        """
        The specific permissions corresponding to the type of account permissions.
        """
        return pulumi.get(self, "account_privilege_detail")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        Database name.
        """
        return pulumi.get(self, "db_name")


@pulumi.output_type
class GetCollationTimeZonesCollationTimeZoneResult(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 standard_time_offset: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param str description: The code of the instance type.
        :param str standard_time_offset: The offset of the UTC time. The offset is in the following format: (UTC+<i>HH:mm</i>).
        :param str time_zone: The time zone that is available for use in ApsaraDB RDS.
        """
        GetCollationTimeZonesCollationTimeZoneResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            standard_time_offset=standard_time_offset,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             standard_time_offset: Optional[str] = None,
             time_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if standard_time_offset is None and 'standardTimeOffset' in kwargs:
            standard_time_offset = kwargs['standardTimeOffset']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        if description is not None:
            _setter("description", description)
        if standard_time_offset is not None:
            _setter("standard_time_offset", standard_time_offset)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The code of the instance type.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="standardTimeOffset")
    def standard_time_offset(self) -> Optional[str]:
        """
        The offset of the UTC time. The offset is in the following format: (UTC+<i>HH:mm</i>).
        """
        return pulumi.get(self, "standard_time_offset")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone that is available for use in ApsaraDB RDS.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetCrossRegionBackupsBackupResult(dict):
    def __init__(__self__, *,
                 backup_end_time: str,
                 backup_method: str,
                 backup_set_scale: str,
                 backup_set_status: int,
                 backup_start_time: str,
                 backup_type: str,
                 category: str,
                 consistent_time: str,
                 cross_backup_download_link: str,
                 cross_backup_id: str,
                 cross_backup_region: str,
                 cross_backup_set_file: str,
                 cross_backup_set_location: str,
                 cross_backup_set_size: int,
                 db_instance_storage_type: str,
                 engine: str,
                 engine_version: str,
                 id: str,
                 instance_id: int,
                 recovery_begin_time: str,
                 recovery_end_time: str,
                 restore_regions: Sequence[str]):
        """
        :param str backup_end_time: The time when the cross-region data backup file was generated.
        :param str backup_method: The method that is used to generate the cross-region data backup file. Valid values:
               `L` - logical backup.
               `P` - physical backup.
        :param str backup_set_scale: The level at which the cross-region data backup file is generated.
               `0` - instance-level backup.
               `1` - database-level backup.
        :param int backup_set_status: TThe status of the cross-region data backup. Valid values:
               `0` - The cross-region data backup is successful.
               `1` - The cross-region data backup failed.
        :param str backup_start_time: The time when the cross-region data backup started.
        :param str backup_type: The type of the cross-region data backup. Valid values:F: full data backup
               `F` - full data backup.
               `I` - incremental data backup.
        :param str category: The RDS edition of the instance. Valid values:
               `Basic` - Basic Edition.
               `HighAvailability` - High-availability Edition.
               `Finance` - Enterprise Edition. This edition is supported only by the China site (aliyun.com).
        :param str consistent_time: The point in time that is indicated by the data in the cross-region data backup file.
        :param str cross_backup_download_link: The external URL from which you can download the cross-region data backup file.
        :param str cross_backup_id: The ID of the cross-region data backup file.
        :param str cross_backup_region: The ID of the destination region where the cross-region data backup file of the instance is stored.
        :param str cross_backup_set_file: The name of the compressed package that contains the cross-region data backup file.
        :param str cross_backup_set_location: The location where the cross-region data backup file is stored.
        :param int cross_backup_set_size: The size of the cross-region data backup file. Unit: bytes.
        :param str db_instance_storage_type: The storage type.
        :param str engine: The engine of the database.
        :param str engine_version: The version of the database engine.
        :param str id: The ID of the cross-region data backup file.
        :param int instance_id: The ID of the instance. This parameter is used to determine whether the instance that generates the cross-region data backup file is a primary or secondary instance.
        :param str recovery_begin_time: The start time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param str recovery_end_time: The end time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param Sequence[str] restore_regions: An array that consists of the regions to which the cross-region data backup file can be restored.
        """
        GetCrossRegionBackupsBackupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_end_time=backup_end_time,
            backup_method=backup_method,
            backup_set_scale=backup_set_scale,
            backup_set_status=backup_set_status,
            backup_start_time=backup_start_time,
            backup_type=backup_type,
            category=category,
            consistent_time=consistent_time,
            cross_backup_download_link=cross_backup_download_link,
            cross_backup_id=cross_backup_id,
            cross_backup_region=cross_backup_region,
            cross_backup_set_file=cross_backup_set_file,
            cross_backup_set_location=cross_backup_set_location,
            cross_backup_set_size=cross_backup_set_size,
            db_instance_storage_type=db_instance_storage_type,
            engine=engine,
            engine_version=engine_version,
            id=id,
            instance_id=instance_id,
            recovery_begin_time=recovery_begin_time,
            recovery_end_time=recovery_end_time,
            restore_regions=restore_regions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_end_time: Optional[str] = None,
             backup_method: Optional[str] = None,
             backup_set_scale: Optional[str] = None,
             backup_set_status: Optional[int] = None,
             backup_start_time: Optional[str] = None,
             backup_type: Optional[str] = None,
             category: Optional[str] = None,
             consistent_time: Optional[str] = None,
             cross_backup_download_link: Optional[str] = None,
             cross_backup_id: Optional[str] = None,
             cross_backup_region: Optional[str] = None,
             cross_backup_set_file: Optional[str] = None,
             cross_backup_set_location: Optional[str] = None,
             cross_backup_set_size: Optional[int] = None,
             db_instance_storage_type: Optional[str] = None,
             engine: Optional[str] = None,
             engine_version: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[int] = None,
             recovery_begin_time: Optional[str] = None,
             recovery_end_time: Optional[str] = None,
             restore_regions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_end_time is None and 'backupEndTime' in kwargs:
            backup_end_time = kwargs['backupEndTime']
        if backup_end_time is None:
            raise TypeError("Missing 'backup_end_time' argument")
        if backup_method is None and 'backupMethod' in kwargs:
            backup_method = kwargs['backupMethod']
        if backup_method is None:
            raise TypeError("Missing 'backup_method' argument")
        if backup_set_scale is None and 'backupSetScale' in kwargs:
            backup_set_scale = kwargs['backupSetScale']
        if backup_set_scale is None:
            raise TypeError("Missing 'backup_set_scale' argument")
        if backup_set_status is None and 'backupSetStatus' in kwargs:
            backup_set_status = kwargs['backupSetStatus']
        if backup_set_status is None:
            raise TypeError("Missing 'backup_set_status' argument")
        if backup_start_time is None and 'backupStartTime' in kwargs:
            backup_start_time = kwargs['backupStartTime']
        if backup_start_time is None:
            raise TypeError("Missing 'backup_start_time' argument")
        if backup_type is None and 'backupType' in kwargs:
            backup_type = kwargs['backupType']
        if backup_type is None:
            raise TypeError("Missing 'backup_type' argument")
        if category is None:
            raise TypeError("Missing 'category' argument")
        if consistent_time is None and 'consistentTime' in kwargs:
            consistent_time = kwargs['consistentTime']
        if consistent_time is None:
            raise TypeError("Missing 'consistent_time' argument")
        if cross_backup_download_link is None and 'crossBackupDownloadLink' in kwargs:
            cross_backup_download_link = kwargs['crossBackupDownloadLink']
        if cross_backup_download_link is None:
            raise TypeError("Missing 'cross_backup_download_link' argument")
        if cross_backup_id is None and 'crossBackupId' in kwargs:
            cross_backup_id = kwargs['crossBackupId']
        if cross_backup_id is None:
            raise TypeError("Missing 'cross_backup_id' argument")
        if cross_backup_region is None and 'crossBackupRegion' in kwargs:
            cross_backup_region = kwargs['crossBackupRegion']
        if cross_backup_region is None:
            raise TypeError("Missing 'cross_backup_region' argument")
        if cross_backup_set_file is None and 'crossBackupSetFile' in kwargs:
            cross_backup_set_file = kwargs['crossBackupSetFile']
        if cross_backup_set_file is None:
            raise TypeError("Missing 'cross_backup_set_file' argument")
        if cross_backup_set_location is None and 'crossBackupSetLocation' in kwargs:
            cross_backup_set_location = kwargs['crossBackupSetLocation']
        if cross_backup_set_location is None:
            raise TypeError("Missing 'cross_backup_set_location' argument")
        if cross_backup_set_size is None and 'crossBackupSetSize' in kwargs:
            cross_backup_set_size = kwargs['crossBackupSetSize']
        if cross_backup_set_size is None:
            raise TypeError("Missing 'cross_backup_set_size' argument")
        if db_instance_storage_type is None and 'dbInstanceStorageType' in kwargs:
            db_instance_storage_type = kwargs['dbInstanceStorageType']
        if db_instance_storage_type is None:
            raise TypeError("Missing 'db_instance_storage_type' argument")
        if engine is None:
            raise TypeError("Missing 'engine' argument")
        if engine_version is None and 'engineVersion' in kwargs:
            engine_version = kwargs['engineVersion']
        if engine_version is None:
            raise TypeError("Missing 'engine_version' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if recovery_begin_time is None and 'recoveryBeginTime' in kwargs:
            recovery_begin_time = kwargs['recoveryBeginTime']
        if recovery_begin_time is None:
            raise TypeError("Missing 'recovery_begin_time' argument")
        if recovery_end_time is None and 'recoveryEndTime' in kwargs:
            recovery_end_time = kwargs['recoveryEndTime']
        if recovery_end_time is None:
            raise TypeError("Missing 'recovery_end_time' argument")
        if restore_regions is None and 'restoreRegions' in kwargs:
            restore_regions = kwargs['restoreRegions']
        if restore_regions is None:
            raise TypeError("Missing 'restore_regions' argument")

        _setter("backup_end_time", backup_end_time)
        _setter("backup_method", backup_method)
        _setter("backup_set_scale", backup_set_scale)
        _setter("backup_set_status", backup_set_status)
        _setter("backup_start_time", backup_start_time)
        _setter("backup_type", backup_type)
        _setter("category", category)
        _setter("consistent_time", consistent_time)
        _setter("cross_backup_download_link", cross_backup_download_link)
        _setter("cross_backup_id", cross_backup_id)
        _setter("cross_backup_region", cross_backup_region)
        _setter("cross_backup_set_file", cross_backup_set_file)
        _setter("cross_backup_set_location", cross_backup_set_location)
        _setter("cross_backup_set_size", cross_backup_set_size)
        _setter("db_instance_storage_type", db_instance_storage_type)
        _setter("engine", engine)
        _setter("engine_version", engine_version)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("recovery_begin_time", recovery_begin_time)
        _setter("recovery_end_time", recovery_end_time)
        _setter("restore_regions", restore_regions)

    @property
    @pulumi.getter(name="backupEndTime")
    def backup_end_time(self) -> str:
        """
        The time when the cross-region data backup file was generated.
        """
        return pulumi.get(self, "backup_end_time")

    @property
    @pulumi.getter(name="backupMethod")
    def backup_method(self) -> str:
        """
        The method that is used to generate the cross-region data backup file. Valid values:
        `L` - logical backup.
        `P` - physical backup.
        """
        return pulumi.get(self, "backup_method")

    @property
    @pulumi.getter(name="backupSetScale")
    def backup_set_scale(self) -> str:
        """
        The level at which the cross-region data backup file is generated.
        `0` - instance-level backup.
        `1` - database-level backup.
        """
        return pulumi.get(self, "backup_set_scale")

    @property
    @pulumi.getter(name="backupSetStatus")
    def backup_set_status(self) -> int:
        """
        TThe status of the cross-region data backup. Valid values:
        `0` - The cross-region data backup is successful.
        `1` - The cross-region data backup failed.
        """
        return pulumi.get(self, "backup_set_status")

    @property
    @pulumi.getter(name="backupStartTime")
    def backup_start_time(self) -> str:
        """
        The time when the cross-region data backup started.
        """
        return pulumi.get(self, "backup_start_time")

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> str:
        """
        The type of the cross-region data backup. Valid values:F: full data backup
        `F` - full data backup.
        `I` - incremental data backup.
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The RDS edition of the instance. Valid values:
        `Basic` - Basic Edition.
        `HighAvailability` - High-availability Edition.
        `Finance` - Enterprise Edition. This edition is supported only by the China site (aliyun.com).
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="consistentTime")
    def consistent_time(self) -> str:
        """
        The point in time that is indicated by the data in the cross-region data backup file.
        """
        return pulumi.get(self, "consistent_time")

    @property
    @pulumi.getter(name="crossBackupDownloadLink")
    def cross_backup_download_link(self) -> str:
        """
        The external URL from which you can download the cross-region data backup file.
        """
        return pulumi.get(self, "cross_backup_download_link")

    @property
    @pulumi.getter(name="crossBackupId")
    def cross_backup_id(self) -> str:
        """
        The ID of the cross-region data backup file.
        """
        return pulumi.get(self, "cross_backup_id")

    @property
    @pulumi.getter(name="crossBackupRegion")
    def cross_backup_region(self) -> str:
        """
        The ID of the destination region where the cross-region data backup file of the instance is stored.
        """
        return pulumi.get(self, "cross_backup_region")

    @property
    @pulumi.getter(name="crossBackupSetFile")
    def cross_backup_set_file(self) -> str:
        """
        The name of the compressed package that contains the cross-region data backup file.
        """
        return pulumi.get(self, "cross_backup_set_file")

    @property
    @pulumi.getter(name="crossBackupSetLocation")
    def cross_backup_set_location(self) -> str:
        """
        The location where the cross-region data backup file is stored.
        """
        return pulumi.get(self, "cross_backup_set_location")

    @property
    @pulumi.getter(name="crossBackupSetSize")
    def cross_backup_set_size(self) -> int:
        """
        The size of the cross-region data backup file. Unit: bytes.
        """
        return pulumi.get(self, "cross_backup_set_size")

    @property
    @pulumi.getter(name="dbInstanceStorageType")
    def db_instance_storage_type(self) -> str:
        """
        The storage type.
        """
        return pulumi.get(self, "db_instance_storage_type")

    @property
    @pulumi.getter
    def engine(self) -> str:
        """
        The engine of the database.
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> str:
        """
        The version of the database engine.
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the cross-region data backup file.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> int:
        """
        The ID of the instance. This parameter is used to determine whether the instance that generates the cross-region data backup file is a primary or secondary instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="recoveryBeginTime")
    def recovery_begin_time(self) -> str:
        """
        The start time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "recovery_begin_time")

    @property
    @pulumi.getter(name="recoveryEndTime")
    def recovery_end_time(self) -> str:
        """
        The end time to which data can be restored. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "recovery_end_time")

    @property
    @pulumi.getter(name="restoreRegions")
    def restore_regions(self) -> Sequence[str]:
        """
        An array that consists of the regions to which the cross-region data backup file can be restored.
        """
        return pulumi.get(self, "restore_regions")


@pulumi.output_type
class GetCrossRegionsRegionResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: ID of the region.
        """
        GetCrossRegionsRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the region.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInstanceClassInfosInfoResult(dict):
    def __init__(__self__, *,
                 class_code: Optional[str] = None,
                 class_group: Optional[str] = None,
                 cpu: Optional[str] = None,
                 instruction_set_arch: Optional[str] = None,
                 max_connections: Optional[str] = None,
                 max_iombps: Optional[str] = None,
                 max_iops: Optional[str] = None,
                 memory_class: Optional[str] = None,
                 reference_price: Optional[str] = None):
        """
        :param str class_code: The code of the instance type.
        :param str class_group: The instance family of the instance.
        :param str cpu: The number of cores that are supported by the instance type. Unit: cores.
        :param str instruction_set_arch: The architecture of the instance type.
        :param str max_connections: The maximum number of connections that are supported by the instance type. Unit: connections.
        :param str max_iombps: The maximum I/O bandwidth that is supported by the instance type. Unit: Mbit/s.
        :param str max_iops: The maximum input/output operations per second (IOPS) that is supported by the instance type. Unit: operations per second.
        :param str memory_class: The memory capacity that is supported by the instance type. Unit: GB.
        :param str reference_price: The fee that you must pay for the instance type. Unit: cent (USD).
        """
        GetInstanceClassInfosInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            class_code=class_code,
            class_group=class_group,
            cpu=cpu,
            instruction_set_arch=instruction_set_arch,
            max_connections=max_connections,
            max_iombps=max_iombps,
            max_iops=max_iops,
            memory_class=memory_class,
            reference_price=reference_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             class_code: Optional[str] = None,
             class_group: Optional[str] = None,
             cpu: Optional[str] = None,
             instruction_set_arch: Optional[str] = None,
             max_connections: Optional[str] = None,
             max_iombps: Optional[str] = None,
             max_iops: Optional[str] = None,
             memory_class: Optional[str] = None,
             reference_price: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if class_code is None and 'classCode' in kwargs:
            class_code = kwargs['classCode']
        if class_group is None and 'classGroup' in kwargs:
            class_group = kwargs['classGroup']
        if instruction_set_arch is None and 'instructionSetArch' in kwargs:
            instruction_set_arch = kwargs['instructionSetArch']
        if max_connections is None and 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if max_iombps is None and 'maxIombps' in kwargs:
            max_iombps = kwargs['maxIombps']
        if max_iops is None and 'maxIops' in kwargs:
            max_iops = kwargs['maxIops']
        if memory_class is None and 'memoryClass' in kwargs:
            memory_class = kwargs['memoryClass']
        if reference_price is None and 'referencePrice' in kwargs:
            reference_price = kwargs['referencePrice']

        if class_code is not None:
            _setter("class_code", class_code)
        if class_group is not None:
            _setter("class_group", class_group)
        if cpu is not None:
            _setter("cpu", cpu)
        if instruction_set_arch is not None:
            _setter("instruction_set_arch", instruction_set_arch)
        if max_connections is not None:
            _setter("max_connections", max_connections)
        if max_iombps is not None:
            _setter("max_iombps", max_iombps)
        if max_iops is not None:
            _setter("max_iops", max_iops)
        if memory_class is not None:
            _setter("memory_class", memory_class)
        if reference_price is not None:
            _setter("reference_price", reference_price)

    @property
    @pulumi.getter(name="classCode")
    def class_code(self) -> Optional[str]:
        """
        The code of the instance type.
        """
        return pulumi.get(self, "class_code")

    @property
    @pulumi.getter(name="classGroup")
    def class_group(self) -> Optional[str]:
        """
        The instance family of the instance.
        """
        return pulumi.get(self, "class_group")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        """
        The number of cores that are supported by the instance type. Unit: cores.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instructionSetArch")
    def instruction_set_arch(self) -> Optional[str]:
        """
        The architecture of the instance type.
        """
        return pulumi.get(self, "instruction_set_arch")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[str]:
        """
        The maximum number of connections that are supported by the instance type. Unit: connections.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxIombps")
    def max_iombps(self) -> Optional[str]:
        """
        The maximum I/O bandwidth that is supported by the instance type. Unit: Mbit/s.
        """
        return pulumi.get(self, "max_iombps")

    @property
    @pulumi.getter(name="maxIops")
    def max_iops(self) -> Optional[str]:
        """
        The maximum input/output operations per second (IOPS) that is supported by the instance type. Unit: operations per second.
        """
        return pulumi.get(self, "max_iops")

    @property
    @pulumi.getter(name="memoryClass")
    def memory_class(self) -> Optional[str]:
        """
        The memory capacity that is supported by the instance type. Unit: GB.
        """
        return pulumi.get(self, "memory_class")

    @property
    @pulumi.getter(name="referencePrice")
    def reference_price(self) -> Optional[str]:
        """
        The fee that you must pay for the instance type. Unit: cent (USD).
        """
        return pulumi.get(self, "reference_price")


@pulumi.output_type
class GetInstanceClassesInstanceClassResult(dict):
    def __init__(__self__, *,
                 instance_class: str,
                 price: str,
                 storage_range: 'outputs.GetInstanceClassesInstanceClassStorageRangeResult',
                 zone_ids: Sequence['outputs.GetInstanceClassesInstanceClassZoneIdResult']):
        """
        :param str instance_class: DB Instance available class.
        :param 'GetInstanceClassesInstanceClassStorageRangeArgs' storage_range: DB Instance available storage range.
        :param Sequence['GetInstanceClassesInstanceClassZoneIdArgs'] zone_ids: A list of Zone to launch the DB instance.
        """
        GetInstanceClassesInstanceClassResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_class=instance_class,
            price=price,
            storage_range=storage_range,
            zone_ids=zone_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_class: Optional[str] = None,
             price: Optional[str] = None,
             storage_range: Optional['outputs.GetInstanceClassesInstanceClassStorageRangeResult'] = None,
             zone_ids: Optional[Sequence['outputs.GetInstanceClassesInstanceClassZoneIdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_class is None and 'instanceClass' in kwargs:
            instance_class = kwargs['instanceClass']
        if instance_class is None:
            raise TypeError("Missing 'instance_class' argument")
        if price is None:
            raise TypeError("Missing 'price' argument")
        if storage_range is None and 'storageRange' in kwargs:
            storage_range = kwargs['storageRange']
        if storage_range is None:
            raise TypeError("Missing 'storage_range' argument")
        if zone_ids is None and 'zoneIds' in kwargs:
            zone_ids = kwargs['zoneIds']
        if zone_ids is None:
            raise TypeError("Missing 'zone_ids' argument")

        _setter("instance_class", instance_class)
        _setter("price", price)
        _setter("storage_range", storage_range)
        _setter("zone_ids", zone_ids)

    @property
    @pulumi.getter(name="instanceClass")
    def instance_class(self) -> str:
        """
        DB Instance available class.
        """
        return pulumi.get(self, "instance_class")

    @property
    @pulumi.getter
    def price(self) -> str:
        return pulumi.get(self, "price")

    @property
    @pulumi.getter(name="storageRange")
    def storage_range(self) -> 'outputs.GetInstanceClassesInstanceClassStorageRangeResult':
        """
        DB Instance available storage range.
        """
        return pulumi.get(self, "storage_range")

    @property
    @pulumi.getter(name="zoneIds")
    def zone_ids(self) -> Sequence['outputs.GetInstanceClassesInstanceClassZoneIdResult']:
        """
        A list of Zone to launch the DB instance.
        """
        return pulumi.get(self, "zone_ids")


@pulumi.output_type
class GetInstanceClassesInstanceClassStorageRangeResult(dict):
    def __init__(__self__, *,
                 max: str,
                 min: str,
                 step: str):
        """
        :param str max: DB Instance available storage max value.
        :param str min: DB Instance available storage min value.
        :param str step: DB Instance available storage increase step.
        """
        GetInstanceClassesInstanceClassStorageRangeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[str] = None,
             min: Optional[str] = None,
             step: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max is None:
            raise TypeError("Missing 'max' argument")
        if min is None:
            raise TypeError("Missing 'min' argument")
        if step is None:
            raise TypeError("Missing 'step' argument")

        _setter("max", max)
        _setter("min", min)
        _setter("step", step)

    @property
    @pulumi.getter
    def max(self) -> str:
        """
        DB Instance available storage max value.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> str:
        """
        DB Instance available storage min value.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def step(self) -> str:
        """
        DB Instance available storage increase step.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class GetInstanceClassesInstanceClassZoneIdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 sub_zone_ids: Sequence[str]):
        """
        :param str id: The Zone to launch the DB instance
        :param Sequence[str] sub_zone_ids: A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `sub_zone_ids` will be `["cn-beijing-a", "cn-beijing-b"]`.
        """
        GetInstanceClassesInstanceClassZoneIdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            sub_zone_ids=sub_zone_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             sub_zone_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if sub_zone_ids is None and 'subZoneIds' in kwargs:
            sub_zone_ids = kwargs['subZoneIds']
        if sub_zone_ids is None:
            raise TypeError("Missing 'sub_zone_ids' argument")

        _setter("id", id)
        _setter("sub_zone_ids", sub_zone_ids)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Zone to launch the DB instance
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="subZoneIds")
    def sub_zone_ids(self) -> Sequence[str]:
        """
        A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `sub_zone_ids` will be `["cn-beijing-a", "cn-beijing-b"]`.
        """
        return pulumi.get(self, "sub_zone_ids")


@pulumi.output_type
class GetInstanceEnginesInstanceEngineResult(dict):
    def __init__(__self__, *,
                 category: str,
                 engine: str,
                 engine_version: str,
                 zone_ids: Sequence['outputs.GetInstanceEnginesInstanceEngineZoneIdResult']):
        """
        :param str category: DB Instance category. the value like [`Basic`, `HighAvailability`, `Finance`, `AlwaysOn`], [detail info](https://www.alibabacloud.com/help/doc-detail/69795.htm).
        :param str engine: Database type. Valid values: "MySQL", "SQLServer", "PostgreSQL", "MariaDB". If not set, it will match all of engines.
        :param str engine_version: Database version required by the user. Value options can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/26228.htm) `EngineVersion`.
        :param Sequence['GetInstanceEnginesInstanceEngineZoneIdArgs'] zone_ids: A list of Zone to launch the DB instance.
        """
        GetInstanceEnginesInstanceEngineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            engine=engine,
            engine_version=engine_version,
            zone_ids=zone_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             engine: Optional[str] = None,
             engine_version: Optional[str] = None,
             zone_ids: Optional[Sequence['outputs.GetInstanceEnginesInstanceEngineZoneIdResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if engine is None:
            raise TypeError("Missing 'engine' argument")
        if engine_version is None and 'engineVersion' in kwargs:
            engine_version = kwargs['engineVersion']
        if engine_version is None:
            raise TypeError("Missing 'engine_version' argument")
        if zone_ids is None and 'zoneIds' in kwargs:
            zone_ids = kwargs['zoneIds']
        if zone_ids is None:
            raise TypeError("Missing 'zone_ids' argument")

        _setter("category", category)
        _setter("engine", engine)
        _setter("engine_version", engine_version)
        _setter("zone_ids", zone_ids)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        DB Instance category. the value like [`Basic`, `HighAvailability`, `Finance`, `AlwaysOn`], [detail info](https://www.alibabacloud.com/help/doc-detail/69795.htm).
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def engine(self) -> str:
        """
        Database type. Valid values: "MySQL", "SQLServer", "PostgreSQL", "MariaDB". If not set, it will match all of engines.
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> str:
        """
        Database version required by the user. Value options can refer to the latest docs [detail info](https://www.alibabacloud.com/help/doc-detail/26228.htm) `EngineVersion`.
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="zoneIds")
    def zone_ids(self) -> Sequence['outputs.GetInstanceEnginesInstanceEngineZoneIdResult']:
        """
        A list of Zone to launch the DB instance.
        """
        return pulumi.get(self, "zone_ids")


@pulumi.output_type
class GetInstanceEnginesInstanceEngineZoneIdResult(dict):
    def __init__(__self__, *,
                 id: str,
                 sub_zone_ids: Sequence[str]):
        """
        :param str id: The Zone to launch the DB instance
        :param Sequence[str] sub_zone_ids: A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `sub_zone_ids` will be `["cn-beijing-a", "cn-beijing-b"]`.
        """
        GetInstanceEnginesInstanceEngineZoneIdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            sub_zone_ids=sub_zone_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             sub_zone_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if sub_zone_ids is None and 'subZoneIds' in kwargs:
            sub_zone_ids = kwargs['subZoneIds']
        if sub_zone_ids is None:
            raise TypeError("Missing 'sub_zone_ids' argument")

        _setter("id", id)
        _setter("sub_zone_ids", sub_zone_ids)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Zone to launch the DB instance
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="subZoneIds")
    def sub_zone_ids(self) -> Sequence[str]:
        """
        A list of sub zone ids which in the id - e.g If `id` is `cn-beijing-MAZ5(a,b)`, `sub_zone_ids` will be `["cn-beijing-a", "cn-beijing-b"]`.
        """
        return pulumi.get(self, "sub_zone_ids")


@pulumi.output_type
class GetInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 acl: str,
                 availability_zone: str,
                 ca_type: str,
                 charge_type: str,
                 client_ca_cert: str,
                 client_ca_cert_expire_time: str,
                 client_cert_revocation_list: str,
                 connection_mode: str,
                 connection_string: str,
                 create_time: str,
                 creator: str,
                 db_instance_storage_type: str,
                 db_instance_type: str,
                 db_type: str,
                 delete_date: str,
                 deletion_protection: bool,
                 description: str,
                 encryption_key: str,
                 encryption_key_status: str,
                 engine: str,
                 engine_version: str,
                 expire_time: str,
                 guard_instance_id: str,
                 ha_mode: str,
                 host_instance_infos: Sequence['outputs.GetInstancesInstanceHostInstanceInfoResult'],
                 id: str,
                 instance_storage: int,
                 instance_type: str,
                 key_usage: str,
                 last_modify_status: str,
                 master_instance_id: str,
                 master_zone: str,
                 material_expire_time: str,
                 modify_status_reason: str,
                 name: str,
                 net_type: str,
                 origin: str,
                 parameters: Sequence['outputs.GetInstancesInstanceParameterResult'],
                 port: str,
                 readonly_instance_ids: Sequence[str],
                 region_id: str,
                 replication_acl: str,
                 require_update: str,
                 require_update_item: str,
                 require_update_reason: str,
                 server_ca_url: str,
                 server_cert: str,
                 server_key: str,
                 ssl_create_time: str,
                 ssl_enabled: str,
                 ssl_expire_time: str,
                 status: str,
                 sync_mode: str,
                 temp_instance_id: str,
                 vpc_id: str,
                 vswitch_id: str,
                 zone_id_slave_a: str,
                 zone_id_slave_b: str):
        """
        :param str acl: (Available in 1.124.1+) The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
               - cert
               - perfer
               - verify-ca
               - verify-full (supported only when the instance runs PostgreSQL 12 or later)
        :param str availability_zone: Availability zone.
        :param str ca_type: (Available in 1.124.1+) The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
               - aliyun: a cloud certificate
               - custom: a custom certificate
        :param str charge_type: Billing method. Value options: `Postpaid` for Pay-As-You-Go and `Prepaid` for subscription.
        :param str client_ca_cert: (Available in 1.124.1+) The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str client_ca_cert_expire_time: (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. This parameter is not supported now.
        :param str client_cert_revocation_list: (Available in 1.124.1+) The certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str connection_mode: `Standard` for standard access mode and `Safe` for high security access mode.
        :param str connection_string: (Available in 1.70.3+) RDS database connection string.
        :param str create_time: Creation time of the instance.
        :param str creator: (Available in 1.124.3+) The creator of the encryption key.
        :param str db_instance_storage_type: (Available in 1.70.3+) The storage type of the instance.
        :param str db_instance_type: (Available in 1.197.0+) The type of instance.
        :param str db_type: `Primary` for primary instance, `Readonly` for read-only instance, `Guard` for disaster recovery instance, and `Temp` for temporary instance.
        :param str delete_date: (Available in 1.124.3+) The estimated time when the encryption key will be deleted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param bool deletion_protection: (Available in 1.167.0+) Indicates whether the release protection feature is enabled for the instance. Valid values:
               * **true**: The release protection feature is enabled.
               * **false**: The release protection feature is disabled.
        :param str description: (Available in 1.124.3+) The description of the encryption key.
        :param str encryption_key: (Available in 1.124.3+) The ID of the encryption key.
        :param str encryption_key_status: (Available in 1.124.3+) The status of the encryption key. Valid values:
               - Enabled
               - Disabled
        :param str engine: Database type. Options are `MySQL`, `SQLServer`, `PostgreSQL`, `MariaDB`. If no value is specified, all types are returned.
        :param str engine_version: Database version.
        :param str expire_time: Expiration time. Pay-As-You-Go instances never expire.
        :param str guard_instance_id: If a disaster recovery instance is attached to the current instance, the ID of the disaster recovery instance applies.
        :param str ha_mode: (Available since v1.209.1) The high availability mode of the instance.
        :param Sequence['GetInstancesInstanceHostInstanceInfoArgs'] host_instance_infos: (Available since v1.209.1) An array that consists of the information of the primary and secondary instances.
        :param str id: The ID of the RDS instance.
        :param int instance_storage: (Available in 1.70.3+) User-defined DB instance storage space.
        :param str instance_type: Sizing of the RDS instance.
        :param str key_usage: (Available in 1.124.3+) The purpose of the encryption key.
        :param str last_modify_status: (Available in 1.124.1+) The status of the SSL link. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
               - success
               - setting
               - failed
        :param str master_instance_id: ID of the primary instance. If this parameter is not returned, the current instance is a primary instance.
        :param str master_zone: (Available in 1.101.0+) The master zone of the instance.
        :param str material_expire_time: (Available in 1.124.3+) The time when the encryption key expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param str modify_status_reason: (Available in 1.124.1+) The reason why the SSL link stays in the current state. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str name: The name of the RDS instance.
        :param str net_type: `Internet` for public network or `Intranet` for private network.
        :param str origin: (Available in 1.124.3+) The source of the encryption key.
        :param Sequence['GetInstancesInstanceParameterArgs'] parameters: (Available in 1.135.0+) Parameter list.
        :param str port: (Available in 1.70.3+) RDS database connection port.
        :param Sequence[str] readonly_instance_ids: A list of IDs of read-only instances attached to the primary instance.
        :param str region_id: The region ID of the instance.
        :param str replication_acl: (Available in 1.124.1+) The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
               - cert
               - perfer
               - verify-ca
               - verify-full (supported only when the instance runs PostgreSQL 12 or later)
        :param str require_update: (Available in 1.124.1+) Indicates whether the server certificate needs to be updated.
               - Valid values for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server:
               - No
               - Yes
               - Valid values for ApsaraDB RDS for PostgreSQL:
               - 0: no
               - 1: yes
        :param str require_update_item: (Available in 1.124.1+) The server certificate that needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str require_update_reason: (Available in 1.124.1+) The reason why the server certificate needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str server_ca_url: (Available in 1.124.1+) The URL of the CA that issues the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str server_cert: (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str server_key: (Available in 1.124.1+) The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        :param str ssl_create_time: (Available in 1.124.1+) The time when the server certificate was created. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. In addition, this parameter is valid only when the CAType parameter is set to aliyun.
        :param str ssl_enabled: (Available in 1.124.1+) Indicates whether SSL encryption is enabled. Valid values:
               - on: enabled
               - off: disabled
        :param str ssl_expire_time: (Available in 1.124.1+) The time when the server certificate expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param str status: Status of the instance.
        :param str sync_mode: (Available since v1.209.1) The data replication mode of the instance.
        :param str temp_instance_id: If a temporary instance is attached to the current instance, the ID of the temporary instance applies.
        :param str vpc_id: Used to retrieve instances belong to specified VPC.
        :param str vswitch_id: Used to retrieve instances belong to specified `vswitch` resources.
        :param str zone_id_slave_a: (Available in 1.101.0+) The region ID of the secondary instance if you create a secondary instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
        :param str zone_id_slave_b: (Available in 1.101.0+) The region ID of the log instance if you create a log instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
        """
        GetInstancesInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl=acl,
            availability_zone=availability_zone,
            ca_type=ca_type,
            charge_type=charge_type,
            client_ca_cert=client_ca_cert,
            client_ca_cert_expire_time=client_ca_cert_expire_time,
            client_cert_revocation_list=client_cert_revocation_list,
            connection_mode=connection_mode,
            connection_string=connection_string,
            create_time=create_time,
            creator=creator,
            db_instance_storage_type=db_instance_storage_type,
            db_instance_type=db_instance_type,
            db_type=db_type,
            delete_date=delete_date,
            deletion_protection=deletion_protection,
            description=description,
            encryption_key=encryption_key,
            encryption_key_status=encryption_key_status,
            engine=engine,
            engine_version=engine_version,
            expire_time=expire_time,
            guard_instance_id=guard_instance_id,
            ha_mode=ha_mode,
            host_instance_infos=host_instance_infos,
            id=id,
            instance_storage=instance_storage,
            instance_type=instance_type,
            key_usage=key_usage,
            last_modify_status=last_modify_status,
            master_instance_id=master_instance_id,
            master_zone=master_zone,
            material_expire_time=material_expire_time,
            modify_status_reason=modify_status_reason,
            name=name,
            net_type=net_type,
            origin=origin,
            parameters=parameters,
            port=port,
            readonly_instance_ids=readonly_instance_ids,
            region_id=region_id,
            replication_acl=replication_acl,
            require_update=require_update,
            require_update_item=require_update_item,
            require_update_reason=require_update_reason,
            server_ca_url=server_ca_url,
            server_cert=server_cert,
            server_key=server_key,
            ssl_create_time=ssl_create_time,
            ssl_enabled=ssl_enabled,
            ssl_expire_time=ssl_expire_time,
            status=status,
            sync_mode=sync_mode,
            temp_instance_id=temp_instance_id,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
            zone_id_slave_a=zone_id_slave_a,
            zone_id_slave_b=zone_id_slave_b,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl: Optional[str] = None,
             availability_zone: Optional[str] = None,
             ca_type: Optional[str] = None,
             charge_type: Optional[str] = None,
             client_ca_cert: Optional[str] = None,
             client_ca_cert_expire_time: Optional[str] = None,
             client_cert_revocation_list: Optional[str] = None,
             connection_mode: Optional[str] = None,
             connection_string: Optional[str] = None,
             create_time: Optional[str] = None,
             creator: Optional[str] = None,
             db_instance_storage_type: Optional[str] = None,
             db_instance_type: Optional[str] = None,
             db_type: Optional[str] = None,
             delete_date: Optional[str] = None,
             deletion_protection: Optional[bool] = None,
             description: Optional[str] = None,
             encryption_key: Optional[str] = None,
             encryption_key_status: Optional[str] = None,
             engine: Optional[str] = None,
             engine_version: Optional[str] = None,
             expire_time: Optional[str] = None,
             guard_instance_id: Optional[str] = None,
             ha_mode: Optional[str] = None,
             host_instance_infos: Optional[Sequence['outputs.GetInstancesInstanceHostInstanceInfoResult']] = None,
             id: Optional[str] = None,
             instance_storage: Optional[int] = None,
             instance_type: Optional[str] = None,
             key_usage: Optional[str] = None,
             last_modify_status: Optional[str] = None,
             master_instance_id: Optional[str] = None,
             master_zone: Optional[str] = None,
             material_expire_time: Optional[str] = None,
             modify_status_reason: Optional[str] = None,
             name: Optional[str] = None,
             net_type: Optional[str] = None,
             origin: Optional[str] = None,
             parameters: Optional[Sequence['outputs.GetInstancesInstanceParameterResult']] = None,
             port: Optional[str] = None,
             readonly_instance_ids: Optional[Sequence[str]] = None,
             region_id: Optional[str] = None,
             replication_acl: Optional[str] = None,
             require_update: Optional[str] = None,
             require_update_item: Optional[str] = None,
             require_update_reason: Optional[str] = None,
             server_ca_url: Optional[str] = None,
             server_cert: Optional[str] = None,
             server_key: Optional[str] = None,
             ssl_create_time: Optional[str] = None,
             ssl_enabled: Optional[str] = None,
             ssl_expire_time: Optional[str] = None,
             status: Optional[str] = None,
             sync_mode: Optional[str] = None,
             temp_instance_id: Optional[str] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             zone_id_slave_a: Optional[str] = None,
             zone_id_slave_b: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acl is None:
            raise TypeError("Missing 'acl' argument")
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if ca_type is None and 'caType' in kwargs:
            ca_type = kwargs['caType']
        if ca_type is None:
            raise TypeError("Missing 'ca_type' argument")
        if charge_type is None and 'chargeType' in kwargs:
            charge_type = kwargs['chargeType']
        if charge_type is None:
            raise TypeError("Missing 'charge_type' argument")
        if client_ca_cert is None and 'clientCaCert' in kwargs:
            client_ca_cert = kwargs['clientCaCert']
        if client_ca_cert is None:
            raise TypeError("Missing 'client_ca_cert' argument")
        if client_ca_cert_expire_time is None and 'clientCaCertExpireTime' in kwargs:
            client_ca_cert_expire_time = kwargs['clientCaCertExpireTime']
        if client_ca_cert_expire_time is None:
            raise TypeError("Missing 'client_ca_cert_expire_time' argument")
        if client_cert_revocation_list is None and 'clientCertRevocationList' in kwargs:
            client_cert_revocation_list = kwargs['clientCertRevocationList']
        if client_cert_revocation_list is None:
            raise TypeError("Missing 'client_cert_revocation_list' argument")
        if connection_mode is None and 'connectionMode' in kwargs:
            connection_mode = kwargs['connectionMode']
        if connection_mode is None:
            raise TypeError("Missing 'connection_mode' argument")
        if connection_string is None and 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']
        if connection_string is None:
            raise TypeError("Missing 'connection_string' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if creator is None:
            raise TypeError("Missing 'creator' argument")
        if db_instance_storage_type is None and 'dbInstanceStorageType' in kwargs:
            db_instance_storage_type = kwargs['dbInstanceStorageType']
        if db_instance_storage_type is None:
            raise TypeError("Missing 'db_instance_storage_type' argument")
        if db_instance_type is None and 'dbInstanceType' in kwargs:
            db_instance_type = kwargs['dbInstanceType']
        if db_instance_type is None:
            raise TypeError("Missing 'db_instance_type' argument")
        if db_type is None and 'dbType' in kwargs:
            db_type = kwargs['dbType']
        if db_type is None:
            raise TypeError("Missing 'db_type' argument")
        if delete_date is None and 'deleteDate' in kwargs:
            delete_date = kwargs['deleteDate']
        if delete_date is None:
            raise TypeError("Missing 'delete_date' argument")
        if deletion_protection is None and 'deletionProtection' in kwargs:
            deletion_protection = kwargs['deletionProtection']
        if deletion_protection is None:
            raise TypeError("Missing 'deletion_protection' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if encryption_key is None and 'encryptionKey' in kwargs:
            encryption_key = kwargs['encryptionKey']
        if encryption_key is None:
            raise TypeError("Missing 'encryption_key' argument")
        if encryption_key_status is None and 'encryptionKeyStatus' in kwargs:
            encryption_key_status = kwargs['encryptionKeyStatus']
        if encryption_key_status is None:
            raise TypeError("Missing 'encryption_key_status' argument")
        if engine is None:
            raise TypeError("Missing 'engine' argument")
        if engine_version is None and 'engineVersion' in kwargs:
            engine_version = kwargs['engineVersion']
        if engine_version is None:
            raise TypeError("Missing 'engine_version' argument")
        if expire_time is None and 'expireTime' in kwargs:
            expire_time = kwargs['expireTime']
        if expire_time is None:
            raise TypeError("Missing 'expire_time' argument")
        if guard_instance_id is None and 'guardInstanceId' in kwargs:
            guard_instance_id = kwargs['guardInstanceId']
        if guard_instance_id is None:
            raise TypeError("Missing 'guard_instance_id' argument")
        if ha_mode is None and 'haMode' in kwargs:
            ha_mode = kwargs['haMode']
        if ha_mode is None:
            raise TypeError("Missing 'ha_mode' argument")
        if host_instance_infos is None and 'hostInstanceInfos' in kwargs:
            host_instance_infos = kwargs['hostInstanceInfos']
        if host_instance_infos is None:
            raise TypeError("Missing 'host_instance_infos' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_storage is None and 'instanceStorage' in kwargs:
            instance_storage = kwargs['instanceStorage']
        if instance_storage is None:
            raise TypeError("Missing 'instance_storage' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if key_usage is None and 'keyUsage' in kwargs:
            key_usage = kwargs['keyUsage']
        if key_usage is None:
            raise TypeError("Missing 'key_usage' argument")
        if last_modify_status is None and 'lastModifyStatus' in kwargs:
            last_modify_status = kwargs['lastModifyStatus']
        if last_modify_status is None:
            raise TypeError("Missing 'last_modify_status' argument")
        if master_instance_id is None and 'masterInstanceId' in kwargs:
            master_instance_id = kwargs['masterInstanceId']
        if master_instance_id is None:
            raise TypeError("Missing 'master_instance_id' argument")
        if master_zone is None and 'masterZone' in kwargs:
            master_zone = kwargs['masterZone']
        if master_zone is None:
            raise TypeError("Missing 'master_zone' argument")
        if material_expire_time is None and 'materialExpireTime' in kwargs:
            material_expire_time = kwargs['materialExpireTime']
        if material_expire_time is None:
            raise TypeError("Missing 'material_expire_time' argument")
        if modify_status_reason is None and 'modifyStatusReason' in kwargs:
            modify_status_reason = kwargs['modifyStatusReason']
        if modify_status_reason is None:
            raise TypeError("Missing 'modify_status_reason' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if net_type is None and 'netType' in kwargs:
            net_type = kwargs['netType']
        if net_type is None:
            raise TypeError("Missing 'net_type' argument")
        if origin is None:
            raise TypeError("Missing 'origin' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if readonly_instance_ids is None and 'readonlyInstanceIds' in kwargs:
            readonly_instance_ids = kwargs['readonlyInstanceIds']
        if readonly_instance_ids is None:
            raise TypeError("Missing 'readonly_instance_ids' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if replication_acl is None and 'replicationAcl' in kwargs:
            replication_acl = kwargs['replicationAcl']
        if replication_acl is None:
            raise TypeError("Missing 'replication_acl' argument")
        if require_update is None and 'requireUpdate' in kwargs:
            require_update = kwargs['requireUpdate']
        if require_update is None:
            raise TypeError("Missing 'require_update' argument")
        if require_update_item is None and 'requireUpdateItem' in kwargs:
            require_update_item = kwargs['requireUpdateItem']
        if require_update_item is None:
            raise TypeError("Missing 'require_update_item' argument")
        if require_update_reason is None and 'requireUpdateReason' in kwargs:
            require_update_reason = kwargs['requireUpdateReason']
        if require_update_reason is None:
            raise TypeError("Missing 'require_update_reason' argument")
        if server_ca_url is None and 'serverCaUrl' in kwargs:
            server_ca_url = kwargs['serverCaUrl']
        if server_ca_url is None:
            raise TypeError("Missing 'server_ca_url' argument")
        if server_cert is None and 'serverCert' in kwargs:
            server_cert = kwargs['serverCert']
        if server_cert is None:
            raise TypeError("Missing 'server_cert' argument")
        if server_key is None and 'serverKey' in kwargs:
            server_key = kwargs['serverKey']
        if server_key is None:
            raise TypeError("Missing 'server_key' argument")
        if ssl_create_time is None and 'sslCreateTime' in kwargs:
            ssl_create_time = kwargs['sslCreateTime']
        if ssl_create_time is None:
            raise TypeError("Missing 'ssl_create_time' argument")
        if ssl_enabled is None and 'sslEnabled' in kwargs:
            ssl_enabled = kwargs['sslEnabled']
        if ssl_enabled is None:
            raise TypeError("Missing 'ssl_enabled' argument")
        if ssl_expire_time is None and 'sslExpireTime' in kwargs:
            ssl_expire_time = kwargs['sslExpireTime']
        if ssl_expire_time is None:
            raise TypeError("Missing 'ssl_expire_time' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if sync_mode is None and 'syncMode' in kwargs:
            sync_mode = kwargs['syncMode']
        if sync_mode is None:
            raise TypeError("Missing 'sync_mode' argument")
        if temp_instance_id is None and 'tempInstanceId' in kwargs:
            temp_instance_id = kwargs['tempInstanceId']
        if temp_instance_id is None:
            raise TypeError("Missing 'temp_instance_id' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")
        if zone_id_slave_a is None and 'zoneIdSlaveA' in kwargs:
            zone_id_slave_a = kwargs['zoneIdSlaveA']
        if zone_id_slave_a is None:
            raise TypeError("Missing 'zone_id_slave_a' argument")
        if zone_id_slave_b is None and 'zoneIdSlaveB' in kwargs:
            zone_id_slave_b = kwargs['zoneIdSlaveB']
        if zone_id_slave_b is None:
            raise TypeError("Missing 'zone_id_slave_b' argument")

        _setter("acl", acl)
        _setter("availability_zone", availability_zone)
        _setter("ca_type", ca_type)
        _setter("charge_type", charge_type)
        _setter("client_ca_cert", client_ca_cert)
        _setter("client_ca_cert_expire_time", client_ca_cert_expire_time)
        _setter("client_cert_revocation_list", client_cert_revocation_list)
        _setter("connection_mode", connection_mode)
        _setter("connection_string", connection_string)
        _setter("create_time", create_time)
        _setter("creator", creator)
        _setter("db_instance_storage_type", db_instance_storage_type)
        _setter("db_instance_type", db_instance_type)
        _setter("db_type", db_type)
        _setter("delete_date", delete_date)
        _setter("deletion_protection", deletion_protection)
        _setter("description", description)
        _setter("encryption_key", encryption_key)
        _setter("encryption_key_status", encryption_key_status)
        _setter("engine", engine)
        _setter("engine_version", engine_version)
        _setter("expire_time", expire_time)
        _setter("guard_instance_id", guard_instance_id)
        _setter("ha_mode", ha_mode)
        _setter("host_instance_infos", host_instance_infos)
        _setter("id", id)
        _setter("instance_storage", instance_storage)
        _setter("instance_type", instance_type)
        _setter("key_usage", key_usage)
        _setter("last_modify_status", last_modify_status)
        _setter("master_instance_id", master_instance_id)
        _setter("master_zone", master_zone)
        _setter("material_expire_time", material_expire_time)
        _setter("modify_status_reason", modify_status_reason)
        _setter("name", name)
        _setter("net_type", net_type)
        _setter("origin", origin)
        _setter("parameters", parameters)
        _setter("port", port)
        _setter("readonly_instance_ids", readonly_instance_ids)
        _setter("region_id", region_id)
        _setter("replication_acl", replication_acl)
        _setter("require_update", require_update)
        _setter("require_update_item", require_update_item)
        _setter("require_update_reason", require_update_reason)
        _setter("server_ca_url", server_ca_url)
        _setter("server_cert", server_cert)
        _setter("server_key", server_key)
        _setter("ssl_create_time", ssl_create_time)
        _setter("ssl_enabled", ssl_enabled)
        _setter("ssl_expire_time", ssl_expire_time)
        _setter("status", status)
        _setter("sync_mode", sync_mode)
        _setter("temp_instance_id", temp_instance_id)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)
        _setter("zone_id_slave_a", zone_id_slave_a)
        _setter("zone_id_slave_b", zone_id_slave_b)

    @property
    @pulumi.getter
    def acl(self) -> str:
        """
        (Available in 1.124.1+) The method that is used to verify the identities of clients. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
        - cert
        - perfer
        - verify-ca
        - verify-full (supported only when the instance runs PostgreSQL 12 or later)
        """
        return pulumi.get(self, "acl")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        Availability zone.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="caType")
    def ca_type(self) -> str:
        """
        (Available in 1.124.1+) The type of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
        - aliyun: a cloud certificate
        - custom: a custom certificate
        """
        return pulumi.get(self, "ca_type")

    @property
    @pulumi.getter(name="chargeType")
    def charge_type(self) -> str:
        """
        Billing method. Value options: `Postpaid` for Pay-As-You-Go and `Prepaid` for subscription.
        """
        return pulumi.get(self, "charge_type")

    @property
    @pulumi.getter(name="clientCaCert")
    def client_ca_cert(self) -> str:
        """
        (Available in 1.124.1+) The public key of the CA that issues client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "client_ca_cert")

    @property
    @pulumi.getter(name="clientCaCertExpireTime")
    def client_ca_cert_expire_time(self) -> str:
        """
        (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with cloud disks. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. This parameter is not supported now.
        """
        return pulumi.get(self, "client_ca_cert_expire_time")

    @property
    @pulumi.getter(name="clientCertRevocationList")
    def client_cert_revocation_list(self) -> str:
        """
        (Available in 1.124.1+) The certificate revocation list (CRL) that contains revoked client certificates. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "client_cert_revocation_list")

    @property
    @pulumi.getter(name="connectionMode")
    def connection_mode(self) -> str:
        """
        `Standard` for standard access mode and `Safe` for high security access mode.
        """
        return pulumi.get(self, "connection_mode")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        (Available in 1.70.3+) RDS database connection string.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Creation time of the instance.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def creator(self) -> str:
        """
        (Available in 1.124.3+) The creator of the encryption key.
        """
        return pulumi.get(self, "creator")

    @property
    @pulumi.getter(name="dbInstanceStorageType")
    def db_instance_storage_type(self) -> str:
        """
        (Available in 1.70.3+) The storage type of the instance.
        """
        return pulumi.get(self, "db_instance_storage_type")

    @property
    @pulumi.getter(name="dbInstanceType")
    def db_instance_type(self) -> str:
        """
        (Available in 1.197.0+) The type of instance.
        """
        return pulumi.get(self, "db_instance_type")

    @property
    @pulumi.getter(name="dbType")
    def db_type(self) -> str:
        """
        `Primary` for primary instance, `Readonly` for read-only instance, `Guard` for disaster recovery instance, and `Temp` for temporary instance.
        """
        return pulumi.get(self, "db_type")

    @property
    @pulumi.getter(name="deleteDate")
    def delete_date(self) -> str:
        """
        (Available in 1.124.3+) The estimated time when the encryption key will be deleted. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "delete_date")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> bool:
        """
        (Available in 1.167.0+) Indicates whether the release protection feature is enabled for the instance. Valid values:
        * **true**: The release protection feature is enabled.
        * **false**: The release protection feature is disabled.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        (Available in 1.124.3+) The description of the encryption key.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> str:
        """
        (Available in 1.124.3+) The ID of the encryption key.
        """
        return pulumi.get(self, "encryption_key")

    @property
    @pulumi.getter(name="encryptionKeyStatus")
    def encryption_key_status(self) -> str:
        """
        (Available in 1.124.3+) The status of the encryption key. Valid values:
        - Enabled
        - Disabled
        """
        return pulumi.get(self, "encryption_key_status")

    @property
    @pulumi.getter
    def engine(self) -> str:
        """
        Database type. Options are `MySQL`, `SQLServer`, `PostgreSQL`, `MariaDB`. If no value is specified, all types are returned.
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> str:
        """
        Database version.
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> str:
        """
        Expiration time. Pay-As-You-Go instances never expire.
        """
        return pulumi.get(self, "expire_time")

    @property
    @pulumi.getter(name="guardInstanceId")
    def guard_instance_id(self) -> str:
        """
        If a disaster recovery instance is attached to the current instance, the ID of the disaster recovery instance applies.
        """
        return pulumi.get(self, "guard_instance_id")

    @property
    @pulumi.getter(name="haMode")
    def ha_mode(self) -> str:
        """
        (Available since v1.209.1) The high availability mode of the instance.
        """
        return pulumi.get(self, "ha_mode")

    @property
    @pulumi.getter(name="hostInstanceInfos")
    def host_instance_infos(self) -> Sequence['outputs.GetInstancesInstanceHostInstanceInfoResult']:
        """
        (Available since v1.209.1) An array that consists of the information of the primary and secondary instances.
        """
        return pulumi.get(self, "host_instance_infos")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the RDS instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceStorage")
    def instance_storage(self) -> int:
        """
        (Available in 1.70.3+) User-defined DB instance storage space.
        """
        return pulumi.get(self, "instance_storage")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Sizing of the RDS instance.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="keyUsage")
    def key_usage(self) -> str:
        """
        (Available in 1.124.3+) The purpose of the encryption key.
        """
        return pulumi.get(self, "key_usage")

    @property
    @pulumi.getter(name="lastModifyStatus")
    def last_modify_status(self) -> str:
        """
        (Available in 1.124.1+) The status of the SSL link. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
        - success
        - setting
        - failed
        """
        return pulumi.get(self, "last_modify_status")

    @property
    @pulumi.getter(name="masterInstanceId")
    def master_instance_id(self) -> str:
        """
        ID of the primary instance. If this parameter is not returned, the current instance is a primary instance.
        """
        return pulumi.get(self, "master_instance_id")

    @property
    @pulumi.getter(name="masterZone")
    def master_zone(self) -> str:
        """
        (Available in 1.101.0+) The master zone of the instance.
        """
        return pulumi.get(self, "master_zone")

    @property
    @pulumi.getter(name="materialExpireTime")
    def material_expire_time(self) -> str:
        """
        (Available in 1.124.3+) The time when the encryption key expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "material_expire_time")

    @property
    @pulumi.getter(name="modifyStatusReason")
    def modify_status_reason(self) -> str:
        """
        (Available in 1.124.1+) The reason why the SSL link stays in the current state. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "modify_status_reason")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDS instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="netType")
    def net_type(self) -> str:
        """
        `Internet` for public network or `Intranet` for private network.
        """
        return pulumi.get(self, "net_type")

    @property
    @pulumi.getter
    def origin(self) -> str:
        """
        (Available in 1.124.3+) The source of the encryption key.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetInstancesInstanceParameterResult']:
        """
        (Available in 1.135.0+) Parameter list.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        (Available in 1.70.3+) RDS database connection port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="readonlyInstanceIds")
    def readonly_instance_ids(self) -> Sequence[str]:
        """
        A list of IDs of read-only instances attached to the primary instance.
        """
        return pulumi.get(self, "readonly_instance_ids")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        The region ID of the instance.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="replicationAcl")
    def replication_acl(self) -> str:
        """
        (Available in 1.124.1+) The method that is used to verify the replication permission. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. Valid values:
        - cert
        - perfer
        - verify-ca
        - verify-full (supported only when the instance runs PostgreSQL 12 or later)
        """
        return pulumi.get(self, "replication_acl")

    @property
    @pulumi.getter(name="requireUpdate")
    def require_update(self) -> str:
        """
        (Available in 1.124.1+) Indicates whether the server certificate needs to be updated.
        - Valid values for ApsaraDB RDS for MySQL and ApsaraDB RDS for SQL Server:
        - No
        - Yes
        - Valid values for ApsaraDB RDS for PostgreSQL:
        - 0: no
        - 1: yes
        """
        return pulumi.get(self, "require_update")

    @property
    @pulumi.getter(name="requireUpdateItem")
    def require_update_item(self) -> str:
        """
        (Available in 1.124.1+) The server certificate that needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "require_update_item")

    @property
    @pulumi.getter(name="requireUpdateReason")
    def require_update_reason(self) -> str:
        """
        (Available in 1.124.1+) The reason why the server certificate needs to be updated. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "require_update_reason")

    @property
    @pulumi.getter(name="serverCaUrl")
    def server_ca_url(self) -> str:
        """
        (Available in 1.124.1+) The URL of the CA that issues the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "server_ca_url")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> str:
        """
        (Available in 1.124.1+) The content of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "server_cert")

    @property
    @pulumi.getter(name="serverKey")
    def server_key(self) -> str:
        """
        (Available in 1.124.1+) The private key of the server certificate. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs.
        """
        return pulumi.get(self, "server_key")

    @property
    @pulumi.getter(name="sslCreateTime")
    def ssl_create_time(self) -> str:
        """
        (Available in 1.124.1+) The time when the server certificate was created. This parameter is supported only when the instance runs PostgreSQL with standard or enhanced SSDs. In addition, this parameter is valid only when the CAType parameter is set to aliyun.
        """
        return pulumi.get(self, "ssl_create_time")

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> str:
        """
        (Available in 1.124.1+) Indicates whether SSL encryption is enabled. Valid values:
        - on: enabled
        - off: disabled
        """
        return pulumi.get(self, "ssl_enabled")

    @property
    @pulumi.getter(name="sslExpireTime")
    def ssl_expire_time(self) -> str:
        """
        (Available in 1.124.1+) The time when the server certificate expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "ssl_expire_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the instance.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="syncMode")
    def sync_mode(self) -> str:
        """
        (Available since v1.209.1) The data replication mode of the instance.
        """
        return pulumi.get(self, "sync_mode")

    @property
    @pulumi.getter(name="tempInstanceId")
    def temp_instance_id(self) -> str:
        """
        If a temporary instance is attached to the current instance, the ID of the temporary instance applies.
        """
        return pulumi.get(self, "temp_instance_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Used to retrieve instances belong to specified VPC.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        Used to retrieve instances belong to specified `vswitch` resources.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="zoneIdSlaveA")
    def zone_id_slave_a(self) -> str:
        """
        (Available in 1.101.0+) The region ID of the secondary instance if you create a secondary instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
        """
        return pulumi.get(self, "zone_id_slave_a")

    @property
    @pulumi.getter(name="zoneIdSlaveB")
    def zone_id_slave_b(self) -> str:
        """
        (Available in 1.101.0+) The region ID of the log instance if you create a log instance. If you set this parameter to the same value as the ZoneId parameter, the instance is deployed in a single zone. Otherwise, the instance is deployed in multiple zones.
        """
        return pulumi.get(self, "zone_id_slave_b")


@pulumi.output_type
class GetInstancesInstanceHostInstanceInfoResult(dict):
    def __init__(__self__, *,
                 data_sync_time: str,
                 log_sync_time: str,
                 node_id: str,
                 node_type: str,
                 region_id: str,
                 sync_status: str,
                 zone_id: str):
        """
        :param str data_sync_time: The time when the secondary instance completed the synchronization of data from the primary instance. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param str log_sync_time: The time when the secondary instance received logs from the primary instance. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        :param str node_id: The ID of the instance.
        :param str node_type: The type of the node.
        :param str region_id: The region ID of the instance.
        :param str sync_status: The synchronization status.
        :param str zone_id: The ID of the zone.
        """
        GetInstancesInstanceHostInstanceInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sync_time=data_sync_time,
            log_sync_time=log_sync_time,
            node_id=node_id,
            node_type=node_type,
            region_id=region_id,
            sync_status=sync_status,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sync_time: Optional[str] = None,
             log_sync_time: Optional[str] = None,
             node_id: Optional[str] = None,
             node_type: Optional[str] = None,
             region_id: Optional[str] = None,
             sync_status: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_sync_time is None and 'dataSyncTime' in kwargs:
            data_sync_time = kwargs['dataSyncTime']
        if data_sync_time is None:
            raise TypeError("Missing 'data_sync_time' argument")
        if log_sync_time is None and 'logSyncTime' in kwargs:
            log_sync_time = kwargs['logSyncTime']
        if log_sync_time is None:
            raise TypeError("Missing 'log_sync_time' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")
        if node_type is None and 'nodeType' in kwargs:
            node_type = kwargs['nodeType']
        if node_type is None:
            raise TypeError("Missing 'node_type' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if sync_status is None and 'syncStatus' in kwargs:
            sync_status = kwargs['syncStatus']
        if sync_status is None:
            raise TypeError("Missing 'sync_status' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("data_sync_time", data_sync_time)
        _setter("log_sync_time", log_sync_time)
        _setter("node_id", node_id)
        _setter("node_type", node_type)
        _setter("region_id", region_id)
        _setter("sync_status", sync_status)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="dataSyncTime")
    def data_sync_time(self) -> str:
        """
        The time when the secondary instance completed the synchronization of data from the primary instance. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "data_sync_time")

    @property
    @pulumi.getter(name="logSyncTime")
    def log_sync_time(self) -> str:
        """
        The time when the secondary instance received logs from the primary instance. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        """
        return pulumi.get(self, "log_sync_time")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> str:
        """
        The type of the node.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        The region ID of the instance.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="syncStatus")
    def sync_status(self) -> str:
        """
        The synchronization status.
        """
        return pulumi.get(self, "sync_status")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The ID of the zone.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetInstancesInstanceParameterResult(dict):
    def __init__(__self__, *,
                 checking_code: str,
                 force_modify: str,
                 force_restart: str,
                 parameter_description: str,
                 parameter_name: str,
                 parameter_value: str):
        """
        :param str checking_code: The value range of the parameter.
        :param str force_modify: Indicates whether the parameter can be modified. Valid values: true | false
        :param str force_restart: Indicates whether the modified parameter takes effect only after a database restart. Valid values: true | false
        :param str parameter_description: The description of the parameter.
        :param str parameter_name: The name of the parameter.
        :param str parameter_value: The default value of the parameter.
        """
        GetInstancesInstanceParameterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            checking_code=checking_code,
            force_modify=force_modify,
            force_restart=force_restart,
            parameter_description=parameter_description,
            parameter_name=parameter_name,
            parameter_value=parameter_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             checking_code: Optional[str] = None,
             force_modify: Optional[str] = None,
             force_restart: Optional[str] = None,
             parameter_description: Optional[str] = None,
             parameter_name: Optional[str] = None,
             parameter_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if checking_code is None and 'checkingCode' in kwargs:
            checking_code = kwargs['checkingCode']
        if checking_code is None:
            raise TypeError("Missing 'checking_code' argument")
        if force_modify is None and 'forceModify' in kwargs:
            force_modify = kwargs['forceModify']
        if force_modify is None:
            raise TypeError("Missing 'force_modify' argument")
        if force_restart is None and 'forceRestart' in kwargs:
            force_restart = kwargs['forceRestart']
        if force_restart is None:
            raise TypeError("Missing 'force_restart' argument")
        if parameter_description is None and 'parameterDescription' in kwargs:
            parameter_description = kwargs['parameterDescription']
        if parameter_description is None:
            raise TypeError("Missing 'parameter_description' argument")
        if parameter_name is None and 'parameterName' in kwargs:
            parameter_name = kwargs['parameterName']
        if parameter_name is None:
            raise TypeError("Missing 'parameter_name' argument")
        if parameter_value is None and 'parameterValue' in kwargs:
            parameter_value = kwargs['parameterValue']
        if parameter_value is None:
            raise TypeError("Missing 'parameter_value' argument")

        _setter("checking_code", checking_code)
        _setter("force_modify", force_modify)
        _setter("force_restart", force_restart)
        _setter("parameter_description", parameter_description)
        _setter("parameter_name", parameter_name)
        _setter("parameter_value", parameter_value)

    @property
    @pulumi.getter(name="checkingCode")
    def checking_code(self) -> str:
        """
        The value range of the parameter.
        """
        return pulumi.get(self, "checking_code")

    @property
    @pulumi.getter(name="forceModify")
    def force_modify(self) -> str:
        """
        Indicates whether the parameter can be modified. Valid values: true | false
        """
        return pulumi.get(self, "force_modify")

    @property
    @pulumi.getter(name="forceRestart")
    def force_restart(self) -> str:
        """
        Indicates whether the modified parameter takes effect only after a database restart. Valid values: true | false
        """
        return pulumi.get(self, "force_restart")

    @property
    @pulumi.getter(name="parameterDescription")
    def parameter_description(self) -> str:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "parameter_description")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> str:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="parameterValue")
    def parameter_value(self) -> str:
        """
        The default value of the parameter.
        """
        return pulumi.get(self, "parameter_value")


@pulumi.output_type
class GetModifyParameterLogsLogResult(dict):
    def __init__(__self__, *,
                 modify_time: str,
                 new_parameter_value: str,
                 old_parameter_value: str,
                 parameter_name: str,
                 status: str):
        """
        :param str modify_time: The time when the parameter was reconfigured. This value is a UNIX timestamp. Unit: milliseconds.
        :param str new_parameter_value: The new value of the parameter.
        :param str old_parameter_value: The original value of the parameter.
        :param str parameter_name: The name of the parameter.
        :param str status: The status of the new value specified for the parameter. Valid values:
               * **Applied**: The new value has taken effect.
               * **Syncing**: The new value is being applied and has not taken effect.
        """
        GetModifyParameterLogsLogResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            modify_time=modify_time,
            new_parameter_value=new_parameter_value,
            old_parameter_value=old_parameter_value,
            parameter_name=parameter_name,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             modify_time: Optional[str] = None,
             new_parameter_value: Optional[str] = None,
             old_parameter_value: Optional[str] = None,
             parameter_name: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if modify_time is None and 'modifyTime' in kwargs:
            modify_time = kwargs['modifyTime']
        if modify_time is None:
            raise TypeError("Missing 'modify_time' argument")
        if new_parameter_value is None and 'newParameterValue' in kwargs:
            new_parameter_value = kwargs['newParameterValue']
        if new_parameter_value is None:
            raise TypeError("Missing 'new_parameter_value' argument")
        if old_parameter_value is None and 'oldParameterValue' in kwargs:
            old_parameter_value = kwargs['oldParameterValue']
        if old_parameter_value is None:
            raise TypeError("Missing 'old_parameter_value' argument")
        if parameter_name is None and 'parameterName' in kwargs:
            parameter_name = kwargs['parameterName']
        if parameter_name is None:
            raise TypeError("Missing 'parameter_name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("modify_time", modify_time)
        _setter("new_parameter_value", new_parameter_value)
        _setter("old_parameter_value", old_parameter_value)
        _setter("parameter_name", parameter_name)
        _setter("status", status)

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> str:
        """
        The time when the parameter was reconfigured. This value is a UNIX timestamp. Unit: milliseconds.
        """
        return pulumi.get(self, "modify_time")

    @property
    @pulumi.getter(name="newParameterValue")
    def new_parameter_value(self) -> str:
        """
        The new value of the parameter.
        """
        return pulumi.get(self, "new_parameter_value")

    @property
    @pulumi.getter(name="oldParameterValue")
    def old_parameter_value(self) -> str:
        """
        The original value of the parameter.
        """
        return pulumi.get(self, "old_parameter_value")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> str:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the new value specified for the parameter. Valid values:
        * **Applied**: The new value has taken effect.
        * **Syncing**: The new value is being applied and has not taken effect.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRdsBackupsBackupResult(dict):
    def __init__(__self__, *,
                 backup_download_url: str,
                 backup_end_time: str,
                 backup_id: str,
                 backup_initiator: str,
                 backup_intranet_download_url: str,
                 backup_method: str,
                 backup_mode: str,
                 backup_size: str,
                 backup_start_time: str,
                 backup_status: str,
                 backup_type: str,
                 consistent_time: str,
                 copy_only_backup: str,
                 db_instance_id: str,
                 encryption: str,
                 host_instance_id: str,
                 id: str,
                 is_avail: int,
                 meta_status: str,
                 storage_class: str,
                 store_status: str):
        """
        :param str backup_download_url: The backup download url.
        :param str backup_end_time: BackupEndTime.
        :param str backup_id: BackupId.
        :param str backup_initiator: The initiator of the backup task. Value:
               * **System**: automatically initiated by the System
               * **User**: manually initiated by the User.
        :param str backup_intranet_download_url: The backup intranet download url.
        :param str backup_method: BackupMethod.
        :param str backup_mode: BackupMode.
        :param str backup_size: BackupSize.
        :param str backup_start_time: BackupStartTime.
        :param str backup_status: Backup task status. **NOTE:** This parameter will only be returned when a task is executed. Value:
               * **NoStart**: Not started
               * **Checking**: check the backup
               * **Preparing**: Prepare a backup
               * **Waiting**: Waiting for backup
               * **Uploading**: Upload backup
               * **Finished**: Complete backup
               * **Failed**: backup Failed
        :param str backup_type: BackupType.
        :param str consistent_time: The consistency point of the backup set. The return value is a timestamp. **NOTE:** only MySQL 5.6 returns this parameter, and other versions return 0.
        :param str copy_only_backup: The backup mode is divided into the normal backup mode (full and incremental recovery is supported) and the replication-only mode (full recovery is supported only). **NOTE:** Only SQL Server returns this parameter. Valid values:
               * **0**: General Backup Mode
               * **1**: Copy only mode
        :param str db_instance_id: The db instance id.
        :param str encryption: The encrypted information of the backup set.
        :param str host_instance_id: HostInstanceID.
        :param str id: The ID of the Backup.
        :param int is_avail: Whether the backup set is available, the value is:
               * **0**: Not available
               * **1**: Available.
        :param str meta_status: The backup set status of the database table. **NOTE:** an empty string indicates that the backup set for database table recovery is not enabled. Valid values:
               * **OK**: normal.
               * **LARGE**: There are too many tables that cannot be used for database and table recovery.
               * **EMPTY**: The backup set that failed to be backed up.
        :param str storage_class: The storage medium for the backup set. Valid values:
               * **0**: Regular storage
               * **1**: Archive storage.
        :param str store_status: StoreStatus.
        """
        GetRdsBackupsBackupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_download_url=backup_download_url,
            backup_end_time=backup_end_time,
            backup_id=backup_id,
            backup_initiator=backup_initiator,
            backup_intranet_download_url=backup_intranet_download_url,
            backup_method=backup_method,
            backup_mode=backup_mode,
            backup_size=backup_size,
            backup_start_time=backup_start_time,
            backup_status=backup_status,
            backup_type=backup_type,
            consistent_time=consistent_time,
            copy_only_backup=copy_only_backup,
            db_instance_id=db_instance_id,
            encryption=encryption,
            host_instance_id=host_instance_id,
            id=id,
            is_avail=is_avail,
            meta_status=meta_status,
            storage_class=storage_class,
            store_status=store_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_download_url: Optional[str] = None,
             backup_end_time: Optional[str] = None,
             backup_id: Optional[str] = None,
             backup_initiator: Optional[str] = None,
             backup_intranet_download_url: Optional[str] = None,
             backup_method: Optional[str] = None,
             backup_mode: Optional[str] = None,
             backup_size: Optional[str] = None,
             backup_start_time: Optional[str] = None,
             backup_status: Optional[str] = None,
             backup_type: Optional[str] = None,
             consistent_time: Optional[str] = None,
             copy_only_backup: Optional[str] = None,
             db_instance_id: Optional[str] = None,
             encryption: Optional[str] = None,
             host_instance_id: Optional[str] = None,
             id: Optional[str] = None,
             is_avail: Optional[int] = None,
             meta_status: Optional[str] = None,
             storage_class: Optional[str] = None,
             store_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_download_url is None and 'backupDownloadUrl' in kwargs:
            backup_download_url = kwargs['backupDownloadUrl']
        if backup_download_url is None:
            raise TypeError("Missing 'backup_download_url' argument")
        if backup_end_time is None and 'backupEndTime' in kwargs:
            backup_end_time = kwargs['backupEndTime']
        if backup_end_time is None:
            raise TypeError("Missing 'backup_end_time' argument")
        if backup_id is None and 'backupId' in kwargs:
            backup_id = kwargs['backupId']
        if backup_id is None:
            raise TypeError("Missing 'backup_id' argument")
        if backup_initiator is None and 'backupInitiator' in kwargs:
            backup_initiator = kwargs['backupInitiator']
        if backup_initiator is None:
            raise TypeError("Missing 'backup_initiator' argument")
        if backup_intranet_download_url is None and 'backupIntranetDownloadUrl' in kwargs:
            backup_intranet_download_url = kwargs['backupIntranetDownloadUrl']
        if backup_intranet_download_url is None:
            raise TypeError("Missing 'backup_intranet_download_url' argument")
        if backup_method is None and 'backupMethod' in kwargs:
            backup_method = kwargs['backupMethod']
        if backup_method is None:
            raise TypeError("Missing 'backup_method' argument")
        if backup_mode is None and 'backupMode' in kwargs:
            backup_mode = kwargs['backupMode']
        if backup_mode is None:
            raise TypeError("Missing 'backup_mode' argument")
        if backup_size is None and 'backupSize' in kwargs:
            backup_size = kwargs['backupSize']
        if backup_size is None:
            raise TypeError("Missing 'backup_size' argument")
        if backup_start_time is None and 'backupStartTime' in kwargs:
            backup_start_time = kwargs['backupStartTime']
        if backup_start_time is None:
            raise TypeError("Missing 'backup_start_time' argument")
        if backup_status is None and 'backupStatus' in kwargs:
            backup_status = kwargs['backupStatus']
        if backup_status is None:
            raise TypeError("Missing 'backup_status' argument")
        if backup_type is None and 'backupType' in kwargs:
            backup_type = kwargs['backupType']
        if backup_type is None:
            raise TypeError("Missing 'backup_type' argument")
        if consistent_time is None and 'consistentTime' in kwargs:
            consistent_time = kwargs['consistentTime']
        if consistent_time is None:
            raise TypeError("Missing 'consistent_time' argument")
        if copy_only_backup is None and 'copyOnlyBackup' in kwargs:
            copy_only_backup = kwargs['copyOnlyBackup']
        if copy_only_backup is None:
            raise TypeError("Missing 'copy_only_backup' argument")
        if db_instance_id is None and 'dbInstanceId' in kwargs:
            db_instance_id = kwargs['dbInstanceId']
        if db_instance_id is None:
            raise TypeError("Missing 'db_instance_id' argument")
        if encryption is None:
            raise TypeError("Missing 'encryption' argument")
        if host_instance_id is None and 'hostInstanceId' in kwargs:
            host_instance_id = kwargs['hostInstanceId']
        if host_instance_id is None:
            raise TypeError("Missing 'host_instance_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_avail is None and 'isAvail' in kwargs:
            is_avail = kwargs['isAvail']
        if is_avail is None:
            raise TypeError("Missing 'is_avail' argument")
        if meta_status is None and 'metaStatus' in kwargs:
            meta_status = kwargs['metaStatus']
        if meta_status is None:
            raise TypeError("Missing 'meta_status' argument")
        if storage_class is None and 'storageClass' in kwargs:
            storage_class = kwargs['storageClass']
        if storage_class is None:
            raise TypeError("Missing 'storage_class' argument")
        if store_status is None and 'storeStatus' in kwargs:
            store_status = kwargs['storeStatus']
        if store_status is None:
            raise TypeError("Missing 'store_status' argument")

        _setter("backup_download_url", backup_download_url)
        _setter("backup_end_time", backup_end_time)
        _setter("backup_id", backup_id)
        _setter("backup_initiator", backup_initiator)
        _setter("backup_intranet_download_url", backup_intranet_download_url)
        _setter("backup_method", backup_method)
        _setter("backup_mode", backup_mode)
        _setter("backup_size", backup_size)
        _setter("backup_start_time", backup_start_time)
        _setter("backup_status", backup_status)
        _setter("backup_type", backup_type)
        _setter("consistent_time", consistent_time)
        _setter("copy_only_backup", copy_only_backup)
        _setter("db_instance_id", db_instance_id)
        _setter("encryption", encryption)
        _setter("host_instance_id", host_instance_id)
        _setter("id", id)
        _setter("is_avail", is_avail)
        _setter("meta_status", meta_status)
        _setter("storage_class", storage_class)
        _setter("store_status", store_status)

    @property
    @pulumi.getter(name="backupDownloadUrl")
    def backup_download_url(self) -> str:
        """
        The backup download url.
        """
        return pulumi.get(self, "backup_download_url")

    @property
    @pulumi.getter(name="backupEndTime")
    def backup_end_time(self) -> str:
        """
        BackupEndTime.
        """
        return pulumi.get(self, "backup_end_time")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        """
        BackupId.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupInitiator")
    def backup_initiator(self) -> str:
        """
        The initiator of the backup task. Value:
        * **System**: automatically initiated by the System
        * **User**: manually initiated by the User.
        """
        return pulumi.get(self, "backup_initiator")

    @property
    @pulumi.getter(name="backupIntranetDownloadUrl")
    def backup_intranet_download_url(self) -> str:
        """
        The backup intranet download url.
        """
        return pulumi.get(self, "backup_intranet_download_url")

    @property
    @pulumi.getter(name="backupMethod")
    def backup_method(self) -> str:
        """
        BackupMethod.
        """
        return pulumi.get(self, "backup_method")

    @property
    @pulumi.getter(name="backupMode")
    def backup_mode(self) -> str:
        """
        BackupMode.
        """
        return pulumi.get(self, "backup_mode")

    @property
    @pulumi.getter(name="backupSize")
    def backup_size(self) -> str:
        """
        BackupSize.
        """
        return pulumi.get(self, "backup_size")

    @property
    @pulumi.getter(name="backupStartTime")
    def backup_start_time(self) -> str:
        """
        BackupStartTime.
        """
        return pulumi.get(self, "backup_start_time")

    @property
    @pulumi.getter(name="backupStatus")
    def backup_status(self) -> str:
        """
        Backup task status. **NOTE:** This parameter will only be returned when a task is executed. Value:
        * **NoStart**: Not started
        * **Checking**: check the backup
        * **Preparing**: Prepare a backup
        * **Waiting**: Waiting for backup
        * **Uploading**: Upload backup
        * **Finished**: Complete backup
        * **Failed**: backup Failed
        """
        return pulumi.get(self, "backup_status")

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> str:
        """
        BackupType.
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter(name="consistentTime")
    def consistent_time(self) -> str:
        """
        The consistency point of the backup set. The return value is a timestamp. **NOTE:** only MySQL 5.6 returns this parameter, and other versions return 0.
        """
        return pulumi.get(self, "consistent_time")

    @property
    @pulumi.getter(name="copyOnlyBackup")
    def copy_only_backup(self) -> str:
        """
        The backup mode is divided into the normal backup mode (full and incremental recovery is supported) and the replication-only mode (full recovery is supported only). **NOTE:** Only SQL Server returns this parameter. Valid values:
        * **0**: General Backup Mode
        * **1**: Copy only mode
        """
        return pulumi.get(self, "copy_only_backup")

    @property
    @pulumi.getter(name="dbInstanceId")
    def db_instance_id(self) -> str:
        """
        The db instance id.
        """
        return pulumi.get(self, "db_instance_id")

    @property
    @pulumi.getter
    def encryption(self) -> str:
        """
        The encrypted information of the backup set.
        """
        return pulumi.get(self, "encryption")

    @property
    @pulumi.getter(name="hostInstanceId")
    def host_instance_id(self) -> str:
        """
        HostInstanceID.
        """
        return pulumi.get(self, "host_instance_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Backup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAvail")
    def is_avail(self) -> int:
        """
        Whether the backup set is available, the value is:
        * **0**: Not available
        * **1**: Available.
        """
        return pulumi.get(self, "is_avail")

    @property
    @pulumi.getter(name="metaStatus")
    def meta_status(self) -> str:
        """
        The backup set status of the database table. **NOTE:** an empty string indicates that the backup set for database table recovery is not enabled. Valid values:
        * **OK**: normal.
        * **LARGE**: There are too many tables that cannot be used for database and table recovery.
        * **EMPTY**: The backup set that failed to be backed up.
        """
        return pulumi.get(self, "meta_status")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        The storage medium for the backup set. Valid values:
        * **0**: Regular storage
        * **1**: Archive storage.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter(name="storeStatus")
    def store_status(self) -> str:
        """
        StoreStatus.
        """
        return pulumi.get(self, "store_status")


@pulumi.output_type
class GetRdsParameterGroupsGroupResult(dict):
    def __init__(__self__, *,
                 engine: str,
                 engine_version: str,
                 force_restart: int,
                 id: str,
                 param_counts: int,
                 param_details: Sequence['outputs.GetRdsParameterGroupsGroupParamDetailResult'],
                 parameter_group_desc: str,
                 parameter_group_id: str,
                 parameter_group_name: str,
                 parameter_group_type: int):
        GetRdsParameterGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            engine=engine,
            engine_version=engine_version,
            force_restart=force_restart,
            id=id,
            param_counts=param_counts,
            param_details=param_details,
            parameter_group_desc=parameter_group_desc,
            parameter_group_id=parameter_group_id,
            parameter_group_name=parameter_group_name,
            parameter_group_type=parameter_group_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             engine: Optional[str] = None,
             engine_version: Optional[str] = None,
             force_restart: Optional[int] = None,
             id: Optional[str] = None,
             param_counts: Optional[int] = None,
             param_details: Optional[Sequence['outputs.GetRdsParameterGroupsGroupParamDetailResult']] = None,
             parameter_group_desc: Optional[str] = None,
             parameter_group_id: Optional[str] = None,
             parameter_group_name: Optional[str] = None,
             parameter_group_type: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if engine is None:
            raise TypeError("Missing 'engine' argument")
        if engine_version is None and 'engineVersion' in kwargs:
            engine_version = kwargs['engineVersion']
        if engine_version is None:
            raise TypeError("Missing 'engine_version' argument")
        if force_restart is None and 'forceRestart' in kwargs:
            force_restart = kwargs['forceRestart']
        if force_restart is None:
            raise TypeError("Missing 'force_restart' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if param_counts is None and 'paramCounts' in kwargs:
            param_counts = kwargs['paramCounts']
        if param_counts is None:
            raise TypeError("Missing 'param_counts' argument")
        if param_details is None and 'paramDetails' in kwargs:
            param_details = kwargs['paramDetails']
        if param_details is None:
            raise TypeError("Missing 'param_details' argument")
        if parameter_group_desc is None and 'parameterGroupDesc' in kwargs:
            parameter_group_desc = kwargs['parameterGroupDesc']
        if parameter_group_desc is None:
            raise TypeError("Missing 'parameter_group_desc' argument")
        if parameter_group_id is None and 'parameterGroupId' in kwargs:
            parameter_group_id = kwargs['parameterGroupId']
        if parameter_group_id is None:
            raise TypeError("Missing 'parameter_group_id' argument")
        if parameter_group_name is None and 'parameterGroupName' in kwargs:
            parameter_group_name = kwargs['parameterGroupName']
        if parameter_group_name is None:
            raise TypeError("Missing 'parameter_group_name' argument")
        if parameter_group_type is None and 'parameterGroupType' in kwargs:
            parameter_group_type = kwargs['parameterGroupType']
        if parameter_group_type is None:
            raise TypeError("Missing 'parameter_group_type' argument")

        _setter("engine", engine)
        _setter("engine_version", engine_version)
        _setter("force_restart", force_restart)
        _setter("id", id)
        _setter("param_counts", param_counts)
        _setter("param_details", param_details)
        _setter("parameter_group_desc", parameter_group_desc)
        _setter("parameter_group_id", parameter_group_id)
        _setter("parameter_group_name", parameter_group_name)
        _setter("parameter_group_type", parameter_group_type)

    @property
    @pulumi.getter
    def engine(self) -> str:
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> str:
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="forceRestart")
    def force_restart(self) -> int:
        return pulumi.get(self, "force_restart")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="paramCounts")
    def param_counts(self) -> int:
        return pulumi.get(self, "param_counts")

    @property
    @pulumi.getter(name="paramDetails")
    def param_details(self) -> Sequence['outputs.GetRdsParameterGroupsGroupParamDetailResult']:
        return pulumi.get(self, "param_details")

    @property
    @pulumi.getter(name="parameterGroupDesc")
    def parameter_group_desc(self) -> str:
        return pulumi.get(self, "parameter_group_desc")

    @property
    @pulumi.getter(name="parameterGroupId")
    def parameter_group_id(self) -> str:
        return pulumi.get(self, "parameter_group_id")

    @property
    @pulumi.getter(name="parameterGroupName")
    def parameter_group_name(self) -> str:
        return pulumi.get(self, "parameter_group_name")

    @property
    @pulumi.getter(name="parameterGroupType")
    def parameter_group_type(self) -> int:
        return pulumi.get(self, "parameter_group_type")


@pulumi.output_type
class GetRdsParameterGroupsGroupParamDetailResult(dict):
    def __init__(__self__, *,
                 param_name: str,
                 param_value: str):
        GetRdsParameterGroupsGroupParamDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            param_name=param_name,
            param_value=param_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             param_name: Optional[str] = None,
             param_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if param_name is None and 'paramName' in kwargs:
            param_name = kwargs['paramName']
        if param_name is None:
            raise TypeError("Missing 'param_name' argument")
        if param_value is None and 'paramValue' in kwargs:
            param_value = kwargs['paramValue']
        if param_value is None:
            raise TypeError("Missing 'param_value' argument")

        _setter("param_name", param_name)
        _setter("param_value", param_value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> str:
        return pulumi.get(self, "param_name")

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> str:
        return pulumi.get(self, "param_value")


@pulumi.output_type
class GetSlotsSlotResult(dict):
    def __init__(__self__, *,
                 database: str,
                 plugin: str,
                 slot_name: str,
                 slot_status: str,
                 slot_type: str,
                 temporary: str,
                 wal_delay: str):
        """
        :param str database: The name of the database where Replication Slot is located.
        :param str plugin: The plugin used by Replication Slot.
        :param str slot_name: The Replication Slot name.
        :param str slot_status: The Replication Slot status.
        :param str slot_type: The Replication Slot type.
        :param str temporary: Is the Replication Slot temporary.
        :param str wal_delay: The amount of logs accumulated by Replication Slot.
        """
        GetSlotsSlotResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            plugin=plugin,
            slot_name=slot_name,
            slot_status=slot_status,
            slot_type=slot_type,
            temporary=temporary,
            wal_delay=wal_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             plugin: Optional[str] = None,
             slot_name: Optional[str] = None,
             slot_status: Optional[str] = None,
             slot_type: Optional[str] = None,
             temporary: Optional[str] = None,
             wal_delay: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if plugin is None:
            raise TypeError("Missing 'plugin' argument")
        if slot_name is None and 'slotName' in kwargs:
            slot_name = kwargs['slotName']
        if slot_name is None:
            raise TypeError("Missing 'slot_name' argument")
        if slot_status is None and 'slotStatus' in kwargs:
            slot_status = kwargs['slotStatus']
        if slot_status is None:
            raise TypeError("Missing 'slot_status' argument")
        if slot_type is None and 'slotType' in kwargs:
            slot_type = kwargs['slotType']
        if slot_type is None:
            raise TypeError("Missing 'slot_type' argument")
        if temporary is None:
            raise TypeError("Missing 'temporary' argument")
        if wal_delay is None and 'walDelay' in kwargs:
            wal_delay = kwargs['walDelay']
        if wal_delay is None:
            raise TypeError("Missing 'wal_delay' argument")

        _setter("database", database)
        _setter("plugin", plugin)
        _setter("slot_name", slot_name)
        _setter("slot_status", slot_status)
        _setter("slot_type", slot_type)
        _setter("temporary", temporary)
        _setter("wal_delay", wal_delay)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database where Replication Slot is located.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def plugin(self) -> str:
        """
        The plugin used by Replication Slot.
        """
        return pulumi.get(self, "plugin")

    @property
    @pulumi.getter(name="slotName")
    def slot_name(self) -> str:
        """
        The Replication Slot name.
        """
        return pulumi.get(self, "slot_name")

    @property
    @pulumi.getter(name="slotStatus")
    def slot_status(self) -> str:
        """
        The Replication Slot status.
        """
        return pulumi.get(self, "slot_status")

    @property
    @pulumi.getter(name="slotType")
    def slot_type(self) -> str:
        """
        The Replication Slot type.
        """
        return pulumi.get(self, "slot_type")

    @property
    @pulumi.getter
    def temporary(self) -> str:
        """
        Is the Replication Slot temporary.
        """
        return pulumi.get(self, "temporary")

    @property
    @pulumi.getter(name="walDelay")
    def wal_delay(self) -> str:
        """
        The amount of logs accumulated by Replication Slot.
        """
        return pulumi.get(self, "wal_delay")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: str,
                 multi_zone_ids: Sequence[str]):
        """
        :param str id: ID of the zone.
        :param Sequence[str] multi_zone_ids: A list of zone ids in which the multi zone.
        """
        GetZonesZoneResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            multi_zone_ids=multi_zone_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             multi_zone_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if multi_zone_ids is None and 'multiZoneIds' in kwargs:
            multi_zone_ids = kwargs['multiZoneIds']
        if multi_zone_ids is None:
            raise TypeError("Missing 'multi_zone_ids' argument")

        _setter("id", id)
        _setter("multi_zone_ids", multi_zone_ids)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the zone.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="multiZoneIds")
    def multi_zone_ids(self) -> Sequence[str]:
        """
        A list of zone ids in which the multi zone.
        """
        return pulumi.get(self, "multi_zone_ids")


