# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'EnterpriseSnapshotPolicyCrossRegionCopyInfoArgs',
    'EnterpriseSnapshotPolicyCrossRegionCopyInfoArgsDict',
    'EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgs',
    'EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgsDict',
    'EnterpriseSnapshotPolicyRetainRuleArgs',
    'EnterpriseSnapshotPolicyRetainRuleArgsDict',
    'EnterpriseSnapshotPolicyScheduleArgs',
    'EnterpriseSnapshotPolicyScheduleArgsDict',
    'EnterpriseSnapshotPolicySpecialRetainRulesArgs',
    'EnterpriseSnapshotPolicySpecialRetainRulesArgsDict',
    'EnterpriseSnapshotPolicySpecialRetainRulesRuleArgs',
    'EnterpriseSnapshotPolicySpecialRetainRulesRuleArgsDict',
    'EnterpriseSnapshotPolicyStorageRuleArgs',
    'EnterpriseSnapshotPolicyStorageRuleArgsDict',
    'SolutionInstanceParameterArgs',
    'SolutionInstanceParameterArgsDict',
]

MYPY = False

if not MYPY:
    class EnterpriseSnapshotPolicyCrossRegionCopyInfoArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable Snapshot replication.
        """
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgsDict']]]]
        """
        Destination region for Snapshot replication. See `regions` below.
        """
elif False:
    EnterpriseSnapshotPolicyCrossRegionCopyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicyCrossRegionCopyInfoArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable Snapshot replication.
        :param pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgs']]] regions: Destination region for Snapshot replication. See `regions` below.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Snapshot replication.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgs']]]]:
        """
        Destination region for Snapshot replication. See `regions` below.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgs']]]]):
        pulumi.set(self, "regions", value)


if not MYPY:
    class EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgsDict(TypedDict):
        region_id: NotRequired[pulumi.Input[str]]
        """
        Destination region ID.
        """
        retain_days: NotRequired[pulumi.Input[int]]
        """
        Number of days of snapshot retention for replication.
        """
elif False:
    EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicyCrossRegionCopyInfoRegionArgs:
    def __init__(__self__, *,
                 region_id: Optional[pulumi.Input[str]] = None,
                 retain_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] region_id: Destination region ID.
        :param pulumi.Input[int] retain_days: Number of days of snapshot retention for replication.
        """
        if region_id is not None:
            pulumi.set(__self__, "region_id", region_id)
        if retain_days is not None:
            pulumi.set(__self__, "retain_days", retain_days)

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> Optional[pulumi.Input[str]]:
        """
        Destination region ID.
        """
        return pulumi.get(self, "region_id")

    @region_id.setter
    def region_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_id", value)

    @property
    @pulumi.getter(name="retainDays")
    def retain_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days of snapshot retention for replication.
        """
        return pulumi.get(self, "retain_days")

    @retain_days.setter
    def retain_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retain_days", value)


if not MYPY:
    class EnterpriseSnapshotPolicyRetainRuleArgsDict(TypedDict):
        number: NotRequired[pulumi.Input[int]]
        """
        Retention based on counting method.
        """
        time_interval: NotRequired[pulumi.Input[int]]
        """
        Time unit.
        """
        time_unit: NotRequired[pulumi.Input[str]]
        """
        Time-based retention.
        """
elif False:
    EnterpriseSnapshotPolicyRetainRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicyRetainRuleArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None,
                 time_interval: Optional[pulumi.Input[int]] = None,
                 time_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] number: Retention based on counting method.
        :param pulumi.Input[int] time_interval: Time unit.
        :param pulumi.Input[str] time_unit: Time-based retention.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        """
        Retention based on counting method.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Time unit.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        Time-based retention.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class EnterpriseSnapshotPolicyScheduleArgsDict(TypedDict):
        cron_expression: pulumi.Input[str]
        """
        CronTab expression.
        """
elif False:
    EnterpriseSnapshotPolicyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicyScheduleArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cron_expression: CronTab expression.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        CronTab expression.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)


if not MYPY:
    class EnterpriseSnapshotPolicySpecialRetainRulesArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether special reservations are enabled. Value range:
        - true
        - false.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicySpecialRetainRulesRuleArgsDict']]]]
        """
        List of special retention rules. See `rules` below.
        """
elif False:
    EnterpriseSnapshotPolicySpecialRetainRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicySpecialRetainRulesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicySpecialRetainRulesRuleArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether special reservations are enabled. Value range:
               - true
               - false.
        :param pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicySpecialRetainRulesRuleArgs']]] rules: List of special retention rules. See `rules` below.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether special reservations are enabled. Value range:
        - true
        - false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicySpecialRetainRulesRuleArgs']]]]:
        """
        List of special retention rules. See `rules` below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnterpriseSnapshotPolicySpecialRetainRulesRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class EnterpriseSnapshotPolicySpecialRetainRulesRuleArgsDict(TypedDict):
        special_period_unit: NotRequired[pulumi.Input[str]]
        """
        The cycle unit of the special reserved snapshot. If the value is set to WEEKS, the first snapshot of each week is reserved. The retention time is determined by TimeUnit and TimeInterval. The value range is:
        - WEEKS
        - MONTHS
        - YEARS.
        """
        time_interval: NotRequired[pulumi.Input[int]]
        time_unit: NotRequired[pulumi.Input[str]]
elif False:
    EnterpriseSnapshotPolicySpecialRetainRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicySpecialRetainRulesRuleArgs:
    def __init__(__self__, *,
                 special_period_unit: Optional[pulumi.Input[str]] = None,
                 time_interval: Optional[pulumi.Input[int]] = None,
                 time_unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] special_period_unit: The cycle unit of the special reserved snapshot. If the value is set to WEEKS, the first snapshot of each week is reserved. The retention time is determined by TimeUnit and TimeInterval. The value range is:
               - WEEKS
               - MONTHS
               - YEARS.
        """
        if special_period_unit is not None:
            pulumi.set(__self__, "special_period_unit", special_period_unit)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="specialPeriodUnit")
    def special_period_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The cycle unit of the special reserved snapshot. If the value is set to WEEKS, the first snapshot of each week is reserved. The retention time is determined by TimeUnit and TimeInterval. The value range is:
        - WEEKS
        - MONTHS
        - YEARS.
        """
        return pulumi.get(self, "special_period_unit")

    @special_period_unit.setter
    def special_period_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "special_period_unit", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class EnterpriseSnapshotPolicyStorageRuleArgsDict(TypedDict):
        enable_immediate_access: NotRequired[pulumi.Input[bool]]
        """
        Snapshot speed available.
        """
elif False:
    EnterpriseSnapshotPolicyStorageRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseSnapshotPolicyStorageRuleArgs:
    def __init__(__self__, *,
                 enable_immediate_access: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_immediate_access: Snapshot speed available.
        """
        if enable_immediate_access is not None:
            pulumi.set(__self__, "enable_immediate_access", enable_immediate_access)

    @property
    @pulumi.getter(name="enableImmediateAccess")
    def enable_immediate_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Snapshot speed available.
        """
        return pulumi.get(self, "enable_immediate_access")

    @enable_immediate_access.setter
    def enable_immediate_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_immediate_access", value)


if not MYPY:
    class SolutionInstanceParameterArgsDict(TypedDict):
        parameter_key: pulumi.Input[str]
        """
        Create parameter Key.
        """
        parameter_value: pulumi.Input[str]
        """
        Create parameter Value.
        """
elif False:
    SolutionInstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SolutionInstanceParameterArgs:
    def __init__(__self__, *,
                 parameter_key: pulumi.Input[str],
                 parameter_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] parameter_key: Create parameter Key.
        :param pulumi.Input[str] parameter_value: Create parameter Value.
        """
        pulumi.set(__self__, "parameter_key", parameter_key)
        pulumi.set(__self__, "parameter_value", parameter_value)

    @property
    @pulumi.getter(name="parameterKey")
    def parameter_key(self) -> pulumi.Input[str]:
        """
        Create parameter Key.
        """
        return pulumi.get(self, "parameter_key")

    @parameter_key.setter
    def parameter_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "parameter_key", value)

    @property
    @pulumi.getter(name="parameterValue")
    def parameter_value(self) -> pulumi.Input[str]:
        """
        Create parameter Value.
        """
        return pulumi.get(self, "parameter_value")

    @parameter_value.setter
    def parameter_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "parameter_value", value)


