# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AutoProvisioningGroupLaunchTemplateConfig',
    'DedicatedHostNetworkAttribute',
    'EcsInstanceSetDataDisk',
    'EcsInstanceSetExcludeInstanceFilter',
    'EcsInstanceSetNetworkInterface',
    'EcsLaunchTemplateDataDisk',
    'EcsLaunchTemplateNetworkInterfaces',
    'EcsLaunchTemplateSystemDisk',
    'EcsPrefixListEntry',
    'ImageDiskDeviceMapping',
    'ImageImportDiskDeviceMapping',
    'InstanceDataDisk',
    'InstanceMaintenanceTime',
    'LaunchTemplateDataDisk',
    'LaunchTemplateNetworkInterfaces',
    'LaunchTemplateSystemDisk',
    'ReservedInstanceOperationLock',
    'GetActivationsActivationResult',
    'GetAutoSnapshotPoliciesPolicyResult',
    'GetCapacityReservationsReservationResult',
    'GetCommandsCommandResult',
    'GetDedicatedHostsHostResult',
    'GetDedicatedHostsHostCapacityResult',
    'GetDedicatedHostsHostNetworkAttributeResult',
    'GetDedicatedHostsHostOperationLockResult',
    'GetDedicatedHostsOperationLockResult',
    'GetDisksDiskResult',
    'GetDisksDiskMountInstanceResult',
    'GetDisksDiskOperationLockResult',
    'GetDisksOperationLockResult',
    'GetEcsDedicatedHostClustersClusterResult',
    'GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityResult',
    'GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityResult',
    'GetEcsDeploymentSetsSetResult',
    'GetEcsDisksDiskResult',
    'GetEcsDisksDiskMountInstanceResult',
    'GetEcsDisksDiskOperationLockResult',
    'GetEcsDisksOperationLockResult',
    'GetEcsImageComponentsComponentResult',
    'GetEcsImagePipelinePipelineResult',
    'GetEcsInvocationsInvocationResult',
    'GetEcsInvocationsInvocationInvokeInstanceResult',
    'GetEcsKeyPairsKeyPairResult',
    'GetEcsKeyPairsKeyPairInstanceResult',
    'GetEcsKeyPairsPairResult',
    'GetEcsKeyPairsPairInstanceResult',
    'GetEcsLaunchTemplatesTemplateResult',
    'GetEcsLaunchTemplatesTemplateDataDiskResult',
    'GetEcsLaunchTemplatesTemplateNetworkInterfaceResult',
    'GetEcsLaunchTemplatesTemplateSystemDiskResult',
    'GetEcsNetworkInterfacePermissionsPermissionResult',
    'GetEcsNetworkInterfacesInterfaceResult',
    'GetEcsNetworkInterfacesInterfaceAssociatedPublicIpResult',
    'GetEcsPrefixListsListResult',
    'GetEcsPrefixListsListEntryResult',
    'GetEcsSnapshotGroupsGroupResult',
    'GetEcsSnapshotsSnapshotResult',
    'GetEcsStorageCapacityUnitsUnitResult',
    'GetEipAddressesAddressResult',
    'GetEipAddressesEipResult',
    'GetEipsAddressResult',
    'GetEipsEipResult',
    'GetElasticityAssurancesAssuranceResult',
    'GetElasticityAssurancesAssuranceAllocatedResourceResult',
    'GetHpcClustersClusterResult',
    'GetImagesImageResult',
    'GetImagesImageDiskDeviceMappingResult',
    'GetInstanceTypeFamiliesFamilyResult',
    'GetInstanceTypesInstanceTypeResult',
    'GetInstanceTypesInstanceTypeBurstableInstanceResult',
    'GetInstanceTypesInstanceTypeGpuResult',
    'GetInstanceTypesInstanceTypeLocalStorageResult',
    'GetInstancesInstanceResult',
    'GetInstancesInstanceDiskDeviceMappingResult',
    'GetKeyPairsKeyPairResult',
    'GetKeyPairsKeyPairInstanceResult',
    'GetKeyPairsPairResult',
    'GetKeyPairsPairInstanceResult',
    'GetNetworkInterfacesInterfaceResult',
    'GetNetworkInterfacesInterfaceAssociatedPublicIpResult',
    'GetSecurityGroupRulesRuleResult',
    'GetSecurityGroupsGroupResult',
    'GetSnapshotsSnapshotResult',
]

@pulumi.output_type
class AutoProvisioningGroupLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPrice":
            suggest = "max_price"
        elif key == "vswitchId":
            suggest = "vswitch_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoProvisioningGroupLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoProvisioningGroupLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoProvisioningGroupLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_price: str,
                 vswitch_id: str,
                 weighted_capacity: str,
                 instance_type: Optional[str] = None,
                 priority: Optional[str] = None):
        """
        :param str max_price: The maximum price of the instance type specified in the Nth extended configurations of the launch template.
        :param str vswitch_id: The ID of the VSwitch in the Nth extended configurations of the launch template.
        :param str weighted_capacity: The weight of the instance type specified in the Nth extended configurations of the launch template.
        :param str instance_type: The instance type of the Nth extended configurations of the launch template.
        :param str priority: The priority of the instance type specified in the Nth extended configurations of the launch template. A value of 0 indicates the highest priority.
        """
        AutoProvisioningGroupLaunchTemplateConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_price=max_price,
            vswitch_id=vswitch_id,
            weighted_capacity=weighted_capacity,
            instance_type=instance_type,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_price: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             weighted_capacity: Optional[str] = None,
             instance_type: Optional[str] = None,
             priority: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_price is None and 'maxPrice' in kwargs:
            max_price = kwargs['maxPrice']
        if max_price is None:
            raise TypeError("Missing 'max_price' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")
        if weighted_capacity is None and 'weightedCapacity' in kwargs:
            weighted_capacity = kwargs['weightedCapacity']
        if weighted_capacity is None:
            raise TypeError("Missing 'weighted_capacity' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']

        _setter("max_price", max_price)
        _setter("vswitch_id", vswitch_id)
        _setter("weighted_capacity", weighted_capacity)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> str:
        """
        The maximum price of the instance type specified in the Nth extended configurations of the launch template.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch in the Nth extended configurations of the launch template.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> str:
        """
        The weight of the instance type specified in the Nth extended configurations of the launch template.
        """
        return pulumi.get(self, "weighted_capacity")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type of the Nth extended configurations of the launch template.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        The priority of the instance type specified in the Nth extended configurations of the launch template. A value of 0 indicates the highest priority.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class DedicatedHostNetworkAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slbUdpTimeout":
            suggest = "slb_udp_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedHostNetworkAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedHostNetworkAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedHostNetworkAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slb_udp_timeout: Optional[int] = None,
                 udp_timeout: Optional[int] = None):
        """
        :param int slb_udp_timeout: The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        :param int udp_timeout: The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        DedicatedHostNetworkAttribute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            slb_udp_timeout=slb_udp_timeout,
            udp_timeout=udp_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             slb_udp_timeout: Optional[int] = None,
             udp_timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if slb_udp_timeout is None and 'slbUdpTimeout' in kwargs:
            slb_udp_timeout = kwargs['slbUdpTimeout']
        if udp_timeout is None and 'udpTimeout' in kwargs:
            udp_timeout = kwargs['udpTimeout']

        if slb_udp_timeout is not None:
            _setter("slb_udp_timeout", slb_udp_timeout)
        if udp_timeout is not None:
            _setter("udp_timeout", udp_timeout)

    @property
    @pulumi.getter(name="slbUdpTimeout")
    def slb_udp_timeout(self) -> Optional[int]:
        """
        The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        return pulumi.get(self, "slb_udp_timeout")

    @property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[int]:
        """
        The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class EcsInstanceSetDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "autoSnapshotPolicyId":
            suggest = "auto_snapshot_policy_id"
        elif key == "diskCategory":
            suggest = "disk_category"
        elif key == "diskDescription":
            suggest = "disk_description"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsInstanceSetDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsInstanceSetDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsInstanceSetDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 auto_snapshot_policy_id: Optional[str] = None,
                 disk_category: Optional[str] = None,
                 disk_description: Optional[str] = None,
                 disk_name: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param int disk_size: The size of the data disk. Unit: GiB.
               - When `disk_category` is `cloud_efficiency`, Valid values: `20` to `32768`.
               - When `disk_category` is `cloud_ssd`, Valid values: `20` to `32768`.
               - When `disk_category` is `cloud_essd`, Valid values: `20` to `32768`.
               - When `disk_category` is `cloud`, Valid values: `5` to `200`.
        :param str auto_snapshot_policy_id: The ID of the automatic snapshot policy applied to the system disk.
        :param str disk_category: The category of the disk. Valid values: `cloud_efficiency`, `cloud_ssd`, `cloud_essd`, `cloud`.
        :param str disk_description: The description of the data disk.
        :param str disk_name: The name of the data disk.
        :param bool encrypted: Encrypted the data in this disk. Default value: `false`.
        :param str kms_key_id: The KMS key ID corresponding to the data disk.
        :param str performance_level: The performance level of the ESSD used as data disk. Valid values: `PL0`, `PL1`, `PL2`, `PL3`.
        :param str snapshot_id: The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        EcsInstanceSetDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_size=disk_size,
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            disk_category=disk_category,
            disk_description=disk_description,
            disk_name=disk_name,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            performance_level=performance_level,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_size: Optional[int] = None,
             auto_snapshot_policy_id: Optional[str] = None,
             disk_category: Optional[str] = None,
             disk_description: Optional[str] = None,
             disk_name: Optional[str] = None,
             encrypted: Optional[bool] = None,
             kms_key_id: Optional[str] = None,
             performance_level: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disk_size is None and 'diskSize' in kwargs:
            disk_size = kwargs['diskSize']
        if disk_size is None:
            raise TypeError("Missing 'disk_size' argument")
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if disk_category is None and 'diskCategory' in kwargs:
            disk_category = kwargs['diskCategory']
        if disk_description is None and 'diskDescription' in kwargs:
            disk_description = kwargs['diskDescription']
        if disk_name is None and 'diskName' in kwargs:
            disk_name = kwargs['diskName']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        _setter("disk_size", disk_size)
        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if disk_category is not None:
            _setter("disk_category", disk_category)
        if disk_description is not None:
            _setter("disk_description", disk_description)
        if disk_name is not None:
            _setter("disk_name", disk_name)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        The size of the data disk. Unit: GiB.
        - When `disk_category` is `cloud_efficiency`, Valid values: `20` to `32768`.
        - When `disk_category` is `cloud_ssd`, Valid values: `20` to `32768`.
        - When `disk_category` is `cloud_essd`, Valid values: `20` to `32768`.
        - When `disk_category` is `cloud`, Valid values: `5` to `200`.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[str]:
        """
        The ID of the automatic snapshot policy applied to the system disk.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter(name="diskCategory")
    def disk_category(self) -> Optional[str]:
        """
        The category of the disk. Valid values: `cloud_efficiency`, `cloud_ssd`, `cloud_essd`, `cloud`.
        """
        return pulumi.get(self, "disk_category")

    @property
    @pulumi.getter(name="diskDescription")
    def disk_description(self) -> Optional[str]:
        """
        The description of the data disk.
        """
        return pulumi.get(self, "disk_description")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[str]:
        """
        The name of the data disk.
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Encrypted the data in this disk. Default value: `false`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The KMS key ID corresponding to the data disk.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        The performance level of the ESSD used as data disk. Valid values: `PL0`, `PL1`, `PL2`, `PL3`.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class EcsInstanceSetExcludeInstanceFilter(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The type of the excluded. Valid values: `InstanceId`, `InstanceName`.
        :param Sequence[str] values: The value of the excluded. The identification of the excluded instances. It is a list of instance Ids or names.
        """
        EcsInstanceSetExcludeInstanceFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("key", key)
        _setter("values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The type of the excluded. Valid values: `InstanceId`, `InstanceName`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The value of the excluded. The identification of the excluded instances. It is a list of instance Ids or names.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class EcsInstanceSetNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "networkInterfaceName":
            suggest = "network_interface_name"
        elif key == "primaryIpAddress":
            suggest = "primary_ip_address"
        elif key == "vswitchId":
            suggest = "vswitch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsInstanceSetNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsInstanceSetNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsInstanceSetNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_id: str,
                 description: Optional[str] = None,
                 network_interface_name: Optional[str] = None,
                 primary_ip_address: Optional[str] = None,
                 vswitch_id: Optional[str] = None):
        """
        :param str security_group_id: The ID of the security group to which to assign secondary ENI.
        :param str description: The description of ENI.
        :param str network_interface_name: The name of ENI.
        :param str primary_ip_address: The primary private IP address of ENI.
        :param str vswitch_id: The ID of the vSwitch to which to connect ENI.
        """
        EcsInstanceSetNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_group_id=security_group_id,
            description=description,
            network_interface_name=network_interface_name,
            primary_ip_address=primary_ip_address,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_group_id: Optional[str] = None,
             description: Optional[str] = None,
             network_interface_name: Optional[str] = None,
             primary_ip_address: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if network_interface_name is None and 'networkInterfaceName' in kwargs:
            network_interface_name = kwargs['networkInterfaceName']
        if primary_ip_address is None and 'primaryIpAddress' in kwargs:
            primary_ip_address = kwargs['primaryIpAddress']
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']

        _setter("security_group_id", security_group_id)
        if description is not None:
            _setter("description", description)
        if network_interface_name is not None:
            _setter("network_interface_name", network_interface_name)
        if primary_ip_address is not None:
            _setter("primary_ip_address", primary_ip_address)
        if vswitch_id is not None:
            _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of the security group to which to assign secondary ENI.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of ENI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="networkInterfaceName")
    def network_interface_name(self) -> Optional[str]:
        """
        The name of ENI.
        """
        return pulumi.get(self, "network_interface_name")

    @property
    @pulumi.getter(name="primaryIpAddress")
    def primary_ip_address(self) -> Optional[str]:
        """
        The primary private IP address of ENI.
        """
        return pulumi.get(self, "primary_ip_address")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[str]:
        """
        The ID of the vSwitch to which to connect ENI.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class EcsLaunchTemplateDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsLaunchTemplateDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsLaunchTemplateDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsLaunchTemplateDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[str] = None,
                 delete_with_instance: Optional[bool] = None,
                 description: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str category: The category of the disk.
        :param bool delete_with_instance: Indicates whether the data disk is released with the instance.
        :param str description: The description of the data disk.
        :param bool encrypted: Encrypted the data in this disk.
        :param str name: The name of the data disk.
        :param str performance_level: The performance level of the ESSD used as the data disk.
        :param int size: The size of the data disk.
        :param str snapshot_id: The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        EcsLaunchTemplateDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            encrypted=encrypted,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             encrypted: Optional[bool] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if category is not None:
            _setter("category", category)
        if delete_with_instance is not None:
            _setter("delete_with_instance", delete_with_instance)
        if description is not None:
            _setter("description", description)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The category of the disk.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[bool]:
        """
        Indicates whether the data disk is released with the instance.
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the data disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Encrypted the data in this disk.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        The performance level of the ESSD used as the data disk.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the data disk.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class EcsLaunchTemplateNetworkInterfaces(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryIp":
            suggest = "primary_ip"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "vswitchId":
            suggest = "vswitch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsLaunchTemplateNetworkInterfaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsLaunchTemplateNetworkInterfaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsLaunchTemplateNetworkInterfaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 primary_ip: Optional[str] = None,
                 security_group_id: Optional[str] = None,
                 vswitch_id: Optional[str] = None):
        """
        :param str description: The ENI description.
        :param str name: The ENI name.
        :param str primary_ip: The primary private IP address of the ENI.
        :param str security_group_id: The security group ID must be one in the same VPC.
        :param str vswitch_id: The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
        """
        EcsLaunchTemplateNetworkInterfaces._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            primary_ip=primary_ip,
            security_group_id=security_group_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             primary_ip: Optional[str] = None,
             security_group_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if primary_ip is None and 'primaryIp' in kwargs:
            primary_ip = kwargs['primaryIp']
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']

        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if primary_ip is not None:
            _setter("primary_ip", primary_ip)
        if security_group_id is not None:
            _setter("security_group_id", security_group_id)
        if vswitch_id is not None:
            _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The ENI description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The ENI name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[str]:
        """
        The primary private IP address of the ENI.
        """
        return pulumi.get(self, "primary_ip")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        """
        The security group ID must be one in the same VPC.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[str]:
        """
        The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class EcsLaunchTemplateSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "performanceLevel":
            suggest = "performance_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsLaunchTemplateSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsLaunchTemplateSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsLaunchTemplateSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[str] = None,
                 delete_with_instance: Optional[bool] = None,
                 description: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[int] = None):
        """
        :param str category: The category of the system disk. System disk type. Valid values: `all`, `cloud`, `ephemeral_ssd`, `cloud_essd`, `cloud_efficiency`, `cloud_ssd`, `local_disk`.
        :param bool delete_with_instance: Specifies whether to release the system disk when the instance is released. Default to `true`.
        :param str description: System disk description. It cannot begin with http:// or https://.
        :param bool encrypted: Specifies whether the system disk is encrypted.
        :param str iops: The Iops.
        :param str name: System disk name. The name is a string of 2 to 128 characters. It must begin with an English or a Chinese character. It can contain A-Z, a-z, Chinese characters, numbers, periods (.), colons (:), underscores (_), and hyphens (-).
        :param str performance_level: The performance level of the ESSD used as the system disk. Valid Values: `PL0`, `PL1`, `PL2`, and `PL3`. Default to: `PL0`.
        :param int size: Size of the system disk, measured in GB. Value range: [20, 500].
        """
        EcsLaunchTemplateSystemDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            encrypted=encrypted,
            iops=iops,
            name=name,
            performance_level=performance_level,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']

        if category is not None:
            _setter("category", category)
        if delete_with_instance is not None:
            _setter("delete_with_instance", delete_with_instance)
        if description is not None:
            _setter("description", description)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The category of the system disk. System disk type. Valid values: `all`, `cloud`, `ephemeral_ssd`, `cloud_essd`, `cloud_efficiency`, `cloud_ssd`, `local_disk`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[bool]:
        """
        Specifies whether to release the system disk when the instance is released. Default to `true`.
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        System disk description. It cannot begin with http:// or https://.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Specifies whether the system disk is encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[str]:
        """
        The Iops.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        System disk name. The name is a string of 2 to 128 characters. It must begin with an English or a Chinese character. It can contain A-Z, a-z, Chinese characters, numbers, periods (.), colons (:), underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        The performance level of the ESSD used as the system disk. Valid Values: `PL0`, `PL1`, `PL2`, and `PL3`. Default to: `PL0`.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Size of the system disk, measured in GB. Value range: [20, 500].
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class EcsPrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 description: Optional[str] = None):
        """
        :param str cidr: The CIDR block in entry. This parameter is empty by default.  Take note of the following items:
               * The total number of entries must not exceed the `max_entries` value.
               * CIDR block types are determined by the IP address family. You cannot combine `IPv4` and `IPv6` CIDR blocks in a single entry.
               * CIDR blocks must be unique across all entries in a prefix list. For example, you cannot specify 192.168.1.0/24 twice in the entries of the prefix list.
               * IP addresses are supported. The system converts IP addresses into CIDR blocks. For example, if you specify 192.168.1.100, the system converts it into the 192.168.1.100/32 CIDR block.
               * If an IPv6 CIDR block is used, the system converts it to the zero compression format and changes uppercase letters into lowercase ones. For example, if you specify 2001:0DB8:0000:0000:0000:0000:0000:0000/32, the system converts it into 2001:db8::/32.
               * For more information about CIDR blocks, see the "What is CIDR block?" section of the [Network FAQ](https://www.alibabacloud.com/help/doc-detail/40637.htm) topic.  * The total number of entries must not exceed the `max_entries` value.
        :param str description: The description in entry. The description must be 2 to 32 characters in length and cannot start with `http://` or `https://`.
        """
        EcsPrefixListEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if cidr is not None:
            _setter("cidr", cidr)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        """
        The CIDR block in entry. This parameter is empty by default.  Take note of the following items:
        * The total number of entries must not exceed the `max_entries` value.
        * CIDR block types are determined by the IP address family. You cannot combine `IPv4` and `IPv6` CIDR blocks in a single entry.
        * CIDR blocks must be unique across all entries in a prefix list. For example, you cannot specify 192.168.1.0/24 twice in the entries of the prefix list.
        * IP addresses are supported. The system converts IP addresses into CIDR blocks. For example, if you specify 192.168.1.100, the system converts it into the 192.168.1.100/32 CIDR block.
        * If an IPv6 CIDR block is used, the system converts it to the zero compression format and changes uppercase letters into lowercase ones. For example, if you specify 2001:0DB8:0000:0000:0000:0000:0000:0000/32, the system converts it into 2001:db8::/32.
        * For more information about CIDR blocks, see the "What is CIDR block?" section of the [Network FAQ](https://www.alibabacloud.com/help/doc-detail/40637.htm) topic.  * The total number of entries must not exceed the `max_entries` value.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description in entry. The description must be 2 to 32 characters in length and cannot start with `http://` or `https://`.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class ImageDiskDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageDiskDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageDiskDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageDiskDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: Optional[str] = None,
                 disk_type: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str device: Specifies the name of a disk in the combined custom image. Value range: /dev/xvda to /dev/xvdz.
        :param str disk_type: Specifies the type of a disk in the combined custom image. If you specify this parameter, you can use a data disk snapshot as the data source of a system disk for creating an image. If it is not specified, the disk type is determined by the corresponding snapshot. Valid values: `system`, `data`,
        :param int size: Specifies the size of a disk in the combined custom image, in GiB. Value range: 5 to 2000.
        :param str snapshot_id: Specifies a snapshot that is used to create a combined custom image.
        """
        ImageDiskDeviceMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device=device,
            disk_type=disk_type,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device: Optional[str] = None,
             disk_type: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disk_type is None and 'diskType' in kwargs:
            disk_type = kwargs['diskType']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if device is not None:
            _setter("device", device)
        if disk_type is not None:
            _setter("disk_type", disk_type)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Specifies the name of a disk in the combined custom image. Value range: /dev/xvda to /dev/xvdz.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[str]:
        """
        Specifies the type of a disk in the combined custom image. If you specify this parameter, you can use a data disk snapshot as the data source of a system disk for creating an image. If it is not specified, the disk type is determined by the corresponding snapshot. Valid values: `system`, `data`,
        """
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Specifies the size of a disk in the combined custom image, in GiB. Value range: 5 to 2000.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        Specifies a snapshot that is used to create a combined custom image.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class ImageImportDiskDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskImageSize":
            suggest = "disk_image_size"
        elif key == "ossBucket":
            suggest = "oss_bucket"
        elif key == "ossObject":
            suggest = "oss_object"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageImportDiskDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageImportDiskDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageImportDiskDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: Optional[str] = None,
                 disk_image_size: Optional[int] = None,
                 format: Optional[str] = None,
                 oss_bucket: Optional[str] = None,
                 oss_object: Optional[str] = None):
        """
        :param str device: The name of disk N in the custom image.
        :param int disk_image_size: Resolution size. You must ensure that the system disk space ≥ file system space. Ranges: When n = 1, the system disk: 5 ~ 500GiB, When n = 2 ~ 17, that is, data disk: 5 ~ 1000GiB, When temporary is introduced, the system automatically detects the size, which is subject to the detection result.
        :param str format: Image format. Value range: When the `RAW`, `VHD`, `qcow2` is imported into the image, the system automatically detects the image format, whichever comes first.
        :param str oss_bucket: Save the exported OSS bucket.
        :param str oss_object: The file name of your OSS Object.
               
               > **NOTE:** The disk_device_mapping is a list and it's first item will be used to system disk and other items are used to data disks.
        """
        ImageImportDiskDeviceMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device=device,
            disk_image_size=disk_image_size,
            format=format,
            oss_bucket=oss_bucket,
            oss_object=oss_object,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device: Optional[str] = None,
             disk_image_size: Optional[int] = None,
             format: Optional[str] = None,
             oss_bucket: Optional[str] = None,
             oss_object: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disk_image_size is None and 'diskImageSize' in kwargs:
            disk_image_size = kwargs['diskImageSize']
        if oss_bucket is None and 'ossBucket' in kwargs:
            oss_bucket = kwargs['ossBucket']
        if oss_object is None and 'ossObject' in kwargs:
            oss_object = kwargs['ossObject']

        if device is not None:
            _setter("device", device)
        if disk_image_size is not None:
            _setter("disk_image_size", disk_image_size)
        if format is not None:
            _setter("format", format)
        if oss_bucket is not None:
            _setter("oss_bucket", oss_bucket)
        if oss_object is not None:
            _setter("oss_object", oss_object)

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The name of disk N in the custom image.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="diskImageSize")
    def disk_image_size(self) -> Optional[int]:
        """
        Resolution size. You must ensure that the system disk space ≥ file system space. Ranges: When n = 1, the system disk: 5 ~ 500GiB, When n = 2 ~ 17, that is, data disk: 5 ~ 1000GiB, When temporary is introduced, the system automatically detects the size, which is subject to the detection result.
        """
        return pulumi.get(self, "disk_image_size")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Image format. Value range: When the `RAW`, `VHD`, `qcow2` is imported into the image, the system automatically detects the image format, whichever comes first.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="ossBucket")
    def oss_bucket(self) -> Optional[str]:
        """
        Save the exported OSS bucket.
        """
        return pulumi.get(self, "oss_bucket")

    @property
    @pulumi.getter(name="ossObject")
    def oss_object(self) -> Optional[str]:
        """
        The file name of your OSS Object.

        > **NOTE:** The disk_device_mapping is a list and it's first item will be used to system disk and other items are used to data disks.
        """
        return pulumi.get(self, "oss_object")


@pulumi.output_type
class InstanceDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSnapshotPolicyId":
            suggest = "auto_snapshot_policy_id"
        elif key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: int,
                 auto_snapshot_policy_id: Optional[str] = None,
                 category: Optional[str] = None,
                 delete_with_instance: Optional[bool] = None,
                 description: Optional[str] = None,
                 device: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param int size: The size of the data disk.
               - cloud：[5, 2000]
               - cloud_efficiency：[20, 32768]
               - cloud_ssd：[20, 32768]
               - cloud_essd：[20, 32768]
               - ephemeral_ssd: [5, 800]
        :param str auto_snapshot_policy_id: The ID of the automatic snapshot policy applied to the system disk.
        :param str category: The category of the disk:
        :param bool delete_with_instance: Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_essd, cloud_ssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param. Default value: `true`.
        :param str description: The description of the data disk.
        :param str device: The mount point of the data disk.
        :param bool encrypted: Encrypted the data in this disk. Default value: `false`.
        :param str kms_key_id: The KMS key ID corresponding to the Nth data disk.
        :param str name: The name of the data disk.
        :param str performance_level: The performance level of the ESSD used as data disk:
        :param str snapshot_id: The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        InstanceDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size=size,
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size: Optional[int] = None,
             auto_snapshot_policy_id: Optional[str] = None,
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             device: Optional[str] = None,
             encrypted: Optional[bool] = None,
             kms_key_id: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if size is None:
            raise TypeError("Missing 'size' argument")
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        _setter("size", size)
        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if delete_with_instance is not None:
            _setter("delete_with_instance", delete_with_instance)
        if description is not None:
            _setter("description", description)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the data disk.
        - cloud：[5, 2000]
        - cloud_efficiency：[20, 32768]
        - cloud_ssd：[20, 32768]
        - cloud_essd：[20, 32768]
        - ephemeral_ssd: [5, 800]
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[str]:
        """
        The ID of the automatic snapshot policy applied to the system disk.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The category of the disk:
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[bool]:
        """
        Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_essd, cloud_ssd disk. If the category of this data disk was ephemeral_ssd, please don't set this param. Default value: `true`.
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the data disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The mount point of the data disk.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Encrypted the data in this disk. Default value: `false`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The KMS key ID corresponding to the Nth data disk.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        The performance level of the ESSD used as data disk:
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class InstanceMaintenanceTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenanceTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenanceTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenanceTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param str end_time: The end time of maintenance. The time must be on the hour at exactly 0 minute and 0 second. The `start_time` and `end_time` parameters must be specified at the same time. The `end_time` value must be 1 to 23 hours later than the `start_time` value. Specify the time in the HH:mm:ss format. The time must be in UTC+8.
        :param str start_time: The start time of maintenance. The time must be on the hour at exactly 0 minute and 0 second. The `start_time` and `end_time` parameters must be specified at the same time. The `end_time` value must be 1 to 23 hours later than the `start_time` value. Specify the time in the HH:mm:ss format. The time must be in UTC+8.
        """
        InstanceMaintenanceTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']

        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The end time of maintenance. The time must be on the hour at exactly 0 minute and 0 second. The `start_time` and `end_time` parameters must be specified at the same time. The `end_time` value must be 1 to 23 hours later than the `start_time` value. Specify the time in the HH:mm:ss format. The time must be in UTC+8.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        The start time of maintenance. The time must be on the hour at exactly 0 minute and 0 second. The `start_time` and `end_time` parameters must be specified at the same time. The `end_time` value must be 1 to 23 hours later than the `start_time` value. Specify the time in the HH:mm:ss format. The time must be in UTC+8.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class LaunchTemplateDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[str] = None,
                 delete_with_instance: Optional[bool] = None,
                 description: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str category: The category of the disk:
               - cloud: Basic cloud disk.
               - cloud_efficiency: Ultra cloud disk.
               - cloud_ssd: SSD cloud Disks.
               - ephemeral_ssd: local SSD Disks
               - cloud_essd: ESSD cloud Disks.
               
               Default to `cloud_efficiency`.
        :param bool delete_with_instance: Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_ssd and cloud_essd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
               
               Default to true
        :param str description: The description of the data disk.
        :param bool encrypted: Encrypted the data in this disk.
               
               Default to false
        :param str name: The name of the data disk.
        :param int size: The size of the data disk.
               - cloud：[5, 2000]
               - cloud_efficiency：[20, 32768]
               - cloud_ssd：[20, 32768]
               - cloud_essd：[20, 32768]
               - ephemeral_ssd: [5, 800]
        :param str snapshot_id: The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        LaunchTemplateDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            encrypted=encrypted,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             encrypted: Optional[bool] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if category is not None:
            _setter("category", category)
        if delete_with_instance is not None:
            _setter("delete_with_instance", delete_with_instance)
        if description is not None:
            _setter("description", description)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The category of the disk:
        - cloud: Basic cloud disk.
        - cloud_efficiency: Ultra cloud disk.
        - cloud_ssd: SSD cloud Disks.
        - ephemeral_ssd: local SSD Disks
        - cloud_essd: ESSD cloud Disks.

        Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[bool]:
        """
        Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_ssd and cloud_essd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.

        Default to true
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the data disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Encrypted the data in this disk.

        Default to false
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the data disk.
        - cloud：[5, 2000]
        - cloud_efficiency：[20, 32768]
        - cloud_ssd：[20, 32768]
        - cloud_essd：[20, 32768]
        - ephemeral_ssd: [5, 800]
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class LaunchTemplateNetworkInterfaces(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryIp":
            suggest = "primary_ip"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "vswitchId":
            suggest = "vswitch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterfaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterfaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterfaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 primary_ip: Optional[str] = None,
                 security_group_id: Optional[str] = None,
                 vswitch_id: Optional[str] = None):
        """
        :param str description: The description of the data disk.
        :param str name: The name of the data disk.
        :param str primary_ip: The primary private IP address of the ENI.
        :param str security_group_id: The security group ID must be one in the same VPC.
        :param str vswitch_id: The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
        """
        LaunchTemplateNetworkInterfaces._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            primary_ip=primary_ip,
            security_group_id=security_group_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             primary_ip: Optional[str] = None,
             security_group_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if primary_ip is None and 'primaryIp' in kwargs:
            primary_ip = kwargs['primaryIp']
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']

        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if primary_ip is not None:
            _setter("primary_ip", primary_ip)
        if security_group_id is not None:
            _setter("security_group_id", security_group_id)
        if vswitch_id is not None:
            _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the data disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[str]:
        """
        The primary private IP address of the ENI.
        """
        return pulumi.get(self, "primary_ip")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        """
        The security group ID must be one in the same VPC.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[str]:
        """
        The VSwitch ID for ENI. The instance must be in the same zone of the same VPC network as the ENI, but they may belong to different VSwitches.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class LaunchTemplateSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteWithInstance":
            suggest = "delete_with_instance"
        elif key == "performanceLevel":
            suggest = "performance_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[str] = None,
                 delete_with_instance: Optional[bool] = None,
                 description: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[int] = None):
        """
        :param str category: The category of the disk:
               - cloud: Basic cloud disk.
               - cloud_efficiency: Ultra cloud disk.
               - cloud_ssd: SSD cloud Disks.
               - ephemeral_ssd: local SSD Disks
               - cloud_essd: ESSD cloud Disks.
               
               Default to `cloud_efficiency`.
        :param bool delete_with_instance: Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_ssd and cloud_essd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.
               
               Default to true
        :param str description: The description of the data disk.
        :param bool encrypted: Encrypted the data in this disk.
               
               Default to false
        :param str name: The name of the data disk.
        :param int size: The size of the data disk.
               - cloud：[5, 2000]
               - cloud_efficiency：[20, 32768]
               - cloud_ssd：[20, 32768]
               - cloud_essd：[20, 32768]
               - ephemeral_ssd: [5, 800]
        """
        LaunchTemplateSystemDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            encrypted=encrypted,
            iops=iops,
            name=name,
            performance_level=performance_level,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']

        if category is not None:
            _setter("category", category)
        if delete_with_instance is not None:
            _setter("delete_with_instance", delete_with_instance)
        if description is not None:
            _setter("description", description)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The category of the disk:
        - cloud: Basic cloud disk.
        - cloud_efficiency: Ultra cloud disk.
        - cloud_ssd: SSD cloud Disks.
        - ephemeral_ssd: local SSD Disks
        - cloud_essd: ESSD cloud Disks.

        Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> Optional[bool]:
        """
        Delete this data disk when the instance is destroyed. It only works on cloud, cloud_efficiency, cloud_ssd and cloud_essd disk. If the category of this data disk was ephemeral_ssd, please don't set this param.

        Default to true
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the data disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Encrypted the data in this disk.

        Default to false
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[str]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the data disk.
        - cloud：[5, 2000]
        - cloud_efficiency：[20, 32768]
        - cloud_ssd：[20, 32768]
        - cloud_essd：[20, 32768]
        - ephemeral_ssd: [5, 800]
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class ReservedInstanceOperationLock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lockReason":
            suggest = "lock_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservedInstanceOperationLock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservedInstanceOperationLock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservedInstanceOperationLock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lock_reason: Optional[str] = None):
        """
        :param str lock_reason: The reason why the reserved instance was locked.
        """
        ReservedInstanceOperationLock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']

        if lock_reason is not None:
            _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> Optional[str]:
        """
        The reason why the reserved instance was locked.
        """
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetActivationsActivationResult(dict):
    def __init__(__self__, *,
                 activation_id: str,
                 create_time: str,
                 deregistered_count: int,
                 description: str,
                 disabled: bool,
                 id: str,
                 instance_count: int,
                 instance_name: str,
                 ip_address_range: str,
                 registered_count: int,
                 time_to_live_in_hours: int):
        """
        :param str activation_id: The ID of the activation code.
        :param str create_time: The time when the activation code was created.
        :param int deregistered_count: The number of instances that have been logged out.
        :param str description: Description of the corresponding activation code.
        :param bool disabled: Indicates whether the activation code is disabled.
        :param str id: The ID of the Activation.
        :param int instance_count: The maximum number of times the activation code is used to register a managed instance.
        :param str instance_name: The default prefix of the instance name.
        :param str ip_address_range: The IP address of the host that allows the activation code to be used.
        :param int registered_count: The number of instances that were registered.
        :param int time_to_live_in_hours: The validity period of the activation code. Unit: hours.
        """
        GetActivationsActivationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            activation_id=activation_id,
            create_time=create_time,
            deregistered_count=deregistered_count,
            description=description,
            disabled=disabled,
            id=id,
            instance_count=instance_count,
            instance_name=instance_name,
            ip_address_range=ip_address_range,
            registered_count=registered_count,
            time_to_live_in_hours=time_to_live_in_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             activation_id: Optional[str] = None,
             create_time: Optional[str] = None,
             deregistered_count: Optional[int] = None,
             description: Optional[str] = None,
             disabled: Optional[bool] = None,
             id: Optional[str] = None,
             instance_count: Optional[int] = None,
             instance_name: Optional[str] = None,
             ip_address_range: Optional[str] = None,
             registered_count: Optional[int] = None,
             time_to_live_in_hours: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if activation_id is None and 'activationId' in kwargs:
            activation_id = kwargs['activationId']
        if activation_id is None:
            raise TypeError("Missing 'activation_id' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if deregistered_count is None and 'deregisteredCount' in kwargs:
            deregistered_count = kwargs['deregisteredCount']
        if deregistered_count is None:
            raise TypeError("Missing 'deregistered_count' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disabled is None:
            raise TypeError("Missing 'disabled' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if instance_count is None:
            raise TypeError("Missing 'instance_count' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if ip_address_range is None and 'ipAddressRange' in kwargs:
            ip_address_range = kwargs['ipAddressRange']
        if ip_address_range is None:
            raise TypeError("Missing 'ip_address_range' argument")
        if registered_count is None and 'registeredCount' in kwargs:
            registered_count = kwargs['registeredCount']
        if registered_count is None:
            raise TypeError("Missing 'registered_count' argument")
        if time_to_live_in_hours is None and 'timeToLiveInHours' in kwargs:
            time_to_live_in_hours = kwargs['timeToLiveInHours']
        if time_to_live_in_hours is None:
            raise TypeError("Missing 'time_to_live_in_hours' argument")

        _setter("activation_id", activation_id)
        _setter("create_time", create_time)
        _setter("deregistered_count", deregistered_count)
        _setter("description", description)
        _setter("disabled", disabled)
        _setter("id", id)
        _setter("instance_count", instance_count)
        _setter("instance_name", instance_name)
        _setter("ip_address_range", ip_address_range)
        _setter("registered_count", registered_count)
        _setter("time_to_live_in_hours", time_to_live_in_hours)

    @property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> str:
        """
        The ID of the activation code.
        """
        return pulumi.get(self, "activation_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time when the activation code was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deregisteredCount")
    def deregistered_count(self) -> int:
        """
        The number of instances that have been logged out.
        """
        return pulumi.get(self, "deregistered_count")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the corresponding activation code.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Indicates whether the activation code is disabled.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Activation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> int:
        """
        The maximum number of times the activation code is used to register a managed instance.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The default prefix of the instance name.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> str:
        """
        The IP address of the host that allows the activation code to be used.
        """
        return pulumi.get(self, "ip_address_range")

    @property
    @pulumi.getter(name="registeredCount")
    def registered_count(self) -> int:
        """
        The number of instances that were registered.
        """
        return pulumi.get(self, "registered_count")

    @property
    @pulumi.getter(name="timeToLiveInHours")
    def time_to_live_in_hours(self) -> int:
        """
        The validity period of the activation code. Unit: hours.
        """
        return pulumi.get(self, "time_to_live_in_hours")


@pulumi.output_type
class GetAutoSnapshotPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 auto_snapshot_policy_id: str,
                 copied_snapshots_retention_days: int,
                 disk_nums: int,
                 enable_cross_region_copy: bool,
                 id: str,
                 name: str,
                 repeat_weekdays: Sequence[str],
                 retention_days: int,
                 status: str,
                 tags: Mapping[str, Any],
                 target_copy_regions: Sequence[str],
                 time_points: Sequence[str],
                 volume_nums: int):
        """
        :param str auto_snapshot_policy_id: The ID of the Auto Snapshot Policy.
        :param int copied_snapshots_retention_days: The retention period of the snapshot copied across regions.
        :param int disk_nums: The number of disks to which the automatic snapshot policy is applied.
        :param bool enable_cross_region_copy: Specifies whether to enable the system to automatically copy snapshots across regions.
        :param str id: The ID of the Auto Snapshot Policy.
        :param str name: The snapshot policy name..
        :param Sequence[str] repeat_weekdays: The automatic snapshot repetition dates.
        :param int retention_days: The snapshot retention time, and the unit of measurement is day.
        :param str status: The status of Auto Snapshot Policy.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        :param Sequence[str] target_copy_regions: The destination region to which the snapshot is copied.
        :param Sequence[str] time_points: The automatic snapshot creation schedule, and the unit of measurement is hour.
        :param int volume_nums: The number of extended volumes on which this policy is enabled.
        """
        GetAutoSnapshotPoliciesPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            copied_snapshots_retention_days=copied_snapshots_retention_days,
            disk_nums=disk_nums,
            enable_cross_region_copy=enable_cross_region_copy,
            id=id,
            name=name,
            repeat_weekdays=repeat_weekdays,
            retention_days=retention_days,
            status=status,
            tags=tags,
            target_copy_regions=target_copy_regions,
            time_points=time_points,
            volume_nums=volume_nums,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[str] = None,
             copied_snapshots_retention_days: Optional[int] = None,
             disk_nums: Optional[int] = None,
             enable_cross_region_copy: Optional[bool] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             repeat_weekdays: Optional[Sequence[str]] = None,
             retention_days: Optional[int] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             target_copy_regions: Optional[Sequence[str]] = None,
             time_points: Optional[Sequence[str]] = None,
             volume_nums: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if auto_snapshot_policy_id is None:
            raise TypeError("Missing 'auto_snapshot_policy_id' argument")
        if copied_snapshots_retention_days is None and 'copiedSnapshotsRetentionDays' in kwargs:
            copied_snapshots_retention_days = kwargs['copiedSnapshotsRetentionDays']
        if copied_snapshots_retention_days is None:
            raise TypeError("Missing 'copied_snapshots_retention_days' argument")
        if disk_nums is None and 'diskNums' in kwargs:
            disk_nums = kwargs['diskNums']
        if disk_nums is None:
            raise TypeError("Missing 'disk_nums' argument")
        if enable_cross_region_copy is None and 'enableCrossRegionCopy' in kwargs:
            enable_cross_region_copy = kwargs['enableCrossRegionCopy']
        if enable_cross_region_copy is None:
            raise TypeError("Missing 'enable_cross_region_copy' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if repeat_weekdays is None and 'repeatWeekdays' in kwargs:
            repeat_weekdays = kwargs['repeatWeekdays']
        if repeat_weekdays is None:
            raise TypeError("Missing 'repeat_weekdays' argument")
        if retention_days is None and 'retentionDays' in kwargs:
            retention_days = kwargs['retentionDays']
        if retention_days is None:
            raise TypeError("Missing 'retention_days' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if target_copy_regions is None and 'targetCopyRegions' in kwargs:
            target_copy_regions = kwargs['targetCopyRegions']
        if target_copy_regions is None:
            raise TypeError("Missing 'target_copy_regions' argument")
        if time_points is None and 'timePoints' in kwargs:
            time_points = kwargs['timePoints']
        if time_points is None:
            raise TypeError("Missing 'time_points' argument")
        if volume_nums is None and 'volumeNums' in kwargs:
            volume_nums = kwargs['volumeNums']
        if volume_nums is None:
            raise TypeError("Missing 'volume_nums' argument")

        _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        _setter("copied_snapshots_retention_days", copied_snapshots_retention_days)
        _setter("disk_nums", disk_nums)
        _setter("enable_cross_region_copy", enable_cross_region_copy)
        _setter("id", id)
        _setter("name", name)
        _setter("repeat_weekdays", repeat_weekdays)
        _setter("retention_days", retention_days)
        _setter("status", status)
        _setter("tags", tags)
        _setter("target_copy_regions", target_copy_regions)
        _setter("time_points", time_points)
        _setter("volume_nums", volume_nums)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> str:
        """
        The ID of the Auto Snapshot Policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter(name="copiedSnapshotsRetentionDays")
    def copied_snapshots_retention_days(self) -> int:
        """
        The retention period of the snapshot copied across regions.
        """
        return pulumi.get(self, "copied_snapshots_retention_days")

    @property
    @pulumi.getter(name="diskNums")
    def disk_nums(self) -> int:
        """
        The number of disks to which the automatic snapshot policy is applied.
        """
        return pulumi.get(self, "disk_nums")

    @property
    @pulumi.getter(name="enableCrossRegionCopy")
    def enable_cross_region_copy(self) -> bool:
        """
        Specifies whether to enable the system to automatically copy snapshots across regions.
        """
        return pulumi.get(self, "enable_cross_region_copy")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Auto Snapshot Policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The snapshot policy name..
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="repeatWeekdays")
    def repeat_weekdays(self) -> Sequence[str]:
        """
        The automatic snapshot repetition dates.
        """
        return pulumi.get(self, "repeat_weekdays")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        """
        The snapshot retention time, and the unit of measurement is day.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of Auto Snapshot Policy.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="targetCopyRegions")
    def target_copy_regions(self) -> Sequence[str]:
        """
        The destination region to which the snapshot is copied.
        """
        return pulumi.get(self, "target_copy_regions")

    @property
    @pulumi.getter(name="timePoints")
    def time_points(self) -> Sequence[str]:
        """
        The automatic snapshot creation schedule, and the unit of measurement is hour.
        """
        return pulumi.get(self, "time_points")

    @property
    @pulumi.getter(name="volumeNums")
    def volume_nums(self) -> int:
        """
        The number of extended volumes on which this policy is enabled.
        """
        return pulumi.get(self, "volume_nums")


@pulumi.output_type
class GetCapacityReservationsReservationResult(dict):
    def __init__(__self__, *,
                 capacity_reservation_id: str,
                 capacity_reservation_name: str,
                 description: str,
                 end_time: str,
                 end_time_type: str,
                 id: str,
                 instance_amount: str,
                 instance_type: str,
                 match_criteria: str,
                 payment_type: str,
                 platform: str,
                 resource_group_id: str,
                 start_time: str,
                 start_time_type: str,
                 status: str,
                 time_slot: str,
                 zone_ids: Sequence[str],
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str capacity_reservation_id: Capacity Reservation id
        :param str capacity_reservation_name: Capacity reservation service name.
        :param str description: description of the capacity reservation instance
        :param str end_time: end time of the capacity reservation. the capacity reservation will be  released at the end time automatically if set. otherwise it will last until manually released
        :param str end_time_type: Release mode of capacity reservation service. Value range:Limited: release at specified time. The EndTime parameter must be specified at the same time.Unlimited: manual release. No time limit.
        :param str id: The ID of the Capacity Reservation.
        :param str instance_amount: The total number of instances that need to be reserved within the capacity reservation
        :param str instance_type: Instance type. Currently, you can only set the capacity reservation service for one instance type.
        :param str match_criteria: The type of private resource pool generated after the capacity reservation service takes effect. Value range:Open: Open mode.Target: dedicated mode.Default value: Open
        :param str payment_type: The payment type of the resource. value range `PostPaid`, `PrePaid`.
        :param str platform: platform of the capacity reservation , value range `windows`, `linux`, `all`.
        :param str resource_group_id: The resource group id.
        :param str start_time: time of the capacity reservation which become active
        :param str start_time_type: The capacity is scheduled to take effect. Possible values:-Now: Effective immediately.-Later: the specified time takes effect.
        :param str status: The status of the capacity reservation. value range `All`, `Pending`, `Preparing`, `Prepared`, `Active`, `Released`.
        :param str time_slot: This parameter is under test and is not yet open for use.
        :param Sequence[str] zone_ids: The ID of the zone in the region to which the capacity reservation service belongs. Currently, it is only supported to create a capacity reservation service in one zone.
        :param Mapping[str, Any] tags: The tag of the resource.
        """
        GetCapacityReservationsReservationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_reservation_id=capacity_reservation_id,
            capacity_reservation_name=capacity_reservation_name,
            description=description,
            end_time=end_time,
            end_time_type=end_time_type,
            id=id,
            instance_amount=instance_amount,
            instance_type=instance_type,
            match_criteria=match_criteria,
            payment_type=payment_type,
            platform=platform,
            resource_group_id=resource_group_id,
            start_time=start_time,
            start_time_type=start_time_type,
            status=status,
            time_slot=time_slot,
            zone_ids=zone_ids,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_reservation_id: Optional[str] = None,
             capacity_reservation_name: Optional[str] = None,
             description: Optional[str] = None,
             end_time: Optional[str] = None,
             end_time_type: Optional[str] = None,
             id: Optional[str] = None,
             instance_amount: Optional[str] = None,
             instance_type: Optional[str] = None,
             match_criteria: Optional[str] = None,
             payment_type: Optional[str] = None,
             platform: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             start_time: Optional[str] = None,
             start_time_type: Optional[str] = None,
             status: Optional[str] = None,
             time_slot: Optional[str] = None,
             zone_ids: Optional[Sequence[str]] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_reservation_id is None and 'capacityReservationId' in kwargs:
            capacity_reservation_id = kwargs['capacityReservationId']
        if capacity_reservation_id is None:
            raise TypeError("Missing 'capacity_reservation_id' argument")
        if capacity_reservation_name is None and 'capacityReservationName' in kwargs:
            capacity_reservation_name = kwargs['capacityReservationName']
        if capacity_reservation_name is None:
            raise TypeError("Missing 'capacity_reservation_name' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if end_time is None:
            raise TypeError("Missing 'end_time' argument")
        if end_time_type is None and 'endTimeType' in kwargs:
            end_time_type = kwargs['endTimeType']
        if end_time_type is None:
            raise TypeError("Missing 'end_time_type' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_amount is None and 'instanceAmount' in kwargs:
            instance_amount = kwargs['instanceAmount']
        if instance_amount is None:
            raise TypeError("Missing 'instance_amount' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if match_criteria is None and 'matchCriteria' in kwargs:
            match_criteria = kwargs['matchCriteria']
        if match_criteria is None:
            raise TypeError("Missing 'match_criteria' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if platform is None:
            raise TypeError("Missing 'platform' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if start_time_type is None and 'startTimeType' in kwargs:
            start_time_type = kwargs['startTimeType']
        if start_time_type is None:
            raise TypeError("Missing 'start_time_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if time_slot is None and 'timeSlot' in kwargs:
            time_slot = kwargs['timeSlot']
        if time_slot is None:
            raise TypeError("Missing 'time_slot' argument")
        if zone_ids is None and 'zoneIds' in kwargs:
            zone_ids = kwargs['zoneIds']
        if zone_ids is None:
            raise TypeError("Missing 'zone_ids' argument")

        _setter("capacity_reservation_id", capacity_reservation_id)
        _setter("capacity_reservation_name", capacity_reservation_name)
        _setter("description", description)
        _setter("end_time", end_time)
        _setter("end_time_type", end_time_type)
        _setter("id", id)
        _setter("instance_amount", instance_amount)
        _setter("instance_type", instance_type)
        _setter("match_criteria", match_criteria)
        _setter("payment_type", payment_type)
        _setter("platform", platform)
        _setter("resource_group_id", resource_group_id)
        _setter("start_time", start_time)
        _setter("start_time_type", start_time_type)
        _setter("status", status)
        _setter("time_slot", time_slot)
        _setter("zone_ids", zone_ids)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> str:
        """
        Capacity Reservation id
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationName")
    def capacity_reservation_name(self) -> str:
        """
        Capacity reservation service name.
        """
        return pulumi.get(self, "capacity_reservation_name")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        description of the capacity reservation instance
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        end time of the capacity reservation. the capacity reservation will be  released at the end time automatically if set. otherwise it will last until manually released
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="endTimeType")
    def end_time_type(self) -> str:
        """
        Release mode of capacity reservation service. Value range:Limited: release at specified time. The EndTime parameter must be specified at the same time.Unlimited: manual release. No time limit.
        """
        return pulumi.get(self, "end_time_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Capacity Reservation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceAmount")
    def instance_amount(self) -> str:
        """
        The total number of instances that need to be reserved within the capacity reservation
        """
        return pulumi.get(self, "instance_amount")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type. Currently, you can only set the capacity reservation service for one instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> str:
        """
        The type of private resource pool generated after the capacity reservation service takes effect. Value range:Open: Open mode.Target: dedicated mode.Default value: Open
        """
        return pulumi.get(self, "match_criteria")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        """
        The payment type of the resource. value range `PostPaid`, `PrePaid`.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter
    def platform(self) -> str:
        """
        platform of the capacity reservation , value range `windows`, `linux`, `all`.
        """
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The resource group id.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        time of the capacity reservation which become active
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="startTimeType")
    def start_time_type(self) -> str:
        """
        The capacity is scheduled to take effect. Possible values:-Now: Effective immediately.-Later: the specified time takes effect.
        """
        return pulumi.get(self, "start_time_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the capacity reservation. value range `All`, `Pending`, `Preparing`, `Prepared`, `Active`, `Released`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="timeSlot")
    def time_slot(self) -> str:
        """
        This parameter is under test and is not yet open for use.
        """
        return pulumi.get(self, "time_slot")

    @property
    @pulumi.getter(name="zoneIds")
    def zone_ids(self) -> Sequence[str]:
        """
        The ID of the zone in the region to which the capacity reservation service belongs. Currently, it is only supported to create a capacity reservation service in one zone.
        """
        return pulumi.get(self, "zone_ids")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        The tag of the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCommandsCommandResult(dict):
    def __init__(__self__, *,
                 command_content: str,
                 command_id: str,
                 description: str,
                 enable_parameter: bool,
                 id: str,
                 name: str,
                 parameter_names: Sequence[str],
                 timeout: int,
                 type: str,
                 working_dir: str):
        """
        :param str command_content: The Base64-encoded content of the command.
        :param str command_id: The ID of the Command.
        :param str description: The description of command.
        :param bool enable_parameter: Specifies whether to use custom parameters in the command to be created.
        :param str id: The ID of the Command.
        :param str name: The name of the command
        :param Sequence[str] parameter_names: A list of custom parameter names which are parsed from the command content specified when the command was being created.
        :param int timeout: The timeout period that is specified for the command to be run on ECS instances.
        :param str type: The command type.
        :param str working_dir: The execution path of the command in the ECS instance.
        """
        GetCommandsCommandResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command_content=command_content,
            command_id=command_id,
            description=description,
            enable_parameter=enable_parameter,
            id=id,
            name=name,
            parameter_names=parameter_names,
            timeout=timeout,
            type=type,
            working_dir=working_dir,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command_content: Optional[str] = None,
             command_id: Optional[str] = None,
             description: Optional[str] = None,
             enable_parameter: Optional[bool] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             parameter_names: Optional[Sequence[str]] = None,
             timeout: Optional[int] = None,
             type: Optional[str] = None,
             working_dir: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command_content is None and 'commandContent' in kwargs:
            command_content = kwargs['commandContent']
        if command_content is None:
            raise TypeError("Missing 'command_content' argument")
        if command_id is None and 'commandId' in kwargs:
            command_id = kwargs['commandId']
        if command_id is None:
            raise TypeError("Missing 'command_id' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if enable_parameter is None and 'enableParameter' in kwargs:
            enable_parameter = kwargs['enableParameter']
        if enable_parameter is None:
            raise TypeError("Missing 'enable_parameter' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameter_names is None and 'parameterNames' in kwargs:
            parameter_names = kwargs['parameterNames']
        if parameter_names is None:
            raise TypeError("Missing 'parameter_names' argument")
        if timeout is None:
            raise TypeError("Missing 'timeout' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if working_dir is None and 'workingDir' in kwargs:
            working_dir = kwargs['workingDir']
        if working_dir is None:
            raise TypeError("Missing 'working_dir' argument")

        _setter("command_content", command_content)
        _setter("command_id", command_id)
        _setter("description", description)
        _setter("enable_parameter", enable_parameter)
        _setter("id", id)
        _setter("name", name)
        _setter("parameter_names", parameter_names)
        _setter("timeout", timeout)
        _setter("type", type)
        _setter("working_dir", working_dir)

    @property
    @pulumi.getter(name="commandContent")
    def command_content(self) -> str:
        """
        The Base64-encoded content of the command.
        """
        return pulumi.get(self, "command_content")

    @property
    @pulumi.getter(name="commandId")
    def command_id(self) -> str:
        """
        The ID of the Command.
        """
        return pulumi.get(self, "command_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of command.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableParameter")
    def enable_parameter(self) -> bool:
        """
        Specifies whether to use custom parameters in the command to be created.
        """
        return pulumi.get(self, "enable_parameter")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Command.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the command
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterNames")
    def parameter_names(self) -> Sequence[str]:
        """
        A list of custom parameter names which are parsed from the command content specified when the command was being created.
        """
        return pulumi.get(self, "parameter_names")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The timeout period that is specified for the command to be run on ECS instances.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The command type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> str:
        """
        The execution path of the command in the ECS instance.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class GetDedicatedHostsHostResult(dict):
    def __init__(__self__, *,
                 action_on_maintenance: str,
                 auto_placement: str,
                 auto_release_time: str,
                 capacities: Sequence['outputs.GetDedicatedHostsHostCapacityResult'],
                 cores: int,
                 cpu_over_commit_ratio: float,
                 dedicated_host_id: str,
                 dedicated_host_name: str,
                 dedicated_host_type: str,
                 description: str,
                 expired_time: str,
                 gpu_spec: str,
                 id: str,
                 machine_id: str,
                 network_attributes: Sequence['outputs.GetDedicatedHostsHostNetworkAttributeResult'],
                 operation_locks: Sequence['outputs.GetDedicatedHostsHostOperationLockResult'],
                 payment_type: str,
                 physical_gpus: int,
                 resource_group_id: str,
                 sale_cycle: str,
                 sockets: int,
                 status: str,
                 supported_custom_instance_type_families: Sequence[str],
                 supported_instance_type_families: Sequence[str],
                 supported_instance_types_lists: Sequence[str],
                 tags: Mapping[str, Any],
                 zone_id: str):
        """
        :param str action_on_maintenance: The policy used to migrate the instances from the dedicated host when the dedicated host fails or needs to be repaired online.
        :param str auto_placement: Specifies whether to add the dedicated host to the resource pool for automatic deployment.
        :param str auto_release_time: The automatic release time of the dedicated host.
        :param Sequence['GetDedicatedHostsHostCapacityArgs'] capacities: (Available in 1.123.1+) A collection of proprietary host performance indicators.
        :param int cores: A mapping of tags to assign to the resource.
        :param float cpu_over_commit_ratio: (Available in 1.123.1+) CPU oversold ratio.
        :param str dedicated_host_id: The ID of ECS Dedicated Host.
        :param str dedicated_host_name: The name of ECS Dedicated Host.
        :param str dedicated_host_type: The type of the dedicated host.
        :param str description: The description of the dedicated host.
        :param str expired_time: The expiration time of the subscription dedicated host.
        :param str gpu_spec: The GPU model.
        :param str id: ID of the ECS Dedicated Host.
        :param str machine_id: The machine code of the dedicated host.
        :param Sequence['GetDedicatedHostsHostNetworkAttributeArgs'] network_attributes: dedicated host network parameters. contains the following attributes:
        :param Sequence['GetDedicatedHostsHostOperationLockArgs'] operation_locks: The reason why the dedicated host resource is locked.
        :param str payment_type: The billing method of the dedicated host.
        :param int physical_gpus: The number of physical GPUs.
        :param str resource_group_id: The ID of the resource group to which the ECS Dedicated Host belongs.
        :param str sale_cycle: The unit of the subscription billing method.
        :param int sockets: The number of physical CPUs.
        :param str status: The status of the ECS Dedicated Host. validate value: `Available`, `Creating`, `PermanentFailure`, `Released`, `UnderAssessment`.
        :param Sequence[str] supported_custom_instance_type_families: (Available in 1.123.1+) A custom instance type family supported by a dedicated host.
        :param Sequence[str] supported_instance_type_families: (Available in 1.123.1+) ECS instance type family supported by the dedicated host.
        :param Sequence[str] supported_instance_types_lists: The list of ECS instance
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        :param str zone_id: The zone ID of the ECS Dedicated Host.
        """
        GetDedicatedHostsHostResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_on_maintenance=action_on_maintenance,
            auto_placement=auto_placement,
            auto_release_time=auto_release_time,
            capacities=capacities,
            cores=cores,
            cpu_over_commit_ratio=cpu_over_commit_ratio,
            dedicated_host_id=dedicated_host_id,
            dedicated_host_name=dedicated_host_name,
            dedicated_host_type=dedicated_host_type,
            description=description,
            expired_time=expired_time,
            gpu_spec=gpu_spec,
            id=id,
            machine_id=machine_id,
            network_attributes=network_attributes,
            operation_locks=operation_locks,
            payment_type=payment_type,
            physical_gpus=physical_gpus,
            resource_group_id=resource_group_id,
            sale_cycle=sale_cycle,
            sockets=sockets,
            status=status,
            supported_custom_instance_type_families=supported_custom_instance_type_families,
            supported_instance_type_families=supported_instance_type_families,
            supported_instance_types_lists=supported_instance_types_lists,
            tags=tags,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_on_maintenance: Optional[str] = None,
             auto_placement: Optional[str] = None,
             auto_release_time: Optional[str] = None,
             capacities: Optional[Sequence['outputs.GetDedicatedHostsHostCapacityResult']] = None,
             cores: Optional[int] = None,
             cpu_over_commit_ratio: Optional[float] = None,
             dedicated_host_id: Optional[str] = None,
             dedicated_host_name: Optional[str] = None,
             dedicated_host_type: Optional[str] = None,
             description: Optional[str] = None,
             expired_time: Optional[str] = None,
             gpu_spec: Optional[str] = None,
             id: Optional[str] = None,
             machine_id: Optional[str] = None,
             network_attributes: Optional[Sequence['outputs.GetDedicatedHostsHostNetworkAttributeResult']] = None,
             operation_locks: Optional[Sequence['outputs.GetDedicatedHostsHostOperationLockResult']] = None,
             payment_type: Optional[str] = None,
             physical_gpus: Optional[int] = None,
             resource_group_id: Optional[str] = None,
             sale_cycle: Optional[str] = None,
             sockets: Optional[int] = None,
             status: Optional[str] = None,
             supported_custom_instance_type_families: Optional[Sequence[str]] = None,
             supported_instance_type_families: Optional[Sequence[str]] = None,
             supported_instance_types_lists: Optional[Sequence[str]] = None,
             tags: Optional[Mapping[str, Any]] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_on_maintenance is None and 'actionOnMaintenance' in kwargs:
            action_on_maintenance = kwargs['actionOnMaintenance']
        if action_on_maintenance is None:
            raise TypeError("Missing 'action_on_maintenance' argument")
        if auto_placement is None and 'autoPlacement' in kwargs:
            auto_placement = kwargs['autoPlacement']
        if auto_placement is None:
            raise TypeError("Missing 'auto_placement' argument")
        if auto_release_time is None and 'autoReleaseTime' in kwargs:
            auto_release_time = kwargs['autoReleaseTime']
        if auto_release_time is None:
            raise TypeError("Missing 'auto_release_time' argument")
        if capacities is None:
            raise TypeError("Missing 'capacities' argument")
        if cores is None:
            raise TypeError("Missing 'cores' argument")
        if cpu_over_commit_ratio is None and 'cpuOverCommitRatio' in kwargs:
            cpu_over_commit_ratio = kwargs['cpuOverCommitRatio']
        if cpu_over_commit_ratio is None:
            raise TypeError("Missing 'cpu_over_commit_ratio' argument")
        if dedicated_host_id is None and 'dedicatedHostId' in kwargs:
            dedicated_host_id = kwargs['dedicatedHostId']
        if dedicated_host_id is None:
            raise TypeError("Missing 'dedicated_host_id' argument")
        if dedicated_host_name is None and 'dedicatedHostName' in kwargs:
            dedicated_host_name = kwargs['dedicatedHostName']
        if dedicated_host_name is None:
            raise TypeError("Missing 'dedicated_host_name' argument")
        if dedicated_host_type is None and 'dedicatedHostType' in kwargs:
            dedicated_host_type = kwargs['dedicatedHostType']
        if dedicated_host_type is None:
            raise TypeError("Missing 'dedicated_host_type' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if gpu_spec is None and 'gpuSpec' in kwargs:
            gpu_spec = kwargs['gpuSpec']
        if gpu_spec is None:
            raise TypeError("Missing 'gpu_spec' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if machine_id is None and 'machineId' in kwargs:
            machine_id = kwargs['machineId']
        if machine_id is None:
            raise TypeError("Missing 'machine_id' argument")
        if network_attributes is None and 'networkAttributes' in kwargs:
            network_attributes = kwargs['networkAttributes']
        if network_attributes is None:
            raise TypeError("Missing 'network_attributes' argument")
        if operation_locks is None and 'operationLocks' in kwargs:
            operation_locks = kwargs['operationLocks']
        if operation_locks is None:
            raise TypeError("Missing 'operation_locks' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if physical_gpus is None and 'physicalGpus' in kwargs:
            physical_gpus = kwargs['physicalGpus']
        if physical_gpus is None:
            raise TypeError("Missing 'physical_gpus' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if sale_cycle is None and 'saleCycle' in kwargs:
            sale_cycle = kwargs['saleCycle']
        if sale_cycle is None:
            raise TypeError("Missing 'sale_cycle' argument")
        if sockets is None:
            raise TypeError("Missing 'sockets' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if supported_custom_instance_type_families is None and 'supportedCustomInstanceTypeFamilies' in kwargs:
            supported_custom_instance_type_families = kwargs['supportedCustomInstanceTypeFamilies']
        if supported_custom_instance_type_families is None:
            raise TypeError("Missing 'supported_custom_instance_type_families' argument")
        if supported_instance_type_families is None and 'supportedInstanceTypeFamilies' in kwargs:
            supported_instance_type_families = kwargs['supportedInstanceTypeFamilies']
        if supported_instance_type_families is None:
            raise TypeError("Missing 'supported_instance_type_families' argument")
        if supported_instance_types_lists is None and 'supportedInstanceTypesLists' in kwargs:
            supported_instance_types_lists = kwargs['supportedInstanceTypesLists']
        if supported_instance_types_lists is None:
            raise TypeError("Missing 'supported_instance_types_lists' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("action_on_maintenance", action_on_maintenance)
        _setter("auto_placement", auto_placement)
        _setter("auto_release_time", auto_release_time)
        _setter("capacities", capacities)
        _setter("cores", cores)
        _setter("cpu_over_commit_ratio", cpu_over_commit_ratio)
        _setter("dedicated_host_id", dedicated_host_id)
        _setter("dedicated_host_name", dedicated_host_name)
        _setter("dedicated_host_type", dedicated_host_type)
        _setter("description", description)
        _setter("expired_time", expired_time)
        _setter("gpu_spec", gpu_spec)
        _setter("id", id)
        _setter("machine_id", machine_id)
        _setter("network_attributes", network_attributes)
        _setter("operation_locks", operation_locks)
        _setter("payment_type", payment_type)
        _setter("physical_gpus", physical_gpus)
        _setter("resource_group_id", resource_group_id)
        _setter("sale_cycle", sale_cycle)
        _setter("sockets", sockets)
        _setter("status", status)
        _setter("supported_custom_instance_type_families", supported_custom_instance_type_families)
        _setter("supported_instance_type_families", supported_instance_type_families)
        _setter("supported_instance_types_lists", supported_instance_types_lists)
        _setter("tags", tags)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="actionOnMaintenance")
    def action_on_maintenance(self) -> str:
        """
        The policy used to migrate the instances from the dedicated host when the dedicated host fails or needs to be repaired online.
        """
        return pulumi.get(self, "action_on_maintenance")

    @property
    @pulumi.getter(name="autoPlacement")
    def auto_placement(self) -> str:
        """
        Specifies whether to add the dedicated host to the resource pool for automatic deployment.
        """
        return pulumi.get(self, "auto_placement")

    @property
    @pulumi.getter(name="autoReleaseTime")
    def auto_release_time(self) -> str:
        """
        The automatic release time of the dedicated host.
        """
        return pulumi.get(self, "auto_release_time")

    @property
    @pulumi.getter
    def capacities(self) -> Sequence['outputs.GetDedicatedHostsHostCapacityResult']:
        """
        (Available in 1.123.1+) A collection of proprietary host performance indicators.
        """
        return pulumi.get(self, "capacities")

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter(name="cpuOverCommitRatio")
    def cpu_over_commit_ratio(self) -> float:
        """
        (Available in 1.123.1+) CPU oversold ratio.
        """
        return pulumi.get(self, "cpu_over_commit_ratio")

    @property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> str:
        """
        The ID of ECS Dedicated Host.
        """
        return pulumi.get(self, "dedicated_host_id")

    @property
    @pulumi.getter(name="dedicatedHostName")
    def dedicated_host_name(self) -> str:
        """
        The name of ECS Dedicated Host.
        """
        return pulumi.get(self, "dedicated_host_name")

    @property
    @pulumi.getter(name="dedicatedHostType")
    def dedicated_host_type(self) -> str:
        """
        The type of the dedicated host.
        """
        return pulumi.get(self, "dedicated_host_type")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the dedicated host.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        """
        The expiration time of the subscription dedicated host.
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter(name="gpuSpec")
    def gpu_spec(self) -> str:
        """
        The GPU model.
        """
        return pulumi.get(self, "gpu_spec")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the ECS Dedicated Host.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="machineId")
    def machine_id(self) -> str:
        """
        The machine code of the dedicated host.
        """
        return pulumi.get(self, "machine_id")

    @property
    @pulumi.getter(name="networkAttributes")
    def network_attributes(self) -> Sequence['outputs.GetDedicatedHostsHostNetworkAttributeResult']:
        """
        dedicated host network parameters. contains the following attributes:
        """
        return pulumi.get(self, "network_attributes")

    @property
    @pulumi.getter(name="operationLocks")
    def operation_locks(self) -> Sequence['outputs.GetDedicatedHostsHostOperationLockResult']:
        """
        The reason why the dedicated host resource is locked.
        """
        return pulumi.get(self, "operation_locks")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        """
        The billing method of the dedicated host.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="physicalGpus")
    def physical_gpus(self) -> int:
        """
        The number of physical GPUs.
        """
        return pulumi.get(self, "physical_gpus")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group to which the ECS Dedicated Host belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="saleCycle")
    def sale_cycle(self) -> str:
        """
        The unit of the subscription billing method.
        """
        return pulumi.get(self, "sale_cycle")

    @property
    @pulumi.getter
    def sockets(self) -> int:
        """
        The number of physical CPUs.
        """
        return pulumi.get(self, "sockets")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the ECS Dedicated Host. validate value: `Available`, `Creating`, `PermanentFailure`, `Released`, `UnderAssessment`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="supportedCustomInstanceTypeFamilies")
    def supported_custom_instance_type_families(self) -> Sequence[str]:
        """
        (Available in 1.123.1+) A custom instance type family supported by a dedicated host.
        """
        return pulumi.get(self, "supported_custom_instance_type_families")

    @property
    @pulumi.getter(name="supportedInstanceTypeFamilies")
    def supported_instance_type_families(self) -> Sequence[str]:
        """
        (Available in 1.123.1+) ECS instance type family supported by the dedicated host.
        """
        return pulumi.get(self, "supported_instance_type_families")

    @property
    @pulumi.getter(name="supportedInstanceTypesLists")
    def supported_instance_types_lists(self) -> Sequence[str]:
        """
        The list of ECS instance
        """
        return pulumi.get(self, "supported_instance_types_lists")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The zone ID of the ECS Dedicated Host.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetDedicatedHostsHostCapacityResult(dict):
    def __init__(__self__, *,
                 available_local_storage: int,
                 available_memory: float,
                 available_vcpus: int,
                 available_vgpus: int,
                 local_storage_category: str,
                 total_local_storage: int,
                 total_memory: float,
                 total_vcpus: int,
                 total_vgpus: int):
        """
        :param int available_local_storage: The remaining local disk capacity. Unit: GiB.
        :param float available_memory: The remaining memory capacity, unit: GiB.
        :param int available_vcpus: The number of remaining vCPU cores.
        :param int available_vgpus: The number of available virtual GPUs.
        :param str local_storage_category: Local disk type.
        :param int total_local_storage: The total capacity of the local disk, in GiB.
        :param float total_memory: The total memory capacity, unit: GiB.
        :param int total_vcpus: The total number of vCPU cores.
        :param int total_vgpus: The total number of virtual GPUs.
        """
        GetDedicatedHostsHostCapacityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_local_storage=available_local_storage,
            available_memory=available_memory,
            available_vcpus=available_vcpus,
            available_vgpus=available_vgpus,
            local_storage_category=local_storage_category,
            total_local_storage=total_local_storage,
            total_memory=total_memory,
            total_vcpus=total_vcpus,
            total_vgpus=total_vgpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_local_storage: Optional[int] = None,
             available_memory: Optional[float] = None,
             available_vcpus: Optional[int] = None,
             available_vgpus: Optional[int] = None,
             local_storage_category: Optional[str] = None,
             total_local_storage: Optional[int] = None,
             total_memory: Optional[float] = None,
             total_vcpus: Optional[int] = None,
             total_vgpus: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if available_local_storage is None and 'availableLocalStorage' in kwargs:
            available_local_storage = kwargs['availableLocalStorage']
        if available_local_storage is None:
            raise TypeError("Missing 'available_local_storage' argument")
        if available_memory is None and 'availableMemory' in kwargs:
            available_memory = kwargs['availableMemory']
        if available_memory is None:
            raise TypeError("Missing 'available_memory' argument")
        if available_vcpus is None and 'availableVcpus' in kwargs:
            available_vcpus = kwargs['availableVcpus']
        if available_vcpus is None:
            raise TypeError("Missing 'available_vcpus' argument")
        if available_vgpus is None and 'availableVgpus' in kwargs:
            available_vgpus = kwargs['availableVgpus']
        if available_vgpus is None:
            raise TypeError("Missing 'available_vgpus' argument")
        if local_storage_category is None and 'localStorageCategory' in kwargs:
            local_storage_category = kwargs['localStorageCategory']
        if local_storage_category is None:
            raise TypeError("Missing 'local_storage_category' argument")
        if total_local_storage is None and 'totalLocalStorage' in kwargs:
            total_local_storage = kwargs['totalLocalStorage']
        if total_local_storage is None:
            raise TypeError("Missing 'total_local_storage' argument")
        if total_memory is None and 'totalMemory' in kwargs:
            total_memory = kwargs['totalMemory']
        if total_memory is None:
            raise TypeError("Missing 'total_memory' argument")
        if total_vcpus is None and 'totalVcpus' in kwargs:
            total_vcpus = kwargs['totalVcpus']
        if total_vcpus is None:
            raise TypeError("Missing 'total_vcpus' argument")
        if total_vgpus is None and 'totalVgpus' in kwargs:
            total_vgpus = kwargs['totalVgpus']
        if total_vgpus is None:
            raise TypeError("Missing 'total_vgpus' argument")

        _setter("available_local_storage", available_local_storage)
        _setter("available_memory", available_memory)
        _setter("available_vcpus", available_vcpus)
        _setter("available_vgpus", available_vgpus)
        _setter("local_storage_category", local_storage_category)
        _setter("total_local_storage", total_local_storage)
        _setter("total_memory", total_memory)
        _setter("total_vcpus", total_vcpus)
        _setter("total_vgpus", total_vgpus)

    @property
    @pulumi.getter(name="availableLocalStorage")
    def available_local_storage(self) -> int:
        """
        The remaining local disk capacity. Unit: GiB.
        """
        return pulumi.get(self, "available_local_storage")

    @property
    @pulumi.getter(name="availableMemory")
    def available_memory(self) -> float:
        """
        The remaining memory capacity, unit: GiB.
        """
        return pulumi.get(self, "available_memory")

    @property
    @pulumi.getter(name="availableVcpus")
    def available_vcpus(self) -> int:
        """
        The number of remaining vCPU cores.
        """
        return pulumi.get(self, "available_vcpus")

    @property
    @pulumi.getter(name="availableVgpus")
    def available_vgpus(self) -> int:
        """
        The number of available virtual GPUs.
        """
        return pulumi.get(self, "available_vgpus")

    @property
    @pulumi.getter(name="localStorageCategory")
    def local_storage_category(self) -> str:
        """
        Local disk type.
        """
        return pulumi.get(self, "local_storage_category")

    @property
    @pulumi.getter(name="totalLocalStorage")
    def total_local_storage(self) -> int:
        """
        The total capacity of the local disk, in GiB.
        """
        return pulumi.get(self, "total_local_storage")

    @property
    @pulumi.getter(name="totalMemory")
    def total_memory(self) -> float:
        """
        The total memory capacity, unit: GiB.
        """
        return pulumi.get(self, "total_memory")

    @property
    @pulumi.getter(name="totalVcpus")
    def total_vcpus(self) -> int:
        """
        The total number of vCPU cores.
        """
        return pulumi.get(self, "total_vcpus")

    @property
    @pulumi.getter(name="totalVgpus")
    def total_vgpus(self) -> int:
        """
        The total number of virtual GPUs.
        """
        return pulumi.get(self, "total_vgpus")


@pulumi.output_type
class GetDedicatedHostsHostNetworkAttributeResult(dict):
    def __init__(__self__, *,
                 slb_udp_timeout: int,
                 udp_timeout: int):
        """
        :param int slb_udp_timeout: The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds.
        :param int udp_timeout: (Available in 1.123.1+) The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds.
        """
        GetDedicatedHostsHostNetworkAttributeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            slb_udp_timeout=slb_udp_timeout,
            udp_timeout=udp_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             slb_udp_timeout: Optional[int] = None,
             udp_timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if slb_udp_timeout is None and 'slbUdpTimeout' in kwargs:
            slb_udp_timeout = kwargs['slbUdpTimeout']
        if slb_udp_timeout is None:
            raise TypeError("Missing 'slb_udp_timeout' argument")
        if udp_timeout is None and 'udpTimeout' in kwargs:
            udp_timeout = kwargs['udpTimeout']
        if udp_timeout is None:
            raise TypeError("Missing 'udp_timeout' argument")

        _setter("slb_udp_timeout", slb_udp_timeout)
        _setter("udp_timeout", udp_timeout)

    @property
    @pulumi.getter(name="slbUdpTimeout")
    def slb_udp_timeout(self) -> int:
        """
        The timeout period for a UDP session between Server Load Balancer (SLB) and the dedicated host. Unit: seconds.
        """
        return pulumi.get(self, "slb_udp_timeout")

    @property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> int:
        """
        (Available in 1.123.1+) The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class GetDedicatedHostsHostOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: str):
        """
        :param str lock_reason: The reason why the dedicated host resource is locked.
        """
        GetDedicatedHostsHostOperationLockResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']
        if lock_reason is None:
            raise TypeError("Missing 'lock_reason' argument")

        _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> str:
        """
        The reason why the dedicated host resource is locked.
        """
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetDedicatedHostsOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: Optional[str] = None):
        """
        :param str lock_reason: The reason why the dedicated host resource is locked.
        """
        GetDedicatedHostsOperationLockResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']

        if lock_reason is not None:
            _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> Optional[str]:
        """
        The reason why the dedicated host resource is locked.
        """
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetDisksDiskResult(dict):
    def __init__(__self__, *,
                 attached_time: str,
                 auto_snapshot_policy_id: str,
                 availability_zone: str,
                 category: str,
                 creation_time: str,
                 delete_auto_snapshot: bool,
                 delete_with_instance: bool,
                 description: str,
                 detached_time: str,
                 device: str,
                 disk_id: str,
                 disk_name: str,
                 disk_type: str,
                 enable_auto_snapshot: bool,
                 enable_automated_snapshot_policy: bool,
                 encrypted: str,
                 expired_time: str,
                 id: str,
                 image_id: str,
                 instance_id: str,
                 iops: int,
                 iops_read: int,
                 iops_write: int,
                 kms_key_id: str,
                 mount_instance_num: int,
                 mount_instances: Sequence['outputs.GetDisksDiskMountInstanceResult'],
                 name: str,
                 operation_locks: Sequence['outputs.GetDisksDiskOperationLockResult'],
                 payment_type: str,
                 performance_level: str,
                 portable: bool,
                 product_code: str,
                 region_id: str,
                 resource_group_id: str,
                 size: int,
                 snapshot_id: str,
                 status: str,
                 tags: Mapping[str, Any],
                 type: str,
                 zone_id: str):
        """
        :param str attached_time: Disk attachment time.
        :param str availability_zone: Availability zone of the disk.
        :param str category: Disk category. Possible values: `cloud` (basic cloud disk), `cloud_efficiency` (ultra cloud disk), `ephemeral_ssd` (local SSD cloud disk), `cloud_ssd` (SSD cloud disk), and `cloud_essd` (ESSD cloud disk).
        :param str creation_time: Disk creation time.
        :param str description: Disk description.
        :param str detached_time: Disk detachment time.
        :param str encrypted: Indicate whether the disk is encrypted or not. Possible values: `on` and `off`.
        :param str id: ID of the disk.
        :param str image_id: ID of the image from which the disk is created. It is null unless the disk is created using an image.
        :param str instance_id: Filter the results by the specified ECS instance ID.
        :param str name: Disk name.
        :param str region_id: Region ID the disk belongs to.
        :param str resource_group_id: The Id of resource group which the disk belongs.
        :param int size: Disk size in GiB.
        :param str snapshot_id: Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
        :param str status: Current status. Possible values: `In_use`, `Available`, `Attaching`, `Detaching`, `Creating` and `ReIniting`.
        :param Mapping[str, Any] tags: A map of tags assigned to the disks. It must be in the format:
        :param str type: Disk type. Possible values: `system` and `data`.
        """
        GetDisksDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attached_time=attached_time,
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            availability_zone=availability_zone,
            category=category,
            creation_time=creation_time,
            delete_auto_snapshot=delete_auto_snapshot,
            delete_with_instance=delete_with_instance,
            description=description,
            detached_time=detached_time,
            device=device,
            disk_id=disk_id,
            disk_name=disk_name,
            disk_type=disk_type,
            enable_auto_snapshot=enable_auto_snapshot,
            enable_automated_snapshot_policy=enable_automated_snapshot_policy,
            encrypted=encrypted,
            expired_time=expired_time,
            id=id,
            image_id=image_id,
            instance_id=instance_id,
            iops=iops,
            iops_read=iops_read,
            iops_write=iops_write,
            kms_key_id=kms_key_id,
            mount_instance_num=mount_instance_num,
            mount_instances=mount_instances,
            name=name,
            operation_locks=operation_locks,
            payment_type=payment_type,
            performance_level=performance_level,
            portable=portable,
            product_code=product_code,
            region_id=region_id,
            resource_group_id=resource_group_id,
            size=size,
            snapshot_id=snapshot_id,
            status=status,
            tags=tags,
            type=type,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attached_time: Optional[str] = None,
             auto_snapshot_policy_id: Optional[str] = None,
             availability_zone: Optional[str] = None,
             category: Optional[str] = None,
             creation_time: Optional[str] = None,
             delete_auto_snapshot: Optional[bool] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             detached_time: Optional[str] = None,
             device: Optional[str] = None,
             disk_id: Optional[str] = None,
             disk_name: Optional[str] = None,
             disk_type: Optional[str] = None,
             enable_auto_snapshot: Optional[bool] = None,
             enable_automated_snapshot_policy: Optional[bool] = None,
             encrypted: Optional[str] = None,
             expired_time: Optional[str] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             iops: Optional[int] = None,
             iops_read: Optional[int] = None,
             iops_write: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             mount_instance_num: Optional[int] = None,
             mount_instances: Optional[Sequence['outputs.GetDisksDiskMountInstanceResult']] = None,
             name: Optional[str] = None,
             operation_locks: Optional[Sequence['outputs.GetDisksDiskOperationLockResult']] = None,
             payment_type: Optional[str] = None,
             performance_level: Optional[str] = None,
             portable: Optional[bool] = None,
             product_code: Optional[str] = None,
             region_id: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attached_time is None and 'attachedTime' in kwargs:
            attached_time = kwargs['attachedTime']
        if attached_time is None:
            raise TypeError("Missing 'attached_time' argument")
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if auto_snapshot_policy_id is None:
            raise TypeError("Missing 'auto_snapshot_policy_id' argument")
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if category is None:
            raise TypeError("Missing 'category' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if delete_auto_snapshot is None and 'deleteAutoSnapshot' in kwargs:
            delete_auto_snapshot = kwargs['deleteAutoSnapshot']
        if delete_auto_snapshot is None:
            raise TypeError("Missing 'delete_auto_snapshot' argument")
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if delete_with_instance is None:
            raise TypeError("Missing 'delete_with_instance' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if detached_time is None and 'detachedTime' in kwargs:
            detached_time = kwargs['detachedTime']
        if detached_time is None:
            raise TypeError("Missing 'detached_time' argument")
        if device is None:
            raise TypeError("Missing 'device' argument")
        if disk_id is None and 'diskId' in kwargs:
            disk_id = kwargs['diskId']
        if disk_id is None:
            raise TypeError("Missing 'disk_id' argument")
        if disk_name is None and 'diskName' in kwargs:
            disk_name = kwargs['diskName']
        if disk_name is None:
            raise TypeError("Missing 'disk_name' argument")
        if disk_type is None and 'diskType' in kwargs:
            disk_type = kwargs['diskType']
        if disk_type is None:
            raise TypeError("Missing 'disk_type' argument")
        if enable_auto_snapshot is None and 'enableAutoSnapshot' in kwargs:
            enable_auto_snapshot = kwargs['enableAutoSnapshot']
        if enable_auto_snapshot is None:
            raise TypeError("Missing 'enable_auto_snapshot' argument")
        if enable_automated_snapshot_policy is None and 'enableAutomatedSnapshotPolicy' in kwargs:
            enable_automated_snapshot_policy = kwargs['enableAutomatedSnapshotPolicy']
        if enable_automated_snapshot_policy is None:
            raise TypeError("Missing 'enable_automated_snapshot_policy' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if iops_read is None and 'iopsRead' in kwargs:
            iops_read = kwargs['iopsRead']
        if iops_read is None:
            raise TypeError("Missing 'iops_read' argument")
        if iops_write is None and 'iopsWrite' in kwargs:
            iops_write = kwargs['iopsWrite']
        if iops_write is None:
            raise TypeError("Missing 'iops_write' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")
        if mount_instance_num is None and 'mountInstanceNum' in kwargs:
            mount_instance_num = kwargs['mountInstanceNum']
        if mount_instance_num is None:
            raise TypeError("Missing 'mount_instance_num' argument")
        if mount_instances is None and 'mountInstances' in kwargs:
            mount_instances = kwargs['mountInstances']
        if mount_instances is None:
            raise TypeError("Missing 'mount_instances' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if operation_locks is None and 'operationLocks' in kwargs:
            operation_locks = kwargs['operationLocks']
        if operation_locks is None:
            raise TypeError("Missing 'operation_locks' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if performance_level is None:
            raise TypeError("Missing 'performance_level' argument")
        if portable is None:
            raise TypeError("Missing 'portable' argument")
        if product_code is None and 'productCode' in kwargs:
            product_code = kwargs['productCode']
        if product_code is None:
            raise TypeError("Missing 'product_code' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("attached_time", attached_time)
        _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        _setter("availability_zone", availability_zone)
        _setter("category", category)
        _setter("creation_time", creation_time)
        _setter("delete_auto_snapshot", delete_auto_snapshot)
        _setter("delete_with_instance", delete_with_instance)
        _setter("description", description)
        _setter("detached_time", detached_time)
        _setter("device", device)
        _setter("disk_id", disk_id)
        _setter("disk_name", disk_name)
        _setter("disk_type", disk_type)
        _setter("enable_auto_snapshot", enable_auto_snapshot)
        _setter("enable_automated_snapshot_policy", enable_automated_snapshot_policy)
        _setter("encrypted", encrypted)
        _setter("expired_time", expired_time)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("instance_id", instance_id)
        _setter("iops", iops)
        _setter("iops_read", iops_read)
        _setter("iops_write", iops_write)
        _setter("kms_key_id", kms_key_id)
        _setter("mount_instance_num", mount_instance_num)
        _setter("mount_instances", mount_instances)
        _setter("name", name)
        _setter("operation_locks", operation_locks)
        _setter("payment_type", payment_type)
        _setter("performance_level", performance_level)
        _setter("portable", portable)
        _setter("product_code", product_code)
        _setter("region_id", region_id)
        _setter("resource_group_id", resource_group_id)
        _setter("size", size)
        _setter("snapshot_id", snapshot_id)
        _setter("status", status)
        _setter("tags", tags)
        _setter("type", type)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="attachedTime")
    def attached_time(self) -> str:
        """
        Disk attachment time.
        """
        return pulumi.get(self, "attached_time")

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> str:
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        Availability zone of the disk.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Disk category. Possible values: `cloud` (basic cloud disk), `cloud_efficiency` (ultra cloud disk), `ephemeral_ssd` (local SSD cloud disk), `cloud_ssd` (SSD cloud disk), and `cloud_essd` (ESSD cloud disk).
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Disk creation time.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="deleteAutoSnapshot")
    def delete_auto_snapshot(self) -> bool:
        return pulumi.get(self, "delete_auto_snapshot")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> bool:
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Disk description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="detachedTime")
    def detached_time(self) -> str:
        """
        Disk detachment time.
        """
        return pulumi.get(self, "detached_time")

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter(name="enableAutoSnapshot")
    def enable_auto_snapshot(self) -> bool:
        return pulumi.get(self, "enable_auto_snapshot")

    @property
    @pulumi.getter(name="enableAutomatedSnapshotPolicy")
    def enable_automated_snapshot_policy(self) -> bool:
        return pulumi.get(self, "enable_automated_snapshot_policy")

    @property
    @pulumi.getter
    def encrypted(self) -> str:
        """
        Indicate whether the disk is encrypted or not. Possible values: `on` and `off`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the disk.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        ID of the image from which the disk is created. It is null unless the disk is created using an image.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        Filter the results by the specified ECS instance ID.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def iops(self) -> int:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="iopsRead")
    def iops_read(self) -> int:
        return pulumi.get(self, "iops_read")

    @property
    @pulumi.getter(name="iopsWrite")
    def iops_write(self) -> int:
        return pulumi.get(self, "iops_write")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="mountInstanceNum")
    def mount_instance_num(self) -> int:
        return pulumi.get(self, "mount_instance_num")

    @property
    @pulumi.getter(name="mountInstances")
    def mount_instances(self) -> Sequence['outputs.GetDisksDiskMountInstanceResult']:
        return pulumi.get(self, "mount_instances")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Disk name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationLocks")
    def operation_locks(self) -> Sequence['outputs.GetDisksDiskOperationLockResult']:
        return pulumi.get(self, "operation_locks")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> str:
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def portable(self) -> bool:
        return pulumi.get(self, "portable")

    @property
    @pulumi.getter(name="productCode")
    def product_code(self) -> str:
        return pulumi.get(self, "product_code")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        Region ID the disk belongs to.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which the disk belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Disk size in GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status. Possible values: `In_use`, `Available`, `Attaching`, `Detaching`, `Creating` and `ReIniting`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the disks. It must be in the format:
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Disk type. Possible values: `system` and `data`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetDisksDiskMountInstanceResult(dict):
    def __init__(__self__, *,
                 attached_time: str,
                 device: str,
                 instance_id: str):
        """
        :param str attached_time: Disk attachment time.
        :param str instance_id: Filter the results by the specified ECS instance ID.
        """
        GetDisksDiskMountInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attached_time=attached_time,
            device=device,
            instance_id=instance_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attached_time: Optional[str] = None,
             device: Optional[str] = None,
             instance_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attached_time is None and 'attachedTime' in kwargs:
            attached_time = kwargs['attachedTime']
        if attached_time is None:
            raise TypeError("Missing 'attached_time' argument")
        if device is None:
            raise TypeError("Missing 'device' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")

        _setter("attached_time", attached_time)
        _setter("device", device)
        _setter("instance_id", instance_id)

    @property
    @pulumi.getter(name="attachedTime")
    def attached_time(self) -> str:
        """
        Disk attachment time.
        """
        return pulumi.get(self, "attached_time")

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        Filter the results by the specified ECS instance ID.
        """
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class GetDisksDiskOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: str):
        GetDisksDiskOperationLockResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']
        if lock_reason is None:
            raise TypeError("Missing 'lock_reason' argument")

        _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> str:
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetDisksOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: Optional[str] = None):
        GetDisksOperationLockResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']

        if lock_reason is not None:
            _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> Optional[str]:
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetEcsDedicatedHostClustersClusterResult(dict):
    def __init__(__self__, *,
                 dedicated_host_cluster_capacities: Sequence['outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityResult'],
                 dedicated_host_cluster_id: str,
                 dedicated_host_cluster_name: str,
                 dedicated_host_ids: Sequence[str],
                 description: str,
                 id: str,
                 resource_group_id: str,
                 tags: Mapping[str, Any],
                 zone_id: str):
        """
        :param Sequence['GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityArgs'] dedicated_host_cluster_capacities: The capacity of the dedicated host cluster.
        :param str dedicated_host_cluster_id: The ID of the dedicated host cluster.
        :param str dedicated_host_cluster_name: The name of the dedicated host cluster.
        :param Sequence[str] dedicated_host_ids: The IDs of dedicated hosts in the dedicated host cluster.
        :param str description: The description of the dedicated host cluster.
        :param str id: The ID of the Dedicated Host Cluster.
        :param str resource_group_id: The ID of the resource group to which the dedicated host cluster belongs.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        :param str zone_id: The zone ID of the dedicated host cluster.
        """
        GetEcsDedicatedHostClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dedicated_host_cluster_capacities=dedicated_host_cluster_capacities,
            dedicated_host_cluster_id=dedicated_host_cluster_id,
            dedicated_host_cluster_name=dedicated_host_cluster_name,
            dedicated_host_ids=dedicated_host_ids,
            description=description,
            id=id,
            resource_group_id=resource_group_id,
            tags=tags,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dedicated_host_cluster_capacities: Optional[Sequence['outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityResult']] = None,
             dedicated_host_cluster_id: Optional[str] = None,
             dedicated_host_cluster_name: Optional[str] = None,
             dedicated_host_ids: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dedicated_host_cluster_capacities is None and 'dedicatedHostClusterCapacities' in kwargs:
            dedicated_host_cluster_capacities = kwargs['dedicatedHostClusterCapacities']
        if dedicated_host_cluster_capacities is None:
            raise TypeError("Missing 'dedicated_host_cluster_capacities' argument")
        if dedicated_host_cluster_id is None and 'dedicatedHostClusterId' in kwargs:
            dedicated_host_cluster_id = kwargs['dedicatedHostClusterId']
        if dedicated_host_cluster_id is None:
            raise TypeError("Missing 'dedicated_host_cluster_id' argument")
        if dedicated_host_cluster_name is None and 'dedicatedHostClusterName' in kwargs:
            dedicated_host_cluster_name = kwargs['dedicatedHostClusterName']
        if dedicated_host_cluster_name is None:
            raise TypeError("Missing 'dedicated_host_cluster_name' argument")
        if dedicated_host_ids is None and 'dedicatedHostIds' in kwargs:
            dedicated_host_ids = kwargs['dedicatedHostIds']
        if dedicated_host_ids is None:
            raise TypeError("Missing 'dedicated_host_ids' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("dedicated_host_cluster_capacities", dedicated_host_cluster_capacities)
        _setter("dedicated_host_cluster_id", dedicated_host_cluster_id)
        _setter("dedicated_host_cluster_name", dedicated_host_cluster_name)
        _setter("dedicated_host_ids", dedicated_host_ids)
        _setter("description", description)
        _setter("id", id)
        _setter("resource_group_id", resource_group_id)
        _setter("tags", tags)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="dedicatedHostClusterCapacities")
    def dedicated_host_cluster_capacities(self) -> Sequence['outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityResult']:
        """
        The capacity of the dedicated host cluster.
        """
        return pulumi.get(self, "dedicated_host_cluster_capacities")

    @property
    @pulumi.getter(name="dedicatedHostClusterId")
    def dedicated_host_cluster_id(self) -> str:
        """
        The ID of the dedicated host cluster.
        """
        return pulumi.get(self, "dedicated_host_cluster_id")

    @property
    @pulumi.getter(name="dedicatedHostClusterName")
    def dedicated_host_cluster_name(self) -> str:
        """
        The name of the dedicated host cluster.
        """
        return pulumi.get(self, "dedicated_host_cluster_name")

    @property
    @pulumi.getter(name="dedicatedHostIds")
    def dedicated_host_ids(self) -> Sequence[str]:
        """
        The IDs of dedicated hosts in the dedicated host cluster.
        """
        return pulumi.get(self, "dedicated_host_ids")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the dedicated host cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Dedicated Host Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group to which the dedicated host cluster belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The zone ID of the dedicated host cluster.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityResult(dict):
    def __init__(__self__, *,
                 available_memory: int,
                 available_vcpus: int,
                 local_storage_capacities: Sequence['outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityResult'],
                 total_memory: int,
                 total_vcpus: int):
        """
        :param int available_memory: The available memory size. Unit: `GiB`.
        :param int available_vcpus: The number of available vCPUs.
        :param Sequence['GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityArgs'] local_storage_capacities: The local storage.
        :param int total_memory: The total memory size. Unit: `GiB`.
        :param int total_vcpus: The total number of vCPUs.
        """
        GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_memory=available_memory,
            available_vcpus=available_vcpus,
            local_storage_capacities=local_storage_capacities,
            total_memory=total_memory,
            total_vcpus=total_vcpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_memory: Optional[int] = None,
             available_vcpus: Optional[int] = None,
             local_storage_capacities: Optional[Sequence['outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityResult']] = None,
             total_memory: Optional[int] = None,
             total_vcpus: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if available_memory is None and 'availableMemory' in kwargs:
            available_memory = kwargs['availableMemory']
        if available_memory is None:
            raise TypeError("Missing 'available_memory' argument")
        if available_vcpus is None and 'availableVcpus' in kwargs:
            available_vcpus = kwargs['availableVcpus']
        if available_vcpus is None:
            raise TypeError("Missing 'available_vcpus' argument")
        if local_storage_capacities is None and 'localStorageCapacities' in kwargs:
            local_storage_capacities = kwargs['localStorageCapacities']
        if local_storage_capacities is None:
            raise TypeError("Missing 'local_storage_capacities' argument")
        if total_memory is None and 'totalMemory' in kwargs:
            total_memory = kwargs['totalMemory']
        if total_memory is None:
            raise TypeError("Missing 'total_memory' argument")
        if total_vcpus is None and 'totalVcpus' in kwargs:
            total_vcpus = kwargs['totalVcpus']
        if total_vcpus is None:
            raise TypeError("Missing 'total_vcpus' argument")

        _setter("available_memory", available_memory)
        _setter("available_vcpus", available_vcpus)
        _setter("local_storage_capacities", local_storage_capacities)
        _setter("total_memory", total_memory)
        _setter("total_vcpus", total_vcpus)

    @property
    @pulumi.getter(name="availableMemory")
    def available_memory(self) -> int:
        """
        The available memory size. Unit: `GiB`.
        """
        return pulumi.get(self, "available_memory")

    @property
    @pulumi.getter(name="availableVcpus")
    def available_vcpus(self) -> int:
        """
        The number of available vCPUs.
        """
        return pulumi.get(self, "available_vcpus")

    @property
    @pulumi.getter(name="localStorageCapacities")
    def local_storage_capacities(self) -> Sequence['outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityResult']:
        """
        The local storage.
        """
        return pulumi.get(self, "local_storage_capacities")

    @property
    @pulumi.getter(name="totalMemory")
    def total_memory(self) -> int:
        """
        The total memory size. Unit: `GiB`.
        """
        return pulumi.get(self, "total_memory")

    @property
    @pulumi.getter(name="totalVcpus")
    def total_vcpus(self) -> int:
        """
        The total number of vCPUs.
        """
        return pulumi.get(self, "total_vcpus")


@pulumi.output_type
class GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityResult(dict):
    def __init__(__self__, *,
                 available_disk: int,
                 data_disk_category: str,
                 total_disk: int):
        """
        :param int available_disk: The available capacity of the local disk. Unit: `GiB`.
        :param str data_disk_category: The category of the data disk. Valid values:`cloud`, `cloud_efficiency`, `cloud_ssd`, `ephemeral_ssd`, `cloud_essd`.
        :param int total_disk: The total capacity of the local disk. Unit: `GiB`.
        """
        GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_disk=available_disk,
            data_disk_category=data_disk_category,
            total_disk=total_disk,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_disk: Optional[int] = None,
             data_disk_category: Optional[str] = None,
             total_disk: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if available_disk is None and 'availableDisk' in kwargs:
            available_disk = kwargs['availableDisk']
        if available_disk is None:
            raise TypeError("Missing 'available_disk' argument")
        if data_disk_category is None and 'dataDiskCategory' in kwargs:
            data_disk_category = kwargs['dataDiskCategory']
        if data_disk_category is None:
            raise TypeError("Missing 'data_disk_category' argument")
        if total_disk is None and 'totalDisk' in kwargs:
            total_disk = kwargs['totalDisk']
        if total_disk is None:
            raise TypeError("Missing 'total_disk' argument")

        _setter("available_disk", available_disk)
        _setter("data_disk_category", data_disk_category)
        _setter("total_disk", total_disk)

    @property
    @pulumi.getter(name="availableDisk")
    def available_disk(self) -> int:
        """
        The available capacity of the local disk. Unit: `GiB`.
        """
        return pulumi.get(self, "available_disk")

    @property
    @pulumi.getter(name="dataDiskCategory")
    def data_disk_category(self) -> str:
        """
        The category of the data disk. Valid values:`cloud`, `cloud_efficiency`, `cloud_ssd`, `ephemeral_ssd`, `cloud_essd`.
        """
        return pulumi.get(self, "data_disk_category")

    @property
    @pulumi.getter(name="totalDisk")
    def total_disk(self) -> int:
        """
        The total capacity of the local disk. Unit: `GiB`.
        """
        return pulumi.get(self, "total_disk")


@pulumi.output_type
class GetEcsDeploymentSetsSetResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 deployment_set_id: str,
                 deployment_set_name: str,
                 description: str,
                 domain: str,
                 granularity: str,
                 id: str,
                 instance_amount: int,
                 instance_ids: Sequence[str],
                 strategy: str):
        """
        :param str create_time: The time when the deployment set was created.
        :param str deployment_set_id: The ID of the Deployment Set.
        :param str deployment_set_name: The name of the deployment set.
        :param str description: The description of the deployment set.
        :param str domain: The deployment domain.
        :param str granularity: The deployment granularity.
        :param str id: The ID of the Deployment Set.
        :param int instance_amount: The number of instances in the deployment set.
        :param Sequence[str] instance_ids: The IDs of the instances in the deployment set.
        :param str strategy: The deployment strategy.
        """
        GetEcsDeploymentSetsSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_time=create_time,
            deployment_set_id=deployment_set_id,
            deployment_set_name=deployment_set_name,
            description=description,
            domain=domain,
            granularity=granularity,
            id=id,
            instance_amount=instance_amount,
            instance_ids=instance_ids,
            strategy=strategy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_time: Optional[str] = None,
             deployment_set_id: Optional[str] = None,
             deployment_set_name: Optional[str] = None,
             description: Optional[str] = None,
             domain: Optional[str] = None,
             granularity: Optional[str] = None,
             id: Optional[str] = None,
             instance_amount: Optional[int] = None,
             instance_ids: Optional[Sequence[str]] = None,
             strategy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if deployment_set_id is None and 'deploymentSetId' in kwargs:
            deployment_set_id = kwargs['deploymentSetId']
        if deployment_set_id is None:
            raise TypeError("Missing 'deployment_set_id' argument")
        if deployment_set_name is None and 'deploymentSetName' in kwargs:
            deployment_set_name = kwargs['deploymentSetName']
        if deployment_set_name is None:
            raise TypeError("Missing 'deployment_set_name' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if domain is None:
            raise TypeError("Missing 'domain' argument")
        if granularity is None:
            raise TypeError("Missing 'granularity' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_amount is None and 'instanceAmount' in kwargs:
            instance_amount = kwargs['instanceAmount']
        if instance_amount is None:
            raise TypeError("Missing 'instance_amount' argument")
        if instance_ids is None and 'instanceIds' in kwargs:
            instance_ids = kwargs['instanceIds']
        if instance_ids is None:
            raise TypeError("Missing 'instance_ids' argument")
        if strategy is None:
            raise TypeError("Missing 'strategy' argument")

        _setter("create_time", create_time)
        _setter("deployment_set_id", deployment_set_id)
        _setter("deployment_set_name", deployment_set_name)
        _setter("description", description)
        _setter("domain", domain)
        _setter("granularity", granularity)
        _setter("id", id)
        _setter("instance_amount", instance_amount)
        _setter("instance_ids", instance_ids)
        _setter("strategy", strategy)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time when the deployment set was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deploymentSetId")
    def deployment_set_id(self) -> str:
        """
        The ID of the Deployment Set.
        """
        return pulumi.get(self, "deployment_set_id")

    @property
    @pulumi.getter(name="deploymentSetName")
    def deployment_set_name(self) -> str:
        """
        The name of the deployment set.
        """
        return pulumi.get(self, "deployment_set_name")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the deployment set.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The deployment domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The deployment granularity.
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Deployment Set.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceAmount")
    def instance_amount(self) -> int:
        """
        The number of instances in the deployment set.
        """
        return pulumi.get(self, "instance_amount")

    @property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Sequence[str]:
        """
        The IDs of the instances in the deployment set.
        """
        return pulumi.get(self, "instance_ids")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The deployment strategy.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetEcsDisksDiskResult(dict):
    def __init__(__self__, *,
                 attached_time: str,
                 auto_snapshot_policy_id: str,
                 availability_zone: str,
                 category: str,
                 creation_time: str,
                 delete_auto_snapshot: bool,
                 delete_with_instance: bool,
                 description: str,
                 detached_time: str,
                 device: str,
                 disk_id: str,
                 disk_name: str,
                 disk_type: str,
                 enable_auto_snapshot: bool,
                 enable_automated_snapshot_policy: bool,
                 encrypted: str,
                 expired_time: str,
                 id: str,
                 image_id: str,
                 instance_id: str,
                 iops: int,
                 iops_read: int,
                 iops_write: int,
                 kms_key_id: str,
                 mount_instance_num: int,
                 mount_instances: Sequence['outputs.GetEcsDisksDiskMountInstanceResult'],
                 name: str,
                 operation_locks: Sequence['outputs.GetEcsDisksDiskOperationLockResult'],
                 payment_type: str,
                 performance_level: str,
                 portable: bool,
                 product_code: str,
                 region_id: str,
                 resource_group_id: str,
                 size: int,
                 snapshot_id: str,
                 status: str,
                 tags: Mapping[str, Any],
                 type: str,
                 zone_id: str):
        """
        :param str attached_time: A mount of time.
        :param str auto_snapshot_policy_id: Query cloud disks based on the automatic snapshot policy ID.
        :param str availability_zone: Availability zone of the disk.
        :param str category: Disk category.
        :param str creation_time: Disk creation time.
        :param bool delete_auto_snapshot: Indicates whether the automatic snapshot is deleted when the disk is released.
        :param bool delete_with_instance: Indicates whether the disk is released together with the instance.
        :param str description: Disk description.
        :param str detached_time: Disk detachment time.
        :param str device: The mount point of the disk.
        :param str disk_id: ID of the disk.
        :param str disk_name: The disk name.
        :param str disk_type: The disk type.
        :param bool enable_auto_snapshot: Whether the disk implements an automatic snapshot policy.
        :param bool enable_automated_snapshot_policy: Whether the disk implements an automatic snapshot policy.
        :param str encrypted: Indicate whether the disk is encrypted or not.
        :param str id: ID of the disk.
        :param str image_id: ID of the image from which the disk is created. It is null unless the disk is created using an image.
        :param str instance_id: The instance ID of the disk mount.
        :param str kms_key_id: The kms key id.
        :param int mount_instance_num: Number of instances mounted on shared storage.
        :param Sequence['GetEcsDisksDiskMountInstanceArgs'] mount_instances: Disk mount instances.
        :param str name: Disk name.
        :param str payment_type: Payment method for disk.
        :param str performance_level: Performance levels of ESSD cloud disk.
        :param bool portable: Whether the disk is unmountable.
        :param str product_code: The product logo of the cloud market.
        :param str region_id: Region ID the disk belongs to.
        :param str resource_group_id: The Id of resource group.
        :param int size: Disk size in GiB.
        :param str snapshot_id: Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
        :param str status: Current status.
        :param Mapping[str, Any] tags: A map of tags assigned to the disk.
        :param str type: Disk type.
        :param str zone_id: The zone id.
        """
        GetEcsDisksDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attached_time=attached_time,
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            availability_zone=availability_zone,
            category=category,
            creation_time=creation_time,
            delete_auto_snapshot=delete_auto_snapshot,
            delete_with_instance=delete_with_instance,
            description=description,
            detached_time=detached_time,
            device=device,
            disk_id=disk_id,
            disk_name=disk_name,
            disk_type=disk_type,
            enable_auto_snapshot=enable_auto_snapshot,
            enable_automated_snapshot_policy=enable_automated_snapshot_policy,
            encrypted=encrypted,
            expired_time=expired_time,
            id=id,
            image_id=image_id,
            instance_id=instance_id,
            iops=iops,
            iops_read=iops_read,
            iops_write=iops_write,
            kms_key_id=kms_key_id,
            mount_instance_num=mount_instance_num,
            mount_instances=mount_instances,
            name=name,
            operation_locks=operation_locks,
            payment_type=payment_type,
            performance_level=performance_level,
            portable=portable,
            product_code=product_code,
            region_id=region_id,
            resource_group_id=resource_group_id,
            size=size,
            snapshot_id=snapshot_id,
            status=status,
            tags=tags,
            type=type,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attached_time: Optional[str] = None,
             auto_snapshot_policy_id: Optional[str] = None,
             availability_zone: Optional[str] = None,
             category: Optional[str] = None,
             creation_time: Optional[str] = None,
             delete_auto_snapshot: Optional[bool] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             detached_time: Optional[str] = None,
             device: Optional[str] = None,
             disk_id: Optional[str] = None,
             disk_name: Optional[str] = None,
             disk_type: Optional[str] = None,
             enable_auto_snapshot: Optional[bool] = None,
             enable_automated_snapshot_policy: Optional[bool] = None,
             encrypted: Optional[str] = None,
             expired_time: Optional[str] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             iops: Optional[int] = None,
             iops_read: Optional[int] = None,
             iops_write: Optional[int] = None,
             kms_key_id: Optional[str] = None,
             mount_instance_num: Optional[int] = None,
             mount_instances: Optional[Sequence['outputs.GetEcsDisksDiskMountInstanceResult']] = None,
             name: Optional[str] = None,
             operation_locks: Optional[Sequence['outputs.GetEcsDisksDiskOperationLockResult']] = None,
             payment_type: Optional[str] = None,
             performance_level: Optional[str] = None,
             portable: Optional[bool] = None,
             product_code: Optional[str] = None,
             region_id: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attached_time is None and 'attachedTime' in kwargs:
            attached_time = kwargs['attachedTime']
        if attached_time is None:
            raise TypeError("Missing 'attached_time' argument")
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if auto_snapshot_policy_id is None:
            raise TypeError("Missing 'auto_snapshot_policy_id' argument")
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if category is None:
            raise TypeError("Missing 'category' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if delete_auto_snapshot is None and 'deleteAutoSnapshot' in kwargs:
            delete_auto_snapshot = kwargs['deleteAutoSnapshot']
        if delete_auto_snapshot is None:
            raise TypeError("Missing 'delete_auto_snapshot' argument")
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if delete_with_instance is None:
            raise TypeError("Missing 'delete_with_instance' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if detached_time is None and 'detachedTime' in kwargs:
            detached_time = kwargs['detachedTime']
        if detached_time is None:
            raise TypeError("Missing 'detached_time' argument")
        if device is None:
            raise TypeError("Missing 'device' argument")
        if disk_id is None and 'diskId' in kwargs:
            disk_id = kwargs['diskId']
        if disk_id is None:
            raise TypeError("Missing 'disk_id' argument")
        if disk_name is None and 'diskName' in kwargs:
            disk_name = kwargs['diskName']
        if disk_name is None:
            raise TypeError("Missing 'disk_name' argument")
        if disk_type is None and 'diskType' in kwargs:
            disk_type = kwargs['diskType']
        if disk_type is None:
            raise TypeError("Missing 'disk_type' argument")
        if enable_auto_snapshot is None and 'enableAutoSnapshot' in kwargs:
            enable_auto_snapshot = kwargs['enableAutoSnapshot']
        if enable_auto_snapshot is None:
            raise TypeError("Missing 'enable_auto_snapshot' argument")
        if enable_automated_snapshot_policy is None and 'enableAutomatedSnapshotPolicy' in kwargs:
            enable_automated_snapshot_policy = kwargs['enableAutomatedSnapshotPolicy']
        if enable_automated_snapshot_policy is None:
            raise TypeError("Missing 'enable_automated_snapshot_policy' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if iops_read is None and 'iopsRead' in kwargs:
            iops_read = kwargs['iopsRead']
        if iops_read is None:
            raise TypeError("Missing 'iops_read' argument")
        if iops_write is None and 'iopsWrite' in kwargs:
            iops_write = kwargs['iopsWrite']
        if iops_write is None:
            raise TypeError("Missing 'iops_write' argument")
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")
        if mount_instance_num is None and 'mountInstanceNum' in kwargs:
            mount_instance_num = kwargs['mountInstanceNum']
        if mount_instance_num is None:
            raise TypeError("Missing 'mount_instance_num' argument")
        if mount_instances is None and 'mountInstances' in kwargs:
            mount_instances = kwargs['mountInstances']
        if mount_instances is None:
            raise TypeError("Missing 'mount_instances' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if operation_locks is None and 'operationLocks' in kwargs:
            operation_locks = kwargs['operationLocks']
        if operation_locks is None:
            raise TypeError("Missing 'operation_locks' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if performance_level is None:
            raise TypeError("Missing 'performance_level' argument")
        if portable is None:
            raise TypeError("Missing 'portable' argument")
        if product_code is None and 'productCode' in kwargs:
            product_code = kwargs['productCode']
        if product_code is None:
            raise TypeError("Missing 'product_code' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("attached_time", attached_time)
        _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        _setter("availability_zone", availability_zone)
        _setter("category", category)
        _setter("creation_time", creation_time)
        _setter("delete_auto_snapshot", delete_auto_snapshot)
        _setter("delete_with_instance", delete_with_instance)
        _setter("description", description)
        _setter("detached_time", detached_time)
        _setter("device", device)
        _setter("disk_id", disk_id)
        _setter("disk_name", disk_name)
        _setter("disk_type", disk_type)
        _setter("enable_auto_snapshot", enable_auto_snapshot)
        _setter("enable_automated_snapshot_policy", enable_automated_snapshot_policy)
        _setter("encrypted", encrypted)
        _setter("expired_time", expired_time)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("instance_id", instance_id)
        _setter("iops", iops)
        _setter("iops_read", iops_read)
        _setter("iops_write", iops_write)
        _setter("kms_key_id", kms_key_id)
        _setter("mount_instance_num", mount_instance_num)
        _setter("mount_instances", mount_instances)
        _setter("name", name)
        _setter("operation_locks", operation_locks)
        _setter("payment_type", payment_type)
        _setter("performance_level", performance_level)
        _setter("portable", portable)
        _setter("product_code", product_code)
        _setter("region_id", region_id)
        _setter("resource_group_id", resource_group_id)
        _setter("size", size)
        _setter("snapshot_id", snapshot_id)
        _setter("status", status)
        _setter("tags", tags)
        _setter("type", type)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="attachedTime")
    def attached_time(self) -> str:
        """
        A mount of time.
        """
        return pulumi.get(self, "attached_time")

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> str:
        """
        Query cloud disks based on the automatic snapshot policy ID.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        Availability zone of the disk.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Disk category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Disk creation time.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="deleteAutoSnapshot")
    def delete_auto_snapshot(self) -> bool:
        """
        Indicates whether the automatic snapshot is deleted when the disk is released.
        """
        return pulumi.get(self, "delete_auto_snapshot")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> bool:
        """
        Indicates whether the disk is released together with the instance.
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Disk description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="detachedTime")
    def detached_time(self) -> str:
        """
        Disk detachment time.
        """
        return pulumi.get(self, "detached_time")

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        The mount point of the disk.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        ID of the disk.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        The disk name.
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        """
        The disk type.
        """
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter(name="enableAutoSnapshot")
    def enable_auto_snapshot(self) -> bool:
        """
        Whether the disk implements an automatic snapshot policy.
        """
        return pulumi.get(self, "enable_auto_snapshot")

    @property
    @pulumi.getter(name="enableAutomatedSnapshotPolicy")
    def enable_automated_snapshot_policy(self) -> bool:
        """
        Whether the disk implements an automatic snapshot policy.
        """
        return pulumi.get(self, "enable_automated_snapshot_policy")

    @property
    @pulumi.getter
    def encrypted(self) -> str:
        """
        Indicate whether the disk is encrypted or not.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the disk.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        ID of the image from which the disk is created. It is null unless the disk is created using an image.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The instance ID of the disk mount.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def iops(self) -> int:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="iopsRead")
    def iops_read(self) -> int:
        return pulumi.get(self, "iops_read")

    @property
    @pulumi.getter(name="iopsWrite")
    def iops_write(self) -> int:
        return pulumi.get(self, "iops_write")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The kms key id.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="mountInstanceNum")
    def mount_instance_num(self) -> int:
        """
        Number of instances mounted on shared storage.
        """
        return pulumi.get(self, "mount_instance_num")

    @property
    @pulumi.getter(name="mountInstances")
    def mount_instances(self) -> Sequence['outputs.GetEcsDisksDiskMountInstanceResult']:
        """
        Disk mount instances.
        """
        return pulumi.get(self, "mount_instances")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Disk name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationLocks")
    def operation_locks(self) -> Sequence['outputs.GetEcsDisksDiskOperationLockResult']:
        return pulumi.get(self, "operation_locks")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        """
        Payment method for disk.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> str:
        """
        Performance levels of ESSD cloud disk.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def portable(self) -> bool:
        """
        Whether the disk is unmountable.
        """
        return pulumi.get(self, "portable")

    @property
    @pulumi.getter(name="productCode")
    def product_code(self) -> str:
        """
        The product logo of the cloud market.
        """
        return pulumi.get(self, "product_code")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        Region ID the disk belongs to.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Disk size in GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Snapshot used to create the disk. It is null if no snapshot is used to create the disk.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the disk.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Disk type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The zone id.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetEcsDisksDiskMountInstanceResult(dict):
    def __init__(__self__, *,
                 attached_time: str,
                 device: str,
                 instance_id: str):
        """
        :param str attached_time: A mount of time.
        :param str device: The mount point of the disk.
        :param str instance_id: The instance ID of the disk mount.
        """
        GetEcsDisksDiskMountInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attached_time=attached_time,
            device=device,
            instance_id=instance_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attached_time: Optional[str] = None,
             device: Optional[str] = None,
             instance_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attached_time is None and 'attachedTime' in kwargs:
            attached_time = kwargs['attachedTime']
        if attached_time is None:
            raise TypeError("Missing 'attached_time' argument")
        if device is None:
            raise TypeError("Missing 'device' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")

        _setter("attached_time", attached_time)
        _setter("device", device)
        _setter("instance_id", instance_id)

    @property
    @pulumi.getter(name="attachedTime")
    def attached_time(self) -> str:
        """
        A mount of time.
        """
        return pulumi.get(self, "attached_time")

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        The mount point of the disk.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The instance ID of the disk mount.
        """
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class GetEcsDisksDiskOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: str):
        GetEcsDisksDiskOperationLockResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']
        if lock_reason is None:
            raise TypeError("Missing 'lock_reason' argument")

        _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> str:
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetEcsDisksOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: Optional[str] = None):
        GetEcsDisksOperationLockResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lock_reason=lock_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lock_reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lock_reason is None and 'lockReason' in kwargs:
            lock_reason = kwargs['lockReason']

        if lock_reason is not None:
            _setter("lock_reason", lock_reason)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> Optional[str]:
        return pulumi.get(self, "lock_reason")


@pulumi.output_type
class GetEcsImageComponentsComponentResult(dict):
    def __init__(__self__, *,
                 component_type: str,
                 content: str,
                 create_time: str,
                 description: str,
                 id: str,
                 image_component_id: str,
                 image_component_name: str,
                 owner: str,
                 resource_group_id: str,
                 system_type: str,
                 tags: Mapping[str, Any]):
        """
        :param str component_type: The type of the image component.
        :param str content: The content of the image component.
        :param str create_time: The time when the image component was created.
        :param str description: The description of the image component.
        :param str id: The ID of the Image Component.
        :param str image_component_id: The ID of the image component.
        :param str image_component_name: The name of the image component.
        :param str owner: The type of the image component.
        :param str resource_group_id: The ID of the resource group.
        :param str system_type: The operating system type supported by the image component.
        :param Mapping[str, Any] tags: List of label key-value pairs.
        """
        GetEcsImageComponentsComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            component_type=component_type,
            content=content,
            create_time=create_time,
            description=description,
            id=id,
            image_component_id=image_component_id,
            image_component_name=image_component_name,
            owner=owner,
            resource_group_id=resource_group_id,
            system_type=system_type,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             component_type: Optional[str] = None,
             content: Optional[str] = None,
             create_time: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             image_component_id: Optional[str] = None,
             image_component_name: Optional[str] = None,
             owner: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             system_type: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if component_type is None and 'componentType' in kwargs:
            component_type = kwargs['componentType']
        if component_type is None:
            raise TypeError("Missing 'component_type' argument")
        if content is None:
            raise TypeError("Missing 'content' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_component_id is None and 'imageComponentId' in kwargs:
            image_component_id = kwargs['imageComponentId']
        if image_component_id is None:
            raise TypeError("Missing 'image_component_id' argument")
        if image_component_name is None and 'imageComponentName' in kwargs:
            image_component_name = kwargs['imageComponentName']
        if image_component_name is None:
            raise TypeError("Missing 'image_component_name' argument")
        if owner is None:
            raise TypeError("Missing 'owner' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if system_type is None and 'systemType' in kwargs:
            system_type = kwargs['systemType']
        if system_type is None:
            raise TypeError("Missing 'system_type' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("component_type", component_type)
        _setter("content", content)
        _setter("create_time", create_time)
        _setter("description", description)
        _setter("id", id)
        _setter("image_component_id", image_component_id)
        _setter("image_component_name", image_component_name)
        _setter("owner", owner)
        _setter("resource_group_id", resource_group_id)
        _setter("system_type", system_type)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="componentType")
    def component_type(self) -> str:
        """
        The type of the image component.
        """
        return pulumi.get(self, "component_type")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the image component.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time when the image component was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the image component.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Image Component.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageComponentId")
    def image_component_id(self) -> str:
        """
        The ID of the image component.
        """
        return pulumi.get(self, "image_component_id")

    @property
    @pulumi.getter(name="imageComponentName")
    def image_component_name(self) -> str:
        """
        The name of the image component.
        """
        return pulumi.get(self, "image_component_name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        The type of the image component.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="systemType")
    def system_type(self) -> str:
        """
        The operating system type supported by the image component.
        """
        return pulumi.get(self, "system_type")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        List of label key-value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEcsImagePipelinePipelineResult(dict):
    def __init__(__self__, *,
                 add_accounts: Sequence[str],
                 base_image: str,
                 base_image_type: str,
                 build_content: str,
                 creation_time: str,
                 delete_instance_on_failure: bool,
                 description: str,
                 id: str,
                 image_name: str,
                 image_pipeline_id: str,
                 instance_type: str,
                 internet_max_bandwidth_out: int,
                 name: str,
                 resource_group_id: str,
                 system_disk_size: int,
                 to_region_ids: Sequence[str],
                 vswitch_id: str,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param Sequence[str] add_accounts: The IDs of Alibaba Cloud accounts to which the image was shared.
        :param str base_image: The source image.
        :param str base_image_type: The type of the source image.
        :param str build_content: The content of the image template.
        :param str creation_time: The time when the image template was created.
        :param bool delete_instance_on_failure: Indicates whether the intermediate instance was released when the image failed to be created.
        :param str description: The description of the image template.
        :param str id: The ID of the Image Pipeline.
        :param str image_name: The name prefix of the created image.
        :param str image_pipeline_id: The ID of the image template.
        :param str instance_type: The instance type of the intermediate instance.
        :param int internet_max_bandwidth_out: The size of the outbound public bandwidth for the intermediate instance. Unit: `Mbit/s`.
        :param str name: The name of the image template.
        :param str resource_group_id: The ID of the resource group to which the image template belongs.
        :param int system_disk_size: The system disk size of the intermediate instance. Unit: `GiB`.
        :param Sequence[str] to_region_ids: The IDs of regions to which to distribute the created image.
        :param str vswitch_id: The vswitch id.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetEcsImagePipelinePipelineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add_accounts=add_accounts,
            base_image=base_image,
            base_image_type=base_image_type,
            build_content=build_content,
            creation_time=creation_time,
            delete_instance_on_failure=delete_instance_on_failure,
            description=description,
            id=id,
            image_name=image_name,
            image_pipeline_id=image_pipeline_id,
            instance_type=instance_type,
            internet_max_bandwidth_out=internet_max_bandwidth_out,
            name=name,
            resource_group_id=resource_group_id,
            system_disk_size=system_disk_size,
            to_region_ids=to_region_ids,
            vswitch_id=vswitch_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add_accounts: Optional[Sequence[str]] = None,
             base_image: Optional[str] = None,
             base_image_type: Optional[str] = None,
             build_content: Optional[str] = None,
             creation_time: Optional[str] = None,
             delete_instance_on_failure: Optional[bool] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             image_name: Optional[str] = None,
             image_pipeline_id: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_max_bandwidth_out: Optional[int] = None,
             name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             system_disk_size: Optional[int] = None,
             to_region_ids: Optional[Sequence[str]] = None,
             vswitch_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if add_accounts is None and 'addAccounts' in kwargs:
            add_accounts = kwargs['addAccounts']
        if add_accounts is None:
            raise TypeError("Missing 'add_accounts' argument")
        if base_image is None and 'baseImage' in kwargs:
            base_image = kwargs['baseImage']
        if base_image is None:
            raise TypeError("Missing 'base_image' argument")
        if base_image_type is None and 'baseImageType' in kwargs:
            base_image_type = kwargs['baseImageType']
        if base_image_type is None:
            raise TypeError("Missing 'base_image_type' argument")
        if build_content is None and 'buildContent' in kwargs:
            build_content = kwargs['buildContent']
        if build_content is None:
            raise TypeError("Missing 'build_content' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if delete_instance_on_failure is None and 'deleteInstanceOnFailure' in kwargs:
            delete_instance_on_failure = kwargs['deleteInstanceOnFailure']
        if delete_instance_on_failure is None:
            raise TypeError("Missing 'delete_instance_on_failure' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_name is None and 'imageName' in kwargs:
            image_name = kwargs['imageName']
        if image_name is None:
            raise TypeError("Missing 'image_name' argument")
        if image_pipeline_id is None and 'imagePipelineId' in kwargs:
            image_pipeline_id = kwargs['imagePipelineId']
        if image_pipeline_id is None:
            raise TypeError("Missing 'image_pipeline_id' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_max_bandwidth_out is None and 'internetMaxBandwidthOut' in kwargs:
            internet_max_bandwidth_out = kwargs['internetMaxBandwidthOut']
        if internet_max_bandwidth_out is None:
            raise TypeError("Missing 'internet_max_bandwidth_out' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if system_disk_size is None and 'systemDiskSize' in kwargs:
            system_disk_size = kwargs['systemDiskSize']
        if system_disk_size is None:
            raise TypeError("Missing 'system_disk_size' argument")
        if to_region_ids is None and 'toRegionIds' in kwargs:
            to_region_ids = kwargs['toRegionIds']
        if to_region_ids is None:
            raise TypeError("Missing 'to_region_ids' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("add_accounts", add_accounts)
        _setter("base_image", base_image)
        _setter("base_image_type", base_image_type)
        _setter("build_content", build_content)
        _setter("creation_time", creation_time)
        _setter("delete_instance_on_failure", delete_instance_on_failure)
        _setter("description", description)
        _setter("id", id)
        _setter("image_name", image_name)
        _setter("image_pipeline_id", image_pipeline_id)
        _setter("instance_type", instance_type)
        _setter("internet_max_bandwidth_out", internet_max_bandwidth_out)
        _setter("name", name)
        _setter("resource_group_id", resource_group_id)
        _setter("system_disk_size", system_disk_size)
        _setter("to_region_ids", to_region_ids)
        _setter("vswitch_id", vswitch_id)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="addAccounts")
    def add_accounts(self) -> Sequence[str]:
        """
        The IDs of Alibaba Cloud accounts to which the image was shared.
        """
        return pulumi.get(self, "add_accounts")

    @property
    @pulumi.getter(name="baseImage")
    def base_image(self) -> str:
        """
        The source image.
        """
        return pulumi.get(self, "base_image")

    @property
    @pulumi.getter(name="baseImageType")
    def base_image_type(self) -> str:
        """
        The type of the source image.
        """
        return pulumi.get(self, "base_image_type")

    @property
    @pulumi.getter(name="buildContent")
    def build_content(self) -> str:
        """
        The content of the image template.
        """
        return pulumi.get(self, "build_content")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        The time when the image template was created.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="deleteInstanceOnFailure")
    def delete_instance_on_failure(self) -> bool:
        """
        Indicates whether the intermediate instance was released when the image failed to be created.
        """
        return pulumi.get(self, "delete_instance_on_failure")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the image template.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Image Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        The name prefix of the created image.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePipelineId")
    def image_pipeline_id(self) -> str:
        """
        The ID of the image template.
        """
        return pulumi.get(self, "image_pipeline_id")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The instance type of the intermediate instance.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> int:
        """
        The size of the outbound public bandwidth for the intermediate instance. Unit: `Mbit/s`.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the image template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group to which the image template belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="systemDiskSize")
    def system_disk_size(self) -> int:
        """
        The system disk size of the intermediate instance. Unit: `GiB`.
        """
        return pulumi.get(self, "system_disk_size")

    @property
    @pulumi.getter(name="toRegionIds")
    def to_region_ids(self) -> Sequence[str]:
        """
        The IDs of regions to which to distribute the created image.
        """
        return pulumi.get(self, "to_region_ids")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The vswitch id.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEcsInvocationsInvocationResult(dict):
    def __init__(__self__, *,
                 command_content: str,
                 command_id: str,
                 command_name: str,
                 command_type: str,
                 create_time: str,
                 frequency: str,
                 id: str,
                 invocation_id: str,
                 invocation_status: str,
                 invoke_instances: Sequence['outputs.GetEcsInvocationsInvocationInvokeInstanceResult'],
                 invoke_status: str,
                 parameters: str,
                 repeat_mode: str,
                 timed: bool,
                 username: str):
        """
        :param str command_content: The Base64-encoded command content.
        :param str command_id: The ID of the command.
        :param str command_name: The name of the command.
        :param str command_type: The type of the command.
        :param str create_time: The creation time of the resource.
        :param str frequency: The schedule on which the recurring execution of the command takes place. For information about the value specifications, see [Cron expression](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/cron-expression).
        :param str id: The ID of the Invocation.
        :param str invocation_id: The ID of the Invocation.
        :param str invocation_status: The execution state on a single instance. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopping`, `Stopped`, `PartialFailed`.
        :param Sequence['GetEcsInvocationsInvocationInvokeInstanceArgs'] invoke_instances: Execute target instance set type.
        :param str invoke_status: The overall execution state of the command. **Note:** We recommend that you ignore this parameter and check the value of the `invocation_status` response parameter for the overall execution state.
        :param str parameters: The custom parameters in the command.
        :param str repeat_mode: Indicates the execution mode of the command.
        :param bool timed: Indicates whether the commands are to be automatically run.
               * `error_code	` - The code that indicates why the command failed to be sent or run.
               * `instance_invoke_status	` - **Note:** We recommend that you ignore this parameter and check the value of the `invocation_status` response parameter for the overall execution state.
        :param str username: The username that was used to run the command on the instance.
        """
        GetEcsInvocationsInvocationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command_content=command_content,
            command_id=command_id,
            command_name=command_name,
            command_type=command_type,
            create_time=create_time,
            frequency=frequency,
            id=id,
            invocation_id=invocation_id,
            invocation_status=invocation_status,
            invoke_instances=invoke_instances,
            invoke_status=invoke_status,
            parameters=parameters,
            repeat_mode=repeat_mode,
            timed=timed,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command_content: Optional[str] = None,
             command_id: Optional[str] = None,
             command_name: Optional[str] = None,
             command_type: Optional[str] = None,
             create_time: Optional[str] = None,
             frequency: Optional[str] = None,
             id: Optional[str] = None,
             invocation_id: Optional[str] = None,
             invocation_status: Optional[str] = None,
             invoke_instances: Optional[Sequence['outputs.GetEcsInvocationsInvocationInvokeInstanceResult']] = None,
             invoke_status: Optional[str] = None,
             parameters: Optional[str] = None,
             repeat_mode: Optional[str] = None,
             timed: Optional[bool] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command_content is None and 'commandContent' in kwargs:
            command_content = kwargs['commandContent']
        if command_content is None:
            raise TypeError("Missing 'command_content' argument")
        if command_id is None and 'commandId' in kwargs:
            command_id = kwargs['commandId']
        if command_id is None:
            raise TypeError("Missing 'command_id' argument")
        if command_name is None and 'commandName' in kwargs:
            command_name = kwargs['commandName']
        if command_name is None:
            raise TypeError("Missing 'command_name' argument")
        if command_type is None and 'commandType' in kwargs:
            command_type = kwargs['commandType']
        if command_type is None:
            raise TypeError("Missing 'command_type' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if frequency is None:
            raise TypeError("Missing 'frequency' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if invocation_id is None and 'invocationId' in kwargs:
            invocation_id = kwargs['invocationId']
        if invocation_id is None:
            raise TypeError("Missing 'invocation_id' argument")
        if invocation_status is None and 'invocationStatus' in kwargs:
            invocation_status = kwargs['invocationStatus']
        if invocation_status is None:
            raise TypeError("Missing 'invocation_status' argument")
        if invoke_instances is None and 'invokeInstances' in kwargs:
            invoke_instances = kwargs['invokeInstances']
        if invoke_instances is None:
            raise TypeError("Missing 'invoke_instances' argument")
        if invoke_status is None and 'invokeStatus' in kwargs:
            invoke_status = kwargs['invokeStatus']
        if invoke_status is None:
            raise TypeError("Missing 'invoke_status' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if repeat_mode is None and 'repeatMode' in kwargs:
            repeat_mode = kwargs['repeatMode']
        if repeat_mode is None:
            raise TypeError("Missing 'repeat_mode' argument")
        if timed is None:
            raise TypeError("Missing 'timed' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("command_content", command_content)
        _setter("command_id", command_id)
        _setter("command_name", command_name)
        _setter("command_type", command_type)
        _setter("create_time", create_time)
        _setter("frequency", frequency)
        _setter("id", id)
        _setter("invocation_id", invocation_id)
        _setter("invocation_status", invocation_status)
        _setter("invoke_instances", invoke_instances)
        _setter("invoke_status", invoke_status)
        _setter("parameters", parameters)
        _setter("repeat_mode", repeat_mode)
        _setter("timed", timed)
        _setter("username", username)

    @property
    @pulumi.getter(name="commandContent")
    def command_content(self) -> str:
        """
        The Base64-encoded command content.
        """
        return pulumi.get(self, "command_content")

    @property
    @pulumi.getter(name="commandId")
    def command_id(self) -> str:
        """
        The ID of the command.
        """
        return pulumi.get(self, "command_id")

    @property
    @pulumi.getter(name="commandName")
    def command_name(self) -> str:
        """
        The name of the command.
        """
        return pulumi.get(self, "command_name")

    @property
    @pulumi.getter(name="commandType")
    def command_type(self) -> str:
        """
        The type of the command.
        """
        return pulumi.get(self, "command_type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        The schedule on which the recurring execution of the command takes place. For information about the value specifications, see [Cron expression](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/cron-expression).
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Invocation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="invocationId")
    def invocation_id(self) -> str:
        """
        The ID of the Invocation.
        """
        return pulumi.get(self, "invocation_id")

    @property
    @pulumi.getter(name="invocationStatus")
    def invocation_status(self) -> str:
        """
        The execution state on a single instance. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopping`, `Stopped`, `PartialFailed`.
        """
        return pulumi.get(self, "invocation_status")

    @property
    @pulumi.getter(name="invokeInstances")
    def invoke_instances(self) -> Sequence['outputs.GetEcsInvocationsInvocationInvokeInstanceResult']:
        """
        Execute target instance set type.
        """
        return pulumi.get(self, "invoke_instances")

    @property
    @pulumi.getter(name="invokeStatus")
    def invoke_status(self) -> str:
        """
        The overall execution state of the command. **Note:** We recommend that you ignore this parameter and check the value of the `invocation_status` response parameter for the overall execution state.
        """
        return pulumi.get(self, "invoke_status")

    @property
    @pulumi.getter
    def parameters(self) -> str:
        """
        The custom parameters in the command.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="repeatMode")
    def repeat_mode(self) -> str:
        """
        Indicates the execution mode of the command.
        """
        return pulumi.get(self, "repeat_mode")

    @property
    @pulumi.getter
    def timed(self) -> bool:
        """
        Indicates whether the commands are to be automatically run.
        * `error_code	` - The code that indicates why the command failed to be sent or run.
        * `instance_invoke_status	` - **Note:** We recommend that you ignore this parameter and check the value of the `invocation_status` response parameter for the overall execution state.
        """
        return pulumi.get(self, "timed")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that was used to run the command on the instance.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetEcsInvocationsInvocationInvokeInstanceResult(dict):
    def __init__(__self__, *,
                 creation_time: str,
                 dropped: int,
                 error_code: str,
                 error_info: str,
                 exit_code: int,
                 finish_time: str,
                 instance_id: str,
                 instance_invoke_status: str,
                 invocation_status: str,
                 output: str,
                 repeats: int,
                 start_time: str,
                 stop_time: str,
                 timed: bool,
                 update_time: str):
        """
        :param str creation_time: The start time of the execution.
        :param int dropped: The size of truncated and discarded text when the value of the Output response parameter exceeds 24 KB in size.
        :param str error_info: Details about the reason why the command failed to be sent or run.
        :param int exit_code: The exit code of the execution.
        :param str finish_time: The end time of the execution.
        :param str instance_id: The ID of the instance.
        :param str invocation_status: The execution state on a single instance. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopping`, `Stopped`, `PartialFailed`.
        :param str output: The output of the command.
        :param int repeats: The number of times that the command is run on the instance.
        :param str start_time: The time when the command started to be run on the instance.
        :param str stop_time: The time when the command stopped being run on the instance. If you call the StopInvocation operation to manually stop the execution, the value is the time when you call the operation.
        :param bool timed: Indicates whether the commands are to be automatically run.
               * `error_code	` - The code that indicates why the command failed to be sent or run.
               * `instance_invoke_status	` - **Note:** We recommend that you ignore this parameter and check the value of the `invocation_status` response parameter for the overall execution state.
        :param str update_time: The time when the execution state was updated.
        """
        GetEcsInvocationsInvocationInvokeInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_time=creation_time,
            dropped=dropped,
            error_code=error_code,
            error_info=error_info,
            exit_code=exit_code,
            finish_time=finish_time,
            instance_id=instance_id,
            instance_invoke_status=instance_invoke_status,
            invocation_status=invocation_status,
            output=output,
            repeats=repeats,
            start_time=start_time,
            stop_time=stop_time,
            timed=timed,
            update_time=update_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_time: Optional[str] = None,
             dropped: Optional[int] = None,
             error_code: Optional[str] = None,
             error_info: Optional[str] = None,
             exit_code: Optional[int] = None,
             finish_time: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_invoke_status: Optional[str] = None,
             invocation_status: Optional[str] = None,
             output: Optional[str] = None,
             repeats: Optional[int] = None,
             start_time: Optional[str] = None,
             stop_time: Optional[str] = None,
             timed: Optional[bool] = None,
             update_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if dropped is None:
            raise TypeError("Missing 'dropped' argument")
        if error_code is None and 'errorCode' in kwargs:
            error_code = kwargs['errorCode']
        if error_code is None:
            raise TypeError("Missing 'error_code' argument")
        if error_info is None and 'errorInfo' in kwargs:
            error_info = kwargs['errorInfo']
        if error_info is None:
            raise TypeError("Missing 'error_info' argument")
        if exit_code is None and 'exitCode' in kwargs:
            exit_code = kwargs['exitCode']
        if exit_code is None:
            raise TypeError("Missing 'exit_code' argument")
        if finish_time is None and 'finishTime' in kwargs:
            finish_time = kwargs['finishTime']
        if finish_time is None:
            raise TypeError("Missing 'finish_time' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_invoke_status is None and 'instanceInvokeStatus' in kwargs:
            instance_invoke_status = kwargs['instanceInvokeStatus']
        if instance_invoke_status is None:
            raise TypeError("Missing 'instance_invoke_status' argument")
        if invocation_status is None and 'invocationStatus' in kwargs:
            invocation_status = kwargs['invocationStatus']
        if invocation_status is None:
            raise TypeError("Missing 'invocation_status' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if repeats is None:
            raise TypeError("Missing 'repeats' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if stop_time is None and 'stopTime' in kwargs:
            stop_time = kwargs['stopTime']
        if stop_time is None:
            raise TypeError("Missing 'stop_time' argument")
        if timed is None:
            raise TypeError("Missing 'timed' argument")
        if update_time is None and 'updateTime' in kwargs:
            update_time = kwargs['updateTime']
        if update_time is None:
            raise TypeError("Missing 'update_time' argument")

        _setter("creation_time", creation_time)
        _setter("dropped", dropped)
        _setter("error_code", error_code)
        _setter("error_info", error_info)
        _setter("exit_code", exit_code)
        _setter("finish_time", finish_time)
        _setter("instance_id", instance_id)
        _setter("instance_invoke_status", instance_invoke_status)
        _setter("invocation_status", invocation_status)
        _setter("output", output)
        _setter("repeats", repeats)
        _setter("start_time", start_time)
        _setter("stop_time", stop_time)
        _setter("timed", timed)
        _setter("update_time", update_time)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        The start time of the execution.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def dropped(self) -> int:
        """
        The size of truncated and discarded text when the value of the Output response parameter exceeds 24 KB in size.
        """
        return pulumi.get(self, "dropped")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> str:
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorInfo")
    def error_info(self) -> str:
        """
        Details about the reason why the command failed to be sent or run.
        """
        return pulumi.get(self, "error_info")

    @property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> int:
        """
        The exit code of the execution.
        """
        return pulumi.get(self, "exit_code")

    @property
    @pulumi.getter(name="finishTime")
    def finish_time(self) -> str:
        """
        The end time of the execution.
        """
        return pulumi.get(self, "finish_time")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceInvokeStatus")
    def instance_invoke_status(self) -> str:
        return pulumi.get(self, "instance_invoke_status")

    @property
    @pulumi.getter(name="invocationStatus")
    def invocation_status(self) -> str:
        """
        The execution state on a single instance. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopping`, `Stopped`, `PartialFailed`.
        """
        return pulumi.get(self, "invocation_status")

    @property
    @pulumi.getter
    def output(self) -> str:
        """
        The output of the command.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def repeats(self) -> int:
        """
        The number of times that the command is run on the instance.
        """
        return pulumi.get(self, "repeats")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The time when the command started to be run on the instance.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="stopTime")
    def stop_time(self) -> str:
        """
        The time when the command stopped being run on the instance. If you call the StopInvocation operation to manually stop the execution, the value is the time when you call the operation.
        """
        return pulumi.get(self, "stop_time")

    @property
    @pulumi.getter
    def timed(self) -> bool:
        """
        Indicates whether the commands are to be automatically run.
        * `error_code	` - The code that indicates why the command failed to be sent or run.
        * `instance_invoke_status	` - **Note:** We recommend that you ignore this parameter and check the value of the `invocation_status` response parameter for the overall execution state.
        """
        return pulumi.get(self, "timed")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        The time when the execution state was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetEcsKeyPairsKeyPairResult(dict):
    def __init__(__self__, *,
                 finger_print: str,
                 id: str,
                 instances: Sequence['outputs.GetEcsKeyPairsKeyPairInstanceResult'],
                 key_name: str,
                 key_pair_name: str,
                 resource_group_id: str,
                 tags: Mapping[str, Any]):
        """
        :param str finger_print: The finger print of the key pair.
        :param str id: The ID of the Key Pair.
        :param Sequence['GetEcsKeyPairsKeyPairInstanceArgs'] instances: A list of ECS instances that has been bound this key pair.
        :param str key_name: The Key Pair Name.
        :param str resource_group_id: The Resource Group Id.
        :param Mapping[str, Any] tags: The tags.
        """
        GetEcsKeyPairsKeyPairResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            finger_print=finger_print,
            id=id,
            instances=instances,
            key_name=key_name,
            key_pair_name=key_pair_name,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             finger_print: Optional[str] = None,
             id: Optional[str] = None,
             instances: Optional[Sequence['outputs.GetEcsKeyPairsKeyPairInstanceResult']] = None,
             key_name: Optional[str] = None,
             key_pair_name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if finger_print is None and 'fingerPrint' in kwargs:
            finger_print = kwargs['fingerPrint']
        if finger_print is None:
            raise TypeError("Missing 'finger_print' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instances is None:
            raise TypeError("Missing 'instances' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if key_pair_name is None and 'keyPairName' in kwargs:
            key_pair_name = kwargs['keyPairName']
        if key_pair_name is None:
            raise TypeError("Missing 'key_pair_name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("finger_print", finger_print)
        _setter("id", id)
        _setter("instances", instances)
        _setter("key_name", key_name)
        _setter("key_pair_name", key_pair_name)
        _setter("resource_group_id", resource_group_id)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="fingerPrint")
    def finger_print(self) -> str:
        """
        The finger print of the key pair.
        """
        return pulumi.get(self, "finger_print")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Key Pair.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetEcsKeyPairsKeyPairInstanceResult']:
        """
        A list of ECS instances that has been bound this key pair.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The Key Pair Name.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> str:
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Resource Group Id.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEcsKeyPairsKeyPairInstanceResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 description: str,
                 image_id: str,
                 instance_id: str,
                 instance_name: str,
                 instance_type: str,
                 key_name: str,
                 private_ip: str,
                 public_ip: str,
                 region_id: str,
                 status: str,
                 vswitch_id: str):
        """
        :param str availability_zone: The ID of the availability zone where the ECS instance is located.
        :param str instance_id: The ID of the ECS instance.
        :param str instance_name: The name of the ECS instance.
        :param str key_name: The Key Pair Name.
        :param str private_ip: The private IP address of the ECS instance.
        :param str public_ip: The public IP address or EIP of the ECS instance.
        :param str vswitch_id: The ID of the VSwitch attached to the ECS instance.
        """
        GetEcsKeyPairsKeyPairInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            description=description,
            image_id=image_id,
            instance_id=instance_id,
            instance_name=instance_name,
            instance_type=instance_type,
            key_name=key_name,
            private_ip=private_ip,
            public_ip=public_ip,
            region_id=region_id,
            status=status,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             description: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_name: Optional[str] = None,
             instance_type: Optional[str] = None,
             key_name: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_ip: Optional[str] = None,
             region_id: Optional[str] = None,
             status: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("availability_zone", availability_zone)
        _setter("description", description)
        _setter("image_id", image_id)
        _setter("instance_id", instance_id)
        _setter("instance_name", instance_name)
        _setter("instance_type", instance_type)
        _setter("key_name", key_name)
        _setter("private_ip", private_ip)
        _setter("public_ip", public_ip)
        _setter("region_id", region_id)
        _setter("status", status)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of the availability zone where the ECS instance is located.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The name of the ECS instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The Key Pair Name.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of the ECS instance.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address or EIP of the ECS instance.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch attached to the ECS instance.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetEcsKeyPairsPairResult(dict):
    def __init__(__self__, *,
                 finger_print: str,
                 id: str,
                 instances: Sequence['outputs.GetEcsKeyPairsPairInstanceResult'],
                 key_name: str,
                 key_pair_name: str,
                 resource_group_id: str,
                 tags: Mapping[str, Any]):
        """
        :param str finger_print: The finger print of the key pair.
        :param str id: The ID of the Key Pair.
        :param Sequence['GetEcsKeyPairsPairInstanceArgs'] instances: A list of ECS instances that has been bound this key pair.
        :param str key_name: The Key Pair Name.
        :param str resource_group_id: The Resource Group Id.
        :param Mapping[str, Any] tags: The tags.
        """
        GetEcsKeyPairsPairResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            finger_print=finger_print,
            id=id,
            instances=instances,
            key_name=key_name,
            key_pair_name=key_pair_name,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             finger_print: Optional[str] = None,
             id: Optional[str] = None,
             instances: Optional[Sequence['outputs.GetEcsKeyPairsPairInstanceResult']] = None,
             key_name: Optional[str] = None,
             key_pair_name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if finger_print is None and 'fingerPrint' in kwargs:
            finger_print = kwargs['fingerPrint']
        if finger_print is None:
            raise TypeError("Missing 'finger_print' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instances is None:
            raise TypeError("Missing 'instances' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if key_pair_name is None and 'keyPairName' in kwargs:
            key_pair_name = kwargs['keyPairName']
        if key_pair_name is None:
            raise TypeError("Missing 'key_pair_name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("finger_print", finger_print)
        _setter("id", id)
        _setter("instances", instances)
        _setter("key_name", key_name)
        _setter("key_pair_name", key_pair_name)
        _setter("resource_group_id", resource_group_id)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="fingerPrint")
    def finger_print(self) -> str:
        """
        The finger print of the key pair.
        """
        return pulumi.get(self, "finger_print")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Key Pair.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetEcsKeyPairsPairInstanceResult']:
        """
        A list of ECS instances that has been bound this key pair.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The Key Pair Name.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> str:
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Resource Group Id.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEcsKeyPairsPairInstanceResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 description: str,
                 image_id: str,
                 instance_id: str,
                 instance_name: str,
                 instance_type: str,
                 key_name: str,
                 private_ip: str,
                 public_ip: str,
                 region_id: str,
                 status: str,
                 vswitch_id: str):
        """
        :param str availability_zone: The ID of the availability zone where the ECS instance is located.
        :param str instance_id: The ID of the ECS instance.
        :param str instance_name: The name of the ECS instance.
        :param str key_name: The Key Pair Name.
        :param str private_ip: The private IP address of the ECS instance.
        :param str public_ip: The public IP address or EIP of the ECS instance.
        :param str vswitch_id: The ID of the VSwitch attached to the ECS instance.
        """
        GetEcsKeyPairsPairInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            description=description,
            image_id=image_id,
            instance_id=instance_id,
            instance_name=instance_name,
            instance_type=instance_type,
            key_name=key_name,
            private_ip=private_ip,
            public_ip=public_ip,
            region_id=region_id,
            status=status,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             description: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_name: Optional[str] = None,
             instance_type: Optional[str] = None,
             key_name: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_ip: Optional[str] = None,
             region_id: Optional[str] = None,
             status: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("availability_zone", availability_zone)
        _setter("description", description)
        _setter("image_id", image_id)
        _setter("instance_id", instance_id)
        _setter("instance_name", instance_name)
        _setter("instance_type", instance_type)
        _setter("key_name", key_name)
        _setter("private_ip", private_ip)
        _setter("public_ip", public_ip)
        _setter("region_id", region_id)
        _setter("status", status)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of the availability zone where the ECS instance is located.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The name of the ECS instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The Key Pair Name.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of the ECS instance.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address or EIP of the ECS instance.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch attached to the ECS instance.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetEcsLaunchTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 auto_release_time: str,
                 created_by: str,
                 data_disks: Sequence['outputs.GetEcsLaunchTemplatesTemplateDataDiskResult'],
                 default_version_number: int,
                 deployment_set_id: str,
                 description: str,
                 enable_vm_os_config: bool,
                 host_name: str,
                 id: str,
                 image_id: str,
                 image_owner_alias: str,
                 instance_charge_type: str,
                 instance_name: str,
                 instance_type: str,
                 internet_charge_type: str,
                 internet_max_bandwidth_in: int,
                 internet_max_bandwidth_out: int,
                 io_optimized: str,
                 key_pair_name: str,
                 latest_version_number: int,
                 launch_template_id: str,
                 launch_template_name: str,
                 modified_time: str,
                 network_interfaces: Sequence['outputs.GetEcsLaunchTemplatesTemplateNetworkInterfaceResult'],
                 network_type: str,
                 password_inherit: bool,
                 period: int,
                 private_ip_address: str,
                 ram_role_name: str,
                 resource_group_id: str,
                 security_enhancement_strategy: str,
                 security_group_id: str,
                 security_group_ids: Sequence[str],
                 spot_duration: str,
                 spot_price_limit: float,
                 spot_strategy: str,
                 system_disks: Sequence['outputs.GetEcsLaunchTemplatesTemplateSystemDiskResult'],
                 template_tags: Mapping[str, Any],
                 user_data: str,
                 version_description: str,
                 vpc_id: str,
                 vswitch_id: str,
                 zone_id: str):
        """
        :param str auto_release_time: Instance auto release time.
        :param str created_by: CreatedBy.
        :param Sequence['GetEcsLaunchTemplatesTemplateDataDiskArgs'] data_disks: The list of data disks created with instance.
        :param int default_version_number: The Default Version Number.
        :param str deployment_set_id: The Deployment Set Id.
        :param str description: System disk description.
        :param bool enable_vm_os_config: Whether to enable the instance operating system configuration.
        :param str host_name: Instance host name.
        :param str id: The ID of the Launch Template.
        :param str image_id: The Image Id.
        :param str image_owner_alias: Mirror source.
        :param str instance_charge_type: Internet bandwidth billing method.
        :param str instance_name: The Instance Name.
        :param str instance_type: Instance type.
        :param str internet_charge_type: Internet bandwidth billing method.
        :param int internet_max_bandwidth_in: The maximum inbound bandwidth from the Internet network, measured in Mbit/s.
        :param int internet_max_bandwidth_out: Maximum outbound bandwidth from the Internet, its unit of measurement is Mbit/s.
        :param str io_optimized: Whether it is an I/O-optimized instance or not.
        :param str key_pair_name: The name of the key pair.
        :param int latest_version_number: The Latest Version Number.
        :param str launch_template_id: The ID of the Launch Template.
        :param str launch_template_name: The Launch Template Name.
        :param str modified_time: The Modified Time.
        :param Sequence['GetEcsLaunchTemplatesTemplateNetworkInterfaceArgs'] network_interfaces: The list of network interfaces created with instance.
        :param str network_type: Network type of the instance.
        :param bool password_inherit: Whether to use the password preset by the mirror.
        :param int period: The subscription period of the instance.
        :param str private_ip_address: The private IP address of the instance.
        :param str ram_role_name: The RAM role name of the instance.
        :param str resource_group_id: The ID of the resource group to which to assign the instance, Elastic Block Storage (EBS) device, and ENI.
        :param str security_enhancement_strategy: Whether or not to activate the security enhancement feature and install network security software free of charge.
        :param str security_group_id: The security group ID.
        :param Sequence[str] security_group_ids: The security group IDs.
        :param str spot_duration: The protection period of the preemptible instance.
        :param float spot_price_limit: Sets the maximum hourly instance price.
        :param str spot_strategy: The spot strategy for a Pay-As-You-Go instance.
        :param Sequence['GetEcsLaunchTemplatesTemplateSystemDiskArgs'] system_disks: The System Disk.
        :param Mapping[str, Any] template_tags: The template tags.
        :param str user_data: The User Data.
        :param str version_description: The Version Description.
        :param str vpc_id: VpcId.
        :param str vswitch_id: The vswitch id.
        :param str zone_id: The Zone Id.
        """
        GetEcsLaunchTemplatesTemplateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_release_time=auto_release_time,
            created_by=created_by,
            data_disks=data_disks,
            default_version_number=default_version_number,
            deployment_set_id=deployment_set_id,
            description=description,
            enable_vm_os_config=enable_vm_os_config,
            host_name=host_name,
            id=id,
            image_id=image_id,
            image_owner_alias=image_owner_alias,
            instance_charge_type=instance_charge_type,
            instance_name=instance_name,
            instance_type=instance_type,
            internet_charge_type=internet_charge_type,
            internet_max_bandwidth_in=internet_max_bandwidth_in,
            internet_max_bandwidth_out=internet_max_bandwidth_out,
            io_optimized=io_optimized,
            key_pair_name=key_pair_name,
            latest_version_number=latest_version_number,
            launch_template_id=launch_template_id,
            launch_template_name=launch_template_name,
            modified_time=modified_time,
            network_interfaces=network_interfaces,
            network_type=network_type,
            password_inherit=password_inherit,
            period=period,
            private_ip_address=private_ip_address,
            ram_role_name=ram_role_name,
            resource_group_id=resource_group_id,
            security_enhancement_strategy=security_enhancement_strategy,
            security_group_id=security_group_id,
            security_group_ids=security_group_ids,
            spot_duration=spot_duration,
            spot_price_limit=spot_price_limit,
            spot_strategy=spot_strategy,
            system_disks=system_disks,
            template_tags=template_tags,
            user_data=user_data,
            version_description=version_description,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_release_time: Optional[str] = None,
             created_by: Optional[str] = None,
             data_disks: Optional[Sequence['outputs.GetEcsLaunchTemplatesTemplateDataDiskResult']] = None,
             default_version_number: Optional[int] = None,
             deployment_set_id: Optional[str] = None,
             description: Optional[str] = None,
             enable_vm_os_config: Optional[bool] = None,
             host_name: Optional[str] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             image_owner_alias: Optional[str] = None,
             instance_charge_type: Optional[str] = None,
             instance_name: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             internet_max_bandwidth_in: Optional[int] = None,
             internet_max_bandwidth_out: Optional[int] = None,
             io_optimized: Optional[str] = None,
             key_pair_name: Optional[str] = None,
             latest_version_number: Optional[int] = None,
             launch_template_id: Optional[str] = None,
             launch_template_name: Optional[str] = None,
             modified_time: Optional[str] = None,
             network_interfaces: Optional[Sequence['outputs.GetEcsLaunchTemplatesTemplateNetworkInterfaceResult']] = None,
             network_type: Optional[str] = None,
             password_inherit: Optional[bool] = None,
             period: Optional[int] = None,
             private_ip_address: Optional[str] = None,
             ram_role_name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             security_enhancement_strategy: Optional[str] = None,
             security_group_id: Optional[str] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             spot_duration: Optional[str] = None,
             spot_price_limit: Optional[float] = None,
             spot_strategy: Optional[str] = None,
             system_disks: Optional[Sequence['outputs.GetEcsLaunchTemplatesTemplateSystemDiskResult']] = None,
             template_tags: Optional[Mapping[str, Any]] = None,
             user_data: Optional[str] = None,
             version_description: Optional[str] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_release_time is None and 'autoReleaseTime' in kwargs:
            auto_release_time = kwargs['autoReleaseTime']
        if auto_release_time is None:
            raise TypeError("Missing 'auto_release_time' argument")
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by is None:
            raise TypeError("Missing 'created_by' argument")
        if data_disks is None and 'dataDisks' in kwargs:
            data_disks = kwargs['dataDisks']
        if data_disks is None:
            raise TypeError("Missing 'data_disks' argument")
        if default_version_number is None and 'defaultVersionNumber' in kwargs:
            default_version_number = kwargs['defaultVersionNumber']
        if default_version_number is None:
            raise TypeError("Missing 'default_version_number' argument")
        if deployment_set_id is None and 'deploymentSetId' in kwargs:
            deployment_set_id = kwargs['deploymentSetId']
        if deployment_set_id is None:
            raise TypeError("Missing 'deployment_set_id' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if enable_vm_os_config is None and 'enableVmOsConfig' in kwargs:
            enable_vm_os_config = kwargs['enableVmOsConfig']
        if enable_vm_os_config is None:
            raise TypeError("Missing 'enable_vm_os_config' argument")
        if host_name is None and 'hostName' in kwargs:
            host_name = kwargs['hostName']
        if host_name is None:
            raise TypeError("Missing 'host_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if image_owner_alias is None and 'imageOwnerAlias' in kwargs:
            image_owner_alias = kwargs['imageOwnerAlias']
        if image_owner_alias is None:
            raise TypeError("Missing 'image_owner_alias' argument")
        if instance_charge_type is None and 'instanceChargeType' in kwargs:
            instance_charge_type = kwargs['instanceChargeType']
        if instance_charge_type is None:
            raise TypeError("Missing 'instance_charge_type' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if internet_max_bandwidth_in is None and 'internetMaxBandwidthIn' in kwargs:
            internet_max_bandwidth_in = kwargs['internetMaxBandwidthIn']
        if internet_max_bandwidth_in is None:
            raise TypeError("Missing 'internet_max_bandwidth_in' argument")
        if internet_max_bandwidth_out is None and 'internetMaxBandwidthOut' in kwargs:
            internet_max_bandwidth_out = kwargs['internetMaxBandwidthOut']
        if internet_max_bandwidth_out is None:
            raise TypeError("Missing 'internet_max_bandwidth_out' argument")
        if io_optimized is None and 'ioOptimized' in kwargs:
            io_optimized = kwargs['ioOptimized']
        if io_optimized is None:
            raise TypeError("Missing 'io_optimized' argument")
        if key_pair_name is None and 'keyPairName' in kwargs:
            key_pair_name = kwargs['keyPairName']
        if key_pair_name is None:
            raise TypeError("Missing 'key_pair_name' argument")
        if latest_version_number is None and 'latestVersionNumber' in kwargs:
            latest_version_number = kwargs['latestVersionNumber']
        if latest_version_number is None:
            raise TypeError("Missing 'latest_version_number' argument")
        if launch_template_id is None and 'launchTemplateId' in kwargs:
            launch_template_id = kwargs['launchTemplateId']
        if launch_template_id is None:
            raise TypeError("Missing 'launch_template_id' argument")
        if launch_template_name is None and 'launchTemplateName' in kwargs:
            launch_template_name = kwargs['launchTemplateName']
        if launch_template_name is None:
            raise TypeError("Missing 'launch_template_name' argument")
        if modified_time is None and 'modifiedTime' in kwargs:
            modified_time = kwargs['modifiedTime']
        if modified_time is None:
            raise TypeError("Missing 'modified_time' argument")
        if network_interfaces is None and 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if network_interfaces is None:
            raise TypeError("Missing 'network_interfaces' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if password_inherit is None and 'passwordInherit' in kwargs:
            password_inherit = kwargs['passwordInherit']
        if password_inherit is None:
            raise TypeError("Missing 'password_inherit' argument")
        if period is None:
            raise TypeError("Missing 'period' argument")
        if private_ip_address is None and 'privateIpAddress' in kwargs:
            private_ip_address = kwargs['privateIpAddress']
        if private_ip_address is None:
            raise TypeError("Missing 'private_ip_address' argument")
        if ram_role_name is None and 'ramRoleName' in kwargs:
            ram_role_name = kwargs['ramRoleName']
        if ram_role_name is None:
            raise TypeError("Missing 'ram_role_name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if security_enhancement_strategy is None and 'securityEnhancementStrategy' in kwargs:
            security_enhancement_strategy = kwargs['securityEnhancementStrategy']
        if security_enhancement_strategy is None:
            raise TypeError("Missing 'security_enhancement_strategy' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if security_group_ids is None:
            raise TypeError("Missing 'security_group_ids' argument")
        if spot_duration is None and 'spotDuration' in kwargs:
            spot_duration = kwargs['spotDuration']
        if spot_duration is None:
            raise TypeError("Missing 'spot_duration' argument")
        if spot_price_limit is None and 'spotPriceLimit' in kwargs:
            spot_price_limit = kwargs['spotPriceLimit']
        if spot_price_limit is None:
            raise TypeError("Missing 'spot_price_limit' argument")
        if spot_strategy is None and 'spotStrategy' in kwargs:
            spot_strategy = kwargs['spotStrategy']
        if spot_strategy is None:
            raise TypeError("Missing 'spot_strategy' argument")
        if system_disks is None and 'systemDisks' in kwargs:
            system_disks = kwargs['systemDisks']
        if system_disks is None:
            raise TypeError("Missing 'system_disks' argument")
        if template_tags is None and 'templateTags' in kwargs:
            template_tags = kwargs['templateTags']
        if template_tags is None:
            raise TypeError("Missing 'template_tags' argument")
        if user_data is None and 'userData' in kwargs:
            user_data = kwargs['userData']
        if user_data is None:
            raise TypeError("Missing 'user_data' argument")
        if version_description is None and 'versionDescription' in kwargs:
            version_description = kwargs['versionDescription']
        if version_description is None:
            raise TypeError("Missing 'version_description' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("auto_release_time", auto_release_time)
        _setter("created_by", created_by)
        _setter("data_disks", data_disks)
        _setter("default_version_number", default_version_number)
        _setter("deployment_set_id", deployment_set_id)
        _setter("description", description)
        _setter("enable_vm_os_config", enable_vm_os_config)
        _setter("host_name", host_name)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("image_owner_alias", image_owner_alias)
        _setter("instance_charge_type", instance_charge_type)
        _setter("instance_name", instance_name)
        _setter("instance_type", instance_type)
        _setter("internet_charge_type", internet_charge_type)
        _setter("internet_max_bandwidth_in", internet_max_bandwidth_in)
        _setter("internet_max_bandwidth_out", internet_max_bandwidth_out)
        _setter("io_optimized", io_optimized)
        _setter("key_pair_name", key_pair_name)
        _setter("latest_version_number", latest_version_number)
        _setter("launch_template_id", launch_template_id)
        _setter("launch_template_name", launch_template_name)
        _setter("modified_time", modified_time)
        _setter("network_interfaces", network_interfaces)
        _setter("network_type", network_type)
        _setter("password_inherit", password_inherit)
        _setter("period", period)
        _setter("private_ip_address", private_ip_address)
        _setter("ram_role_name", ram_role_name)
        _setter("resource_group_id", resource_group_id)
        _setter("security_enhancement_strategy", security_enhancement_strategy)
        _setter("security_group_id", security_group_id)
        _setter("security_group_ids", security_group_ids)
        _setter("spot_duration", spot_duration)
        _setter("spot_price_limit", spot_price_limit)
        _setter("spot_strategy", spot_strategy)
        _setter("system_disks", system_disks)
        _setter("template_tags", template_tags)
        _setter("user_data", user_data)
        _setter("version_description", version_description)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="autoReleaseTime")
    def auto_release_time(self) -> str:
        """
        Instance auto release time.
        """
        return pulumi.get(self, "auto_release_time")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> str:
        """
        CreatedBy.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.GetEcsLaunchTemplatesTemplateDataDiskResult']:
        """
        The list of data disks created with instance.
        """
        return pulumi.get(self, "data_disks")

    @property
    @pulumi.getter(name="defaultVersionNumber")
    def default_version_number(self) -> int:
        """
        The Default Version Number.
        """
        return pulumi.get(self, "default_version_number")

    @property
    @pulumi.getter(name="deploymentSetId")
    def deployment_set_id(self) -> str:
        """
        The Deployment Set Id.
        """
        return pulumi.get(self, "deployment_set_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        System disk description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableVmOsConfig")
    def enable_vm_os_config(self) -> bool:
        """
        Whether to enable the instance operating system configuration.
        """
        return pulumi.get(self, "enable_vm_os_config")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        Instance host name.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Launch Template.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The Image Id.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="imageOwnerAlias")
    def image_owner_alias(self) -> str:
        """
        Mirror source.
        """
        return pulumi.get(self, "image_owner_alias")

    @property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> str:
        """
        Internet bandwidth billing method.
        """
        return pulumi.get(self, "instance_charge_type")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The Instance Name.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        Internet bandwidth billing method.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="internetMaxBandwidthIn")
    def internet_max_bandwidth_in(self) -> int:
        """
        The maximum inbound bandwidth from the Internet network, measured in Mbit/s.
        """
        return pulumi.get(self, "internet_max_bandwidth_in")

    @property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> int:
        """
        Maximum outbound bandwidth from the Internet, its unit of measurement is Mbit/s.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @property
    @pulumi.getter(name="ioOptimized")
    def io_optimized(self) -> str:
        """
        Whether it is an I/O-optimized instance or not.
        """
        return pulumi.get(self, "io_optimized")

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> str:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter(name="latestVersionNumber")
    def latest_version_number(self) -> int:
        """
        The Latest Version Number.
        """
        return pulumi.get(self, "latest_version_number")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> str:
        """
        The ID of the Launch Template.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> str:
        """
        The Launch Template Name.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The Modified Time.
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetEcsLaunchTemplatesTemplateNetworkInterfaceResult']:
        """
        The list of network interfaces created with instance.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        Network type of the instance.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="passwordInherit")
    def password_inherit(self) -> bool:
        """
        Whether to use the password preset by the mirror.
        """
        return pulumi.get(self, "password_inherit")

    @property
    @pulumi.getter
    def period(self) -> int:
        """
        The subscription period of the instance.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address of the instance.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="ramRoleName")
    def ram_role_name(self) -> str:
        """
        The RAM role name of the instance.
        """
        return pulumi.get(self, "ram_role_name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group to which to assign the instance, Elastic Block Storage (EBS) device, and ENI.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityEnhancementStrategy")
    def security_enhancement_strategy(self) -> str:
        """
        Whether or not to activate the security enhancement feature and install network security software free of charge.
        """
        return pulumi.get(self, "security_enhancement_strategy")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        The security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="spotDuration")
    def spot_duration(self) -> str:
        """
        The protection period of the preemptible instance.
        """
        return pulumi.get(self, "spot_duration")

    @property
    @pulumi.getter(name="spotPriceLimit")
    def spot_price_limit(self) -> float:
        """
        Sets the maximum hourly instance price.
        """
        return pulumi.get(self, "spot_price_limit")

    @property
    @pulumi.getter(name="spotStrategy")
    def spot_strategy(self) -> str:
        """
        The spot strategy for a Pay-As-You-Go instance.
        """
        return pulumi.get(self, "spot_strategy")

    @property
    @pulumi.getter(name="systemDisks")
    def system_disks(self) -> Sequence['outputs.GetEcsLaunchTemplatesTemplateSystemDiskResult']:
        """
        The System Disk.
        """
        return pulumi.get(self, "system_disks")

    @property
    @pulumi.getter(name="templateTags")
    def template_tags(self) -> Mapping[str, Any]:
        """
        The template tags.
        """
        return pulumi.get(self, "template_tags")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        """
        The User Data.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter(name="versionDescription")
    def version_description(self) -> str:
        """
        The Version Description.
        """
        return pulumi.get(self, "version_description")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        VpcId.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The vswitch id.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The Zone Id.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetEcsLaunchTemplatesTemplateDataDiskResult(dict):
    def __init__(__self__, *,
                 category: str,
                 delete_with_instance: bool,
                 description: str,
                 encrypted: bool,
                 name: str,
                 performance_level: str,
                 size: int,
                 snapshot_id: str):
        """
        :param str category: The category of the system disk.
        :param bool delete_with_instance: Specifies whether to release the system disk when the instance is released.
        :param str description: System disk description.
        :param bool encrypted: Encrypted the data in this disk.
        :param str name: System disk name.
        :param str performance_level: The performance level of the ESSD used as the system disk.
        :param int size: Size of the system disk, measured in GB.
        :param str snapshot_id: The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        GetEcsLaunchTemplatesTemplateDataDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            encrypted=encrypted,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             encrypted: Optional[bool] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if delete_with_instance is None:
            raise TypeError("Missing 'delete_with_instance' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if performance_level is None:
            raise TypeError("Missing 'performance_level' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")

        _setter("category", category)
        _setter("delete_with_instance", delete_with_instance)
        _setter("description", description)
        _setter("encrypted", encrypted)
        _setter("name", name)
        _setter("performance_level", performance_level)
        _setter("size", size)
        _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of the system disk.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> bool:
        """
        Specifies whether to release the system disk when the instance is released.
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        System disk description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Encrypted the data in this disk.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        System disk name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> str:
        """
        The performance level of the ESSD used as the system disk.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the system disk, measured in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        The snapshot ID used to initialize the data disk. If the size specified by snapshot is greater that the size of the disk, use the size specified by snapshot as the size of the data disk.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class GetEcsLaunchTemplatesTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str,
                 primary_ip: str,
                 security_group_id: str,
                 vswitch_id: str):
        """
        :param str description: System disk description.
        :param str name: System disk name.
        :param str primary_ip: The primary private IP address of the ENI.
        :param str security_group_id: The security group ID.
        :param str vswitch_id: The vswitch id.
        """
        GetEcsLaunchTemplatesTemplateNetworkInterfaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            primary_ip=primary_ip,
            security_group_id=security_group_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             primary_ip: Optional[str] = None,
             security_group_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if primary_ip is None and 'primaryIp' in kwargs:
            primary_ip = kwargs['primaryIp']
        if primary_ip is None:
            raise TypeError("Missing 'primary_ip' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("description", description)
        _setter("name", name)
        _setter("primary_ip", primary_ip)
        _setter("security_group_id", security_group_id)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        System disk description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        System disk name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> str:
        """
        The primary private IP address of the ENI.
        """
        return pulumi.get(self, "primary_ip")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The vswitch id.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetEcsLaunchTemplatesTemplateSystemDiskResult(dict):
    def __init__(__self__, *,
                 category: str,
                 delete_with_instance: bool,
                 description: str,
                 iops: str,
                 name: str,
                 performance_level: str,
                 size: int):
        """
        :param str category: The category of the system disk.
        :param bool delete_with_instance: Specifies whether to release the system disk when the instance is released.
        :param str description: System disk description.
        :param str iops: The Iops.
        :param str name: System disk name.
        :param str performance_level: The performance level of the ESSD used as the system disk.
        :param int size: Size of the system disk, measured in GB.
        """
        GetEcsLaunchTemplatesTemplateSystemDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            delete_with_instance=delete_with_instance,
            description=description,
            iops=iops,
            name=name,
            performance_level=performance_level,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             delete_with_instance: Optional[bool] = None,
             description: Optional[str] = None,
             iops: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if delete_with_instance is None and 'deleteWithInstance' in kwargs:
            delete_with_instance = kwargs['deleteWithInstance']
        if delete_with_instance is None:
            raise TypeError("Missing 'delete_with_instance' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if iops is None:
            raise TypeError("Missing 'iops' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if performance_level is None:
            raise TypeError("Missing 'performance_level' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")

        _setter("category", category)
        _setter("delete_with_instance", delete_with_instance)
        _setter("description", description)
        _setter("iops", iops)
        _setter("name", name)
        _setter("performance_level", performance_level)
        _setter("size", size)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of the system disk.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="deleteWithInstance")
    def delete_with_instance(self) -> bool:
        """
        Specifies whether to release the system disk when the instance is released.
        """
        return pulumi.get(self, "delete_with_instance")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        System disk description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def iops(self) -> str:
        """
        The Iops.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        System disk name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> str:
        """
        The performance level of the ESSD used as the system disk.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the system disk, measured in GB.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetEcsNetworkInterfacePermissionsPermissionResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 id: str,
                 network_interface_id: str,
                 network_interface_permission_id: str,
                 permission: str,
                 service_name: str,
                 status: str):
        """
        :param str account_id: Alibaba Cloud Partner (Certified ISV) account ID or individual user ID.
        :param str id: The ID of the Network Interface Permission.
        :param str network_interface_id: The ID of the network interface.
        :param str network_interface_permission_id: The ID of the Network Interface Permissions.
        :param str permission: The permissions of the Network Interface.
        :param str service_name: Alibaba Cloud service name.
        :param str status: The Status of the Network Interface Permissions.
        """
        GetEcsNetworkInterfacePermissionsPermissionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            id=id,
            network_interface_id=network_interface_id,
            network_interface_permission_id=network_interface_permission_id,
            permission=permission,
            service_name=service_name,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             id: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             network_interface_permission_id: Optional[str] = None,
             permission: Optional[str] = None,
             service_name: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if account_id is None:
            raise TypeError("Missing 'account_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if network_interface_permission_id is None and 'networkInterfacePermissionId' in kwargs:
            network_interface_permission_id = kwargs['networkInterfacePermissionId']
        if network_interface_permission_id is None:
            raise TypeError("Missing 'network_interface_permission_id' argument")
        if permission is None:
            raise TypeError("Missing 'permission' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if service_name is None:
            raise TypeError("Missing 'service_name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("account_id", account_id)
        _setter("id", id)
        _setter("network_interface_id", network_interface_id)
        _setter("network_interface_permission_id", network_interface_permission_id)
        _setter("permission", permission)
        _setter("service_name", service_name)
        _setter("status", status)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Alibaba Cloud Partner (Certified ISV) account ID or individual user ID.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network Interface Permission.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="networkInterfacePermissionId")
    def network_interface_permission_id(self) -> str:
        """
        The ID of the Network Interface Permissions.
        """
        return pulumi.get(self, "network_interface_permission_id")

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        The permissions of the Network Interface.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Alibaba Cloud service name.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The Status of the Network Interface Permissions.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEcsNetworkInterfacesInterfaceResult(dict):
    def __init__(__self__, *,
                 associated_public_ips: Sequence['outputs.GetEcsNetworkInterfacesInterfaceAssociatedPublicIpResult'],
                 creation_time: str,
                 description: str,
                 id: str,
                 instance_id: str,
                 mac: str,
                 name: str,
                 network_interface_id: str,
                 network_interface_name: str,
                 network_interface_traffic_mode: str,
                 owner_id: str,
                 primary_ip_address: str,
                 private_ip: str,
                 private_ip_addresses: Sequence[str],
                 private_ips: Sequence[str],
                 queue_number: int,
                 resource_group_id: str,
                 security_group_ids: Sequence[str],
                 security_groups: Sequence[str],
                 service_id: int,
                 service_managed: bool,
                 status: str,
                 tags: Mapping[str, Any],
                 type: str,
                 vpc_id: str,
                 vswitch_id: str,
                 zone_id: str):
        """
        :param Sequence['GetEcsNetworkInterfacesInterfaceAssociatedPublicIpArgs'] associated_public_ips: The EIP associated with the secondary private IP address of the ENI.  **NOTE:** Available in v1.163.0+.
        :param str creation_time: The creation time.
        :param str description: The description of the ENI.
        :param str id: The ID of the Network Interface.
        :param str instance_id: The instance id.
        :param str mac: The MAC address of the ENI.
        :param str name: The network interface name.
        :param str network_interface_id: The network interface id.
        :param str network_interface_name: The network interface name.
        :param str network_interface_traffic_mode: The communication mode of the elastic network card.
        :param str owner_id: The ID of the account to which the ENIC belongs.
        :param str primary_ip_address: The primary private IP address of the ENI.
        :param str private_ip: The primary private IP address of the ENI.
        :param Sequence[str] private_ips: A list of secondary private IP address that is assigned to the ENI.
        :param int queue_number: Number of network card queues.
        :param str resource_group_id: The resource group id.
        :param Sequence[str] security_group_ids: The security group ids.
        :param Sequence[str] security_groups: The security groups.
        :param int service_id: The service id.
        :param bool service_managed: Whether the user of the elastic network card is a cloud product or a virtual vendor.
        :param str status: The status of the ENI.
        :param Mapping[str, Any] tags: The tags.
        :param str type: The type of the ENI.
        :param str vpc_id: The Vpc Id.
        :param str vswitch_id: The vswitch id.
        :param str zone_id: The zone id.
        """
        GetEcsNetworkInterfacesInterfaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associated_public_ips=associated_public_ips,
            creation_time=creation_time,
            description=description,
            id=id,
            instance_id=instance_id,
            mac=mac,
            name=name,
            network_interface_id=network_interface_id,
            network_interface_name=network_interface_name,
            network_interface_traffic_mode=network_interface_traffic_mode,
            owner_id=owner_id,
            primary_ip_address=primary_ip_address,
            private_ip=private_ip,
            private_ip_addresses=private_ip_addresses,
            private_ips=private_ips,
            queue_number=queue_number,
            resource_group_id=resource_group_id,
            security_group_ids=security_group_ids,
            security_groups=security_groups,
            service_id=service_id,
            service_managed=service_managed,
            status=status,
            tags=tags,
            type=type,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associated_public_ips: Optional[Sequence['outputs.GetEcsNetworkInterfacesInterfaceAssociatedPublicIpResult']] = None,
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             mac: Optional[str] = None,
             name: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             network_interface_name: Optional[str] = None,
             network_interface_traffic_mode: Optional[str] = None,
             owner_id: Optional[str] = None,
             primary_ip_address: Optional[str] = None,
             private_ip: Optional[str] = None,
             private_ip_addresses: Optional[Sequence[str]] = None,
             private_ips: Optional[Sequence[str]] = None,
             queue_number: Optional[int] = None,
             resource_group_id: Optional[str] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             security_groups: Optional[Sequence[str]] = None,
             service_id: Optional[int] = None,
             service_managed: Optional[bool] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if associated_public_ips is None and 'associatedPublicIps' in kwargs:
            associated_public_ips = kwargs['associatedPublicIps']
        if associated_public_ips is None:
            raise TypeError("Missing 'associated_public_ips' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if mac is None:
            raise TypeError("Missing 'mac' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if network_interface_name is None and 'networkInterfaceName' in kwargs:
            network_interface_name = kwargs['networkInterfaceName']
        if network_interface_name is None:
            raise TypeError("Missing 'network_interface_name' argument")
        if network_interface_traffic_mode is None and 'networkInterfaceTrafficMode' in kwargs:
            network_interface_traffic_mode = kwargs['networkInterfaceTrafficMode']
        if network_interface_traffic_mode is None:
            raise TypeError("Missing 'network_interface_traffic_mode' argument")
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']
        if owner_id is None:
            raise TypeError("Missing 'owner_id' argument")
        if primary_ip_address is None and 'primaryIpAddress' in kwargs:
            primary_ip_address = kwargs['primaryIpAddress']
        if primary_ip_address is None:
            raise TypeError("Missing 'primary_ip_address' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if private_ip_addresses is None and 'privateIpAddresses' in kwargs:
            private_ip_addresses = kwargs['privateIpAddresses']
        if private_ip_addresses is None:
            raise TypeError("Missing 'private_ip_addresses' argument")
        if private_ips is None and 'privateIps' in kwargs:
            private_ips = kwargs['privateIps']
        if private_ips is None:
            raise TypeError("Missing 'private_ips' argument")
        if queue_number is None and 'queueNumber' in kwargs:
            queue_number = kwargs['queueNumber']
        if queue_number is None:
            raise TypeError("Missing 'queue_number' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if security_group_ids is None:
            raise TypeError("Missing 'security_group_ids' argument")
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if security_groups is None:
            raise TypeError("Missing 'security_groups' argument")
        if service_id is None and 'serviceId' in kwargs:
            service_id = kwargs['serviceId']
        if service_id is None:
            raise TypeError("Missing 'service_id' argument")
        if service_managed is None and 'serviceManaged' in kwargs:
            service_managed = kwargs['serviceManaged']
        if service_managed is None:
            raise TypeError("Missing 'service_managed' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("associated_public_ips", associated_public_ips)
        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("mac", mac)
        _setter("name", name)
        _setter("network_interface_id", network_interface_id)
        _setter("network_interface_name", network_interface_name)
        _setter("network_interface_traffic_mode", network_interface_traffic_mode)
        _setter("owner_id", owner_id)
        _setter("primary_ip_address", primary_ip_address)
        _setter("private_ip", private_ip)
        _setter("private_ip_addresses", private_ip_addresses)
        _setter("private_ips", private_ips)
        _setter("queue_number", queue_number)
        _setter("resource_group_id", resource_group_id)
        _setter("security_group_ids", security_group_ids)
        _setter("security_groups", security_groups)
        _setter("service_id", service_id)
        _setter("service_managed", service_managed)
        _setter("status", status)
        _setter("tags", tags)
        _setter("type", type)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="associatedPublicIps")
    def associated_public_ips(self) -> Sequence['outputs.GetEcsNetworkInterfacesInterfaceAssociatedPublicIpResult']:
        """
        The EIP associated with the secondary private IP address of the ENI.  **NOTE:** Available in v1.163.0+.
        """
        return pulumi.get(self, "associated_public_ips")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        The creation time.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the ENI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Network Interface.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The instance id.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        The MAC address of the ENI.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The network interface name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        The network interface id.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="networkInterfaceName")
    def network_interface_name(self) -> str:
        """
        The network interface name.
        """
        return pulumi.get(self, "network_interface_name")

    @property
    @pulumi.getter(name="networkInterfaceTrafficMode")
    def network_interface_traffic_mode(self) -> str:
        """
        The communication mode of the elastic network card.
        """
        return pulumi.get(self, "network_interface_traffic_mode")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> str:
        """
        The ID of the account to which the ENIC belongs.
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter(name="primaryIpAddress")
    def primary_ip_address(self) -> str:
        """
        The primary private IP address of the ENI.
        """
        return pulumi.get(self, "primary_ip_address")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The primary private IP address of the ENI.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="privateIps")
    def private_ips(self) -> Sequence[str]:
        """
        A list of secondary private IP address that is assigned to the ENI.
        """
        return pulumi.get(self, "private_ips")

    @property
    @pulumi.getter(name="queueNumber")
    def queue_number(self) -> int:
        """
        Number of network card queues.
        """
        return pulumi.get(self, "queue_number")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The resource group id.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        The security group ids.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[str]:
        """
        The security groups.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> int:
        """
        The service id.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter(name="serviceManaged")
    def service_managed(self) -> bool:
        """
        Whether the user of the elastic network card is a cloud product or a virtual vendor.
        """
        return pulumi.get(self, "service_managed")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the ENI.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the ENI.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The Vpc Id.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The vswitch id.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The zone id.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetEcsNetworkInterfacesInterfaceAssociatedPublicIpResult(dict):
    def __init__(__self__, *,
                 public_ip_address: str):
        """
        :param str public_ip_address: The EIP of the ENI.
        """
        GetEcsNetworkInterfacesInterfaceAssociatedPublicIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_ip_address=public_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_ip_address is None and 'publicIpAddress' in kwargs:
            public_ip_address = kwargs['publicIpAddress']
        if public_ip_address is None:
            raise TypeError("Missing 'public_ip_address' argument")

        _setter("public_ip_address", public_ip_address)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The EIP of the ENI.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class GetEcsPrefixListsListResult(dict):
    def __init__(__self__, *,
                 address_family: str,
                 association_count: int,
                 create_time: str,
                 description: str,
                 entries: Sequence['outputs.GetEcsPrefixListsListEntryResult'],
                 id: str,
                 max_entries: int,
                 prefix_list_id: str,
                 prefix_list_name: str):
        """
        :param str address_family: The address family of the prefix list. Valid values:`IPv4`,`IPv6`.
        :param int association_count: The amount of associated resources.
        :param str create_time: The time when the prefix list was created.
        :param str description: The description of the prefix list.
        :param str id: The ID of the prefix list.
        :param int max_entries: The maximum number of entries that the prefix list supports.
        :param str prefix_list_id: The ID of the prefix list.
        :param str prefix_list_name: The name of the prefix list.
        """
        GetEcsPrefixListsListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_family=address_family,
            association_count=association_count,
            create_time=create_time,
            description=description,
            entries=entries,
            id=id,
            max_entries=max_entries,
            prefix_list_id=prefix_list_id,
            prefix_list_name=prefix_list_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_family: Optional[str] = None,
             association_count: Optional[int] = None,
             create_time: Optional[str] = None,
             description: Optional[str] = None,
             entries: Optional[Sequence['outputs.GetEcsPrefixListsListEntryResult']] = None,
             id: Optional[str] = None,
             max_entries: Optional[int] = None,
             prefix_list_id: Optional[str] = None,
             prefix_list_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_family is None and 'addressFamily' in kwargs:
            address_family = kwargs['addressFamily']
        if address_family is None:
            raise TypeError("Missing 'address_family' argument")
        if association_count is None and 'associationCount' in kwargs:
            association_count = kwargs['associationCount']
        if association_count is None:
            raise TypeError("Missing 'association_count' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if entries is None:
            raise TypeError("Missing 'entries' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if max_entries is None and 'maxEntries' in kwargs:
            max_entries = kwargs['maxEntries']
        if max_entries is None:
            raise TypeError("Missing 'max_entries' argument")
        if prefix_list_id is None and 'prefixListId' in kwargs:
            prefix_list_id = kwargs['prefixListId']
        if prefix_list_id is None:
            raise TypeError("Missing 'prefix_list_id' argument")
        if prefix_list_name is None and 'prefixListName' in kwargs:
            prefix_list_name = kwargs['prefixListName']
        if prefix_list_name is None:
            raise TypeError("Missing 'prefix_list_name' argument")

        _setter("address_family", address_family)
        _setter("association_count", association_count)
        _setter("create_time", create_time)
        _setter("description", description)
        _setter("entries", entries)
        _setter("id", id)
        _setter("max_entries", max_entries)
        _setter("prefix_list_id", prefix_list_id)
        _setter("prefix_list_name", prefix_list_name)

    @property
    @pulumi.getter(name="addressFamily")
    def address_family(self) -> str:
        """
        The address family of the prefix list. Valid values:`IPv4`,`IPv6`.
        """
        return pulumi.get(self, "address_family")

    @property
    @pulumi.getter(name="associationCount")
    def association_count(self) -> int:
        """
        The amount of associated resources.
        """
        return pulumi.get(self, "association_count")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time when the prefix list was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the prefix list.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.GetEcsPrefixListsListEntryResult']:
        return pulumi.get(self, "entries")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the prefix list.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> int:
        """
        The maximum number of entries that the prefix list supports.
        """
        return pulumi.get(self, "max_entries")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> str:
        """
        The ID of the prefix list.
        """
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="prefixListName")
    def prefix_list_name(self) -> str:
        """
        The name of the prefix list.
        """
        return pulumi.get(self, "prefix_list_name")


@pulumi.output_type
class GetEcsPrefixListsListEntryResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 description: str):
        """
        :param str description: The description of the prefix list.
        """
        GetEcsPrefixListsListEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidr is None:
            raise TypeError("Missing 'cidr' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")

        _setter("cidr", cidr)
        _setter("description", description)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the prefix list.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetEcsSnapshotGroupsGroupResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 instance_id: str,
                 resource_group_id: str,
                 snapshot_group_id: str,
                 snapshot_group_name: str,
                 status: str,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str description: The description of the snapshot-consistent group.
        :param str id: The ID of the Snapshot Group.
        :param str instance_id: The ID of the instance.
        :param str resource_group_id: The ID of the resource group to which the snapshot consistency group belongs.
        :param str snapshot_group_id: The first ID of the resource.
        :param str snapshot_group_name: The name of the snapshot-consistent group.
        :param str status: The status of the resource.
        :param Mapping[str, Any] tags: List of label key-value pairs.
        """
        GetEcsSnapshotGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            instance_id=instance_id,
            resource_group_id=resource_group_id,
            snapshot_group_id=snapshot_group_id,
            snapshot_group_name=snapshot_group_name,
            status=status,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             snapshot_group_id: Optional[str] = None,
             snapshot_group_name: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if snapshot_group_id is None and 'snapshotGroupId' in kwargs:
            snapshot_group_id = kwargs['snapshotGroupId']
        if snapshot_group_id is None:
            raise TypeError("Missing 'snapshot_group_id' argument")
        if snapshot_group_name is None and 'snapshotGroupName' in kwargs:
            snapshot_group_name = kwargs['snapshotGroupName']
        if snapshot_group_name is None:
            raise TypeError("Missing 'snapshot_group_name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("resource_group_id", resource_group_id)
        _setter("snapshot_group_id", snapshot_group_id)
        _setter("snapshot_group_name", snapshot_group_name)
        _setter("status", status)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the snapshot-consistent group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Snapshot Group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group to which the snapshot consistency group belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="snapshotGroupId")
    def snapshot_group_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "snapshot_group_id")

    @property
    @pulumi.getter(name="snapshotGroupName")
    def snapshot_group_name(self) -> str:
        """
        The name of the snapshot-consistent group.
        """
        return pulumi.get(self, "snapshot_group_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        List of label key-value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEcsSnapshotsSnapshotResult(dict):
    def __init__(__self__, *,
                 category: str,
                 creation_time: str,
                 description: str,
                 disk_id: str,
                 encrypted: bool,
                 id: str,
                 instant_access: bool,
                 instant_access_retention_days: int,
                 name: str,
                 product_code: str,
                 progress: str,
                 remain_time: int,
                 resource_group_id: str,
                 retention_days: int,
                 snapshot_id: str,
                 snapshot_name: str,
                 snapshot_sn: str,
                 snapshot_type: str,
                 source_disk_id: str,
                 source_disk_size: str,
                 source_disk_type: str,
                 source_storage_type: str,
                 status: str,
                 tags: Mapping[str, Any],
                 type: str,
                 usage: str):
        """
        :param str category: The category of the snapshot.
        :param str description: The description of the snapshot.
        :param str disk_id: The source disk id.
        :param bool encrypted: Whether the snapshot is encrypted.
        :param str id: The ID of the Snapshot.
        :param bool instant_access: Whether snapshot speed availability is enabled.
        :param int instant_access_retention_days: Specifies the retention period of the instant access feature. After the retention period ends, the snapshot is automatically released.
        :param str product_code: The product number inherited from the mirror market.
        :param str progress: Snapshot creation progress, in percentage.
        :param int remain_time: Remaining completion time for the snapshot being created.
        :param str resource_group_id: The resource group id.
        :param int retention_days: Automatic snapshot retention days.
        :param str snapshot_id: The snapshot id.
        :param str snapshot_name: Snapshot Display Name.
        :param str snapshot_sn: The serial number of the snapshot.
        :param str snapshot_type: Snapshot creation type.
        :param str source_disk_size: Source disk capacity.
        :param str source_disk_type: Source disk attributes.
        :param str source_storage_type: Original disk type.
        :param str status: The status of the snapshot.
        :param Mapping[str, Any] tags: The tags.
        :param str usage: A resource type that has a reference relationship.
        """
        GetEcsSnapshotsSnapshotResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            creation_time=creation_time,
            description=description,
            disk_id=disk_id,
            encrypted=encrypted,
            id=id,
            instant_access=instant_access,
            instant_access_retention_days=instant_access_retention_days,
            name=name,
            product_code=product_code,
            progress=progress,
            remain_time=remain_time,
            resource_group_id=resource_group_id,
            retention_days=retention_days,
            snapshot_id=snapshot_id,
            snapshot_name=snapshot_name,
            snapshot_sn=snapshot_sn,
            snapshot_type=snapshot_type,
            source_disk_id=source_disk_id,
            source_disk_size=source_disk_size,
            source_disk_type=source_disk_type,
            source_storage_type=source_storage_type,
            status=status,
            tags=tags,
            type=type,
            usage=usage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             disk_id: Optional[str] = None,
             encrypted: Optional[bool] = None,
             id: Optional[str] = None,
             instant_access: Optional[bool] = None,
             instant_access_retention_days: Optional[int] = None,
             name: Optional[str] = None,
             product_code: Optional[str] = None,
             progress: Optional[str] = None,
             remain_time: Optional[int] = None,
             resource_group_id: Optional[str] = None,
             retention_days: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             snapshot_name: Optional[str] = None,
             snapshot_sn: Optional[str] = None,
             snapshot_type: Optional[str] = None,
             source_disk_id: Optional[str] = None,
             source_disk_size: Optional[str] = None,
             source_disk_type: Optional[str] = None,
             source_storage_type: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             usage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disk_id is None and 'diskId' in kwargs:
            disk_id = kwargs['diskId']
        if disk_id is None:
            raise TypeError("Missing 'disk_id' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instant_access is None and 'instantAccess' in kwargs:
            instant_access = kwargs['instantAccess']
        if instant_access is None:
            raise TypeError("Missing 'instant_access' argument")
        if instant_access_retention_days is None and 'instantAccessRetentionDays' in kwargs:
            instant_access_retention_days = kwargs['instantAccessRetentionDays']
        if instant_access_retention_days is None:
            raise TypeError("Missing 'instant_access_retention_days' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if product_code is None and 'productCode' in kwargs:
            product_code = kwargs['productCode']
        if product_code is None:
            raise TypeError("Missing 'product_code' argument")
        if progress is None:
            raise TypeError("Missing 'progress' argument")
        if remain_time is None and 'remainTime' in kwargs:
            remain_time = kwargs['remainTime']
        if remain_time is None:
            raise TypeError("Missing 'remain_time' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if retention_days is None and 'retentionDays' in kwargs:
            retention_days = kwargs['retentionDays']
        if retention_days is None:
            raise TypeError("Missing 'retention_days' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if snapshot_name is None and 'snapshotName' in kwargs:
            snapshot_name = kwargs['snapshotName']
        if snapshot_name is None:
            raise TypeError("Missing 'snapshot_name' argument")
        if snapshot_sn is None and 'snapshotSn' in kwargs:
            snapshot_sn = kwargs['snapshotSn']
        if snapshot_sn is None:
            raise TypeError("Missing 'snapshot_sn' argument")
        if snapshot_type is None and 'snapshotType' in kwargs:
            snapshot_type = kwargs['snapshotType']
        if snapshot_type is None:
            raise TypeError("Missing 'snapshot_type' argument")
        if source_disk_id is None and 'sourceDiskId' in kwargs:
            source_disk_id = kwargs['sourceDiskId']
        if source_disk_id is None:
            raise TypeError("Missing 'source_disk_id' argument")
        if source_disk_size is None and 'sourceDiskSize' in kwargs:
            source_disk_size = kwargs['sourceDiskSize']
        if source_disk_size is None:
            raise TypeError("Missing 'source_disk_size' argument")
        if source_disk_type is None and 'sourceDiskType' in kwargs:
            source_disk_type = kwargs['sourceDiskType']
        if source_disk_type is None:
            raise TypeError("Missing 'source_disk_type' argument")
        if source_storage_type is None and 'sourceStorageType' in kwargs:
            source_storage_type = kwargs['sourceStorageType']
        if source_storage_type is None:
            raise TypeError("Missing 'source_storage_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if usage is None:
            raise TypeError("Missing 'usage' argument")

        _setter("category", category)
        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("disk_id", disk_id)
        _setter("encrypted", encrypted)
        _setter("id", id)
        _setter("instant_access", instant_access)
        _setter("instant_access_retention_days", instant_access_retention_days)
        _setter("name", name)
        _setter("product_code", product_code)
        _setter("progress", progress)
        _setter("remain_time", remain_time)
        _setter("resource_group_id", resource_group_id)
        _setter("retention_days", retention_days)
        _setter("snapshot_id", snapshot_id)
        _setter("snapshot_name", snapshot_name)
        _setter("snapshot_sn", snapshot_sn)
        _setter("snapshot_type", snapshot_type)
        _setter("source_disk_id", source_disk_id)
        _setter("source_disk_size", source_disk_size)
        _setter("source_disk_type", source_disk_type)
        _setter("source_storage_type", source_storage_type)
        _setter("status", status)
        _setter("tags", tags)
        _setter("type", type)
        _setter("usage", usage)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of the snapshot.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the snapshot.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        The source disk id.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Whether the snapshot is encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instantAccess")
    def instant_access(self) -> bool:
        """
        Whether snapshot speed availability is enabled.
        """
        return pulumi.get(self, "instant_access")

    @property
    @pulumi.getter(name="instantAccessRetentionDays")
    def instant_access_retention_days(self) -> int:
        """
        Specifies the retention period of the instant access feature. After the retention period ends, the snapshot is automatically released.
        """
        return pulumi.get(self, "instant_access_retention_days")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="productCode")
    def product_code(self) -> str:
        """
        The product number inherited from the mirror market.
        """
        return pulumi.get(self, "product_code")

    @property
    @pulumi.getter
    def progress(self) -> str:
        """
        Snapshot creation progress, in percentage.
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter(name="remainTime")
    def remain_time(self) -> int:
        """
        Remaining completion time for the snapshot being created.
        """
        return pulumi.get(self, "remain_time")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The resource group id.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        """
        Automatic snapshot retention days.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        The snapshot id.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> str:
        """
        Snapshot Display Name.
        """
        return pulumi.get(self, "snapshot_name")

    @property
    @pulumi.getter(name="snapshotSn")
    def snapshot_sn(self) -> str:
        """
        The serial number of the snapshot.
        """
        return pulumi.get(self, "snapshot_sn")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        """
        Snapshot creation type.
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter(name="sourceDiskId")
    def source_disk_id(self) -> str:
        return pulumi.get(self, "source_disk_id")

    @property
    @pulumi.getter(name="sourceDiskSize")
    def source_disk_size(self) -> str:
        """
        Source disk capacity.
        """
        return pulumi.get(self, "source_disk_size")

    @property
    @pulumi.getter(name="sourceDiskType")
    def source_disk_type(self) -> str:
        """
        Source disk attributes.
        """
        return pulumi.get(self, "source_disk_type")

    @property
    @pulumi.getter(name="sourceStorageType")
    def source_storage_type(self) -> str:
        """
        Original disk type.
        """
        return pulumi.get(self, "source_storage_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the snapshot.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> str:
        """
        A resource type that has a reference relationship.
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetEcsStorageCapacityUnitsUnitResult(dict):
    def __init__(__self__, *,
                 allocation_status: str,
                 capacity: int,
                 create_time: str,
                 description: str,
                 expired_time: str,
                 id: str,
                 start_time: str,
                 status: str,
                 storage_capacity_unit_id: str,
                 storage_capacity_unit_name: str):
        """
        :param str allocation_status: When the AllocationType value is Shared, this parameter indicates the allocation status of Storage Capacity Unit. Valid values: `allocated`, `Ignored`.
        :param int capacity: The capacity of the Storage Capacity Unit.
        :param str create_time: The time when the Storage Capacity Unit was created.
        :param str description: The description of the Storage Capacity Unit.
        :param str expired_time: The time when the Storage Capacity Unit expires.
        :param str id: The ID of the Storage Capacity Unit.
        :param str start_time: The effective time of the Storage Capacity Unit.
        :param str status: The status of Storage Capacity Unit.
        :param str storage_capacity_unit_id: The ID of Storage Capacity Unit.
        :param str storage_capacity_unit_name: The name of the Storage Capacity Unit.
        """
        GetEcsStorageCapacityUnitsUnitResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_status=allocation_status,
            capacity=capacity,
            create_time=create_time,
            description=description,
            expired_time=expired_time,
            id=id,
            start_time=start_time,
            status=status,
            storage_capacity_unit_id=storage_capacity_unit_id,
            storage_capacity_unit_name=storage_capacity_unit_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_status: Optional[str] = None,
             capacity: Optional[int] = None,
             create_time: Optional[str] = None,
             description: Optional[str] = None,
             expired_time: Optional[str] = None,
             id: Optional[str] = None,
             start_time: Optional[str] = None,
             status: Optional[str] = None,
             storage_capacity_unit_id: Optional[str] = None,
             storage_capacity_unit_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allocation_status is None and 'allocationStatus' in kwargs:
            allocation_status = kwargs['allocationStatus']
        if allocation_status is None:
            raise TypeError("Missing 'allocation_status' argument")
        if capacity is None:
            raise TypeError("Missing 'capacity' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if storage_capacity_unit_id is None and 'storageCapacityUnitId' in kwargs:
            storage_capacity_unit_id = kwargs['storageCapacityUnitId']
        if storage_capacity_unit_id is None:
            raise TypeError("Missing 'storage_capacity_unit_id' argument")
        if storage_capacity_unit_name is None and 'storageCapacityUnitName' in kwargs:
            storage_capacity_unit_name = kwargs['storageCapacityUnitName']
        if storage_capacity_unit_name is None:
            raise TypeError("Missing 'storage_capacity_unit_name' argument")

        _setter("allocation_status", allocation_status)
        _setter("capacity", capacity)
        _setter("create_time", create_time)
        _setter("description", description)
        _setter("expired_time", expired_time)
        _setter("id", id)
        _setter("start_time", start_time)
        _setter("status", status)
        _setter("storage_capacity_unit_id", storage_capacity_unit_id)
        _setter("storage_capacity_unit_name", storage_capacity_unit_name)

    @property
    @pulumi.getter(name="allocationStatus")
    def allocation_status(self) -> str:
        """
        When the AllocationType value is Shared, this parameter indicates the allocation status of Storage Capacity Unit. Valid values: `allocated`, `Ignored`.
        """
        return pulumi.get(self, "allocation_status")

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        The capacity of the Storage Capacity Unit.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time when the Storage Capacity Unit was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Storage Capacity Unit.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        """
        The time when the Storage Capacity Unit expires.
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Storage Capacity Unit.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The effective time of the Storage Capacity Unit.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of Storage Capacity Unit.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageCapacityUnitId")
    def storage_capacity_unit_id(self) -> str:
        """
        The ID of Storage Capacity Unit.
        """
        return pulumi.get(self, "storage_capacity_unit_id")

    @property
    @pulumi.getter(name="storageCapacityUnitName")
    def storage_capacity_unit_name(self) -> str:
        """
        The name of the Storage Capacity Unit.
        """
        return pulumi.get(self, "storage_capacity_unit_name")


@pulumi.output_type
class GetEipAddressesAddressResult(dict):
    def __init__(__self__, *,
                 address_name: str,
                 allocation_id: str,
                 available_regions: Sequence[str],
                 bandwidth: str,
                 bandwidth_package_bandwidth: str,
                 bandwidth_package_id: str,
                 bandwidth_package_type: str,
                 create_time: str,
                 deletion_protection: bool,
                 description: str,
                 expired_time: str,
                 has_reservation_data: str,
                 hd_monitor_status: str,
                 id: str,
                 instance_id: str,
                 instance_region_id: str,
                 instance_type: str,
                 internet_charge_type: str,
                 ip_address: str,
                 isp: str,
                 operation_locks: Sequence[str],
                 payment_type: str,
                 reservation_active_time: str,
                 reservation_bandwidth: str,
                 reservation_internet_charge_type: str,
                 reservation_order_type: str,
                 resource_group_id: str,
                 second_limited: bool,
                 segment_instance_id: str,
                 status: str,
                 tags: Mapping[str, Any]):
        """
        :param str address_name: The name of the EIP.
        :param str allocation_id: The ID of the EIP.
        :param Sequence[str] available_regions: The ID of the region to which the EIP belongs.
        :param str bandwidth: The maximum bandwidth of the EIP. Unit: Mbit/s.
        :param str bandwidth_package_bandwidth: The bandwidth value of the EIP bandwidth plan with which the EIP is associated.
        :param str bandwidth_package_id: The ID of the EIP bandwidth plan.
        :param str bandwidth_package_type: The type of the bandwidth. Only CommonBandwidthPackage (an EIP bandwidth plan) is returned.
        :param str create_time: The time when the EIP was created.
        :param bool deletion_protection: Indicates whether deletion protection is enabled.
        :param str description: The description of the EIP.
        :param str expired_time: The expiration date. The time follows the ISO 8601 standard and is displayed in UTC. Format: YYYY-MM-DDThh:mmZ.
        :param str has_reservation_data: Indicates whether renewal data is included. This parameter returns true only when the parameter IncludeReservationData is set to true, and some orders have not taken effect.
        :param str hd_monitor_status: Indicates whether fine-grained monitoring is enabled for the EIP.
        :param str id: The ID of the Address.
        :param str instance_id: The ID of the instance with which the EIP is associated.
        :param str instance_region_id: The region ID of the associated resource.
        :param str instance_type: The type of the instance with which the EIP is associated.
        :param str internet_charge_type: The metering method of the EIP.
        :param str ip_address: The IP address of the EIP.
        :param str isp: The Internet service provider (ISP).
        :param Sequence[str] operation_locks: The details about the locked EIP.
        :param str payment_type: The billing method of the EIP.
        :param str reservation_active_time: The time when the renewal takes effect.
        :param str reservation_bandwidth: The bandwidth after the renewal takes effect.
        :param str reservation_internet_charge_type: The metering method of the renewal.
        :param str reservation_order_type: The type of the renewal order.
        :param str resource_group_id: The ID of the resource group.
        :param bool second_limited: Indicates whether level-2 throttling is configured.
        :param str segment_instance_id: The IDs of the contiguous EIPs.
        :param str status: The status of the EIP.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetEipAddressesAddressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_name=address_name,
            allocation_id=allocation_id,
            available_regions=available_regions,
            bandwidth=bandwidth,
            bandwidth_package_bandwidth=bandwidth_package_bandwidth,
            bandwidth_package_id=bandwidth_package_id,
            bandwidth_package_type=bandwidth_package_type,
            create_time=create_time,
            deletion_protection=deletion_protection,
            description=description,
            expired_time=expired_time,
            has_reservation_data=has_reservation_data,
            hd_monitor_status=hd_monitor_status,
            id=id,
            instance_id=instance_id,
            instance_region_id=instance_region_id,
            instance_type=instance_type,
            internet_charge_type=internet_charge_type,
            ip_address=ip_address,
            isp=isp,
            operation_locks=operation_locks,
            payment_type=payment_type,
            reservation_active_time=reservation_active_time,
            reservation_bandwidth=reservation_bandwidth,
            reservation_internet_charge_type=reservation_internet_charge_type,
            reservation_order_type=reservation_order_type,
            resource_group_id=resource_group_id,
            second_limited=second_limited,
            segment_instance_id=segment_instance_id,
            status=status,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_name: Optional[str] = None,
             allocation_id: Optional[str] = None,
             available_regions: Optional[Sequence[str]] = None,
             bandwidth: Optional[str] = None,
             bandwidth_package_bandwidth: Optional[str] = None,
             bandwidth_package_id: Optional[str] = None,
             bandwidth_package_type: Optional[str] = None,
             create_time: Optional[str] = None,
             deletion_protection: Optional[bool] = None,
             description: Optional[str] = None,
             expired_time: Optional[str] = None,
             has_reservation_data: Optional[str] = None,
             hd_monitor_status: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_region_id: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             ip_address: Optional[str] = None,
             isp: Optional[str] = None,
             operation_locks: Optional[Sequence[str]] = None,
             payment_type: Optional[str] = None,
             reservation_active_time: Optional[str] = None,
             reservation_bandwidth: Optional[str] = None,
             reservation_internet_charge_type: Optional[str] = None,
             reservation_order_type: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             second_limited: Optional[bool] = None,
             segment_instance_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_name is None and 'addressName' in kwargs:
            address_name = kwargs['addressName']
        if address_name is None:
            raise TypeError("Missing 'address_name' argument")
        if allocation_id is None and 'allocationId' in kwargs:
            allocation_id = kwargs['allocationId']
        if allocation_id is None:
            raise TypeError("Missing 'allocation_id' argument")
        if available_regions is None and 'availableRegions' in kwargs:
            available_regions = kwargs['availableRegions']
        if available_regions is None:
            raise TypeError("Missing 'available_regions' argument")
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if bandwidth_package_bandwidth is None and 'bandwidthPackageBandwidth' in kwargs:
            bandwidth_package_bandwidth = kwargs['bandwidthPackageBandwidth']
        if bandwidth_package_bandwidth is None:
            raise TypeError("Missing 'bandwidth_package_bandwidth' argument")
        if bandwidth_package_id is None and 'bandwidthPackageId' in kwargs:
            bandwidth_package_id = kwargs['bandwidthPackageId']
        if bandwidth_package_id is None:
            raise TypeError("Missing 'bandwidth_package_id' argument")
        if bandwidth_package_type is None and 'bandwidthPackageType' in kwargs:
            bandwidth_package_type = kwargs['bandwidthPackageType']
        if bandwidth_package_type is None:
            raise TypeError("Missing 'bandwidth_package_type' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if deletion_protection is None and 'deletionProtection' in kwargs:
            deletion_protection = kwargs['deletionProtection']
        if deletion_protection is None:
            raise TypeError("Missing 'deletion_protection' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if has_reservation_data is None and 'hasReservationData' in kwargs:
            has_reservation_data = kwargs['hasReservationData']
        if has_reservation_data is None:
            raise TypeError("Missing 'has_reservation_data' argument")
        if hd_monitor_status is None and 'hdMonitorStatus' in kwargs:
            hd_monitor_status = kwargs['hdMonitorStatus']
        if hd_monitor_status is None:
            raise TypeError("Missing 'hd_monitor_status' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_region_id is None and 'instanceRegionId' in kwargs:
            instance_region_id = kwargs['instanceRegionId']
        if instance_region_id is None:
            raise TypeError("Missing 'instance_region_id' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if isp is None:
            raise TypeError("Missing 'isp' argument")
        if operation_locks is None and 'operationLocks' in kwargs:
            operation_locks = kwargs['operationLocks']
        if operation_locks is None:
            raise TypeError("Missing 'operation_locks' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if reservation_active_time is None and 'reservationActiveTime' in kwargs:
            reservation_active_time = kwargs['reservationActiveTime']
        if reservation_active_time is None:
            raise TypeError("Missing 'reservation_active_time' argument")
        if reservation_bandwidth is None and 'reservationBandwidth' in kwargs:
            reservation_bandwidth = kwargs['reservationBandwidth']
        if reservation_bandwidth is None:
            raise TypeError("Missing 'reservation_bandwidth' argument")
        if reservation_internet_charge_type is None and 'reservationInternetChargeType' in kwargs:
            reservation_internet_charge_type = kwargs['reservationInternetChargeType']
        if reservation_internet_charge_type is None:
            raise TypeError("Missing 'reservation_internet_charge_type' argument")
        if reservation_order_type is None and 'reservationOrderType' in kwargs:
            reservation_order_type = kwargs['reservationOrderType']
        if reservation_order_type is None:
            raise TypeError("Missing 'reservation_order_type' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if second_limited is None and 'secondLimited' in kwargs:
            second_limited = kwargs['secondLimited']
        if second_limited is None:
            raise TypeError("Missing 'second_limited' argument")
        if segment_instance_id is None and 'segmentInstanceId' in kwargs:
            segment_instance_id = kwargs['segmentInstanceId']
        if segment_instance_id is None:
            raise TypeError("Missing 'segment_instance_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("address_name", address_name)
        _setter("allocation_id", allocation_id)
        _setter("available_regions", available_regions)
        _setter("bandwidth", bandwidth)
        _setter("bandwidth_package_bandwidth", bandwidth_package_bandwidth)
        _setter("bandwidth_package_id", bandwidth_package_id)
        _setter("bandwidth_package_type", bandwidth_package_type)
        _setter("create_time", create_time)
        _setter("deletion_protection", deletion_protection)
        _setter("description", description)
        _setter("expired_time", expired_time)
        _setter("has_reservation_data", has_reservation_data)
        _setter("hd_monitor_status", hd_monitor_status)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("instance_region_id", instance_region_id)
        _setter("instance_type", instance_type)
        _setter("internet_charge_type", internet_charge_type)
        _setter("ip_address", ip_address)
        _setter("isp", isp)
        _setter("operation_locks", operation_locks)
        _setter("payment_type", payment_type)
        _setter("reservation_active_time", reservation_active_time)
        _setter("reservation_bandwidth", reservation_bandwidth)
        _setter("reservation_internet_charge_type", reservation_internet_charge_type)
        _setter("reservation_order_type", reservation_order_type)
        _setter("resource_group_id", resource_group_id)
        _setter("second_limited", second_limited)
        _setter("segment_instance_id", segment_instance_id)
        _setter("status", status)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="addressName")
    def address_name(self) -> str:
        """
        The name of the EIP.
        """
        return pulumi.get(self, "address_name")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> str:
        """
        The ID of the EIP.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter(name="availableRegions")
    def available_regions(self) -> Sequence[str]:
        """
        The ID of the region to which the EIP belongs.
        """
        return pulumi.get(self, "available_regions")

    @property
    @pulumi.getter
    def bandwidth(self) -> str:
        """
        The maximum bandwidth of the EIP. Unit: Mbit/s.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="bandwidthPackageBandwidth")
    def bandwidth_package_bandwidth(self) -> str:
        """
        The bandwidth value of the EIP bandwidth plan with which the EIP is associated.
        """
        return pulumi.get(self, "bandwidth_package_bandwidth")

    @property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> str:
        """
        The ID of the EIP bandwidth plan.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @property
    @pulumi.getter(name="bandwidthPackageType")
    def bandwidth_package_type(self) -> str:
        """
        The type of the bandwidth. Only CommonBandwidthPackage (an EIP bandwidth plan) is returned.
        """
        return pulumi.get(self, "bandwidth_package_type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time when the EIP was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> bool:
        """
        Indicates whether deletion protection is enabled.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the EIP.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        """
        The expiration date. The time follows the ISO 8601 standard and is displayed in UTC. Format: YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter(name="hasReservationData")
    def has_reservation_data(self) -> str:
        """
        Indicates whether renewal data is included. This parameter returns true only when the parameter IncludeReservationData is set to true, and some orders have not taken effect.
        """
        return pulumi.get(self, "has_reservation_data")

    @property
    @pulumi.getter(name="hdMonitorStatus")
    def hd_monitor_status(self) -> str:
        """
        Indicates whether fine-grained monitoring is enabled for the EIP.
        """
        return pulumi.get(self, "hd_monitor_status")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Address.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance with which the EIP is associated.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceRegionId")
    def instance_region_id(self) -> str:
        """
        The region ID of the associated resource.
        """
        return pulumi.get(self, "instance_region_id")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The type of the instance with which the EIP is associated.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        The metering method of the EIP.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the EIP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def isp(self) -> str:
        """
        The Internet service provider (ISP).
        """
        return pulumi.get(self, "isp")

    @property
    @pulumi.getter(name="operationLocks")
    def operation_locks(self) -> Sequence[str]:
        """
        The details about the locked EIP.
        """
        return pulumi.get(self, "operation_locks")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        """
        The billing method of the EIP.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="reservationActiveTime")
    def reservation_active_time(self) -> str:
        """
        The time when the renewal takes effect.
        """
        return pulumi.get(self, "reservation_active_time")

    @property
    @pulumi.getter(name="reservationBandwidth")
    def reservation_bandwidth(self) -> str:
        """
        The bandwidth after the renewal takes effect.
        """
        return pulumi.get(self, "reservation_bandwidth")

    @property
    @pulumi.getter(name="reservationInternetChargeType")
    def reservation_internet_charge_type(self) -> str:
        """
        The metering method of the renewal.
        """
        return pulumi.get(self, "reservation_internet_charge_type")

    @property
    @pulumi.getter(name="reservationOrderType")
    def reservation_order_type(self) -> str:
        """
        The type of the renewal order.
        """
        return pulumi.get(self, "reservation_order_type")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="secondLimited")
    def second_limited(self) -> bool:
        """
        Indicates whether level-2 throttling is configured.
        """
        return pulumi.get(self, "second_limited")

    @property
    @pulumi.getter(name="segmentInstanceId")
    def segment_instance_id(self) -> str:
        """
        The IDs of the contiguous EIPs.
        """
        return pulumi.get(self, "segment_instance_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the EIP.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEipAddressesEipResult(dict):
    def __init__(__self__, *,
                 bandwidth: str,
                 creation_time: str,
                 deletion_protection: bool,
                 id: str,
                 instance_id: str,
                 instance_type: str,
                 internet_charge_type: str,
                 ip_address: str,
                 status: str):
        """
        :param str bandwidth: The maximum bandwidth of the EIP. Unit: Mbit/s.
        :param bool deletion_protection: Indicates whether deletion protection is enabled.
        :param str id: The ID of the Address.
        :param str instance_id: The ID of the instance with which the EIP is associated.
        :param str instance_type: The type of the instance with which the EIP is associated.
        :param str internet_charge_type: The metering method of the EIP.
        :param str ip_address: The IP address of the EIP.
        :param str status: The status of the EIP.
        """
        GetEipAddressesEipResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bandwidth=bandwidth,
            creation_time=creation_time,
            deletion_protection=deletion_protection,
            id=id,
            instance_id=instance_id,
            instance_type=instance_type,
            internet_charge_type=internet_charge_type,
            ip_address=ip_address,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bandwidth: Optional[str] = None,
             creation_time: Optional[str] = None,
             deletion_protection: Optional[bool] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             ip_address: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if deletion_protection is None and 'deletionProtection' in kwargs:
            deletion_protection = kwargs['deletionProtection']
        if deletion_protection is None:
            raise TypeError("Missing 'deletion_protection' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("bandwidth", bandwidth)
        _setter("creation_time", creation_time)
        _setter("deletion_protection", deletion_protection)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("instance_type", instance_type)
        _setter("internet_charge_type", internet_charge_type)
        _setter("ip_address", ip_address)
        _setter("status", status)

    @property
    @pulumi.getter
    def bandwidth(self) -> str:
        """
        The maximum bandwidth of the EIP. Unit: Mbit/s.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> bool:
        """
        Indicates whether deletion protection is enabled.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Address.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance with which the EIP is associated.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The type of the instance with which the EIP is associated.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        The metering method of the EIP.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the EIP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the EIP.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEipsAddressResult(dict):
    def __init__(__self__, *,
                 address_name: str,
                 allocation_id: str,
                 available_regions: Sequence[str],
                 bandwidth: str,
                 bandwidth_package_bandwidth: str,
                 bandwidth_package_id: str,
                 bandwidth_package_type: str,
                 create_time: str,
                 deletion_protection: bool,
                 description: str,
                 expired_time: str,
                 has_reservation_data: str,
                 hd_monitor_status: str,
                 id: str,
                 instance_id: str,
                 instance_region_id: str,
                 instance_type: str,
                 internet_charge_type: str,
                 ip_address: str,
                 isp: str,
                 operation_locks: Sequence[str],
                 payment_type: str,
                 reservation_active_time: str,
                 reservation_bandwidth: str,
                 reservation_internet_charge_type: str,
                 reservation_order_type: str,
                 resource_group_id: str,
                 second_limited: bool,
                 segment_instance_id: str,
                 status: str,
                 tags: Mapping[str, Any]):
        """
        :param str bandwidth: EIP internet max bandwidth in Mbps.
        :param bool deletion_protection: (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
        :param str id: ID of the EIP.
        :param str instance_id: The ID of the instance that is being bound.
        :param str instance_type: The instance type of that the EIP is bound.
        :param str internet_charge_type: EIP internet charge type.
        :param str ip_address: Public IP Address of the the EIP.
        :param str resource_group_id: The Id of resource group which the eips belongs.
        :param str status: EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetEipsAddressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_name=address_name,
            allocation_id=allocation_id,
            available_regions=available_regions,
            bandwidth=bandwidth,
            bandwidth_package_bandwidth=bandwidth_package_bandwidth,
            bandwidth_package_id=bandwidth_package_id,
            bandwidth_package_type=bandwidth_package_type,
            create_time=create_time,
            deletion_protection=deletion_protection,
            description=description,
            expired_time=expired_time,
            has_reservation_data=has_reservation_data,
            hd_monitor_status=hd_monitor_status,
            id=id,
            instance_id=instance_id,
            instance_region_id=instance_region_id,
            instance_type=instance_type,
            internet_charge_type=internet_charge_type,
            ip_address=ip_address,
            isp=isp,
            operation_locks=operation_locks,
            payment_type=payment_type,
            reservation_active_time=reservation_active_time,
            reservation_bandwidth=reservation_bandwidth,
            reservation_internet_charge_type=reservation_internet_charge_type,
            reservation_order_type=reservation_order_type,
            resource_group_id=resource_group_id,
            second_limited=second_limited,
            segment_instance_id=segment_instance_id,
            status=status,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_name: Optional[str] = None,
             allocation_id: Optional[str] = None,
             available_regions: Optional[Sequence[str]] = None,
             bandwidth: Optional[str] = None,
             bandwidth_package_bandwidth: Optional[str] = None,
             bandwidth_package_id: Optional[str] = None,
             bandwidth_package_type: Optional[str] = None,
             create_time: Optional[str] = None,
             deletion_protection: Optional[bool] = None,
             description: Optional[str] = None,
             expired_time: Optional[str] = None,
             has_reservation_data: Optional[str] = None,
             hd_monitor_status: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_region_id: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             ip_address: Optional[str] = None,
             isp: Optional[str] = None,
             operation_locks: Optional[Sequence[str]] = None,
             payment_type: Optional[str] = None,
             reservation_active_time: Optional[str] = None,
             reservation_bandwidth: Optional[str] = None,
             reservation_internet_charge_type: Optional[str] = None,
             reservation_order_type: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             second_limited: Optional[bool] = None,
             segment_instance_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_name is None and 'addressName' in kwargs:
            address_name = kwargs['addressName']
        if address_name is None:
            raise TypeError("Missing 'address_name' argument")
        if allocation_id is None and 'allocationId' in kwargs:
            allocation_id = kwargs['allocationId']
        if allocation_id is None:
            raise TypeError("Missing 'allocation_id' argument")
        if available_regions is None and 'availableRegions' in kwargs:
            available_regions = kwargs['availableRegions']
        if available_regions is None:
            raise TypeError("Missing 'available_regions' argument")
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if bandwidth_package_bandwidth is None and 'bandwidthPackageBandwidth' in kwargs:
            bandwidth_package_bandwidth = kwargs['bandwidthPackageBandwidth']
        if bandwidth_package_bandwidth is None:
            raise TypeError("Missing 'bandwidth_package_bandwidth' argument")
        if bandwidth_package_id is None and 'bandwidthPackageId' in kwargs:
            bandwidth_package_id = kwargs['bandwidthPackageId']
        if bandwidth_package_id is None:
            raise TypeError("Missing 'bandwidth_package_id' argument")
        if bandwidth_package_type is None and 'bandwidthPackageType' in kwargs:
            bandwidth_package_type = kwargs['bandwidthPackageType']
        if bandwidth_package_type is None:
            raise TypeError("Missing 'bandwidth_package_type' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if deletion_protection is None and 'deletionProtection' in kwargs:
            deletion_protection = kwargs['deletionProtection']
        if deletion_protection is None:
            raise TypeError("Missing 'deletion_protection' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if has_reservation_data is None and 'hasReservationData' in kwargs:
            has_reservation_data = kwargs['hasReservationData']
        if has_reservation_data is None:
            raise TypeError("Missing 'has_reservation_data' argument")
        if hd_monitor_status is None and 'hdMonitorStatus' in kwargs:
            hd_monitor_status = kwargs['hdMonitorStatus']
        if hd_monitor_status is None:
            raise TypeError("Missing 'hd_monitor_status' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_region_id is None and 'instanceRegionId' in kwargs:
            instance_region_id = kwargs['instanceRegionId']
        if instance_region_id is None:
            raise TypeError("Missing 'instance_region_id' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if isp is None:
            raise TypeError("Missing 'isp' argument")
        if operation_locks is None and 'operationLocks' in kwargs:
            operation_locks = kwargs['operationLocks']
        if operation_locks is None:
            raise TypeError("Missing 'operation_locks' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if reservation_active_time is None and 'reservationActiveTime' in kwargs:
            reservation_active_time = kwargs['reservationActiveTime']
        if reservation_active_time is None:
            raise TypeError("Missing 'reservation_active_time' argument")
        if reservation_bandwidth is None and 'reservationBandwidth' in kwargs:
            reservation_bandwidth = kwargs['reservationBandwidth']
        if reservation_bandwidth is None:
            raise TypeError("Missing 'reservation_bandwidth' argument")
        if reservation_internet_charge_type is None and 'reservationInternetChargeType' in kwargs:
            reservation_internet_charge_type = kwargs['reservationInternetChargeType']
        if reservation_internet_charge_type is None:
            raise TypeError("Missing 'reservation_internet_charge_type' argument")
        if reservation_order_type is None and 'reservationOrderType' in kwargs:
            reservation_order_type = kwargs['reservationOrderType']
        if reservation_order_type is None:
            raise TypeError("Missing 'reservation_order_type' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if second_limited is None and 'secondLimited' in kwargs:
            second_limited = kwargs['secondLimited']
        if second_limited is None:
            raise TypeError("Missing 'second_limited' argument")
        if segment_instance_id is None and 'segmentInstanceId' in kwargs:
            segment_instance_id = kwargs['segmentInstanceId']
        if segment_instance_id is None:
            raise TypeError("Missing 'segment_instance_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("address_name", address_name)
        _setter("allocation_id", allocation_id)
        _setter("available_regions", available_regions)
        _setter("bandwidth", bandwidth)
        _setter("bandwidth_package_bandwidth", bandwidth_package_bandwidth)
        _setter("bandwidth_package_id", bandwidth_package_id)
        _setter("bandwidth_package_type", bandwidth_package_type)
        _setter("create_time", create_time)
        _setter("deletion_protection", deletion_protection)
        _setter("description", description)
        _setter("expired_time", expired_time)
        _setter("has_reservation_data", has_reservation_data)
        _setter("hd_monitor_status", hd_monitor_status)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("instance_region_id", instance_region_id)
        _setter("instance_type", instance_type)
        _setter("internet_charge_type", internet_charge_type)
        _setter("ip_address", ip_address)
        _setter("isp", isp)
        _setter("operation_locks", operation_locks)
        _setter("payment_type", payment_type)
        _setter("reservation_active_time", reservation_active_time)
        _setter("reservation_bandwidth", reservation_bandwidth)
        _setter("reservation_internet_charge_type", reservation_internet_charge_type)
        _setter("reservation_order_type", reservation_order_type)
        _setter("resource_group_id", resource_group_id)
        _setter("second_limited", second_limited)
        _setter("segment_instance_id", segment_instance_id)
        _setter("status", status)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="addressName")
    def address_name(self) -> str:
        return pulumi.get(self, "address_name")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> str:
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter(name="availableRegions")
    def available_regions(self) -> Sequence[str]:
        return pulumi.get(self, "available_regions")

    @property
    @pulumi.getter
    def bandwidth(self) -> str:
        """
        EIP internet max bandwidth in Mbps.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="bandwidthPackageBandwidth")
    def bandwidth_package_bandwidth(self) -> str:
        return pulumi.get(self, "bandwidth_package_bandwidth")

    @property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> str:
        return pulumi.get(self, "bandwidth_package_id")

    @property
    @pulumi.getter(name="bandwidthPackageType")
    def bandwidth_package_type(self) -> str:
        return pulumi.get(self, "bandwidth_package_type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> bool:
        """
        (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter(name="hasReservationData")
    def has_reservation_data(self) -> str:
        return pulumi.get(self, "has_reservation_data")

    @property
    @pulumi.getter(name="hdMonitorStatus")
    def hd_monitor_status(self) -> str:
        return pulumi.get(self, "hd_monitor_status")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the EIP.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance that is being bound.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceRegionId")
    def instance_region_id(self) -> str:
        return pulumi.get(self, "instance_region_id")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The instance type of that the EIP is bound.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        EIP internet charge type.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Public IP Address of the the EIP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def isp(self) -> str:
        return pulumi.get(self, "isp")

    @property
    @pulumi.getter(name="operationLocks")
    def operation_locks(self) -> Sequence[str]:
        return pulumi.get(self, "operation_locks")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="reservationActiveTime")
    def reservation_active_time(self) -> str:
        return pulumi.get(self, "reservation_active_time")

    @property
    @pulumi.getter(name="reservationBandwidth")
    def reservation_bandwidth(self) -> str:
        return pulumi.get(self, "reservation_bandwidth")

    @property
    @pulumi.getter(name="reservationInternetChargeType")
    def reservation_internet_charge_type(self) -> str:
        return pulumi.get(self, "reservation_internet_charge_type")

    @property
    @pulumi.getter(name="reservationOrderType")
    def reservation_order_type(self) -> str:
        return pulumi.get(self, "reservation_order_type")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which the eips belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="secondLimited")
    def second_limited(self) -> bool:
        return pulumi.get(self, "second_limited")

    @property
    @pulumi.getter(name="segmentInstanceId")
    def segment_instance_id(self) -> str:
        return pulumi.get(self, "segment_instance_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEipsEipResult(dict):
    def __init__(__self__, *,
                 bandwidth: str,
                 creation_time: str,
                 deletion_protection: bool,
                 id: str,
                 instance_id: str,
                 instance_type: str,
                 internet_charge_type: str,
                 ip_address: str,
                 status: str):
        """
        :param str bandwidth: EIP internet max bandwidth in Mbps.
        :param str creation_time: Time of creation.
        :param bool deletion_protection: (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
        :param str id: ID of the EIP.
        :param str instance_id: The ID of the instance that is being bound.
        :param str instance_type: The instance type of that the EIP is bound.
        :param str internet_charge_type: EIP internet charge type.
        :param str ip_address: Public IP Address of the the EIP.
        :param str status: EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
        """
        GetEipsEipResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bandwidth=bandwidth,
            creation_time=creation_time,
            deletion_protection=deletion_protection,
            id=id,
            instance_id=instance_id,
            instance_type=instance_type,
            internet_charge_type=internet_charge_type,
            ip_address=ip_address,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bandwidth: Optional[str] = None,
             creation_time: Optional[str] = None,
             deletion_protection: Optional[bool] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             ip_address: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if deletion_protection is None and 'deletionProtection' in kwargs:
            deletion_protection = kwargs['deletionProtection']
        if deletion_protection is None:
            raise TypeError("Missing 'deletion_protection' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("bandwidth", bandwidth)
        _setter("creation_time", creation_time)
        _setter("deletion_protection", deletion_protection)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("instance_type", instance_type)
        _setter("internet_charge_type", internet_charge_type)
        _setter("ip_address", ip_address)
        _setter("status", status)

    @property
    @pulumi.getter
    def bandwidth(self) -> str:
        """
        EIP internet max bandwidth in Mbps.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Time of creation.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> bool:
        """
        (Optional, Available in v1.124.4+) Whether enable the deletion protection or not.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the EIP.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance that is being bound.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        The instance type of that the EIP is bound.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        EIP internet charge type.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Public IP Address of the the EIP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        EIP status. Possible values are: `Associating`, `Unassociating`, `InUse` and `Available`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetElasticityAssurancesAssuranceResult(dict):
    def __init__(__self__, *,
                 allocated_resources: Sequence['outputs.GetElasticityAssurancesAssuranceAllocatedResourceResult'],
                 description: str,
                 elasticity_assurance_id: str,
                 end_time: str,
                 id: str,
                 instance_charge_type: str,
                 private_pool_options_id: str,
                 private_pool_options_match_criteria: str,
                 private_pool_options_name: str,
                 resource_group_id: str,
                 start_time: str,
                 start_time_type: str,
                 status: str,
                 total_assurance_times: str,
                 used_assurance_times: int,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param Sequence['GetElasticityAssurancesAssuranceAllocatedResourceArgs'] allocated_resources: Details of resource allocation.
        :param str description: Description of flexible guarantee service.
        :param str elasticity_assurance_id: The first ID of the resource
        :param str end_time: Flexible guarantee service failure time.
        :param str id: ID of flexible guarantee service.
        :param str instance_charge_type: The billing method of the instance. Possible value: PostPaid. Currently, only pay-as-you-go is supported.
        :param str private_pool_options_id: The ID of the elasticity assurance.
        :param str private_pool_options_match_criteria: The matching mode of flexible guarantee service. Possible values:-Open: flexible guarantee service for Open mode.-Target: specifies the flexible guarantee service of the mode.
        :param str private_pool_options_name: The name of the elasticity assurance.
        :param str resource_group_id: The ID of the resource group.
        :param str start_time: Flexible guarantee service effective time.
        :param str start_time_type: Flexible guarantee effective way. Possible values:-Now: Effective immediately.-Later: the specified time takes effect.
        :param str status: The status of flexible guarantee services. Possible values: `All`, `Preparing`, `Prepared`, `Active`, `Released`.
        :param str total_assurance_times: The total number of flexible guarantee services.
        :param int used_assurance_times: This parameter is not yet available.
        :param Mapping[str, Any] tags: The tag key-value pair information bound by the elastic guarantee service.
        """
        GetElasticityAssurancesAssuranceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocated_resources=allocated_resources,
            description=description,
            elasticity_assurance_id=elasticity_assurance_id,
            end_time=end_time,
            id=id,
            instance_charge_type=instance_charge_type,
            private_pool_options_id=private_pool_options_id,
            private_pool_options_match_criteria=private_pool_options_match_criteria,
            private_pool_options_name=private_pool_options_name,
            resource_group_id=resource_group_id,
            start_time=start_time,
            start_time_type=start_time_type,
            status=status,
            total_assurance_times=total_assurance_times,
            used_assurance_times=used_assurance_times,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocated_resources: Optional[Sequence['outputs.GetElasticityAssurancesAssuranceAllocatedResourceResult']] = None,
             description: Optional[str] = None,
             elasticity_assurance_id: Optional[str] = None,
             end_time: Optional[str] = None,
             id: Optional[str] = None,
             instance_charge_type: Optional[str] = None,
             private_pool_options_id: Optional[str] = None,
             private_pool_options_match_criteria: Optional[str] = None,
             private_pool_options_name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             start_time: Optional[str] = None,
             start_time_type: Optional[str] = None,
             status: Optional[str] = None,
             total_assurance_times: Optional[str] = None,
             used_assurance_times: Optional[int] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allocated_resources is None and 'allocatedResources' in kwargs:
            allocated_resources = kwargs['allocatedResources']
        if allocated_resources is None:
            raise TypeError("Missing 'allocated_resources' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if elasticity_assurance_id is None and 'elasticityAssuranceId' in kwargs:
            elasticity_assurance_id = kwargs['elasticityAssuranceId']
        if elasticity_assurance_id is None:
            raise TypeError("Missing 'elasticity_assurance_id' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if end_time is None:
            raise TypeError("Missing 'end_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_charge_type is None and 'instanceChargeType' in kwargs:
            instance_charge_type = kwargs['instanceChargeType']
        if instance_charge_type is None:
            raise TypeError("Missing 'instance_charge_type' argument")
        if private_pool_options_id is None and 'privatePoolOptionsId' in kwargs:
            private_pool_options_id = kwargs['privatePoolOptionsId']
        if private_pool_options_id is None:
            raise TypeError("Missing 'private_pool_options_id' argument")
        if private_pool_options_match_criteria is None and 'privatePoolOptionsMatchCriteria' in kwargs:
            private_pool_options_match_criteria = kwargs['privatePoolOptionsMatchCriteria']
        if private_pool_options_match_criteria is None:
            raise TypeError("Missing 'private_pool_options_match_criteria' argument")
        if private_pool_options_name is None and 'privatePoolOptionsName' in kwargs:
            private_pool_options_name = kwargs['privatePoolOptionsName']
        if private_pool_options_name is None:
            raise TypeError("Missing 'private_pool_options_name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if start_time_type is None and 'startTimeType' in kwargs:
            start_time_type = kwargs['startTimeType']
        if start_time_type is None:
            raise TypeError("Missing 'start_time_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if total_assurance_times is None and 'totalAssuranceTimes' in kwargs:
            total_assurance_times = kwargs['totalAssuranceTimes']
        if total_assurance_times is None:
            raise TypeError("Missing 'total_assurance_times' argument")
        if used_assurance_times is None and 'usedAssuranceTimes' in kwargs:
            used_assurance_times = kwargs['usedAssuranceTimes']
        if used_assurance_times is None:
            raise TypeError("Missing 'used_assurance_times' argument")

        _setter("allocated_resources", allocated_resources)
        _setter("description", description)
        _setter("elasticity_assurance_id", elasticity_assurance_id)
        _setter("end_time", end_time)
        _setter("id", id)
        _setter("instance_charge_type", instance_charge_type)
        _setter("private_pool_options_id", private_pool_options_id)
        _setter("private_pool_options_match_criteria", private_pool_options_match_criteria)
        _setter("private_pool_options_name", private_pool_options_name)
        _setter("resource_group_id", resource_group_id)
        _setter("start_time", start_time)
        _setter("start_time_type", start_time_type)
        _setter("status", status)
        _setter("total_assurance_times", total_assurance_times)
        _setter("used_assurance_times", used_assurance_times)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="allocatedResources")
    def allocated_resources(self) -> Sequence['outputs.GetElasticityAssurancesAssuranceAllocatedResourceResult']:
        """
        Details of resource allocation.
        """
        return pulumi.get(self, "allocated_resources")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of flexible guarantee service.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="elasticityAssuranceId")
    def elasticity_assurance_id(self) -> str:
        """
        The first ID of the resource
        """
        return pulumi.get(self, "elasticity_assurance_id")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        Flexible guarantee service failure time.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of flexible guarantee service.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> str:
        """
        The billing method of the instance. Possible value: PostPaid. Currently, only pay-as-you-go is supported.
        """
        return pulumi.get(self, "instance_charge_type")

    @property
    @pulumi.getter(name="privatePoolOptionsId")
    def private_pool_options_id(self) -> str:
        """
        The ID of the elasticity assurance.
        """
        return pulumi.get(self, "private_pool_options_id")

    @property
    @pulumi.getter(name="privatePoolOptionsMatchCriteria")
    def private_pool_options_match_criteria(self) -> str:
        """
        The matching mode of flexible guarantee service. Possible values:-Open: flexible guarantee service for Open mode.-Target: specifies the flexible guarantee service of the mode.
        """
        return pulumi.get(self, "private_pool_options_match_criteria")

    @property
    @pulumi.getter(name="privatePoolOptionsName")
    def private_pool_options_name(self) -> str:
        """
        The name of the elasticity assurance.
        """
        return pulumi.get(self, "private_pool_options_name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Flexible guarantee service effective time.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="startTimeType")
    def start_time_type(self) -> str:
        """
        Flexible guarantee effective way. Possible values:-Now: Effective immediately.-Later: the specified time takes effect.
        """
        return pulumi.get(self, "start_time_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of flexible guarantee services. Possible values: `All`, `Preparing`, `Prepared`, `Active`, `Released`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="totalAssuranceTimes")
    def total_assurance_times(self) -> str:
        """
        The total number of flexible guarantee services.
        """
        return pulumi.get(self, "total_assurance_times")

    @property
    @pulumi.getter(name="usedAssuranceTimes")
    def used_assurance_times(self) -> int:
        """
        This parameter is not yet available.
        """
        return pulumi.get(self, "used_assurance_times")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        The tag key-value pair information bound by the elastic guarantee service.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetElasticityAssurancesAssuranceAllocatedResourceResult(dict):
    def __init__(__self__, *,
                 instance_type: str,
                 total_amount: int,
                 used_amount: int,
                 zone_id: str):
        """
        :param str instance_type: Instance type.
        :param int total_amount: The total number of instances that need to be reserved within an instance type.
        :param int used_amount: The number of instances that have been used.
        :param str zone_id: The zone ID.
        """
        GetElasticityAssurancesAssuranceAllocatedResourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            total_amount=total_amount,
            used_amount=used_amount,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: Optional[str] = None,
             total_amount: Optional[int] = None,
             used_amount: Optional[int] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if total_amount is None and 'totalAmount' in kwargs:
            total_amount = kwargs['totalAmount']
        if total_amount is None:
            raise TypeError("Missing 'total_amount' argument")
        if used_amount is None and 'usedAmount' in kwargs:
            used_amount = kwargs['usedAmount']
        if used_amount is None:
            raise TypeError("Missing 'used_amount' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("instance_type", instance_type)
        _setter("total_amount", total_amount)
        _setter("used_amount", used_amount)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="totalAmount")
    def total_amount(self) -> int:
        """
        The total number of instances that need to be reserved within an instance type.
        """
        return pulumi.get(self, "total_amount")

    @property
    @pulumi.getter(name="usedAmount")
    def used_amount(self) -> int:
        """
        The number of instances that have been used.
        """
        return pulumi.get(self, "used_amount")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The zone ID.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetHpcClustersClusterResult(dict):
    def __init__(__self__, *,
                 description: str,
                 hpc_cluster_id: str,
                 id: str,
                 name: str):
        """
        :param str description: The description of ECS Hpc Cluster.
        :param str hpc_cluster_id: The ID of the Hpc Cluster.
        :param str id: The ID of the Hpc Cluster.
        :param str name: The name of ECS Hpc Cluster.
        """
        GetHpcClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            hpc_cluster_id=hpc_cluster_id,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             hpc_cluster_id: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if hpc_cluster_id is None and 'hpcClusterId' in kwargs:
            hpc_cluster_id = kwargs['hpcClusterId']
        if hpc_cluster_id is None:
            raise TypeError("Missing 'hpc_cluster_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("description", description)
        _setter("hpc_cluster_id", hpc_cluster_id)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of ECS Hpc Cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="hpcClusterId")
    def hpc_cluster_id(self) -> str:
        """
        The ID of the Hpc Cluster.
        """
        return pulumi.get(self, "hpc_cluster_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Hpc Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of ECS Hpc Cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 architecture: str,
                 creation_time: str,
                 description: str,
                 disk_device_mappings: Sequence['outputs.GetImagesImageDiskDeviceMappingResult'],
                 id: str,
                 image_id: str,
                 image_owner_alias: str,
                 image_version: str,
                 is_copied: bool,
                 is_self_shared: str,
                 is_subscribed: bool,
                 is_support_io_optimized: bool,
                 name: str,
                 os_name: str,
                 os_name_en: str,
                 os_type: str,
                 platform: str,
                 product_code: str,
                 progress: str,
                 size: int,
                 state: str,
                 status: str,
                 usage: str,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str architecture: The image architecture. Valid values: `i386` and `x86_64`.
        :param str creation_time: Time of creation.
        :param str description: Description of the image.
        :param Sequence['GetImagesImageDiskDeviceMappingArgs'] disk_device_mappings: Description of the system with disks and snapshots under the image.
        :param str id: ID of the image.
        :param str image_id: The ID of the image.
        :param str image_owner_alias: Alias of the image owner.
        :param str image_version: Version of the image.
        :param bool is_subscribed: Whether the user has subscribed to the terms of service for the image product corresponding to the ProductCode.
        :param bool is_support_io_optimized: Specifies whether the image can be used on I/O optimized instances.
        :param str os_name: Display Chinese name of the OS.
        :param str os_name_en: Display English name of the OS.
        :param str os_type: The operating system type of the image. Valid values: `windows` and `linux`.
        :param str product_code: Product code of the image on the image market.
        :param str progress: Progress of image creation, presented in percentages.
        :param int size: Size of the created disk.
        :param str status: The status of the image. The following values are available, Separate multiple parameter values by using commas (,). Default value: `Available`. Valid values:
        :param str usage: Specifies whether to check the validity of the request without actually making the request. Valid values:
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetImagesImageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architecture=architecture,
            creation_time=creation_time,
            description=description,
            disk_device_mappings=disk_device_mappings,
            id=id,
            image_id=image_id,
            image_owner_alias=image_owner_alias,
            image_version=image_version,
            is_copied=is_copied,
            is_self_shared=is_self_shared,
            is_subscribed=is_subscribed,
            is_support_io_optimized=is_support_io_optimized,
            name=name,
            os_name=os_name,
            os_name_en=os_name_en,
            os_type=os_type,
            platform=platform,
            product_code=product_code,
            progress=progress,
            size=size,
            state=state,
            status=status,
            usage=usage,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architecture: Optional[str] = None,
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             disk_device_mappings: Optional[Sequence['outputs.GetImagesImageDiskDeviceMappingResult']] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             image_owner_alias: Optional[str] = None,
             image_version: Optional[str] = None,
             is_copied: Optional[bool] = None,
             is_self_shared: Optional[str] = None,
             is_subscribed: Optional[bool] = None,
             is_support_io_optimized: Optional[bool] = None,
             name: Optional[str] = None,
             os_name: Optional[str] = None,
             os_name_en: Optional[str] = None,
             os_type: Optional[str] = None,
             platform: Optional[str] = None,
             product_code: Optional[str] = None,
             progress: Optional[str] = None,
             size: Optional[int] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             usage: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if architecture is None:
            raise TypeError("Missing 'architecture' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disk_device_mappings is None and 'diskDeviceMappings' in kwargs:
            disk_device_mappings = kwargs['diskDeviceMappings']
        if disk_device_mappings is None:
            raise TypeError("Missing 'disk_device_mappings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if image_owner_alias is None and 'imageOwnerAlias' in kwargs:
            image_owner_alias = kwargs['imageOwnerAlias']
        if image_owner_alias is None:
            raise TypeError("Missing 'image_owner_alias' argument")
        if image_version is None and 'imageVersion' in kwargs:
            image_version = kwargs['imageVersion']
        if image_version is None:
            raise TypeError("Missing 'image_version' argument")
        if is_copied is None and 'isCopied' in kwargs:
            is_copied = kwargs['isCopied']
        if is_copied is None:
            raise TypeError("Missing 'is_copied' argument")
        if is_self_shared is None and 'isSelfShared' in kwargs:
            is_self_shared = kwargs['isSelfShared']
        if is_self_shared is None:
            raise TypeError("Missing 'is_self_shared' argument")
        if is_subscribed is None and 'isSubscribed' in kwargs:
            is_subscribed = kwargs['isSubscribed']
        if is_subscribed is None:
            raise TypeError("Missing 'is_subscribed' argument")
        if is_support_io_optimized is None and 'isSupportIoOptimized' in kwargs:
            is_support_io_optimized = kwargs['isSupportIoOptimized']
        if is_support_io_optimized is None:
            raise TypeError("Missing 'is_support_io_optimized' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if os_name is None and 'osName' in kwargs:
            os_name = kwargs['osName']
        if os_name is None:
            raise TypeError("Missing 'os_name' argument")
        if os_name_en is None and 'osNameEn' in kwargs:
            os_name_en = kwargs['osNameEn']
        if os_name_en is None:
            raise TypeError("Missing 'os_name_en' argument")
        if os_type is None and 'osType' in kwargs:
            os_type = kwargs['osType']
        if os_type is None:
            raise TypeError("Missing 'os_type' argument")
        if platform is None:
            raise TypeError("Missing 'platform' argument")
        if product_code is None and 'productCode' in kwargs:
            product_code = kwargs['productCode']
        if product_code is None:
            raise TypeError("Missing 'product_code' argument")
        if progress is None:
            raise TypeError("Missing 'progress' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if usage is None:
            raise TypeError("Missing 'usage' argument")

        _setter("architecture", architecture)
        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("disk_device_mappings", disk_device_mappings)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("image_owner_alias", image_owner_alias)
        _setter("image_version", image_version)
        _setter("is_copied", is_copied)
        _setter("is_self_shared", is_self_shared)
        _setter("is_subscribed", is_subscribed)
        _setter("is_support_io_optimized", is_support_io_optimized)
        _setter("name", name)
        _setter("os_name", os_name)
        _setter("os_name_en", os_name_en)
        _setter("os_type", os_type)
        _setter("platform", platform)
        _setter("product_code", product_code)
        _setter("progress", progress)
        _setter("size", size)
        _setter("state", state)
        _setter("status", status)
        _setter("usage", usage)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def architecture(self) -> str:
        """
        The image architecture. Valid values: `i386` and `x86_64`.
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Time of creation.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the image.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskDeviceMappings")
    def disk_device_mappings(self) -> Sequence['outputs.GetImagesImageDiskDeviceMappingResult']:
        """
        Description of the system with disks and snapshots under the image.
        """
        return pulumi.get(self, "disk_device_mappings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the image.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The ID of the image.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="imageOwnerAlias")
    def image_owner_alias(self) -> str:
        """
        Alias of the image owner.
        """
        return pulumi.get(self, "image_owner_alias")

    @property
    @pulumi.getter(name="imageVersion")
    def image_version(self) -> str:
        """
        Version of the image.
        """
        return pulumi.get(self, "image_version")

    @property
    @pulumi.getter(name="isCopied")
    def is_copied(self) -> bool:
        return pulumi.get(self, "is_copied")

    @property
    @pulumi.getter(name="isSelfShared")
    def is_self_shared(self) -> str:
        return pulumi.get(self, "is_self_shared")

    @property
    @pulumi.getter(name="isSubscribed")
    def is_subscribed(self) -> bool:
        """
        Whether the user has subscribed to the terms of service for the image product corresponding to the ProductCode.
        """
        return pulumi.get(self, "is_subscribed")

    @property
    @pulumi.getter(name="isSupportIoOptimized")
    def is_support_io_optimized(self) -> bool:
        """
        Specifies whether the image can be used on I/O optimized instances.
        """
        return pulumi.get(self, "is_support_io_optimized")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osName")
    def os_name(self) -> str:
        """
        Display Chinese name of the OS.
        """
        return pulumi.get(self, "os_name")

    @property
    @pulumi.getter(name="osNameEn")
    def os_name_en(self) -> str:
        """
        Display English name of the OS.
        """
        return pulumi.get(self, "os_name_en")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> str:
        """
        The operating system type of the image. Valid values: `windows` and `linux`.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter
    def platform(self) -> str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter(name="productCode")
    def product_code(self) -> str:
        """
        Product code of the image on the image market.
        """
        return pulumi.get(self, "product_code")

    @property
    @pulumi.getter
    def progress(self) -> str:
        """
        Progress of image creation, presented in percentages.
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the created disk.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the image. The following values are available, Separate multiple parameter values by using commas (,). Default value: `Available`. Valid values:
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def usage(self) -> str:
        """
        Specifies whether to check the validity of the request without actually making the request. Valid values:
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetImagesImageDiskDeviceMappingResult(dict):
    def __init__(__self__, *,
                 device: str,
                 size: str,
                 snapshot_id: str):
        """
        :param str device: Device information of the created disk: such as /dev/xvdb.
        :param str size: Size of the created disk.
        :param str snapshot_id: The ID of the snapshot used to create the custom image.
        """
        GetImagesImageDiskDeviceMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device=device,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device: Optional[str] = None,
             size: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device is None:
            raise TypeError("Missing 'device' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")

        _setter("device", device)
        _setter("size", size)
        _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        Device information of the created disk: such as /dev/xvdb.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Size of the created disk.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        The ID of the snapshot used to create the custom image.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class GetInstanceTypeFamiliesFamilyResult(dict):
    def __init__(__self__, *,
                 generation: str,
                 id: str,
                 zone_ids: Sequence[str]):
        """
        :param str generation: The generation of the instance type family, Valid values: `ecs-1`, `ecs-2`, `ecs-3`, `ecs-4`, `ecs-5`, `ecs-6`. For more information, see [Instance type families](https://www.alibabacloud.com/help/doc-detail/25378.htm).
        :param str id: ID of the instance type family.
        :param Sequence[str] zone_ids: A list of Zone to launch the instance.
        """
        GetInstanceTypeFamiliesFamilyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            generation=generation,
            id=id,
            zone_ids=zone_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             generation: Optional[str] = None,
             id: Optional[str] = None,
             zone_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if generation is None:
            raise TypeError("Missing 'generation' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if zone_ids is None and 'zoneIds' in kwargs:
            zone_ids = kwargs['zoneIds']
        if zone_ids is None:
            raise TypeError("Missing 'zone_ids' argument")

        _setter("generation", generation)
        _setter("id", id)
        _setter("zone_ids", zone_ids)

    @property
    @pulumi.getter
    def generation(self) -> str:
        """
        The generation of the instance type family, Valid values: `ecs-1`, `ecs-2`, `ecs-3`, `ecs-4`, `ecs-5`, `ecs-6`. For more information, see [Instance type families](https://www.alibabacloud.com/help/doc-detail/25378.htm).
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the instance type family.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="zoneIds")
    def zone_ids(self) -> Sequence[str]:
        """
        A list of Zone to launch the instance.
        """
        return pulumi.get(self, "zone_ids")


@pulumi.output_type
class GetInstanceTypesInstanceTypeResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[str],
                 burstable_instance: 'outputs.GetInstanceTypesInstanceTypeBurstableInstanceResult',
                 cpu_core_count: int,
                 eni_amount: int,
                 family: str,
                 gpu: 'outputs.GetInstanceTypesInstanceTypeGpuResult',
                 id: str,
                 local_storage: 'outputs.GetInstanceTypesInstanceTypeLocalStorageResult',
                 memory_size: float,
                 nvme_support: str,
                 price: str):
        """
        :param Sequence[str] availability_zones: List of availability zones that support the instance type.
        :param 'GetInstanceTypesInstanceTypeBurstableInstanceArgs' burstable_instance: The burstable instance attribution:
               - initial_credit: The initial CPU credit of a burstable instance.
               - baseline_credit:  The compute performance benchmark CPU credit of a burstable instance.
        :param int cpu_core_count: Filter the results to a specific number of cpu cores.
        :param int eni_amount: Filter the result whose network interface number is no more than `eni_amount`.
        :param str family: The instance type family.
        :param 'GetInstanceTypesInstanceTypeGpuArgs' gpu: The GPU attribution of an instance type:
               - amount: The amount of GPU of an instance type.
               - category: The category of GPU of an instance type.
        :param str id: ID of the instance type.
        :param 'GetInstanceTypesInstanceTypeLocalStorageArgs' local_storage: Local storage of an instance type:
               - capacity: The capacity of a local storage in GB.
               - amount:  The number of local storage devices that an instance has been attached to.
               - category: The category of local storage that an instance has been attached to.
        :param float memory_size: Filter the results to a specific memory size in GB.
        :param str nvme_support: Indicates whether the cloud disk can be attached by using the nonvolatile memory express (NVMe) protocol. Valid values:
               - required: The cloud disk can be attached by using the NVMe protocol.
               - unsupported: The cloud disk cannot be attached by using the NVMe protocol.
        """
        GetInstanceTypesInstanceTypeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zones=availability_zones,
            burstable_instance=burstable_instance,
            cpu_core_count=cpu_core_count,
            eni_amount=eni_amount,
            family=family,
            gpu=gpu,
            id=id,
            local_storage=local_storage,
            memory_size=memory_size,
            nvme_support=nvme_support,
            price=price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zones: Optional[Sequence[str]] = None,
             burstable_instance: Optional['outputs.GetInstanceTypesInstanceTypeBurstableInstanceResult'] = None,
             cpu_core_count: Optional[int] = None,
             eni_amount: Optional[int] = None,
             family: Optional[str] = None,
             gpu: Optional['outputs.GetInstanceTypesInstanceTypeGpuResult'] = None,
             id: Optional[str] = None,
             local_storage: Optional['outputs.GetInstanceTypesInstanceTypeLocalStorageResult'] = None,
             memory_size: Optional[float] = None,
             nvme_support: Optional[str] = None,
             price: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zones is None and 'availabilityZones' in kwargs:
            availability_zones = kwargs['availabilityZones']
        if availability_zones is None:
            raise TypeError("Missing 'availability_zones' argument")
        if burstable_instance is None and 'burstableInstance' in kwargs:
            burstable_instance = kwargs['burstableInstance']
        if burstable_instance is None:
            raise TypeError("Missing 'burstable_instance' argument")
        if cpu_core_count is None and 'cpuCoreCount' in kwargs:
            cpu_core_count = kwargs['cpuCoreCount']
        if cpu_core_count is None:
            raise TypeError("Missing 'cpu_core_count' argument")
        if eni_amount is None and 'eniAmount' in kwargs:
            eni_amount = kwargs['eniAmount']
        if eni_amount is None:
            raise TypeError("Missing 'eni_amount' argument")
        if family is None:
            raise TypeError("Missing 'family' argument")
        if gpu is None:
            raise TypeError("Missing 'gpu' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if local_storage is None and 'localStorage' in kwargs:
            local_storage = kwargs['localStorage']
        if local_storage is None:
            raise TypeError("Missing 'local_storage' argument")
        if memory_size is None and 'memorySize' in kwargs:
            memory_size = kwargs['memorySize']
        if memory_size is None:
            raise TypeError("Missing 'memory_size' argument")
        if nvme_support is None and 'nvmeSupport' in kwargs:
            nvme_support = kwargs['nvmeSupport']
        if nvme_support is None:
            raise TypeError("Missing 'nvme_support' argument")
        if price is None:
            raise TypeError("Missing 'price' argument")

        _setter("availability_zones", availability_zones)
        _setter("burstable_instance", burstable_instance)
        _setter("cpu_core_count", cpu_core_count)
        _setter("eni_amount", eni_amount)
        _setter("family", family)
        _setter("gpu", gpu)
        _setter("id", id)
        _setter("local_storage", local_storage)
        _setter("memory_size", memory_size)
        _setter("nvme_support", nvme_support)
        _setter("price", price)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        """
        List of availability zones that support the instance type.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="burstableInstance")
    def burstable_instance(self) -> 'outputs.GetInstanceTypesInstanceTypeBurstableInstanceResult':
        """
        The burstable instance attribution:
        - initial_credit: The initial CPU credit of a burstable instance.
        - baseline_credit:  The compute performance benchmark CPU credit of a burstable instance.
        """
        return pulumi.get(self, "burstable_instance")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        Filter the results to a specific number of cpu cores.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="eniAmount")
    def eni_amount(self) -> int:
        """
        Filter the result whose network interface number is no more than `eni_amount`.
        """
        return pulumi.get(self, "eni_amount")

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The instance type family.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gpu(self) -> 'outputs.GetInstanceTypesInstanceTypeGpuResult':
        """
        The GPU attribution of an instance type:
        - amount: The amount of GPU of an instance type.
        - category: The category of GPU of an instance type.
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the instance type.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> 'outputs.GetInstanceTypesInstanceTypeLocalStorageResult':
        """
        Local storage of an instance type:
        - capacity: The capacity of a local storage in GB.
        - amount:  The number of local storage devices that an instance has been attached to.
        - category: The category of local storage that an instance has been attached to.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> float:
        """
        Filter the results to a specific memory size in GB.
        """
        return pulumi.get(self, "memory_size")

    @property
    @pulumi.getter(name="nvmeSupport")
    def nvme_support(self) -> str:
        """
        Indicates whether the cloud disk can be attached by using the nonvolatile memory express (NVMe) protocol. Valid values:
        - required: The cloud disk can be attached by using the NVMe protocol.
        - unsupported: The cloud disk cannot be attached by using the NVMe protocol.
        """
        return pulumi.get(self, "nvme_support")

    @property
    @pulumi.getter
    def price(self) -> str:
        return pulumi.get(self, "price")


@pulumi.output_type
class GetInstanceTypesInstanceTypeBurstableInstanceResult(dict):
    def __init__(__self__, *,
                 baseline_credit: str,
                 initial_credit: str):
        GetInstanceTypesInstanceTypeBurstableInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baseline_credit=baseline_credit,
            initial_credit=initial_credit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baseline_credit: Optional[str] = None,
             initial_credit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if baseline_credit is None and 'baselineCredit' in kwargs:
            baseline_credit = kwargs['baselineCredit']
        if baseline_credit is None:
            raise TypeError("Missing 'baseline_credit' argument")
        if initial_credit is None and 'initialCredit' in kwargs:
            initial_credit = kwargs['initialCredit']
        if initial_credit is None:
            raise TypeError("Missing 'initial_credit' argument")

        _setter("baseline_credit", baseline_credit)
        _setter("initial_credit", initial_credit)

    @property
    @pulumi.getter(name="baselineCredit")
    def baseline_credit(self) -> str:
        return pulumi.get(self, "baseline_credit")

    @property
    @pulumi.getter(name="initialCredit")
    def initial_credit(self) -> str:
        return pulumi.get(self, "initial_credit")


@pulumi.output_type
class GetInstanceTypesInstanceTypeGpuResult(dict):
    def __init__(__self__, *,
                 amount: str,
                 category: str):
        GetInstanceTypesInstanceTypeGpuResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            category=category,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[str] = None,
             category: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if category is None:
            raise TypeError("Missing 'category' argument")

        _setter("amount", amount)
        _setter("category", category)

    @property
    @pulumi.getter
    def amount(self) -> str:
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def category(self) -> str:
        return pulumi.get(self, "category")


@pulumi.output_type
class GetInstanceTypesInstanceTypeLocalStorageResult(dict):
    def __init__(__self__, *,
                 amount: str,
                 capacity: str,
                 category: str):
        GetInstanceTypesInstanceTypeLocalStorageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            capacity=capacity,
            category=category,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[str] = None,
             capacity: Optional[str] = None,
             category: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if capacity is None:
            raise TypeError("Missing 'capacity' argument")
        if category is None:
            raise TypeError("Missing 'category' argument")

        _setter("amount", amount)
        _setter("capacity", capacity)
        _setter("category", category)

    @property
    @pulumi.getter
    def amount(self) -> str:
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def capacity(self) -> str:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def category(self) -> str:
        return pulumi.get(self, "category")


@pulumi.output_type
class GetInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 creation_time: str,
                 description: str,
                 disk_device_mappings: Sequence['outputs.GetInstancesInstanceDiskDeviceMappingResult'],
                 eip: str,
                 id: str,
                 image_id: str,
                 instance_charge_type: str,
                 instance_type: str,
                 internet_charge_type: str,
                 internet_max_bandwidth_out: int,
                 key_name: str,
                 name: str,
                 private_ip: str,
                 public_ip: str,
                 ram_role_name: str,
                 region_id: str,
                 resource_group_id: str,
                 security_groups: Sequence[str],
                 spot_strategy: str,
                 status: str,
                 vpc_id: str,
                 vswitch_id: str,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str availability_zone: Availability zone where instances are located.
        :param str creation_time: Instance creation time.
        :param str description: Instance description.
        :param Sequence['GetInstancesInstanceDiskDeviceMappingArgs'] disk_device_mappings: Description of the attached disks.
        :param str eip: EIP address the VPC instance is using.
        :param str id: ID of the instance.
        :param str image_id: The image ID of some ECS instance used.
        :param str instance_charge_type: Instance charge type.
        :param str instance_type: Instance type.
        :param str internet_charge_type: Instance network charge type.
        :param int internet_max_bandwidth_out: Max output bandwidth for internet.
        :param str key_name: Key pair the instance is using.
        :param str name: Instance name.
        :param str private_ip: Instance private IP address.
        :param str public_ip: Instance public IP address.
        :param str ram_role_name: The RAM role name which the instance attaches.
        :param str region_id: Region ID the instance belongs to.
        :param str resource_group_id: The ID of resource group which the instance belongs.
        :param Sequence[str] security_groups: List of security group IDs the instance belongs to.
        :param str spot_strategy: Spot strategy the instance is using.
        :param str status: Instance status. Valid values: "Creating", "Starting", "Running", "Stopping" and "Stopped". If undefined, all statuses are considered.
        :param str vpc_id: ID of the VPC linked to the instances.
        :param str vswitch_id: ID of the VSwitch linked to the instances.
        :param Mapping[str, Any] tags: A map of tags assigned to the ECS instances. It must be in the format:
        """
        GetInstancesInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            creation_time=creation_time,
            description=description,
            disk_device_mappings=disk_device_mappings,
            eip=eip,
            id=id,
            image_id=image_id,
            instance_charge_type=instance_charge_type,
            instance_type=instance_type,
            internet_charge_type=internet_charge_type,
            internet_max_bandwidth_out=internet_max_bandwidth_out,
            key_name=key_name,
            name=name,
            private_ip=private_ip,
            public_ip=public_ip,
            ram_role_name=ram_role_name,
            region_id=region_id,
            resource_group_id=resource_group_id,
            security_groups=security_groups,
            spot_strategy=spot_strategy,
            status=status,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             disk_device_mappings: Optional[Sequence['outputs.GetInstancesInstanceDiskDeviceMappingResult']] = None,
             eip: Optional[str] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_charge_type: Optional[str] = None,
             instance_type: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             internet_max_bandwidth_out: Optional[int] = None,
             key_name: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_ip: Optional[str] = None,
             ram_role_name: Optional[str] = None,
             region_id: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             security_groups: Optional[Sequence[str]] = None,
             spot_strategy: Optional[str] = None,
             status: Optional[str] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disk_device_mappings is None and 'diskDeviceMappings' in kwargs:
            disk_device_mappings = kwargs['diskDeviceMappings']
        if disk_device_mappings is None:
            raise TypeError("Missing 'disk_device_mappings' argument")
        if eip is None:
            raise TypeError("Missing 'eip' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_charge_type is None and 'instanceChargeType' in kwargs:
            instance_charge_type = kwargs['instanceChargeType']
        if instance_charge_type is None:
            raise TypeError("Missing 'instance_charge_type' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if internet_max_bandwidth_out is None and 'internetMaxBandwidthOut' in kwargs:
            internet_max_bandwidth_out = kwargs['internetMaxBandwidthOut']
        if internet_max_bandwidth_out is None:
            raise TypeError("Missing 'internet_max_bandwidth_out' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")
        if ram_role_name is None and 'ramRoleName' in kwargs:
            ram_role_name = kwargs['ramRoleName']
        if ram_role_name is None:
            raise TypeError("Missing 'ram_role_name' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if security_groups is None:
            raise TypeError("Missing 'security_groups' argument")
        if spot_strategy is None and 'spotStrategy' in kwargs:
            spot_strategy = kwargs['spotStrategy']
        if spot_strategy is None:
            raise TypeError("Missing 'spot_strategy' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("availability_zone", availability_zone)
        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("disk_device_mappings", disk_device_mappings)
        _setter("eip", eip)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("instance_charge_type", instance_charge_type)
        _setter("instance_type", instance_type)
        _setter("internet_charge_type", internet_charge_type)
        _setter("internet_max_bandwidth_out", internet_max_bandwidth_out)
        _setter("key_name", key_name)
        _setter("name", name)
        _setter("private_ip", private_ip)
        _setter("public_ip", public_ip)
        _setter("ram_role_name", ram_role_name)
        _setter("region_id", region_id)
        _setter("resource_group_id", resource_group_id)
        _setter("security_groups", security_groups)
        _setter("spot_strategy", spot_strategy)
        _setter("status", status)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        Availability zone where instances are located.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Instance creation time.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Instance description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskDeviceMappings")
    def disk_device_mappings(self) -> Sequence['outputs.GetInstancesInstanceDiskDeviceMappingResult']:
        """
        Description of the attached disks.
        """
        return pulumi.get(self, "disk_device_mappings")

    @property
    @pulumi.getter
    def eip(self) -> str:
        """
        EIP address the VPC instance is using.
        """
        return pulumi.get(self, "eip")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The image ID of some ECS instance used.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceChargeType")
    def instance_charge_type(self) -> str:
        """
        Instance charge type.
        """
        return pulumi.get(self, "instance_charge_type")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        Instance network charge type.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="internetMaxBandwidthOut")
    def internet_max_bandwidth_out(self) -> int:
        """
        Max output bandwidth for internet.
        """
        return pulumi.get(self, "internet_max_bandwidth_out")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        Key pair the instance is using.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Instance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Instance private IP address.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        Instance public IP address.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="ramRoleName")
    def ram_role_name(self) -> str:
        """
        The RAM role name which the instance attaches.
        """
        return pulumi.get(self, "ram_role_name")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        Region ID the instance belongs to.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of resource group which the instance belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[str]:
        """
        List of security group IDs the instance belongs to.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="spotStrategy")
    def spot_strategy(self) -> str:
        """
        Spot strategy the instance is using.
        """
        return pulumi.get(self, "spot_strategy")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Instance status. Valid values: "Creating", "Starting", "Running", "Stopping" and "Stopped". If undefined, all statuses are considered.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC linked to the instances.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        ID of the VSwitch linked to the instances.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        A map of tags assigned to the ECS instances. It must be in the format:
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetInstancesInstanceDiskDeviceMappingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 device: str,
                 disk_id: str,
                 disk_name: str,
                 size: int,
                 type: str):
        """
        :param str category: Cloud disk category.
        :param str device: Device information of the created disk: such as /dev/xvdb.
        :param str disk_id: The ID of the Disk.
        :param str disk_name: The name of the Disk.
        :param int size: Size of the created disk.
        :param str type: Cloud disk type: system disk or data disk.
        """
        GetInstancesInstanceDiskDeviceMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            device=device,
            disk_id=disk_id,
            disk_name=disk_name,
            size=size,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             device: Optional[str] = None,
             disk_id: Optional[str] = None,
             disk_name: Optional[str] = None,
             size: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if device is None:
            raise TypeError("Missing 'device' argument")
        if disk_id is None and 'diskId' in kwargs:
            disk_id = kwargs['diskId']
        if disk_id is None:
            raise TypeError("Missing 'disk_id' argument")
        if disk_name is None and 'diskName' in kwargs:
            disk_name = kwargs['diskName']
        if disk_name is None:
            raise TypeError("Missing 'disk_name' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("category", category)
        _setter("device", device)
        _setter("disk_id", disk_id)
        _setter("disk_name", disk_name)
        _setter("size", size)
        _setter("type", type)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Cloud disk category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        Device information of the created disk: such as /dev/xvdb.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        The ID of the Disk.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        The name of the Disk.
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the created disk.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Cloud disk type: system disk or data disk.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKeyPairsKeyPairResult(dict):
    def __init__(__self__, *,
                 finger_print: str,
                 id: str,
                 instances: Sequence['outputs.GetKeyPairsKeyPairInstanceResult'],
                 key_name: str,
                 key_pair_name: str,
                 resource_group_id: str,
                 tags: Mapping[str, Any]):
        """
        :param str finger_print: A finger print used to retrieve specified key pair.
        :param str id: ID of the key pair.
        :param Sequence['GetKeyPairsKeyPairInstanceArgs'] instances: A list of ECS instances that has been bound this key pair.
        :param str key_name: Name of the key pair.
        :param str resource_group_id: The Id of resource group which the key pair belongs.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetKeyPairsKeyPairResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            finger_print=finger_print,
            id=id,
            instances=instances,
            key_name=key_name,
            key_pair_name=key_pair_name,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             finger_print: Optional[str] = None,
             id: Optional[str] = None,
             instances: Optional[Sequence['outputs.GetKeyPairsKeyPairInstanceResult']] = None,
             key_name: Optional[str] = None,
             key_pair_name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if finger_print is None and 'fingerPrint' in kwargs:
            finger_print = kwargs['fingerPrint']
        if finger_print is None:
            raise TypeError("Missing 'finger_print' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instances is None:
            raise TypeError("Missing 'instances' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if key_pair_name is None and 'keyPairName' in kwargs:
            key_pair_name = kwargs['keyPairName']
        if key_pair_name is None:
            raise TypeError("Missing 'key_pair_name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("finger_print", finger_print)
        _setter("id", id)
        _setter("instances", instances)
        _setter("key_name", key_name)
        _setter("key_pair_name", key_pair_name)
        _setter("resource_group_id", resource_group_id)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="fingerPrint")
    def finger_print(self) -> str:
        """
        A finger print used to retrieve specified key pair.
        """
        return pulumi.get(self, "finger_print")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the key pair.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetKeyPairsKeyPairInstanceResult']:
        """
        A list of ECS instances that has been bound this key pair.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        Name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> str:
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which the key pair belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetKeyPairsKeyPairInstanceResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 description: str,
                 image_id: str,
                 instance_id: str,
                 instance_name: str,
                 instance_type: str,
                 key_name: str,
                 private_ip: str,
                 public_ip: str,
                 region_id: str,
                 status: str,
                 vswitch_id: str):
        """
        :param str availability_zone: The ID of the availability zone where the ECS instance is located.
        :param str instance_id: The ID of the ECS instance.
        :param str instance_name: The name of the ECS instance.
        :param str key_name: Name of the key pair.
        :param str private_ip: The private IP address of the ECS instance.
        :param str public_ip: The public IP address or EIP of the ECS instance.
        :param str vswitch_id: The ID of the VSwitch attached to the ECS instance.
        """
        GetKeyPairsKeyPairInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            description=description,
            image_id=image_id,
            instance_id=instance_id,
            instance_name=instance_name,
            instance_type=instance_type,
            key_name=key_name,
            private_ip=private_ip,
            public_ip=public_ip,
            region_id=region_id,
            status=status,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             description: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_name: Optional[str] = None,
             instance_type: Optional[str] = None,
             key_name: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_ip: Optional[str] = None,
             region_id: Optional[str] = None,
             status: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("availability_zone", availability_zone)
        _setter("description", description)
        _setter("image_id", image_id)
        _setter("instance_id", instance_id)
        _setter("instance_name", instance_name)
        _setter("instance_type", instance_type)
        _setter("key_name", key_name)
        _setter("private_ip", private_ip)
        _setter("public_ip", public_ip)
        _setter("region_id", region_id)
        _setter("status", status)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of the availability zone where the ECS instance is located.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The name of the ECS instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        Name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of the ECS instance.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address or EIP of the ECS instance.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch attached to the ECS instance.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetKeyPairsPairResult(dict):
    def __init__(__self__, *,
                 finger_print: str,
                 id: str,
                 instances: Sequence['outputs.GetKeyPairsPairInstanceResult'],
                 key_name: str,
                 key_pair_name: str,
                 resource_group_id: str,
                 tags: Mapping[str, Any]):
        """
        :param str finger_print: A finger print used to retrieve specified key pair.
        :param str id: ID of the key pair.
        :param Sequence['GetKeyPairsPairInstanceArgs'] instances: A list of ECS instances that has been bound this key pair.
        :param str key_name: Name of the key pair.
        :param str resource_group_id: The Id of resource group which the key pair belongs.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetKeyPairsPairResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            finger_print=finger_print,
            id=id,
            instances=instances,
            key_name=key_name,
            key_pair_name=key_pair_name,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             finger_print: Optional[str] = None,
             id: Optional[str] = None,
             instances: Optional[Sequence['outputs.GetKeyPairsPairInstanceResult']] = None,
             key_name: Optional[str] = None,
             key_pair_name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if finger_print is None and 'fingerPrint' in kwargs:
            finger_print = kwargs['fingerPrint']
        if finger_print is None:
            raise TypeError("Missing 'finger_print' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instances is None:
            raise TypeError("Missing 'instances' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if key_pair_name is None and 'keyPairName' in kwargs:
            key_pair_name = kwargs['keyPairName']
        if key_pair_name is None:
            raise TypeError("Missing 'key_pair_name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("finger_print", finger_print)
        _setter("id", id)
        _setter("instances", instances)
        _setter("key_name", key_name)
        _setter("key_pair_name", key_pair_name)
        _setter("resource_group_id", resource_group_id)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="fingerPrint")
    def finger_print(self) -> str:
        """
        A finger print used to retrieve specified key pair.
        """
        return pulumi.get(self, "finger_print")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the key pair.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetKeyPairsPairInstanceResult']:
        """
        A list of ECS instances that has been bound this key pair.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        Name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> str:
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which the key pair belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetKeyPairsPairInstanceResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 description: str,
                 image_id: str,
                 instance_id: str,
                 instance_name: str,
                 instance_type: str,
                 key_name: str,
                 private_ip: str,
                 public_ip: str,
                 region_id: str,
                 status: str,
                 vswitch_id: str):
        """
        :param str availability_zone: The ID of the availability zone where the ECS instance is located.
        :param str instance_id: The ID of the ECS instance.
        :param str instance_name: The name of the ECS instance.
        :param str key_name: Name of the key pair.
        :param str private_ip: The private IP address of the ECS instance.
        :param str public_ip: The public IP address or EIP of the ECS instance.
        :param str vswitch_id: The ID of the VSwitch attached to the ECS instance.
        """
        GetKeyPairsPairInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            description=description,
            image_id=image_id,
            instance_id=instance_id,
            instance_name=instance_name,
            instance_type=instance_type,
            key_name=key_name,
            private_ip=private_ip,
            public_ip=public_ip,
            region_id=region_id,
            status=status,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             description: Optional[str] = None,
             image_id: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_name: Optional[str] = None,
             instance_type: Optional[str] = None,
             key_name: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_ip: Optional[str] = None,
             region_id: Optional[str] = None,
             status: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if public_ip is None and 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if public_ip is None:
            raise TypeError("Missing 'public_ip' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("availability_zone", availability_zone)
        _setter("description", description)
        _setter("image_id", image_id)
        _setter("instance_id", instance_id)
        _setter("instance_name", instance_name)
        _setter("instance_type", instance_type)
        _setter("key_name", key_name)
        _setter("private_ip", private_ip)
        _setter("public_ip", public_ip)
        _setter("region_id", region_id)
        _setter("status", status)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of the availability zone where the ECS instance is located.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The name of the ECS instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        Name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of the ECS instance.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address or EIP of the ECS instance.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the VSwitch attached to the ECS instance.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetNetworkInterfacesInterfaceResult(dict):
    def __init__(__self__, *,
                 associated_public_ips: Sequence['outputs.GetNetworkInterfacesInterfaceAssociatedPublicIpResult'],
                 creation_time: str,
                 description: str,
                 id: str,
                 instance_id: str,
                 mac: str,
                 name: str,
                 network_interface_id: str,
                 network_interface_name: str,
                 network_interface_traffic_mode: str,
                 owner_id: str,
                 primary_ip_address: str,
                 private_ip: str,
                 private_ip_addresses: Sequence[str],
                 private_ips: Sequence[str],
                 queue_number: int,
                 resource_group_id: str,
                 security_group_ids: Sequence[str],
                 security_groups: Sequence[str],
                 service_id: int,
                 service_managed: bool,
                 status: str,
                 tags: Mapping[str, Any],
                 type: str,
                 vpc_id: str,
                 vswitch_id: str,
                 zone_id: str):
        """
        :param str creation_time: Creation time of the ENI.
        :param str description: Description of the ENI.
        :param str id: ID of the ENI.
        :param str instance_id: ID of the instance that the ENI is attached to.
        :param str mac: MAC address of the ENI.
        :param str name: Name of the ENI.
        :param str private_ip: Primary private IP of the ENI.
        :param Sequence[str] private_ips: A list of secondary private IP address that is assigned to the ENI.
        :param str resource_group_id: The Id of resource group.
        :param Sequence[str] security_groups: A list of security group that the ENI belongs to.
        :param str status: Current status of the ENI.
        :param Mapping[str, Any] tags: A map of tags assigned to the ENI.
        :param str vpc_id: ID of the VPC that the ENI belongs to.
        :param str vswitch_id: ID of the VSwitch that the ENI is linked to.
        :param str zone_id: ID of the availability zone that the ENI belongs to.
        """
        GetNetworkInterfacesInterfaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associated_public_ips=associated_public_ips,
            creation_time=creation_time,
            description=description,
            id=id,
            instance_id=instance_id,
            mac=mac,
            name=name,
            network_interface_id=network_interface_id,
            network_interface_name=network_interface_name,
            network_interface_traffic_mode=network_interface_traffic_mode,
            owner_id=owner_id,
            primary_ip_address=primary_ip_address,
            private_ip=private_ip,
            private_ip_addresses=private_ip_addresses,
            private_ips=private_ips,
            queue_number=queue_number,
            resource_group_id=resource_group_id,
            security_group_ids=security_group_ids,
            security_groups=security_groups,
            service_id=service_id,
            service_managed=service_managed,
            status=status,
            tags=tags,
            type=type,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associated_public_ips: Optional[Sequence['outputs.GetNetworkInterfacesInterfaceAssociatedPublicIpResult']] = None,
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             mac: Optional[str] = None,
             name: Optional[str] = None,
             network_interface_id: Optional[str] = None,
             network_interface_name: Optional[str] = None,
             network_interface_traffic_mode: Optional[str] = None,
             owner_id: Optional[str] = None,
             primary_ip_address: Optional[str] = None,
             private_ip: Optional[str] = None,
             private_ip_addresses: Optional[Sequence[str]] = None,
             private_ips: Optional[Sequence[str]] = None,
             queue_number: Optional[int] = None,
             resource_group_id: Optional[str] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             security_groups: Optional[Sequence[str]] = None,
             service_id: Optional[int] = None,
             service_managed: Optional[bool] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if associated_public_ips is None and 'associatedPublicIps' in kwargs:
            associated_public_ips = kwargs['associatedPublicIps']
        if associated_public_ips is None:
            raise TypeError("Missing 'associated_public_ips' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if mac is None:
            raise TypeError("Missing 'mac' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_interface_id is None and 'networkInterfaceId' in kwargs:
            network_interface_id = kwargs['networkInterfaceId']
        if network_interface_id is None:
            raise TypeError("Missing 'network_interface_id' argument")
        if network_interface_name is None and 'networkInterfaceName' in kwargs:
            network_interface_name = kwargs['networkInterfaceName']
        if network_interface_name is None:
            raise TypeError("Missing 'network_interface_name' argument")
        if network_interface_traffic_mode is None and 'networkInterfaceTrafficMode' in kwargs:
            network_interface_traffic_mode = kwargs['networkInterfaceTrafficMode']
        if network_interface_traffic_mode is None:
            raise TypeError("Missing 'network_interface_traffic_mode' argument")
        if owner_id is None and 'ownerId' in kwargs:
            owner_id = kwargs['ownerId']
        if owner_id is None:
            raise TypeError("Missing 'owner_id' argument")
        if primary_ip_address is None and 'primaryIpAddress' in kwargs:
            primary_ip_address = kwargs['primaryIpAddress']
        if primary_ip_address is None:
            raise TypeError("Missing 'primary_ip_address' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")
        if private_ip_addresses is None and 'privateIpAddresses' in kwargs:
            private_ip_addresses = kwargs['privateIpAddresses']
        if private_ip_addresses is None:
            raise TypeError("Missing 'private_ip_addresses' argument")
        if private_ips is None and 'privateIps' in kwargs:
            private_ips = kwargs['privateIps']
        if private_ips is None:
            raise TypeError("Missing 'private_ips' argument")
        if queue_number is None and 'queueNumber' in kwargs:
            queue_number = kwargs['queueNumber']
        if queue_number is None:
            raise TypeError("Missing 'queue_number' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if security_group_ids is None:
            raise TypeError("Missing 'security_group_ids' argument")
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']
        if security_groups is None:
            raise TypeError("Missing 'security_groups' argument")
        if service_id is None and 'serviceId' in kwargs:
            service_id = kwargs['serviceId']
        if service_id is None:
            raise TypeError("Missing 'service_id' argument")
        if service_managed is None and 'serviceManaged' in kwargs:
            service_managed = kwargs['serviceManaged']
        if service_managed is None:
            raise TypeError("Missing 'service_managed' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")

        _setter("associated_public_ips", associated_public_ips)
        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("mac", mac)
        _setter("name", name)
        _setter("network_interface_id", network_interface_id)
        _setter("network_interface_name", network_interface_name)
        _setter("network_interface_traffic_mode", network_interface_traffic_mode)
        _setter("owner_id", owner_id)
        _setter("primary_ip_address", primary_ip_address)
        _setter("private_ip", private_ip)
        _setter("private_ip_addresses", private_ip_addresses)
        _setter("private_ips", private_ips)
        _setter("queue_number", queue_number)
        _setter("resource_group_id", resource_group_id)
        _setter("security_group_ids", security_group_ids)
        _setter("security_groups", security_groups)
        _setter("service_id", service_id)
        _setter("service_managed", service_managed)
        _setter("status", status)
        _setter("tags", tags)
        _setter("type", type)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="associatedPublicIps")
    def associated_public_ips(self) -> Sequence['outputs.GetNetworkInterfacesInterfaceAssociatedPublicIpResult']:
        return pulumi.get(self, "associated_public_ips")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Creation time of the ENI.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the ENI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the ENI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of the instance that the ENI is attached to.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        MAC address of the ENI.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the ENI.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="networkInterfaceName")
    def network_interface_name(self) -> str:
        return pulumi.get(self, "network_interface_name")

    @property
    @pulumi.getter(name="networkInterfaceTrafficMode")
    def network_interface_traffic_mode(self) -> str:
        return pulumi.get(self, "network_interface_traffic_mode")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> str:
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter(name="primaryIpAddress")
    def primary_ip_address(self) -> str:
        return pulumi.get(self, "primary_ip_address")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        Primary private IP of the ENI.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Sequence[str]:
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="privateIps")
    def private_ips(self) -> Sequence[str]:
        """
        A list of secondary private IP address that is assigned to the ENI.
        """
        return pulumi.get(self, "private_ips")

    @property
    @pulumi.getter(name="queueNumber")
    def queue_number(self) -> int:
        return pulumi.get(self, "queue_number")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[str]:
        """
        A list of security group that the ENI belongs to.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> int:
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter(name="serviceManaged")
    def service_managed(self) -> bool:
        return pulumi.get(self, "service_managed")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the ENI.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the ENI.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC that the ENI belongs to.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        ID of the VSwitch that the ENI is linked to.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        ID of the availability zone that the ENI belongs to.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetNetworkInterfacesInterfaceAssociatedPublicIpResult(dict):
    def __init__(__self__, *,
                 public_ip_address: str):
        GetNetworkInterfacesInterfaceAssociatedPublicIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_ip_address=public_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_ip_address is None and 'publicIpAddress' in kwargs:
            public_ip_address = kwargs['publicIpAddress']
        if public_ip_address is None:
            raise TypeError("Missing 'public_ip_address' argument")

        _setter("public_ip_address", public_ip_address)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class GetSecurityGroupRulesRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 dest_cidr_ip: str,
                 dest_group_id: str,
                 dest_group_owner_account: str,
                 direction: str,
                 ip_protocol: str,
                 nic_type: str,
                 policy: str,
                 port_range: str,
                 priority: int,
                 source_cidr_ip: str,
                 source_group_id: str,
                 source_group_owner_account: str):
        """
        :param str description: The description of the rule.
        :param str dest_cidr_ip: Target IP address segment for egress authorization.
        :param str dest_group_id: Target security group id for ingress authorization.
        :param str dest_group_owner_account: Alibaba Cloud account of the target security group.
        :param str direction: Authorization direction. Valid values are: `ingress` or `egress`.
        :param str ip_protocol: The IP protocol. Valid values are: `tcp`, `udp`, `icmp`, `gre` and `all`.
        :param str nic_type: Refers to the network type. Can be either `internet` or `intranet`. The default value is `internet`.
        :param str policy: Authorization policy. Can be either `accept` or `drop`. The default value is `accept`.
        :param str port_range: The range of port numbers.
        :param int priority: Rule priority.
        :param str source_cidr_ip: Source IP address segment for ingress authorization.
        :param str source_group_id: Source security group ID for ingress authorization.
        :param str source_group_owner_account: Alibaba Cloud account of the source security group.
        """
        GetSecurityGroupRulesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            dest_cidr_ip=dest_cidr_ip,
            dest_group_id=dest_group_id,
            dest_group_owner_account=dest_group_owner_account,
            direction=direction,
            ip_protocol=ip_protocol,
            nic_type=nic_type,
            policy=policy,
            port_range=port_range,
            priority=priority,
            source_cidr_ip=source_cidr_ip,
            source_group_id=source_group_id,
            source_group_owner_account=source_group_owner_account,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             dest_cidr_ip: Optional[str] = None,
             dest_group_id: Optional[str] = None,
             dest_group_owner_account: Optional[str] = None,
             direction: Optional[str] = None,
             ip_protocol: Optional[str] = None,
             nic_type: Optional[str] = None,
             policy: Optional[str] = None,
             port_range: Optional[str] = None,
             priority: Optional[int] = None,
             source_cidr_ip: Optional[str] = None,
             source_group_id: Optional[str] = None,
             source_group_owner_account: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if dest_cidr_ip is None and 'destCidrIp' in kwargs:
            dest_cidr_ip = kwargs['destCidrIp']
        if dest_cidr_ip is None:
            raise TypeError("Missing 'dest_cidr_ip' argument")
        if dest_group_id is None and 'destGroupId' in kwargs:
            dest_group_id = kwargs['destGroupId']
        if dest_group_id is None:
            raise TypeError("Missing 'dest_group_id' argument")
        if dest_group_owner_account is None and 'destGroupOwnerAccount' in kwargs:
            dest_group_owner_account = kwargs['destGroupOwnerAccount']
        if dest_group_owner_account is None:
            raise TypeError("Missing 'dest_group_owner_account' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if ip_protocol is None and 'ipProtocol' in kwargs:
            ip_protocol = kwargs['ipProtocol']
        if ip_protocol is None:
            raise TypeError("Missing 'ip_protocol' argument")
        if nic_type is None and 'nicType' in kwargs:
            nic_type = kwargs['nicType']
        if nic_type is None:
            raise TypeError("Missing 'nic_type' argument")
        if policy is None:
            raise TypeError("Missing 'policy' argument")
        if port_range is None and 'portRange' in kwargs:
            port_range = kwargs['portRange']
        if port_range is None:
            raise TypeError("Missing 'port_range' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if source_cidr_ip is None and 'sourceCidrIp' in kwargs:
            source_cidr_ip = kwargs['sourceCidrIp']
        if source_cidr_ip is None:
            raise TypeError("Missing 'source_cidr_ip' argument")
        if source_group_id is None and 'sourceGroupId' in kwargs:
            source_group_id = kwargs['sourceGroupId']
        if source_group_id is None:
            raise TypeError("Missing 'source_group_id' argument")
        if source_group_owner_account is None and 'sourceGroupOwnerAccount' in kwargs:
            source_group_owner_account = kwargs['sourceGroupOwnerAccount']
        if source_group_owner_account is None:
            raise TypeError("Missing 'source_group_owner_account' argument")

        _setter("description", description)
        _setter("dest_cidr_ip", dest_cidr_ip)
        _setter("dest_group_id", dest_group_id)
        _setter("dest_group_owner_account", dest_group_owner_account)
        _setter("direction", direction)
        _setter("ip_protocol", ip_protocol)
        _setter("nic_type", nic_type)
        _setter("policy", policy)
        _setter("port_range", port_range)
        _setter("priority", priority)
        _setter("source_cidr_ip", source_cidr_ip)
        _setter("source_group_id", source_group_id)
        _setter("source_group_owner_account", source_group_owner_account)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destCidrIp")
    def dest_cidr_ip(self) -> str:
        """
        Target IP address segment for egress authorization.
        """
        return pulumi.get(self, "dest_cidr_ip")

    @property
    @pulumi.getter(name="destGroupId")
    def dest_group_id(self) -> str:
        """
        Target security group id for ingress authorization.
        """
        return pulumi.get(self, "dest_group_id")

    @property
    @pulumi.getter(name="destGroupOwnerAccount")
    def dest_group_owner_account(self) -> str:
        """
        Alibaba Cloud account of the target security group.
        """
        return pulumi.get(self, "dest_group_owner_account")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Authorization direction. Valid values are: `ingress` or `egress`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        The IP protocol. Valid values are: `tcp`, `udp`, `icmp`, `gre` and `all`.
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> str:
        """
        Refers to the network type. Can be either `internet` or `intranet`. The default value is `internet`.
        """
        return pulumi.get(self, "nic_type")

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        Authorization policy. Can be either `accept` or `drop`. The default value is `accept`.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        """
        The range of port numbers.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Rule priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="sourceCidrIp")
    def source_cidr_ip(self) -> str:
        """
        Source IP address segment for ingress authorization.
        """
        return pulumi.get(self, "source_cidr_ip")

    @property
    @pulumi.getter(name="sourceGroupId")
    def source_group_id(self) -> str:
        """
        Source security group ID for ingress authorization.
        """
        return pulumi.get(self, "source_group_id")

    @property
    @pulumi.getter(name="sourceGroupOwnerAccount")
    def source_group_owner_account(self) -> str:
        """
        Alibaba Cloud account of the source security group.
        """
        return pulumi.get(self, "source_group_owner_account")


@pulumi.output_type
class GetSecurityGroupsGroupResult(dict):
    def __init__(__self__, *,
                 creation_time: str,
                 description: str,
                 id: str,
                 inner_access: bool,
                 name: str,
                 resource_group_id: str,
                 security_group_type: str,
                 vpc_id: str,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str creation_time: Creation time of the security group.
        :param str description: The description of the security group.
        :param str id: The ID of the security group.
        :param bool inner_access: Whether to allow inner network access.
        :param str name: The name of the security group.
        :param str resource_group_id: The Id of resource group which the security_group belongs.
        :param str security_group_type: The type of the security group.
        :param str vpc_id: Used to retrieve security groups that belong to the specified VPC ID.
        :param Mapping[str, Any] tags: A map of tags assigned to the ECS instances. It must be in the format:
        """
        GetSecurityGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_time=creation_time,
            description=description,
            id=id,
            inner_access=inner_access,
            name=name,
            resource_group_id=resource_group_id,
            security_group_type=security_group_type,
            vpc_id=vpc_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             inner_access: Optional[bool] = None,
             name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             security_group_type: Optional[str] = None,
             vpc_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if inner_access is None and 'innerAccess' in kwargs:
            inner_access = kwargs['innerAccess']
        if inner_access is None:
            raise TypeError("Missing 'inner_access' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if security_group_type is None and 'securityGroupType' in kwargs:
            security_group_type = kwargs['securityGroupType']
        if security_group_type is None:
            raise TypeError("Missing 'security_group_type' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("id", id)
        _setter("inner_access", inner_access)
        _setter("name", name)
        _setter("resource_group_id", resource_group_id)
        _setter("security_group_type", security_group_type)
        _setter("vpc_id", vpc_id)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Creation time of the security group.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the security group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="innerAccess")
    def inner_access(self) -> bool:
        """
        Whether to allow inner network access.
        """
        return pulumi.get(self, "inner_access")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the security group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which the security_group belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityGroupType")
    def security_group_type(self) -> str:
        """
        The type of the security group.
        """
        return pulumi.get(self, "security_group_type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Used to retrieve security groups that belong to the specified VPC ID.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        A map of tags assigned to the ECS instances. It must be in the format:
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSnapshotsSnapshotResult(dict):
    def __init__(__self__, *,
                 category: str,
                 creation_time: str,
                 description: str,
                 disk_id: str,
                 encrypted: bool,
                 id: str,
                 instant_access: bool,
                 instant_access_retention_days: int,
                 name: str,
                 product_code: str,
                 progress: str,
                 remain_time: int,
                 resource_group_id: str,
                 retention_days: int,
                 snapshot_id: str,
                 snapshot_name: str,
                 snapshot_sn: str,
                 snapshot_type: str,
                 source_disk_id: str,
                 source_disk_size: str,
                 source_disk_type: str,
                 source_storage_type: str,
                 status: str,
                 tags: Mapping[str, Any],
                 type: str,
                 usage: str):
        """
        :param str creation_time: Creation time. Time of creation. It is represented according to ISO8601, and UTC time is used. Format: YYYY-MM-DDThh:mmZ.
        :param str description: Description of the snapshot.
        :param bool encrypted: Whether the snapshot is encrypted or not.
        :param str id: ID of the snapshot.
        :param str name: Name of the snapshot.
        :param str product_code: Product code on the image market place.
        :param str progress: Progress of snapshot creation, presented in percentage.
        :param int remain_time: The remaining time of a snapshot creation task, in seconds.
        :param int retention_days: The number of days that an automatic snapshot retains in the console for your instance.
        :param str source_disk_id: Source disk ID, which is retained after the source disk of the snapshot is deleted.
        :param str source_disk_size: Size of the source disk, measured in GB.
        :param str source_disk_type: Source disk attribute. Value range: `System`,`Data`.
        :param str status: The snapshot status. Value range: `progressing`, `accomplished` and `failed`.
        :param Mapping[str, Any] tags: A map of tags assigned to the snapshot.
        :param str usage: Whether the snapshots are used to create resources or not. Value range: `image`, `disk`, `image_disk` and `none`.
        """
        GetSnapshotsSnapshotResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            creation_time=creation_time,
            description=description,
            disk_id=disk_id,
            encrypted=encrypted,
            id=id,
            instant_access=instant_access,
            instant_access_retention_days=instant_access_retention_days,
            name=name,
            product_code=product_code,
            progress=progress,
            remain_time=remain_time,
            resource_group_id=resource_group_id,
            retention_days=retention_days,
            snapshot_id=snapshot_id,
            snapshot_name=snapshot_name,
            snapshot_sn=snapshot_sn,
            snapshot_type=snapshot_type,
            source_disk_id=source_disk_id,
            source_disk_size=source_disk_size,
            source_disk_type=source_disk_type,
            source_storage_type=source_storage_type,
            status=status,
            tags=tags,
            type=type,
            usage=usage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             creation_time: Optional[str] = None,
             description: Optional[str] = None,
             disk_id: Optional[str] = None,
             encrypted: Optional[bool] = None,
             id: Optional[str] = None,
             instant_access: Optional[bool] = None,
             instant_access_retention_days: Optional[int] = None,
             name: Optional[str] = None,
             product_code: Optional[str] = None,
             progress: Optional[str] = None,
             remain_time: Optional[int] = None,
             resource_group_id: Optional[str] = None,
             retention_days: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             snapshot_name: Optional[str] = None,
             snapshot_sn: Optional[str] = None,
             snapshot_type: Optional[str] = None,
             source_disk_id: Optional[str] = None,
             source_disk_size: Optional[str] = None,
             source_disk_type: Optional[str] = None,
             source_storage_type: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             usage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if disk_id is None and 'diskId' in kwargs:
            disk_id = kwargs['diskId']
        if disk_id is None:
            raise TypeError("Missing 'disk_id' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instant_access is None and 'instantAccess' in kwargs:
            instant_access = kwargs['instantAccess']
        if instant_access is None:
            raise TypeError("Missing 'instant_access' argument")
        if instant_access_retention_days is None and 'instantAccessRetentionDays' in kwargs:
            instant_access_retention_days = kwargs['instantAccessRetentionDays']
        if instant_access_retention_days is None:
            raise TypeError("Missing 'instant_access_retention_days' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if product_code is None and 'productCode' in kwargs:
            product_code = kwargs['productCode']
        if product_code is None:
            raise TypeError("Missing 'product_code' argument")
        if progress is None:
            raise TypeError("Missing 'progress' argument")
        if remain_time is None and 'remainTime' in kwargs:
            remain_time = kwargs['remainTime']
        if remain_time is None:
            raise TypeError("Missing 'remain_time' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if retention_days is None and 'retentionDays' in kwargs:
            retention_days = kwargs['retentionDays']
        if retention_days is None:
            raise TypeError("Missing 'retention_days' argument")
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if snapshot_id is None:
            raise TypeError("Missing 'snapshot_id' argument")
        if snapshot_name is None and 'snapshotName' in kwargs:
            snapshot_name = kwargs['snapshotName']
        if snapshot_name is None:
            raise TypeError("Missing 'snapshot_name' argument")
        if snapshot_sn is None and 'snapshotSn' in kwargs:
            snapshot_sn = kwargs['snapshotSn']
        if snapshot_sn is None:
            raise TypeError("Missing 'snapshot_sn' argument")
        if snapshot_type is None and 'snapshotType' in kwargs:
            snapshot_type = kwargs['snapshotType']
        if snapshot_type is None:
            raise TypeError("Missing 'snapshot_type' argument")
        if source_disk_id is None and 'sourceDiskId' in kwargs:
            source_disk_id = kwargs['sourceDiskId']
        if source_disk_id is None:
            raise TypeError("Missing 'source_disk_id' argument")
        if source_disk_size is None and 'sourceDiskSize' in kwargs:
            source_disk_size = kwargs['sourceDiskSize']
        if source_disk_size is None:
            raise TypeError("Missing 'source_disk_size' argument")
        if source_disk_type is None and 'sourceDiskType' in kwargs:
            source_disk_type = kwargs['sourceDiskType']
        if source_disk_type is None:
            raise TypeError("Missing 'source_disk_type' argument")
        if source_storage_type is None and 'sourceStorageType' in kwargs:
            source_storage_type = kwargs['sourceStorageType']
        if source_storage_type is None:
            raise TypeError("Missing 'source_storage_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if usage is None:
            raise TypeError("Missing 'usage' argument")

        _setter("category", category)
        _setter("creation_time", creation_time)
        _setter("description", description)
        _setter("disk_id", disk_id)
        _setter("encrypted", encrypted)
        _setter("id", id)
        _setter("instant_access", instant_access)
        _setter("instant_access_retention_days", instant_access_retention_days)
        _setter("name", name)
        _setter("product_code", product_code)
        _setter("progress", progress)
        _setter("remain_time", remain_time)
        _setter("resource_group_id", resource_group_id)
        _setter("retention_days", retention_days)
        _setter("snapshot_id", snapshot_id)
        _setter("snapshot_name", snapshot_name)
        _setter("snapshot_sn", snapshot_sn)
        _setter("snapshot_type", snapshot_type)
        _setter("source_disk_id", source_disk_id)
        _setter("source_disk_size", source_disk_size)
        _setter("source_disk_type", source_disk_type)
        _setter("source_storage_type", source_storage_type)
        _setter("status", status)
        _setter("tags", tags)
        _setter("type", type)
        _setter("usage", usage)

    @property
    @pulumi.getter
    def category(self) -> str:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Creation time. Time of creation. It is represented according to ISO8601, and UTC time is used. Format: YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the snapshot.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Whether the snapshot is encrypted or not.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instantAccess")
    def instant_access(self) -> bool:
        return pulumi.get(self, "instant_access")

    @property
    @pulumi.getter(name="instantAccessRetentionDays")
    def instant_access_retention_days(self) -> int:
        return pulumi.get(self, "instant_access_retention_days")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the snapshot.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="productCode")
    def product_code(self) -> str:
        """
        Product code on the image market place.
        """
        return pulumi.get(self, "product_code")

    @property
    @pulumi.getter
    def progress(self) -> str:
        """
        Progress of snapshot creation, presented in percentage.
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter(name="remainTime")
    def remain_time(self) -> int:
        """
        The remaining time of a snapshot creation task, in seconds.
        """
        return pulumi.get(self, "remain_time")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        """
        The number of days that an automatic snapshot retains in the console for your instance.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> str:
        return pulumi.get(self, "snapshot_name")

    @property
    @pulumi.getter(name="snapshotSn")
    def snapshot_sn(self) -> str:
        return pulumi.get(self, "snapshot_sn")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter(name="sourceDiskId")
    def source_disk_id(self) -> str:
        """
        Source disk ID, which is retained after the source disk of the snapshot is deleted.
        """
        return pulumi.get(self, "source_disk_id")

    @property
    @pulumi.getter(name="sourceDiskSize")
    def source_disk_size(self) -> str:
        """
        Size of the source disk, measured in GB.
        """
        return pulumi.get(self, "source_disk_size")

    @property
    @pulumi.getter(name="sourceDiskType")
    def source_disk_type(self) -> str:
        """
        Source disk attribute. Value range: `System`,`Data`.
        """
        return pulumi.get(self, "source_disk_type")

    @property
    @pulumi.getter(name="sourceStorageType")
    def source_storage_type(self) -> str:
        return pulumi.get(self, "source_storage_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The snapshot status. Value range: `progressing`, `accomplished` and `failed`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the snapshot.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def usage(self) -> str:
        """
        Whether the snapshots are used to create resources or not. Value range: `image`, `disk`, `image_disk` and `none`.
        """
        return pulumi.get(self, "usage")


