# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AclEntryList',
    'BackendServerBackendServer',
    'ListenerXForwardedFor',
    'MasterSlaveServerGroupServer',
    'ServerGroupServer',
    'GetAclsAclResult',
    'GetAclsAclEntryListResult',
    'GetAclsAclRelatedListenerResult',
    'GetApplicationLoadBalancersBalancerResult',
    'GetApplicationLoadBalancersBalancerBackendServerResult',
    'GetApplicationLoadBalancersBalancerListenerPortsAndProtocalResult',
    'GetApplicationLoadBalancersBalancerListenerPortsAndProtocolResult',
    'GetApplicationLoadBalancersSlbResult',
    'GetAttachmentsSlbAttachmentResult',
    'GetBackendServersBackendServerResult',
    'GetCaCertificatesCertificateResult',
    'GetDomainExtensionsExtensionResult',
    'GetListenersSlbListenerResult',
    'GetLoadBalancersBalancerResult',
    'GetLoadBalancersBalancerBackendServerResult',
    'GetLoadBalancersBalancerListenerPortsAndProtocalResult',
    'GetLoadBalancersBalancerListenerPortsAndProtocolResult',
    'GetLoadBalancersSlbResult',
    'GetMasterSlaveServerGroupsGroupResult',
    'GetMasterSlaveServerGroupsGroupServerResult',
    'GetRulesSlbRuleResult',
    'GetServerCertificatesCertificateResult',
    'GetServerGroupsSlbServerGroupResult',
    'GetServerGroupsSlbServerGroupServerResult',
    'GetTlsCipherPoliciesPolicyResult',
    'GetTlsCipherPoliciesPolicyRelateListenerResult',
    'GetZonesZoneResult',
    'GetZonesZoneSupportedResourceResult',
]

@pulumi.output_type
class AclEntryList(dict):
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 entry: Optional[str] = None):
        AclEntryList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            entry=entry,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: Optional[str] = None,
             entry: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if comment is not None:
            _setter("comment", comment)
        if entry is not None:
            _setter("entry", entry)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def entry(self) -> Optional[str]:
        return pulumi.get(self, "entry")


@pulumi.output_type
class BackendServerBackendServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverId":
            suggest = "server_id"
        elif key == "serverIp":
            suggest = "server_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServerBackendServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServerBackendServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServerBackendServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_id: str,
                 weight: int,
                 server_ip: Optional[str] = None,
                 type: Optional[str] = None):
        BackendServerBackendServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_id=server_id,
            weight=weight,
            server_ip=server_ip,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_id: Optional[str] = None,
             weight: Optional[int] = None,
             server_ip: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")
        if server_ip is None and 'serverIp' in kwargs:
            server_ip = kwargs['serverIp']

        _setter("server_id", server_id)
        _setter("weight", weight)
        if server_ip is not None:
            _setter("server_ip", server_ip)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> Optional[str]:
        return pulumi.get(self, "server_ip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ListenerXForwardedFor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retriveClientIp":
            suggest = "retrive_client_ip"
        elif key == "retriveSlbId":
            suggest = "retrive_slb_id"
        elif key == "retriveSlbIp":
            suggest = "retrive_slb_ip"
        elif key == "retriveSlbProto":
            suggest = "retrive_slb_proto"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerXForwardedFor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerXForwardedFor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerXForwardedFor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retrive_client_ip: Optional[bool] = None,
                 retrive_slb_id: Optional[bool] = None,
                 retrive_slb_ip: Optional[bool] = None,
                 retrive_slb_proto: Optional[bool] = None):
        """
        :param bool retrive_client_ip: Whether to retrieve the client ip. It is read-only attribute.
        :param bool retrive_slb_id: Whether to use the XForwardedFor header to obtain the ID of the SLB instance. Default to false.
        :param bool retrive_slb_ip: Whether to use the XForwardedFor_SLBIP header to obtain the public IP address of the SLB instance. Default to false.
        :param bool retrive_slb_proto: Whether to use the XForwardedFor_proto header to obtain the protocol used by the listener. Default to false.
        """
        ListenerXForwardedFor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            retrive_client_ip=retrive_client_ip,
            retrive_slb_id=retrive_slb_id,
            retrive_slb_ip=retrive_slb_ip,
            retrive_slb_proto=retrive_slb_proto,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             retrive_client_ip: Optional[bool] = None,
             retrive_slb_id: Optional[bool] = None,
             retrive_slb_ip: Optional[bool] = None,
             retrive_slb_proto: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if retrive_client_ip is None and 'retriveClientIp' in kwargs:
            retrive_client_ip = kwargs['retriveClientIp']
        if retrive_slb_id is None and 'retriveSlbId' in kwargs:
            retrive_slb_id = kwargs['retriveSlbId']
        if retrive_slb_ip is None and 'retriveSlbIp' in kwargs:
            retrive_slb_ip = kwargs['retriveSlbIp']
        if retrive_slb_proto is None and 'retriveSlbProto' in kwargs:
            retrive_slb_proto = kwargs['retriveSlbProto']

        if retrive_client_ip is not None:
            _setter("retrive_client_ip", retrive_client_ip)
        if retrive_slb_id is not None:
            _setter("retrive_slb_id", retrive_slb_id)
        if retrive_slb_ip is not None:
            _setter("retrive_slb_ip", retrive_slb_ip)
        if retrive_slb_proto is not None:
            _setter("retrive_slb_proto", retrive_slb_proto)

    @property
    @pulumi.getter(name="retriveClientIp")
    def retrive_client_ip(self) -> Optional[bool]:
        """
        Whether to retrieve the client ip. It is read-only attribute.
        """
        return pulumi.get(self, "retrive_client_ip")

    @property
    @pulumi.getter(name="retriveSlbId")
    def retrive_slb_id(self) -> Optional[bool]:
        """
        Whether to use the XForwardedFor header to obtain the ID of the SLB instance. Default to false.
        """
        return pulumi.get(self, "retrive_slb_id")

    @property
    @pulumi.getter(name="retriveSlbIp")
    def retrive_slb_ip(self) -> Optional[bool]:
        """
        Whether to use the XForwardedFor_SLBIP header to obtain the public IP address of the SLB instance. Default to false.
        """
        return pulumi.get(self, "retrive_slb_ip")

    @property
    @pulumi.getter(name="retriveSlbProto")
    def retrive_slb_proto(self) -> Optional[bool]:
        """
        Whether to use the XForwardedFor_proto header to obtain the protocol used by the listener. Default to false.
        """
        return pulumi.get(self, "retrive_slb_proto")


@pulumi.output_type
class MasterSlaveServerGroupServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverId":
            suggest = "server_id"
        elif key == "isBackup":
            suggest = "is_backup"
        elif key == "serverType":
            suggest = "server_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MasterSlaveServerGroupServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MasterSlaveServerGroupServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MasterSlaveServerGroupServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 server_id: str,
                 is_backup: Optional[int] = None,
                 server_type: Optional[str] = None,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        MasterSlaveServerGroupServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            server_id=server_id,
            is_backup=is_backup,
            server_type=server_type,
            type=type,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             server_id: Optional[str] = None,
             is_backup: Optional[int] = None,
             server_type: Optional[str] = None,
             type: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if is_backup is None and 'isBackup' in kwargs:
            is_backup = kwargs['isBackup']
        if server_type is None and 'serverType' in kwargs:
            server_type = kwargs['serverType']

        _setter("port", port)
        _setter("server_id", server_id)
        if is_backup is not None:
            _setter("is_backup", is_backup)
        if server_type is not None:
            _setter("server_type", server_type)
        if type is not None:
            _setter("type", type)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> Optional[int]:
        return pulumi.get(self, "is_backup")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[str]:
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class ServerGroupServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverIds":
            suggest = "server_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 server_ids: Sequence[str],
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        ServerGroupServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            server_ids=server_ids,
            type=type,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             server_ids: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if server_ids is None and 'serverIds' in kwargs:
            server_ids = kwargs['serverIds']
        if server_ids is None:
            raise TypeError("Missing 'server_ids' argument")

        _setter("port", port)
        _setter("server_ids", server_ids)
        if type is not None:
            _setter("type", type)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverIds")
    def server_ids(self) -> Sequence[str]:
        return pulumi.get(self, "server_ids")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAclsAclResult(dict):
    def __init__(__self__, *,
                 entry_lists: Sequence['outputs.GetAclsAclEntryListResult'],
                 id: str,
                 ip_version: str,
                 name: str,
                 related_listeners: Sequence['outputs.GetAclsAclRelatedListenerResult'],
                 resource_group_id: str,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param Sequence['GetAclsAclEntryListArgs'] entry_lists: A list of entry (IP addresses or CIDR blocks).  Each entry contains two sub-fields as `Entry Block` follows.
        :param str id: Acl ID.
        :param str name: Acl name.
        :param Sequence['GetAclsAclRelatedListenerArgs'] related_listeners: A list of listener are attached by the acl.  Each listener contains four sub-fields as `Listener Block` follows.
        :param str resource_group_id: The Id of resource group which acl belongs.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetAclsAclResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entry_lists=entry_lists,
            id=id,
            ip_version=ip_version,
            name=name,
            related_listeners=related_listeners,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entry_lists: Optional[Sequence['outputs.GetAclsAclEntryListResult']] = None,
             id: Optional[str] = None,
             ip_version: Optional[str] = None,
             name: Optional[str] = None,
             related_listeners: Optional[Sequence['outputs.GetAclsAclRelatedListenerResult']] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if entry_lists is None and 'entryLists' in kwargs:
            entry_lists = kwargs['entryLists']
        if entry_lists is None:
            raise TypeError("Missing 'entry_lists' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if ip_version is None and 'ipVersion' in kwargs:
            ip_version = kwargs['ipVersion']
        if ip_version is None:
            raise TypeError("Missing 'ip_version' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if related_listeners is None and 'relatedListeners' in kwargs:
            related_listeners = kwargs['relatedListeners']
        if related_listeners is None:
            raise TypeError("Missing 'related_listeners' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")

        _setter("entry_lists", entry_lists)
        _setter("id", id)
        _setter("ip_version", ip_version)
        _setter("name", name)
        _setter("related_listeners", related_listeners)
        _setter("resource_group_id", resource_group_id)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="entryLists")
    def entry_lists(self) -> Sequence['outputs.GetAclsAclEntryListResult']:
        """
        A list of entry (IP addresses or CIDR blocks).  Each entry contains two sub-fields as `Entry Block` follows.
        """
        return pulumi.get(self, "entry_lists")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Acl ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> str:
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Acl name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="relatedListeners")
    def related_listeners(self) -> Sequence['outputs.GetAclsAclRelatedListenerResult']:
        """
        A list of listener are attached by the acl.  Each listener contains four sub-fields as `Listener Block` follows.
        """
        return pulumi.get(self, "related_listeners")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which acl belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAclsAclEntryListResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 entry: str):
        GetAclsAclEntryListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            entry=entry,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: Optional[str] = None,
             entry: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if comment is None:
            raise TypeError("Missing 'comment' argument")
        if entry is None:
            raise TypeError("Missing 'entry' argument")

        _setter("comment", comment)
        _setter("entry", entry)

    @property
    @pulumi.getter
    def comment(self) -> str:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def entry(self) -> str:
        return pulumi.get(self, "entry")


@pulumi.output_type
class GetAclsAclRelatedListenerResult(dict):
    def __init__(__self__, *,
                 acl_type: str,
                 frontend_port: int,
                 load_balancer_id: str,
                 protocol: str):
        GetAclsAclRelatedListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acl_type=acl_type,
            frontend_port=frontend_port,
            load_balancer_id=load_balancer_id,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acl_type: Optional[str] = None,
             frontend_port: Optional[int] = None,
             load_balancer_id: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if acl_type is None and 'aclType' in kwargs:
            acl_type = kwargs['aclType']
        if acl_type is None:
            raise TypeError("Missing 'acl_type' argument")
        if frontend_port is None and 'frontendPort' in kwargs:
            frontend_port = kwargs['frontendPort']
        if frontend_port is None:
            raise TypeError("Missing 'frontend_port' argument")
        if load_balancer_id is None and 'loadBalancerId' in kwargs:
            load_balancer_id = kwargs['loadBalancerId']
        if load_balancer_id is None:
            raise TypeError("Missing 'load_balancer_id' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("acl_type", acl_type)
        _setter("frontend_port", frontend_port)
        _setter("load_balancer_id", load_balancer_id)
        _setter("protocol", protocol)

    @property
    @pulumi.getter(name="aclType")
    def acl_type(self) -> str:
        return pulumi.get(self, "acl_type")

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> int:
        return pulumi.get(self, "frontend_port")

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> str:
        return pulumi.get(self, "load_balancer_id")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetApplicationLoadBalancersBalancerResult(dict):
    def __init__(__self__, *,
                 address: str,
                 address_ip_version: str,
                 address_type: str,
                 auto_release_time: int,
                 backend_servers: Sequence['outputs.GetApplicationLoadBalancersBalancerBackendServerResult'],
                 bandwidth: int,
                 create_time_stamp: int,
                 delete_protection: str,
                 end_time: str,
                 end_time_stamp: int,
                 id: str,
                 internet_charge_type: str,
                 listener_ports_and_protocals: Sequence['outputs.GetApplicationLoadBalancersBalancerListenerPortsAndProtocalResult'],
                 listener_ports_and_protocols: Sequence['outputs.GetApplicationLoadBalancersBalancerListenerPortsAndProtocolResult'],
                 load_balancer_id: str,
                 load_balancer_name: str,
                 load_balancer_spec: str,
                 master_zone_id: str,
                 modification_protection_reason: str,
                 modification_protection_status: str,
                 network_type: str,
                 payment_type: str,
                 region_id_alias: str,
                 renewal_cyc_unit: str,
                 renewal_duration: int,
                 renewal_status: str,
                 resource_group_id: str,
                 slave_zone_id: str,
                 status: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param str address: Service address of the SLBs.
        :param str address_ip_version: The address ip version. Valid values `ipv4` and `ipv6`.
        :param str address_type: The address type of the SLB. Valid values `internet` and `intranet`.
        :param int auto_release_time: The auto release time.
        :param Sequence['GetApplicationLoadBalancersBalancerBackendServerArgs'] backend_servers: The backend servers of the SLB.
        :param int bandwidth: The bandwidth of the SLB.
        :param int create_time_stamp: The create time stamp of the SLB.
        :param str delete_protection: Whether the SLB should delete protection.
        :param str end_time: The end time of the SLB.
        :param int end_time_stamp: The end time stamp of the SLB.
        :param str id: ID of the SLB.
        :param str internet_charge_type: The internet charge type. Valid values `PayByBandwidth` and `PayByTraffic`.
        :param Sequence['GetApplicationLoadBalancersBalancerListenerPortsAndProtocalArgs'] listener_ports_and_protocals: The listener ports and protocal of the SLB.
        :param Sequence['GetApplicationLoadBalancersBalancerListenerPortsAndProtocolArgs'] listener_ports_and_protocols: The listener ports and protocol of the SLB.
        :param str load_balancer_id: Thd ID of the SLB.
        :param str load_balancer_name: The name of the SLB.
        :param str load_balancer_spec: The specification of the SLB.
        :param str master_zone_id: The master zone id of the SLB.
        :param str modification_protection_reason: The reason of modification protection.
        :param str modification_protection_status: The status of modification protection.
        :param str network_type: Network type of the SLBs. Valid values: `vpc` and `classic`.
        :param str payment_type: The payment type of SLB. Valid values `PayAsYouGo` and `Subscription`.
        :param str region_id_alias: Region ID the SLB belongs to.
        :param str renewal_cyc_unit: The renewal cyc unit of the SLB.
        :param int renewal_duration: The renewal duration of the SLB.
        :param str renewal_status: The renewal status of the SLB.
        :param str resource_group_id: The Id of resource group which SLB belongs.
        :param str slave_zone_id: The slave zone id of the SLB.
        :param str status: SLB current status. Possible values: `inactive`, `active` and `locked`.
        :param Mapping[str, Any] tags: A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
        :param str vpc_id: ID of the VPC linked to the SLBs.
        :param str vswitch_id: ID of the VSwitch linked to the SLBs.
        """
        GetApplicationLoadBalancersBalancerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            address_ip_version=address_ip_version,
            address_type=address_type,
            auto_release_time=auto_release_time,
            backend_servers=backend_servers,
            bandwidth=bandwidth,
            create_time_stamp=create_time_stamp,
            delete_protection=delete_protection,
            end_time=end_time,
            end_time_stamp=end_time_stamp,
            id=id,
            internet_charge_type=internet_charge_type,
            listener_ports_and_protocals=listener_ports_and_protocals,
            listener_ports_and_protocols=listener_ports_and_protocols,
            load_balancer_id=load_balancer_id,
            load_balancer_name=load_balancer_name,
            load_balancer_spec=load_balancer_spec,
            master_zone_id=master_zone_id,
            modification_protection_reason=modification_protection_reason,
            modification_protection_status=modification_protection_status,
            network_type=network_type,
            payment_type=payment_type,
            region_id_alias=region_id_alias,
            renewal_cyc_unit=renewal_cyc_unit,
            renewal_duration=renewal_duration,
            renewal_status=renewal_status,
            resource_group_id=resource_group_id,
            slave_zone_id=slave_zone_id,
            status=status,
            tags=tags,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             address_ip_version: Optional[str] = None,
             address_type: Optional[str] = None,
             auto_release_time: Optional[int] = None,
             backend_servers: Optional[Sequence['outputs.GetApplicationLoadBalancersBalancerBackendServerResult']] = None,
             bandwidth: Optional[int] = None,
             create_time_stamp: Optional[int] = None,
             delete_protection: Optional[str] = None,
             end_time: Optional[str] = None,
             end_time_stamp: Optional[int] = None,
             id: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             listener_ports_and_protocals: Optional[Sequence['outputs.GetApplicationLoadBalancersBalancerListenerPortsAndProtocalResult']] = None,
             listener_ports_and_protocols: Optional[Sequence['outputs.GetApplicationLoadBalancersBalancerListenerPortsAndProtocolResult']] = None,
             load_balancer_id: Optional[str] = None,
             load_balancer_name: Optional[str] = None,
             load_balancer_spec: Optional[str] = None,
             master_zone_id: Optional[str] = None,
             modification_protection_reason: Optional[str] = None,
             modification_protection_status: Optional[str] = None,
             network_type: Optional[str] = None,
             payment_type: Optional[str] = None,
             region_id_alias: Optional[str] = None,
             renewal_cyc_unit: Optional[str] = None,
             renewal_duration: Optional[int] = None,
             renewal_status: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             slave_zone_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if address_ip_version is None and 'addressIpVersion' in kwargs:
            address_ip_version = kwargs['addressIpVersion']
        if address_ip_version is None:
            raise TypeError("Missing 'address_ip_version' argument")
        if address_type is None and 'addressType' in kwargs:
            address_type = kwargs['addressType']
        if address_type is None:
            raise TypeError("Missing 'address_type' argument")
        if auto_release_time is None and 'autoReleaseTime' in kwargs:
            auto_release_time = kwargs['autoReleaseTime']
        if auto_release_time is None:
            raise TypeError("Missing 'auto_release_time' argument")
        if backend_servers is None and 'backendServers' in kwargs:
            backend_servers = kwargs['backendServers']
        if backend_servers is None:
            raise TypeError("Missing 'backend_servers' argument")
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if create_time_stamp is None and 'createTimeStamp' in kwargs:
            create_time_stamp = kwargs['createTimeStamp']
        if create_time_stamp is None:
            raise TypeError("Missing 'create_time_stamp' argument")
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if end_time is None:
            raise TypeError("Missing 'end_time' argument")
        if end_time_stamp is None and 'endTimeStamp' in kwargs:
            end_time_stamp = kwargs['endTimeStamp']
        if end_time_stamp is None:
            raise TypeError("Missing 'end_time_stamp' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if listener_ports_and_protocals is None and 'listenerPortsAndProtocals' in kwargs:
            listener_ports_and_protocals = kwargs['listenerPortsAndProtocals']
        if listener_ports_and_protocals is None:
            raise TypeError("Missing 'listener_ports_and_protocals' argument")
        if listener_ports_and_protocols is None and 'listenerPortsAndProtocols' in kwargs:
            listener_ports_and_protocols = kwargs['listenerPortsAndProtocols']
        if listener_ports_and_protocols is None:
            raise TypeError("Missing 'listener_ports_and_protocols' argument")
        if load_balancer_id is None and 'loadBalancerId' in kwargs:
            load_balancer_id = kwargs['loadBalancerId']
        if load_balancer_id is None:
            raise TypeError("Missing 'load_balancer_id' argument")
        if load_balancer_name is None and 'loadBalancerName' in kwargs:
            load_balancer_name = kwargs['loadBalancerName']
        if load_balancer_name is None:
            raise TypeError("Missing 'load_balancer_name' argument")
        if load_balancer_spec is None and 'loadBalancerSpec' in kwargs:
            load_balancer_spec = kwargs['loadBalancerSpec']
        if load_balancer_spec is None:
            raise TypeError("Missing 'load_balancer_spec' argument")
        if master_zone_id is None and 'masterZoneId' in kwargs:
            master_zone_id = kwargs['masterZoneId']
        if master_zone_id is None:
            raise TypeError("Missing 'master_zone_id' argument")
        if modification_protection_reason is None and 'modificationProtectionReason' in kwargs:
            modification_protection_reason = kwargs['modificationProtectionReason']
        if modification_protection_reason is None:
            raise TypeError("Missing 'modification_protection_reason' argument")
        if modification_protection_status is None and 'modificationProtectionStatus' in kwargs:
            modification_protection_status = kwargs['modificationProtectionStatus']
        if modification_protection_status is None:
            raise TypeError("Missing 'modification_protection_status' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if region_id_alias is None and 'regionIdAlias' in kwargs:
            region_id_alias = kwargs['regionIdAlias']
        if region_id_alias is None:
            raise TypeError("Missing 'region_id_alias' argument")
        if renewal_cyc_unit is None and 'renewalCycUnit' in kwargs:
            renewal_cyc_unit = kwargs['renewalCycUnit']
        if renewal_cyc_unit is None:
            raise TypeError("Missing 'renewal_cyc_unit' argument")
        if renewal_duration is None and 'renewalDuration' in kwargs:
            renewal_duration = kwargs['renewalDuration']
        if renewal_duration is None:
            raise TypeError("Missing 'renewal_duration' argument")
        if renewal_status is None and 'renewalStatus' in kwargs:
            renewal_status = kwargs['renewalStatus']
        if renewal_status is None:
            raise TypeError("Missing 'renewal_status' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if slave_zone_id is None and 'slaveZoneId' in kwargs:
            slave_zone_id = kwargs['slaveZoneId']
        if slave_zone_id is None:
            raise TypeError("Missing 'slave_zone_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("address", address)
        _setter("address_ip_version", address_ip_version)
        _setter("address_type", address_type)
        _setter("auto_release_time", auto_release_time)
        _setter("backend_servers", backend_servers)
        _setter("bandwidth", bandwidth)
        _setter("create_time_stamp", create_time_stamp)
        _setter("delete_protection", delete_protection)
        _setter("end_time", end_time)
        _setter("end_time_stamp", end_time_stamp)
        _setter("id", id)
        _setter("internet_charge_type", internet_charge_type)
        _setter("listener_ports_and_protocals", listener_ports_and_protocals)
        _setter("listener_ports_and_protocols", listener_ports_and_protocols)
        _setter("load_balancer_id", load_balancer_id)
        _setter("load_balancer_name", load_balancer_name)
        _setter("load_balancer_spec", load_balancer_spec)
        _setter("master_zone_id", master_zone_id)
        _setter("modification_protection_reason", modification_protection_reason)
        _setter("modification_protection_status", modification_protection_status)
        _setter("network_type", network_type)
        _setter("payment_type", payment_type)
        _setter("region_id_alias", region_id_alias)
        _setter("renewal_cyc_unit", renewal_cyc_unit)
        _setter("renewal_duration", renewal_duration)
        _setter("renewal_status", renewal_status)
        _setter("resource_group_id", resource_group_id)
        _setter("slave_zone_id", slave_zone_id)
        _setter("status", status)
        _setter("tags", tags)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Service address of the SLBs.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressIpVersion")
    def address_ip_version(self) -> str:
        """
        The address ip version. Valid values `ipv4` and `ipv6`.
        """
        return pulumi.get(self, "address_ip_version")

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> str:
        """
        The address type of the SLB. Valid values `internet` and `intranet`.
        """
        return pulumi.get(self, "address_type")

    @property
    @pulumi.getter(name="autoReleaseTime")
    def auto_release_time(self) -> int:
        """
        The auto release time.
        """
        return pulumi.get(self, "auto_release_time")

    @property
    @pulumi.getter(name="backendServers")
    def backend_servers(self) -> Sequence['outputs.GetApplicationLoadBalancersBalancerBackendServerResult']:
        """
        The backend servers of the SLB.
        """
        return pulumi.get(self, "backend_servers")

    @property
    @pulumi.getter
    def bandwidth(self) -> int:
        """
        The bandwidth of the SLB.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="createTimeStamp")
    def create_time_stamp(self) -> int:
        """
        The create time stamp of the SLB.
        """
        return pulumi.get(self, "create_time_stamp")

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> str:
        """
        Whether the SLB should delete protection.
        """
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the SLB.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="endTimeStamp")
    def end_time_stamp(self) -> int:
        """
        The end time stamp of the SLB.
        """
        return pulumi.get(self, "end_time_stamp")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the SLB.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        """
        The internet charge type. Valid values `PayByBandwidth` and `PayByTraffic`.
        """
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="listenerPortsAndProtocals")
    def listener_ports_and_protocals(self) -> Sequence['outputs.GetApplicationLoadBalancersBalancerListenerPortsAndProtocalResult']:
        """
        The listener ports and protocal of the SLB.
        """
        return pulumi.get(self, "listener_ports_and_protocals")

    @property
    @pulumi.getter(name="listenerPortsAndProtocols")
    def listener_ports_and_protocols(self) -> Sequence['outputs.GetApplicationLoadBalancersBalancerListenerPortsAndProtocolResult']:
        """
        The listener ports and protocol of the SLB.
        """
        return pulumi.get(self, "listener_ports_and_protocols")

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> str:
        """
        Thd ID of the SLB.
        """
        return pulumi.get(self, "load_balancer_id")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        """
        The name of the SLB.
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="loadBalancerSpec")
    def load_balancer_spec(self) -> str:
        """
        The specification of the SLB.
        """
        return pulumi.get(self, "load_balancer_spec")

    @property
    @pulumi.getter(name="masterZoneId")
    def master_zone_id(self) -> str:
        """
        The master zone id of the SLB.
        """
        return pulumi.get(self, "master_zone_id")

    @property
    @pulumi.getter(name="modificationProtectionReason")
    def modification_protection_reason(self) -> str:
        """
        The reason of modification protection.
        """
        return pulumi.get(self, "modification_protection_reason")

    @property
    @pulumi.getter(name="modificationProtectionStatus")
    def modification_protection_status(self) -> str:
        """
        The status of modification protection.
        """
        return pulumi.get(self, "modification_protection_status")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        Network type of the SLBs. Valid values: `vpc` and `classic`.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        """
        The payment type of SLB. Valid values `PayAsYouGo` and `Subscription`.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="regionIdAlias")
    def region_id_alias(self) -> str:
        """
        Region ID the SLB belongs to.
        """
        return pulumi.get(self, "region_id_alias")

    @property
    @pulumi.getter(name="renewalCycUnit")
    def renewal_cyc_unit(self) -> str:
        """
        The renewal cyc unit of the SLB.
        """
        return pulumi.get(self, "renewal_cyc_unit")

    @property
    @pulumi.getter(name="renewalDuration")
    def renewal_duration(self) -> int:
        """
        The renewal duration of the SLB.
        """
        return pulumi.get(self, "renewal_duration")

    @property
    @pulumi.getter(name="renewalStatus")
    def renewal_status(self) -> str:
        """
        The renewal status of the SLB.
        """
        return pulumi.get(self, "renewal_status")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which SLB belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="slaveZoneId")
    def slave_zone_id(self) -> str:
        """
        The slave zone id of the SLB.
        """
        return pulumi.get(self, "slave_zone_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        SLB current status. Possible values: `inactive`, `active` and `locked`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC linked to the SLBs.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        ID of the VSwitch linked to the SLBs.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetApplicationLoadBalancersBalancerBackendServerResult(dict):
    def __init__(__self__, *,
                 description: str,
                 server_id: str,
                 type: str,
                 weight: int):
        """
        :param str description: The description of protocol.
        :param str server_id: The server ID.
        :param str type: The type of servers.
        :param int weight: The weight of servers.
        """
        GetApplicationLoadBalancersBalancerBackendServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            server_id=server_id,
            type=type,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             server_id: Optional[str] = None,
             type: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("description", description)
        _setter("server_id", server_id)
        _setter("type", type)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of protocol.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        """
        The server ID.
        """
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of servers.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of servers.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetApplicationLoadBalancersBalancerListenerPortsAndProtocalResult(dict):
    def __init__(__self__, *,
                 listener_port: int,
                 listener_protocal: str):
        """
        :param int listener_port: The listener port.
        :param str listener_protocal: The listener protoal.
        """
        GetApplicationLoadBalancersBalancerListenerPortsAndProtocalResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            listener_port=listener_port,
            listener_protocal=listener_protocal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             listener_port: Optional[int] = None,
             listener_protocal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if listener_port is None:
            raise TypeError("Missing 'listener_port' argument")
        if listener_protocal is None and 'listenerProtocal' in kwargs:
            listener_protocal = kwargs['listenerProtocal']
        if listener_protocal is None:
            raise TypeError("Missing 'listener_protocal' argument")

        _setter("listener_port", listener_port)
        _setter("listener_protocal", listener_protocal)

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        """
        The listener port.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="listenerProtocal")
    def listener_protocal(self) -> str:
        """
        The listener protoal.
        """
        return pulumi.get(self, "listener_protocal")


@pulumi.output_type
class GetApplicationLoadBalancersBalancerListenerPortsAndProtocolResult(dict):
    def __init__(__self__, *,
                 description: str,
                 forward_port: int,
                 listener_forward: str,
                 listener_port: int,
                 listener_protocol: str):
        """
        :param str description: The description of protocol.
        :param int forward_port: The forward port.
        :param str listener_forward: The listener forward.
        :param int listener_port: The listener port.
        :param str listener_protocol: The listener protocol.
        """
        GetApplicationLoadBalancersBalancerListenerPortsAndProtocolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            forward_port=forward_port,
            listener_forward=listener_forward,
            listener_port=listener_port,
            listener_protocol=listener_protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             forward_port: Optional[int] = None,
             listener_forward: Optional[str] = None,
             listener_port: Optional[int] = None,
             listener_protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if forward_port is None and 'forwardPort' in kwargs:
            forward_port = kwargs['forwardPort']
        if forward_port is None:
            raise TypeError("Missing 'forward_port' argument")
        if listener_forward is None and 'listenerForward' in kwargs:
            listener_forward = kwargs['listenerForward']
        if listener_forward is None:
            raise TypeError("Missing 'listener_forward' argument")
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if listener_port is None:
            raise TypeError("Missing 'listener_port' argument")
        if listener_protocol is None and 'listenerProtocol' in kwargs:
            listener_protocol = kwargs['listenerProtocol']
        if listener_protocol is None:
            raise TypeError("Missing 'listener_protocol' argument")

        _setter("description", description)
        _setter("forward_port", forward_port)
        _setter("listener_forward", listener_forward)
        _setter("listener_port", listener_port)
        _setter("listener_protocol", listener_protocol)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of protocol.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> int:
        """
        The forward port.
        """
        return pulumi.get(self, "forward_port")

    @property
    @pulumi.getter(name="listenerForward")
    def listener_forward(self) -> str:
        """
        The listener forward.
        """
        return pulumi.get(self, "listener_forward")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        """
        The listener port.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="listenerProtocol")
    def listener_protocol(self) -> str:
        """
        The listener protocol.
        """
        return pulumi.get(self, "listener_protocol")


@pulumi.output_type
class GetApplicationLoadBalancersSlbResult(dict):
    def __init__(__self__, *,
                 address: str,
                 creation_time: str,
                 id: str,
                 internet: bool,
                 master_availability_zone: str,
                 name: str,
                 network_type: str,
                 region_id: str,
                 slave_availability_zone: str,
                 status: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param str address: Service address of the SLBs.
        :param str id: ID of the SLB.
        :param str network_type: Network type of the SLBs. Valid values: `vpc` and `classic`.
        :param str status: SLB current status. Possible values: `inactive`, `active` and `locked`.
        :param Mapping[str, Any] tags: A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
        :param str vpc_id: ID of the VPC linked to the SLBs.
        :param str vswitch_id: ID of the VSwitch linked to the SLBs.
        """
        GetApplicationLoadBalancersSlbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            creation_time=creation_time,
            id=id,
            internet=internet,
            master_availability_zone=master_availability_zone,
            name=name,
            network_type=network_type,
            region_id=region_id,
            slave_availability_zone=slave_availability_zone,
            status=status,
            tags=tags,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             creation_time: Optional[str] = None,
             id: Optional[str] = None,
             internet: Optional[bool] = None,
             master_availability_zone: Optional[str] = None,
             name: Optional[str] = None,
             network_type: Optional[str] = None,
             region_id: Optional[str] = None,
             slave_availability_zone: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if internet is None:
            raise TypeError("Missing 'internet' argument")
        if master_availability_zone is None and 'masterAvailabilityZone' in kwargs:
            master_availability_zone = kwargs['masterAvailabilityZone']
        if master_availability_zone is None:
            raise TypeError("Missing 'master_availability_zone' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if slave_availability_zone is None and 'slaveAvailabilityZone' in kwargs:
            slave_availability_zone = kwargs['slaveAvailabilityZone']
        if slave_availability_zone is None:
            raise TypeError("Missing 'slave_availability_zone' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("address", address)
        _setter("creation_time", creation_time)
        _setter("id", id)
        _setter("internet", internet)
        _setter("master_availability_zone", master_availability_zone)
        _setter("name", name)
        _setter("network_type", network_type)
        _setter("region_id", region_id)
        _setter("slave_availability_zone", slave_availability_zone)
        _setter("status", status)
        _setter("tags", tags)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Service address of the SLBs.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the SLB.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def internet(self) -> bool:
        return pulumi.get(self, "internet")

    @property
    @pulumi.getter(name="masterAvailabilityZone")
    def master_availability_zone(self) -> str:
        return pulumi.get(self, "master_availability_zone")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        Network type of the SLBs. Valid values: `vpc` and `classic`.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="slaveAvailabilityZone")
    def slave_availability_zone(self) -> str:
        return pulumi.get(self, "slave_availability_zone")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        SLB current status. Possible values: `inactive`, `active` and `locked`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC linked to the SLBs.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        ID of the VSwitch linked to the SLBs.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetAttachmentsSlbAttachmentResult(dict):
    def __init__(__self__, *,
                 instance_id: str,
                 weight: int):
        """
        :param str instance_id: ID of the attached ECS instance.
        :param int weight: Weight associated to the ECS instance.
        """
        GetAttachmentsSlbAttachmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_id=instance_id,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_id: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("instance_id", instance_id)
        _setter("weight", weight)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of the attached ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight associated to the ECS instance.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetBackendServersBackendServerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 server_type: str,
                 weight: int):
        """
        :param str id: backend server ID.
        :param str server_type: Type of the backend server.
        :param int weight: Weight associated to the ECS instance.
        """
        GetBackendServersBackendServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            server_type=server_type,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             server_type: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if server_type is None and 'serverType' in kwargs:
            server_type = kwargs['serverType']
        if server_type is None:
            raise TypeError("Missing 'server_type' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("id", id)
        _setter("server_type", server_type)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        backend server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        """
        Type of the backend server.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight associated to the ECS instance.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetCaCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 ca_certificate_id: str,
                 ca_certificate_name: str,
                 common_name: str,
                 created_timestamp: int,
                 expired_time: str,
                 expired_timestamp: int,
                 fingerprint: str,
                 id: str,
                 name: str,
                 resource_group_id: str,
                 tags: Mapping[str, Any]):
        """
        :param str ca_certificate_id: (Available in v1.123.1+) CA certificate ID.
        :param str ca_certificate_name: (Available in v1.123.1+) CA certificate name.
        :param str common_name: CA certificate common name.
        :param int created_timestamp: CA certificate created timestamp.
        :param str expired_time: CA certificate expired time.
        :param int expired_timestamp: CA certificate expired timestamp.
        :param str fingerprint: CA certificate fingerprint.
        :param str id: CA certificate ID.
        :param str name: (Deprecated from v1.123.1) Deprecated and replace by `ca_certificate_name`.
        :param str resource_group_id: The Id of resource group which ca certificates belongs.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetCaCertificatesCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ca_certificate_id=ca_certificate_id,
            ca_certificate_name=ca_certificate_name,
            common_name=common_name,
            created_timestamp=created_timestamp,
            expired_time=expired_time,
            expired_timestamp=expired_timestamp,
            fingerprint=fingerprint,
            id=id,
            name=name,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ca_certificate_id: Optional[str] = None,
             ca_certificate_name: Optional[str] = None,
             common_name: Optional[str] = None,
             created_timestamp: Optional[int] = None,
             expired_time: Optional[str] = None,
             expired_timestamp: Optional[int] = None,
             fingerprint: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ca_certificate_id is None and 'caCertificateId' in kwargs:
            ca_certificate_id = kwargs['caCertificateId']
        if ca_certificate_id is None:
            raise TypeError("Missing 'ca_certificate_id' argument")
        if ca_certificate_name is None and 'caCertificateName' in kwargs:
            ca_certificate_name = kwargs['caCertificateName']
        if ca_certificate_name is None:
            raise TypeError("Missing 'ca_certificate_name' argument")
        if common_name is None and 'commonName' in kwargs:
            common_name = kwargs['commonName']
        if common_name is None:
            raise TypeError("Missing 'common_name' argument")
        if created_timestamp is None and 'createdTimestamp' in kwargs:
            created_timestamp = kwargs['createdTimestamp']
        if created_timestamp is None:
            raise TypeError("Missing 'created_timestamp' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if expired_timestamp is None and 'expiredTimestamp' in kwargs:
            expired_timestamp = kwargs['expiredTimestamp']
        if expired_timestamp is None:
            raise TypeError("Missing 'expired_timestamp' argument")
        if fingerprint is None:
            raise TypeError("Missing 'fingerprint' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("ca_certificate_id", ca_certificate_id)
        _setter("ca_certificate_name", ca_certificate_name)
        _setter("common_name", common_name)
        _setter("created_timestamp", created_timestamp)
        _setter("expired_time", expired_time)
        _setter("expired_timestamp", expired_timestamp)
        _setter("fingerprint", fingerprint)
        _setter("id", id)
        _setter("name", name)
        _setter("resource_group_id", resource_group_id)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="caCertificateId")
    def ca_certificate_id(self) -> str:
        """
        (Available in v1.123.1+) CA certificate ID.
        """
        return pulumi.get(self, "ca_certificate_id")

    @property
    @pulumi.getter(name="caCertificateName")
    def ca_certificate_name(self) -> str:
        """
        (Available in v1.123.1+) CA certificate name.
        """
        return pulumi.get(self, "ca_certificate_name")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        CA certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="createdTimestamp")
    def created_timestamp(self) -> int:
        """
        CA certificate created timestamp.
        """
        return pulumi.get(self, "created_timestamp")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        """
        CA certificate expired time.
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter(name="expiredTimestamp")
    def expired_timestamp(self) -> int:
        """
        CA certificate expired timestamp.
        """
        return pulumi.get(self, "expired_timestamp")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        CA certificate fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        CA certificate ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Deprecated from v1.123.1) Deprecated and replace by `ca_certificate_name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which ca certificates belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDomainExtensionsExtensionResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 id: str,
                 server_certificate_id: str):
        """
        :param str domain: The domain name.
        :param str id: The ID of the domain extension.
        :param str server_certificate_id: The ID of the certificate used by the domain name.
        """
        GetDomainExtensionsExtensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            id=id,
            server_certificate_id=server_certificate_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             id: Optional[str] = None,
             server_certificate_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if domain is None:
            raise TypeError("Missing 'domain' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if server_certificate_id is None and 'serverCertificateId' in kwargs:
            server_certificate_id = kwargs['serverCertificateId']
        if server_certificate_id is None:
            raise TypeError("Missing 'server_certificate_id' argument")

        _setter("domain", domain)
        _setter("id", id)
        _setter("server_certificate_id", server_certificate_id)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain name.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the domain extension.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serverCertificateId")
    def server_certificate_id(self) -> str:
        """
        The ID of the certificate used by the domain name.
        """
        return pulumi.get(self, "server_certificate_id")


@pulumi.output_type
class GetListenersSlbListenerResult(dict):
    def __init__(__self__, *,
                 backend_port: int,
                 bandwidth: int,
                 ca_certificate_id: str,
                 cookie: str,
                 cookie_timeout: int,
                 description: str,
                 enable_http2: str,
                 established_timeout: int,
                 frontend_port: int,
                 gzip: str,
                 health_check: str,
                 health_check_connect_port: int,
                 health_check_connect_timeout: int,
                 health_check_domain: str,
                 health_check_http_code: str,
                 health_check_interval: int,
                 health_check_timeout: int,
                 health_check_type: str,
                 health_check_uri: str,
                 healthy_threshold: int,
                 idle_timeout: int,
                 master_slave_server_group_id: str,
                 persistence_timeout: int,
                 protocol: str,
                 proxy_protocol_v2_enabled: bool,
                 request_timeout: int,
                 scheduler: str,
                 security_status: str,
                 server_certificate_id: str,
                 server_group_id: str,
                 ssl_certificate_id: str,
                 status: str,
                 sticky_session: str,
                 sticky_session_type: str,
                 tls_cipher_policy: str,
                 unhealthy_threshold: int,
                 x_forwarded_for: str,
                 x_forwarded_for_slb_id: str,
                 x_forwarded_for_slb_ip: str,
                 x_forwarded_for_slb_proto: str):
        """
        :param int backend_port: Port opened on the backend server to receive requests.
        :param int bandwidth: Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
        :param str ca_certificate_id: ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
        :param str cookie: Cookie configured by the backend server. Only available when the sticky_session_type is `server`.
        :param int cookie_timeout: Cookie timeout in seconds. Only available when the sticky_session_type is `insert`.
        :param str description: The description of slb listener.
        :param str enable_http2: Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
        :param int established_timeout: Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
        :param int frontend_port: Filter listeners by the specified frontend port.
        :param str gzip: Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        :param str health_check: Indicate whether health check is enabled of not. Possible values are `on` and `off`.
        :param int health_check_connect_port: Port used for health check.
        :param int health_check_connect_timeout: Amount of time in seconds to wait for the response for a health check.
        :param str health_check_domain: Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
        :param str health_check_http_code: HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as "http_2xx,http_3xx". Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
        :param int health_check_interval: Time interval between two consecutive health checks.
        :param int health_check_timeout: Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
        :param str health_check_type: Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
        :param str health_check_uri: URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
        :param int healthy_threshold: Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
        :param int idle_timeout: Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
        :param str master_slave_server_group_id: ID of the active/standby server group.
        :param int persistence_timeout: Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
        :param str protocol: Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
        :param bool proxy_protocol_v2_enabled: Whether to support carrying the client source address to the backend server through the Proxy Protocol. Valid values are `true` and `false`. Default to `false`.
        :param int request_timeout: Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
        :param str scheduler: Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
        :param str security_status: Security status. Only available when the protocol is `https`.
        :param str server_group_id: ID of the linked VServer group.
        :param str ssl_certificate_id: ID of the server certificate. Only available when the protocol is `https`.
        :param str status: Listener status.
        :param str sticky_session: Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        :param str sticky_session_type: Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and sticky_session is `on`.
        :param str tls_cipher_policy: Https listener TLS cipher policy. Valid values are `tls_cipher_policy_1_0`, `tls_cipher_policy_1_1`, `tls_cipher_policy_1_2`, `tls_cipher_policy_1_2_strict`. Default to `tls_cipher_policy_1_0`.
        :param int unhealthy_threshold: Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
        :param str x_forwarded_for: Indicate whether the HTTP header field "X-Forwarded-For" is added or not; it allows the backend server to know about the user's IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        :param str x_forwarded_for_slb_id: Indicate whether the HTTP header field "X-Forwarded-For_SLBID" is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        :param str x_forwarded_for_slb_ip: Indicate whether the HTTP header field "X-Forwarded-For_SLBIP" is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        :param str x_forwarded_for_slb_proto: Indicate whether the HTTP header field "X-Forwarded-For_proto" is added or not; it allows the backend server to know about the user's protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        GetListenersSlbListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_port=backend_port,
            bandwidth=bandwidth,
            ca_certificate_id=ca_certificate_id,
            cookie=cookie,
            cookie_timeout=cookie_timeout,
            description=description,
            enable_http2=enable_http2,
            established_timeout=established_timeout,
            frontend_port=frontend_port,
            gzip=gzip,
            health_check=health_check,
            health_check_connect_port=health_check_connect_port,
            health_check_connect_timeout=health_check_connect_timeout,
            health_check_domain=health_check_domain,
            health_check_http_code=health_check_http_code,
            health_check_interval=health_check_interval,
            health_check_timeout=health_check_timeout,
            health_check_type=health_check_type,
            health_check_uri=health_check_uri,
            healthy_threshold=healthy_threshold,
            idle_timeout=idle_timeout,
            master_slave_server_group_id=master_slave_server_group_id,
            persistence_timeout=persistence_timeout,
            protocol=protocol,
            proxy_protocol_v2_enabled=proxy_protocol_v2_enabled,
            request_timeout=request_timeout,
            scheduler=scheduler,
            security_status=security_status,
            server_certificate_id=server_certificate_id,
            server_group_id=server_group_id,
            ssl_certificate_id=ssl_certificate_id,
            status=status,
            sticky_session=sticky_session,
            sticky_session_type=sticky_session_type,
            tls_cipher_policy=tls_cipher_policy,
            unhealthy_threshold=unhealthy_threshold,
            x_forwarded_for=x_forwarded_for,
            x_forwarded_for_slb_id=x_forwarded_for_slb_id,
            x_forwarded_for_slb_ip=x_forwarded_for_slb_ip,
            x_forwarded_for_slb_proto=x_forwarded_for_slb_proto,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_port: Optional[int] = None,
             bandwidth: Optional[int] = None,
             ca_certificate_id: Optional[str] = None,
             cookie: Optional[str] = None,
             cookie_timeout: Optional[int] = None,
             description: Optional[str] = None,
             enable_http2: Optional[str] = None,
             established_timeout: Optional[int] = None,
             frontend_port: Optional[int] = None,
             gzip: Optional[str] = None,
             health_check: Optional[str] = None,
             health_check_connect_port: Optional[int] = None,
             health_check_connect_timeout: Optional[int] = None,
             health_check_domain: Optional[str] = None,
             health_check_http_code: Optional[str] = None,
             health_check_interval: Optional[int] = None,
             health_check_timeout: Optional[int] = None,
             health_check_type: Optional[str] = None,
             health_check_uri: Optional[str] = None,
             healthy_threshold: Optional[int] = None,
             idle_timeout: Optional[int] = None,
             master_slave_server_group_id: Optional[str] = None,
             persistence_timeout: Optional[int] = None,
             protocol: Optional[str] = None,
             proxy_protocol_v2_enabled: Optional[bool] = None,
             request_timeout: Optional[int] = None,
             scheduler: Optional[str] = None,
             security_status: Optional[str] = None,
             server_certificate_id: Optional[str] = None,
             server_group_id: Optional[str] = None,
             ssl_certificate_id: Optional[str] = None,
             status: Optional[str] = None,
             sticky_session: Optional[str] = None,
             sticky_session_type: Optional[str] = None,
             tls_cipher_policy: Optional[str] = None,
             unhealthy_threshold: Optional[int] = None,
             x_forwarded_for: Optional[str] = None,
             x_forwarded_for_slb_id: Optional[str] = None,
             x_forwarded_for_slb_ip: Optional[str] = None,
             x_forwarded_for_slb_proto: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if backend_port is None and 'backendPort' in kwargs:
            backend_port = kwargs['backendPort']
        if backend_port is None:
            raise TypeError("Missing 'backend_port' argument")
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if ca_certificate_id is None and 'caCertificateId' in kwargs:
            ca_certificate_id = kwargs['caCertificateId']
        if ca_certificate_id is None:
            raise TypeError("Missing 'ca_certificate_id' argument")
        if cookie is None:
            raise TypeError("Missing 'cookie' argument")
        if cookie_timeout is None and 'cookieTimeout' in kwargs:
            cookie_timeout = kwargs['cookieTimeout']
        if cookie_timeout is None:
            raise TypeError("Missing 'cookie_timeout' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if enable_http2 is None and 'enableHttp2' in kwargs:
            enable_http2 = kwargs['enableHttp2']
        if enable_http2 is None:
            raise TypeError("Missing 'enable_http2' argument")
        if established_timeout is None and 'establishedTimeout' in kwargs:
            established_timeout = kwargs['establishedTimeout']
        if established_timeout is None:
            raise TypeError("Missing 'established_timeout' argument")
        if frontend_port is None and 'frontendPort' in kwargs:
            frontend_port = kwargs['frontendPort']
        if frontend_port is None:
            raise TypeError("Missing 'frontend_port' argument")
        if gzip is None:
            raise TypeError("Missing 'gzip' argument")
        if health_check is None and 'healthCheck' in kwargs:
            health_check = kwargs['healthCheck']
        if health_check is None:
            raise TypeError("Missing 'health_check' argument")
        if health_check_connect_port is None and 'healthCheckConnectPort' in kwargs:
            health_check_connect_port = kwargs['healthCheckConnectPort']
        if health_check_connect_port is None:
            raise TypeError("Missing 'health_check_connect_port' argument")
        if health_check_connect_timeout is None and 'healthCheckConnectTimeout' in kwargs:
            health_check_connect_timeout = kwargs['healthCheckConnectTimeout']
        if health_check_connect_timeout is None:
            raise TypeError("Missing 'health_check_connect_timeout' argument")
        if health_check_domain is None and 'healthCheckDomain' in kwargs:
            health_check_domain = kwargs['healthCheckDomain']
        if health_check_domain is None:
            raise TypeError("Missing 'health_check_domain' argument")
        if health_check_http_code is None and 'healthCheckHttpCode' in kwargs:
            health_check_http_code = kwargs['healthCheckHttpCode']
        if health_check_http_code is None:
            raise TypeError("Missing 'health_check_http_code' argument")
        if health_check_interval is None and 'healthCheckInterval' in kwargs:
            health_check_interval = kwargs['healthCheckInterval']
        if health_check_interval is None:
            raise TypeError("Missing 'health_check_interval' argument")
        if health_check_timeout is None and 'healthCheckTimeout' in kwargs:
            health_check_timeout = kwargs['healthCheckTimeout']
        if health_check_timeout is None:
            raise TypeError("Missing 'health_check_timeout' argument")
        if health_check_type is None and 'healthCheckType' in kwargs:
            health_check_type = kwargs['healthCheckType']
        if health_check_type is None:
            raise TypeError("Missing 'health_check_type' argument")
        if health_check_uri is None and 'healthCheckUri' in kwargs:
            health_check_uri = kwargs['healthCheckUri']
        if health_check_uri is None:
            raise TypeError("Missing 'health_check_uri' argument")
        if healthy_threshold is None and 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if healthy_threshold is None:
            raise TypeError("Missing 'healthy_threshold' argument")
        if idle_timeout is None and 'idleTimeout' in kwargs:
            idle_timeout = kwargs['idleTimeout']
        if idle_timeout is None:
            raise TypeError("Missing 'idle_timeout' argument")
        if master_slave_server_group_id is None and 'masterSlaveServerGroupId' in kwargs:
            master_slave_server_group_id = kwargs['masterSlaveServerGroupId']
        if master_slave_server_group_id is None:
            raise TypeError("Missing 'master_slave_server_group_id' argument")
        if persistence_timeout is None and 'persistenceTimeout' in kwargs:
            persistence_timeout = kwargs['persistenceTimeout']
        if persistence_timeout is None:
            raise TypeError("Missing 'persistence_timeout' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if proxy_protocol_v2_enabled is None and 'proxyProtocolV2Enabled' in kwargs:
            proxy_protocol_v2_enabled = kwargs['proxyProtocolV2Enabled']
        if proxy_protocol_v2_enabled is None:
            raise TypeError("Missing 'proxy_protocol_v2_enabled' argument")
        if request_timeout is None and 'requestTimeout' in kwargs:
            request_timeout = kwargs['requestTimeout']
        if request_timeout is None:
            raise TypeError("Missing 'request_timeout' argument")
        if scheduler is None:
            raise TypeError("Missing 'scheduler' argument")
        if security_status is None and 'securityStatus' in kwargs:
            security_status = kwargs['securityStatus']
        if security_status is None:
            raise TypeError("Missing 'security_status' argument")
        if server_certificate_id is None and 'serverCertificateId' in kwargs:
            server_certificate_id = kwargs['serverCertificateId']
        if server_certificate_id is None:
            raise TypeError("Missing 'server_certificate_id' argument")
        if server_group_id is None and 'serverGroupId' in kwargs:
            server_group_id = kwargs['serverGroupId']
        if server_group_id is None:
            raise TypeError("Missing 'server_group_id' argument")
        if ssl_certificate_id is None and 'sslCertificateId' in kwargs:
            ssl_certificate_id = kwargs['sslCertificateId']
        if ssl_certificate_id is None:
            raise TypeError("Missing 'ssl_certificate_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if sticky_session is None and 'stickySession' in kwargs:
            sticky_session = kwargs['stickySession']
        if sticky_session is None:
            raise TypeError("Missing 'sticky_session' argument")
        if sticky_session_type is None and 'stickySessionType' in kwargs:
            sticky_session_type = kwargs['stickySessionType']
        if sticky_session_type is None:
            raise TypeError("Missing 'sticky_session_type' argument")
        if tls_cipher_policy is None and 'tlsCipherPolicy' in kwargs:
            tls_cipher_policy = kwargs['tlsCipherPolicy']
        if tls_cipher_policy is None:
            raise TypeError("Missing 'tls_cipher_policy' argument")
        if unhealthy_threshold is None and 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']
        if unhealthy_threshold is None:
            raise TypeError("Missing 'unhealthy_threshold' argument")
        if x_forwarded_for is None and 'xForwardedFor' in kwargs:
            x_forwarded_for = kwargs['xForwardedFor']
        if x_forwarded_for is None:
            raise TypeError("Missing 'x_forwarded_for' argument")
        if x_forwarded_for_slb_id is None and 'xForwardedForSlbId' in kwargs:
            x_forwarded_for_slb_id = kwargs['xForwardedForSlbId']
        if x_forwarded_for_slb_id is None:
            raise TypeError("Missing 'x_forwarded_for_slb_id' argument")
        if x_forwarded_for_slb_ip is None and 'xForwardedForSlbIp' in kwargs:
            x_forwarded_for_slb_ip = kwargs['xForwardedForSlbIp']
        if x_forwarded_for_slb_ip is None:
            raise TypeError("Missing 'x_forwarded_for_slb_ip' argument")
        if x_forwarded_for_slb_proto is None and 'xForwardedForSlbProto' in kwargs:
            x_forwarded_for_slb_proto = kwargs['xForwardedForSlbProto']
        if x_forwarded_for_slb_proto is None:
            raise TypeError("Missing 'x_forwarded_for_slb_proto' argument")

        _setter("backend_port", backend_port)
        _setter("bandwidth", bandwidth)
        _setter("ca_certificate_id", ca_certificate_id)
        _setter("cookie", cookie)
        _setter("cookie_timeout", cookie_timeout)
        _setter("description", description)
        _setter("enable_http2", enable_http2)
        _setter("established_timeout", established_timeout)
        _setter("frontend_port", frontend_port)
        _setter("gzip", gzip)
        _setter("health_check", health_check)
        _setter("health_check_connect_port", health_check_connect_port)
        _setter("health_check_connect_timeout", health_check_connect_timeout)
        _setter("health_check_domain", health_check_domain)
        _setter("health_check_http_code", health_check_http_code)
        _setter("health_check_interval", health_check_interval)
        _setter("health_check_timeout", health_check_timeout)
        _setter("health_check_type", health_check_type)
        _setter("health_check_uri", health_check_uri)
        _setter("healthy_threshold", healthy_threshold)
        _setter("idle_timeout", idle_timeout)
        _setter("master_slave_server_group_id", master_slave_server_group_id)
        _setter("persistence_timeout", persistence_timeout)
        _setter("protocol", protocol)
        _setter("proxy_protocol_v2_enabled", proxy_protocol_v2_enabled)
        _setter("request_timeout", request_timeout)
        _setter("scheduler", scheduler)
        _setter("security_status", security_status)
        _setter("server_certificate_id", server_certificate_id)
        _setter("server_group_id", server_group_id)
        _setter("ssl_certificate_id", ssl_certificate_id)
        _setter("status", status)
        _setter("sticky_session", sticky_session)
        _setter("sticky_session_type", sticky_session_type)
        _setter("tls_cipher_policy", tls_cipher_policy)
        _setter("unhealthy_threshold", unhealthy_threshold)
        _setter("x_forwarded_for", x_forwarded_for)
        _setter("x_forwarded_for_slb_id", x_forwarded_for_slb_id)
        _setter("x_forwarded_for_slb_ip", x_forwarded_for_slb_ip)
        _setter("x_forwarded_for_slb_proto", x_forwarded_for_slb_proto)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> int:
        """
        Port opened on the backend server to receive requests.
        """
        return pulumi.get(self, "backend_port")

    @property
    @pulumi.getter
    def bandwidth(self) -> int:
        """
        Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="caCertificateId")
    def ca_certificate_id(self) -> str:
        """
        ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
        """
        return pulumi.get(self, "ca_certificate_id")

    @property
    @pulumi.getter
    def cookie(self) -> str:
        """
        Cookie configured by the backend server. Only available when the sticky_session_type is `server`.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> int:
        """
        Cookie timeout in seconds. Only available when the sticky_session_type is `insert`.
        """
        return pulumi.get(self, "cookie_timeout")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of slb listener.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableHttp2")
    def enable_http2(self) -> str:
        """
        Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
        """
        return pulumi.get(self, "enable_http2")

    @property
    @pulumi.getter(name="establishedTimeout")
    def established_timeout(self) -> int:
        """
        Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
        """
        return pulumi.get(self, "established_timeout")

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> int:
        """
        Filter listeners by the specified frontend port.
        """
        return pulumi.get(self, "frontend_port")

    @property
    @pulumi.getter
    def gzip(self) -> str:
        """
        Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> str:
        """
        Indicate whether health check is enabled of not. Possible values are `on` and `off`.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> int:
        """
        Port used for health check.
        """
        return pulumi.get(self, "health_check_connect_port")

    @property
    @pulumi.getter(name="healthCheckConnectTimeout")
    def health_check_connect_timeout(self) -> int:
        """
        Amount of time in seconds to wait for the response for a health check.
        """
        return pulumi.get(self, "health_check_connect_timeout")

    @property
    @pulumi.getter(name="healthCheckDomain")
    def health_check_domain(self) -> str:
        """
        Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
        """
        return pulumi.get(self, "health_check_domain")

    @property
    @pulumi.getter(name="healthCheckHttpCode")
    def health_check_http_code(self) -> str:
        """
        HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as "http_2xx,http_3xx". Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
        """
        return pulumi.get(self, "health_check_http_code")

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> int:
        """
        Time interval between two consecutive health checks.
        """
        return pulumi.get(self, "health_check_interval")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> int:
        """
        Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> str:
        """
        Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
        """
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="healthCheckUri")
    def health_check_uri(self) -> str:
        """
        URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
        """
        return pulumi.get(self, "health_check_uri")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> int:
        """
        Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="masterSlaveServerGroupId")
    def master_slave_server_group_id(self) -> str:
        """
        ID of the active/standby server group.
        """
        return pulumi.get(self, "master_slave_server_group_id")

    @property
    @pulumi.getter(name="persistenceTimeout")
    def persistence_timeout(self) -> int:
        """
        Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
        """
        return pulumi.get(self, "persistence_timeout")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="proxyProtocolV2Enabled")
    def proxy_protocol_v2_enabled(self) -> bool:
        """
        Whether to support carrying the client source address to the backend server through the Proxy Protocol. Valid values are `true` and `false`. Default to `false`.
        """
        return pulumi.get(self, "proxy_protocol_v2_enabled")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> int:
        """
        Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter
    def scheduler(self) -> str:
        """
        Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
        """
        return pulumi.get(self, "scheduler")

    @property
    @pulumi.getter(name="securityStatus")
    def security_status(self) -> str:
        """
        Security status. Only available when the protocol is `https`.
        """
        return pulumi.get(self, "security_status")

    @property
    @pulumi.getter(name="serverCertificateId")
    def server_certificate_id(self) -> str:
        return pulumi.get(self, "server_certificate_id")

    @property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> str:
        """
        ID of the linked VServer group.
        """
        return pulumi.get(self, "server_group_id")

    @property
    @pulumi.getter(name="sslCertificateId")
    def ssl_certificate_id(self) -> str:
        """
        ID of the server certificate. Only available when the protocol is `https`.
        """
        return pulumi.get(self, "ssl_certificate_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Listener status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stickySession")
    def sticky_session(self) -> str:
        """
        Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "sticky_session")

    @property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> str:
        """
        Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and sticky_session is `on`.
        """
        return pulumi.get(self, "sticky_session_type")

    @property
    @pulumi.getter(name="tlsCipherPolicy")
    def tls_cipher_policy(self) -> str:
        """
        Https listener TLS cipher policy. Valid values are `tls_cipher_policy_1_0`, `tls_cipher_policy_1_1`, `tls_cipher_policy_1_2`, `tls_cipher_policy_1_2_strict`. Default to `tls_cipher_policy_1_0`.
        """
        return pulumi.get(self, "tls_cipher_policy")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
        """
        return pulumi.get(self, "unhealthy_threshold")

    @property
    @pulumi.getter(name="xForwardedFor")
    def x_forwarded_for(self) -> str:
        """
        Indicate whether the HTTP header field "X-Forwarded-For" is added or not; it allows the backend server to know about the user's IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "x_forwarded_for")

    @property
    @pulumi.getter(name="xForwardedForSlbId")
    def x_forwarded_for_slb_id(self) -> str:
        """
        Indicate whether the HTTP header field "X-Forwarded-For_SLBID" is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "x_forwarded_for_slb_id")

    @property
    @pulumi.getter(name="xForwardedForSlbIp")
    def x_forwarded_for_slb_ip(self) -> str:
        """
        Indicate whether the HTTP header field "X-Forwarded-For_SLBIP" is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "x_forwarded_for_slb_ip")

    @property
    @pulumi.getter(name="xForwardedForSlbProto")
    def x_forwarded_for_slb_proto(self) -> str:
        """
        Indicate whether the HTTP header field "X-Forwarded-For_proto" is added or not; it allows the backend server to know about the user's protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
        """
        return pulumi.get(self, "x_forwarded_for_slb_proto")


@pulumi.output_type
class GetLoadBalancersBalancerResult(dict):
    def __init__(__self__, *,
                 address: str,
                 address_ip_version: str,
                 address_type: str,
                 auto_release_time: int,
                 backend_servers: Sequence['outputs.GetLoadBalancersBalancerBackendServerResult'],
                 bandwidth: int,
                 create_time_stamp: int,
                 delete_protection: str,
                 end_time: str,
                 end_time_stamp: int,
                 id: str,
                 internet_charge_type: str,
                 listener_ports_and_protocals: Sequence['outputs.GetLoadBalancersBalancerListenerPortsAndProtocalResult'],
                 listener_ports_and_protocols: Sequence['outputs.GetLoadBalancersBalancerListenerPortsAndProtocolResult'],
                 load_balancer_id: str,
                 load_balancer_name: str,
                 load_balancer_spec: str,
                 master_zone_id: str,
                 modification_protection_reason: str,
                 modification_protection_status: str,
                 network_type: str,
                 payment_type: str,
                 region_id_alias: str,
                 renewal_cyc_unit: str,
                 renewal_duration: int,
                 renewal_status: str,
                 resource_group_id: str,
                 slave_zone_id: str,
                 status: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param str address: Service address of the SLBs.
        :param str id: ID of the SLB.
        :param str network_type: Network type of the SLBs. Valid values: `vpc` and `classic`.
        :param str resource_group_id: The Id of resource group which SLB belongs.
        :param str status: SLB current status. Possible values: `inactive`, `active` and `locked`.
        :param Mapping[str, Any] tags: A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
               ```python
               import pulumi
               import pulumi_alicloud as alicloud
               
               tagged_instances = alicloud.slb.get_load_balancers(tags={
                   "tagKey1": "tagValue1",
                   "tagKey2": "tagValue2",
               })
               ```
        :param str vpc_id: ID of the VPC linked to the SLBs.
        :param str vswitch_id: ID of the VSwitch linked to the SLBs.
        """
        GetLoadBalancersBalancerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            address_ip_version=address_ip_version,
            address_type=address_type,
            auto_release_time=auto_release_time,
            backend_servers=backend_servers,
            bandwidth=bandwidth,
            create_time_stamp=create_time_stamp,
            delete_protection=delete_protection,
            end_time=end_time,
            end_time_stamp=end_time_stamp,
            id=id,
            internet_charge_type=internet_charge_type,
            listener_ports_and_protocals=listener_ports_and_protocals,
            listener_ports_and_protocols=listener_ports_and_protocols,
            load_balancer_id=load_balancer_id,
            load_balancer_name=load_balancer_name,
            load_balancer_spec=load_balancer_spec,
            master_zone_id=master_zone_id,
            modification_protection_reason=modification_protection_reason,
            modification_protection_status=modification_protection_status,
            network_type=network_type,
            payment_type=payment_type,
            region_id_alias=region_id_alias,
            renewal_cyc_unit=renewal_cyc_unit,
            renewal_duration=renewal_duration,
            renewal_status=renewal_status,
            resource_group_id=resource_group_id,
            slave_zone_id=slave_zone_id,
            status=status,
            tags=tags,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             address_ip_version: Optional[str] = None,
             address_type: Optional[str] = None,
             auto_release_time: Optional[int] = None,
             backend_servers: Optional[Sequence['outputs.GetLoadBalancersBalancerBackendServerResult']] = None,
             bandwidth: Optional[int] = None,
             create_time_stamp: Optional[int] = None,
             delete_protection: Optional[str] = None,
             end_time: Optional[str] = None,
             end_time_stamp: Optional[int] = None,
             id: Optional[str] = None,
             internet_charge_type: Optional[str] = None,
             listener_ports_and_protocals: Optional[Sequence['outputs.GetLoadBalancersBalancerListenerPortsAndProtocalResult']] = None,
             listener_ports_and_protocols: Optional[Sequence['outputs.GetLoadBalancersBalancerListenerPortsAndProtocolResult']] = None,
             load_balancer_id: Optional[str] = None,
             load_balancer_name: Optional[str] = None,
             load_balancer_spec: Optional[str] = None,
             master_zone_id: Optional[str] = None,
             modification_protection_reason: Optional[str] = None,
             modification_protection_status: Optional[str] = None,
             network_type: Optional[str] = None,
             payment_type: Optional[str] = None,
             region_id_alias: Optional[str] = None,
             renewal_cyc_unit: Optional[str] = None,
             renewal_duration: Optional[int] = None,
             renewal_status: Optional[str] = None,
             resource_group_id: Optional[str] = None,
             slave_zone_id: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if address_ip_version is None and 'addressIpVersion' in kwargs:
            address_ip_version = kwargs['addressIpVersion']
        if address_ip_version is None:
            raise TypeError("Missing 'address_ip_version' argument")
        if address_type is None and 'addressType' in kwargs:
            address_type = kwargs['addressType']
        if address_type is None:
            raise TypeError("Missing 'address_type' argument")
        if auto_release_time is None and 'autoReleaseTime' in kwargs:
            auto_release_time = kwargs['autoReleaseTime']
        if auto_release_time is None:
            raise TypeError("Missing 'auto_release_time' argument")
        if backend_servers is None and 'backendServers' in kwargs:
            backend_servers = kwargs['backendServers']
        if backend_servers is None:
            raise TypeError("Missing 'backend_servers' argument")
        if bandwidth is None:
            raise TypeError("Missing 'bandwidth' argument")
        if create_time_stamp is None and 'createTimeStamp' in kwargs:
            create_time_stamp = kwargs['createTimeStamp']
        if create_time_stamp is None:
            raise TypeError("Missing 'create_time_stamp' argument")
        if delete_protection is None and 'deleteProtection' in kwargs:
            delete_protection = kwargs['deleteProtection']
        if delete_protection is None:
            raise TypeError("Missing 'delete_protection' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if end_time is None:
            raise TypeError("Missing 'end_time' argument")
        if end_time_stamp is None and 'endTimeStamp' in kwargs:
            end_time_stamp = kwargs['endTimeStamp']
        if end_time_stamp is None:
            raise TypeError("Missing 'end_time_stamp' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if internet_charge_type is None and 'internetChargeType' in kwargs:
            internet_charge_type = kwargs['internetChargeType']
        if internet_charge_type is None:
            raise TypeError("Missing 'internet_charge_type' argument")
        if listener_ports_and_protocals is None and 'listenerPortsAndProtocals' in kwargs:
            listener_ports_and_protocals = kwargs['listenerPortsAndProtocals']
        if listener_ports_and_protocals is None:
            raise TypeError("Missing 'listener_ports_and_protocals' argument")
        if listener_ports_and_protocols is None and 'listenerPortsAndProtocols' in kwargs:
            listener_ports_and_protocols = kwargs['listenerPortsAndProtocols']
        if listener_ports_and_protocols is None:
            raise TypeError("Missing 'listener_ports_and_protocols' argument")
        if load_balancer_id is None and 'loadBalancerId' in kwargs:
            load_balancer_id = kwargs['loadBalancerId']
        if load_balancer_id is None:
            raise TypeError("Missing 'load_balancer_id' argument")
        if load_balancer_name is None and 'loadBalancerName' in kwargs:
            load_balancer_name = kwargs['loadBalancerName']
        if load_balancer_name is None:
            raise TypeError("Missing 'load_balancer_name' argument")
        if load_balancer_spec is None and 'loadBalancerSpec' in kwargs:
            load_balancer_spec = kwargs['loadBalancerSpec']
        if load_balancer_spec is None:
            raise TypeError("Missing 'load_balancer_spec' argument")
        if master_zone_id is None and 'masterZoneId' in kwargs:
            master_zone_id = kwargs['masterZoneId']
        if master_zone_id is None:
            raise TypeError("Missing 'master_zone_id' argument")
        if modification_protection_reason is None and 'modificationProtectionReason' in kwargs:
            modification_protection_reason = kwargs['modificationProtectionReason']
        if modification_protection_reason is None:
            raise TypeError("Missing 'modification_protection_reason' argument")
        if modification_protection_status is None and 'modificationProtectionStatus' in kwargs:
            modification_protection_status = kwargs['modificationProtectionStatus']
        if modification_protection_status is None:
            raise TypeError("Missing 'modification_protection_status' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if payment_type is None and 'paymentType' in kwargs:
            payment_type = kwargs['paymentType']
        if payment_type is None:
            raise TypeError("Missing 'payment_type' argument")
        if region_id_alias is None and 'regionIdAlias' in kwargs:
            region_id_alias = kwargs['regionIdAlias']
        if region_id_alias is None:
            raise TypeError("Missing 'region_id_alias' argument")
        if renewal_cyc_unit is None and 'renewalCycUnit' in kwargs:
            renewal_cyc_unit = kwargs['renewalCycUnit']
        if renewal_cyc_unit is None:
            raise TypeError("Missing 'renewal_cyc_unit' argument")
        if renewal_duration is None and 'renewalDuration' in kwargs:
            renewal_duration = kwargs['renewalDuration']
        if renewal_duration is None:
            raise TypeError("Missing 'renewal_duration' argument")
        if renewal_status is None and 'renewalStatus' in kwargs:
            renewal_status = kwargs['renewalStatus']
        if renewal_status is None:
            raise TypeError("Missing 'renewal_status' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']
        if resource_group_id is None:
            raise TypeError("Missing 'resource_group_id' argument")
        if slave_zone_id is None and 'slaveZoneId' in kwargs:
            slave_zone_id = kwargs['slaveZoneId']
        if slave_zone_id is None:
            raise TypeError("Missing 'slave_zone_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("address", address)
        _setter("address_ip_version", address_ip_version)
        _setter("address_type", address_type)
        _setter("auto_release_time", auto_release_time)
        _setter("backend_servers", backend_servers)
        _setter("bandwidth", bandwidth)
        _setter("create_time_stamp", create_time_stamp)
        _setter("delete_protection", delete_protection)
        _setter("end_time", end_time)
        _setter("end_time_stamp", end_time_stamp)
        _setter("id", id)
        _setter("internet_charge_type", internet_charge_type)
        _setter("listener_ports_and_protocals", listener_ports_and_protocals)
        _setter("listener_ports_and_protocols", listener_ports_and_protocols)
        _setter("load_balancer_id", load_balancer_id)
        _setter("load_balancer_name", load_balancer_name)
        _setter("load_balancer_spec", load_balancer_spec)
        _setter("master_zone_id", master_zone_id)
        _setter("modification_protection_reason", modification_protection_reason)
        _setter("modification_protection_status", modification_protection_status)
        _setter("network_type", network_type)
        _setter("payment_type", payment_type)
        _setter("region_id_alias", region_id_alias)
        _setter("renewal_cyc_unit", renewal_cyc_unit)
        _setter("renewal_duration", renewal_duration)
        _setter("renewal_status", renewal_status)
        _setter("resource_group_id", resource_group_id)
        _setter("slave_zone_id", slave_zone_id)
        _setter("status", status)
        _setter("tags", tags)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Service address of the SLBs.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressIpVersion")
    def address_ip_version(self) -> str:
        return pulumi.get(self, "address_ip_version")

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> str:
        return pulumi.get(self, "address_type")

    @property
    @pulumi.getter(name="autoReleaseTime")
    def auto_release_time(self) -> int:
        return pulumi.get(self, "auto_release_time")

    @property
    @pulumi.getter(name="backendServers")
    def backend_servers(self) -> Sequence['outputs.GetLoadBalancersBalancerBackendServerResult']:
        return pulumi.get(self, "backend_servers")

    @property
    @pulumi.getter
    def bandwidth(self) -> int:
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="createTimeStamp")
    def create_time_stamp(self) -> int:
        return pulumi.get(self, "create_time_stamp")

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> str:
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="endTimeStamp")
    def end_time_stamp(self) -> int:
        return pulumi.get(self, "end_time_stamp")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the SLB.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetChargeType")
    def internet_charge_type(self) -> str:
        return pulumi.get(self, "internet_charge_type")

    @property
    @pulumi.getter(name="listenerPortsAndProtocals")
    def listener_ports_and_protocals(self) -> Sequence['outputs.GetLoadBalancersBalancerListenerPortsAndProtocalResult']:
        return pulumi.get(self, "listener_ports_and_protocals")

    @property
    @pulumi.getter(name="listenerPortsAndProtocols")
    def listener_ports_and_protocols(self) -> Sequence['outputs.GetLoadBalancersBalancerListenerPortsAndProtocolResult']:
        return pulumi.get(self, "listener_ports_and_protocols")

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> str:
        return pulumi.get(self, "load_balancer_id")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="loadBalancerSpec")
    def load_balancer_spec(self) -> str:
        return pulumi.get(self, "load_balancer_spec")

    @property
    @pulumi.getter(name="masterZoneId")
    def master_zone_id(self) -> str:
        return pulumi.get(self, "master_zone_id")

    @property
    @pulumi.getter(name="modificationProtectionReason")
    def modification_protection_reason(self) -> str:
        return pulumi.get(self, "modification_protection_reason")

    @property
    @pulumi.getter(name="modificationProtectionStatus")
    def modification_protection_status(self) -> str:
        return pulumi.get(self, "modification_protection_status")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        Network type of the SLBs. Valid values: `vpc` and `classic`.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="regionIdAlias")
    def region_id_alias(self) -> str:
        return pulumi.get(self, "region_id_alias")

    @property
    @pulumi.getter(name="renewalCycUnit")
    def renewal_cyc_unit(self) -> str:
        return pulumi.get(self, "renewal_cyc_unit")

    @property
    @pulumi.getter(name="renewalDuration")
    def renewal_duration(self) -> int:
        return pulumi.get(self, "renewal_duration")

    @property
    @pulumi.getter(name="renewalStatus")
    def renewal_status(self) -> str:
        return pulumi.get(self, "renewal_status")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Id of resource group which SLB belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="slaveZoneId")
    def slave_zone_id(self) -> str:
        return pulumi.get(self, "slave_zone_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        SLB current status. Possible values: `inactive`, `active` and `locked`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
        ```python
        import pulumi
        import pulumi_alicloud as alicloud

        tagged_instances = alicloud.slb.get_load_balancers(tags={
            "tagKey1": "tagValue1",
            "tagKey2": "tagValue2",
        })
        ```
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC linked to the SLBs.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        ID of the VSwitch linked to the SLBs.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetLoadBalancersBalancerBackendServerResult(dict):
    def __init__(__self__, *,
                 description: str,
                 server_id: str,
                 type: str,
                 weight: int):
        GetLoadBalancersBalancerBackendServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            server_id=server_id,
            type=type,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             server_id: Optional[str] = None,
             type: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if server_id is None and 'serverId' in kwargs:
            server_id = kwargs['serverId']
        if server_id is None:
            raise TypeError("Missing 'server_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("description", description)
        _setter("server_id", server_id)
        _setter("type", type)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetLoadBalancersBalancerListenerPortsAndProtocalResult(dict):
    def __init__(__self__, *,
                 listener_port: int,
                 listener_protocal: str):
        GetLoadBalancersBalancerListenerPortsAndProtocalResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            listener_port=listener_port,
            listener_protocal=listener_protocal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             listener_port: Optional[int] = None,
             listener_protocal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if listener_port is None:
            raise TypeError("Missing 'listener_port' argument")
        if listener_protocal is None and 'listenerProtocal' in kwargs:
            listener_protocal = kwargs['listenerProtocal']
        if listener_protocal is None:
            raise TypeError("Missing 'listener_protocal' argument")

        _setter("listener_port", listener_port)
        _setter("listener_protocal", listener_protocal)

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="listenerProtocal")
    def listener_protocal(self) -> str:
        return pulumi.get(self, "listener_protocal")


@pulumi.output_type
class GetLoadBalancersBalancerListenerPortsAndProtocolResult(dict):
    def __init__(__self__, *,
                 description: str,
                 forward_port: int,
                 listener_forward: str,
                 listener_port: int,
                 listener_protocol: str):
        GetLoadBalancersBalancerListenerPortsAndProtocolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            forward_port=forward_port,
            listener_forward=listener_forward,
            listener_port=listener_port,
            listener_protocol=listener_protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             forward_port: Optional[int] = None,
             listener_forward: Optional[str] = None,
             listener_port: Optional[int] = None,
             listener_protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if forward_port is None and 'forwardPort' in kwargs:
            forward_port = kwargs['forwardPort']
        if forward_port is None:
            raise TypeError("Missing 'forward_port' argument")
        if listener_forward is None and 'listenerForward' in kwargs:
            listener_forward = kwargs['listenerForward']
        if listener_forward is None:
            raise TypeError("Missing 'listener_forward' argument")
        if listener_port is None and 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if listener_port is None:
            raise TypeError("Missing 'listener_port' argument")
        if listener_protocol is None and 'listenerProtocol' in kwargs:
            listener_protocol = kwargs['listenerProtocol']
        if listener_protocol is None:
            raise TypeError("Missing 'listener_protocol' argument")

        _setter("description", description)
        _setter("forward_port", forward_port)
        _setter("listener_forward", listener_forward)
        _setter("listener_port", listener_port)
        _setter("listener_protocol", listener_protocol)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> int:
        return pulumi.get(self, "forward_port")

    @property
    @pulumi.getter(name="listenerForward")
    def listener_forward(self) -> str:
        return pulumi.get(self, "listener_forward")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="listenerProtocol")
    def listener_protocol(self) -> str:
        return pulumi.get(self, "listener_protocol")


@pulumi.output_type
class GetLoadBalancersSlbResult(dict):
    def __init__(__self__, *,
                 address: str,
                 creation_time: str,
                 id: str,
                 internet: bool,
                 master_availability_zone: str,
                 name: str,
                 network_type: str,
                 region_id: str,
                 slave_availability_zone: str,
                 status: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param str address: Service address of the SLBs.
        :param str creation_time: SLB creation time.
        :param str id: ID of the SLB.
        :param bool internet: SLB addressType: internet if `true`, intranet if `false`. Must be `false` when `network_type` is `vpc`.
        :param str master_availability_zone: Master availability zone of the SLBs.
        :param str name: SLB name.
        :param str network_type: Network type of the SLBs. Valid values: `vpc` and `classic`.
        :param str region_id: Region ID the SLB belongs to.
        :param str slave_availability_zone: Slave availability zone of the SLBs.
        :param str status: SLB current status. Possible values: `inactive`, `active` and `locked`.
        :param Mapping[str, Any] tags: A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
               ```python
               import pulumi
               import pulumi_alicloud as alicloud
               
               tagged_instances = alicloud.slb.get_load_balancers(tags={
                   "tagKey1": "tagValue1",
                   "tagKey2": "tagValue2",
               })
               ```
        :param str vpc_id: ID of the VPC linked to the SLBs.
        :param str vswitch_id: ID of the VSwitch linked to the SLBs.
        """
        GetLoadBalancersSlbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            creation_time=creation_time,
            id=id,
            internet=internet,
            master_availability_zone=master_availability_zone,
            name=name,
            network_type=network_type,
            region_id=region_id,
            slave_availability_zone=slave_availability_zone,
            status=status,
            tags=tags,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             creation_time: Optional[str] = None,
             id: Optional[str] = None,
             internet: Optional[bool] = None,
             master_availability_zone: Optional[str] = None,
             name: Optional[str] = None,
             network_type: Optional[str] = None,
             region_id: Optional[str] = None,
             slave_availability_zone: Optional[str] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if creation_time is None and 'creationTime' in kwargs:
            creation_time = kwargs['creationTime']
        if creation_time is None:
            raise TypeError("Missing 'creation_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if internet is None:
            raise TypeError("Missing 'internet' argument")
        if master_availability_zone is None and 'masterAvailabilityZone' in kwargs:
            master_availability_zone = kwargs['masterAvailabilityZone']
        if master_availability_zone is None:
            raise TypeError("Missing 'master_availability_zone' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if slave_availability_zone is None and 'slaveAvailabilityZone' in kwargs:
            slave_availability_zone = kwargs['slaveAvailabilityZone']
        if slave_availability_zone is None:
            raise TypeError("Missing 'slave_availability_zone' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("address", address)
        _setter("creation_time", creation_time)
        _setter("id", id)
        _setter("internet", internet)
        _setter("master_availability_zone", master_availability_zone)
        _setter("name", name)
        _setter("network_type", network_type)
        _setter("region_id", region_id)
        _setter("slave_availability_zone", slave_availability_zone)
        _setter("status", status)
        _setter("tags", tags)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Service address of the SLBs.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        SLB creation time.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the SLB.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def internet(self) -> bool:
        """
        SLB addressType: internet if `true`, intranet if `false`. Must be `false` when `network_type` is `vpc`.
        """
        return pulumi.get(self, "internet")

    @property
    @pulumi.getter(name="masterAvailabilityZone")
    def master_availability_zone(self) -> str:
        """
        Master availability zone of the SLBs.
        """
        return pulumi.get(self, "master_availability_zone")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        SLB name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        Network type of the SLBs. Valid values: `vpc` and `classic`.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        Region ID the SLB belongs to.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="slaveAvailabilityZone")
    def slave_availability_zone(self) -> str:
        """
        Slave availability zone of the SLBs.
        """
        return pulumi.get(self, "slave_availability_zone")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        SLB current status. Possible values: `inactive`, `active` and `locked`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the SLB instances. The `tags` can have a maximum of 5 tag. It must be in the format:
        ```python
        import pulumi
        import pulumi_alicloud as alicloud

        tagged_instances = alicloud.slb.get_load_balancers(tags={
            "tagKey1": "tagValue1",
            "tagKey2": "tagValue2",
        })
        ```
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the VPC linked to the SLBs.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        ID of the VSwitch linked to the SLBs.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetMasterSlaveServerGroupsGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 servers: Sequence['outputs.GetMasterSlaveServerGroupsGroupServerResult']):
        """
        :param str id: master slave server group ID.
        :param str name: master slave server group name.
        :param Sequence['GetMasterSlaveServerGroupsGroupServerArgs'] servers: ECS instances associated to the group. Each element contains the following attributes:
        """
        GetMasterSlaveServerGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            servers=servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             servers: Optional[Sequence['outputs.GetMasterSlaveServerGroupsGroupServerResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if servers is None:
            raise TypeError("Missing 'servers' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("servers", servers)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        master slave server group ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        master slave server group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetMasterSlaveServerGroupsGroupServerResult']:
        """
        ECS instances associated to the group. Each element contains the following attributes:
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetMasterSlaveServerGroupsGroupServerResult(dict):
    def __init__(__self__, *,
                 instance_id: str,
                 is_backup: int,
                 port: int,
                 server_type: str,
                 weight: int):
        """
        :param str instance_id: ID of the attached ECS instance.
        :param int is_backup: (Removed from v1.63.0) Determine if the server is executing.
        :param int port: The port used by the master slave server group.
        :param str server_type: The server type of the attached ECS instance.
        :param int weight: Weight associated to the ECS instance.
        """
        GetMasterSlaveServerGroupsGroupServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_id=instance_id,
            is_backup=is_backup,
            port=port,
            server_type=server_type,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_id: Optional[str] = None,
             is_backup: Optional[int] = None,
             port: Optional[int] = None,
             server_type: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if is_backup is None and 'isBackup' in kwargs:
            is_backup = kwargs['isBackup']
        if is_backup is None:
            raise TypeError("Missing 'is_backup' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if server_type is None and 'serverType' in kwargs:
            server_type = kwargs['serverType']
        if server_type is None:
            raise TypeError("Missing 'server_type' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("instance_id", instance_id)
        _setter("is_backup", is_backup)
        _setter("port", port)
        _setter("server_type", server_type)
        _setter("weight", weight)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of the attached ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> int:
        """
        (Removed from v1.63.0) Determine if the server is executing.
        """
        return pulumi.get(self, "is_backup")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used by the master slave server group.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        """
        The server type of the attached ECS instance.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight associated to the ECS instance.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRulesSlbRuleResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 id: str,
                 name: str,
                 server_group_id: str,
                 url: str):
        """
        :param str domain: Domain name in the HTTP request where the rule applies (e.g. "*.aliyun.com").
        :param str id: Rule ID.
        :param str name: Rule name.
        :param str server_group_id: ID of the linked VServer group.
        :param str url: Path in the HTTP request where the rule applies (e.g. "/image").
        """
        GetRulesSlbRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            id=id,
            name=name,
            server_group_id=server_group_id,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             server_group_id: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if domain is None:
            raise TypeError("Missing 'domain' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if server_group_id is None and 'serverGroupId' in kwargs:
            server_group_id = kwargs['serverGroupId']
        if server_group_id is None:
            raise TypeError("Missing 'server_group_id' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")

        _setter("domain", domain)
        _setter("id", id)
        _setter("name", name)
        _setter("server_group_id", server_group_id)
        _setter("url", url)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Domain name in the HTTP request where the rule applies (e.g. "*.aliyun.com").
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Rule ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> str:
        """
        ID of the linked VServer group.
        """
        return pulumi.get(self, "server_group_id")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Path in the HTTP request where the rule applies (e.g. "/image").
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetServerCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 alicloud_certificate_id: str,
                 alicloud_certificate_name: str,
                 common_name: str,
                 created_time: str,
                 created_timestamp: int,
                 expired_time: str,
                 expired_timestamp: int,
                 fingerprint: str,
                 id: str,
                 is_alicloud_certificate: bool,
                 name: str,
                 subject_alternative_names: Sequence[str],
                 resource_group_id: Optional[str] = None,
                 tags: Optional[Mapping[str, Any]] = None):
        """
        :param str alicloud_certificate_id: Id of server certificate issued by alibaba cloud.
        :param str alicloud_certificate_name: Name of server certificate issued by alibaba cloud.
        :param str common_name: Server certificate common name.
        :param str created_time: Server certificate created time.
        :param int created_timestamp: Server certificate created timestamp.
        :param str expired_time: Server certificate expired time.
        :param int expired_timestamp: Server certificate expired timestamp.
        :param str fingerprint: Server certificate fingerprint.
        :param str id: Server certificate ID.
        :param bool is_alicloud_certificate: Is server certificate issued by alibaba cloud or not.
        :param str name: Server certificate name.
        :param Sequence[str] subject_alternative_names: Server certificate subject alternative name list.
        :param str resource_group_id: The Id of resource group which the slb server certificates belongs.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        """
        GetServerCertificatesCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alicloud_certificate_id=alicloud_certificate_id,
            alicloud_certificate_name=alicloud_certificate_name,
            common_name=common_name,
            created_time=created_time,
            created_timestamp=created_timestamp,
            expired_time=expired_time,
            expired_timestamp=expired_timestamp,
            fingerprint=fingerprint,
            id=id,
            is_alicloud_certificate=is_alicloud_certificate,
            name=name,
            subject_alternative_names=subject_alternative_names,
            resource_group_id=resource_group_id,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alicloud_certificate_id: Optional[str] = None,
             alicloud_certificate_name: Optional[str] = None,
             common_name: Optional[str] = None,
             created_time: Optional[str] = None,
             created_timestamp: Optional[int] = None,
             expired_time: Optional[str] = None,
             expired_timestamp: Optional[int] = None,
             fingerprint: Optional[str] = None,
             id: Optional[str] = None,
             is_alicloud_certificate: Optional[bool] = None,
             name: Optional[str] = None,
             subject_alternative_names: Optional[Sequence[str]] = None,
             resource_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alicloud_certificate_id is None and 'alicloudCertificateId' in kwargs:
            alicloud_certificate_id = kwargs['alicloudCertificateId']
        if alicloud_certificate_id is None:
            raise TypeError("Missing 'alicloud_certificate_id' argument")
        if alicloud_certificate_name is None and 'alicloudCertificateName' in kwargs:
            alicloud_certificate_name = kwargs['alicloudCertificateName']
        if alicloud_certificate_name is None:
            raise TypeError("Missing 'alicloud_certificate_name' argument")
        if common_name is None and 'commonName' in kwargs:
            common_name = kwargs['commonName']
        if common_name is None:
            raise TypeError("Missing 'common_name' argument")
        if created_time is None and 'createdTime' in kwargs:
            created_time = kwargs['createdTime']
        if created_time is None:
            raise TypeError("Missing 'created_time' argument")
        if created_timestamp is None and 'createdTimestamp' in kwargs:
            created_timestamp = kwargs['createdTimestamp']
        if created_timestamp is None:
            raise TypeError("Missing 'created_timestamp' argument")
        if expired_time is None and 'expiredTime' in kwargs:
            expired_time = kwargs['expiredTime']
        if expired_time is None:
            raise TypeError("Missing 'expired_time' argument")
        if expired_timestamp is None and 'expiredTimestamp' in kwargs:
            expired_timestamp = kwargs['expiredTimestamp']
        if expired_timestamp is None:
            raise TypeError("Missing 'expired_timestamp' argument")
        if fingerprint is None:
            raise TypeError("Missing 'fingerprint' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_alicloud_certificate is None and 'isAlicloudCertificate' in kwargs:
            is_alicloud_certificate = kwargs['isAlicloudCertificate']
        if is_alicloud_certificate is None:
            raise TypeError("Missing 'is_alicloud_certificate' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if subject_alternative_names is None:
            raise TypeError("Missing 'subject_alternative_names' argument")
        if resource_group_id is None and 'resourceGroupId' in kwargs:
            resource_group_id = kwargs['resourceGroupId']

        _setter("alicloud_certificate_id", alicloud_certificate_id)
        _setter("alicloud_certificate_name", alicloud_certificate_name)
        _setter("common_name", common_name)
        _setter("created_time", created_time)
        _setter("created_timestamp", created_timestamp)
        _setter("expired_time", expired_time)
        _setter("expired_timestamp", expired_timestamp)
        _setter("fingerprint", fingerprint)
        _setter("id", id)
        _setter("is_alicloud_certificate", is_alicloud_certificate)
        _setter("name", name)
        _setter("subject_alternative_names", subject_alternative_names)
        if resource_group_id is not None:
            _setter("resource_group_id", resource_group_id)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="alicloudCertificateId")
    def alicloud_certificate_id(self) -> str:
        """
        Id of server certificate issued by alibaba cloud.
        """
        return pulumi.get(self, "alicloud_certificate_id")

    @property
    @pulumi.getter(name="alicloudCertificateName")
    def alicloud_certificate_name(self) -> str:
        """
        Name of server certificate issued by alibaba cloud.
        """
        return pulumi.get(self, "alicloud_certificate_name")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        Server certificate common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        Server certificate created time.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="createdTimestamp")
    def created_timestamp(self) -> int:
        """
        Server certificate created timestamp.
        """
        return pulumi.get(self, "created_timestamp")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> str:
        """
        Server certificate expired time.
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter(name="expiredTimestamp")
    def expired_timestamp(self) -> int:
        """
        Server certificate expired timestamp.
        """
        return pulumi.get(self, "expired_timestamp")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        Server certificate fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Server certificate ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAlicloudCertificate")
    def is_alicloud_certificate(self) -> bool:
        """
        Is server certificate issued by alibaba cloud or not.
        """
        return pulumi.get(self, "is_alicloud_certificate")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Server certificate name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[str]:
        """
        Server certificate subject alternative name list.
        """
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> Optional[str]:
        """
        The Id of resource group which the slb server certificates belongs.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetServerGroupsSlbServerGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 servers: Sequence['outputs.GetServerGroupsSlbServerGroupServerResult']):
        """
        :param str id: VServer group ID.
        :param str name: VServer group name.
        :param Sequence['GetServerGroupsSlbServerGroupServerArgs'] servers: ECS instances associated to the group. Each element contains the following attributes:
        """
        GetServerGroupsSlbServerGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            servers=servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             servers: Optional[Sequence['outputs.GetServerGroupsSlbServerGroupServerResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if servers is None:
            raise TypeError("Missing 'servers' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("servers", servers)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        VServer group ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        VServer group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetServerGroupsSlbServerGroupServerResult']:
        """
        ECS instances associated to the group. Each element contains the following attributes:
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetServerGroupsSlbServerGroupServerResult(dict):
    def __init__(__self__, *,
                 instance_id: str,
                 weight: int):
        """
        :param str instance_id: ID of the attached ECS instance.
        :param int weight: Weight associated to the ECS instance.
        """
        GetServerGroupsSlbServerGroupServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_id=instance_id,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_id: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if weight is None:
            raise TypeError("Missing 'weight' argument")

        _setter("instance_id", instance_id)
        _setter("weight", weight)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of the attached ECS instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight associated to the ECS instance.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetTlsCipherPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 ciphers: Sequence[str],
                 create_time: str,
                 id: str,
                 relate_listeners: Sequence['outputs.GetTlsCipherPoliciesPolicyRelateListenerResult'],
                 status: str,
                 tls_cipher_policy_id: str,
                 tls_cipher_policy_name: str,
                 tls_versions: Sequence[str]):
        """
        :param Sequence[str] ciphers: The encryption algorithms supported. It depends on the value of `tls_versions`.
        :param str create_time: The creation time timestamp.
        :param str id: The ID of the Tls Cipher Policy.
        :param Sequence['GetTlsCipherPoliciesPolicyRelateListenerArgs'] relate_listeners: Array of Relate Listeners.
        :param str status: TLS policy instance state.
        :param str tls_cipher_policy_id: The ID of TLS cipher policy.
        :param str tls_cipher_policy_name: TLS policy name. Length is from 2 to 128, or in both the English and Chinese characters must be with an uppercase/lowercase letter or a Chinese character and the beginning, may contain numbers, in dot `.`, underscore `_` or dash `-`.
        :param Sequence[str] tls_versions: The version of TLS protocol.
        """
        GetTlsCipherPoliciesPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ciphers=ciphers,
            create_time=create_time,
            id=id,
            relate_listeners=relate_listeners,
            status=status,
            tls_cipher_policy_id=tls_cipher_policy_id,
            tls_cipher_policy_name=tls_cipher_policy_name,
            tls_versions=tls_versions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ciphers: Optional[Sequence[str]] = None,
             create_time: Optional[str] = None,
             id: Optional[str] = None,
             relate_listeners: Optional[Sequence['outputs.GetTlsCipherPoliciesPolicyRelateListenerResult']] = None,
             status: Optional[str] = None,
             tls_cipher_policy_id: Optional[str] = None,
             tls_cipher_policy_name: Optional[str] = None,
             tls_versions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ciphers is None:
            raise TypeError("Missing 'ciphers' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if relate_listeners is None and 'relateListeners' in kwargs:
            relate_listeners = kwargs['relateListeners']
        if relate_listeners is None:
            raise TypeError("Missing 'relate_listeners' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tls_cipher_policy_id is None and 'tlsCipherPolicyId' in kwargs:
            tls_cipher_policy_id = kwargs['tlsCipherPolicyId']
        if tls_cipher_policy_id is None:
            raise TypeError("Missing 'tls_cipher_policy_id' argument")
        if tls_cipher_policy_name is None and 'tlsCipherPolicyName' in kwargs:
            tls_cipher_policy_name = kwargs['tlsCipherPolicyName']
        if tls_cipher_policy_name is None:
            raise TypeError("Missing 'tls_cipher_policy_name' argument")
        if tls_versions is None and 'tlsVersions' in kwargs:
            tls_versions = kwargs['tlsVersions']
        if tls_versions is None:
            raise TypeError("Missing 'tls_versions' argument")

        _setter("ciphers", ciphers)
        _setter("create_time", create_time)
        _setter("id", id)
        _setter("relate_listeners", relate_listeners)
        _setter("status", status)
        _setter("tls_cipher_policy_id", tls_cipher_policy_id)
        _setter("tls_cipher_policy_name", tls_cipher_policy_name)
        _setter("tls_versions", tls_versions)

    @property
    @pulumi.getter
    def ciphers(self) -> Sequence[str]:
        """
        The encryption algorithms supported. It depends on the value of `tls_versions`.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creation time timestamp.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Tls Cipher Policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="relateListeners")
    def relate_listeners(self) -> Sequence['outputs.GetTlsCipherPoliciesPolicyRelateListenerResult']:
        """
        Array of Relate Listeners.
        """
        return pulumi.get(self, "relate_listeners")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        TLS policy instance state.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tlsCipherPolicyId")
    def tls_cipher_policy_id(self) -> str:
        """
        The ID of TLS cipher policy.
        """
        return pulumi.get(self, "tls_cipher_policy_id")

    @property
    @pulumi.getter(name="tlsCipherPolicyName")
    def tls_cipher_policy_name(self) -> str:
        """
        TLS policy name. Length is from 2 to 128, or in both the English and Chinese characters must be with an uppercase/lowercase letter or a Chinese character and the beginning, may contain numbers, in dot `.`, underscore `_` or dash `-`.
        """
        return pulumi.get(self, "tls_cipher_policy_name")

    @property
    @pulumi.getter(name="tlsVersions")
    def tls_versions(self) -> Sequence[str]:
        """
        The version of TLS protocol.
        """
        return pulumi.get(self, "tls_versions")


@pulumi.output_type
class GetTlsCipherPoliciesPolicyRelateListenerResult(dict):
    def __init__(__self__, *,
                 load_balancer_id: str,
                 port: int,
                 protocol: str):
        """
        :param str load_balancer_id: The ID of SLB instance.
        :param int port: Listening port. Valid value: 1 to 65535.
        :param str protocol: Snooping protocols. Valid values: `TCP`, `UDP`, `HTTP`, or `HTTPS`.
        """
        GetTlsCipherPoliciesPolicyRelateListenerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            load_balancer_id=load_balancer_id,
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             load_balancer_id: Optional[str] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if load_balancer_id is None and 'loadBalancerId' in kwargs:
            load_balancer_id = kwargs['loadBalancerId']
        if load_balancer_id is None:
            raise TypeError("Missing 'load_balancer_id' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("load_balancer_id", load_balancer_id)
        _setter("port", port)
        _setter("protocol", protocol)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> str:
        """
        The ID of SLB instance.
        """
        return pulumi.get(self, "load_balancer_id")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Listening port. Valid value: 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Snooping protocols. Valid values: `TCP`, `UDP`, `HTTP`, or `HTTPS`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: str,
                 master_zone_id: str,
                 slave_zone_id: str,
                 slb_slave_zone_ids: Sequence[str],
                 supported_resources: Sequence['outputs.GetZonesZoneSupportedResourceResult']):
        """
        :param str id: ID of the zone. It is same as `master_zone_id`.
        :param str master_zone_id: The primary zone.
        :param str slave_zone_id: The secondary zone.
        :param Sequence[str] slb_slave_zone_ids: (Deprecated from 1.157.0) A list of slb slave zone ids in which the slb master zone. 
               It has been deprecated from v1.157.0 and use `slave_zone_id` instead.
        :param Sequence['GetZonesZoneSupportedResourceArgs'] supported_resources: (Available in 1.154.0+)A list of available resource which the slb master zone supported.
        """
        GetZonesZoneResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            master_zone_id=master_zone_id,
            slave_zone_id=slave_zone_id,
            slb_slave_zone_ids=slb_slave_zone_ids,
            supported_resources=supported_resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             master_zone_id: Optional[str] = None,
             slave_zone_id: Optional[str] = None,
             slb_slave_zone_ids: Optional[Sequence[str]] = None,
             supported_resources: Optional[Sequence['outputs.GetZonesZoneSupportedResourceResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if master_zone_id is None and 'masterZoneId' in kwargs:
            master_zone_id = kwargs['masterZoneId']
        if master_zone_id is None:
            raise TypeError("Missing 'master_zone_id' argument")
        if slave_zone_id is None and 'slaveZoneId' in kwargs:
            slave_zone_id = kwargs['slaveZoneId']
        if slave_zone_id is None:
            raise TypeError("Missing 'slave_zone_id' argument")
        if slb_slave_zone_ids is None and 'slbSlaveZoneIds' in kwargs:
            slb_slave_zone_ids = kwargs['slbSlaveZoneIds']
        if slb_slave_zone_ids is None:
            raise TypeError("Missing 'slb_slave_zone_ids' argument")
        if supported_resources is None and 'supportedResources' in kwargs:
            supported_resources = kwargs['supportedResources']
        if supported_resources is None:
            raise TypeError("Missing 'supported_resources' argument")

        _setter("id", id)
        _setter("master_zone_id", master_zone_id)
        _setter("slave_zone_id", slave_zone_id)
        _setter("slb_slave_zone_ids", slb_slave_zone_ids)
        _setter("supported_resources", supported_resources)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the zone. It is same as `master_zone_id`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterZoneId")
    def master_zone_id(self) -> str:
        """
        The primary zone.
        """
        return pulumi.get(self, "master_zone_id")

    @property
    @pulumi.getter(name="slaveZoneId")
    def slave_zone_id(self) -> str:
        """
        The secondary zone.
        """
        return pulumi.get(self, "slave_zone_id")

    @property
    @pulumi.getter(name="slbSlaveZoneIds")
    def slb_slave_zone_ids(self) -> Sequence[str]:
        """
        (Deprecated from 1.157.0) A list of slb slave zone ids in which the slb master zone. 
        It has been deprecated from v1.157.0 and use `slave_zone_id` instead.
        """
        warnings.warn("""the attribute slb_slave_zone_ids has been deprecated from version 1.157.0 and use slave_zone_id instead.""", DeprecationWarning)
        pulumi.log.warn("""slb_slave_zone_ids is deprecated: the attribute slb_slave_zone_ids has been deprecated from version 1.157.0 and use slave_zone_id instead.""")

        return pulumi.get(self, "slb_slave_zone_ids")

    @property
    @pulumi.getter(name="supportedResources")
    def supported_resources(self) -> Sequence['outputs.GetZonesZoneSupportedResourceResult']:
        """
        (Available in 1.154.0+)A list of available resource which the slb master zone supported.
        """
        return pulumi.get(self, "supported_resources")


@pulumi.output_type
class GetZonesZoneSupportedResourceResult(dict):
    def __init__(__self__, *,
                 address_ip_version: str,
                 address_type: str):
        """
        :param str address_ip_version: The type of IP address.
        :param str address_type: The type of network.
        """
        GetZonesZoneSupportedResourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_ip_version=address_ip_version,
            address_type=address_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_ip_version: Optional[str] = None,
             address_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if address_ip_version is None and 'addressIpVersion' in kwargs:
            address_ip_version = kwargs['addressIpVersion']
        if address_ip_version is None:
            raise TypeError("Missing 'address_ip_version' argument")
        if address_type is None and 'addressType' in kwargs:
            address_type = kwargs['addressType']
        if address_type is None:
            raise TypeError("Missing 'address_type' argument")

        _setter("address_ip_version", address_ip_version)
        _setter("address_type", address_type)

    @property
    @pulumi.getter(name="addressIpVersion")
    def address_ip_version(self) -> str:
        """
        The type of IP address.
        """
        return pulumi.get(self, "address_ip_version")

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> str:
        """
        The type of network.
        """
        return pulumi.get(self, "address_type")


