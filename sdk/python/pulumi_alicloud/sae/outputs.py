# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationConfigMapMountDescV2',
    'ApplicationCustomHostAliasV2',
    'ApplicationKafkaConfigs',
    'ApplicationKafkaConfigsKafkaConfig',
    'ApplicationLivenessV2',
    'ApplicationLivenessV2Exec',
    'ApplicationLivenessV2HttpGet',
    'ApplicationLivenessV2TcpSocket',
    'ApplicationNasConfig',
    'ApplicationOssMountDescsV2',
    'ApplicationPostStartV2',
    'ApplicationPostStartV2Exec',
    'ApplicationPreStopV2',
    'ApplicationPreStopV2Exec',
    'ApplicationPvtzDiscoverySvc',
    'ApplicationPvtzDiscoverySvcPortProtocol',
    'ApplicationReadinessV2',
    'ApplicationReadinessV2Exec',
    'ApplicationReadinessV2HttpGet',
    'ApplicationReadinessV2TcpSocket',
    'ApplicationScalingRuleScalingRuleMetric',
    'ApplicationScalingRuleScalingRuleMetricMetric',
    'ApplicationScalingRuleScalingRuleMetricScaleDownRules',
    'ApplicationScalingRuleScalingRuleMetricScaleUpRules',
    'ApplicationScalingRuleScalingRuleTimer',
    'ApplicationScalingRuleScalingRuleTimerSchedule',
    'ApplicationTomcatConfigV2',
    'ApplicationUpdateStrategyV2',
    'ApplicationUpdateStrategyV2BatchUpdate',
    'GreyTagRouteDubboRule',
    'GreyTagRouteDubboRuleItem',
    'GreyTagRouteScRule',
    'GreyTagRouteScRuleItem',
    'IngressDefaultRule',
    'IngressRule',
    'LoadBalancerInternetInternet',
    'LoadBalancerIntranetIntranet',
    'GetApplicationScalingRulesRuleResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult',
    'GetApplicationScalingRulesRuleScalingRuleTimerResult',
    'GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult',
    'GetApplicationsApplicationResult',
    'GetApplicationsApplicationMountDescResult',
    'GetApplicationsApplicationOssMountDetailResult',
    'GetConfigMapsMapResult',
    'GetGreyTagRoutesRouteResult',
    'GetGreyTagRoutesRouteDubboRuleResult',
    'GetGreyTagRoutesRouteDubboRuleItemResult',
    'GetGreyTagRoutesRouteScRuleResult',
    'GetGreyTagRoutesRouteScRuleItemResult',
    'GetIngressesIngressResult',
    'GetInstanceSpecificationsSpecificationResult',
    'GetNamespacesNamespaceResult',
]

@pulumi.output_type
class ApplicationConfigMapMountDescV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapId":
            suggest = "config_map_id"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationConfigMapMountDescV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationConfigMapMountDescV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationConfigMapMountDescV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_id: Optional[str] = None,
                 key: Optional[str] = None,
                 mount_path: Optional[str] = None):
        """
        :param str config_map_id: The ID of the ConfigMap.
        :param str key: The key.
        :param str mount_path: The mount path.
        """
        ApplicationConfigMapMountDescV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_map_id=config_map_id,
            key=key,
            mount_path=mount_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_map_id: Optional[str] = None,
             key: Optional[str] = None,
             mount_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configMapId' in kwargs:
            config_map_id = kwargs['configMapId']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']

        if config_map_id is not None:
            _setter("config_map_id", config_map_id)
        if key is not None:
            _setter("key", key)
        if mount_path is not None:
            _setter("mount_path", mount_path)

    @property
    @pulumi.getter(name="configMapId")
    def config_map_id(self) -> Optional[str]:
        """
        The ID of the ConfigMap.
        """
        return pulumi.get(self, "config_map_id")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The mount path.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class ApplicationCustomHostAliasV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationCustomHostAliasV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationCustomHostAliasV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationCustomHostAliasV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: Optional[str] = None,
                 ip: Optional[str] = None):
        """
        :param str host_name: The domain name or hostname.
        :param str ip: The IP address.
        """
        ApplicationCustomHostAliasV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_name=host_name,
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_name: Optional[str] = None,
             ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostName' in kwargs:
            host_name = kwargs['hostName']

        if host_name is not None:
            _setter("host_name", host_name)
        if ip is not None:
            _setter("ip", ip)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        The domain name or hostname.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        The IP address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ApplicationKafkaConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConfigs":
            suggest = "kafka_configs"
        elif key == "kafkaEndpoint":
            suggest = "kafka_endpoint"
        elif key == "kafkaInstanceId":
            suggest = "kafka_instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationKafkaConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationKafkaConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationKafkaConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_configs: Optional[Sequence['outputs.ApplicationKafkaConfigsKafkaConfig']] = None,
                 kafka_endpoint: Optional[str] = None,
                 kafka_instance_id: Optional[str] = None):
        """
        :param Sequence['ApplicationKafkaConfigsKafkaConfigArgs'] kafka_configs: One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        :param str kafka_endpoint: The endpoint of the ApsaraMQ for Kafka API.
        :param str kafka_instance_id: The  ID of the ApsaraMQ for Kafka instance.
        """
        ApplicationKafkaConfigs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kafka_configs=kafka_configs,
            kafka_endpoint=kafka_endpoint,
            kafka_instance_id=kafka_instance_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kafka_configs: Optional[Sequence['outputs.ApplicationKafkaConfigsKafkaConfig']] = None,
             kafka_endpoint: Optional[str] = None,
             kafka_instance_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'kafkaConfigs' in kwargs:
            kafka_configs = kwargs['kafkaConfigs']
        if 'kafkaEndpoint' in kwargs:
            kafka_endpoint = kwargs['kafkaEndpoint']
        if 'kafkaInstanceId' in kwargs:
            kafka_instance_id = kwargs['kafkaInstanceId']

        if kafka_configs is not None:
            _setter("kafka_configs", kafka_configs)
        if kafka_endpoint is not None:
            _setter("kafka_endpoint", kafka_endpoint)
        if kafka_instance_id is not None:
            _setter("kafka_instance_id", kafka_instance_id)

    @property
    @pulumi.getter(name="kafkaConfigs")
    def kafka_configs(self) -> Optional[Sequence['outputs.ApplicationKafkaConfigsKafkaConfig']]:
        """
        One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        """
        return pulumi.get(self, "kafka_configs")

    @property
    @pulumi.getter(name="kafkaEndpoint")
    def kafka_endpoint(self) -> Optional[str]:
        """
        The endpoint of the ApsaraMQ for Kafka API.
        """
        return pulumi.get(self, "kafka_endpoint")

    @property
    @pulumi.getter(name="kafkaInstanceId")
    def kafka_instance_id(self) -> Optional[str]:
        """
        The  ID of the ApsaraMQ for Kafka instance.
        """
        return pulumi.get(self, "kafka_instance_id")


@pulumi.output_type
class ApplicationKafkaConfigsKafkaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaTopic":
            suggest = "kafka_topic"
        elif key == "logDir":
            suggest = "log_dir"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationKafkaConfigsKafkaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationKafkaConfigsKafkaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationKafkaConfigsKafkaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_topic: Optional[str] = None,
                 log_dir: Optional[str] = None,
                 log_type: Optional[str] = None):
        """
        :param str kafka_topic: The topic of the Kafka.
        :param str log_dir: The path in which logs are stored.
        :param str log_type: The type of the log.
        """
        ApplicationKafkaConfigsKafkaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kafka_topic=kafka_topic,
            log_dir=log_dir,
            log_type=log_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kafka_topic: Optional[str] = None,
             log_dir: Optional[str] = None,
             log_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'kafkaTopic' in kwargs:
            kafka_topic = kwargs['kafkaTopic']
        if 'logDir' in kwargs:
            log_dir = kwargs['logDir']
        if 'logType' in kwargs:
            log_type = kwargs['logType']

        if kafka_topic is not None:
            _setter("kafka_topic", kafka_topic)
        if log_dir is not None:
            _setter("log_dir", log_dir)
        if log_type is not None:
            _setter("log_type", log_type)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[str]:
        """
        The topic of the Kafka.
        """
        return pulumi.get(self, "kafka_topic")

    @property
    @pulumi.getter(name="logDir")
    def log_dir(self) -> Optional[str]:
        """
        The path in which logs are stored.
        """
        return pulumi.get(self, "log_dir")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[str]:
        """
        The type of the log.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class ApplicationLivenessV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLivenessV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLivenessV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLivenessV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationLivenessV2Exec'] = None,
                 http_get: Optional['outputs.ApplicationLivenessV2HttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 tcp_socket: Optional['outputs.ApplicationLivenessV2TcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'ApplicationLivenessV2ExecArgs' exec_: Execute. See `exec` below.
        :param 'ApplicationLivenessV2HttpGetArgs' http_get: The liveness check settings of the container. See `http_get` below.
        :param int initial_delay_seconds: The delay of the health check.
        :param int period_seconds: The interval at which the health check is performed.
        :param 'ApplicationLivenessV2TcpSocketArgs' tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param int timeout_seconds: The timeout period of the health check.
        """
        ApplicationLivenessV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.ApplicationLivenessV2Exec'] = None,
             http_get: Optional['outputs.ApplicationLivenessV2HttpGet'] = None,
             initial_delay_seconds: Optional[int] = None,
             period_seconds: Optional[int] = None,
             tcp_socket: Optional['outputs.ApplicationLivenessV2TcpSocket'] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationLivenessV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.ApplicationLivenessV2HttpGet']:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.ApplicationLivenessV2TcpSocket']:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class ApplicationLivenessV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationLivenessV2Exec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationLivenessV2HttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContainKeyWord":
            suggest = "is_contain_key_word"
        elif key == "keyWord":
            suggest = "key_word"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLivenessV2HttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLivenessV2HttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLivenessV2HttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_contain_key_word: Optional[bool] = None,
                 key_word: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        """
        :param bool is_contain_key_word: Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        :param str key_word: The custom keywords.
        :param str path: The request path.
        :param int port: The port.
        :param str scheme: The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        ApplicationLivenessV2HttpGet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_contain_key_word=is_contain_key_word,
            key_word=key_word,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_contain_key_word: Optional[bool] = None,
             key_word: Optional[str] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isContainKeyWord' in kwargs:
            is_contain_key_word = kwargs['isContainKeyWord']
        if 'keyWord' in kwargs:
            key_word = kwargs['keyWord']

        if is_contain_key_word is not None:
            _setter("is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            _setter("key_word", key_word)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[bool]:
        """
        Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        """
        return pulumi.get(self, "is_contain_key_word")

    @property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[str]:
        """
        The custom keywords.
        """
        return pulumi.get(self, "key_word")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The request path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ApplicationLivenessV2TcpSocket(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        """
        :param int port: The port.
        """
        ApplicationLivenessV2TcpSocket._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplicationNasConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountDomain":
            suggest = "mount_domain"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "nasId":
            suggest = "nas_id"
        elif key == "nasPath":
            suggest = "nas_path"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationNasConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationNasConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationNasConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_domain: Optional[str] = None,
                 mount_path: Optional[str] = None,
                 nas_id: Optional[str] = None,
                 nas_path: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str mount_domain: The domain name of the mount target.
        :param str mount_path: The mount path of the container.
        :param str nas_id: The ID of the NAS file system.
        :param str nas_path: The directory in the NAS file system.
        :param bool read_only: Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        ApplicationNasConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_domain=mount_domain,
            mount_path=mount_path,
            nas_id=nas_id,
            nas_path=nas_path,
            read_only=read_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_domain: Optional[str] = None,
             mount_path: Optional[str] = None,
             nas_id: Optional[str] = None,
             nas_path: Optional[str] = None,
             read_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mountDomain' in kwargs:
            mount_domain = kwargs['mountDomain']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'nasId' in kwargs:
            nas_id = kwargs['nasId']
        if 'nasPath' in kwargs:
            nas_path = kwargs['nasPath']
        if 'readOnly' in kwargs:
            read_only = kwargs['readOnly']

        if mount_domain is not None:
            _setter("mount_domain", mount_domain)
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if nas_id is not None:
            _setter("nas_id", nas_id)
        if nas_path is not None:
            _setter("nas_path", nas_path)
        if read_only is not None:
            _setter("read_only", read_only)

    @property
    @pulumi.getter(name="mountDomain")
    def mount_domain(self) -> Optional[str]:
        """
        The domain name of the mount target.
        """
        return pulumi.get(self, "mount_domain")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The mount path of the container.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="nasId")
    def nas_id(self) -> Optional[str]:
        """
        The ID of the NAS file system.
        """
        return pulumi.get(self, "nas_id")

    @property
    @pulumi.getter(name="nasPath")
    def nas_path(self) -> Optional[str]:
        """
        The directory in the NAS file system.
        """
        return pulumi.get(self, "nas_path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class ApplicationOssMountDescsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPath":
            suggest = "bucket_path"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationOssMountDescsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationOssMountDescsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationOssMountDescsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_path: Optional[str] = None,
                 mount_path: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str bucket_name: The name of the OSS bucket.
        :param str bucket_path: The directory or object in OSS.
        :param str mount_path: The mount path.
        :param bool read_only: Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        ApplicationOssMountDescsV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_path=bucket_path,
            mount_path=mount_path,
            read_only=read_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[str] = None,
             bucket_path: Optional[str] = None,
             mount_path: Optional[str] = None,
             read_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if 'bucketPath' in kwargs:
            bucket_path = kwargs['bucketPath']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'readOnly' in kwargs:
            read_only = kwargs['readOnly']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_path is not None:
            _setter("bucket_path", bucket_path)
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if read_only is not None:
            _setter("read_only", read_only)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the OSS bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[str]:
        """
        The directory or object in OSS.
        """
        return pulumi.get(self, "bucket_path")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        The mount path.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class ApplicationPostStartV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPostStartV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPostStartV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPostStartV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationPostStartV2Exec'] = None):
        """
        :param 'ApplicationPostStartV2ExecArgs' exec_: Execute. See `exec` below.
        """
        ApplicationPostStartV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.ApplicationPostStartV2Exec'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        if exec_ is not None:
            _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationPostStartV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")


@pulumi.output_type
class ApplicationPostStartV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationPostStartV2Exec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationPreStopV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPreStopV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPreStopV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPreStopV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationPreStopV2Exec'] = None):
        """
        :param 'ApplicationPreStopV2ExecArgs' exec_: Execute. See `exec` below.
        """
        ApplicationPreStopV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.ApplicationPreStopV2Exec'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        if exec_ is not None:
            _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationPreStopV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")


@pulumi.output_type
class ApplicationPreStopV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationPreStopV2Exec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationPvtzDiscoverySvc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "portProtocols":
            suggest = "port_protocols"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPvtzDiscoverySvc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPvtzDiscoverySvc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPvtzDiscoverySvc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 namespace_id: Optional[str] = None,
                 port_protocols: Optional[Sequence['outputs.ApplicationPvtzDiscoverySvcPortProtocol']] = None,
                 service_name: Optional[str] = None):
        """
        :param bool enable: Enables the Kubernetes Service-based registration and discovery feature.
        :param str namespace_id: The ID of the namespace.
        :param Sequence['ApplicationPvtzDiscoverySvcPortProtocolArgs'] port_protocols: The port number and protocol. See `port_protocols` below.
        :param str service_name: The name of the Service.
        """
        ApplicationPvtzDiscoverySvc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            namespace_id=namespace_id,
            port_protocols=port_protocols,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: Optional[bool] = None,
             namespace_id: Optional[str] = None,
             port_protocols: Optional[Sequence['outputs.ApplicationPvtzDiscoverySvcPortProtocol']] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'portProtocols' in kwargs:
            port_protocols = kwargs['portProtocols']
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        if enable is not None:
            _setter("enable", enable)
        if namespace_id is not None:
            _setter("namespace_id", namespace_id)
        if port_protocols is not None:
            _setter("port_protocols", port_protocols)
        if service_name is not None:
            _setter("service_name", service_name)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Enables the Kubernetes Service-based registration and discovery feature.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        The ID of the namespace.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="portProtocols")
    def port_protocols(self) -> Optional[Sequence['outputs.ApplicationPvtzDiscoverySvcPortProtocol']]:
        """
        The port number and protocol. See `port_protocols` below.
        """
        return pulumi.get(self, "port_protocols")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the Service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class ApplicationPvtzDiscoverySvcPortProtocol(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None):
        """
        :param int port: The port.
        :param str protocol: The protocol. Valid values: `TCP` and `UDP`.
        """
        ApplicationPvtzDiscoverySvcPortProtocol._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol. Valid values: `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ApplicationReadinessV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationReadinessV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationReadinessV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationReadinessV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationReadinessV2Exec'] = None,
                 http_get: Optional['outputs.ApplicationReadinessV2HttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 tcp_socket: Optional['outputs.ApplicationReadinessV2TcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'ApplicationReadinessV2ExecArgs' exec_: Execute. See `exec` below.
        :param 'ApplicationReadinessV2HttpGetArgs' http_get: The liveness check settings of the container. See `http_get` below.
        :param int initial_delay_seconds: The delay of the health check.
        :param int period_seconds: The interval at which the health check is performed.
        :param 'ApplicationReadinessV2TcpSocketArgs' tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param int timeout_seconds: The timeout period of the health check.
        """
        ApplicationReadinessV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.ApplicationReadinessV2Exec'] = None,
             http_get: Optional['outputs.ApplicationReadinessV2HttpGet'] = None,
             initial_delay_seconds: Optional[int] = None,
             period_seconds: Optional[int] = None,
             tcp_socket: Optional['outputs.ApplicationReadinessV2TcpSocket'] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationReadinessV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.ApplicationReadinessV2HttpGet']:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.ApplicationReadinessV2TcpSocket']:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class ApplicationReadinessV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationReadinessV2Exec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationReadinessV2HttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContainKeyWord":
            suggest = "is_contain_key_word"
        elif key == "keyWord":
            suggest = "key_word"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationReadinessV2HttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationReadinessV2HttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationReadinessV2HttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_contain_key_word: Optional[bool] = None,
                 key_word: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        """
        :param bool is_contain_key_word: Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        :param str key_word: The custom keywords.
        :param str path: The request path.
        :param int port: The port.
        :param str scheme: The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        ApplicationReadinessV2HttpGet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_contain_key_word=is_contain_key_word,
            key_word=key_word,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_contain_key_word: Optional[bool] = None,
             key_word: Optional[str] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isContainKeyWord' in kwargs:
            is_contain_key_word = kwargs['isContainKeyWord']
        if 'keyWord' in kwargs:
            key_word = kwargs['keyWord']

        if is_contain_key_word is not None:
            _setter("is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            _setter("key_word", key_word)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[bool]:
        """
        Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        """
        return pulumi.get(self, "is_contain_key_word")

    @property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[str]:
        """
        The custom keywords.
        """
        return pulumi.get(self, "key_word")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The request path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ApplicationReadinessV2TcpSocket(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        """
        :param int port: The port.
        """
        ApplicationReadinessV2TcpSocket._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "scaleDownRules":
            suggest = "scale_down_rules"
        elif key == "scaleUpRules":
            suggest = "scale_up_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: Optional[int] = None,
                 metrics: Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleMetricMetric']] = None,
                 min_replicas: Optional[int] = None,
                 scale_down_rules: Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleDownRules'] = None,
                 scale_up_rules: Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleUpRules'] = None):
        """
        :param int max_replicas: Maximum number of instances applied.
        :param Sequence['ApplicationScalingRuleScalingRuleMetricMetricArgs'] metrics: Indicator rule configuration. See `metrics` below.
        :param int min_replicas: Minimum number of instances applied.
        :param 'ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs' scale_down_rules: Apply shrink rules. See `scale_down_rules` below.
        :param 'ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs' scale_up_rules: Apply expansion rules. See `scale_up_rules` below.
        """
        ApplicationScalingRuleScalingRuleMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_replicas=max_replicas,
            metrics=metrics,
            min_replicas=min_replicas,
            scale_down_rules=scale_down_rules,
            scale_up_rules=scale_up_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_replicas: Optional[int] = None,
             metrics: Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleMetricMetric']] = None,
             min_replicas: Optional[int] = None,
             scale_down_rules: Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleDownRules'] = None,
             scale_up_rules: Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleUpRules'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'scaleDownRules' in kwargs:
            scale_down_rules = kwargs['scaleDownRules']
        if 'scaleUpRules' in kwargs:
            scale_up_rules = kwargs['scaleUpRules']

        if max_replicas is not None:
            _setter("max_replicas", max_replicas)
        if metrics is not None:
            _setter("metrics", metrics)
        if min_replicas is not None:
            _setter("min_replicas", min_replicas)
        if scale_down_rules is not None:
            _setter("scale_down_rules", scale_down_rules)
        if scale_up_rules is not None:
            _setter("scale_up_rules", scale_up_rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[int]:
        """
        Maximum number of instances applied.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleMetricMetric']]:
        """
        Indicator rule configuration. See `metrics` below.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[int]:
        """
        Minimum number of instances applied.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="scaleDownRules")
    def scale_down_rules(self) -> Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleDownRules']:
        """
        Apply shrink rules. See `scale_down_rules` below.
        """
        return pulumi.get(self, "scale_down_rules")

    @property
    @pulumi.getter(name="scaleUpRules")
    def scale_up_rules(self) -> Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleUpRules']:
        """
        Apply expansion rules. See `scale_up_rules` below.
        """
        return pulumi.get(self, "scale_up_rules")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetricMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricTargetAverageUtilization":
            suggest = "metric_target_average_utilization"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "slbId":
            suggest = "slb_id"
        elif key == "slbLogStore":
            suggest = "slb_log_store"
        elif key == "slbProject":
            suggest = "slb_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetricMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetricMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetricMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_target_average_utilization: Optional[int] = None,
                 metric_type: Optional[str] = None,
                 slb_id: Optional[str] = None,
                 slb_log_store: Optional[str] = None,
                 slb_project: Optional[str] = None,
                 vport: Optional[str] = None):
        """
        :param int metric_target_average_utilization: According to different `metric_type`, set the target value of the corresponding monitoring index.
        :param str metric_type: Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
               - CPU: CPU usage.
               - MEMORY: MEMORY usage.
               - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
               - QPS: The average QPS of a single instance within 1 minute of JAVA application.
               - RT: The average response time of all service interfaces within 1 minute of JAVA application.
               - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
               - SLB_RT: The average response time of public network SLB within 15 seconds.
               - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
               - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
               **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        :param str slb_id: SLB ID.
        :param str slb_log_store: The log store of the Log Service.
        :param str slb_project: The project of the Log Service.
        :param str vport: SLB listening port.
        """
        ApplicationScalingRuleScalingRuleMetricMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_target_average_utilization=metric_target_average_utilization,
            metric_type=metric_type,
            slb_id=slb_id,
            slb_log_store=slb_log_store,
            slb_project=slb_project,
            vport=vport,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_target_average_utilization: Optional[int] = None,
             metric_type: Optional[str] = None,
             slb_id: Optional[str] = None,
             slb_log_store: Optional[str] = None,
             slb_project: Optional[str] = None,
             vport: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'metricTargetAverageUtilization' in kwargs:
            metric_target_average_utilization = kwargs['metricTargetAverageUtilization']
        if 'metricType' in kwargs:
            metric_type = kwargs['metricType']
        if 'slbId' in kwargs:
            slb_id = kwargs['slbId']
        if 'slbLogStore' in kwargs:
            slb_log_store = kwargs['slbLogStore']
        if 'slbProject' in kwargs:
            slb_project = kwargs['slbProject']

        if metric_target_average_utilization is not None:
            _setter("metric_target_average_utilization", metric_target_average_utilization)
        if metric_type is not None:
            _setter("metric_type", metric_type)
        if slb_id is not None:
            _setter("slb_id", slb_id)
        if slb_log_store is not None:
            _setter("slb_log_store", slb_log_store)
        if slb_project is not None:
            _setter("slb_project", slb_project)
        if vport is not None:
            _setter("vport", vport)

    @property
    @pulumi.getter(name="metricTargetAverageUtilization")
    def metric_target_average_utilization(self) -> Optional[int]:
        """
        According to different `metric_type`, set the target value of the corresponding monitoring index.
        """
        return pulumi.get(self, "metric_target_average_utilization")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[str]:
        """
        Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
        - CPU: CPU usage.
        - MEMORY: MEMORY usage.
        - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
        - QPS: The average QPS of a single instance within 1 minute of JAVA application.
        - RT: The average response time of all service interfaces within 1 minute of JAVA application.
        - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
        - SLB_RT: The average response time of public network SLB within 15 seconds.
        - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
        - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
        **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter(name="slbId")
    def slb_id(self) -> Optional[str]:
        """
        SLB ID.
        """
        return pulumi.get(self, "slb_id")

    @property
    @pulumi.getter(name="slbLogStore")
    def slb_log_store(self) -> Optional[str]:
        """
        The log store of the Log Service.
        """
        return pulumi.get(self, "slb_log_store")

    @property
    @pulumi.getter(name="slbProject")
    def slb_project(self) -> Optional[str]:
        """
        The project of the Log Service.
        """
        return pulumi.get(self, "slb_project")

    @property
    @pulumi.getter
    def vport(self) -> Optional[str]:
        """
        SLB listening port.
        """
        return pulumi.get(self, "vport")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetricScaleDownRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stabilizationWindowSeconds":
            suggest = "stabilization_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetricScaleDownRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleDownRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleDownRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[bool] = None,
                 stabilization_window_seconds: Optional[int] = None,
                 step: Optional[int] = None):
        """
        :param bool disabled: Whether shrinkage is prohibited.
        :param int stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param int step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        ApplicationScalingRuleScalingRuleMetricScaleDownRules._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled=disabled,
            stabilization_window_seconds=stabilization_window_seconds,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled: Optional[bool] = None,
             stabilization_window_seconds: Optional[int] = None,
             step: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stabilizationWindowSeconds' in kwargs:
            stabilization_window_seconds = kwargs['stabilizationWindowSeconds']

        if disabled is not None:
            _setter("disabled", disabled)
        if stabilization_window_seconds is not None:
            _setter("stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            _setter("step", step)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[int]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @property
    @pulumi.getter
    def step(self) -> Optional[int]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetricScaleUpRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stabilizationWindowSeconds":
            suggest = "stabilization_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetricScaleUpRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleUpRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleUpRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[bool] = None,
                 stabilization_window_seconds: Optional[int] = None,
                 step: Optional[int] = None):
        """
        :param bool disabled: Whether shrinkage is prohibited.
        :param int stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param int step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        ApplicationScalingRuleScalingRuleMetricScaleUpRules._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled=disabled,
            stabilization_window_seconds=stabilization_window_seconds,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled: Optional[bool] = None,
             stabilization_window_seconds: Optional[int] = None,
             step: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stabilizationWindowSeconds' in kwargs:
            stabilization_window_seconds = kwargs['stabilizationWindowSeconds']

        if disabled is not None:
            _setter("disabled", disabled)
        if stabilization_window_seconds is not None:
            _setter("stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            _setter("step", step)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[int]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @property
    @pulumi.getter
    def step(self) -> Optional[int]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginDate":
            suggest = "begin_date"
        elif key == "endDate":
            suggest = "end_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_date: Optional[str] = None,
                 end_date: Optional[str] = None,
                 period: Optional[str] = None,
                 schedules: Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleTimerSchedule']] = None):
        """
        :param str begin_date: The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param str end_date: The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param str period: The period in which a timed elastic scaling strategy is executed.
        :param Sequence['ApplicationScalingRuleScalingRuleTimerScheduleArgs'] schedules: Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        ApplicationScalingRuleScalingRuleTimer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            begin_date=begin_date,
            end_date=end_date,
            period=period,
            schedules=schedules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             begin_date: Optional[str] = None,
             end_date: Optional[str] = None,
             period: Optional[str] = None,
             schedules: Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleTimerSchedule']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'beginDate' in kwargs:
            begin_date = kwargs['beginDate']
        if 'endDate' in kwargs:
            end_date = kwargs['endDate']

        if begin_date is not None:
            _setter("begin_date", begin_date)
        if end_date is not None:
            _setter("end_date", end_date)
        if period is not None:
            _setter("period", period)
        if schedules is not None:
            _setter("schedules", schedules)

    @property
    @pulumi.getter(name="beginDate")
    def begin_date(self) -> Optional[str]:
        """
        The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "begin_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def period(self) -> Optional[str]:
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def schedules(self) -> Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleTimerSchedule']]:
        """
        Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        return pulumi.get(self, "schedules")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleTimerSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atTime":
            suggest = "at_time"
        elif key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "targetReplicas":
            suggest = "target_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleTimerSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleTimerSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleTimerSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 at_time: Optional[str] = None,
                 max_replicas: Optional[int] = None,
                 min_replicas: Optional[int] = None,
                 target_replicas: Optional[int] = None):
        """
        :param str at_time: Trigger point in time. When supporting format: minutes, for example: `08:00`.
        :param int max_replicas: Maximum number of instances applied.
        :param int min_replicas: Minimum number of instances applied.
        :param int target_replicas: This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        ApplicationScalingRuleScalingRuleTimerSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            at_time=at_time,
            max_replicas=max_replicas,
            min_replicas=min_replicas,
            target_replicas=target_replicas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             at_time: Optional[str] = None,
             max_replicas: Optional[int] = None,
             min_replicas: Optional[int] = None,
             target_replicas: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'atTime' in kwargs:
            at_time = kwargs['atTime']
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'targetReplicas' in kwargs:
            target_replicas = kwargs['targetReplicas']

        if at_time is not None:
            _setter("at_time", at_time)
        if max_replicas is not None:
            _setter("max_replicas", max_replicas)
        if min_replicas is not None:
            _setter("min_replicas", min_replicas)
        if target_replicas is not None:
            _setter("target_replicas", target_replicas)

    @property
    @pulumi.getter(name="atTime")
    def at_time(self) -> Optional[str]:
        """
        Trigger point in time. When supporting format: minutes, for example: `08:00`.
        """
        return pulumi.get(self, "at_time")

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[int]:
        """
        Maximum number of instances applied.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[int]:
        """
        Minimum number of instances applied.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> Optional[int]:
        """
        This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        return pulumi.get(self, "target_replicas")


@pulumi.output_type
class ApplicationTomcatConfigV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextPath":
            suggest = "context_path"
        elif key == "maxThreads":
            suggest = "max_threads"
        elif key == "uriEncoding":
            suggest = "uri_encoding"
        elif key == "useBodyEncodingForUri":
            suggest = "use_body_encoding_for_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationTomcatConfigV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationTomcatConfigV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationTomcatConfigV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_path: Optional[str] = None,
                 max_threads: Optional[int] = None,
                 port: Optional[int] = None,
                 uri_encoding: Optional[str] = None,
                 use_body_encoding_for_uri: Optional[str] = None):
        """
        :param str context_path: The path.
        :param int max_threads: The maximum number of connections in the connection pool.
        :param int port: The port.
        :param str uri_encoding: The URI encoding scheme in the Tomcat container.
        :param str use_body_encoding_for_uri: Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        ApplicationTomcatConfigV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            context_path=context_path,
            max_threads=max_threads,
            port=port,
            uri_encoding=uri_encoding,
            use_body_encoding_for_uri=use_body_encoding_for_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             context_path: Optional[str] = None,
             max_threads: Optional[int] = None,
             port: Optional[int] = None,
             uri_encoding: Optional[str] = None,
             use_body_encoding_for_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'contextPath' in kwargs:
            context_path = kwargs['contextPath']
        if 'maxThreads' in kwargs:
            max_threads = kwargs['maxThreads']
        if 'uriEncoding' in kwargs:
            uri_encoding = kwargs['uriEncoding']
        if 'useBodyEncodingForUri' in kwargs:
            use_body_encoding_for_uri = kwargs['useBodyEncodingForUri']

        if context_path is not None:
            _setter("context_path", context_path)
        if max_threads is not None:
            _setter("max_threads", max_threads)
        if port is not None:
            _setter("port", port)
        if uri_encoding is not None:
            _setter("uri_encoding", uri_encoding)
        if use_body_encoding_for_uri is not None:
            _setter("use_body_encoding_for_uri", use_body_encoding_for_uri)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[str]:
        """
        The path.
        """
        return pulumi.get(self, "context_path")

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[int]:
        """
        The maximum number of connections in the connection pool.
        """
        return pulumi.get(self, "max_threads")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="uriEncoding")
    def uri_encoding(self) -> Optional[str]:
        """
        The URI encoding scheme in the Tomcat container.
        """
        return pulumi.get(self, "uri_encoding")

    @property
    @pulumi.getter(name="useBodyEncodingForUri")
    def use_body_encoding_for_uri(self) -> Optional[str]:
        """
        Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        return pulumi.get(self, "use_body_encoding_for_uri")


@pulumi.output_type
class ApplicationUpdateStrategyV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchUpdate":
            suggest = "batch_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationUpdateStrategyV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationUpdateStrategyV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationUpdateStrategyV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_update: Optional['outputs.ApplicationUpdateStrategyV2BatchUpdate'] = None,
                 type: Optional[str] = None):
        """
        :param 'ApplicationUpdateStrategyV2BatchUpdateArgs' batch_update: The phased release policy. See `batch_update` below.
        :param str type: The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        ApplicationUpdateStrategyV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_update=batch_update,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_update: Optional['outputs.ApplicationUpdateStrategyV2BatchUpdate'] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'batchUpdate' in kwargs:
            batch_update = kwargs['batchUpdate']

        if batch_update is not None:
            _setter("batch_update", batch_update)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="batchUpdate")
    def batch_update(self) -> Optional['outputs.ApplicationUpdateStrategyV2BatchUpdate']:
        """
        The phased release policy. See `batch_update` below.
        """
        return pulumi.get(self, "batch_update")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplicationUpdateStrategyV2BatchUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchWaitTime":
            suggest = "batch_wait_time"
        elif key == "releaseType":
            suggest = "release_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationUpdateStrategyV2BatchUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationUpdateStrategyV2BatchUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationUpdateStrategyV2BatchUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional[int] = None,
                 batch_wait_time: Optional[int] = None,
                 release_type: Optional[str] = None):
        """
        :param int batch: The number of batches in which you want to release the instances.
        :param int batch_wait_time: The batch wait time.
        :param str release_type: The processing method for the batches. Valid values: `auto` and `manual`.
        """
        ApplicationUpdateStrategyV2BatchUpdate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch=batch,
            batch_wait_time=batch_wait_time,
            release_type=release_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch: Optional[int] = None,
             batch_wait_time: Optional[int] = None,
             release_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'batchWaitTime' in kwargs:
            batch_wait_time = kwargs['batchWaitTime']
        if 'releaseType' in kwargs:
            release_type = kwargs['releaseType']

        if batch is not None:
            _setter("batch", batch)
        if batch_wait_time is not None:
            _setter("batch_wait_time", batch_wait_time)
        if release_type is not None:
            _setter("release_type", release_type)

    @property
    @pulumi.getter
    def batch(self) -> Optional[int]:
        """
        The number of batches in which you want to release the instances.
        """
        return pulumi.get(self, "batch")

    @property
    @pulumi.getter(name="batchWaitTime")
    def batch_wait_time(self) -> Optional[int]:
        """
        The batch wait time.
        """
        return pulumi.get(self, "batch_wait_time")

    @property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[str]:
        """
        The processing method for the batches. Valid values: `auto` and `manual`.
        """
        return pulumi.get(self, "release_type")


@pulumi.output_type
class GreyTagRouteDubboRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodName":
            suggest = "method_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GreyTagRouteDubboRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GreyTagRouteDubboRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GreyTagRouteDubboRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 group: Optional[str] = None,
                 items: Optional[Sequence['outputs.GreyTagRouteDubboRuleItem']] = None,
                 method_name: Optional[str] = None,
                 service_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str condition: The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param str group: The service group.
        :param Sequence['GreyTagRouteDubboRuleItemArgs'] items: A list of conditions items. See `items` below.
        :param str method_name: The method name
        :param str service_name: The service name.
        :param str version: The service version.
        """
        GreyTagRouteDubboRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            group=group,
            items=items,
            method_name=method_name,
            service_name=service_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             group: Optional[str] = None,
             items: Optional[Sequence['outputs.GreyTagRouteDubboRuleItem']] = None,
             method_name: Optional[str] = None,
             service_name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'methodName' in kwargs:
            method_name = kwargs['methodName']
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        if condition is not None:
            _setter("condition", condition)
        if group is not None:
            _setter("group", group)
        if items is not None:
            _setter("items", items)
        if method_name is not None:
            _setter("method_name", method_name)
        if service_name is not None:
            _setter("service_name", service_name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The service group.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GreyTagRouteDubboRuleItem']]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> Optional[str]:
        """
        The method name
        """
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The service name.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The service version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GreyTagRouteDubboRuleItem(dict):
    def __init__(__self__, *,
                 cond: Optional[str] = None,
                 expr: Optional[str] = None,
                 index: Optional[int] = None,
                 operator: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str cond: The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        :param str expr: The parameter value gets the expression.
        :param int index: The parameter number.
        :param str operator: The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        :param str value: The value of the parameter.
        """
        GreyTagRouteDubboRuleItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cond=cond,
            expr=expr,
            index=index,
            operator=operator,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cond: Optional[str] = None,
             expr: Optional[str] = None,
             index: Optional[int] = None,
             operator: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cond is not None:
            _setter("cond", cond)
        if expr is not None:
            _setter("expr", expr)
        if index is not None:
            _setter("index", index)
        if operator is not None:
            _setter("operator", operator)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def cond(self) -> Optional[str]:
        """
        The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        """
        return pulumi.get(self, "cond")

    @property
    @pulumi.getter
    def expr(self) -> Optional[str]:
        """
        The parameter value gets the expression.
        """
        return pulumi.get(self, "expr")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        The parameter number.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GreyTagRouteScRule(dict):
    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 items: Optional[Sequence['outputs.GreyTagRouteScRuleItem']] = None,
                 path: Optional[str] = None):
        """
        :param str condition: The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param Sequence['GreyTagRouteScRuleItemArgs'] items: A list of conditions items. See `items` below.
        :param str path: The path corresponding to the grayscale rule.
        """
        GreyTagRouteScRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            items=items,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             items: Optional[Sequence['outputs.GreyTagRouteScRuleItem']] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if condition is not None:
            _setter("condition", condition)
        if items is not None:
            _setter("items", items)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GreyTagRouteScRuleItem']]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path corresponding to the grayscale rule.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GreyTagRouteScRuleItem(dict):
    def __init__(__self__, *,
                 cond: Optional[str] = None,
                 name: Optional[str] = None,
                 operator: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str cond: The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        :param str name: The name of the parameter.
        :param str operator: The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        :param str type: The compare types. Valid values: `param`, `cookie`, `header`.
        :param str value: The value of the parameter.
        """
        GreyTagRouteScRuleItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cond=cond,
            name=name,
            operator=operator,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cond: Optional[str] = None,
             name: Optional[str] = None,
             operator: Optional[str] = None,
             type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cond is not None:
            _setter("cond", cond)
        if name is not None:
            _setter("name", name)
        if operator is not None:
            _setter("operator", operator)
        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def cond(self) -> Optional[str]:
        """
        The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        """
        return pulumi.get(self, "cond")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The compare types. Valid values: `param`, `cookie`, `header`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IngressDefaultRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"
        elif key == "containerPort":
            suggest = "container_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressDefaultRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressDefaultRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressDefaultRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 app_name: Optional[str] = None,
                 container_port: Optional[int] = None):
        """
        :param str app_id: Target application ID.
        :param str app_name: Target application name.
        :param int container_port: Application backend port.
        """
        IngressDefaultRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_name=app_name,
            container_port=container_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: Optional[str] = None,
             app_name: Optional[str] = None,
             container_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appName' in kwargs:
            app_name = kwargs['appName']
        if 'containerPort' in kwargs:
            container_port = kwargs['containerPort']

        if app_id is not None:
            _setter("app_id", app_id)
        if app_name is not None:
            _setter("app_name", app_name)
        if container_port is not None:
            _setter("container_port", container_port)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[str]:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")


@pulumi.output_type
class IngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"
        elif key == "containerPort":
            suggest = "container_port"
        elif key == "backendProtocol":
            suggest = "backend_protocol"
        elif key == "rewritePath":
            suggest = "rewrite_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 app_name: str,
                 container_port: int,
                 domain: str,
                 path: str,
                 backend_protocol: Optional[str] = None,
                 rewrite_path: Optional[str] = None):
        """
        :param str app_id: Target application ID.
        :param str app_name: Target application name.
        :param int container_port: Application backend port.
        :param str domain: Application domain name.
        :param str path: URL path.
        :param str backend_protocol: The backend protocol.
        :param str rewrite_path: The rewrite path.
        """
        IngressRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_name=app_name,
            container_port=container_port,
            domain=domain,
            path=path,
            backend_protocol=backend_protocol,
            rewrite_path=rewrite_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: str,
             app_name: str,
             container_port: int,
             domain: str,
             path: str,
             backend_protocol: Optional[str] = None,
             rewrite_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appName' in kwargs:
            app_name = kwargs['appName']
        if 'containerPort' in kwargs:
            container_port = kwargs['containerPort']
        if 'backendProtocol' in kwargs:
            backend_protocol = kwargs['backendProtocol']
        if 'rewritePath' in kwargs:
            rewrite_path = kwargs['rewritePath']

        _setter("app_id", app_id)
        _setter("app_name", app_name)
        _setter("container_port", container_port)
        _setter("domain", domain)
        _setter("path", path)
        if backend_protocol is not None:
            _setter("backend_protocol", backend_protocol)
        if rewrite_path is not None:
            _setter("rewrite_path", rewrite_path)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> str:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Application domain name.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        URL path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[str]:
        """
        The backend protocol.
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="rewritePath")
    def rewrite_path(self) -> Optional[str]:
        """
        The rewrite path.
        """
        return pulumi.get(self, "rewrite_path")


@pulumi.output_type
class LoadBalancerInternetInternet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCertId":
            suggest = "https_cert_id"
        elif key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerInternetInternet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerInternetInternet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerInternetInternet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_cert_id: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        :param str https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param int port: The SLB Port.
        :param str protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param int target_port: The Container port.
        """
        LoadBalancerInternetInternet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https_cert_id=https_cert_id,
            port=port,
            protocol=protocol,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https_cert_id: Optional[str] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             target_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpsCertId' in kwargs:
            https_cert_id = kwargs['httpsCertId']
        if 'targetPort' in kwargs:
            target_port = kwargs['targetPort']

        if https_cert_id is not None:
            _setter("https_cert_id", https_cert_id)
        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)
        if target_port is not None:
            _setter("target_port", target_port)

    @property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[str]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class LoadBalancerIntranetIntranet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCertId":
            suggest = "https_cert_id"
        elif key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerIntranetIntranet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerIntranetIntranet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerIntranetIntranet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_cert_id: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        :param str https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param int port: The SLB Port.
        :param str protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param int target_port: The Container port.
        """
        LoadBalancerIntranetIntranet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https_cert_id=https_cert_id,
            port=port,
            protocol=protocol,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https_cert_id: Optional[str] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             target_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpsCertId' in kwargs:
            https_cert_id = kwargs['httpsCertId']
        if 'targetPort' in kwargs:
            target_port = kwargs['targetPort']

        if https_cert_id is not None:
            _setter("https_cert_id", https_cert_id)
        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)
        if target_port is not None:
            _setter("target_port", target_port)

    @property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[str]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetApplicationScalingRulesRuleResult(dict):
    def __init__(__self__, *,
                 app_id: str,
                 create_time: str,
                 id: str,
                 scaling_rule_enable: bool,
                 scaling_rule_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricResult'],
                 scaling_rule_name: str,
                 scaling_rule_timers: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerResult'],
                 scaling_rule_type: str):
        """
        :param str app_id: The ID of the Application.
        :param str create_time: The CreateTime of the Application Scaling Rule.
        :param str id: The ID of the Application Scaling Rule.
        :param bool scaling_rule_enable: Whether to enable the auto scaling policy.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricArgs'] scaling_rule_metrics: Monitoring indicators for elastic scaling.
        :param str scaling_rule_name: The name of the scaling rule.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleTimerArgs'] scaling_rule_timers: Timing elastic expansion.
        :param str scaling_rule_type: Flexible strategy type.
        """
        GetApplicationScalingRulesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            create_time=create_time,
            id=id,
            scaling_rule_enable=scaling_rule_enable,
            scaling_rule_metrics=scaling_rule_metrics,
            scaling_rule_name=scaling_rule_name,
            scaling_rule_timers=scaling_rule_timers,
            scaling_rule_type=scaling_rule_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: str,
             create_time: str,
             id: str,
             scaling_rule_enable: bool,
             scaling_rule_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricResult'],
             scaling_rule_name: str,
             scaling_rule_timers: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerResult'],
             scaling_rule_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if 'scalingRuleEnable' in kwargs:
            scaling_rule_enable = kwargs['scalingRuleEnable']
        if 'scalingRuleMetrics' in kwargs:
            scaling_rule_metrics = kwargs['scalingRuleMetrics']
        if 'scalingRuleName' in kwargs:
            scaling_rule_name = kwargs['scalingRuleName']
        if 'scalingRuleTimers' in kwargs:
            scaling_rule_timers = kwargs['scalingRuleTimers']
        if 'scalingRuleType' in kwargs:
            scaling_rule_type = kwargs['scalingRuleType']

        _setter("app_id", app_id)
        _setter("create_time", create_time)
        _setter("id", id)
        _setter("scaling_rule_enable", scaling_rule_enable)
        _setter("scaling_rule_metrics", scaling_rule_metrics)
        _setter("scaling_rule_name", scaling_rule_name)
        _setter("scaling_rule_timers", scaling_rule_timers)
        _setter("scaling_rule_type", scaling_rule_type)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The ID of the Application.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The CreateTime of the Application Scaling Rule.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Application Scaling Rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scalingRuleEnable")
    def scaling_rule_enable(self) -> bool:
        """
        Whether to enable the auto scaling policy.
        """
        return pulumi.get(self, "scaling_rule_enable")

    @property
    @pulumi.getter(name="scalingRuleMetrics")
    def scaling_rule_metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricResult']:
        """
        Monitoring indicators for elastic scaling.
        """
        return pulumi.get(self, "scaling_rule_metrics")

    @property
    @pulumi.getter(name="scalingRuleName")
    def scaling_rule_name(self) -> str:
        """
        The name of the scaling rule.
        """
        return pulumi.get(self, "scaling_rule_name")

    @property
    @pulumi.getter(name="scalingRuleTimers")
    def scaling_rule_timers(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerResult']:
        """
        Timing elastic expansion.
        """
        return pulumi.get(self, "scaling_rule_timers")

    @property
    @pulumi.getter(name="scalingRuleType")
    def scaling_rule_type(self) -> str:
        """
        Flexible strategy type.
        """
        return pulumi.get(self, "scaling_rule_type")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricResult(dict):
    def __init__(__self__, *,
                 max_replicas: int,
                 metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricResult'],
                 metrics_statuses: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult'],
                 min_replicas: int,
                 scale_down_rules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult'],
                 scale_up_rules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult']):
        """
        :param int max_replicas: The maximum number of instances.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricArgs'] metrics: The auto scaling list of monitoring indicators.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusArgs'] metrics_statuses: Monitor indicator elasticity status.
        :param int min_replicas: The minimum number of instances.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleArgs'] scale_down_rules: The shrink rule.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleArgs'] scale_up_rules: The expansion rules.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_replicas=max_replicas,
            metrics=metrics,
            metrics_statuses=metrics_statuses,
            min_replicas=min_replicas,
            scale_down_rules=scale_down_rules,
            scale_up_rules=scale_up_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_replicas: int,
             metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricResult'],
             metrics_statuses: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult'],
             min_replicas: int,
             scale_down_rules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult'],
             scale_up_rules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'metricsStatuses' in kwargs:
            metrics_statuses = kwargs['metricsStatuses']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'scaleDownRules' in kwargs:
            scale_down_rules = kwargs['scaleDownRules']
        if 'scaleUpRules' in kwargs:
            scale_up_rules = kwargs['scaleUpRules']

        _setter("max_replicas", max_replicas)
        _setter("metrics", metrics)
        _setter("metrics_statuses", metrics_statuses)
        _setter("min_replicas", min_replicas)
        _setter("scale_down_rules", scale_down_rules)
        _setter("scale_up_rules", scale_up_rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        The maximum number of instances.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricResult']:
        """
        The auto scaling list of monitoring indicators.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="metricsStatuses")
    def metrics_statuses(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult']:
        """
        Monitor indicator elasticity status.
        """
        return pulumi.get(self, "metrics_statuses")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        The minimum number of instances.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="scaleDownRules")
    def scale_down_rules(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult']:
        """
        The shrink rule.
        """
        return pulumi.get(self, "scale_down_rules")

    @property
    @pulumi.getter(name="scaleUpRules")
    def scale_up_rules(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult']:
        """
        The expansion rules.
        """
        return pulumi.get(self, "scale_up_rules")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricResult(dict):
    def __init__(__self__, *,
                 metric_target_average_utilization: int,
                 metric_type: str):
        """
        :param int metric_target_average_utilization: The target value of the monitoring indicator.
        :param str metric_type: The metric type of the Application Scaling Rule.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricMetricResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_target_average_utilization=metric_target_average_utilization,
            metric_type=metric_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_target_average_utilization: int,
             metric_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'metricTargetAverageUtilization' in kwargs:
            metric_target_average_utilization = kwargs['metricTargetAverageUtilization']
        if 'metricType' in kwargs:
            metric_type = kwargs['metricType']

        _setter("metric_target_average_utilization", metric_target_average_utilization)
        _setter("metric_type", metric_type)

    @property
    @pulumi.getter(name="metricTargetAverageUtilization")
    def metric_target_average_utilization(self) -> int:
        """
        The target value of the monitoring indicator.
        """
        return pulumi.get(self, "metric_target_average_utilization")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        The metric type of the Application Scaling Rule.
        """
        return pulumi.get(self, "metric_type")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult(dict):
    def __init__(__self__, *,
                 current_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult'],
                 current_replicas: int,
                 desired_replicas: int,
                 last_scale_time: str,
                 max_replicas: int,
                 min_replicas: int,
                 next_scale_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult'],
                 next_scale_time_period: int):
        """
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricArgs'] current_metrics: The current monitoring indicator elasticity list.
        :param int current_replicas: The number of current instances.
        :param int desired_replicas: The number of target instances.
        :param str last_scale_time: The time of the last elastic expansion.
        :param int max_replicas: The maximum number of instances.
        :param int min_replicas: The minimum number of instances.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricArgs'] next_scale_metrics: Next monitoring indicator elasticity list
        :param int next_scale_time_period: The next cycle of monitoring indicator elasticity.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_metrics=current_metrics,
            current_replicas=current_replicas,
            desired_replicas=desired_replicas,
            last_scale_time=last_scale_time,
            max_replicas=max_replicas,
            min_replicas=min_replicas,
            next_scale_metrics=next_scale_metrics,
            next_scale_time_period=next_scale_time_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult'],
             current_replicas: int,
             desired_replicas: int,
             last_scale_time: str,
             max_replicas: int,
             min_replicas: int,
             next_scale_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult'],
             next_scale_time_period: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'currentMetrics' in kwargs:
            current_metrics = kwargs['currentMetrics']
        if 'currentReplicas' in kwargs:
            current_replicas = kwargs['currentReplicas']
        if 'desiredReplicas' in kwargs:
            desired_replicas = kwargs['desiredReplicas']
        if 'lastScaleTime' in kwargs:
            last_scale_time = kwargs['lastScaleTime']
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'nextScaleMetrics' in kwargs:
            next_scale_metrics = kwargs['nextScaleMetrics']
        if 'nextScaleTimePeriod' in kwargs:
            next_scale_time_period = kwargs['nextScaleTimePeriod']

        _setter("current_metrics", current_metrics)
        _setter("current_replicas", current_replicas)
        _setter("desired_replicas", desired_replicas)
        _setter("last_scale_time", last_scale_time)
        _setter("max_replicas", max_replicas)
        _setter("min_replicas", min_replicas)
        _setter("next_scale_metrics", next_scale_metrics)
        _setter("next_scale_time_period", next_scale_time_period)

    @property
    @pulumi.getter(name="currentMetrics")
    def current_metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult']:
        """
        The current monitoring indicator elasticity list.
        """
        return pulumi.get(self, "current_metrics")

    @property
    @pulumi.getter(name="currentReplicas")
    def current_replicas(self) -> int:
        """
        The number of current instances.
        """
        return pulumi.get(self, "current_replicas")

    @property
    @pulumi.getter(name="desiredReplicas")
    def desired_replicas(self) -> int:
        """
        The number of target instances.
        """
        return pulumi.get(self, "desired_replicas")

    @property
    @pulumi.getter(name="lastScaleTime")
    def last_scale_time(self) -> str:
        """
        The time of the last elastic expansion.
        """
        return pulumi.get(self, "last_scale_time")

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        The maximum number of instances.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        The minimum number of instances.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="nextScaleMetrics")
    def next_scale_metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult']:
        """
        Next monitoring indicator elasticity list
        """
        return pulumi.get(self, "next_scale_metrics")

    @property
    @pulumi.getter(name="nextScaleTimePeriod")
    def next_scale_time_period(self) -> int:
        """
        The next cycle of monitoring indicator elasticity.
        """
        return pulumi.get(self, "next_scale_time_period")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult(dict):
    def __init__(__self__, *,
                 current_value: int,
                 name: str,
                 type: str):
        """
        :param int current_value: The current value.
        :param str name: The name of the trigger condition.
        :param str type: The metric type. Associated with monitoring indicators.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_value=current_value,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_value: int,
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'currentValue' in kwargs:
            current_value = kwargs['currentValue']

        _setter("current_value", current_value)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> int:
        """
        The current value.
        """
        return pulumi.get(self, "current_value")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the trigger condition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The metric type. Associated with monitoring indicators.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult(dict):
    def __init__(__self__, *,
                 name: str,
                 next_scale_in_average_utilization: int,
                 next_scale_out_average_utilization: int):
        """
        :param str name: The name of the trigger condition.
        :param int next_scale_in_average_utilization: The percentage value of the monitoring indicator elasticity that triggers the shrinkage condition next time.
        :param int next_scale_out_average_utilization: The percentage value of the monitoring indicator elasticity that triggers the expansion condition next time.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            next_scale_in_average_utilization=next_scale_in_average_utilization,
            next_scale_out_average_utilization=next_scale_out_average_utilization,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             next_scale_in_average_utilization: int,
             next_scale_out_average_utilization: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nextScaleInAverageUtilization' in kwargs:
            next_scale_in_average_utilization = kwargs['nextScaleInAverageUtilization']
        if 'nextScaleOutAverageUtilization' in kwargs:
            next_scale_out_average_utilization = kwargs['nextScaleOutAverageUtilization']

        _setter("name", name)
        _setter("next_scale_in_average_utilization", next_scale_in_average_utilization)
        _setter("next_scale_out_average_utilization", next_scale_out_average_utilization)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the trigger condition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextScaleInAverageUtilization")
    def next_scale_in_average_utilization(self) -> int:
        """
        The percentage value of the monitoring indicator elasticity that triggers the shrinkage condition next time.
        """
        return pulumi.get(self, "next_scale_in_average_utilization")

    @property
    @pulumi.getter(name="nextScaleOutAverageUtilization")
    def next_scale_out_average_utilization(self) -> int:
        """
        The percentage value of the monitoring indicator elasticity that triggers the expansion condition next time.
        """
        return pulumi.get(self, "next_scale_out_average_utilization")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult(dict):
    def __init__(__self__, *,
                 disabled: bool,
                 stabilization_window_seconds: int,
                 step: int):
        """
        :param bool disabled: Whether shrinkage is prohibited. The values are described as follows:
        :param int stabilization_window_seconds: Expansion cooling time.
        :param int step: Flexible expansion step. The maximum number of instances per unit time.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled=disabled,
            stabilization_window_seconds=stabilization_window_seconds,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled: bool,
             stabilization_window_seconds: int,
             step: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stabilizationWindowSeconds' in kwargs:
            stabilization_window_seconds = kwargs['stabilizationWindowSeconds']

        _setter("disabled", disabled)
        _setter("stabilization_window_seconds", stabilization_window_seconds)
        _setter("step", step)

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Whether shrinkage is prohibited. The values are described as follows:
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> int:
        """
        Expansion cooling time.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @property
    @pulumi.getter
    def step(self) -> int:
        """
        Flexible expansion step. The maximum number of instances per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult(dict):
    def __init__(__self__, *,
                 disabled: bool,
                 stabilization_window_seconds: int,
                 step: int):
        """
        :param bool disabled: Whether shrinkage is prohibited. The values are described as follows:
        :param int stabilization_window_seconds: Expansion cooling time.
        :param int step: Flexible expansion step. The maximum number of instances per unit time.
        """
        GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled=disabled,
            stabilization_window_seconds=stabilization_window_seconds,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled: bool,
             stabilization_window_seconds: int,
             step: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stabilizationWindowSeconds' in kwargs:
            stabilization_window_seconds = kwargs['stabilizationWindowSeconds']

        _setter("disabled", disabled)
        _setter("stabilization_window_seconds", stabilization_window_seconds)
        _setter("step", step)

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Whether shrinkage is prohibited. The values are described as follows:
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> int:
        """
        Expansion cooling time.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @property
    @pulumi.getter
    def step(self) -> int:
        """
        Flexible expansion step. The maximum number of instances per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleTimerResult(dict):
    def __init__(__self__, *,
                 begin_date: str,
                 end_date: str,
                 period: str,
                 schedules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult']):
        """
        :param str begin_date: The short-term start date of the timed elastic scaling strategy.
        :param str end_date: The short-term end date of the timed elastic scaling strategy.
        :param str period: The period in which a timed elastic scaling strategy is executed.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleTimerScheduleArgs'] schedules: Trigger point in time within a single day.
        """
        GetApplicationScalingRulesRuleScalingRuleTimerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            begin_date=begin_date,
            end_date=end_date,
            period=period,
            schedules=schedules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             begin_date: str,
             end_date: str,
             period: str,
             schedules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'beginDate' in kwargs:
            begin_date = kwargs['beginDate']
        if 'endDate' in kwargs:
            end_date = kwargs['endDate']

        _setter("begin_date", begin_date)
        _setter("end_date", end_date)
        _setter("period", period)
        _setter("schedules", schedules)

    @property
    @pulumi.getter(name="beginDate")
    def begin_date(self) -> str:
        """
        The short-term start date of the timed elastic scaling strategy.
        """
        return pulumi.get(self, "begin_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The short-term end date of the timed elastic scaling strategy.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def period(self) -> str:
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult']:
        """
        Trigger point in time within a single day.
        """
        return pulumi.get(self, "schedules")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult(dict):
    def __init__(__self__, *,
                 at_time: str,
                 max_replicas: int,
                 min_replicas: int,
                 target_replicas: int):
        """
        :param str at_time: Time point. Format: `hours:minutes`.
        :param int max_replicas: The maximum number of instances.
        :param int min_replicas: The minimum number of instances.
        :param int target_replicas: The number of target instances.
        """
        GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            at_time=at_time,
            max_replicas=max_replicas,
            min_replicas=min_replicas,
            target_replicas=target_replicas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             at_time: str,
             max_replicas: int,
             min_replicas: int,
             target_replicas: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'atTime' in kwargs:
            at_time = kwargs['atTime']
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'targetReplicas' in kwargs:
            target_replicas = kwargs['targetReplicas']

        _setter("at_time", at_time)
        _setter("max_replicas", max_replicas)
        _setter("min_replicas", min_replicas)
        _setter("target_replicas", target_replicas)

    @property
    @pulumi.getter(name="atTime")
    def at_time(self) -> str:
        """
        Time point. Format: `hours:minutes`.
        """
        return pulumi.get(self, "at_time")

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        The maximum number of instances.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        The minimum number of instances.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> int:
        """
        The number of target instances.
        """
        return pulumi.get(self, "target_replicas")


@pulumi.output_type
class GetApplicationsApplicationResult(dict):
    def __init__(__self__, *,
                 acr_assume_role_arn: str,
                 acr_instance_id: str,
                 app_description: str,
                 app_name: str,
                 application_id: str,
                 command: str,
                 command_args: str,
                 config_map_mount_desc: str,
                 cpu: int,
                 create_time: str,
                 custom_host_alias: str,
                 edas_container_version: str,
                 envs: str,
                 id: str,
                 image_url: str,
                 jar_start_args: str,
                 jar_start_options: str,
                 jdk: str,
                 liveness: str,
                 memory: int,
                 min_ready_instances: int,
                 mount_descs: Sequence['outputs.GetApplicationsApplicationMountDescResult'],
                 mount_host: str,
                 namespace_id: str,
                 nas_id: str,
                 oss_ak_id: str,
                 oss_ak_secret: str,
                 oss_mount_descs: str,
                 oss_mount_details: Sequence['outputs.GetApplicationsApplicationOssMountDetailResult'],
                 package_type: str,
                 package_url: str,
                 package_version: str,
                 php_arms_config_location: str,
                 php_config: str,
                 php_config_location: str,
                 post_start: str,
                 pre_stop: str,
                 readiness: str,
                 region_id: str,
                 replicas: int,
                 repo_name: str,
                 repo_namespace: str,
                 repo_origin_type: str,
                 security_group_id: str,
                 sls_configs: str,
                 status: str,
                 tags: Mapping[str, Any],
                 termination_grace_period_seconds: int,
                 timezone: str,
                 tomcat_config: str,
                 vpc_id: str,
                 vswitch_id: str,
                 war_start_options: str,
                 web_container: str):
        """
        :param str acr_assume_role_arn: The ARN of the RAM role required when pulling images across accounts.
        :param str acr_instance_id: The ID of the ACR EE instance.
        :param str app_description: Application description information. No more than 1024 characters.
        :param str app_name: Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
        :param str application_id: The first ID of the resource.
        :param str command: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        :param str command_args: Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
        :param str config_map_mount_desc: ConfigMap mount description.
        :param int cpu: The CPU required for each instance, in millicores, cannot be 0.
        :param str create_time: Indicates That the Application of the Creation Time.
        :param str custom_host_alias: Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
        :param str edas_container_version: The operating environment used by the Pandora application.
        :param str envs: The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
        :param str id: The ID of the Application.
        :param str image_url: Mirror address. Only Image type applications can configure the mirror address.
        :param str jar_start_args: The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        :param str jar_start_options: The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        :param str jdk: The JDK version that the deployment package depends on. Image type applications are not supported.
        :param str liveness: Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
        :param int memory: The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
        :param int min_ready_instances: The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
        :param Sequence['GetApplicationsApplicationMountDescArgs'] mount_descs: Mount description information.
        :param str mount_host: Mount point of NAS in application VPC.
        :param str namespace_id: SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
        :param str nas_id: ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
        :param str oss_ak_id: OSS AccessKey ID.
        :param str oss_ak_secret: OSS  AccessKey Secret.
        :param str oss_mount_descs: OSS mount description information.
        :param Sequence['GetApplicationsApplicationOssMountDetailArgs'] oss_mount_details: The OSS mount detail.
        :param str package_type: Application package type. Support FatJar, War and Image.
        :param str package_url: Deployment package address. Only FatJar or War type applications can configure the deployment package address.
        :param str package_version: The version number of the deployment package. Required when the Package Type is War and FatJar.
        :param str php_arms_config_location: The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
        :param str php_config: PHP configuration file content.
        :param str php_config_location: PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
        :param str post_start: Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        :param str pre_stop: Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        :param str readiness: Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
        :param int replicas: Initial number of instances.
        :param str security_group_id: Security group ID.
        :param str sls_configs: SLS  configuration.
        :param str status: The status of the resource.
        :param Mapping[str, Any] tags: A mapping of tags to assign to the resource.
        :param int termination_grace_period_seconds: Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
        :param str timezone: Time zone, the default value is Asia/Shanghai.
        :param str tomcat_config: Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
        :param str vpc_id: The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
        :param str vswitch_id: The vswitch id.
        :param str war_start_options: WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
        :param str web_container: The version of tomcat that the deployment package depends on. Image type applications are not supported.
        """
        GetApplicationsApplicationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acr_assume_role_arn=acr_assume_role_arn,
            acr_instance_id=acr_instance_id,
            app_description=app_description,
            app_name=app_name,
            application_id=application_id,
            command=command,
            command_args=command_args,
            config_map_mount_desc=config_map_mount_desc,
            cpu=cpu,
            create_time=create_time,
            custom_host_alias=custom_host_alias,
            edas_container_version=edas_container_version,
            envs=envs,
            id=id,
            image_url=image_url,
            jar_start_args=jar_start_args,
            jar_start_options=jar_start_options,
            jdk=jdk,
            liveness=liveness,
            memory=memory,
            min_ready_instances=min_ready_instances,
            mount_descs=mount_descs,
            mount_host=mount_host,
            namespace_id=namespace_id,
            nas_id=nas_id,
            oss_ak_id=oss_ak_id,
            oss_ak_secret=oss_ak_secret,
            oss_mount_descs=oss_mount_descs,
            oss_mount_details=oss_mount_details,
            package_type=package_type,
            package_url=package_url,
            package_version=package_version,
            php_arms_config_location=php_arms_config_location,
            php_config=php_config,
            php_config_location=php_config_location,
            post_start=post_start,
            pre_stop=pre_stop,
            readiness=readiness,
            region_id=region_id,
            replicas=replicas,
            repo_name=repo_name,
            repo_namespace=repo_namespace,
            repo_origin_type=repo_origin_type,
            security_group_id=security_group_id,
            sls_configs=sls_configs,
            status=status,
            tags=tags,
            termination_grace_period_seconds=termination_grace_period_seconds,
            timezone=timezone,
            tomcat_config=tomcat_config,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
            war_start_options=war_start_options,
            web_container=web_container,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acr_assume_role_arn: str,
             acr_instance_id: str,
             app_description: str,
             app_name: str,
             application_id: str,
             command: str,
             command_args: str,
             config_map_mount_desc: str,
             cpu: int,
             create_time: str,
             custom_host_alias: str,
             edas_container_version: str,
             envs: str,
             id: str,
             image_url: str,
             jar_start_args: str,
             jar_start_options: str,
             jdk: str,
             liveness: str,
             memory: int,
             min_ready_instances: int,
             mount_descs: Sequence['outputs.GetApplicationsApplicationMountDescResult'],
             mount_host: str,
             namespace_id: str,
             nas_id: str,
             oss_ak_id: str,
             oss_ak_secret: str,
             oss_mount_descs: str,
             oss_mount_details: Sequence['outputs.GetApplicationsApplicationOssMountDetailResult'],
             package_type: str,
             package_url: str,
             package_version: str,
             php_arms_config_location: str,
             php_config: str,
             php_config_location: str,
             post_start: str,
             pre_stop: str,
             readiness: str,
             region_id: str,
             replicas: int,
             repo_name: str,
             repo_namespace: str,
             repo_origin_type: str,
             security_group_id: str,
             sls_configs: str,
             status: str,
             tags: Mapping[str, Any],
             termination_grace_period_seconds: int,
             timezone: str,
             tomcat_config: str,
             vpc_id: str,
             vswitch_id: str,
             war_start_options: str,
             web_container: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'acrAssumeRoleArn' in kwargs:
            acr_assume_role_arn = kwargs['acrAssumeRoleArn']
        if 'acrInstanceId' in kwargs:
            acr_instance_id = kwargs['acrInstanceId']
        if 'appDescription' in kwargs:
            app_description = kwargs['appDescription']
        if 'appName' in kwargs:
            app_name = kwargs['appName']
        if 'applicationId' in kwargs:
            application_id = kwargs['applicationId']
        if 'commandArgs' in kwargs:
            command_args = kwargs['commandArgs']
        if 'configMapMountDesc' in kwargs:
            config_map_mount_desc = kwargs['configMapMountDesc']
        if 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if 'customHostAlias' in kwargs:
            custom_host_alias = kwargs['customHostAlias']
        if 'edasContainerVersion' in kwargs:
            edas_container_version = kwargs['edasContainerVersion']
        if 'imageUrl' in kwargs:
            image_url = kwargs['imageUrl']
        if 'jarStartArgs' in kwargs:
            jar_start_args = kwargs['jarStartArgs']
        if 'jarStartOptions' in kwargs:
            jar_start_options = kwargs['jarStartOptions']
        if 'minReadyInstances' in kwargs:
            min_ready_instances = kwargs['minReadyInstances']
        if 'mountDescs' in kwargs:
            mount_descs = kwargs['mountDescs']
        if 'mountHost' in kwargs:
            mount_host = kwargs['mountHost']
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'nasId' in kwargs:
            nas_id = kwargs['nasId']
        if 'ossAkId' in kwargs:
            oss_ak_id = kwargs['ossAkId']
        if 'ossAkSecret' in kwargs:
            oss_ak_secret = kwargs['ossAkSecret']
        if 'ossMountDescs' in kwargs:
            oss_mount_descs = kwargs['ossMountDescs']
        if 'ossMountDetails' in kwargs:
            oss_mount_details = kwargs['ossMountDetails']
        if 'packageType' in kwargs:
            package_type = kwargs['packageType']
        if 'packageUrl' in kwargs:
            package_url = kwargs['packageUrl']
        if 'packageVersion' in kwargs:
            package_version = kwargs['packageVersion']
        if 'phpArmsConfigLocation' in kwargs:
            php_arms_config_location = kwargs['phpArmsConfigLocation']
        if 'phpConfig' in kwargs:
            php_config = kwargs['phpConfig']
        if 'phpConfigLocation' in kwargs:
            php_config_location = kwargs['phpConfigLocation']
        if 'postStart' in kwargs:
            post_start = kwargs['postStart']
        if 'preStop' in kwargs:
            pre_stop = kwargs['preStop']
        if 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if 'repoName' in kwargs:
            repo_name = kwargs['repoName']
        if 'repoNamespace' in kwargs:
            repo_namespace = kwargs['repoNamespace']
        if 'repoOriginType' in kwargs:
            repo_origin_type = kwargs['repoOriginType']
        if 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if 'slsConfigs' in kwargs:
            sls_configs = kwargs['slsConfigs']
        if 'terminationGracePeriodSeconds' in kwargs:
            termination_grace_period_seconds = kwargs['terminationGracePeriodSeconds']
        if 'tomcatConfig' in kwargs:
            tomcat_config = kwargs['tomcatConfig']
        if 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if 'warStartOptions' in kwargs:
            war_start_options = kwargs['warStartOptions']
        if 'webContainer' in kwargs:
            web_container = kwargs['webContainer']

        _setter("acr_assume_role_arn", acr_assume_role_arn)
        _setter("acr_instance_id", acr_instance_id)
        _setter("app_description", app_description)
        _setter("app_name", app_name)
        _setter("application_id", application_id)
        _setter("command", command)
        _setter("command_args", command_args)
        _setter("config_map_mount_desc", config_map_mount_desc)
        _setter("cpu", cpu)
        _setter("create_time", create_time)
        _setter("custom_host_alias", custom_host_alias)
        _setter("edas_container_version", edas_container_version)
        _setter("envs", envs)
        _setter("id", id)
        _setter("image_url", image_url)
        _setter("jar_start_args", jar_start_args)
        _setter("jar_start_options", jar_start_options)
        _setter("jdk", jdk)
        _setter("liveness", liveness)
        _setter("memory", memory)
        _setter("min_ready_instances", min_ready_instances)
        _setter("mount_descs", mount_descs)
        _setter("mount_host", mount_host)
        _setter("namespace_id", namespace_id)
        _setter("nas_id", nas_id)
        _setter("oss_ak_id", oss_ak_id)
        _setter("oss_ak_secret", oss_ak_secret)
        _setter("oss_mount_descs", oss_mount_descs)
        _setter("oss_mount_details", oss_mount_details)
        _setter("package_type", package_type)
        _setter("package_url", package_url)
        _setter("package_version", package_version)
        _setter("php_arms_config_location", php_arms_config_location)
        _setter("php_config", php_config)
        _setter("php_config_location", php_config_location)
        _setter("post_start", post_start)
        _setter("pre_stop", pre_stop)
        _setter("readiness", readiness)
        _setter("region_id", region_id)
        _setter("replicas", replicas)
        _setter("repo_name", repo_name)
        _setter("repo_namespace", repo_namespace)
        _setter("repo_origin_type", repo_origin_type)
        _setter("security_group_id", security_group_id)
        _setter("sls_configs", sls_configs)
        _setter("status", status)
        _setter("tags", tags)
        _setter("termination_grace_period_seconds", termination_grace_period_seconds)
        _setter("timezone", timezone)
        _setter("tomcat_config", tomcat_config)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)
        _setter("war_start_options", war_start_options)
        _setter("web_container", web_container)

    @property
    @pulumi.getter(name="acrAssumeRoleArn")
    def acr_assume_role_arn(self) -> str:
        """
        The ARN of the RAM role required when pulling images across accounts.
        """
        return pulumi.get(self, "acr_assume_role_arn")

    @property
    @pulumi.getter(name="acrInstanceId")
    def acr_instance_id(self) -> str:
        """
        The ID of the ACR EE instance.
        """
        return pulumi.get(self, "acr_instance_id")

    @property
    @pulumi.getter(name="appDescription")
    def app_description(self) -> str:
        """
        Application description information. No more than 1024 characters.
        """
        return pulumi.get(self, "app_description")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> str:
        """
        Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def command(self) -> str:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="commandArgs")
    def command_args(self) -> str:
        """
        Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
        """
        return pulumi.get(self, "command_args")

    @property
    @pulumi.getter(name="configMapMountDesc")
    def config_map_mount_desc(self) -> str:
        """
        ConfigMap mount description.
        """
        return pulumi.get(self, "config_map_mount_desc")

    @property
    @pulumi.getter
    def cpu(self) -> int:
        """
        The CPU required for each instance, in millicores, cannot be 0.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Indicates That the Application of the Creation Time.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="customHostAlias")
    def custom_host_alias(self) -> str:
        """
        Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
        """
        return pulumi.get(self, "custom_host_alias")

    @property
    @pulumi.getter(name="edasContainerVersion")
    def edas_container_version(self) -> str:
        """
        The operating environment used by the Pandora application.
        """
        return pulumi.get(self, "edas_container_version")

    @property
    @pulumi.getter
    def envs(self) -> str:
        """
        The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Application.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> str:
        """
        Mirror address. Only Image type applications can configure the mirror address.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter(name="jarStartArgs")
    def jar_start_args(self) -> str:
        """
        The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        """
        return pulumi.get(self, "jar_start_args")

    @property
    @pulumi.getter(name="jarStartOptions")
    def jar_start_options(self) -> str:
        """
        The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        """
        return pulumi.get(self, "jar_start_options")

    @property
    @pulumi.getter
    def jdk(self) -> str:
        """
        The JDK version that the deployment package depends on. Image type applications are not supported.
        """
        return pulumi.get(self, "jdk")

    @property
    @pulumi.getter
    def liveness(self) -> str:
        """
        Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
        """
        return pulumi.get(self, "liveness")

    @property
    @pulumi.getter
    def memory(self) -> int:
        """
        The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="minReadyInstances")
    def min_ready_instances(self) -> int:
        """
        The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
        """
        return pulumi.get(self, "min_ready_instances")

    @property
    @pulumi.getter(name="mountDescs")
    def mount_descs(self) -> Sequence['outputs.GetApplicationsApplicationMountDescResult']:
        """
        Mount description information.
        """
        return pulumi.get(self, "mount_descs")

    @property
    @pulumi.getter(name="mountHost")
    def mount_host(self) -> str:
        """
        Mount point of NAS in application VPC.
        """
        return pulumi.get(self, "mount_host")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="nasId")
    def nas_id(self) -> str:
        """
        ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
        """
        return pulumi.get(self, "nas_id")

    @property
    @pulumi.getter(name="ossAkId")
    def oss_ak_id(self) -> str:
        """
        OSS AccessKey ID.
        """
        return pulumi.get(self, "oss_ak_id")

    @property
    @pulumi.getter(name="ossAkSecret")
    def oss_ak_secret(self) -> str:
        """
        OSS  AccessKey Secret.
        """
        return pulumi.get(self, "oss_ak_secret")

    @property
    @pulumi.getter(name="ossMountDescs")
    def oss_mount_descs(self) -> str:
        """
        OSS mount description information.
        """
        return pulumi.get(self, "oss_mount_descs")

    @property
    @pulumi.getter(name="ossMountDetails")
    def oss_mount_details(self) -> Sequence['outputs.GetApplicationsApplicationOssMountDetailResult']:
        """
        The OSS mount detail.
        """
        return pulumi.get(self, "oss_mount_details")

    @property
    @pulumi.getter(name="packageType")
    def package_type(self) -> str:
        """
        Application package type. Support FatJar, War and Image.
        """
        return pulumi.get(self, "package_type")

    @property
    @pulumi.getter(name="packageUrl")
    def package_url(self) -> str:
        """
        Deployment package address. Only FatJar or War type applications can configure the deployment package address.
        """
        return pulumi.get(self, "package_url")

    @property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> str:
        """
        The version number of the deployment package. Required when the Package Type is War and FatJar.
        """
        return pulumi.get(self, "package_version")

    @property
    @pulumi.getter(name="phpArmsConfigLocation")
    def php_arms_config_location(self) -> str:
        """
        The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
        """
        return pulumi.get(self, "php_arms_config_location")

    @property
    @pulumi.getter(name="phpConfig")
    def php_config(self) -> str:
        """
        PHP configuration file content.
        """
        return pulumi.get(self, "php_config")

    @property
    @pulumi.getter(name="phpConfigLocation")
    def php_config_location(self) -> str:
        """
        PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
        """
        return pulumi.get(self, "php_config_location")

    @property
    @pulumi.getter(name="postStart")
    def post_start(self) -> str:
        """
        Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        """
        return pulumi.get(self, "post_start")

    @property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> str:
        """
        Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        """
        return pulumi.get(self, "pre_stop")

    @property
    @pulumi.getter
    def readiness(self) -> str:
        """
        Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
        """
        return pulumi.get(self, "readiness")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        Initial number of instances.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="repoNamespace")
    def repo_namespace(self) -> str:
        return pulumi.get(self, "repo_namespace")

    @property
    @pulumi.getter(name="repoOriginType")
    def repo_origin_type(self) -> str:
        return pulumi.get(self, "repo_origin_type")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        Security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="slsConfigs")
    def sls_configs(self) -> str:
        """
        SLS  configuration.
        """
        return pulumi.get(self, "sls_configs")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> int:
        """
        Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        Time zone, the default value is Asia/Shanghai.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="tomcatConfig")
    def tomcat_config(self) -> str:
        """
        Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
        """
        return pulumi.get(self, "tomcat_config")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The vswitch id.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="warStartOptions")
    def war_start_options(self) -> str:
        """
        WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
        """
        return pulumi.get(self, "war_start_options")

    @property
    @pulumi.getter(name="webContainer")
    def web_container(self) -> str:
        """
        The version of tomcat that the deployment package depends on. Image type applications are not supported.
        """
        return pulumi.get(self, "web_container")


@pulumi.output_type
class GetApplicationsApplicationMountDescResult(dict):
    def __init__(__self__, *,
                 mount_path: str,
                 nas_path: str):
        """
        :param str mount_path: The Container mount path.
        :param str nas_path: NAS relative file directory.
        """
        GetApplicationsApplicationMountDescResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_path=mount_path,
            nas_path=nas_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_path: str,
             nas_path: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'nasPath' in kwargs:
            nas_path = kwargs['nasPath']

        _setter("mount_path", mount_path)
        _setter("nas_path", nas_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The Container mount path.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="nasPath")
    def nas_path(self) -> str:
        """
        NAS relative file directory.
        """
        return pulumi.get(self, "nas_path")


@pulumi.output_type
class GetApplicationsApplicationOssMountDetailResult(dict):
    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_path: str,
                 mount_path: str,
                 read_only: bool):
        """
        :param str bucket_name: The name of the bucket.
        :param str bucket_path: The path of the bucket.
        :param str mount_path: The Container mount path.
        :param bool read_only: Whether the container path has readable permission to mount directory resources.
        """
        GetApplicationsApplicationOssMountDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_path=bucket_path,
            mount_path=mount_path,
            read_only=read_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: str,
             bucket_path: str,
             mount_path: str,
             read_only: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if 'bucketPath' in kwargs:
            bucket_path = kwargs['bucketPath']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'readOnly' in kwargs:
            read_only = kwargs['readOnly']

        _setter("bucket_name", bucket_name)
        _setter("bucket_path", bucket_path)
        _setter("mount_path", mount_path)
        _setter("read_only", read_only)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> str:
        """
        The path of the bucket.
        """
        return pulumi.get(self, "bucket_path")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The Container mount path.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> bool:
        """
        Whether the container path has readable permission to mount directory resources.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetConfigMapsMapResult(dict):
    def __init__(__self__, *,
                 config_map_id: str,
                 create_time: str,
                 data: str,
                 description: str,
                 id: str,
                 name: str,
                 namespace_id: str):
        """
        :param str config_map_id: The first ID of the resource.
        :param str create_time: The Creation Time of the ConfigMap.
        :param str data: ConfigMap instance data. The value's format is a `json` string
        :param str description: The Description of Config Map.
        :param str id: The ID of the Config Map.
        :param str name: ConfigMap instance name.
        :param str namespace_id: The NamespaceId of Config Maps.
        """
        GetConfigMapsMapResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_map_id=config_map_id,
            create_time=create_time,
            data=data,
            description=description,
            id=id,
            name=name,
            namespace_id=namespace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_map_id: str,
             create_time: str,
             data: str,
             description: str,
             id: str,
             name: str,
             namespace_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configMapId' in kwargs:
            config_map_id = kwargs['configMapId']
        if 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']

        _setter("config_map_id", config_map_id)
        _setter("create_time", create_time)
        _setter("data", data)
        _setter("description", description)
        _setter("id", id)
        _setter("name", name)
        _setter("namespace_id", namespace_id)

    @property
    @pulumi.getter(name="configMapId")
    def config_map_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "config_map_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The Creation Time of the ConfigMap.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        ConfigMap instance data. The value's format is a `json` string
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The Description of Config Map.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Config Map.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        ConfigMap instance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        The NamespaceId of Config Maps.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class GetGreyTagRoutesRouteResult(dict):
    def __init__(__self__, *,
                 description: str,
                 dubbo_rules: Sequence['outputs.GetGreyTagRoutesRouteDubboRuleResult'],
                 grey_tag_route_name: str,
                 id: str,
                 sc_rules: Sequence['outputs.GetGreyTagRoutesRouteScRuleResult']):
        """
        :param str description: The description of GreyTagRoute.
        :param Sequence['GetGreyTagRoutesRouteDubboRuleArgs'] dubbo_rules: The grayscale rule created for Dubbo Application.
        :param str grey_tag_route_name: The name of GreyTagRoute.
        :param str id: The ID of the GreyTagRoute.
        :param Sequence['GetGreyTagRoutesRouteScRuleArgs'] sc_rules: The grayscale rule created for SpringCloud Application.
        """
        GetGreyTagRoutesRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            dubbo_rules=dubbo_rules,
            grey_tag_route_name=grey_tag_route_name,
            id=id,
            sc_rules=sc_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             dubbo_rules: Sequence['outputs.GetGreyTagRoutesRouteDubboRuleResult'],
             grey_tag_route_name: str,
             id: str,
             sc_rules: Sequence['outputs.GetGreyTagRoutesRouteScRuleResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dubboRules' in kwargs:
            dubbo_rules = kwargs['dubboRules']
        if 'greyTagRouteName' in kwargs:
            grey_tag_route_name = kwargs['greyTagRouteName']
        if 'scRules' in kwargs:
            sc_rules = kwargs['scRules']

        _setter("description", description)
        _setter("dubbo_rules", dubbo_rules)
        _setter("grey_tag_route_name", grey_tag_route_name)
        _setter("id", id)
        _setter("sc_rules", sc_rules)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of GreyTagRoute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dubboRules")
    def dubbo_rules(self) -> Sequence['outputs.GetGreyTagRoutesRouteDubboRuleResult']:
        """
        The grayscale rule created for Dubbo Application.
        """
        return pulumi.get(self, "dubbo_rules")

    @property
    @pulumi.getter(name="greyTagRouteName")
    def grey_tag_route_name(self) -> str:
        """
        The name of GreyTagRoute.
        """
        return pulumi.get(self, "grey_tag_route_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the GreyTagRoute.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="scRules")
    def sc_rules(self) -> Sequence['outputs.GetGreyTagRoutesRouteScRuleResult']:
        """
        The grayscale rule created for SpringCloud Application.
        """
        return pulumi.get(self, "sc_rules")


@pulumi.output_type
class GetGreyTagRoutesRouteDubboRuleResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 group: str,
                 items: Sequence['outputs.GetGreyTagRoutesRouteDubboRuleItemResult'],
                 method_name: str,
                 service_name: str,
                 version: str):
        """
        :param str condition: The Conditional Patterns for Grayscale Rules.
        :param str group: The service group.
        :param Sequence['GetGreyTagRoutesRouteDubboRuleItemArgs'] items: A list of conditions items.
        :param str method_name: The method name
        :param str service_name: The service name.
        :param str version: The service version.
        """
        GetGreyTagRoutesRouteDubboRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            group=group,
            items=items,
            method_name=method_name,
            service_name=service_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             group: str,
             items: Sequence['outputs.GetGreyTagRoutesRouteDubboRuleItemResult'],
             method_name: str,
             service_name: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'methodName' in kwargs:
            method_name = kwargs['methodName']
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        _setter("condition", condition)
        _setter("group", group)
        _setter("items", items)
        _setter("method_name", method_name)
        _setter("service_name", service_name)
        _setter("version", version)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The Conditional Patterns for Grayscale Rules.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The service group.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetGreyTagRoutesRouteDubboRuleItemResult']:
        """
        A list of conditions items.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> str:
        """
        The method name
        """
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The service name.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The service version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGreyTagRoutesRouteDubboRuleItemResult(dict):
    def __init__(__self__, *,
                 cond: str,
                 expr: str,
                 index: int,
                 operator: str,
                 value: str):
        """
        :param str cond: The comparison operator.
        :param str expr: The parameter value gets the expression.
        :param int index: The parameter number.
        :param str operator: The operator.
        :param str value: The value of the parameter.
        """
        GetGreyTagRoutesRouteDubboRuleItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cond=cond,
            expr=expr,
            index=index,
            operator=operator,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cond: str,
             expr: str,
             index: int,
             operator: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("cond", cond)
        _setter("expr", expr)
        _setter("index", index)
        _setter("operator", operator)
        _setter("value", value)

    @property
    @pulumi.getter
    def cond(self) -> str:
        """
        The comparison operator.
        """
        return pulumi.get(self, "cond")

    @property
    @pulumi.getter
    def expr(self) -> str:
        """
        The parameter value gets the expression.
        """
        return pulumi.get(self, "expr")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The parameter number.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGreyTagRoutesRouteScRuleResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 items: Sequence['outputs.GetGreyTagRoutesRouteScRuleItemResult'],
                 path: str):
        """
        :param str condition: The Conditional Patterns for Grayscale Rules.
        :param Sequence['GetGreyTagRoutesRouteScRuleItemArgs'] items: A list of conditions items.
        :param str path: The path corresponding to the grayscale rule.
        """
        GetGreyTagRoutesRouteScRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            items=items,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             items: Sequence['outputs.GetGreyTagRoutesRouteScRuleItemResult'],
             path: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("condition", condition)
        _setter("items", items)
        _setter("path", path)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        The Conditional Patterns for Grayscale Rules.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetGreyTagRoutesRouteScRuleItemResult']:
        """
        A list of conditions items.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path corresponding to the grayscale rule.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetGreyTagRoutesRouteScRuleItemResult(dict):
    def __init__(__self__, *,
                 cond: str,
                 name: str,
                 operator: str,
                 type: str,
                 value: str):
        """
        :param str cond: The comparison operator.
        :param str name: The name of the parameter.
        :param str operator: The operator.
        :param str type: The Compare types.
        :param str value: The value of the parameter.
        """
        GetGreyTagRoutesRouteScRuleItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cond=cond,
            name=name,
            operator=operator,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cond: str,
             name: str,
             operator: str,
             type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("cond", cond)
        _setter("name", name)
        _setter("operator", operator)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def cond(self) -> str:
        """
        The comparison operator.
        """
        return pulumi.get(self, "cond")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Compare types.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetIngressesIngressResult(dict):
    def __init__(__self__, *,
                 cert_id: str,
                 default_rule: str,
                 description: str,
                 id: str,
                 ingress_id: str,
                 listener_port: int,
                 namespace_id: str,
                 slb_id: str):
        """
        :param str cert_id: Cert Id.
        :param str default_rule: Default Rule.
        :param str description: Description.
        :param str id: The ID of the Ingress.
        :param str ingress_id: The first ID of the resource.
        :param int listener_port: SLB listening port.
        :param str namespace_id: The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        :param str slb_id: SLB ID.
        """
        GetIngressesIngressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert_id=cert_id,
            default_rule=default_rule,
            description=description,
            id=id,
            ingress_id=ingress_id,
            listener_port=listener_port,
            namespace_id=namespace_id,
            slb_id=slb_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert_id: str,
             default_rule: str,
             description: str,
             id: str,
             ingress_id: str,
             listener_port: int,
             namespace_id: str,
             slb_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certId' in kwargs:
            cert_id = kwargs['certId']
        if 'defaultRule' in kwargs:
            default_rule = kwargs['defaultRule']
        if 'ingressId' in kwargs:
            ingress_id = kwargs['ingressId']
        if 'listenerPort' in kwargs:
            listener_port = kwargs['listenerPort']
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'slbId' in kwargs:
            slb_id = kwargs['slbId']

        _setter("cert_id", cert_id)
        _setter("default_rule", default_rule)
        _setter("description", description)
        _setter("id", id)
        _setter("ingress_id", ingress_id)
        _setter("listener_port", listener_port)
        _setter("namespace_id", namespace_id)
        _setter("slb_id", slb_id)

    @property
    @pulumi.getter(name="certId")
    def cert_id(self) -> str:
        """
        Cert Id.
        """
        return pulumi.get(self, "cert_id")

    @property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> str:
        """
        Default Rule.
        """
        return pulumi.get(self, "default_rule")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Ingress.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ingressId")
    def ingress_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "ingress_id")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        """
        SLB listening port.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="slbId")
    def slb_id(self) -> str:
        """
        SLB ID.
        """
        return pulumi.get(self, "slb_id")


@pulumi.output_type
class GetInstanceSpecificationsSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu: int,
                 enable: bool,
                 id: str,
                 instance_specification_id: str,
                 memory: int,
                 spec_info: str,
                 version: int):
        """
        :param int cpu: CPU Size, Specifications for Micronucleus.
        :param bool enable: Whether the instance is available. The value description is as follows:
        :param str id: The ID of the Instance Specification.
        :param str instance_specification_id: The first ID of the resource.
        :param int memory: The Memory specifications for the MB.
        :param str spec_info: The specification configuration name.
        :param int version: The specification configuration version.
        """
        GetInstanceSpecificationsSpecificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            enable=enable,
            id=id,
            instance_specification_id=instance_specification_id,
            memory=memory,
            spec_info=spec_info,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: int,
             enable: bool,
             id: str,
             instance_specification_id: str,
             memory: int,
             spec_info: str,
             version: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'instanceSpecificationId' in kwargs:
            instance_specification_id = kwargs['instanceSpecificationId']
        if 'specInfo' in kwargs:
            spec_info = kwargs['specInfo']

        _setter("cpu", cpu)
        _setter("enable", enable)
        _setter("id", id)
        _setter("instance_specification_id", instance_specification_id)
        _setter("memory", memory)
        _setter("spec_info", spec_info)
        _setter("version", version)

    @property
    @pulumi.getter
    def cpu(self) -> int:
        """
        CPU Size, Specifications for Micronucleus.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Whether the instance is available. The value description is as follows:
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Instance Specification.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceSpecificationId")
    def instance_specification_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "instance_specification_id")

    @property
    @pulumi.getter
    def memory(self) -> int:
        """
        The Memory specifications for the MB.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="specInfo")
    def spec_info(self) -> str:
        """
        The specification configuration name.
        """
        return pulumi.get(self, "spec_info")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        The specification configuration version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 id: str,
                 namespace_description: str,
                 namespace_id: str,
                 namespace_name: str):
        """
        :param str id: The ID of the Namespace.
        :param str namespace_description: The Description of Namespace.
        :param str namespace_id: The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        :param str namespace_name: The Name of Namespace.
        """
        GetNamespacesNamespaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            namespace_description=namespace_description,
            namespace_id=namespace_id,
            namespace_name=namespace_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             namespace_description: str,
             namespace_id: str,
             namespace_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceDescription' in kwargs:
            namespace_description = kwargs['namespaceDescription']
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'namespaceName' in kwargs:
            namespace_name = kwargs['namespaceName']

        _setter("id", id)
        _setter("namespace_description", namespace_description)
        _setter("namespace_id", namespace_id)
        _setter("namespace_name", namespace_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Namespace.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="namespaceDescription")
    def namespace_description(self) -> str:
        """
        The Description of Namespace.
        """
        return pulumi.get(self, "namespace_description")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> str:
        """
        The Name of Namespace.
        """
        return pulumi.get(self, "namespace_name")


