# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationConfigMapMountDescV2',
    'ApplicationCustomHostAliasV2',
    'ApplicationKafkaConfigs',
    'ApplicationKafkaConfigsKafkaConfig',
    'ApplicationLivenessV2',
    'ApplicationLivenessV2Exec',
    'ApplicationLivenessV2HttpGet',
    'ApplicationLivenessV2TcpSocket',
    'ApplicationNasConfig',
    'ApplicationOssMountDescsV2',
    'ApplicationPostStartV2',
    'ApplicationPostStartV2Exec',
    'ApplicationPreStopV2',
    'ApplicationPreStopV2Exec',
    'ApplicationPvtzDiscoverySvc',
    'ApplicationPvtzDiscoverySvcPortProtocol',
    'ApplicationReadinessV2',
    'ApplicationReadinessV2Exec',
    'ApplicationReadinessV2HttpGet',
    'ApplicationReadinessV2TcpSocket',
    'ApplicationScalingRuleScalingRuleMetric',
    'ApplicationScalingRuleScalingRuleMetricMetric',
    'ApplicationScalingRuleScalingRuleMetricScaleDownRules',
    'ApplicationScalingRuleScalingRuleMetricScaleUpRules',
    'ApplicationScalingRuleScalingRuleTimer',
    'ApplicationScalingRuleScalingRuleTimerSchedule',
    'ApplicationTomcatConfigV2',
    'ApplicationUpdateStrategyV2',
    'ApplicationUpdateStrategyV2BatchUpdate',
    'GreyTagRouteDubboRule',
    'GreyTagRouteDubboRuleItem',
    'GreyTagRouteScRule',
    'GreyTagRouteScRuleItem',
    'IngressDefaultRule',
    'IngressRule',
    'LoadBalancerInternetInternet',
    'LoadBalancerIntranetIntranet',
    'GetApplicationScalingRulesRuleResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult',
    'GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult',
    'GetApplicationScalingRulesRuleScalingRuleTimerResult',
    'GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult',
    'GetApplicationsApplicationResult',
    'GetApplicationsApplicationMountDescResult',
    'GetApplicationsApplicationOssMountDetailResult',
    'GetConfigMapsMapResult',
    'GetGreyTagRoutesRouteResult',
    'GetGreyTagRoutesRouteDubboRuleResult',
    'GetGreyTagRoutesRouteDubboRuleItemResult',
    'GetGreyTagRoutesRouteScRuleResult',
    'GetGreyTagRoutesRouteScRuleItemResult',
    'GetIngressesIngressResult',
    'GetInstanceSpecificationsSpecificationResult',
    'GetNamespacesNamespaceResult',
]

@pulumi.output_type
class ApplicationConfigMapMountDescV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapId":
            suggest = "config_map_id"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationConfigMapMountDescV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationConfigMapMountDescV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationConfigMapMountDescV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_id: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 mount_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str config_map_id: The ID of the ConfigMap.
        :param _builtins.str key: The key.
        :param _builtins.str mount_path: The mount path.
        """
        if config_map_id is not None:
            pulumi.set(__self__, "config_map_id", config_map_id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @_builtins.property
    @pulumi.getter(name="configMapId")
    def config_map_id(self) -> Optional[_builtins.str]:
        """
        The ID of the ConfigMap.
        """
        return pulumi.get(self, "config_map_id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[_builtins.str]:
        """
        The mount path.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class ApplicationCustomHostAliasV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationCustomHostAliasV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationCustomHostAliasV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationCustomHostAliasV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_name: The domain name or hostname.
        :param _builtins.str ip: The IP address.
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[_builtins.str]:
        """
        The domain name or hostname.
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ApplicationKafkaConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConfigs":
            suggest = "kafka_configs"
        elif key == "kafkaEndpoint":
            suggest = "kafka_endpoint"
        elif key == "kafkaInstanceId":
            suggest = "kafka_instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationKafkaConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationKafkaConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationKafkaConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_configs: Optional[Sequence['outputs.ApplicationKafkaConfigsKafkaConfig']] = None,
                 kafka_endpoint: Optional[_builtins.str] = None,
                 kafka_instance_id: Optional[_builtins.str] = None):
        """
        :param Sequence['ApplicationKafkaConfigsKafkaConfigArgs'] kafka_configs: One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        :param _builtins.str kafka_endpoint: The endpoint of the ApsaraMQ for Kafka API.
        :param _builtins.str kafka_instance_id: The  ID of the ApsaraMQ for Kafka instance.
        """
        if kafka_configs is not None:
            pulumi.set(__self__, "kafka_configs", kafka_configs)
        if kafka_endpoint is not None:
            pulumi.set(__self__, "kafka_endpoint", kafka_endpoint)
        if kafka_instance_id is not None:
            pulumi.set(__self__, "kafka_instance_id", kafka_instance_id)

    @_builtins.property
    @pulumi.getter(name="kafkaConfigs")
    def kafka_configs(self) -> Optional[Sequence['outputs.ApplicationKafkaConfigsKafkaConfig']]:
        """
        One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        """
        return pulumi.get(self, "kafka_configs")

    @_builtins.property
    @pulumi.getter(name="kafkaEndpoint")
    def kafka_endpoint(self) -> Optional[_builtins.str]:
        """
        The endpoint of the ApsaraMQ for Kafka API.
        """
        return pulumi.get(self, "kafka_endpoint")

    @_builtins.property
    @pulumi.getter(name="kafkaInstanceId")
    def kafka_instance_id(self) -> Optional[_builtins.str]:
        """
        The  ID of the ApsaraMQ for Kafka instance.
        """
        return pulumi.get(self, "kafka_instance_id")


@pulumi.output_type
class ApplicationKafkaConfigsKafkaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaTopic":
            suggest = "kafka_topic"
        elif key == "logDir":
            suggest = "log_dir"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationKafkaConfigsKafkaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationKafkaConfigsKafkaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationKafkaConfigsKafkaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_topic: Optional[_builtins.str] = None,
                 log_dir: Optional[_builtins.str] = None,
                 log_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str kafka_topic: The topic of the Kafka.
        :param _builtins.str log_dir: The path in which logs are stored.
        :param _builtins.str log_type: The type of the log.
        """
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)
        if log_dir is not None:
            pulumi.set(__self__, "log_dir", log_dir)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[_builtins.str]:
        """
        The topic of the Kafka.
        """
        return pulumi.get(self, "kafka_topic")

    @_builtins.property
    @pulumi.getter(name="logDir")
    def log_dir(self) -> Optional[_builtins.str]:
        """
        The path in which logs are stored.
        """
        return pulumi.get(self, "log_dir")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[_builtins.str]:
        """
        The type of the log.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class ApplicationLivenessV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLivenessV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLivenessV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLivenessV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationLivenessV2Exec'] = None,
                 http_get: Optional['outputs.ApplicationLivenessV2HttpGet'] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 tcp_socket: Optional['outputs.ApplicationLivenessV2TcpSocket'] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param 'ApplicationLivenessV2ExecArgs' exec_: Execute. See `exec` below.
        :param 'ApplicationLivenessV2HttpGetArgs' http_get: The liveness check settings of the container. See `http_get` below.
        :param _builtins.int initial_delay_seconds: The delay of the health check.
        :param _builtins.int period_seconds: The interval at which the health check is performed.
        :param 'ApplicationLivenessV2TcpSocketArgs' tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param _builtins.int timeout_seconds: The timeout period of the health check.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationLivenessV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.ApplicationLivenessV2HttpGet']:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.ApplicationLivenessV2TcpSocket']:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class ApplicationLivenessV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationLivenessV2HttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContainKeyWord":
            suggest = "is_contain_key_word"
        elif key == "keyWord":
            suggest = "key_word"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLivenessV2HttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLivenessV2HttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLivenessV2HttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_contain_key_word: Optional[_builtins.bool] = None,
                 key_word: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None):
        if is_contain_key_word is not None:
            pulumi.set(__self__, "is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            pulumi.set(__self__, "key_word", key_word)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_contain_key_word")

    @_builtins.property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_word")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ApplicationLivenessV2TcpSocket(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplicationNasConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountDomain":
            suggest = "mount_domain"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "nasId":
            suggest = "nas_id"
        elif key == "nasPath":
            suggest = "nas_path"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationNasConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationNasConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationNasConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_domain: Optional[_builtins.str] = None,
                 mount_path: Optional[_builtins.str] = None,
                 nas_id: Optional[_builtins.str] = None,
                 nas_path: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None):
        """
        :param _builtins.str mount_domain: The domain name of the mount target.
        :param _builtins.str mount_path: The mount path of the container.
        :param _builtins.str nas_id: The ID of the NAS file system.
        :param _builtins.str nas_path: The directory in the NAS file system.
        :param _builtins.bool read_only: Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        if mount_domain is not None:
            pulumi.set(__self__, "mount_domain", mount_domain)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if nas_id is not None:
            pulumi.set(__self__, "nas_id", nas_id)
        if nas_path is not None:
            pulumi.set(__self__, "nas_path", nas_path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter(name="mountDomain")
    def mount_domain(self) -> Optional[_builtins.str]:
        """
        The domain name of the mount target.
        """
        return pulumi.get(self, "mount_domain")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[_builtins.str]:
        """
        The mount path of the container.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter(name="nasId")
    def nas_id(self) -> Optional[_builtins.str]:
        """
        The ID of the NAS file system.
        """
        return pulumi.get(self, "nas_id")

    @_builtins.property
    @pulumi.getter(name="nasPath")
    def nas_path(self) -> Optional[_builtins.str]:
        """
        The directory in the NAS file system.
        """
        return pulumi.get(self, "nas_path")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class ApplicationOssMountDescsV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPath":
            suggest = "bucket_path"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationOssMountDescsV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationOssMountDescsV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationOssMountDescsV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 bucket_path: Optional[_builtins.str] = None,
                 mount_path: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket_name: The name of the OSS bucket.
        :param _builtins.str bucket_path: The directory or object in OSS.
        :param _builtins.str mount_path: The path of the container in SAE.
        :param _builtins.bool read_only: Specifies whether the application can use the container path to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_path is not None:
            pulumi.set(__self__, "bucket_path", bucket_path)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        The name of the OSS bucket.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[_builtins.str]:
        """
        The directory or object in OSS.
        """
        return pulumi.get(self, "bucket_path")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[_builtins.str]:
        """
        The path of the container in SAE.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the application can use the container path to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class ApplicationPostStartV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPostStartV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPostStartV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPostStartV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationPostStartV2Exec'] = None):
        """
        :param 'ApplicationPostStartV2ExecArgs' exec_: Execute. See `exec` below.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationPostStartV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")


@pulumi.output_type
class ApplicationPostStartV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationPreStopV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPreStopV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPreStopV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPreStopV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationPreStopV2Exec'] = None):
        """
        :param 'ApplicationPreStopV2ExecArgs' exec_: Execute. See `exec` below.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationPreStopV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")


@pulumi.output_type
class ApplicationPreStopV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationPvtzDiscoverySvc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "portProtocols":
            suggest = "port_protocols"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPvtzDiscoverySvc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPvtzDiscoverySvc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPvtzDiscoverySvc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 namespace_id: Optional[_builtins.str] = None,
                 port_protocols: Optional[Sequence['outputs.ApplicationPvtzDiscoverySvcPortProtocol']] = None,
                 service_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable: Enables the Kubernetes Service-based registration and discovery feature.
        :param _builtins.str namespace_id: The ID of the namespace.
        :param Sequence['ApplicationPvtzDiscoverySvcPortProtocolArgs'] port_protocols: The port number and protocol. See `port_protocols` below.
        :param _builtins.str service_name: The name of the Service.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if port_protocols is not None:
            pulumi.set(__self__, "port_protocols", port_protocols)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Enables the Kubernetes Service-based registration and discovery feature.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[_builtins.str]:
        """
        The ID of the namespace.
        """
        return pulumi.get(self, "namespace_id")

    @_builtins.property
    @pulumi.getter(name="portProtocols")
    def port_protocols(self) -> Optional[Sequence['outputs.ApplicationPvtzDiscoverySvcPortProtocol']]:
        """
        The port number and protocol. See `port_protocols` below.
        """
        return pulumi.get(self, "port_protocols")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        The name of the Service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class ApplicationPvtzDiscoverySvcPortProtocol(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str protocol: The protocol. Valid values: `TCP` and `UDP`.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The protocol. Valid values: `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ApplicationReadinessV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationReadinessV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationReadinessV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationReadinessV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.ApplicationReadinessV2Exec'] = None,
                 http_get: Optional['outputs.ApplicationReadinessV2HttpGet'] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 tcp_socket: Optional['outputs.ApplicationReadinessV2TcpSocket'] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param 'ApplicationReadinessV2ExecArgs' exec_: Execute. See `exec` below.
        :param 'ApplicationReadinessV2HttpGetArgs' http_get: The liveness check settings of the container. See `http_get` below.
        :param _builtins.int initial_delay_seconds: The delay of the health check.
        :param _builtins.int period_seconds: The interval at which the health check is performed.
        :param 'ApplicationReadinessV2TcpSocketArgs' tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param _builtins.int timeout_seconds: The timeout period of the health check.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.ApplicationReadinessV2Exec']:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.ApplicationReadinessV2HttpGet']:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.ApplicationReadinessV2TcpSocket']:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class ApplicationReadinessV2Exec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class ApplicationReadinessV2HttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContainKeyWord":
            suggest = "is_contain_key_word"
        elif key == "keyWord":
            suggest = "key_word"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationReadinessV2HttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationReadinessV2HttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationReadinessV2HttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_contain_key_word: Optional[_builtins.bool] = None,
                 key_word: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None):
        if is_contain_key_word is not None:
            pulumi.set(__self__, "is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            pulumi.set(__self__, "key_word", key_word)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_contain_key_word")

    @_builtins.property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_word")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ApplicationReadinessV2TcpSocket(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "scaleDownRules":
            suggest = "scale_down_rules"
        elif key == "scaleUpRules":
            suggest = "scale_up_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: Optional[_builtins.int] = None,
                 metrics: Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleMetricMetric']] = None,
                 min_replicas: Optional[_builtins.int] = None,
                 scale_down_rules: Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleDownRules'] = None,
                 scale_up_rules: Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleUpRules'] = None):
        """
        :param _builtins.int max_replicas: Maximum number of instances applied.
        :param Sequence['ApplicationScalingRuleScalingRuleMetricMetricArgs'] metrics: Indicator rule configuration. See `metrics` below.
        :param _builtins.int min_replicas: Minimum number of instances applied.
        :param 'ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs' scale_down_rules: Apply shrink rules. See `scale_down_rules` below.
        :param 'ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs' scale_up_rules: Apply expansion rules. See `scale_up_rules` below.
        """
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if scale_down_rules is not None:
            pulumi.set(__self__, "scale_down_rules", scale_down_rules)
        if scale_up_rules is not None:
            pulumi.set(__self__, "scale_up_rules", scale_up_rules)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[_builtins.int]:
        """
        Maximum number of instances applied.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleMetricMetric']]:
        """
        Indicator rule configuration. See `metrics` below.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[_builtins.int]:
        """
        Minimum number of instances applied.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="scaleDownRules")
    def scale_down_rules(self) -> Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleDownRules']:
        """
        Apply shrink rules. See `scale_down_rules` below.
        """
        return pulumi.get(self, "scale_down_rules")

    @_builtins.property
    @pulumi.getter(name="scaleUpRules")
    def scale_up_rules(self) -> Optional['outputs.ApplicationScalingRuleScalingRuleMetricScaleUpRules']:
        """
        Apply expansion rules. See `scale_up_rules` below.
        """
        return pulumi.get(self, "scale_up_rules")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetricMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricTargetAverageUtilization":
            suggest = "metric_target_average_utilization"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "slbId":
            suggest = "slb_id"
        elif key == "slbLogStore":
            suggest = "slb_log_store"
        elif key == "slbProject":
            suggest = "slb_project"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetricMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetricMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetricMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_target_average_utilization: Optional[_builtins.int] = None,
                 metric_type: Optional[_builtins.str] = None,
                 slb_id: Optional[_builtins.str] = None,
                 slb_log_store: Optional[_builtins.str] = None,
                 slb_project: Optional[_builtins.str] = None,
                 vport: Optional[_builtins.str] = None):
        """
        :param _builtins.int metric_target_average_utilization: According to different `metric_type`, set the target value of the corresponding monitoring index.
        :param _builtins.str metric_type: Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
               - CPU: CPU usage.
               - MEMORY: MEMORY usage.
               - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
               - QPS: The average QPS of a single instance within 1 minute of JAVA application.
               - RT: The average response time of all service interfaces within 1 minute of JAVA application.
               - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
               - SLB_RT: The average response time of public network SLB within 15 seconds.
               - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
               - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
               **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        :param _builtins.str slb_id: SLB ID.
        :param _builtins.str slb_log_store: The log store of the Log Service.
        :param _builtins.str slb_project: The project of the Log Service.
        :param _builtins.str vport: SLB listening port.
        """
        if metric_target_average_utilization is not None:
            pulumi.set(__self__, "metric_target_average_utilization", metric_target_average_utilization)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if slb_id is not None:
            pulumi.set(__self__, "slb_id", slb_id)
        if slb_log_store is not None:
            pulumi.set(__self__, "slb_log_store", slb_log_store)
        if slb_project is not None:
            pulumi.set(__self__, "slb_project", slb_project)
        if vport is not None:
            pulumi.set(__self__, "vport", vport)

    @_builtins.property
    @pulumi.getter(name="metricTargetAverageUtilization")
    def metric_target_average_utilization(self) -> Optional[_builtins.int]:
        """
        According to different `metric_type`, set the target value of the corresponding monitoring index.
        """
        return pulumi.get(self, "metric_target_average_utilization")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[_builtins.str]:
        """
        Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
        - CPU: CPU usage.
        - MEMORY: MEMORY usage.
        - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
        - QPS: The average QPS of a single instance within 1 minute of JAVA application.
        - RT: The average response time of all service interfaces within 1 minute of JAVA application.
        - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
        - SLB_RT: The average response time of public network SLB within 15 seconds.
        - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
        - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
        **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="slbId")
    def slb_id(self) -> Optional[_builtins.str]:
        """
        SLB ID.
        """
        return pulumi.get(self, "slb_id")

    @_builtins.property
    @pulumi.getter(name="slbLogStore")
    def slb_log_store(self) -> Optional[_builtins.str]:
        """
        The log store of the Log Service.
        """
        return pulumi.get(self, "slb_log_store")

    @_builtins.property
    @pulumi.getter(name="slbProject")
    def slb_project(self) -> Optional[_builtins.str]:
        """
        The project of the Log Service.
        """
        return pulumi.get(self, "slb_project")

    @_builtins.property
    @pulumi.getter
    def vport(self) -> Optional[_builtins.str]:
        """
        SLB listening port.
        """
        return pulumi.get(self, "vport")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetricScaleDownRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stabilizationWindowSeconds":
            suggest = "stabilization_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetricScaleDownRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleDownRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleDownRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 stabilization_window_seconds: Optional[_builtins.int] = None,
                 step: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disabled: Whether shrinkage is prohibited.
        :param _builtins.int stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param _builtins.int step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[_builtins.int]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[_builtins.int]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleMetricScaleUpRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stabilizationWindowSeconds":
            suggest = "stabilization_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleMetricScaleUpRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleUpRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleMetricScaleUpRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 stabilization_window_seconds: Optional[_builtins.int] = None,
                 step: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disabled: Whether shrinkage is prohibited.
        :param _builtins.int stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param _builtins.int step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[_builtins.int]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[_builtins.int]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginDate":
            suggest = "begin_date"
        elif key == "endDate":
            suggest = "end_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_date: Optional[_builtins.str] = None,
                 end_date: Optional[_builtins.str] = None,
                 period: Optional[_builtins.str] = None,
                 schedules: Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleTimerSchedule']] = None):
        """
        :param _builtins.str begin_date: The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param _builtins.str end_date: The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param _builtins.str period: The period in which a timed elastic scaling strategy is executed.
        :param Sequence['ApplicationScalingRuleScalingRuleTimerScheduleArgs'] schedules: Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        if begin_date is not None:
            pulumi.set(__self__, "begin_date", begin_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter(name="beginDate")
    def begin_date(self) -> Optional[_builtins.str]:
        """
        The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "begin_date")

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[_builtins.str]:
        """
        The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "end_date")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.str]:
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Optional[Sequence['outputs.ApplicationScalingRuleScalingRuleTimerSchedule']]:
        """
        Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        return pulumi.get(self, "schedules")


@pulumi.output_type
class ApplicationScalingRuleScalingRuleTimerSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atTime":
            suggest = "at_time"
        elif key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "targetReplicas":
            suggest = "target_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationScalingRuleScalingRuleTimerSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationScalingRuleScalingRuleTimerSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationScalingRuleScalingRuleTimerSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 at_time: Optional[_builtins.str] = None,
                 max_replicas: Optional[_builtins.int] = None,
                 min_replicas: Optional[_builtins.int] = None,
                 target_replicas: Optional[_builtins.int] = None):
        """
        :param _builtins.str at_time: Trigger point in time. When supporting format: minutes, for example: `08:00`.
        :param _builtins.int target_replicas: This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        if at_time is not None:
            pulumi.set(__self__, "at_time", at_time)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if target_replicas is not None:
            pulumi.set(__self__, "target_replicas", target_replicas)

    @_builtins.property
    @pulumi.getter(name="atTime")
    def at_time(self) -> Optional[_builtins.str]:
        """
        Trigger point in time. When supporting format: minutes, for example: `08:00`.
        """
        return pulumi.get(self, "at_time")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> Optional[_builtins.int]:
        """
        This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        return pulumi.get(self, "target_replicas")


@pulumi.output_type
class ApplicationTomcatConfigV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextPath":
            suggest = "context_path"
        elif key == "maxThreads":
            suggest = "max_threads"
        elif key == "uriEncoding":
            suggest = "uri_encoding"
        elif key == "useBodyEncodingForUri":
            suggest = "use_body_encoding_for_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationTomcatConfigV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationTomcatConfigV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationTomcatConfigV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_path: Optional[_builtins.str] = None,
                 max_threads: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 uri_encoding: Optional[_builtins.str] = None,
                 use_body_encoding_for_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str context_path: The path.
        :param _builtins.int max_threads: The maximum number of connections in the connection pool.
        :param _builtins.int port: The port.
        :param _builtins.str uri_encoding: The URI encoding scheme in the Tomcat container.
        :param _builtins.str use_body_encoding_for_uri: Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if uri_encoding is not None:
            pulumi.set(__self__, "uri_encoding", uri_encoding)
        if use_body_encoding_for_uri is not None:
            pulumi.set(__self__, "use_body_encoding_for_uri", use_body_encoding_for_uri)

    @_builtins.property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[_builtins.str]:
        """
        The path.
        """
        return pulumi.get(self, "context_path")

    @_builtins.property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[_builtins.int]:
        """
        The maximum number of connections in the connection pool.
        """
        return pulumi.get(self, "max_threads")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="uriEncoding")
    def uri_encoding(self) -> Optional[_builtins.str]:
        """
        The URI encoding scheme in the Tomcat container.
        """
        return pulumi.get(self, "uri_encoding")

    @_builtins.property
    @pulumi.getter(name="useBodyEncodingForUri")
    def use_body_encoding_for_uri(self) -> Optional[_builtins.str]:
        """
        Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        return pulumi.get(self, "use_body_encoding_for_uri")


@pulumi.output_type
class ApplicationUpdateStrategyV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchUpdate":
            suggest = "batch_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationUpdateStrategyV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationUpdateStrategyV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationUpdateStrategyV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_update: Optional['outputs.ApplicationUpdateStrategyV2BatchUpdate'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'ApplicationUpdateStrategyV2BatchUpdateArgs' batch_update: The phased release policy. See `batch_update` below.
        :param _builtins.str type: The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        if batch_update is not None:
            pulumi.set(__self__, "batch_update", batch_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="batchUpdate")
    def batch_update(self) -> Optional['outputs.ApplicationUpdateStrategyV2BatchUpdate']:
        """
        The phased release policy. See `batch_update` below.
        """
        return pulumi.get(self, "batch_update")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplicationUpdateStrategyV2BatchUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchWaitTime":
            suggest = "batch_wait_time"
        elif key == "releaseType":
            suggest = "release_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationUpdateStrategyV2BatchUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationUpdateStrategyV2BatchUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationUpdateStrategyV2BatchUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional[_builtins.int] = None,
                 batch_wait_time: Optional[_builtins.int] = None,
                 release_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int batch: The number of batches in which you want to release the instances.
        :param _builtins.int batch_wait_time: The batch wait time.
        :param _builtins.str release_type: The processing method for the batches. Valid values: `auto` and `manual`.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if batch_wait_time is not None:
            pulumi.set(__self__, "batch_wait_time", batch_wait_time)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)

    @_builtins.property
    @pulumi.getter
    def batch(self) -> Optional[_builtins.int]:
        """
        The number of batches in which you want to release the instances.
        """
        return pulumi.get(self, "batch")

    @_builtins.property
    @pulumi.getter(name="batchWaitTime")
    def batch_wait_time(self) -> Optional[_builtins.int]:
        """
        The batch wait time.
        """
        return pulumi.get(self, "batch_wait_time")

    @_builtins.property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[_builtins.str]:
        """
        The processing method for the batches. Valid values: `auto` and `manual`.
        """
        return pulumi.get(self, "release_type")


@pulumi.output_type
class GreyTagRouteDubboRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodName":
            suggest = "method_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GreyTagRouteDubboRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GreyTagRouteDubboRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GreyTagRouteDubboRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 items: Optional[Sequence['outputs.GreyTagRouteDubboRuleItem']] = None,
                 method_name: Optional[_builtins.str] = None,
                 service_name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str condition: The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param _builtins.str group: The service group.
        :param Sequence['GreyTagRouteDubboRuleItemArgs'] items: A list of conditions items. See `items` below.
        :param _builtins.str method_name: The method name
        :param _builtins.str service_name: The service name.
        :param _builtins.str version: The service version.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if method_name is not None:
            pulumi.set(__self__, "method_name", method_name)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        The service group.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GreyTagRouteDubboRuleItem']]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="methodName")
    def method_name(self) -> Optional[_builtins.str]:
        """
        The method name
        """
        return pulumi.get(self, "method_name")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        The service name.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The service version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GreyTagRouteDubboRuleItem(dict):
    def __init__(__self__, *,
                 cond: Optional[_builtins.str] = None,
                 expr: Optional[_builtins.str] = None,
                 index: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str expr: The parameter value gets the expression.
        :param _builtins.int index: The parameter number.
        """
        if cond is not None:
            pulumi.set(__self__, "cond", cond)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def cond(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cond")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> Optional[_builtins.str]:
        """
        The parameter value gets the expression.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        """
        The parameter number.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GreyTagRouteScRule(dict):
    def __init__(__self__, *,
                 condition: Optional[_builtins.str] = None,
                 items: Optional[Sequence['outputs.GreyTagRouteScRuleItem']] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str condition: The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param Sequence['GreyTagRouteScRuleItemArgs'] items: A list of conditions items. See `items` below.
        :param _builtins.str path: The path corresponding to the grayscale rule.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GreyTagRouteScRuleItem']]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path corresponding to the grayscale rule.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GreyTagRouteScRuleItem(dict):
    def __init__(__self__, *,
                 cond: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the parameter.
        :param _builtins.str type: The compare types. Valid values: `param`, `cookie`, `header`.
        """
        if cond is not None:
            pulumi.set(__self__, "cond", cond)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def cond(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cond")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The compare types. Valid values: `param`, `cookie`, `header`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class IngressDefaultRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"
        elif key == "containerPort":
            suggest = "container_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressDefaultRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressDefaultRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressDefaultRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 app_name: Optional[_builtins.str] = None,
                 container_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str app_id: Target application ID.
        :param _builtins.str app_name: Target application name.
        :param _builtins.int container_port: Application backend port.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[_builtins.str]:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[_builtins.int]:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")


@pulumi.output_type
class IngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"
        elif key == "containerPort":
            suggest = "container_port"
        elif key == "backendProtocol":
            suggest = "backend_protocol"
        elif key == "rewritePath":
            suggest = "rewrite_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: _builtins.str,
                 app_name: _builtins.str,
                 container_port: _builtins.int,
                 domain: _builtins.str,
                 path: _builtins.str,
                 backend_protocol: Optional[_builtins.str] = None,
                 rewrite_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: Target application ID.
        :param _builtins.str app_name: Target application name.
        :param _builtins.int container_port: Application backend port.
        :param _builtins.str domain: Application domain name.
        :param _builtins.str path: URL path.
        :param _builtins.str backend_protocol: The backend protocol.
        :param _builtins.str rewrite_path: The rewrite path.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "container_port", container_port)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "path", path)
        if backend_protocol is not None:
            pulumi.set(__self__, "backend_protocol", backend_protocol)
        if rewrite_path is not None:
            pulumi.set(__self__, "rewrite_path", rewrite_path)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> _builtins.int:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Application domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        URL path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[_builtins.str]:
        """
        The backend protocol.
        """
        return pulumi.get(self, "backend_protocol")

    @_builtins.property
    @pulumi.getter(name="rewritePath")
    def rewrite_path(self) -> Optional[_builtins.str]:
        """
        The rewrite path.
        """
        return pulumi.get(self, "rewrite_path")


@pulumi.output_type
class LoadBalancerInternetInternet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCertId":
            suggest = "https_cert_id"
        elif key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerInternetInternet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerInternetInternet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerInternetInternet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_cert_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 target_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param _builtins.int port: The SLB Port.
        :param _builtins.str protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param _builtins.int target_port: The Container port.
        """
        if https_cert_id is not None:
            pulumi.set(__self__, "https_cert_id", https_cert_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[_builtins.str]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class LoadBalancerIntranetIntranet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCertId":
            suggest = "https_cert_id"
        elif key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerIntranetIntranet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerIntranetIntranet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerIntranetIntranet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_cert_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 target_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param _builtins.int port: The SLB Port.
        :param _builtins.str protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param _builtins.int target_port: The Container port.
        """
        if https_cert_id is not None:
            pulumi.set(__self__, "https_cert_id", https_cert_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[_builtins.str]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetApplicationScalingRulesRuleResult(dict):
    def __init__(__self__, *,
                 app_id: _builtins.str,
                 create_time: _builtins.str,
                 id: _builtins.str,
                 scaling_rule_enable: _builtins.bool,
                 scaling_rule_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricResult'],
                 scaling_rule_name: _builtins.str,
                 scaling_rule_timers: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerResult'],
                 scaling_rule_type: _builtins.str):
        """
        :param _builtins.str app_id: The ID of the Application.
        :param _builtins.str create_time: The CreateTime of the Application Scaling Rule.
        :param _builtins.str id: The ID of the Application Scaling Rule.
        :param _builtins.bool scaling_rule_enable: Whether to enable the auto scaling policy.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricArgs'] scaling_rule_metrics: Monitoring indicators for elastic scaling.
        :param _builtins.str scaling_rule_name: The name of the scaling rule.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleTimerArgs'] scaling_rule_timers: Timing elastic expansion.
        :param _builtins.str scaling_rule_type: Flexible strategy type.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "scaling_rule_enable", scaling_rule_enable)
        pulumi.set(__self__, "scaling_rule_metrics", scaling_rule_metrics)
        pulumi.set(__self__, "scaling_rule_name", scaling_rule_name)
        pulumi.set(__self__, "scaling_rule_timers", scaling_rule_timers)
        pulumi.set(__self__, "scaling_rule_type", scaling_rule_type)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        The ID of the Application.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The CreateTime of the Application Scaling Rule.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Application Scaling Rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="scalingRuleEnable")
    def scaling_rule_enable(self) -> _builtins.bool:
        """
        Whether to enable the auto scaling policy.
        """
        return pulumi.get(self, "scaling_rule_enable")

    @_builtins.property
    @pulumi.getter(name="scalingRuleMetrics")
    def scaling_rule_metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricResult']:
        """
        Monitoring indicators for elastic scaling.
        """
        return pulumi.get(self, "scaling_rule_metrics")

    @_builtins.property
    @pulumi.getter(name="scalingRuleName")
    def scaling_rule_name(self) -> _builtins.str:
        """
        The name of the scaling rule.
        """
        return pulumi.get(self, "scaling_rule_name")

    @_builtins.property
    @pulumi.getter(name="scalingRuleTimers")
    def scaling_rule_timers(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerResult']:
        """
        Timing elastic expansion.
        """
        return pulumi.get(self, "scaling_rule_timers")

    @_builtins.property
    @pulumi.getter(name="scalingRuleType")
    def scaling_rule_type(self) -> _builtins.str:
        """
        Flexible strategy type.
        """
        return pulumi.get(self, "scaling_rule_type")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricResult(dict):
    def __init__(__self__, *,
                 max_replicas: _builtins.int,
                 metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricResult'],
                 metrics_statuses: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult'],
                 min_replicas: _builtins.int,
                 scale_down_rules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult'],
                 scale_up_rules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult']):
        """
        :param _builtins.int max_replicas: The maximum number of instances.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricArgs'] metrics: The auto scaling list of monitoring indicators.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusArgs'] metrics_statuses: Monitor indicator elasticity status.
        :param _builtins.int min_replicas: The minimum number of instances.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleArgs'] scale_down_rules: The shrink rule.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleArgs'] scale_up_rules: The expansion rules.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "metrics_statuses", metrics_statuses)
        pulumi.set(__self__, "min_replicas", min_replicas)
        pulumi.set(__self__, "scale_down_rules", scale_down_rules)
        pulumi.set(__self__, "scale_up_rules", scale_up_rules)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        The maximum number of instances.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricResult']:
        """
        The auto scaling list of monitoring indicators.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="metricsStatuses")
    def metrics_statuses(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult']:
        """
        Monitor indicator elasticity status.
        """
        return pulumi.get(self, "metrics_statuses")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        The minimum number of instances.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="scaleDownRules")
    def scale_down_rules(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult']:
        """
        The shrink rule.
        """
        return pulumi.get(self, "scale_down_rules")

    @_builtins.property
    @pulumi.getter(name="scaleUpRules")
    def scale_up_rules(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult']:
        """
        The expansion rules.
        """
        return pulumi.get(self, "scale_up_rules")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricResult(dict):
    def __init__(__self__, *,
                 metric_target_average_utilization: _builtins.int,
                 metric_type: _builtins.str):
        """
        :param _builtins.int metric_target_average_utilization: The target value of the monitoring indicator.
        :param _builtins.str metric_type: The metric type of the Application Scaling Rule.
        """
        pulumi.set(__self__, "metric_target_average_utilization", metric_target_average_utilization)
        pulumi.set(__self__, "metric_type", metric_type)

    @_builtins.property
    @pulumi.getter(name="metricTargetAverageUtilization")
    def metric_target_average_utilization(self) -> _builtins.int:
        """
        The target value of the monitoring indicator.
        """
        return pulumi.get(self, "metric_target_average_utilization")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        The metric type of the Application Scaling Rule.
        """
        return pulumi.get(self, "metric_type")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusResult(dict):
    def __init__(__self__, *,
                 current_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult'],
                 current_replicas: _builtins.int,
                 desired_replicas: _builtins.int,
                 last_scale_time: _builtins.str,
                 max_replicas: _builtins.int,
                 min_replicas: _builtins.int,
                 next_scale_metrics: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult'],
                 next_scale_time_period: _builtins.int):
        """
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricArgs'] current_metrics: The current monitoring indicator elasticity list.
        :param _builtins.int current_replicas: The number of current instances.
        :param _builtins.int desired_replicas: The number of target instances.
        :param _builtins.str last_scale_time: The time of the last elastic expansion.
        :param _builtins.int max_replicas: The maximum number of instances.
        :param _builtins.int min_replicas: The minimum number of instances.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricArgs'] next_scale_metrics: Next monitoring indicator elasticity list
        :param _builtins.int next_scale_time_period: The next cycle of monitoring indicator elasticity.
        """
        pulumi.set(__self__, "current_metrics", current_metrics)
        pulumi.set(__self__, "current_replicas", current_replicas)
        pulumi.set(__self__, "desired_replicas", desired_replicas)
        pulumi.set(__self__, "last_scale_time", last_scale_time)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        pulumi.set(__self__, "next_scale_metrics", next_scale_metrics)
        pulumi.set(__self__, "next_scale_time_period", next_scale_time_period)

    @_builtins.property
    @pulumi.getter(name="currentMetrics")
    def current_metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult']:
        """
        The current monitoring indicator elasticity list.
        """
        return pulumi.get(self, "current_metrics")

    @_builtins.property
    @pulumi.getter(name="currentReplicas")
    def current_replicas(self) -> _builtins.int:
        """
        The number of current instances.
        """
        return pulumi.get(self, "current_replicas")

    @_builtins.property
    @pulumi.getter(name="desiredReplicas")
    def desired_replicas(self) -> _builtins.int:
        """
        The number of target instances.
        """
        return pulumi.get(self, "desired_replicas")

    @_builtins.property
    @pulumi.getter(name="lastScaleTime")
    def last_scale_time(self) -> _builtins.str:
        """
        The time of the last elastic expansion.
        """
        return pulumi.get(self, "last_scale_time")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        The maximum number of instances.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        The minimum number of instances.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="nextScaleMetrics")
    def next_scale_metrics(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult']:
        """
        Next monitoring indicator elasticity list
        """
        return pulumi.get(self, "next_scale_metrics")

    @_builtins.property
    @pulumi.getter(name="nextScaleTimePeriod")
    def next_scale_time_period(self) -> _builtins.int:
        """
        The next cycle of monitoring indicator elasticity.
        """
        return pulumi.get(self, "next_scale_time_period")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetricResult(dict):
    def __init__(__self__, *,
                 current_value: _builtins.int,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int current_value: The current value.
        :param _builtins.str name: The name of the trigger condition.
        :param _builtins.str type: The metric type. Associated with monitoring indicators.
        """
        pulumi.set(__self__, "current_value", current_value)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> _builtins.int:
        """
        The current value.
        """
        return pulumi.get(self, "current_value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the trigger condition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The metric type. Associated with monitoring indicators.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetricResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 next_scale_in_average_utilization: _builtins.int,
                 next_scale_out_average_utilization: _builtins.int):
        """
        :param _builtins.str name: The name of the trigger condition.
        :param _builtins.int next_scale_in_average_utilization: The percentage value of the monitoring indicator elasticity that triggers the shrinkage condition next time.
        :param _builtins.int next_scale_out_average_utilization: The percentage value of the monitoring indicator elasticity that triggers the expansion condition next time.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_scale_in_average_utilization", next_scale_in_average_utilization)
        pulumi.set(__self__, "next_scale_out_average_utilization", next_scale_out_average_utilization)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the trigger condition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nextScaleInAverageUtilization")
    def next_scale_in_average_utilization(self) -> _builtins.int:
        """
        The percentage value of the monitoring indicator elasticity that triggers the shrinkage condition next time.
        """
        return pulumi.get(self, "next_scale_in_average_utilization")

    @_builtins.property
    @pulumi.getter(name="nextScaleOutAverageUtilization")
    def next_scale_out_average_utilization(self) -> _builtins.int:
        """
        The percentage value of the monitoring indicator elasticity that triggers the expansion condition next time.
        """
        return pulumi.get(self, "next_scale_out_average_utilization")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricScaleDownRuleResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 stabilization_window_seconds: _builtins.int,
                 step: _builtins.int):
        """
        :param _builtins.bool disabled: Whether shrinkage is prohibited.
        :param _builtins.int stabilization_window_seconds: Shrinkage cooling time.
        :param _builtins.int step: Elastic shrinkage step. The maximum number of instances per unit time.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)
        pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> _builtins.int:
        """
        Shrinkage cooling time.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        Elastic shrinkage step. The maximum number of instances per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleMetricScaleUpRuleResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 stabilization_window_seconds: _builtins.int,
                 step: _builtins.int):
        """
        :param _builtins.bool disabled: Whether shrinkage is prohibited. The values are described as follows:
        :param _builtins.int stabilization_window_seconds: Expansion cooling time.
        :param _builtins.int step: Flexible expansion step. The maximum number of instances per unit time.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)
        pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Whether shrinkage is prohibited. The values are described as follows:
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> _builtins.int:
        """
        Expansion cooling time.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        Flexible expansion step. The maximum number of instances per unit time.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleTimerResult(dict):
    def __init__(__self__, *,
                 begin_date: _builtins.str,
                 end_date: _builtins.str,
                 period: _builtins.str,
                 schedules: Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult']):
        """
        :param _builtins.str begin_date: The short-term start date of the timed elastic scaling strategy.
        :param _builtins.str end_date: The short-term end date of the timed elastic scaling strategy.
        :param _builtins.str period: The period in which a timed elastic scaling strategy is executed.
        :param Sequence['GetApplicationScalingRulesRuleScalingRuleTimerScheduleArgs'] schedules: Trigger point in time within a single day.
        """
        pulumi.set(__self__, "begin_date", begin_date)
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "schedules", schedules)

    @_builtins.property
    @pulumi.getter(name="beginDate")
    def begin_date(self) -> _builtins.str:
        """
        The short-term start date of the timed elastic scaling strategy.
        """
        return pulumi.get(self, "begin_date")

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> _builtins.str:
        """
        The short-term end date of the timed elastic scaling strategy.
        """
        return pulumi.get(self, "end_date")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.str:
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult']:
        """
        Trigger point in time within a single day.
        """
        return pulumi.get(self, "schedules")


@pulumi.output_type
class GetApplicationScalingRulesRuleScalingRuleTimerScheduleResult(dict):
    def __init__(__self__, *,
                 at_time: _builtins.str,
                 max_replicas: _builtins.int,
                 min_replicas: _builtins.int,
                 target_replicas: _builtins.int):
        """
        :param _builtins.str at_time: Time point. Format: `hours:minutes`.
        :param _builtins.int max_replicas: The maximum number of instances.
        :param _builtins.int min_replicas: The minimum number of instances.
        :param _builtins.int target_replicas: The number of target instances.
        """
        pulumi.set(__self__, "at_time", at_time)
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)
        pulumi.set(__self__, "target_replicas", target_replicas)

    @_builtins.property
    @pulumi.getter(name="atTime")
    def at_time(self) -> _builtins.str:
        """
        Time point. Format: `hours:minutes`.
        """
        return pulumi.get(self, "at_time")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> _builtins.int:
        """
        The maximum number of instances.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> _builtins.int:
        """
        The minimum number of instances.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> _builtins.int:
        """
        The number of target instances.
        """
        return pulumi.get(self, "target_replicas")


@pulumi.output_type
class GetApplicationsApplicationResult(dict):
    def __init__(__self__, *,
                 acr_assume_role_arn: _builtins.str,
                 acr_instance_id: _builtins.str,
                 app_description: _builtins.str,
                 app_name: _builtins.str,
                 application_id: _builtins.str,
                 command: _builtins.str,
                 command_args: _builtins.str,
                 config_map_mount_desc: _builtins.str,
                 cpu: _builtins.int,
                 create_time: _builtins.str,
                 custom_host_alias: _builtins.str,
                 edas_container_version: _builtins.str,
                 envs: _builtins.str,
                 id: _builtins.str,
                 image_url: _builtins.str,
                 jar_start_args: _builtins.str,
                 jar_start_options: _builtins.str,
                 jdk: _builtins.str,
                 liveness: _builtins.str,
                 memory: _builtins.int,
                 min_ready_instances: _builtins.int,
                 mount_descs: Sequence['outputs.GetApplicationsApplicationMountDescResult'],
                 mount_host: _builtins.str,
                 namespace_id: _builtins.str,
                 nas_id: _builtins.str,
                 oss_ak_id: _builtins.str,
                 oss_ak_secret: _builtins.str,
                 oss_mount_descs: _builtins.str,
                 oss_mount_details: Sequence['outputs.GetApplicationsApplicationOssMountDetailResult'],
                 package_type: _builtins.str,
                 package_url: _builtins.str,
                 package_version: _builtins.str,
                 php_arms_config_location: _builtins.str,
                 php_config: _builtins.str,
                 php_config_location: _builtins.str,
                 post_start: _builtins.str,
                 pre_stop: _builtins.str,
                 readiness: _builtins.str,
                 region_id: _builtins.str,
                 replicas: _builtins.int,
                 repo_name: _builtins.str,
                 repo_namespace: _builtins.str,
                 repo_origin_type: _builtins.str,
                 security_group_id: _builtins.str,
                 sls_configs: _builtins.str,
                 status: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 termination_grace_period_seconds: _builtins.int,
                 timezone: _builtins.str,
                 tomcat_config: _builtins.str,
                 vpc_id: _builtins.str,
                 vswitch_id: _builtins.str,
                 war_start_options: _builtins.str,
                 web_container: _builtins.str):
        """
        :param _builtins.str acr_assume_role_arn: The ARN of the RAM role required when pulling images across accounts.
        :param _builtins.str acr_instance_id: The ID of the ACR EE instance.
        :param _builtins.str app_description: Application description information. No more than 1024 characters.
        :param _builtins.str app_name: Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
        :param _builtins.str application_id: The first ID of the resource.
        :param _builtins.str command: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        :param _builtins.str command_args: Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
        :param _builtins.str config_map_mount_desc: ConfigMap mount description.
        :param _builtins.int cpu: The CPU required for each instance, in millicores, cannot be 0.
        :param _builtins.str create_time: Indicates That the Application of the Creation Time.
        :param _builtins.str custom_host_alias: Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
        :param _builtins.str edas_container_version: The operating environment used by the Pandora application.
        :param _builtins.str envs: The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
        :param _builtins.str id: The ID of the Application.
        :param _builtins.str image_url: Mirror address. Only Image type applications can configure the mirror address.
        :param _builtins.str jar_start_args: The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        :param _builtins.str jar_start_options: The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        :param _builtins.str jdk: The JDK version that the deployment package depends on. Image type applications are not supported.
        :param _builtins.str liveness: Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
        :param _builtins.int memory: The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
        :param _builtins.int min_ready_instances: The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
        :param Sequence['GetApplicationsApplicationMountDescArgs'] mount_descs: Mount description information.
        :param _builtins.str mount_host: Mount point of NAS in application VPC.
        :param _builtins.str namespace_id: SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
        :param _builtins.str nas_id: ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
        :param _builtins.str oss_ak_id: OSS AccessKey ID.
        :param _builtins.str oss_ak_secret: OSS  AccessKey Secret.
        :param _builtins.str oss_mount_descs: OSS mount description information.
        :param Sequence['GetApplicationsApplicationOssMountDetailArgs'] oss_mount_details: The OSS mount detail.
        :param _builtins.str package_type: Application package type. Support FatJar, War and Image.
        :param _builtins.str package_url: Deployment package address. Only FatJar or War type applications can configure the deployment package address.
        :param _builtins.str package_version: The version number of the deployment package. Required when the Package Type is War and FatJar.
        :param _builtins.str php_arms_config_location: The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
        :param _builtins.str php_config: PHP configuration file content.
        :param _builtins.str php_config_location: PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
        :param _builtins.str post_start: Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        :param _builtins.str pre_stop: Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        :param _builtins.str readiness: Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
        :param _builtins.int replicas: Initial number of instances.
        :param _builtins.str security_group_id: Security group ID.
        :param _builtins.str sls_configs: SLS  configuration.
        :param _builtins.str status: The status of the resource.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.int termination_grace_period_seconds: Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
        :param _builtins.str timezone: Time zone, the default value is Asia/Shanghai.
        :param _builtins.str tomcat_config: Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
        :param _builtins.str vpc_id: The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
        :param _builtins.str vswitch_id: The vswitch id.
        :param _builtins.str war_start_options: WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
        :param _builtins.str web_container: The version of tomcat that the deployment package depends on. Image type applications are not supported.
        """
        pulumi.set(__self__, "acr_assume_role_arn", acr_assume_role_arn)
        pulumi.set(__self__, "acr_instance_id", acr_instance_id)
        pulumi.set(__self__, "app_description", app_description)
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "command_args", command_args)
        pulumi.set(__self__, "config_map_mount_desc", config_map_mount_desc)
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "custom_host_alias", custom_host_alias)
        pulumi.set(__self__, "edas_container_version", edas_container_version)
        pulumi.set(__self__, "envs", envs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_url", image_url)
        pulumi.set(__self__, "jar_start_args", jar_start_args)
        pulumi.set(__self__, "jar_start_options", jar_start_options)
        pulumi.set(__self__, "jdk", jdk)
        pulumi.set(__self__, "liveness", liveness)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "min_ready_instances", min_ready_instances)
        pulumi.set(__self__, "mount_descs", mount_descs)
        pulumi.set(__self__, "mount_host", mount_host)
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "nas_id", nas_id)
        pulumi.set(__self__, "oss_ak_id", oss_ak_id)
        pulumi.set(__self__, "oss_ak_secret", oss_ak_secret)
        pulumi.set(__self__, "oss_mount_descs", oss_mount_descs)
        pulumi.set(__self__, "oss_mount_details", oss_mount_details)
        pulumi.set(__self__, "package_type", package_type)
        pulumi.set(__self__, "package_url", package_url)
        pulumi.set(__self__, "package_version", package_version)
        pulumi.set(__self__, "php_arms_config_location", php_arms_config_location)
        pulumi.set(__self__, "php_config", php_config)
        pulumi.set(__self__, "php_config_location", php_config_location)
        pulumi.set(__self__, "post_start", post_start)
        pulumi.set(__self__, "pre_stop", pre_stop)
        pulumi.set(__self__, "readiness", readiness)
        pulumi.set(__self__, "region_id", region_id)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "repo_name", repo_name)
        pulumi.set(__self__, "repo_namespace", repo_namespace)
        pulumi.set(__self__, "repo_origin_type", repo_origin_type)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "sls_configs", sls_configs)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "tomcat_config", tomcat_config)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "war_start_options", war_start_options)
        pulumi.set(__self__, "web_container", web_container)

    @_builtins.property
    @pulumi.getter(name="acrAssumeRoleArn")
    def acr_assume_role_arn(self) -> _builtins.str:
        """
        The ARN of the RAM role required when pulling images across accounts.
        """
        return pulumi.get(self, "acr_assume_role_arn")

    @_builtins.property
    @pulumi.getter(name="acrInstanceId")
    def acr_instance_id(self) -> _builtins.str:
        """
        The ID of the ACR EE instance.
        """
        return pulumi.get(self, "acr_instance_id")

    @_builtins.property
    @pulumi.getter(name="appDescription")
    def app_description(self) -> _builtins.str:
        """
        Application description information. No more than 1024 characters.
        """
        return pulumi.get(self, "app_description")

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter
    def command(self) -> _builtins.str:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter(name="commandArgs")
    def command_args(self) -> _builtins.str:
        """
        Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
        """
        return pulumi.get(self, "command_args")

    @_builtins.property
    @pulumi.getter(name="configMapMountDesc")
    def config_map_mount_desc(self) -> _builtins.str:
        """
        ConfigMap mount description.
        """
        return pulumi.get(self, "config_map_mount_desc")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.int:
        """
        The CPU required for each instance, in millicores, cannot be 0.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Indicates That the Application of the Creation Time.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="customHostAlias")
    def custom_host_alias(self) -> _builtins.str:
        """
        Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
        """
        return pulumi.get(self, "custom_host_alias")

    @_builtins.property
    @pulumi.getter(name="edasContainerVersion")
    def edas_container_version(self) -> _builtins.str:
        """
        The operating environment used by the Pandora application.
        """
        return pulumi.get(self, "edas_container_version")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> _builtins.str:
        """
        The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Application.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> _builtins.str:
        """
        Mirror address. Only Image type applications can configure the mirror address.
        """
        return pulumi.get(self, "image_url")

    @_builtins.property
    @pulumi.getter(name="jarStartArgs")
    def jar_start_args(self) -> _builtins.str:
        """
        The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        """
        return pulumi.get(self, "jar_start_args")

    @_builtins.property
    @pulumi.getter(name="jarStartOptions")
    def jar_start_options(self) -> _builtins.str:
        """
        The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
        """
        return pulumi.get(self, "jar_start_options")

    @_builtins.property
    @pulumi.getter
    def jdk(self) -> _builtins.str:
        """
        The JDK version that the deployment package depends on. Image type applications are not supported.
        """
        return pulumi.get(self, "jdk")

    @_builtins.property
    @pulumi.getter
    def liveness(self) -> _builtins.str:
        """
        Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
        """
        return pulumi.get(self, "liveness")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter(name="minReadyInstances")
    def min_ready_instances(self) -> _builtins.int:
        """
        The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
        """
        return pulumi.get(self, "min_ready_instances")

    @_builtins.property
    @pulumi.getter(name="mountDescs")
    def mount_descs(self) -> Sequence['outputs.GetApplicationsApplicationMountDescResult']:
        """
        Mount description information.
        """
        return pulumi.get(self, "mount_descs")

    @_builtins.property
    @pulumi.getter(name="mountHost")
    def mount_host(self) -> _builtins.str:
        """
        Mount point of NAS in application VPC.
        """
        return pulumi.get(self, "mount_host")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> _builtins.str:
        """
        SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
        """
        return pulumi.get(self, "namespace_id")

    @_builtins.property
    @pulumi.getter(name="nasId")
    def nas_id(self) -> _builtins.str:
        """
        ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
        """
        return pulumi.get(self, "nas_id")

    @_builtins.property
    @pulumi.getter(name="ossAkId")
    def oss_ak_id(self) -> _builtins.str:
        """
        OSS AccessKey ID.
        """
        return pulumi.get(self, "oss_ak_id")

    @_builtins.property
    @pulumi.getter(name="ossAkSecret")
    def oss_ak_secret(self) -> _builtins.str:
        """
        OSS  AccessKey Secret.
        """
        return pulumi.get(self, "oss_ak_secret")

    @_builtins.property
    @pulumi.getter(name="ossMountDescs")
    def oss_mount_descs(self) -> _builtins.str:
        """
        OSS mount description information.
        """
        return pulumi.get(self, "oss_mount_descs")

    @_builtins.property
    @pulumi.getter(name="ossMountDetails")
    def oss_mount_details(self) -> Sequence['outputs.GetApplicationsApplicationOssMountDetailResult']:
        """
        The OSS mount detail.
        """
        return pulumi.get(self, "oss_mount_details")

    @_builtins.property
    @pulumi.getter(name="packageType")
    def package_type(self) -> _builtins.str:
        """
        Application package type. Support FatJar, War and Image.
        """
        return pulumi.get(self, "package_type")

    @_builtins.property
    @pulumi.getter(name="packageUrl")
    def package_url(self) -> _builtins.str:
        """
        Deployment package address. Only FatJar or War type applications can configure the deployment package address.
        """
        return pulumi.get(self, "package_url")

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> _builtins.str:
        """
        The version number of the deployment package. Required when the Package Type is War and FatJar.
        """
        return pulumi.get(self, "package_version")

    @_builtins.property
    @pulumi.getter(name="phpArmsConfigLocation")
    def php_arms_config_location(self) -> _builtins.str:
        """
        The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
        """
        return pulumi.get(self, "php_arms_config_location")

    @_builtins.property
    @pulumi.getter(name="phpConfig")
    def php_config(self) -> _builtins.str:
        """
        PHP configuration file content.
        """
        return pulumi.get(self, "php_config")

    @_builtins.property
    @pulumi.getter(name="phpConfigLocation")
    def php_config_location(self) -> _builtins.str:
        """
        PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
        """
        return pulumi.get(self, "php_config_location")

    @_builtins.property
    @pulumi.getter(name="postStart")
    def post_start(self) -> _builtins.str:
        """
        Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        """
        return pulumi.get(self, "post_start")

    @_builtins.property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> _builtins.str:
        """
        Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
        """
        return pulumi.get(self, "pre_stop")

    @_builtins.property
    @pulumi.getter
    def readiness(self) -> _builtins.str:
        """
        Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
        """
        return pulumi.get(self, "readiness")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        return pulumi.get(self, "region_id")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        Initial number of instances.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> _builtins.str:
        return pulumi.get(self, "repo_name")

    @_builtins.property
    @pulumi.getter(name="repoNamespace")
    def repo_namespace(self) -> _builtins.str:
        return pulumi.get(self, "repo_namespace")

    @_builtins.property
    @pulumi.getter(name="repoOriginType")
    def repo_origin_type(self) -> _builtins.str:
        return pulumi.get(self, "repo_origin_type")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="slsConfigs")
    def sls_configs(self) -> _builtins.str:
        """
        SLS  configuration.
        """
        return pulumi.get(self, "sls_configs")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> _builtins.int:
        """
        Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        Time zone, the default value is Asia/Shanghai.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="tomcatConfig")
    def tomcat_config(self) -> _builtins.str:
        """
        Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
        """
        return pulumi.get(self, "tomcat_config")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> _builtins.str:
        """
        The vswitch id.
        """
        return pulumi.get(self, "vswitch_id")

    @_builtins.property
    @pulumi.getter(name="warStartOptions")
    def war_start_options(self) -> _builtins.str:
        """
        WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
        """
        return pulumi.get(self, "war_start_options")

    @_builtins.property
    @pulumi.getter(name="webContainer")
    def web_container(self) -> _builtins.str:
        """
        The version of tomcat that the deployment package depends on. Image type applications are not supported.
        """
        return pulumi.get(self, "web_container")


@pulumi.output_type
class GetApplicationsApplicationMountDescResult(dict):
    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 nas_path: _builtins.str):
        """
        :param _builtins.str mount_path: Container mount path.
        :param _builtins.str nas_path: NAS relative file directory.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "nas_path", nas_path)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        Container mount path.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter(name="nasPath")
    def nas_path(self) -> _builtins.str:
        """
        NAS relative file directory.
        """
        return pulumi.get(self, "nas_path")


@pulumi.output_type
class GetApplicationsApplicationOssMountDetailResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 bucket_path: _builtins.str,
                 mount_path: _builtins.str,
                 read_only: _builtins.bool):
        """
        :param _builtins.str bucket_name: The name of the bucket.
        :param _builtins.str bucket_path: The path of the bucket.
        :param _builtins.str mount_path: The Container mount path.
        :param _builtins.bool read_only: Whether the container path has readable permission to mount directory resources.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "bucket_path", bucket_path)
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> _builtins.str:
        """
        The path of the bucket.
        """
        return pulumi.get(self, "bucket_path")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        The Container mount path.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> _builtins.bool:
        """
        Whether the container path has readable permission to mount directory resources.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetConfigMapsMapResult(dict):
    def __init__(__self__, *,
                 config_map_id: _builtins.str,
                 create_time: _builtins.str,
                 data: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 namespace_id: _builtins.str):
        """
        :param _builtins.str config_map_id: The first ID of the resource.
        :param _builtins.str create_time: The Creation Time of the ConfigMap.
        :param _builtins.str data: ConfigMap instance data. The value's format is a `json` string
        :param _builtins.str description: The Description of Config Map.
        :param _builtins.str id: The ID of the Config Map.
        :param _builtins.str name: ConfigMap instance name.
        :param _builtins.str namespace_id: The NamespaceId of Config Maps.
        """
        pulumi.set(__self__, "config_map_id", config_map_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)

    @_builtins.property
    @pulumi.getter(name="configMapId")
    def config_map_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "config_map_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The Creation Time of the ConfigMap.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        ConfigMap instance data. The value's format is a `json` string
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The Description of Config Map.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Config Map.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        ConfigMap instance name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> _builtins.str:
        """
        The NamespaceId of Config Maps.
        """
        return pulumi.get(self, "namespace_id")


@pulumi.output_type
class GetGreyTagRoutesRouteResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 dubbo_rules: Sequence['outputs.GetGreyTagRoutesRouteDubboRuleResult'],
                 grey_tag_route_name: _builtins.str,
                 id: _builtins.str,
                 sc_rules: Sequence['outputs.GetGreyTagRoutesRouteScRuleResult']):
        """
        :param _builtins.str description: The description of GreyTagRoute.
        :param Sequence['GetGreyTagRoutesRouteDubboRuleArgs'] dubbo_rules: The grayscale rule created for Dubbo Application.
        :param _builtins.str grey_tag_route_name: The name of GreyTagRoute.
        :param _builtins.str id: The ID of the GreyTagRoute.
        :param Sequence['GetGreyTagRoutesRouteScRuleArgs'] sc_rules: The grayscale rule created for SpringCloud Application.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dubbo_rules", dubbo_rules)
        pulumi.set(__self__, "grey_tag_route_name", grey_tag_route_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "sc_rules", sc_rules)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of GreyTagRoute.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dubboRules")
    def dubbo_rules(self) -> Sequence['outputs.GetGreyTagRoutesRouteDubboRuleResult']:
        """
        The grayscale rule created for Dubbo Application.
        """
        return pulumi.get(self, "dubbo_rules")

    @_builtins.property
    @pulumi.getter(name="greyTagRouteName")
    def grey_tag_route_name(self) -> _builtins.str:
        """
        The name of GreyTagRoute.
        """
        return pulumi.get(self, "grey_tag_route_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the GreyTagRoute.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="scRules")
    def sc_rules(self) -> Sequence['outputs.GetGreyTagRoutesRouteScRuleResult']:
        """
        The grayscale rule created for SpringCloud Application.
        """
        return pulumi.get(self, "sc_rules")


@pulumi.output_type
class GetGreyTagRoutesRouteDubboRuleResult(dict):
    def __init__(__self__, *,
                 condition: _builtins.str,
                 group: _builtins.str,
                 items: Sequence['outputs.GetGreyTagRoutesRouteDubboRuleItemResult'],
                 method_name: _builtins.str,
                 service_name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str condition: The conditional Patterns for Grayscale Rules.
        :param _builtins.str group: The service group.
        :param Sequence['GetGreyTagRoutesRouteDubboRuleItemArgs'] items: A list of conditions items.
        :param _builtins.str method_name: The method name
        :param _builtins.str service_name: The service name.
        :param _builtins.str version: The service version.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "method_name", method_name)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        The conditional Patterns for Grayscale Rules.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The service group.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetGreyTagRoutesRouteDubboRuleItemResult']:
        """
        A list of conditions items.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="methodName")
    def method_name(self) -> _builtins.str:
        """
        The method name
        """
        return pulumi.get(self, "method_name")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The service name.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The service version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGreyTagRoutesRouteDubboRuleItemResult(dict):
    def __init__(__self__, *,
                 cond: _builtins.str,
                 expr: _builtins.str,
                 index: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str cond: The comparison operator.
        :param _builtins.str expr: The parameter value gets the expression.
        :param _builtins.int index: The parameter number.
        :param _builtins.str operator: The operator.
        :param _builtins.str value: The value of the parameter.
        """
        pulumi.set(__self__, "cond", cond)
        pulumi.set(__self__, "expr", expr)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def cond(self) -> _builtins.str:
        """
        The comparison operator.
        """
        return pulumi.get(self, "cond")

    @_builtins.property
    @pulumi.getter
    def expr(self) -> _builtins.str:
        """
        The parameter value gets the expression.
        """
        return pulumi.get(self, "expr")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        """
        The parameter number.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGreyTagRoutesRouteScRuleResult(dict):
    def __init__(__self__, *,
                 condition: _builtins.str,
                 items: Sequence['outputs.GetGreyTagRoutesRouteScRuleItemResult'],
                 path: _builtins.str):
        """
        :param _builtins.str condition: The Conditional Patterns for Grayscale Rules.
        :param Sequence['GetGreyTagRoutesRouteScRuleItemArgs'] items: A list of conditions items.
        :param _builtins.str path: The path corresponding to the grayscale rule.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        The Conditional Patterns for Grayscale Rules.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetGreyTagRoutesRouteScRuleItemResult']:
        """
        A list of conditions items.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path corresponding to the grayscale rule.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetGreyTagRoutesRouteScRuleItemResult(dict):
    def __init__(__self__, *,
                 cond: _builtins.str,
                 name: _builtins.str,
                 operator: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str cond: The comparison operator.
        :param _builtins.str name: The name of the parameter.
        :param _builtins.str operator: The operator.
        :param _builtins.str type: The Compare types.
        :param _builtins.str value: The value of the parameter.
        """
        pulumi.set(__self__, "cond", cond)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def cond(self) -> _builtins.str:
        """
        The comparison operator.
        """
        return pulumi.get(self, "cond")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The Compare types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetIngressesIngressResult(dict):
    def __init__(__self__, *,
                 cert_id: _builtins.str,
                 default_rule: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 ingress_id: _builtins.str,
                 listener_port: _builtins.int,
                 namespace_id: _builtins.str,
                 slb_id: _builtins.str):
        """
        :param _builtins.str cert_id: Cert Id.
        :param _builtins.str default_rule: Default Rule.
        :param _builtins.str description: Description.
        :param _builtins.str id: The ID of the Ingress.
        :param _builtins.str ingress_id: The first ID of the resource.
        :param _builtins.int listener_port: SLB listening port.
        :param _builtins.str namespace_id: The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        :param _builtins.str slb_id: SLB ID.
        """
        pulumi.set(__self__, "cert_id", cert_id)
        pulumi.set(__self__, "default_rule", default_rule)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ingress_id", ingress_id)
        pulumi.set(__self__, "listener_port", listener_port)
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "slb_id", slb_id)

    @_builtins.property
    @pulumi.getter(name="certId")
    def cert_id(self) -> _builtins.str:
        """
        Cert Id.
        """
        return pulumi.get(self, "cert_id")

    @_builtins.property
    @pulumi.getter(name="defaultRule")
    def default_rule(self) -> _builtins.str:
        """
        Default Rule.
        """
        return pulumi.get(self, "default_rule")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Ingress.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ingressId")
    def ingress_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "ingress_id")

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> _builtins.int:
        """
        SLB listening port.
        """
        return pulumi.get(self, "listener_port")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> _builtins.str:
        """
        The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        """
        return pulumi.get(self, "namespace_id")

    @_builtins.property
    @pulumi.getter(name="slbId")
    def slb_id(self) -> _builtins.str:
        """
        SLB ID.
        """
        return pulumi.get(self, "slb_id")


@pulumi.output_type
class GetInstanceSpecificationsSpecificationResult(dict):
    def __init__(__self__, *,
                 cpu: _builtins.int,
                 enable: _builtins.bool,
                 id: _builtins.str,
                 instance_specification_id: _builtins.str,
                 memory: _builtins.int,
                 spec_info: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.int cpu: CPU Size, Specifications for Micronucleus.
        :param _builtins.bool enable: Whether the instance is available. The value description is as follows:
        :param _builtins.str id: The ID of the Instance Specification.
        :param _builtins.str instance_specification_id: The first ID of the resource.
        :param _builtins.int memory: The Memory specifications for the MB.
        :param _builtins.str spec_info: The specification configuration name.
        :param _builtins.int version: The specification configuration version.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_specification_id", instance_specification_id)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "spec_info", spec_info)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.int:
        """
        CPU Size, Specifications for Micronucleus.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Whether the instance is available. The value description is as follows:
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Instance Specification.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceSpecificationId")
    def instance_specification_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "instance_specification_id")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        The Memory specifications for the MB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter(name="specInfo")
    def spec_info(self) -> _builtins.str:
        """
        The specification configuration name.
        """
        return pulumi.get(self, "spec_info")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The specification configuration version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 namespace_description: _builtins.str,
                 namespace_id: _builtins.str,
                 namespace_name: _builtins.str):
        """
        :param _builtins.str id: The ID of the Namespace.
        :param _builtins.str namespace_description: The Description of Namespace.
        :param _builtins.str namespace_id: The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        :param _builtins.str namespace_name: The Name of Namespace.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "namespace_description", namespace_description)
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "namespace_name", namespace_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Namespace.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="namespaceDescription")
    def namespace_description(self) -> _builtins.str:
        """
        The Description of Namespace.
        """
        return pulumi.get(self, "namespace_description")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> _builtins.str:
        """
        The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
        """
        return pulumi.get(self, "namespace_id")

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> _builtins.str:
        """
        The Name of Namespace.
        """
        return pulumi.get(self, "namespace_name")


