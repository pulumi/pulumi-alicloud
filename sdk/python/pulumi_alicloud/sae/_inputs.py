# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplicationConfigMapMountDescV2Args',
    'ApplicationConfigMapMountDescV2ArgsDict',
    'ApplicationCustomHostAliasV2Args',
    'ApplicationCustomHostAliasV2ArgsDict',
    'ApplicationKafkaConfigsArgs',
    'ApplicationKafkaConfigsArgsDict',
    'ApplicationKafkaConfigsKafkaConfigArgs',
    'ApplicationKafkaConfigsKafkaConfigArgsDict',
    'ApplicationLivenessV2Args',
    'ApplicationLivenessV2ArgsDict',
    'ApplicationLivenessV2ExecArgs',
    'ApplicationLivenessV2ExecArgsDict',
    'ApplicationLivenessV2HttpGetArgs',
    'ApplicationLivenessV2HttpGetArgsDict',
    'ApplicationLivenessV2TcpSocketArgs',
    'ApplicationLivenessV2TcpSocketArgsDict',
    'ApplicationNasConfigArgs',
    'ApplicationNasConfigArgsDict',
    'ApplicationOssMountDescsV2Args',
    'ApplicationOssMountDescsV2ArgsDict',
    'ApplicationPostStartV2Args',
    'ApplicationPostStartV2ArgsDict',
    'ApplicationPostStartV2ExecArgs',
    'ApplicationPostStartV2ExecArgsDict',
    'ApplicationPreStopV2Args',
    'ApplicationPreStopV2ArgsDict',
    'ApplicationPreStopV2ExecArgs',
    'ApplicationPreStopV2ExecArgsDict',
    'ApplicationPvtzDiscoverySvcArgs',
    'ApplicationPvtzDiscoverySvcArgsDict',
    'ApplicationPvtzDiscoverySvcPortProtocolArgs',
    'ApplicationPvtzDiscoverySvcPortProtocolArgsDict',
    'ApplicationReadinessV2Args',
    'ApplicationReadinessV2ArgsDict',
    'ApplicationReadinessV2ExecArgs',
    'ApplicationReadinessV2ExecArgsDict',
    'ApplicationReadinessV2HttpGetArgs',
    'ApplicationReadinessV2HttpGetArgsDict',
    'ApplicationReadinessV2TcpSocketArgs',
    'ApplicationReadinessV2TcpSocketArgsDict',
    'ApplicationScalingRuleScalingRuleMetricArgs',
    'ApplicationScalingRuleScalingRuleMetricArgsDict',
    'ApplicationScalingRuleScalingRuleMetricMetricArgs',
    'ApplicationScalingRuleScalingRuleMetricMetricArgsDict',
    'ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs',
    'ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgsDict',
    'ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs',
    'ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgsDict',
    'ApplicationScalingRuleScalingRuleTimerArgs',
    'ApplicationScalingRuleScalingRuleTimerArgsDict',
    'ApplicationScalingRuleScalingRuleTimerScheduleArgs',
    'ApplicationScalingRuleScalingRuleTimerScheduleArgsDict',
    'ApplicationTomcatConfigV2Args',
    'ApplicationTomcatConfigV2ArgsDict',
    'ApplicationUpdateStrategyV2Args',
    'ApplicationUpdateStrategyV2ArgsDict',
    'ApplicationUpdateStrategyV2BatchUpdateArgs',
    'ApplicationUpdateStrategyV2BatchUpdateArgsDict',
    'GreyTagRouteDubboRuleArgs',
    'GreyTagRouteDubboRuleArgsDict',
    'GreyTagRouteDubboRuleItemArgs',
    'GreyTagRouteDubboRuleItemArgsDict',
    'GreyTagRouteScRuleArgs',
    'GreyTagRouteScRuleArgsDict',
    'GreyTagRouteScRuleItemArgs',
    'GreyTagRouteScRuleItemArgsDict',
    'IngressDefaultRuleArgs',
    'IngressDefaultRuleArgsDict',
    'IngressRuleArgs',
    'IngressRuleArgsDict',
    'LoadBalancerInternetInternetArgs',
    'LoadBalancerInternetInternetArgsDict',
    'LoadBalancerIntranetIntranetArgs',
    'LoadBalancerIntranetIntranetArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationConfigMapMountDescV2ArgsDict(TypedDict):
        config_map_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the ConfigMap.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        The key.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The mount path.
        """
elif False:
    ApplicationConfigMapMountDescV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationConfigMapMountDescV2Args:
    def __init__(__self__, *,
                 config_map_id: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_map_id: The ID of the ConfigMap.
        :param pulumi.Input[str] key: The key.
        :param pulumi.Input[str] mount_path: The mount path.
        """
        if config_map_id is not None:
            pulumi.set(__self__, "config_map_id", config_map_id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="configMapId")
    def config_map_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the ConfigMap.
        """
        return pulumi.get(self, "config_map_id")

    @config_map_id.setter
    def config_map_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_map_id", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The mount path.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class ApplicationCustomHostAliasV2ArgsDict(TypedDict):
        host_name: NotRequired[pulumi.Input[str]]
        """
        The domain name or hostname.
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        The IP address.
        """
elif False:
    ApplicationCustomHostAliasV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationCustomHostAliasV2Args:
    def __init__(__self__, *,
                 host_name: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_name: The domain name or hostname.
        :param pulumi.Input[str] ip: The IP address.
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name or hostname.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ApplicationKafkaConfigsArgsDict(TypedDict):
        kafka_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgsDict']]]]
        """
        One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        """
        kafka_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint of the ApsaraMQ for Kafka API.
        """
        kafka_instance_id: NotRequired[pulumi.Input[str]]
        """
        The  ID of the ApsaraMQ for Kafka instance.
        """
elif False:
    ApplicationKafkaConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationKafkaConfigsArgs:
    def __init__(__self__, *,
                 kafka_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]] = None,
                 kafka_endpoint: Optional[pulumi.Input[str]] = None,
                 kafka_instance_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]] kafka_configs: One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        :param pulumi.Input[str] kafka_endpoint: The endpoint of the ApsaraMQ for Kafka API.
        :param pulumi.Input[str] kafka_instance_id: The  ID of the ApsaraMQ for Kafka instance.
        """
        if kafka_configs is not None:
            pulumi.set(__self__, "kafka_configs", kafka_configs)
        if kafka_endpoint is not None:
            pulumi.set(__self__, "kafka_endpoint", kafka_endpoint)
        if kafka_instance_id is not None:
            pulumi.set(__self__, "kafka_instance_id", kafka_instance_id)

    @property
    @pulumi.getter(name="kafkaConfigs")
    def kafka_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]]:
        """
        One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        """
        return pulumi.get(self, "kafka_configs")

    @kafka_configs.setter
    def kafka_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]]):
        pulumi.set(self, "kafka_configs", value)

    @property
    @pulumi.getter(name="kafkaEndpoint")
    def kafka_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint of the ApsaraMQ for Kafka API.
        """
        return pulumi.get(self, "kafka_endpoint")

    @kafka_endpoint.setter
    def kafka_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_endpoint", value)

    @property
    @pulumi.getter(name="kafkaInstanceId")
    def kafka_instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        The  ID of the ApsaraMQ for Kafka instance.
        """
        return pulumi.get(self, "kafka_instance_id")

    @kafka_instance_id.setter
    def kafka_instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_instance_id", value)


if not MYPY:
    class ApplicationKafkaConfigsKafkaConfigArgsDict(TypedDict):
        kafka_topic: NotRequired[pulumi.Input[str]]
        """
        The topic of the Kafka.
        """
        log_dir: NotRequired[pulumi.Input[str]]
        """
        The path in which logs are stored.
        """
        log_type: NotRequired[pulumi.Input[str]]
        """
        The type of the log.
        """
elif False:
    ApplicationKafkaConfigsKafkaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationKafkaConfigsKafkaConfigArgs:
    def __init__(__self__, *,
                 kafka_topic: Optional[pulumi.Input[str]] = None,
                 log_dir: Optional[pulumi.Input[str]] = None,
                 log_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kafka_topic: The topic of the Kafka.
        :param pulumi.Input[str] log_dir: The path in which logs are stored.
        :param pulumi.Input[str] log_type: The type of the log.
        """
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)
        if log_dir is not None:
            pulumi.set(__self__, "log_dir", log_dir)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[pulumi.Input[str]]:
        """
        The topic of the Kafka.
        """
        return pulumi.get(self, "kafka_topic")

    @kafka_topic.setter
    def kafka_topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_topic", value)

    @property
    @pulumi.getter(name="logDir")
    def log_dir(self) -> Optional[pulumi.Input[str]]:
        """
        The path in which logs are stored.
        """
        return pulumi.get(self, "log_dir")

    @log_dir.setter
    def log_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_dir", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the log.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class ApplicationLivenessV2ArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['ApplicationLivenessV2ExecArgsDict']]
        """
        Execute. See `exec` below.
        """
        http_get: NotRequired[pulumi.Input['ApplicationLivenessV2HttpGetArgsDict']]
        """
        The liveness check settings of the container. See `http_get` below.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        """
        The delay of the health check.
        """
        period_seconds: NotRequired[pulumi.Input[int]]
        """
        The interval at which the health check is performed.
        """
        tcp_socket: NotRequired[pulumi.Input['ApplicationLivenessV2TcpSocketArgsDict']]
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        The timeout period of the health check.
        """
elif False:
    ApplicationLivenessV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationLivenessV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']] = None,
                 http_get: Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ApplicationLivenessV2ExecArgs'] exec_: Execute. See `exec` below.
        :param pulumi.Input['ApplicationLivenessV2HttpGetArgs'] http_get: The liveness check settings of the container. See `http_get` below.
        :param pulumi.Input[int] initial_delay_seconds: The delay of the health check.
        :param pulumi.Input[int] period_seconds: The interval at which the health check is performed.
        :param pulumi.Input['ApplicationLivenessV2TcpSocketArgs'] tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param pulumi.Input[int] timeout_seconds: The timeout period of the health check.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']]):
        pulumi.set(self, "exec_", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']]:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']]:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class ApplicationLivenessV2ExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
elif False:
    ApplicationLivenessV2ExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationLivenessV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class ApplicationLivenessV2HttpGetArgsDict(TypedDict):
        is_contain_key_word: NotRequired[pulumi.Input[bool]]
        key_word: NotRequired[pulumi.Input[str]]
        path: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        scheme: NotRequired[pulumi.Input[str]]
elif False:
    ApplicationLivenessV2HttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationLivenessV2HttpGetArgs:
    def __init__(__self__, *,
                 is_contain_key_word: Optional[pulumi.Input[bool]] = None,
                 key_word: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        if is_contain_key_word is not None:
            pulumi.set(__self__, "is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            pulumi.set(__self__, "key_word", key_word)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_contain_key_word")

    @is_contain_key_word.setter
    def is_contain_key_word(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contain_key_word", value)

    @property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key_word")

    @key_word.setter
    def key_word(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_word", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class ApplicationLivenessV2TcpSocketArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[int]]
elif False:
    ApplicationLivenessV2TcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationLivenessV2TcpSocketArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ApplicationNasConfigArgsDict(TypedDict):
        mount_domain: NotRequired[pulumi.Input[str]]
        """
        The domain name of the mount target.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The mount path of the container.
        """
        nas_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the NAS file system.
        """
        nas_path: NotRequired[pulumi.Input[str]]
        """
        The directory in the NAS file system.
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
elif False:
    ApplicationNasConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationNasConfigArgs:
    def __init__(__self__, *,
                 mount_domain: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 nas_id: Optional[pulumi.Input[str]] = None,
                 nas_path: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] mount_domain: The domain name of the mount target.
        :param pulumi.Input[str] mount_path: The mount path of the container.
        :param pulumi.Input[str] nas_id: The ID of the NAS file system.
        :param pulumi.Input[str] nas_path: The directory in the NAS file system.
        :param pulumi.Input[bool] read_only: Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        if mount_domain is not None:
            pulumi.set(__self__, "mount_domain", mount_domain)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if nas_id is not None:
            pulumi.set(__self__, "nas_id", nas_id)
        if nas_path is not None:
            pulumi.set(__self__, "nas_path", nas_path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="mountDomain")
    def mount_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name of the mount target.
        """
        return pulumi.get(self, "mount_domain")

    @mount_domain.setter
    def mount_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_domain", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The mount path of the container.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="nasId")
    def nas_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the NAS file system.
        """
        return pulumi.get(self, "nas_id")

    @nas_id.setter
    def nas_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nas_id", value)

    @property
    @pulumi.getter(name="nasPath")
    def nas_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory in the NAS file system.
        """
        return pulumi.get(self, "nas_path")

    @nas_path.setter
    def nas_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nas_path", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class ApplicationOssMountDescsV2ArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the OSS bucket.
        """
        bucket_path: NotRequired[pulumi.Input[str]]
        """
        The directory or object in OSS.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path of the container in SAE.
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the application can use the container path to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        """
elif False:
    ApplicationOssMountDescsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationOssMountDescsV2Args:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 bucket_path: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket_name: The name of the OSS bucket.
        :param pulumi.Input[str] bucket_path: The directory or object in OSS.
        :param pulumi.Input[str] mount_path: The path of the container in SAE.
        :param pulumi.Input[bool] read_only: Specifies whether the application can use the container path to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_path is not None:
            pulumi.set(__self__, "bucket_path", bucket_path)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the OSS bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory or object in OSS.
        """
        return pulumi.get(self, "bucket_path")

    @bucket_path.setter
    def bucket_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_path", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path of the container in SAE.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the application can use the container path to read data from or write data to resources in the directory of the OSS bucket. Valid values:
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class ApplicationPostStartV2ArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['ApplicationPostStartV2ExecArgsDict']]
        """
        Execute. See `exec` below.
        """
elif False:
    ApplicationPostStartV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPostStartV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']] = None):
        """
        :param pulumi.Input['ApplicationPostStartV2ExecArgs'] exec_: Execute. See `exec` below.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']]):
        pulumi.set(self, "exec_", value)


if not MYPY:
    class ApplicationPostStartV2ExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
elif False:
    ApplicationPostStartV2ExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPostStartV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class ApplicationPreStopV2ArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['ApplicationPreStopV2ExecArgsDict']]
        """
        Execute. See `exec` below.
        """
elif False:
    ApplicationPreStopV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPreStopV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']] = None):
        """
        :param pulumi.Input['ApplicationPreStopV2ExecArgs'] exec_: Execute. See `exec` below.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']]):
        pulumi.set(self, "exec_", value)


if not MYPY:
    class ApplicationPreStopV2ExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
elif False:
    ApplicationPreStopV2ExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPreStopV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class ApplicationPvtzDiscoverySvcArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        """
        Enables the Kubernetes Service-based registration and discovery feature.
        """
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the namespace.
        """
        port_protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgsDict']]]]
        """
        The port number and protocol. See `port_protocols` below.
        """
        service_name: NotRequired[pulumi.Input[str]]
        """
        The name of the Service.
        """
elif False:
    ApplicationPvtzDiscoverySvcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPvtzDiscoverySvcArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 namespace_id: Optional[pulumi.Input[str]] = None,
                 port_protocols: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable: Enables the Kubernetes Service-based registration and discovery feature.
        :param pulumi.Input[str] namespace_id: The ID of the namespace.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]] port_protocols: The port number and protocol. See `port_protocols` below.
        :param pulumi.Input[str] service_name: The name of the Service.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if port_protocols is not None:
            pulumi.set(__self__, "port_protocols", port_protocols)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the Kubernetes Service-based registration and discovery feature.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter(name="portProtocols")
    def port_protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]]:
        """
        The port number and protocol. See `port_protocols` below.
        """
        return pulumi.get(self, "port_protocols")

    @port_protocols.setter
    def port_protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]]):
        pulumi.set(self, "port_protocols", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class ApplicationPvtzDiscoverySvcPortProtocolArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[int]]
        protocol: NotRequired[pulumi.Input[str]]
        """
        The protocol. Valid values: `TCP` and `UDP`.
        """
elif False:
    ApplicationPvtzDiscoverySvcPortProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPvtzDiscoverySvcPortProtocolArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The protocol. Valid values: `TCP` and `UDP`.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol. Valid values: `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ApplicationReadinessV2ArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['ApplicationReadinessV2ExecArgsDict']]
        """
        Execute. See `exec` below.
        """
        http_get: NotRequired[pulumi.Input['ApplicationReadinessV2HttpGetArgsDict']]
        """
        The liveness check settings of the container. See `http_get` below.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        """
        The delay of the health check.
        """
        period_seconds: NotRequired[pulumi.Input[int]]
        """
        The interval at which the health check is performed.
        """
        tcp_socket: NotRequired[pulumi.Input['ApplicationReadinessV2TcpSocketArgsDict']]
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        The timeout period of the health check.
        """
elif False:
    ApplicationReadinessV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationReadinessV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']] = None,
                 http_get: Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ApplicationReadinessV2ExecArgs'] exec_: Execute. See `exec` below.
        :param pulumi.Input['ApplicationReadinessV2HttpGetArgs'] http_get: The liveness check settings of the container. See `http_get` below.
        :param pulumi.Input[int] initial_delay_seconds: The delay of the health check.
        :param pulumi.Input[int] period_seconds: The interval at which the health check is performed.
        :param pulumi.Input['ApplicationReadinessV2TcpSocketArgs'] tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param pulumi.Input[int] timeout_seconds: The timeout period of the health check.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']]):
        pulumi.set(self, "exec_", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']]:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']]:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class ApplicationReadinessV2ExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
elif False:
    ApplicationReadinessV2ExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationReadinessV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class ApplicationReadinessV2HttpGetArgsDict(TypedDict):
        is_contain_key_word: NotRequired[pulumi.Input[bool]]
        key_word: NotRequired[pulumi.Input[str]]
        path: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        scheme: NotRequired[pulumi.Input[str]]
elif False:
    ApplicationReadinessV2HttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationReadinessV2HttpGetArgs:
    def __init__(__self__, *,
                 is_contain_key_word: Optional[pulumi.Input[bool]] = None,
                 key_word: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        if is_contain_key_word is not None:
            pulumi.set(__self__, "is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            pulumi.set(__self__, "key_word", key_word)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_contain_key_word")

    @is_contain_key_word.setter
    def is_contain_key_word(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contain_key_word", value)

    @property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key_word")

    @key_word.setter
    def key_word(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_word", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class ApplicationReadinessV2TcpSocketArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[int]]
elif False:
    ApplicationReadinessV2TcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationReadinessV2TcpSocketArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ApplicationScalingRuleScalingRuleMetricArgsDict(TypedDict):
        max_replicas: NotRequired[pulumi.Input[int]]
        """
        Maximum number of instances applied.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgsDict']]]]
        """
        Indicator rule configuration. See `metrics` below.
        """
        min_replicas: NotRequired[pulumi.Input[int]]
        """
        Minimum number of instances applied.
        """
        scale_down_rules: NotRequired[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgsDict']]
        """
        Apply shrink rules. See `scale_down_rules` below.
        """
        scale_up_rules: NotRequired[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgsDict']]
        """
        Apply expansion rules. See `scale_up_rules` below.
        """
elif False:
    ApplicationScalingRuleScalingRuleMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None,
                 scale_down_rules: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']] = None,
                 scale_up_rules: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']] = None):
        """
        :param pulumi.Input[int] max_replicas: Maximum number of instances applied.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]] metrics: Indicator rule configuration. See `metrics` below.
        :param pulumi.Input[int] min_replicas: Minimum number of instances applied.
        :param pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs'] scale_down_rules: Apply shrink rules. See `scale_down_rules` below.
        :param pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs'] scale_up_rules: Apply expansion rules. See `scale_up_rules` below.
        """
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if scale_down_rules is not None:
            pulumi.set(__self__, "scale_down_rules", scale_down_rules)
        if scale_up_rules is not None:
            pulumi.set(__self__, "scale_up_rules", scale_up_rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of instances applied.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]]:
        """
        Indicator rule configuration. See `metrics` below.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of instances applied.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter(name="scaleDownRules")
    def scale_down_rules(self) -> Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']]:
        """
        Apply shrink rules. See `scale_down_rules` below.
        """
        return pulumi.get(self, "scale_down_rules")

    @scale_down_rules.setter
    def scale_down_rules(self, value: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']]):
        pulumi.set(self, "scale_down_rules", value)

    @property
    @pulumi.getter(name="scaleUpRules")
    def scale_up_rules(self) -> Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']]:
        """
        Apply expansion rules. See `scale_up_rules` below.
        """
        return pulumi.get(self, "scale_up_rules")

    @scale_up_rules.setter
    def scale_up_rules(self, value: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']]):
        pulumi.set(self, "scale_up_rules", value)


if not MYPY:
    class ApplicationScalingRuleScalingRuleMetricMetricArgsDict(TypedDict):
        metric_target_average_utilization: NotRequired[pulumi.Input[int]]
        """
        According to different `metric_type`, set the target value of the corresponding monitoring index.
        """
        metric_type: NotRequired[pulumi.Input[str]]
        """
        Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
        - CPU: CPU usage.
        - MEMORY: MEMORY usage.
        - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
        - QPS: The average QPS of a single instance within 1 minute of JAVA application.
        - RT: The average response time of all service interfaces within 1 minute of JAVA application.
        - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
        - SLB_RT: The average response time of public network SLB within 15 seconds.
        - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
        - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
        **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        """
        slb_id: NotRequired[pulumi.Input[str]]
        """
        SLB ID.
        """
        slb_log_store: NotRequired[pulumi.Input[str]]
        """
        The log store of the Log Service.
        """
        slb_project: NotRequired[pulumi.Input[str]]
        """
        The project of the Log Service.
        """
        vport: NotRequired[pulumi.Input[str]]
        """
        SLB listening port.
        """
elif False:
    ApplicationScalingRuleScalingRuleMetricMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricMetricArgs:
    def __init__(__self__, *,
                 metric_target_average_utilization: Optional[pulumi.Input[int]] = None,
                 metric_type: Optional[pulumi.Input[str]] = None,
                 slb_id: Optional[pulumi.Input[str]] = None,
                 slb_log_store: Optional[pulumi.Input[str]] = None,
                 slb_project: Optional[pulumi.Input[str]] = None,
                 vport: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] metric_target_average_utilization: According to different `metric_type`, set the target value of the corresponding monitoring index.
        :param pulumi.Input[str] metric_type: Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
               - CPU: CPU usage.
               - MEMORY: MEMORY usage.
               - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
               - QPS: The average QPS of a single instance within 1 minute of JAVA application.
               - RT: The average response time of all service interfaces within 1 minute of JAVA application.
               - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
               - SLB_RT: The average response time of public network SLB within 15 seconds.
               - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
               - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
               **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        :param pulumi.Input[str] slb_id: SLB ID.
        :param pulumi.Input[str] slb_log_store: The log store of the Log Service.
        :param pulumi.Input[str] slb_project: The project of the Log Service.
        :param pulumi.Input[str] vport: SLB listening port.
        """
        if metric_target_average_utilization is not None:
            pulumi.set(__self__, "metric_target_average_utilization", metric_target_average_utilization)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if slb_id is not None:
            pulumi.set(__self__, "slb_id", slb_id)
        if slb_log_store is not None:
            pulumi.set(__self__, "slb_log_store", slb_log_store)
        if slb_project is not None:
            pulumi.set(__self__, "slb_project", slb_project)
        if vport is not None:
            pulumi.set(__self__, "vport", vport)

    @property
    @pulumi.getter(name="metricTargetAverageUtilization")
    def metric_target_average_utilization(self) -> Optional[pulumi.Input[int]]:
        """
        According to different `metric_type`, set the target value of the corresponding monitoring index.
        """
        return pulumi.get(self, "metric_target_average_utilization")

    @metric_target_average_utilization.setter
    def metric_target_average_utilization(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric_target_average_utilization", value)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
        - CPU: CPU usage.
        - MEMORY: MEMORY usage.
        - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
        - QPS: The average QPS of a single instance within 1 minute of JAVA application.
        - RT: The average response time of all service interfaces within 1 minute of JAVA application.
        - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
        - SLB_RT: The average response time of public network SLB within 15 seconds.
        - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
        - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
        **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter(name="slbId")
    def slb_id(self) -> Optional[pulumi.Input[str]]:
        """
        SLB ID.
        """
        return pulumi.get(self, "slb_id")

    @slb_id.setter
    def slb_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slb_id", value)

    @property
    @pulumi.getter(name="slbLogStore")
    def slb_log_store(self) -> Optional[pulumi.Input[str]]:
        """
        The log store of the Log Service.
        """
        return pulumi.get(self, "slb_log_store")

    @slb_log_store.setter
    def slb_log_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slb_log_store", value)

    @property
    @pulumi.getter(name="slbProject")
    def slb_project(self) -> Optional[pulumi.Input[str]]:
        """
        The project of the Log Service.
        """
        return pulumi.get(self, "slb_project")

    @slb_project.setter
    def slb_project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slb_project", value)

    @property
    @pulumi.getter
    def vport(self) -> Optional[pulumi.Input[str]]:
        """
        SLB listening port.
        """
        return pulumi.get(self, "vport")

    @vport.setter
    def vport(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vport", value)


if not MYPY:
    class ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Whether shrinkage is prohibited.
        """
        stabilization_window_seconds: NotRequired[pulumi.Input[int]]
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        step: NotRequired[pulumi.Input[int]]
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
elif False:
    ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[int]] = None,
                 step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: Whether shrinkage is prohibited.
        :param pulumi.Input[int] stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param pulumi.Input[int] step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stabilization_window_seconds", value)

    @property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[int]]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "step", value)


if not MYPY:
    class ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Whether shrinkage is prohibited.
        """
        stabilization_window_seconds: NotRequired[pulumi.Input[int]]
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        step: NotRequired[pulumi.Input[int]]
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
elif False:
    ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[int]] = None,
                 step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: Whether shrinkage is prohibited.
        :param pulumi.Input[int] stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param pulumi.Input[int] step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stabilization_window_seconds", value)

    @property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[int]]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "step", value)


if not MYPY:
    class ApplicationScalingRuleScalingRuleTimerArgsDict(TypedDict):
        begin_date: NotRequired[pulumi.Input[str]]
        """
        The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        end_date: NotRequired[pulumi.Input[str]]
        """
        The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        period: NotRequired[pulumi.Input[str]]
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgsDict']]]]
        """
        Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
elif False:
    ApplicationScalingRuleScalingRuleTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationScalingRuleScalingRuleTimerArgs:
    def __init__(__self__, *,
                 begin_date: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] begin_date: The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param pulumi.Input[str] end_date: The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param pulumi.Input[str] period: The period in which a timed elastic scaling strategy is executed.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]] schedules: Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        if begin_date is not None:
            pulumi.set(__self__, "begin_date", begin_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter(name="beginDate")
    def begin_date(self) -> Optional[pulumi.Input[str]]:
        """
        The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "begin_date")

    @begin_date.setter
    def begin_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "begin_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[str]]:
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]]:
        """
        Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)


if not MYPY:
    class ApplicationScalingRuleScalingRuleTimerScheduleArgsDict(TypedDict):
        at_time: NotRequired[pulumi.Input[str]]
        """
        Trigger point in time. When supporting format: minutes, for example: `08:00`.
        """
        max_replicas: NotRequired[pulumi.Input[int]]
        min_replicas: NotRequired[pulumi.Input[int]]
        target_replicas: NotRequired[pulumi.Input[int]]
        """
        This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
elif False:
    ApplicationScalingRuleScalingRuleTimerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationScalingRuleScalingRuleTimerScheduleArgs:
    def __init__(__self__, *,
                 at_time: Optional[pulumi.Input[str]] = None,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None,
                 target_replicas: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] at_time: Trigger point in time. When supporting format: minutes, for example: `08:00`.
        :param pulumi.Input[int] target_replicas: This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        if at_time is not None:
            pulumi.set(__self__, "at_time", at_time)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if target_replicas is not None:
            pulumi.set(__self__, "target_replicas", target_replicas)

    @property
    @pulumi.getter(name="atTime")
    def at_time(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger point in time. When supporting format: minutes, for example: `08:00`.
        """
        return pulumi.get(self, "at_time")

    @at_time.setter
    def at_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "at_time", value)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        return pulumi.get(self, "target_replicas")

    @target_replicas.setter
    def target_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_replicas", value)


if not MYPY:
    class ApplicationTomcatConfigV2ArgsDict(TypedDict):
        context_path: NotRequired[pulumi.Input[str]]
        """
        The path.
        """
        max_threads: NotRequired[pulumi.Input[int]]
        """
        The maximum number of connections in the connection pool.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port.
        """
        uri_encoding: NotRequired[pulumi.Input[str]]
        """
        The URI encoding scheme in the Tomcat container.
        """
        use_body_encoding_for_uri: NotRequired[pulumi.Input[str]]
        """
        Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
elif False:
    ApplicationTomcatConfigV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationTomcatConfigV2Args:
    def __init__(__self__, *,
                 context_path: Optional[pulumi.Input[str]] = None,
                 max_threads: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 uri_encoding: Optional[pulumi.Input[str]] = None,
                 use_body_encoding_for_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context_path: The path.
        :param pulumi.Input[int] max_threads: The maximum number of connections in the connection pool.
        :param pulumi.Input[int] port: The port.
        :param pulumi.Input[str] uri_encoding: The URI encoding scheme in the Tomcat container.
        :param pulumi.Input[str] use_body_encoding_for_uri: Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if uri_encoding is not None:
            pulumi.set(__self__, "uri_encoding", uri_encoding)
        if use_body_encoding_for_uri is not None:
            pulumi.set(__self__, "use_body_encoding_for_uri", use_body_encoding_for_uri)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path.
        """
        return pulumi.get(self, "context_path")

    @context_path.setter
    def context_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_path", value)

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of connections in the connection pool.
        """
        return pulumi.get(self, "max_threads")

    @max_threads.setter
    def max_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_threads", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="uriEncoding")
    def uri_encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The URI encoding scheme in the Tomcat container.
        """
        return pulumi.get(self, "uri_encoding")

    @uri_encoding.setter
    def uri_encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri_encoding", value)

    @property
    @pulumi.getter(name="useBodyEncodingForUri")
    def use_body_encoding_for_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        return pulumi.get(self, "use_body_encoding_for_uri")

    @use_body_encoding_for_uri.setter
    def use_body_encoding_for_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_body_encoding_for_uri", value)


if not MYPY:
    class ApplicationUpdateStrategyV2ArgsDict(TypedDict):
        batch_update: NotRequired[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgsDict']]
        """
        The phased release policy. See `batch_update` below.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
elif False:
    ApplicationUpdateStrategyV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationUpdateStrategyV2Args:
    def __init__(__self__, *,
                 batch_update: Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs'] batch_update: The phased release policy. See `batch_update` below.
        :param pulumi.Input[str] type: The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        if batch_update is not None:
            pulumi.set(__self__, "batch_update", batch_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="batchUpdate")
    def batch_update(self) -> Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']]:
        """
        The phased release policy. See `batch_update` below.
        """
        return pulumi.get(self, "batch_update")

    @batch_update.setter
    def batch_update(self, value: Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']]):
        pulumi.set(self, "batch_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApplicationUpdateStrategyV2BatchUpdateArgsDict(TypedDict):
        batch: NotRequired[pulumi.Input[int]]
        """
        The number of batches in which you want to release the instances.
        """
        batch_wait_time: NotRequired[pulumi.Input[int]]
        """
        The batch wait time.
        """
        release_type: NotRequired[pulumi.Input[str]]
        """
        The processing method for the batches. Valid values: `auto` and `manual`.
        """
elif False:
    ApplicationUpdateStrategyV2BatchUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationUpdateStrategyV2BatchUpdateArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input[int]] = None,
                 batch_wait_time: Optional[pulumi.Input[int]] = None,
                 release_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] batch: The number of batches in which you want to release the instances.
        :param pulumi.Input[int] batch_wait_time: The batch wait time.
        :param pulumi.Input[str] release_type: The processing method for the batches. Valid values: `auto` and `manual`.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if batch_wait_time is not None:
            pulumi.set(__self__, "batch_wait_time", batch_wait_time)
        if release_type is not None:
            pulumi.set(__self__, "release_type", release_type)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input[int]]:
        """
        The number of batches in which you want to release the instances.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="batchWaitTime")
    def batch_wait_time(self) -> Optional[pulumi.Input[int]]:
        """
        The batch wait time.
        """
        return pulumi.get(self, "batch_wait_time")

    @batch_wait_time.setter
    def batch_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_wait_time", value)

    @property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[str]]:
        """
        The processing method for the batches. Valid values: `auto` and `manual`.
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "release_type", value)


if not MYPY:
    class GreyTagRouteDubboRuleArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        The service group.
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgsDict']]]]
        """
        A list of conditions items. See `items` below.
        """
        method_name: NotRequired[pulumi.Input[str]]
        """
        The method name
        """
        service_name: NotRequired[pulumi.Input[str]]
        """
        The service name.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The service version.
        """
elif False:
    GreyTagRouteDubboRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GreyTagRouteDubboRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]] = None,
                 method_name: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param pulumi.Input[str] group: The service group.
        :param pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]] items: A list of conditions items. See `items` below.
        :param pulumi.Input[str] method_name: The method name
        :param pulumi.Input[str] service_name: The service name.
        :param pulumi.Input[str] version: The service version.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if method_name is not None:
            pulumi.set(__self__, "method_name", method_name)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The service group.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> Optional[pulumi.Input[str]]:
        """
        The method name
        """
        return pulumi.get(self, "method_name")

    @method_name.setter
    def method_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method_name", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The service version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GreyTagRouteDubboRuleItemArgsDict(TypedDict):
        cond: NotRequired[pulumi.Input[str]]
        expr: NotRequired[pulumi.Input[str]]
        """
        The parameter value gets the expression.
        """
        index: NotRequired[pulumi.Input[int]]
        """
        The parameter number.
        """
        operator: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    GreyTagRouteDubboRuleItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GreyTagRouteDubboRuleItemArgs:
    def __init__(__self__, *,
                 cond: Optional[pulumi.Input[str]] = None,
                 expr: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expr: The parameter value gets the expression.
        :param pulumi.Input[int] index: The parameter number.
        """
        if cond is not None:
            pulumi.set(__self__, "cond", cond)
        if expr is not None:
            pulumi.set(__self__, "expr", expr)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def cond(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cond")

    @cond.setter
    def cond(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cond", value)

    @property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[str]]:
        """
        The parameter value gets the expression.
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expr", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        The parameter number.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GreyTagRouteScRuleArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgsDict']]]]
        """
        A list of conditions items. See `items` below.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path corresponding to the grayscale rule.
        """
elif False:
    GreyTagRouteScRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GreyTagRouteScRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]] items: A list of conditions items. See `items` below.
        :param pulumi.Input[str] path: The path corresponding to the grayscale rule.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path corresponding to the grayscale rule.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class GreyTagRouteScRuleItemArgsDict(TypedDict):
        cond: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the parameter.
        """
        operator: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        The compare types. Valid values: `param`, `cookie`, `header`.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    GreyTagRouteScRuleItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GreyTagRouteScRuleItemArgs:
    def __init__(__self__, *,
                 cond: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the parameter.
        :param pulumi.Input[str] type: The compare types. Valid values: `param`, `cookie`, `header`.
        """
        if cond is not None:
            pulumi.set(__self__, "cond", cond)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def cond(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cond")

    @cond.setter
    def cond(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cond", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The compare types. Valid values: `param`, `cookie`, `header`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IngressDefaultRuleArgsDict(TypedDict):
        app_id: NotRequired[pulumi.Input[str]]
        """
        Target application ID.
        """
        app_name: NotRequired[pulumi.Input[str]]
        """
        Target application name.
        """
        container_port: NotRequired[pulumi.Input[int]]
        """
        Application backend port.
        """
elif False:
    IngressDefaultRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IngressDefaultRuleArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_name: Optional[pulumi.Input[str]] = None,
                 container_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] app_id: Target application ID.
        :param pulumi.Input[str] app_name: Target application name.
        :param pulumi.Input[int] container_port: Application backend port.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_name", value)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[int]]:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_port", value)


if not MYPY:
    class IngressRuleArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        Target application ID.
        """
        app_name: pulumi.Input[str]
        """
        Target application name.
        """
        container_port: pulumi.Input[int]
        """
        Application backend port.
        """
        domain: pulumi.Input[str]
        """
        Application domain name.
        """
        path: pulumi.Input[str]
        """
        URL path.
        """
        backend_protocol: NotRequired[pulumi.Input[str]]
        """
        The backend protocol.
        """
        rewrite_path: NotRequired[pulumi.Input[str]]
        """
        The rewrite path.
        """
elif False:
    IngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IngressRuleArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_name: pulumi.Input[str],
                 container_port: pulumi.Input[int],
                 domain: pulumi.Input[str],
                 path: pulumi.Input[str],
                 backend_protocol: Optional[pulumi.Input[str]] = None,
                 rewrite_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] app_id: Target application ID.
        :param pulumi.Input[str] app_name: Target application name.
        :param pulumi.Input[int] container_port: Application backend port.
        :param pulumi.Input[str] domain: Application domain name.
        :param pulumi.Input[str] path: URL path.
        :param pulumi.Input[str] backend_protocol: The backend protocol.
        :param pulumi.Input[str] rewrite_path: The rewrite path.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "container_port", container_port)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "path", path)
        if backend_protocol is not None:
            pulumi.set(__self__, "backend_protocol", backend_protocol)
        if rewrite_path is not None:
            pulumi.set(__self__, "rewrite_path", rewrite_path)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> pulumi.Input[str]:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_name", value)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[int]:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "container_port", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Application domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        URL path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The backend protocol.
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_protocol", value)

    @property
    @pulumi.getter(name="rewritePath")
    def rewrite_path(self) -> Optional[pulumi.Input[str]]:
        """
        The rewrite path.
        """
        return pulumi.get(self, "rewrite_path")

    @rewrite_path.setter
    def rewrite_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rewrite_path", value)


if not MYPY:
    class LoadBalancerInternetInternetArgsDict(TypedDict):
        https_cert_id: NotRequired[pulumi.Input[str]]
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The SLB Port.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        target_port: NotRequired[pulumi.Input[int]]
        """
        The Container port.
        """
elif False:
    LoadBalancerInternetInternetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerInternetInternetArgs:
    def __init__(__self__, *,
                 https_cert_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param pulumi.Input[int] port: The SLB Port.
        :param pulumi.Input[str] protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param pulumi.Input[int] target_port: The Container port.
        """
        if https_cert_id is not None:
            pulumi.set(__self__, "https_cert_id", https_cert_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[pulumi.Input[str]]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @https_cert_id.setter
    def https_cert_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_cert_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class LoadBalancerIntranetIntranetArgsDict(TypedDict):
        https_cert_id: NotRequired[pulumi.Input[str]]
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The SLB Port.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        target_port: NotRequired[pulumi.Input[int]]
        """
        The Container port.
        """
elif False:
    LoadBalancerIntranetIntranetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerIntranetIntranetArgs:
    def __init__(__self__, *,
                 https_cert_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param pulumi.Input[int] port: The SLB Port.
        :param pulumi.Input[str] protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param pulumi.Input[int] target_port: The Container port.
        """
        if https_cert_id is not None:
            pulumi.set(__self__, "https_cert_id", https_cert_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[pulumi.Input[str]]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @https_cert_id.setter
    def https_cert_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_cert_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


