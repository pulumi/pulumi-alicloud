# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ApplicationConfigMapMountDescV2Args',
    'ApplicationCustomHostAliasV2Args',
    'ApplicationKafkaConfigsArgs',
    'ApplicationKafkaConfigsKafkaConfigArgs',
    'ApplicationLivenessV2Args',
    'ApplicationLivenessV2ExecArgs',
    'ApplicationLivenessV2HttpGetArgs',
    'ApplicationLivenessV2TcpSocketArgs',
    'ApplicationNasConfigArgs',
    'ApplicationOssMountDescsV2Args',
    'ApplicationPostStartV2Args',
    'ApplicationPostStartV2ExecArgs',
    'ApplicationPreStopV2Args',
    'ApplicationPreStopV2ExecArgs',
    'ApplicationPvtzDiscoverySvcArgs',
    'ApplicationPvtzDiscoverySvcPortProtocolArgs',
    'ApplicationReadinessV2Args',
    'ApplicationReadinessV2ExecArgs',
    'ApplicationReadinessV2HttpGetArgs',
    'ApplicationReadinessV2TcpSocketArgs',
    'ApplicationScalingRuleScalingRuleMetricArgs',
    'ApplicationScalingRuleScalingRuleMetricMetricArgs',
    'ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs',
    'ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs',
    'ApplicationScalingRuleScalingRuleTimerArgs',
    'ApplicationScalingRuleScalingRuleTimerScheduleArgs',
    'ApplicationTomcatConfigV2Args',
    'ApplicationUpdateStrategyV2Args',
    'ApplicationUpdateStrategyV2BatchUpdateArgs',
    'GreyTagRouteDubboRuleArgs',
    'GreyTagRouteDubboRuleItemArgs',
    'GreyTagRouteScRuleArgs',
    'GreyTagRouteScRuleItemArgs',
    'IngressDefaultRuleArgs',
    'IngressRuleArgs',
    'LoadBalancerInternetInternetArgs',
    'LoadBalancerIntranetIntranetArgs',
]

@pulumi.input_type
class ApplicationConfigMapMountDescV2Args:
    def __init__(__self__, *,
                 config_map_id: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_map_id: The ID of the ConfigMap.
        :param pulumi.Input[str] key: The key.
        :param pulumi.Input[str] mount_path: The mount path.
        """
        ApplicationConfigMapMountDescV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_map_id=config_map_id,
            key=key,
            mount_path=mount_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_map_id: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             mount_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configMapId' in kwargs:
            config_map_id = kwargs['configMapId']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']

        if config_map_id is not None:
            _setter("config_map_id", config_map_id)
        if key is not None:
            _setter("key", key)
        if mount_path is not None:
            _setter("mount_path", mount_path)

    @property
    @pulumi.getter(name="configMapId")
    def config_map_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the ConfigMap.
        """
        return pulumi.get(self, "config_map_id")

    @config_map_id.setter
    def config_map_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_map_id", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The mount path.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


@pulumi.input_type
class ApplicationCustomHostAliasV2Args:
    def __init__(__self__, *,
                 host_name: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_name: The domain name or hostname.
        :param pulumi.Input[str] ip: The IP address.
        """
        ApplicationCustomHostAliasV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_name=host_name,
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_name: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostName' in kwargs:
            host_name = kwargs['hostName']

        if host_name is not None:
            _setter("host_name", host_name)
        if ip is not None:
            _setter("ip", ip)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name or hostname.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class ApplicationKafkaConfigsArgs:
    def __init__(__self__, *,
                 kafka_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]] = None,
                 kafka_endpoint: Optional[pulumi.Input[str]] = None,
                 kafka_instance_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]] kafka_configs: One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        :param pulumi.Input[str] kafka_endpoint: The endpoint of the ApsaraMQ for Kafka API.
        :param pulumi.Input[str] kafka_instance_id: The  ID of the ApsaraMQ for Kafka instance.
        """
        ApplicationKafkaConfigsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kafka_configs=kafka_configs,
            kafka_endpoint=kafka_endpoint,
            kafka_instance_id=kafka_instance_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kafka_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]] = None,
             kafka_endpoint: Optional[pulumi.Input[str]] = None,
             kafka_instance_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'kafkaConfigs' in kwargs:
            kafka_configs = kwargs['kafkaConfigs']
        if 'kafkaEndpoint' in kwargs:
            kafka_endpoint = kwargs['kafkaEndpoint']
        if 'kafkaInstanceId' in kwargs:
            kafka_instance_id = kwargs['kafkaInstanceId']

        if kafka_configs is not None:
            _setter("kafka_configs", kafka_configs)
        if kafka_endpoint is not None:
            _setter("kafka_endpoint", kafka_endpoint)
        if kafka_instance_id is not None:
            _setter("kafka_instance_id", kafka_instance_id)

    @property
    @pulumi.getter(name="kafkaConfigs")
    def kafka_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]]:
        """
        One or more logging configurations of ApsaraMQ for Kafka. See `kafka_configs` below.
        """
        return pulumi.get(self, "kafka_configs")

    @kafka_configs.setter
    def kafka_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationKafkaConfigsKafkaConfigArgs']]]]):
        pulumi.set(self, "kafka_configs", value)

    @property
    @pulumi.getter(name="kafkaEndpoint")
    def kafka_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint of the ApsaraMQ for Kafka API.
        """
        return pulumi.get(self, "kafka_endpoint")

    @kafka_endpoint.setter
    def kafka_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_endpoint", value)

    @property
    @pulumi.getter(name="kafkaInstanceId")
    def kafka_instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        The  ID of the ApsaraMQ for Kafka instance.
        """
        return pulumi.get(self, "kafka_instance_id")

    @kafka_instance_id.setter
    def kafka_instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_instance_id", value)


@pulumi.input_type
class ApplicationKafkaConfigsKafkaConfigArgs:
    def __init__(__self__, *,
                 kafka_topic: Optional[pulumi.Input[str]] = None,
                 log_dir: Optional[pulumi.Input[str]] = None,
                 log_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kafka_topic: The topic of the Kafka.
        :param pulumi.Input[str] log_dir: The path in which logs are stored.
        :param pulumi.Input[str] log_type: The type of the log.
        """
        ApplicationKafkaConfigsKafkaConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kafka_topic=kafka_topic,
            log_dir=log_dir,
            log_type=log_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kafka_topic: Optional[pulumi.Input[str]] = None,
             log_dir: Optional[pulumi.Input[str]] = None,
             log_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'kafkaTopic' in kwargs:
            kafka_topic = kwargs['kafkaTopic']
        if 'logDir' in kwargs:
            log_dir = kwargs['logDir']
        if 'logType' in kwargs:
            log_type = kwargs['logType']

        if kafka_topic is not None:
            _setter("kafka_topic", kafka_topic)
        if log_dir is not None:
            _setter("log_dir", log_dir)
        if log_type is not None:
            _setter("log_type", log_type)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[pulumi.Input[str]]:
        """
        The topic of the Kafka.
        """
        return pulumi.get(self, "kafka_topic")

    @kafka_topic.setter
    def kafka_topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_topic", value)

    @property
    @pulumi.getter(name="logDir")
    def log_dir(self) -> Optional[pulumi.Input[str]]:
        """
        The path in which logs are stored.
        """
        return pulumi.get(self, "log_dir")

    @log_dir.setter
    def log_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_dir", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the log.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class ApplicationLivenessV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']] = None,
                 http_get: Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ApplicationLivenessV2ExecArgs'] exec_: Execute. See `exec` below.
        :param pulumi.Input['ApplicationLivenessV2HttpGetArgs'] http_get: The liveness check settings of the container. See `http_get` below.
        :param pulumi.Input[int] initial_delay_seconds: The delay of the health check.
        :param pulumi.Input[int] period_seconds: The interval at which the health check is performed.
        :param pulumi.Input['ApplicationLivenessV2TcpSocketArgs'] tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param pulumi.Input[int] timeout_seconds: The timeout period of the health check.
        """
        ApplicationLivenessV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']] = None,
             http_get: Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']] = None,
             initial_delay_seconds: Optional[pulumi.Input[int]] = None,
             period_seconds: Optional[pulumi.Input[int]] = None,
             tcp_socket: Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']] = None,
             timeout_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationLivenessV2ExecArgs']]):
        pulumi.set(self, "exec_", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']]:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ApplicationLivenessV2HttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']]:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ApplicationLivenessV2TcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class ApplicationLivenessV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationLivenessV2ExecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


@pulumi.input_type
class ApplicationLivenessV2HttpGetArgs:
    def __init__(__self__, *,
                 is_contain_key_word: Optional[pulumi.Input[bool]] = None,
                 key_word: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_contain_key_word: Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        :param pulumi.Input[str] key_word: The custom keywords.
        :param pulumi.Input[str] path: The request path.
        :param pulumi.Input[int] port: The port.
        :param pulumi.Input[str] scheme: The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        ApplicationLivenessV2HttpGetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_contain_key_word=is_contain_key_word,
            key_word=key_word,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_contain_key_word: Optional[pulumi.Input[bool]] = None,
             key_word: Optional[pulumi.Input[str]] = None,
             path: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             scheme: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isContainKeyWord' in kwargs:
            is_contain_key_word = kwargs['isContainKeyWord']
        if 'keyWord' in kwargs:
            key_word = kwargs['keyWord']

        if is_contain_key_word is not None:
            _setter("is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            _setter("key_word", key_word)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        """
        return pulumi.get(self, "is_contain_key_word")

    @is_contain_key_word.setter
    def is_contain_key_word(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contain_key_word", value)

    @property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[pulumi.Input[str]]:
        """
        The custom keywords.
        """
        return pulumi.get(self, "key_word")

    @key_word.setter
    def key_word(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_word", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The request path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class ApplicationLivenessV2TcpSocketArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] port: The port.
        """
        ApplicationLivenessV2TcpSocketArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class ApplicationNasConfigArgs:
    def __init__(__self__, *,
                 mount_domain: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 nas_id: Optional[pulumi.Input[str]] = None,
                 nas_path: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] mount_domain: The domain name of the mount target.
        :param pulumi.Input[str] mount_path: The mount path of the container.
        :param pulumi.Input[str] nas_id: The ID of the NAS file system.
        :param pulumi.Input[str] nas_path: The directory in the NAS file system.
        :param pulumi.Input[bool] read_only: Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        ApplicationNasConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_domain=mount_domain,
            mount_path=mount_path,
            nas_id=nas_id,
            nas_path=nas_path,
            read_only=read_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_domain: Optional[pulumi.Input[str]] = None,
             mount_path: Optional[pulumi.Input[str]] = None,
             nas_id: Optional[pulumi.Input[str]] = None,
             nas_path: Optional[pulumi.Input[str]] = None,
             read_only: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mountDomain' in kwargs:
            mount_domain = kwargs['mountDomain']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'nasId' in kwargs:
            nas_id = kwargs['nasId']
        if 'nasPath' in kwargs:
            nas_path = kwargs['nasPath']
        if 'readOnly' in kwargs:
            read_only = kwargs['readOnly']

        if mount_domain is not None:
            _setter("mount_domain", mount_domain)
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if nas_id is not None:
            _setter("nas_id", nas_id)
        if nas_path is not None:
            _setter("nas_path", nas_path)
        if read_only is not None:
            _setter("read_only", read_only)

    @property
    @pulumi.getter(name="mountDomain")
    def mount_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name of the mount target.
        """
        return pulumi.get(self, "mount_domain")

    @mount_domain.setter
    def mount_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_domain", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The mount path of the container.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="nasId")
    def nas_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the NAS file system.
        """
        return pulumi.get(self, "nas_id")

    @nas_id.setter
    def nas_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nas_id", value)

    @property
    @pulumi.getter(name="nasPath")
    def nas_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory in the NAS file system.
        """
        return pulumi.get(self, "nas_path")

    @nas_path.setter
    def nas_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nas_path", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


@pulumi.input_type
class ApplicationOssMountDescsV2Args:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 bucket_path: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket_name: The name of the OSS bucket.
        :param pulumi.Input[str] bucket_path: The directory or object in OSS.
        :param pulumi.Input[str] mount_path: The mount path.
        :param pulumi.Input[bool] read_only: Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        ApplicationOssMountDescsV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_path=bucket_path,
            mount_path=mount_path,
            read_only=read_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[pulumi.Input[str]] = None,
             bucket_path: Optional[pulumi.Input[str]] = None,
             mount_path: Optional[pulumi.Input[str]] = None,
             read_only: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if 'bucketPath' in kwargs:
            bucket_path = kwargs['bucketPath']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'readOnly' in kwargs:
            read_only = kwargs['readOnly']

        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if bucket_path is not None:
            _setter("bucket_path", bucket_path)
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if read_only is not None:
            _setter("read_only", read_only)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the OSS bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory or object in OSS.
        """
        return pulumi.get(self, "bucket_path")

    @bucket_path.setter
    def bucket_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_path", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The mount path.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the application can read data from or write data to resources in the directory of the NAS. Valid values: `true` and `false`. If you set `read_only` to `false`, the application has the read and write permissions.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


@pulumi.input_type
class ApplicationPostStartV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']] = None):
        """
        :param pulumi.Input['ApplicationPostStartV2ExecArgs'] exec_: Execute. See `exec` below.
        """
        ApplicationPostStartV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        if exec_ is not None:
            _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationPostStartV2ExecArgs']]):
        pulumi.set(self, "exec_", value)


@pulumi.input_type
class ApplicationPostStartV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationPostStartV2ExecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


@pulumi.input_type
class ApplicationPreStopV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']] = None):
        """
        :param pulumi.Input['ApplicationPreStopV2ExecArgs'] exec_: Execute. See `exec` below.
        """
        ApplicationPreStopV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        if exec_ is not None:
            _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationPreStopV2ExecArgs']]):
        pulumi.set(self, "exec_", value)


@pulumi.input_type
class ApplicationPreStopV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationPreStopV2ExecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


@pulumi.input_type
class ApplicationPvtzDiscoverySvcArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 namespace_id: Optional[pulumi.Input[str]] = None,
                 port_protocols: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable: Enables the Kubernetes Service-based registration and discovery feature.
        :param pulumi.Input[str] namespace_id: The ID of the namespace.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]] port_protocols: The port number and protocol. See `port_protocols` below.
        :param pulumi.Input[str] service_name: The name of the Service.
        """
        ApplicationPvtzDiscoverySvcArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            namespace_id=namespace_id,
            port_protocols=port_protocols,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: Optional[pulumi.Input[bool]] = None,
             namespace_id: Optional[pulumi.Input[str]] = None,
             port_protocols: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]] = None,
             service_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'portProtocols' in kwargs:
            port_protocols = kwargs['portProtocols']
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        if enable is not None:
            _setter("enable", enable)
        if namespace_id is not None:
            _setter("namespace_id", namespace_id)
        if port_protocols is not None:
            _setter("port_protocols", port_protocols)
        if service_name is not None:
            _setter("service_name", service_name)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the Kubernetes Service-based registration and discovery feature.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter(name="portProtocols")
    def port_protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]]:
        """
        The port number and protocol. See `port_protocols` below.
        """
        return pulumi.get(self, "port_protocols")

    @port_protocols.setter
    def port_protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationPvtzDiscoverySvcPortProtocolArgs']]]]):
        pulumi.set(self, "port_protocols", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class ApplicationPvtzDiscoverySvcPortProtocolArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: The port.
        :param pulumi.Input[str] protocol: The protocol. Valid values: `TCP` and `UDP`.
        """
        ApplicationPvtzDiscoverySvcPortProtocolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[pulumi.Input[int]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol. Valid values: `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class ApplicationReadinessV2Args:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']] = None,
                 http_get: Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ApplicationReadinessV2ExecArgs'] exec_: Execute. See `exec` below.
        :param pulumi.Input['ApplicationReadinessV2HttpGetArgs'] http_get: The liveness check settings of the container. See `http_get` below.
        :param pulumi.Input[int] initial_delay_seconds: The delay of the health check.
        :param pulumi.Input[int] period_seconds: The interval at which the health check is performed.
        :param pulumi.Input['ApplicationReadinessV2TcpSocketArgs'] tcp_socket: The liveness check settings of the container. See `tcp_socket` below.
        :param pulumi.Input[int] timeout_seconds: The timeout period of the health check.
        """
        ApplicationReadinessV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']] = None,
             http_get: Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']] = None,
             initial_delay_seconds: Optional[pulumi.Input[int]] = None,
             period_seconds: Optional[pulumi.Input[int]] = None,
             tcp_socket: Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']] = None,
             timeout_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']]:
        """
        Execute. See `exec` below.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['ApplicationReadinessV2ExecArgs']]):
        pulumi.set(self, "exec_", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']]:
        """
        The liveness check settings of the container. See `http_get` below.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ApplicationReadinessV2HttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The delay of the health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which the health check is performed.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']]:
        """
        The liveness check settings of the container. See `tcp_socket` below.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ApplicationReadinessV2TcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout period of the health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class ApplicationReadinessV2ExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        ApplicationReadinessV2ExecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if commands is not None:
            _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


@pulumi.input_type
class ApplicationReadinessV2HttpGetArgs:
    def __init__(__self__, *,
                 is_contain_key_word: Optional[pulumi.Input[bool]] = None,
                 key_word: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_contain_key_word: Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        :param pulumi.Input[str] key_word: The custom keywords.
        :param pulumi.Input[str] path: The request path.
        :param pulumi.Input[int] port: The port.
        :param pulumi.Input[str] scheme: The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        ApplicationReadinessV2HttpGetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_contain_key_word=is_contain_key_word,
            key_word=key_word,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_contain_key_word: Optional[pulumi.Input[bool]] = None,
             key_word: Optional[pulumi.Input[str]] = None,
             path: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             scheme: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isContainKeyWord' in kwargs:
            is_contain_key_word = kwargs['isContainKeyWord']
        if 'keyWord' in kwargs:
            key_word = kwargs['keyWord']

        if is_contain_key_word is not None:
            _setter("is_contain_key_word", is_contain_key_word)
        if key_word is not None:
            _setter("key_word", key_word)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="isContainKeyWord")
    def is_contain_key_word(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the response contains keywords. Valid values: `true` and `false`. If you do not set it, the advanced settings are not used.
        """
        return pulumi.get(self, "is_contain_key_word")

    @is_contain_key_word.setter
    def is_contain_key_word(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contain_key_word", value)

    @property
    @pulumi.getter(name="keyWord")
    def key_word(self) -> Optional[pulumi.Input[str]]:
        """
        The custom keywords.
        """
        return pulumi.get(self, "key_word")

    @key_word.setter
    def key_word(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_word", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The request path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol that is used to perform the health check. Valid values: `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class ApplicationReadinessV2TcpSocketArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] port: The port.
        """
        ApplicationReadinessV2TcpSocketArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None,
                 scale_down_rules: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']] = None,
                 scale_up_rules: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']] = None):
        """
        :param pulumi.Input[int] max_replicas: Maximum number of instances applied.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]] metrics: Indicator rule configuration. See `metrics` below.
        :param pulumi.Input[int] min_replicas: Minimum number of instances applied.
        :param pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs'] scale_down_rules: Apply shrink rules. See `scale_down_rules` below.
        :param pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs'] scale_up_rules: Apply expansion rules. See `scale_up_rules` below.
        """
        ApplicationScalingRuleScalingRuleMetricArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_replicas=max_replicas,
            metrics=metrics,
            min_replicas=min_replicas,
            scale_down_rules=scale_down_rules,
            scale_up_rules=scale_up_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_replicas: Optional[pulumi.Input[int]] = None,
             metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]] = None,
             min_replicas: Optional[pulumi.Input[int]] = None,
             scale_down_rules: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']] = None,
             scale_up_rules: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'scaleDownRules' in kwargs:
            scale_down_rules = kwargs['scaleDownRules']
        if 'scaleUpRules' in kwargs:
            scale_up_rules = kwargs['scaleUpRules']

        if max_replicas is not None:
            _setter("max_replicas", max_replicas)
        if metrics is not None:
            _setter("metrics", metrics)
        if min_replicas is not None:
            _setter("min_replicas", min_replicas)
        if scale_down_rules is not None:
            _setter("scale_down_rules", scale_down_rules)
        if scale_up_rules is not None:
            _setter("scale_up_rules", scale_up_rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of instances applied.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]]:
        """
        Indicator rule configuration. See `metrics` below.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleMetricMetricArgs']]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of instances applied.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter(name="scaleDownRules")
    def scale_down_rules(self) -> Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']]:
        """
        Apply shrink rules. See `scale_down_rules` below.
        """
        return pulumi.get(self, "scale_down_rules")

    @scale_down_rules.setter
    def scale_down_rules(self, value: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs']]):
        pulumi.set(self, "scale_down_rules", value)

    @property
    @pulumi.getter(name="scaleUpRules")
    def scale_up_rules(self) -> Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']]:
        """
        Apply expansion rules. See `scale_up_rules` below.
        """
        return pulumi.get(self, "scale_up_rules")

    @scale_up_rules.setter
    def scale_up_rules(self, value: Optional[pulumi.Input['ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs']]):
        pulumi.set(self, "scale_up_rules", value)


@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricMetricArgs:
    def __init__(__self__, *,
                 metric_target_average_utilization: Optional[pulumi.Input[int]] = None,
                 metric_type: Optional[pulumi.Input[str]] = None,
                 slb_id: Optional[pulumi.Input[str]] = None,
                 slb_log_store: Optional[pulumi.Input[str]] = None,
                 slb_project: Optional[pulumi.Input[str]] = None,
                 vport: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] metric_target_average_utilization: According to different `metric_type`, set the target value of the corresponding monitoring index.
        :param pulumi.Input[str] metric_type: Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
               - CPU: CPU usage.
               - MEMORY: MEMORY usage.
               - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
               - QPS: The average QPS of a single instance within 1 minute of JAVA application.
               - RT: The average response time of all service interfaces within 1 minute of JAVA application.
               - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
               - SLB_RT: The average response time of public network SLB within 15 seconds.
               - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
               - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
               **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        :param pulumi.Input[str] slb_id: SLB ID.
        :param pulumi.Input[str] slb_log_store: The log store of the Log Service.
        :param pulumi.Input[str] slb_project: The project of the Log Service.
        :param pulumi.Input[str] vport: SLB listening port.
        """
        ApplicationScalingRuleScalingRuleMetricMetricArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_target_average_utilization=metric_target_average_utilization,
            metric_type=metric_type,
            slb_id=slb_id,
            slb_log_store=slb_log_store,
            slb_project=slb_project,
            vport=vport,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_target_average_utilization: Optional[pulumi.Input[int]] = None,
             metric_type: Optional[pulumi.Input[str]] = None,
             slb_id: Optional[pulumi.Input[str]] = None,
             slb_log_store: Optional[pulumi.Input[str]] = None,
             slb_project: Optional[pulumi.Input[str]] = None,
             vport: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'metricTargetAverageUtilization' in kwargs:
            metric_target_average_utilization = kwargs['metricTargetAverageUtilization']
        if 'metricType' in kwargs:
            metric_type = kwargs['metricType']
        if 'slbId' in kwargs:
            slb_id = kwargs['slbId']
        if 'slbLogStore' in kwargs:
            slb_log_store = kwargs['slbLogStore']
        if 'slbProject' in kwargs:
            slb_project = kwargs['slbProject']

        if metric_target_average_utilization is not None:
            _setter("metric_target_average_utilization", metric_target_average_utilization)
        if metric_type is not None:
            _setter("metric_type", metric_type)
        if slb_id is not None:
            _setter("slb_id", slb_id)
        if slb_log_store is not None:
            _setter("slb_log_store", slb_log_store)
        if slb_project is not None:
            _setter("slb_project", slb_project)
        if vport is not None:
            _setter("vport", vport)

    @property
    @pulumi.getter(name="metricTargetAverageUtilization")
    def metric_target_average_utilization(self) -> Optional[pulumi.Input[int]]:
        """
        According to different `metric_type`, set the target value of the corresponding monitoring index.
        """
        return pulumi.get(self, "metric_target_average_utilization")

    @metric_target_average_utilization.setter
    def metric_target_average_utilization(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric_target_average_utilization", value)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring indicator trigger condition. Valid values: `CPU`, `MEMORY`, `tcpActiveConn`, `QPS`, `RT`, `SLB_QPS`, `SLB_RT`, `INTRANET_SLB_QPS` and `INTRANET_SLB_RT`. The values are described as follows:
        - CPU: CPU usage.
        - MEMORY: MEMORY usage.
        - tcpActiveConn: The average number of TCP active connections for a single instance in 30 seconds.
        - QPS: The average QPS of a single instance within 1 minute of JAVA application.
        - RT: The average response time of all service interfaces within 1 minute of JAVA application.
        - SLB_QPS: The average public network SLB QPS of a single instance within 15 seconds.
        - SLB_RT: The average response time of public network SLB within 15 seconds.
        - INTRANET_SLB_QPS: The average private network SLB QPS of a single instance within 15 seconds.
        - INTRANET_SLB_RT: The average response time of private network SLB within 15 seconds.
        **NOTE:** From version 1.206.0, `metric_type` can be set to `QPS`, `RT`, `INTRANET_SLB_QPS`, `INTRANET_SLB_RT`.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter(name="slbId")
    def slb_id(self) -> Optional[pulumi.Input[str]]:
        """
        SLB ID.
        """
        return pulumi.get(self, "slb_id")

    @slb_id.setter
    def slb_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slb_id", value)

    @property
    @pulumi.getter(name="slbLogStore")
    def slb_log_store(self) -> Optional[pulumi.Input[str]]:
        """
        The log store of the Log Service.
        """
        return pulumi.get(self, "slb_log_store")

    @slb_log_store.setter
    def slb_log_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slb_log_store", value)

    @property
    @pulumi.getter(name="slbProject")
    def slb_project(self) -> Optional[pulumi.Input[str]]:
        """
        The project of the Log Service.
        """
        return pulumi.get(self, "slb_project")

    @slb_project.setter
    def slb_project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slb_project", value)

    @property
    @pulumi.getter
    def vport(self) -> Optional[pulumi.Input[str]]:
        """
        SLB listening port.
        """
        return pulumi.get(self, "vport")

    @vport.setter
    def vport(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vport", value)


@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[int]] = None,
                 step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: Whether shrinkage is prohibited.
        :param pulumi.Input[int] stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param pulumi.Input[int] step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        ApplicationScalingRuleScalingRuleMetricScaleDownRulesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled=disabled,
            stabilization_window_seconds=stabilization_window_seconds,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled: Optional[pulumi.Input[bool]] = None,
             stabilization_window_seconds: Optional[pulumi.Input[int]] = None,
             step: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stabilizationWindowSeconds' in kwargs:
            stabilization_window_seconds = kwargs['stabilizationWindowSeconds']

        if disabled is not None:
            _setter("disabled", disabled)
        if stabilization_window_seconds is not None:
            _setter("stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            _setter("step", step)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stabilization_window_seconds", value)

    @property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[int]]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "step", value)


@pulumi.input_type
class ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[int]] = None,
                 step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: Whether shrinkage is prohibited.
        :param pulumi.Input[int] stabilization_window_seconds: Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        :param pulumi.Input[int] step: Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        ApplicationScalingRuleScalingRuleMetricScaleUpRulesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled=disabled,
            stabilization_window_seconds=stabilization_window_seconds,
            step=step,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled: Optional[pulumi.Input[bool]] = None,
             stabilization_window_seconds: Optional[pulumi.Input[int]] = None,
             step: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stabilizationWindowSeconds' in kwargs:
            stabilization_window_seconds = kwargs['stabilizationWindowSeconds']

        if disabled is not None:
            _setter("disabled", disabled)
        if stabilization_window_seconds is not None:
            _setter("stabilization_window_seconds", stabilization_window_seconds)
        if step is not None:
            _setter("step", step)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether shrinkage is prohibited.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Cooling time for expansion or contraction. Valid values: `0` to `3600`. Unit: seconds. The default is `0` seconds.
        """
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stabilization_window_seconds", value)

    @property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[int]]:
        """
        Elastic expansion or contraction step size. the maximum number of instances to be scaled in per unit time.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "step", value)


@pulumi.input_type
class ApplicationScalingRuleScalingRuleTimerArgs:
    def __init__(__self__, *,
                 begin_date: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] begin_date: The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param pulumi.Input[str] end_date: The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        :param pulumi.Input[str] period: The period in which a timed elastic scaling strategy is executed.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]] schedules: Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        ApplicationScalingRuleScalingRuleTimerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            begin_date=begin_date,
            end_date=end_date,
            period=period,
            schedules=schedules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             begin_date: Optional[pulumi.Input[str]] = None,
             end_date: Optional[pulumi.Input[str]] = None,
             period: Optional[pulumi.Input[str]] = None,
             schedules: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'beginDate' in kwargs:
            begin_date = kwargs['beginDate']
        if 'endDate' in kwargs:
            end_date = kwargs['endDate']

        if begin_date is not None:
            _setter("begin_date", begin_date)
        if end_date is not None:
            _setter("end_date", end_date)
        if period is not None:
            _setter("period", period)
        if schedules is not None:
            _setter("schedules", schedules)

    @property
    @pulumi.getter(name="beginDate")
    def begin_date(self) -> Optional[pulumi.Input[str]]:
        """
        The Start date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "begin_date")

    @begin_date.setter
    def begin_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "begin_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The End Date. When the `begin_date` and `end_date` values are empty. it indicates long-term execution and is the default value.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[str]]:
        """
        The period in which a timed elastic scaling strategy is executed.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]]:
        """
        Resilient Scaling Strategy Trigger Timing. See `schedules` below.
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationScalingRuleScalingRuleTimerScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)


@pulumi.input_type
class ApplicationScalingRuleScalingRuleTimerScheduleArgs:
    def __init__(__self__, *,
                 at_time: Optional[pulumi.Input[str]] = None,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None,
                 target_replicas: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] at_time: Trigger point in time. When supporting format: minutes, for example: `08:00`.
        :param pulumi.Input[int] max_replicas: Maximum number of instances applied.
        :param pulumi.Input[int] min_replicas: Minimum number of instances applied.
        :param pulumi.Input[int] target_replicas: This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        ApplicationScalingRuleScalingRuleTimerScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            at_time=at_time,
            max_replicas=max_replicas,
            min_replicas=min_replicas,
            target_replicas=target_replicas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             at_time: Optional[pulumi.Input[str]] = None,
             max_replicas: Optional[pulumi.Input[int]] = None,
             min_replicas: Optional[pulumi.Input[int]] = None,
             target_replicas: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'atTime' in kwargs:
            at_time = kwargs['atTime']
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']
        if 'targetReplicas' in kwargs:
            target_replicas = kwargs['targetReplicas']

        if at_time is not None:
            _setter("at_time", at_time)
        if max_replicas is not None:
            _setter("max_replicas", max_replicas)
        if min_replicas is not None:
            _setter("min_replicas", min_replicas)
        if target_replicas is not None:
            _setter("target_replicas", target_replicas)

    @property
    @pulumi.getter(name="atTime")
    def at_time(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger point in time. When supporting format: minutes, for example: `08:00`.
        """
        return pulumi.get(self, "at_time")

    @at_time.setter
    def at_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "at_time", value)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of instances applied.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of instances applied.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter(name="targetReplicas")
    def target_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        This parameter can specify the number of instances to be applied or the minimum number of surviving instances per deployment. value range [1,50]. > **NOTE:** The attribute is valid when the attribute `scaling_rule_type` is `timing`.
        """
        return pulumi.get(self, "target_replicas")

    @target_replicas.setter
    def target_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_replicas", value)


@pulumi.input_type
class ApplicationTomcatConfigV2Args:
    def __init__(__self__, *,
                 context_path: Optional[pulumi.Input[str]] = None,
                 max_threads: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 uri_encoding: Optional[pulumi.Input[str]] = None,
                 use_body_encoding_for_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context_path: The path.
        :param pulumi.Input[int] max_threads: The maximum number of connections in the connection pool.
        :param pulumi.Input[int] port: The port.
        :param pulumi.Input[str] uri_encoding: The URI encoding scheme in the Tomcat container.
        :param pulumi.Input[str] use_body_encoding_for_uri: Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        ApplicationTomcatConfigV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            context_path=context_path,
            max_threads=max_threads,
            port=port,
            uri_encoding=uri_encoding,
            use_body_encoding_for_uri=use_body_encoding_for_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             context_path: Optional[pulumi.Input[str]] = None,
             max_threads: Optional[pulumi.Input[int]] = None,
             port: Optional[pulumi.Input[int]] = None,
             uri_encoding: Optional[pulumi.Input[str]] = None,
             use_body_encoding_for_uri: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'contextPath' in kwargs:
            context_path = kwargs['contextPath']
        if 'maxThreads' in kwargs:
            max_threads = kwargs['maxThreads']
        if 'uriEncoding' in kwargs:
            uri_encoding = kwargs['uriEncoding']
        if 'useBodyEncodingForUri' in kwargs:
            use_body_encoding_for_uri = kwargs['useBodyEncodingForUri']

        if context_path is not None:
            _setter("context_path", context_path)
        if max_threads is not None:
            _setter("max_threads", max_threads)
        if port is not None:
            _setter("port", port)
        if uri_encoding is not None:
            _setter("uri_encoding", uri_encoding)
        if use_body_encoding_for_uri is not None:
            _setter("use_body_encoding_for_uri", use_body_encoding_for_uri)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path.
        """
        return pulumi.get(self, "context_path")

    @context_path.setter
    def context_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_path", value)

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of connections in the connection pool.
        """
        return pulumi.get(self, "max_threads")

    @max_threads.setter
    def max_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_threads", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="uriEncoding")
    def uri_encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The URI encoding scheme in the Tomcat container.
        """
        return pulumi.get(self, "uri_encoding")

    @uri_encoding.setter
    def uri_encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri_encoding", value)

    @property
    @pulumi.getter(name="useBodyEncodingForUri")
    def use_body_encoding_for_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to use the encoding scheme that is specified by BodyEncoding for URL.
        """
        return pulumi.get(self, "use_body_encoding_for_uri")

    @use_body_encoding_for_uri.setter
    def use_body_encoding_for_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_body_encoding_for_uri", value)


@pulumi.input_type
class ApplicationUpdateStrategyV2Args:
    def __init__(__self__, *,
                 batch_update: Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs'] batch_update: The phased release policy. See `batch_update` below.
        :param pulumi.Input[str] type: The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        ApplicationUpdateStrategyV2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_update=batch_update,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_update: Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'batchUpdate' in kwargs:
            batch_update = kwargs['batchUpdate']

        if batch_update is not None:
            _setter("batch_update", batch_update)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="batchUpdate")
    def batch_update(self) -> Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']]:
        """
        The phased release policy. See `batch_update` below.
        """
        return pulumi.get(self, "batch_update")

    @batch_update.setter
    def batch_update(self, value: Optional[pulumi.Input['ApplicationUpdateStrategyV2BatchUpdateArgs']]):
        pulumi.set(self, "batch_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the release policy. Valid values: `GrayBatchUpdate` and `BatchUpdate`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApplicationUpdateStrategyV2BatchUpdateArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input[int]] = None,
                 batch_wait_time: Optional[pulumi.Input[int]] = None,
                 release_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] batch: The number of batches in which you want to release the instances.
        :param pulumi.Input[int] batch_wait_time: The batch wait time.
        :param pulumi.Input[str] release_type: The processing method for the batches. Valid values: `auto` and `manual`.
        """
        ApplicationUpdateStrategyV2BatchUpdateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch=batch,
            batch_wait_time=batch_wait_time,
            release_type=release_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch: Optional[pulumi.Input[int]] = None,
             batch_wait_time: Optional[pulumi.Input[int]] = None,
             release_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'batchWaitTime' in kwargs:
            batch_wait_time = kwargs['batchWaitTime']
        if 'releaseType' in kwargs:
            release_type = kwargs['releaseType']

        if batch is not None:
            _setter("batch", batch)
        if batch_wait_time is not None:
            _setter("batch_wait_time", batch_wait_time)
        if release_type is not None:
            _setter("release_type", release_type)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input[int]]:
        """
        The number of batches in which you want to release the instances.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="batchWaitTime")
    def batch_wait_time(self) -> Optional[pulumi.Input[int]]:
        """
        The batch wait time.
        """
        return pulumi.get(self, "batch_wait_time")

    @batch_wait_time.setter
    def batch_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_wait_time", value)

    @property
    @pulumi.getter(name="releaseType")
    def release_type(self) -> Optional[pulumi.Input[str]]:
        """
        The processing method for the batches. Valid values: `auto` and `manual`.
        """
        return pulumi.get(self, "release_type")

    @release_type.setter
    def release_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "release_type", value)


@pulumi.input_type
class GreyTagRouteDubboRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]] = None,
                 method_name: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param pulumi.Input[str] group: The service group.
        :param pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]] items: A list of conditions items. See `items` below.
        :param pulumi.Input[str] method_name: The method name
        :param pulumi.Input[str] service_name: The service name.
        :param pulumi.Input[str] version: The service version.
        """
        GreyTagRouteDubboRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            group=group,
            items=items,
            method_name=method_name,
            service_name=service_name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[pulumi.Input[str]] = None,
             group: Optional[pulumi.Input[str]] = None,
             items: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]] = None,
             method_name: Optional[pulumi.Input[str]] = None,
             service_name: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'methodName' in kwargs:
            method_name = kwargs['methodName']
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        if condition is not None:
            _setter("condition", condition)
        if group is not None:
            _setter("group", group)
        if items is not None:
            _setter("items", items)
        if method_name is not None:
            _setter("method_name", method_name)
        if service_name is not None:
            _setter("service_name", service_name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The Conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The service group.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteDubboRuleItemArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> Optional[pulumi.Input[str]]:
        """
        The method name
        """
        return pulumi.get(self, "method_name")

    @method_name.setter
    def method_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method_name", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The service name.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The service version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class GreyTagRouteDubboRuleItemArgs:
    def __init__(__self__, *,
                 cond: Optional[pulumi.Input[str]] = None,
                 expr: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cond: The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        :param pulumi.Input[str] expr: The parameter value gets the expression.
        :param pulumi.Input[int] index: The parameter number.
        :param pulumi.Input[str] operator: The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        :param pulumi.Input[str] value: The value of the parameter.
        """
        GreyTagRouteDubboRuleItemArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cond=cond,
            expr=expr,
            index=index,
            operator=operator,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cond: Optional[pulumi.Input[str]] = None,
             expr: Optional[pulumi.Input[str]] = None,
             index: Optional[pulumi.Input[int]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cond is not None:
            _setter("cond", cond)
        if expr is not None:
            _setter("expr", expr)
        if index is not None:
            _setter("index", index)
        if operator is not None:
            _setter("operator", operator)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def cond(self) -> Optional[pulumi.Input[str]]:
        """
        The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        """
        return pulumi.get(self, "cond")

    @cond.setter
    def cond(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cond", value)

    @property
    @pulumi.getter
    def expr(self) -> Optional[pulumi.Input[str]]:
        """
        The parameter value gets the expression.
        """
        return pulumi.get(self, "expr")

    @expr.setter
    def expr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expr", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        The parameter number.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GreyTagRouteScRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        :param pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]] items: A list of conditions items. See `items` below.
        :param pulumi.Input[str] path: The path corresponding to the grayscale rule.
        """
        GreyTagRouteScRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            items=items,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[pulumi.Input[str]] = None,
             items: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]] = None,
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if condition is not None:
            _setter("condition", condition)
        if items is not None:
            _setter("items", items)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The conditional Patterns for Grayscale Rules. Valid values: `AND`, `OR`.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]]:
        """
        A list of conditions items. See `items` below.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GreyTagRouteScRuleItemArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path corresponding to the grayscale rule.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class GreyTagRouteScRuleItemArgs:
    def __init__(__self__, *,
                 cond: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cond: The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        :param pulumi.Input[str] name: The name of the parameter.
        :param pulumi.Input[str] operator: The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        :param pulumi.Input[str] type: The compare types. Valid values: `param`, `cookie`, `header`.
        :param pulumi.Input[str] value: The value of the parameter.
        """
        GreyTagRouteScRuleItemArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cond=cond,
            name=name,
            operator=operator,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cond: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cond is not None:
            _setter("cond", cond)
        if name is not None:
            _setter("name", name)
        if operator is not None:
            _setter("operator", operator)
        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def cond(self) -> Optional[pulumi.Input[str]]:
        """
        The comparison operator. Valid values: `>`, `<`, `>=`, `<=`, `==`, `!=`.
        """
        return pulumi.get(self, "cond")

    @cond.setter
    def cond(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cond", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator. Valid values: `rawvalue`, `list`, `mod`, `deterministic_proportional_steaming_division`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The compare types. Valid values: `param`, `cookie`, `header`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class IngressDefaultRuleArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_name: Optional[pulumi.Input[str]] = None,
                 container_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] app_id: Target application ID.
        :param pulumi.Input[str] app_name: Target application name.
        :param pulumi.Input[int] container_port: Application backend port.
        """
        IngressDefaultRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_name=app_name,
            container_port=container_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: Optional[pulumi.Input[str]] = None,
             app_name: Optional[pulumi.Input[str]] = None,
             container_port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appName' in kwargs:
            app_name = kwargs['appName']
        if 'containerPort' in kwargs:
            container_port = kwargs['containerPort']

        if app_id is not None:
            _setter("app_id", app_id)
        if app_name is not None:
            _setter("app_name", app_name)
        if container_port is not None:
            _setter("container_port", container_port)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_name", value)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[int]]:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_port", value)


@pulumi.input_type
class IngressRuleArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_name: pulumi.Input[str],
                 container_port: pulumi.Input[int],
                 domain: pulumi.Input[str],
                 path: pulumi.Input[str],
                 backend_protocol: Optional[pulumi.Input[str]] = None,
                 rewrite_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] app_id: Target application ID.
        :param pulumi.Input[str] app_name: Target application name.
        :param pulumi.Input[int] container_port: Application backend port.
        :param pulumi.Input[str] domain: Application domain name.
        :param pulumi.Input[str] path: URL path.
        :param pulumi.Input[str] backend_protocol: The backend protocol.
        :param pulumi.Input[str] rewrite_path: The rewrite path.
        """
        IngressRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_name=app_name,
            container_port=container_port,
            domain=domain,
            path=path,
            backend_protocol=backend_protocol,
            rewrite_path=rewrite_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: pulumi.Input[str],
             app_name: pulumi.Input[str],
             container_port: pulumi.Input[int],
             domain: pulumi.Input[str],
             path: pulumi.Input[str],
             backend_protocol: Optional[pulumi.Input[str]] = None,
             rewrite_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appName' in kwargs:
            app_name = kwargs['appName']
        if 'containerPort' in kwargs:
            container_port = kwargs['containerPort']
        if 'backendProtocol' in kwargs:
            backend_protocol = kwargs['backendProtocol']
        if 'rewritePath' in kwargs:
            rewrite_path = kwargs['rewritePath']

        _setter("app_id", app_id)
        _setter("app_name", app_name)
        _setter("container_port", container_port)
        _setter("domain", domain)
        _setter("path", path)
        if backend_protocol is not None:
            _setter("backend_protocol", backend_protocol)
        if rewrite_path is not None:
            _setter("rewrite_path", rewrite_path)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        Target application ID.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> pulumi.Input[str]:
        """
        Target application name.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_name", value)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[int]:
        """
        Application backend port.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "container_port", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Application domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        URL path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The backend protocol.
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_protocol", value)

    @property
    @pulumi.getter(name="rewritePath")
    def rewrite_path(self) -> Optional[pulumi.Input[str]]:
        """
        The rewrite path.
        """
        return pulumi.get(self, "rewrite_path")

    @rewrite_path.setter
    def rewrite_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rewrite_path", value)


@pulumi.input_type
class LoadBalancerInternetInternetArgs:
    def __init__(__self__, *,
                 https_cert_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param pulumi.Input[int] port: The SLB Port.
        :param pulumi.Input[str] protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param pulumi.Input[int] target_port: The Container port.
        """
        LoadBalancerInternetInternetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https_cert_id=https_cert_id,
            port=port,
            protocol=protocol,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https_cert_id: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             target_port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpsCertId' in kwargs:
            https_cert_id = kwargs['httpsCertId']
        if 'targetPort' in kwargs:
            target_port = kwargs['targetPort']

        if https_cert_id is not None:
            _setter("https_cert_id", https_cert_id)
        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)
        if target_port is not None:
            _setter("target_port", target_port)

    @property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[pulumi.Input[str]]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @https_cert_id.setter
    def https_cert_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_cert_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


@pulumi.input_type
class LoadBalancerIntranetIntranetArgs:
    def __init__(__self__, *,
                 https_cert_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] https_cert_id: The SSL certificate. `https_cert_id` is required when HTTPS is selected
        :param pulumi.Input[int] port: The SLB Port.
        :param pulumi.Input[str] protocol: The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        :param pulumi.Input[int] target_port: The Container port.
        """
        LoadBalancerIntranetIntranetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https_cert_id=https_cert_id,
            port=port,
            protocol=protocol,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https_cert_id: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             target_port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpsCertId' in kwargs:
            https_cert_id = kwargs['httpsCertId']
        if 'targetPort' in kwargs:
            target_port = kwargs['targetPort']

        if https_cert_id is not None:
            _setter("https_cert_id", https_cert_id)
        if port is not None:
            _setter("port", port)
        if protocol is not None:
            _setter("protocol", protocol)
        if target_port is not None:
            _setter("target_port", target_port)

    @property
    @pulumi.getter(name="httpsCertId")
    def https_cert_id(self) -> Optional[pulumi.Input[str]]:
        """
        The SSL certificate. `https_cert_id` is required when HTTPS is selected
        """
        return pulumi.get(self, "https_cert_id")

    @https_cert_id.setter
    def https_cert_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_cert_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The SLB Port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        """
        The Container port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


