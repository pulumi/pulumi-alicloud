# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccessPointPosixUserArgs',
    'AccessPointPosixUserArgsDict',
    'AccessPointRootPathPermissionArgs',
    'AccessPointRootPathPermissionArgsDict',
    'FileSystemNfsAclArgs',
    'FileSystemNfsAclArgsDict',
    'FileSystemOptionsArgs',
    'FileSystemOptionsArgsDict',
    'FileSystemRecycleBinArgs',
    'FileSystemRecycleBinArgsDict',
    'FileSystemSmbAclArgs',
    'FileSystemSmbAclArgsDict',
]

MYPY = False

if not MYPY:
    class AccessPointPosixUserArgsDict(TypedDict):
        posix_group_id: NotRequired[pulumi.Input[builtins.int]]
        """
        The ID of the Posix user group.
        """
        posix_secondary_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        The ID of the second user group.
        """
        posix_user_id: NotRequired[pulumi.Input[builtins.int]]
        """
        The Posix user ID.
        """
elif False:
    AccessPointPosixUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPointPosixUserArgs:
    def __init__(__self__, *,
                 posix_group_id: Optional[pulumi.Input[builtins.int]] = None,
                 posix_secondary_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 posix_user_id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] posix_group_id: The ID of the Posix user group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] posix_secondary_group_ids: The ID of the second user group.
        :param pulumi.Input[builtins.int] posix_user_id: The Posix user ID.
        """
        if posix_group_id is not None:
            pulumi.set(__self__, "posix_group_id", posix_group_id)
        if posix_secondary_group_ids is not None:
            pulumi.set(__self__, "posix_secondary_group_ids", posix_secondary_group_ids)
        if posix_user_id is not None:
            pulumi.set(__self__, "posix_user_id", posix_user_id)

    @property
    @pulumi.getter(name="posixGroupId")
    def posix_group_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The ID of the Posix user group.
        """
        return pulumi.get(self, "posix_group_id")

    @posix_group_id.setter
    def posix_group_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "posix_group_id", value)

    @property
    @pulumi.getter(name="posixSecondaryGroupIds")
    def posix_secondary_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        The ID of the second user group.
        """
        return pulumi.get(self, "posix_secondary_group_ids")

    @posix_secondary_group_ids.setter
    def posix_secondary_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "posix_secondary_group_ids", value)

    @property
    @pulumi.getter(name="posixUserId")
    def posix_user_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The Posix user ID.
        """
        return pulumi.get(self, "posix_user_id")

    @posix_user_id.setter
    def posix_user_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "posix_user_id", value)


if not MYPY:
    class AccessPointRootPathPermissionArgsDict(TypedDict):
        owner_group_id: NotRequired[pulumi.Input[builtins.int]]
        """
        The ID of the primary user group.
        """
        owner_user_id: NotRequired[pulumi.Input[builtins.int]]
        """
        The owner user ID.
        """
        permission: NotRequired[pulumi.Input[builtins.str]]
        """
        POSIX permission.
        """
elif False:
    AccessPointRootPathPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPointRootPathPermissionArgs:
    def __init__(__self__, *,
                 owner_group_id: Optional[pulumi.Input[builtins.int]] = None,
                 owner_user_id: Optional[pulumi.Input[builtins.int]] = None,
                 permission: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] owner_group_id: The ID of the primary user group.
        :param pulumi.Input[builtins.int] owner_user_id: The owner user ID.
        :param pulumi.Input[builtins.str] permission: POSIX permission.
        """
        if owner_group_id is not None:
            pulumi.set(__self__, "owner_group_id", owner_group_id)
        if owner_user_id is not None:
            pulumi.set(__self__, "owner_user_id", owner_user_id)
        if permission is not None:
            pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="ownerGroupId")
    def owner_group_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The ID of the primary user group.
        """
        return pulumi.get(self, "owner_group_id")

    @owner_group_id.setter
    def owner_group_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "owner_group_id", value)

    @property
    @pulumi.getter(name="ownerUserId")
    def owner_user_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The owner user ID.
        """
        return pulumi.get(self, "owner_user_id")

    @owner_user_id.setter
    def owner_user_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "owner_user_id", value)

    @property
    @pulumi.getter
    def permission(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        POSIX permission.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class FileSystemNfsAclArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the NFS ACL function is enabled.
        """
elif False:
    FileSystemNfsAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemNfsAclArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the NFS ACL function is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the NFS ACL function is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class FileSystemOptionsArgsDict(TypedDict):
        enable_oplock: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable the OpLock function. Value:
        - true: On.
        - false: does not turn on.

        > **NOTE:**  Description Only file systems of the SMB protocol type are supported.
        """
elif False:
    FileSystemOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemOptionsArgs:
    def __init__(__self__, *,
                 enable_oplock: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_oplock: Whether to enable the OpLock function. Value:
               - true: On.
               - false: does not turn on.
               
               > **NOTE:**  Description Only file systems of the SMB protocol type are supported.
        """
        if enable_oplock is not None:
            pulumi.set(__self__, "enable_oplock", enable_oplock)

    @property
    @pulumi.getter(name="enableOplock")
    def enable_oplock(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable the OpLock function. Value:
        - true: On.
        - false: does not turn on.

        > **NOTE:**  Description Only file systems of the SMB protocol type are supported.
        """
        return pulumi.get(self, "enable_oplock")

    @enable_oplock.setter
    def enable_oplock(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_oplock", value)


if not MYPY:
    class FileSystemRecycleBinArgsDict(TypedDict):
        enable_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Recycle Bin open time
        """
        reserved_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Retention time of files in the Recycle Bin. Unit: days.
        """
        secondary_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of low-frequency data stored in the recycle bin. Unit: Byte.
        """
        size: NotRequired[pulumi.Input[builtins.int]]
        """
        The amount of files stored in the Recycle Bin. Unit: Byte.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Recycle Bin Status
        """
elif False:
    FileSystemRecycleBinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemRecycleBinArgs:
    def __init__(__self__, *,
                 enable_time: Optional[pulumi.Input[builtins.str]] = None,
                 reserved_days: Optional[pulumi.Input[builtins.int]] = None,
                 secondary_size: Optional[pulumi.Input[builtins.int]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] enable_time: Recycle Bin open time
        :param pulumi.Input[builtins.int] reserved_days: Retention time of files in the Recycle Bin. Unit: days.
        :param pulumi.Input[builtins.int] secondary_size: Amount of low-frequency data stored in the recycle bin. Unit: Byte.
        :param pulumi.Input[builtins.int] size: The amount of files stored in the Recycle Bin. Unit: Byte.
        :param pulumi.Input[builtins.str] status: Recycle Bin Status
        """
        if enable_time is not None:
            pulumi.set(__self__, "enable_time", enable_time)
        if reserved_days is not None:
            pulumi.set(__self__, "reserved_days", reserved_days)
        if secondary_size is not None:
            pulumi.set(__self__, "secondary_size", secondary_size)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="enableTime")
    def enable_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Recycle Bin open time
        """
        return pulumi.get(self, "enable_time")

    @enable_time.setter
    def enable_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enable_time", value)

    @property
    @pulumi.getter(name="reservedDays")
    def reserved_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retention time of files in the Recycle Bin. Unit: days.
        """
        return pulumi.get(self, "reserved_days")

    @reserved_days.setter
    def reserved_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "reserved_days", value)

    @property
    @pulumi.getter(name="secondarySize")
    def secondary_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of low-frequency data stored in the recycle bin. Unit: Byte.
        """
        return pulumi.get(self, "secondary_size")

    @secondary_size.setter
    def secondary_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "secondary_size", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The amount of files stored in the Recycle Bin. Unit: Byte.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Recycle Bin Status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FileSystemSmbAclArgsDict(TypedDict):
        enable_anonymous_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow anonymous access.
        - true: Allow anonymous access.
        - false (default): Anonymous access is not allowed.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether SMB ACL is enabled
        """
        encrypt_data: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether transmission encryption is enabled.
        - true: Enables encryption in transit.
        - false (default): Transport encryption is not enabled.
        """
        home_dir_path: NotRequired[pulumi.Input[builtins.str]]
        """
        The user directory home path for each user. The file path format is as follows:
        - A forward slash (/) or backslash (\\) as a separator.
        - Each paragraph cannot contain ":|? *.
        - The length of each segment ranges from 0 to 255.
        - The total length range is 0~32767.

        For example, if the user directory is/home, the file system will automatically create A directory of/home/A when user A logs in. Skip if/home/A already exists.

        > **NOTE:**  Explain that user A needs to have the permission to create A directory, otherwise the/home/A directory cannot be created.
        """
        reject_unencrypted_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to reject non-encrypted clients.
        - true: Deny non-encrypted clients.
        - false (default): Non-encrypted clients are not rejected.
        """
        super_admin_sid: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the Super User. The ID rules are as follows:
        - Must start with S and no other letters can appear after the S at the beginning.
        - At least three dashes (-) apart.

        Such as S-1-5-22 or S-1-5-22-23.
        """
elif False:
    FileSystemSmbAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemSmbAclArgs:
    def __init__(__self__, *,
                 enable_anonymous_access: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 encrypt_data: Optional[pulumi.Input[builtins.bool]] = None,
                 home_dir_path: Optional[pulumi.Input[builtins.str]] = None,
                 reject_unencrypted_access: Optional[pulumi.Input[builtins.bool]] = None,
                 super_admin_sid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_anonymous_access: Whether to allow anonymous access.
               - true: Allow anonymous access.
               - false (default): Anonymous access is not allowed.
        :param pulumi.Input[builtins.bool] enabled: Whether SMB ACL is enabled
        :param pulumi.Input[builtins.bool] encrypt_data: Whether transmission encryption is enabled.
               - true: Enables encryption in transit.
               - false (default): Transport encryption is not enabled.
        :param pulumi.Input[builtins.str] home_dir_path: The user directory home path for each user. The file path format is as follows:
               - A forward slash (/) or backslash (\\) as a separator.
               - Each paragraph cannot contain ":|? *.
               - The length of each segment ranges from 0 to 255.
               - The total length range is 0~32767.
               
               For example, if the user directory is/home, the file system will automatically create A directory of/home/A when user A logs in. Skip if/home/A already exists.
               
               > **NOTE:**  Explain that user A needs to have the permission to create A directory, otherwise the/home/A directory cannot be created.
        :param pulumi.Input[builtins.bool] reject_unencrypted_access: Whether to reject non-encrypted clients.
               - true: Deny non-encrypted clients.
               - false (default): Non-encrypted clients are not rejected.
        :param pulumi.Input[builtins.str] super_admin_sid: The ID of the Super User. The ID rules are as follows:
               - Must start with S and no other letters can appear after the S at the beginning.
               - At least three dashes (-) apart.
               
               Such as S-1-5-22 or S-1-5-22-23.
        """
        if enable_anonymous_access is not None:
            pulumi.set(__self__, "enable_anonymous_access", enable_anonymous_access)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encrypt_data is not None:
            pulumi.set(__self__, "encrypt_data", encrypt_data)
        if home_dir_path is not None:
            pulumi.set(__self__, "home_dir_path", home_dir_path)
        if reject_unencrypted_access is not None:
            pulumi.set(__self__, "reject_unencrypted_access", reject_unencrypted_access)
        if super_admin_sid is not None:
            pulumi.set(__self__, "super_admin_sid", super_admin_sid)

    @property
    @pulumi.getter(name="enableAnonymousAccess")
    def enable_anonymous_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow anonymous access.
        - true: Allow anonymous access.
        - false (default): Anonymous access is not allowed.
        """
        return pulumi.get(self, "enable_anonymous_access")

    @enable_anonymous_access.setter
    def enable_anonymous_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_anonymous_access", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether SMB ACL is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="encryptData")
    def encrypt_data(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether transmission encryption is enabled.
        - true: Enables encryption in transit.
        - false (default): Transport encryption is not enabled.
        """
        return pulumi.get(self, "encrypt_data")

    @encrypt_data.setter
    def encrypt_data(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "encrypt_data", value)

    @property
    @pulumi.getter(name="homeDirPath")
    def home_dir_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user directory home path for each user. The file path format is as follows:
        - A forward slash (/) or backslash (\\) as a separator.
        - Each paragraph cannot contain ":|? *.
        - The length of each segment ranges from 0 to 255.
        - The total length range is 0~32767.

        For example, if the user directory is/home, the file system will automatically create A directory of/home/A when user A logs in. Skip if/home/A already exists.

        > **NOTE:**  Explain that user A needs to have the permission to create A directory, otherwise the/home/A directory cannot be created.
        """
        return pulumi.get(self, "home_dir_path")

    @home_dir_path.setter
    def home_dir_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "home_dir_path", value)

    @property
    @pulumi.getter(name="rejectUnencryptedAccess")
    def reject_unencrypted_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to reject non-encrypted clients.
        - true: Deny non-encrypted clients.
        - false (default): Non-encrypted clients are not rejected.
        """
        return pulumi.get(self, "reject_unencrypted_access")

    @reject_unencrypted_access.setter
    def reject_unencrypted_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "reject_unencrypted_access", value)

    @property
    @pulumi.getter(name="superAdminSid")
    def super_admin_sid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the Super User. The ID rules are as follows:
        - Must start with S and no other letters can appear after the S at the beginning.
        - At least three dashes (-) apart.

        Such as S-1-5-22 or S-1-5-22-23.
        """
        return pulumi.get(self, "super_admin_sid")

    @super_admin_sid.setter
    def super_admin_sid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "super_admin_sid", value)


