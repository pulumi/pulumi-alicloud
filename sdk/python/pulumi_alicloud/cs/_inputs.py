# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplicationServiceArgs',
    'ApplicationServiceArgsDict',
    'ClusterNodeArgs',
    'ClusterNodeArgsDict',
    'EdgeKubernetesAddonArgs',
    'EdgeKubernetesAddonArgsDict',
    'EdgeKubernetesCertificateAuthorityArgs',
    'EdgeKubernetesCertificateAuthorityArgsDict',
    'EdgeKubernetesConnectionsArgs',
    'EdgeKubernetesConnectionsArgsDict',
    'EdgeKubernetesLogConfigArgs',
    'EdgeKubernetesLogConfigArgsDict',
    'EdgeKubernetesRuntimeArgs',
    'EdgeKubernetesRuntimeArgsDict',
    'EdgeKubernetesWorkerDataDiskArgs',
    'EdgeKubernetesWorkerDataDiskArgsDict',
    'EdgeKubernetesWorkerNodeArgs',
    'EdgeKubernetesWorkerNodeArgsDict',
    'KubernetesAddonArgs',
    'KubernetesAddonArgsDict',
    'KubernetesAutoscalerNodepoolArgs',
    'KubernetesAutoscalerNodepoolArgsDict',
    'KubernetesCertificateAuthorityArgs',
    'KubernetesCertificateAuthorityArgsDict',
    'KubernetesConnectionsArgs',
    'KubernetesConnectionsArgsDict',
    'KubernetesDeleteOptionArgs',
    'KubernetesDeleteOptionArgsDict',
    'KubernetesMasterNodeArgs',
    'KubernetesMasterNodeArgsDict',
    'KubernetesPermissionPermissionArgs',
    'KubernetesPermissionPermissionArgsDict',
    'KubernetesRuntimeArgs',
    'KubernetesRuntimeArgsDict',
    'ManagedKubernetesAddonArgs',
    'ManagedKubernetesAddonArgsDict',
    'ManagedKubernetesAuditLogConfigArgs',
    'ManagedKubernetesAuditLogConfigArgsDict',
    'ManagedKubernetesAutoModeArgs',
    'ManagedKubernetesAutoModeArgsDict',
    'ManagedKubernetesCertificateAuthorityArgs',
    'ManagedKubernetesCertificateAuthorityArgsDict',
    'ManagedKubernetesConnectionsArgs',
    'ManagedKubernetesConnectionsArgsDict',
    'ManagedKubernetesDeleteOptionArgs',
    'ManagedKubernetesDeleteOptionArgsDict',
    'ManagedKubernetesMaintenanceWindowArgs',
    'ManagedKubernetesMaintenanceWindowArgsDict',
    'ManagedKubernetesOperationPolicyArgs',
    'ManagedKubernetesOperationPolicyArgsDict',
    'ManagedKubernetesOperationPolicyClusterAutoUpgradeArgs',
    'ManagedKubernetesOperationPolicyClusterAutoUpgradeArgsDict',
    'ManagedKubernetesRrsaMetadataArgs',
    'ManagedKubernetesRrsaMetadataArgsDict',
    'NodePoolDataDiskArgs',
    'NodePoolDataDiskArgsDict',
    'NodePoolEfloNodeGroupArgs',
    'NodePoolEfloNodeGroupArgsDict',
    'NodePoolKubeletConfigurationArgs',
    'NodePoolKubeletConfigurationArgsDict',
    'NodePoolKubeletConfigurationReservedMemoryArgs',
    'NodePoolKubeletConfigurationReservedMemoryArgsDict',
    'NodePoolKubeletConfigurationTracingArgs',
    'NodePoolKubeletConfigurationTracingArgsDict',
    'NodePoolLabelArgs',
    'NodePoolLabelArgsDict',
    'NodePoolManagementArgs',
    'NodePoolManagementArgsDict',
    'NodePoolManagementAutoRepairPolicyArgs',
    'NodePoolManagementAutoRepairPolicyArgsDict',
    'NodePoolManagementAutoUpgradePolicyArgs',
    'NodePoolManagementAutoUpgradePolicyArgsDict',
    'NodePoolManagementAutoVulFixPolicyArgs',
    'NodePoolManagementAutoVulFixPolicyArgsDict',
    'NodePoolPrivatePoolOptionsArgs',
    'NodePoolPrivatePoolOptionsArgsDict',
    'NodePoolRollingPolicyArgs',
    'NodePoolRollingPolicyArgsDict',
    'NodePoolScalingConfigArgs',
    'NodePoolScalingConfigArgsDict',
    'NodePoolSpotPriceLimitArgs',
    'NodePoolSpotPriceLimitArgsDict',
    'NodePoolTaintArgs',
    'NodePoolTaintArgsDict',
    'NodePoolTeeConfigArgs',
    'NodePoolTeeConfigArgsDict',
    'ServerlessKubernetesAddonArgs',
    'ServerlessKubernetesAddonArgsDict',
    'ServerlessKubernetesDeleteOptionArgs',
    'ServerlessKubernetesDeleteOptionArgsDict',
    'ServerlessKubernetesMaintenanceWindowArgs',
    'ServerlessKubernetesMaintenanceWindowArgsDict',
    'ServerlessKubernetesOperationPolicyArgs',
    'ServerlessKubernetesOperationPolicyArgsDict',
    'ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgs',
    'ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgsDict',
    'ServerlessKubernetesRrsaMetadataArgs',
    'ServerlessKubernetesRrsaMetadataArgsDict',
    'SwarmNodeArgs',
    'SwarmNodeArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationServiceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationServiceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterNodeArgsDict(TypedDict):
        eip: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeArgs:
    def __init__(__self__, *,
                 eip: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        if eip is not None:
            pulumi.set(__self__, "eip", eip)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class EdgeKubernetesAddonArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:

        ```
        # install nginx ingress, conflict with SLB ingress
        addons {
        name = "nginx-ingress-controller"
        # use internet
        config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        # if use intranet, detail below.
        # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        }
        ```
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        It specifies the version of the component.
        """
elif False:
    EdgeKubernetesAddonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        :param pulumi.Input[_builtins.bool] disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
               
               ```
               # install nginx ingress, conflict with SLB ingress
               addons {
               name = "nginx-ingress-controller"
               # use internet
               config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
               # if use intranet, detail below.
               # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
               }
               ```
        :param pulumi.Input[_builtins.str] name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        :param pulumi.Input[_builtins.str] version: It specifies the version of the component.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:

        ```
        # install nginx ingress, conflict with SLB ingress
        addons {
        name = "nginx-ingress-controller"
        # use internet
        config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        # if use intranet, detail below.
        # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        }
        ```
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        It specifies the version of the component.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class EdgeKubernetesCertificateAuthorityArgsDict(TypedDict):
        client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        """
        cluster_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
elif False:
    EdgeKubernetesCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesCertificateAuthorityArgs:
    def __init__(__self__, *,
                 client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_cert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_cert: From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        :param pulumi.Input[_builtins.str] client_key: From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        :param pulumi.Input[_builtins.str] cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_cert is not None:
            pulumi.set(__self__, "cluster_cert", cluster_cert)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")

    @cluster_cert.setter
    def cluster_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_cert", value)


if not MYPY:
    class EdgeKubernetesConnectionsArgsDict(TypedDict):
        api_server_internet: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Server Internet endpoint.
        """
        api_server_intranet: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Server Intranet endpoint.
        """
        master_public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Master node SSH IP address.
        """
        service_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service Access Domain.
        """
elif False:
    EdgeKubernetesConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesConnectionsArgs:
    def __init__(__self__, *,
                 api_server_internet: Optional[pulumi.Input[_builtins.str]] = None,
                 api_server_intranet: Optional[pulumi.Input[_builtins.str]] = None,
                 master_public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 service_domain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_server_internet: API Server Internet endpoint.
        :param pulumi.Input[_builtins.str] api_server_intranet: API Server Intranet endpoint.
        :param pulumi.Input[_builtins.str] master_public_ip: Master node SSH IP address.
        :param pulumi.Input[_builtins.str] service_domain: Service Access Domain.
        """
        if api_server_internet is not None:
            pulumi.set(__self__, "api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            pulumi.set(__self__, "api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            pulumi.set(__self__, "master_public_ip", master_public_ip)
        if service_domain is not None:
            pulumi.set(__self__, "service_domain", service_domain)

    @_builtins.property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @api_server_internet.setter
    def api_server_internet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_server_internet", value)

    @_builtins.property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @api_server_intranet.setter
    def api_server_intranet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_server_intranet", value)

    @_builtins.property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @master_public_ip.setter
    def master_public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_domain", value)


if not MYPY:
    class EdgeKubernetesLogConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of collecting logs, only `SLS` are supported currently.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log Service project name, cluster logs will output to this project.
        """
elif False:
    EdgeKubernetesLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesLogConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 project: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of collecting logs, only `SLS` are supported currently.
        :param pulumi.Input[_builtins.str] project: Log Service project name, cluster logs will output to this project.
        """
        pulumi.set(__self__, "type", type)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of collecting logs, only `SLS` are supported currently.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log Service project name, cluster logs will output to this project.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class EdgeKubernetesRuntimeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the runtime. Supported runtimes can be queried by data source alicloud_cs_kubernetes_version.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the runtime.

        The following example is the definition of runtime block:

        ```
        runtime = {
        name = "containerd"
        version = "1.6.28"
        }
        ```
        """
elif False:
    EdgeKubernetesRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesRuntimeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the runtime. Supported runtimes can be queried by data source alicloud_cs_kubernetes_version.
        :param pulumi.Input[_builtins.str] version: The version of the runtime.
               
               The following example is the definition of runtime block:
               
               ```
               runtime = {
               name = "containerd"
               version = "1.6.28"
               }
               ```
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the runtime. Supported runtimes can be queried by data source alicloud_cs_kubernetes_version.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the runtime.

        The following example is the definition of runtime block:

        ```
        runtime = {
        name = "containerd"
        version = "1.6.28"
        }
        ```
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class EdgeKubernetesWorkerDataDiskArgsDict(TypedDict):
        auto_snapshot_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Worker node data disk auto snapshot policy.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device of the data disks.
        """
        encrypted: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the kms key.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the data disks.
        """
        performance_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        size: NotRequired[pulumi.Input[_builtins.str]]
        """
        The size of a data disk, at least 40. Unit: GiB.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of snapshot.
        """
elif False:
    EdgeKubernetesWorkerDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesWorkerDataDiskArgs:
    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 performance_level: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auto_snapshot_policy_id: Worker node data disk auto snapshot policy.
        :param pulumi.Input[_builtins.str] category: The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param pulumi.Input[_builtins.str] device: The device of the data disks.
        :param pulumi.Input[_builtins.str] encrypted: Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        :param pulumi.Input[_builtins.str] kms_key_id: The id of the kms key.
        :param pulumi.Input[_builtins.str] name: The name of the data disks.
        :param pulumi.Input[_builtins.str] performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param pulumi.Input[_builtins.str] size: The size of a data disk, at least 40. Unit: GiB.
        :param pulumi.Input[_builtins.str] snapshot_id: The id of snapshot.
        """
        if auto_snapshot_policy_id is not None:
            pulumi.set(__self__, "auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if performance_level is not None:
            pulumi.set(__self__, "performance_level", performance_level)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @_builtins.property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @auto_snapshot_policy_id.setter
    def auto_snapshot_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_snapshot_policy_id", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device of the data disks.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the kms key.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the data disks.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "performance_level", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)


if not MYPY:
    class EdgeKubernetesWorkerNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the node.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address of node.
        """
elif False:
    EdgeKubernetesWorkerNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeKubernetesWorkerNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the node.
        :param pulumi.Input[_builtins.str] name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param pulumi.Input[_builtins.str] private_ip: The private IP address of node.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class KubernetesAddonArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:

        ```
        # install nginx ingress, conflict with SLB ingress
        addons {
        name = "nginx-ingress-controller"
        # use internet
        config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        # if use intranet, detail below.
        # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        }
        ```
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the component.
        """
elif False:
    KubernetesAddonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        :param pulumi.Input[_builtins.bool] disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
               
               ```
               # install nginx ingress, conflict with SLB ingress
               addons {
               name = "nginx-ingress-controller"
               # use internet
               config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
               # if use intranet, detail below.
               # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
               }
               ```
        :param pulumi.Input[_builtins.str] name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        :param pulumi.Input[_builtins.str] version: The version of the component.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:

        ```
        # install nginx ingress, conflict with SLB ingress
        addons {
        name = "nginx-ingress-controller"
        # use internet
        config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        # if use intranet, detail below.
        # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        }
        ```
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the component.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class KubernetesAutoscalerNodepoolArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scaling group id of the groups configured for cluster-autoscaler.
        """
        labels: NotRequired[pulumi.Input[_builtins.str]]
        """
        The labels for the nodes in scaling group.
        """
        taints: NotRequired[pulumi.Input[_builtins.str]]
        """
        The taints for the nodes in scaling group.
        """
elif False:
    KubernetesAutoscalerNodepoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesAutoscalerNodepoolArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[_builtins.str]] = None,
                 taints: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The scaling group id of the groups configured for cluster-autoscaler.
        :param pulumi.Input[_builtins.str] labels: The labels for the nodes in scaling group.
        :param pulumi.Input[_builtins.str] taints: The taints for the nodes in scaling group.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scaling group id of the groups configured for cluster-autoscaler.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The labels for the nodes in scaling group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The taints for the nodes in scaling group.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class KubernetesCertificateAuthorityArgsDict(TypedDict):
        client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        """
        cluster_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
elif False:
    KubernetesCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesCertificateAuthorityArgs:
    def __init__(__self__, *,
                 client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_cert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_cert: From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        :param pulumi.Input[_builtins.str] client_key: From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        :param pulumi.Input[_builtins.str] cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_cert is not None:
            pulumi.set(__self__, "cluster_cert", cluster_cert)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")

    @cluster_cert.setter
    def cluster_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_cert", value)


if not MYPY:
    class KubernetesConnectionsArgsDict(TypedDict):
        api_server_internet: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Server Internet endpoint.
        """
        api_server_intranet: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Server Intranet endpoint.
        """
        master_public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Master node SSH IP address.
        """
        service_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service Access Domain.
        """
elif False:
    KubernetesConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesConnectionsArgs:
    def __init__(__self__, *,
                 api_server_internet: Optional[pulumi.Input[_builtins.str]] = None,
                 api_server_intranet: Optional[pulumi.Input[_builtins.str]] = None,
                 master_public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 service_domain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_server_internet: API Server Internet endpoint.
        :param pulumi.Input[_builtins.str] api_server_intranet: API Server Intranet endpoint.
        :param pulumi.Input[_builtins.str] master_public_ip: Master node SSH IP address.
        :param pulumi.Input[_builtins.str] service_domain: Service Access Domain.
        """
        if api_server_internet is not None:
            pulumi.set(__self__, "api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            pulumi.set(__self__, "api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            pulumi.set(__self__, "master_public_ip", master_public_ip)
        if service_domain is not None:
            pulumi.set(__self__, "service_domain", service_domain)

    @_builtins.property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @api_server_internet.setter
    def api_server_internet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_server_internet", value)

    @_builtins.property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @api_server_intranet.setter
    def api_server_intranet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_server_intranet", value)

    @_builtins.property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @master_public_ip.setter
    def master_public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_domain", value)


if not MYPY:
    class KubernetesDeleteOptionArgsDict(TypedDict):
        delete_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resources that are created by cluster. Valid values:
        - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
        - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
        - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
        - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.

        ```
        ...
        // Specify delete_options as below when deleting cluster
        // delete SLB resources created by the Nginx Ingress Service
        delete_options {
        delete_mode = "delete"
        resource_type = "SLB"
        }
        // delete ALB resources created by the ALB Ingress Controller
        delete_options {
        delete_mode = "delete"
        resource_type = "ALB"
        }
        // delete SLS Project used by the cluster logging feature
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_Data"
        }
        // delete SLS Project used for the managed cluster control plane logs
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_ControlPlane"
        }
        ```
        """
elif False:
    KubernetesDeleteOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesDeleteOptionArgs:
    def __init__(__self__, *,
                 delete_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete_mode: The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        :param pulumi.Input[_builtins.str] resource_type: The type of resources that are created by cluster. Valid values:
               - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
               - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
               - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
               - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.
               
               ```
               ...
               // Specify delete_options as below when deleting cluster
               // delete SLB resources created by the Nginx Ingress Service
               delete_options {
               delete_mode = "delete"
               resource_type = "SLB"
               }
               // delete ALB resources created by the ALB Ingress Controller
               delete_options {
               delete_mode = "delete"
               resource_type = "ALB"
               }
               // delete SLS Project used by the cluster logging feature
               delete_options {
               delete_mode = "delete"
               resource_type = "SLS_Data"
               }
               // delete SLS Project used for the managed cluster control plane logs
               delete_options {
               delete_mode = "delete"
               resource_type = "SLS_ControlPlane"
               }
               ```
        """
        if delete_mode is not None:
            pulumi.set(__self__, "delete_mode", delete_mode)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="deleteMode")
    def delete_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        """
        return pulumi.get(self, "delete_mode")

    @delete_mode.setter
    def delete_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resources that are created by cluster. Valid values:
        - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
        - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
        - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
        - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.

        ```
        ...
        // Specify delete_options as below when deleting cluster
        // delete SLB resources created by the Nginx Ingress Service
        delete_options {
        delete_mode = "delete"
        resource_type = "SLB"
        }
        // delete ALB resources created by the ALB Ingress Controller
        delete_options {
        delete_mode = "delete"
        resource_type = "ALB"
        }
        // delete SLS Project used by the cluster logging feature
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_Data"
        }
        // delete SLS Project used for the managed cluster control plane logs
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_ControlPlane"
        }
        ```
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class KubernetesMasterNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the node.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP address of node.
        """
elif False:
    KubernetesMasterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesMasterNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the node.
        :param pulumi.Input[_builtins.str] name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param pulumi.Input[_builtins.str] private_ip: The private IP address of node.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class KubernetesPermissionPermissionArgsDict(TypedDict):
        cluster: pulumi.Input[_builtins.str]
        """
        The ID of the cluster that you want to manage, When `role_type` value is `all-clusters`, the value of `cluster` must be `""`.
        """
        role_name: pulumi.Input[_builtins.str]
        """
        Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        """
        role_type: pulumi.Input[_builtins.str]
        """
        The authorization type. Valid values `cluster`, `namespace` and `all-clusters`.
        """
        is_custom: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to perform a custom authorization. To perform a custom authorization, the value of `is_custom` must be `true`, and set `role_name` to a custom cluster role.
        """
        is_ram_role: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
elif False:
    KubernetesPermissionPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesPermissionPermissionArgs:
    def __init__(__self__, *,
                 cluster: pulumi.Input[_builtins.str],
                 role_name: pulumi.Input[_builtins.str],
                 role_type: pulumi.Input[_builtins.str],
                 is_custom: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_ram_role: Optional[pulumi.Input[_builtins.bool]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster: The ID of the cluster that you want to manage, When `role_type` value is `all-clusters`, the value of `cluster` must be `""`.
        :param pulumi.Input[_builtins.str] role_name: Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        :param pulumi.Input[_builtins.str] role_type: The authorization type. Valid values `cluster`, `namespace` and `all-clusters`.
        :param pulumi.Input[_builtins.bool] is_custom: Specifies whether to perform a custom authorization. To perform a custom authorization, the value of `is_custom` must be `true`, and set `role_name` to a custom cluster role.
        :param pulumi.Input[_builtins.bool] is_ram_role: Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        :param pulumi.Input[_builtins.str] namespace: The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "role_type", role_type)
        if is_custom is not None:
            pulumi.set(__self__, "is_custom", is_custom)
        if is_ram_role is not None:
            pulumi.set(__self__, "is_ram_role", is_ram_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the cluster that you want to manage, When `role_type` value is `all-clusters`, the value of `cluster` must be `""`.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_name", value)

    @_builtins.property
    @pulumi.getter(name="roleType")
    def role_type(self) -> pulumi.Input[_builtins.str]:
        """
        The authorization type. Valid values `cluster`, `namespace` and `all-clusters`.
        """
        return pulumi.get(self, "role_type")

    @role_type.setter
    def role_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_type", value)

    @_builtins.property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to perform a custom authorization. To perform a custom authorization, the value of `is_custom` must be `true`, and set `role_name` to a custom cluster role.
        """
        return pulumi.get(self, "is_custom")

    @is_custom.setter
    def is_custom(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_custom", value)

    @_builtins.property
    @pulumi.getter(name="isRamRole")
    def is_ram_role(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        """
        return pulumi.get(self, "is_ram_role")

    @is_ram_role.setter
    def is_ram_role(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ram_role", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class KubernetesRuntimeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the runtime. Supported runtimes can be queried by data source alicloud_cs_kubernetes_version.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the runtime.

        The following example is the definition of runtime block:

        ```
        runtime = {
        name = "containerd"
        version = "1.6.28"
        }
        ```
        """
elif False:
    KubernetesRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesRuntimeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the runtime. Supported runtimes can be queried by data source alicloud_cs_kubernetes_version.
        :param pulumi.Input[_builtins.str] version: The version of the runtime.
               
               The following example is the definition of runtime block:
               
               ```
               runtime = {
               name = "containerd"
               version = "1.6.28"
               }
               ```
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the runtime. Supported runtimes can be queried by data source alicloud_cs_kubernetes_version.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the runtime.

        The following example is the definition of runtime block:

        ```
        runtime = {
        name = "containerd"
        version = "1.6.28"
        }
        ```
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ManagedKubernetesAddonArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[_builtins.str]]
        """
        If this parameter is left empty, no configurations are required. For more config information, see cs_kubernetes_addon_metadata.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        It specifies whether to disable automatic installation. 

        It is a new field since 1.75.0. You can specific network plugin, log component,ingress component and so on.

        You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.

        `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.

        `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.

        The `main.tf`:

        ```python
        import pulumi
        import pulumi_alicloud as alicloud
        import pulumi_std as std

        k8s = alicloud.cs.ManagedKubernetes("k8s", addons=[{
            "name": std.lookup(map=entry["value"],
                key="name",
                default=cluster_addons).result,
            "config": std.lookup(map=entry["value"],
                key="config",
                default=cluster_addons).result,
            "version": std.lookup(map=entry["value"],
                key="version",
                default=cluster_addons).result,
            "disabled": std.lookup(map=entry["value"],
                key="disabled",
                default=cluster_addons).result,
        } for entry in [{"key": k, "value": v} for k, v in cluster_addons]])
        ```

        The `varibales.tf`:

        ```
        # Network-flannel is required, Conflicts With Network-terway
        variable "cluster_addons" {
        description = "Addon components in kubernetes cluster"

        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "flannel",
        "config"   = "",
        }
        ]
        }

        # Network-terway is required, Conflicts With Network-flannel
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "terway-eniip",
        "config"   = "",
        }
        ]
        }

        # Storage-csi is required, Conflicts With Storage-flexvolume
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "csi-plugin",
        "config"   = "",
        },
        {
        "name"     = "csi-provisioner",
        "config"   = "",
        }
        ]
        }

        # Storage-flexvolume is required, Conflicts With Storage-csi
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "flexvolume",
        "config"   = "",
        }
        ]
        }

        # Log, Optional
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "logtail-ds",
        "config"   = "{\\"IngressDashboardEnabled\\":\\"true\\",\\"sls_project_name\\":\\"your-sls-project-name\\"}",
        }
        ]
        }

        # Ingress,Optional
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "nginx-ingress-controller",
        "config"   = "{\\"IngressSlbNetworkType\\":\\"internet\\"}",
        }
        ]
        }

        # Ingress-Disable, Optional
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        disabled  = bool
        }))

        default = [
        {
        "name"     = "nginx-ingress-controller",
        "config"   = "",
        "disabled": true,
        }
        ]

        # Prometheus, Optional.
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "arms-prometheus",
        "config"   = "",
        }
        ]
        }

        # Event Center, Optional.
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "ack-node-problem-detector",
        "config"   = "{\\"sls_project_name\\":\\"\\"}",
        }
        ]
        }
        # ACK default alert, Optional.
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "alicloud-monitor-controller",
        "config"   = "{\\"group_contact_ids\\":\\"[159]\\"}",
        }
        ]
        }
        ```
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        This parameter specifies the name of the component.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        It specifies the version of the component.
        """
elif False:
    ManagedKubernetesAddonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: If this parameter is left empty, no configurations are required. For more config information, see cs_kubernetes_addon_metadata.
        :param pulumi.Input[_builtins.bool] disabled: It specifies whether to disable automatic installation. 
               
               It is a new field since 1.75.0. You can specific network plugin, log component,ingress component and so on.
               
               You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.
               
               `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.
               
               `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.
               
               The `main.tf`:
               
               ```python
               import pulumi
               import pulumi_alicloud as alicloud
               import pulumi_std as std
               
               k8s = alicloud.cs.ManagedKubernetes("k8s", addons=[{
                   "name": std.lookup(map=entry["value"],
                       key="name",
                       default=cluster_addons).result,
                   "config": std.lookup(map=entry["value"],
                       key="config",
                       default=cluster_addons).result,
                   "version": std.lookup(map=entry["value"],
                       key="version",
                       default=cluster_addons).result,
                   "disabled": std.lookup(map=entry["value"],
                       key="disabled",
                       default=cluster_addons).result,
               } for entry in [{"key": k, "value": v} for k, v in cluster_addons]])
               ```
               
               The `varibales.tf`:
               
               ```
               # Network-flannel is required, Conflicts With Network-terway
               variable "cluster_addons" {
               description = "Addon components in kubernetes cluster"
               
               type = list(object({
               name      = string
               config    = string
               }))
               
               default = [
               {
               "name"     = "flannel",
               "config"   = "",
               }
               ]
               }
               
               # Network-terway is required, Conflicts With Network-flannel
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               
               default = [
               {
               "name"     = "terway-eniip",
               "config"   = "",
               }
               ]
               }
               
               # Storage-csi is required, Conflicts With Storage-flexvolume
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               
               default = [
               {
               "name"     = "csi-plugin",
               "config"   = "",
               },
               {
               "name"     = "csi-provisioner",
               "config"   = "",
               }
               ]
               }
               
               # Storage-flexvolume is required, Conflicts With Storage-csi
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               default = [
               {
               "name"     = "flexvolume",
               "config"   = "",
               }
               ]
               }
               
               # Log, Optional
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               default = [
               {
               "name"     = "logtail-ds",
               "config"   = "{\\"IngressDashboardEnabled\\":\\"true\\",\\"sls_project_name\\":\\"your-sls-project-name\\"}",
               }
               ]
               }
               
               # Ingress,Optional
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               
               default = [
               {
               "name"     = "nginx-ingress-controller",
               "config"   = "{\\"IngressSlbNetworkType\\":\\"internet\\"}",
               }
               ]
               }
               
               # Ingress-Disable, Optional
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               disabled  = bool
               }))
               
               default = [
               {
               "name"     = "nginx-ingress-controller",
               "config"   = "",
               "disabled": true,
               }
               ]
               
               # Prometheus, Optional.
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               
               default = [
               {
               "name"     = "arms-prometheus",
               "config"   = "",
               }
               ]
               }
               
               # Event Center, Optional.
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               default = [
               {
               "name"     = "ack-node-problem-detector",
               "config"   = "{\\"sls_project_name\\":\\"\\"}",
               }
               ]
               }
               # ACK default alert, Optional.
               variable "cluster_addons" {
               type = list(object({
               name      = string
               config    = string
               }))
               default = [
               {
               "name"     = "alicloud-monitor-controller",
               "config"   = "{\\"group_contact_ids\\":\\"[159]\\"}",
               }
               ]
               }
               ```
        :param pulumi.Input[_builtins.str] name: This parameter specifies the name of the component.
        :param pulumi.Input[_builtins.str] version: It specifies the version of the component.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If this parameter is left empty, no configurations are required. For more config information, see cs_kubernetes_addon_metadata.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        It specifies whether to disable automatic installation. 

        It is a new field since 1.75.0. You can specific network plugin, log component,ingress component and so on.

        You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.

        `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.

        `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.

        The `main.tf`:

        ```python
        import pulumi
        import pulumi_alicloud as alicloud
        import pulumi_std as std

        k8s = alicloud.cs.ManagedKubernetes("k8s", addons=[{
            "name": std.lookup(map=entry["value"],
                key="name",
                default=cluster_addons).result,
            "config": std.lookup(map=entry["value"],
                key="config",
                default=cluster_addons).result,
            "version": std.lookup(map=entry["value"],
                key="version",
                default=cluster_addons).result,
            "disabled": std.lookup(map=entry["value"],
                key="disabled",
                default=cluster_addons).result,
        } for entry in [{"key": k, "value": v} for k, v in cluster_addons]])
        ```

        The `varibales.tf`:

        ```
        # Network-flannel is required, Conflicts With Network-terway
        variable "cluster_addons" {
        description = "Addon components in kubernetes cluster"

        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "flannel",
        "config"   = "",
        }
        ]
        }

        # Network-terway is required, Conflicts With Network-flannel
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "terway-eniip",
        "config"   = "",
        }
        ]
        }

        # Storage-csi is required, Conflicts With Storage-flexvolume
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "csi-plugin",
        "config"   = "",
        },
        {
        "name"     = "csi-provisioner",
        "config"   = "",
        }
        ]
        }

        # Storage-flexvolume is required, Conflicts With Storage-csi
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "flexvolume",
        "config"   = "",
        }
        ]
        }

        # Log, Optional
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "logtail-ds",
        "config"   = "{\\"IngressDashboardEnabled\\":\\"true\\",\\"sls_project_name\\":\\"your-sls-project-name\\"}",
        }
        ]
        }

        # Ingress,Optional
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "nginx-ingress-controller",
        "config"   = "{\\"IngressSlbNetworkType\\":\\"internet\\"}",
        }
        ]
        }

        # Ingress-Disable, Optional
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        disabled  = bool
        }))

        default = [
        {
        "name"     = "nginx-ingress-controller",
        "config"   = "",
        "disabled": true,
        }
        ]

        # Prometheus, Optional.
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))

        default = [
        {
        "name"     = "arms-prometheus",
        "config"   = "",
        }
        ]
        }

        # Event Center, Optional.
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "ack-node-problem-detector",
        "config"   = "{\\"sls_project_name\\":\\"\\"}",
        }
        ]
        }
        # ACK default alert, Optional.
        variable "cluster_addons" {
        type = list(object({
        name      = string
        config    = string
        }))
        default = [
        {
        "name"     = "alicloud-monitor-controller",
        "config"   = "{\\"group_contact_ids\\":\\"[159]\\"}",
        }
        ]
        }
        ```
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        It specifies the version of the component.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ManagedKubernetesAuditLogConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable audit logging. Valid values: `true`, `false`.
        """
        sls_project_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SLS project to which the Logstore storing the cluster audit logs belongs.
        """
elif False:
    ManagedKubernetesAuditLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesAuditLogConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 sls_project_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable audit logging. Valid values: `true`, `false`.
        :param pulumi.Input[_builtins.str] sls_project_name: The SLS project to which the Logstore storing the cluster audit logs belongs.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if sls_project_name is not None:
            pulumi.set(__self__, "sls_project_name", sls_project_name)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable audit logging. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="slsProjectName")
    def sls_project_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SLS project to which the Logstore storing the cluster audit logs belongs.
        """
        return pulumi.get(self, "sls_project_name")

    @sls_project_name.setter
    def sls_project_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sls_project_name", value)


if not MYPY:
    class ManagedKubernetesAutoModeArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable auto mode. Valid values: `true`, `false`. Only ACK managed Pro clusters support Auto Mode.
        """
elif False:
    ManagedKubernetesAutoModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesAutoModeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable auto mode. Valid values: `true`, `false`. Only ACK managed Pro clusters support Auto Mode.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable auto mode. Valid values: `true`, `false`. Only ACK managed Pro clusters support Auto Mode.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ManagedKubernetesCertificateAuthorityArgsDict(TypedDict):
        client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        """
        cluster_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
elif False:
    ManagedKubernetesCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesCertificateAuthorityArgs:
    def __init__(__self__, *,
                 client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_cert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_cert: From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        :param pulumi.Input[_builtins.str] client_key: From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        :param pulumi.Input[_builtins.str] cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_cert is not None:
            pulumi.set(__self__, "cluster_cert", cluster_cert)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_cert attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-cert.pem) for replace it.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        From version 1.248.0, new DataSource `cs_get_cluster_credential` is recommended to manage cluster's kubeconfig, you can also save the certificate_authority.client_key attribute content of new DataSource `cs_get_cluster_credential` to an appropriate path(like ~/.kube/client-key.pem) for replace it.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")

    @cluster_cert.setter
    def cluster_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_cert", value)


if not MYPY:
    class ManagedKubernetesConnectionsArgsDict(TypedDict):
        api_server_internet: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Server Internet endpoint.
        """
        api_server_intranet: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Server Intranet endpoint.
        """
        master_public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Master node SSH IP address.
        """
        service_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service Access Domain.
        """
elif False:
    ManagedKubernetesConnectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesConnectionsArgs:
    def __init__(__self__, *,
                 api_server_internet: Optional[pulumi.Input[_builtins.str]] = None,
                 api_server_intranet: Optional[pulumi.Input[_builtins.str]] = None,
                 master_public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 service_domain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_server_internet: API Server Internet endpoint.
        :param pulumi.Input[_builtins.str] api_server_intranet: API Server Intranet endpoint.
        :param pulumi.Input[_builtins.str] master_public_ip: Master node SSH IP address.
        :param pulumi.Input[_builtins.str] service_domain: Service Access Domain.
        """
        if api_server_internet is not None:
            pulumi.set(__self__, "api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            pulumi.set(__self__, "api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            pulumi.set(__self__, "master_public_ip", master_public_ip)
        if service_domain is not None:
            pulumi.set(__self__, "service_domain", service_domain)

    @_builtins.property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @api_server_internet.setter
    def api_server_internet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_server_internet", value)

    @_builtins.property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @api_server_intranet.setter
    def api_server_intranet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_server_intranet", value)

    @_builtins.property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @master_public_ip.setter
    def master_public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_domain", value)


if not MYPY:
    class ManagedKubernetesDeleteOptionArgsDict(TypedDict):
        delete_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resources that are created by cluster. Valid values:
        - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
        - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
        - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
        - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.

        ```
        ...
        // Specify delete_options as below when deleting cluster
        // delete SLB resources created by the Nginx Ingress Service
        delete_options {
        delete_mode = "delete"
        resource_type = "SLB"
        }
        // delete ALB resources created by the ALB Ingress Controller
        delete_options {
        delete_mode = "delete"
        resource_type = "ALB"
        }
        // delete SLS Project used by the cluster logging feature
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_Data"
        }
        // delete SLS Project used for the managed cluster control plane logs
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_ControlPlane"
        }
        ```
        """
elif False:
    ManagedKubernetesDeleteOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesDeleteOptionArgs:
    def __init__(__self__, *,
                 delete_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete_mode: The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        :param pulumi.Input[_builtins.str] resource_type: The type of resources that are created by cluster. Valid values:
               - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
               - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
               - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
               - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.
               
               ```
               ...
               // Specify delete_options as below when deleting cluster
               // delete SLB resources created by the Nginx Ingress Service
               delete_options {
               delete_mode = "delete"
               resource_type = "SLB"
               }
               // delete ALB resources created by the ALB Ingress Controller
               delete_options {
               delete_mode = "delete"
               resource_type = "ALB"
               }
               // delete SLS Project used by the cluster logging feature
               delete_options {
               delete_mode = "delete"
               resource_type = "SLS_Data"
               }
               // delete SLS Project used for the managed cluster control plane logs
               delete_options {
               delete_mode = "delete"
               resource_type = "SLS_ControlPlane"
               }
               ```
        """
        if delete_mode is not None:
            pulumi.set(__self__, "delete_mode", delete_mode)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="deleteMode")
    def delete_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        """
        return pulumi.get(self, "delete_mode")

    @delete_mode.setter
    def delete_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resources that are created by cluster. Valid values:
        - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
        - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
        - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
        - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.

        ```
        ...
        // Specify delete_options as below when deleting cluster
        // delete SLB resources created by the Nginx Ingress Service
        delete_options {
        delete_mode = "delete"
        resource_type = "SLB"
        }
        // delete ALB resources created by the ALB Ingress Controller
        delete_options {
        delete_mode = "delete"
        resource_type = "ALB"
        }
        // delete SLS Project used by the cluster logging feature
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_Data"
        }
        // delete SLS Project used for the managed cluster control plane logs
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_ControlPlane"
        }
        ```
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class ManagedKubernetesMaintenanceWindowArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        """
        maintenance_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Initial maintenance time, RFC3339 format. For example: "2024-10-15T12:31:00.000+08:00".
        """
        weekly_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.

        for example:
        ```
        maintenance_window {
        enable            = true
        maintenance_time  = "2024-10-15T12:31:00.000+08:00"
        duration          = "3h"
        weekly_period     = "Monday,Friday"
        }
        ```
        """
elif False:
    ManagedKubernetesMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesMaintenanceWindowArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 maintenance_time: Optional[pulumi.Input[_builtins.str]] = None,
                 weekly_period: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] duration: The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        :param pulumi.Input[_builtins.bool] enable: Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        :param pulumi.Input[_builtins.str] maintenance_time: Initial maintenance time, RFC3339 format. For example: "2024-10-15T12:31:00.000+08:00".
        :param pulumi.Input[_builtins.str] weekly_period: Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
               
               for example:
               ```
               maintenance_window {
               enable            = true
               maintenance_time  = "2024-10-15T12:31:00.000+08:00"
               duration          = "3h"
               weekly_period     = "Monday,Friday"
               }
               ```
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if maintenance_time is not None:
            pulumi.set(__self__, "maintenance_time", maintenance_time)
        if weekly_period is not None:
            pulumi.set(__self__, "weekly_period", weekly_period)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Initial maintenance time, RFC3339 format. For example: "2024-10-15T12:31:00.000+08:00".
        """
        return pulumi.get(self, "maintenance_time")

    @maintenance_time.setter
    def maintenance_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maintenance_time", value)

    @_builtins.property
    @pulumi.getter(name="weeklyPeriod")
    def weekly_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.

        for example:
        ```
        maintenance_window {
        enable            = true
        maintenance_time  = "2024-10-15T12:31:00.000+08:00"
        duration          = "3h"
        weekly_period     = "Monday,Friday"
        }
        ```
        """
        return pulumi.get(self, "weekly_period")

    @weekly_period.setter
    def weekly_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "weekly_period", value)


if not MYPY:
    class ManagedKubernetesOperationPolicyArgsDict(TypedDict):
        cluster_auto_upgrade: NotRequired[pulumi.Input['ManagedKubernetesOperationPolicyClusterAutoUpgradeArgsDict']]
        """
        Automatic cluster upgrade policy. See `cluster_auto_upgrade` below.
        """
elif False:
    ManagedKubernetesOperationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesOperationPolicyArgs:
    def __init__(__self__, *,
                 cluster_auto_upgrade: Optional[pulumi.Input['ManagedKubernetesOperationPolicyClusterAutoUpgradeArgs']] = None):
        """
        :param pulumi.Input['ManagedKubernetesOperationPolicyClusterAutoUpgradeArgs'] cluster_auto_upgrade: Automatic cluster upgrade policy. See `cluster_auto_upgrade` below.
        """
        if cluster_auto_upgrade is not None:
            pulumi.set(__self__, "cluster_auto_upgrade", cluster_auto_upgrade)

    @_builtins.property
    @pulumi.getter(name="clusterAutoUpgrade")
    def cluster_auto_upgrade(self) -> Optional[pulumi.Input['ManagedKubernetesOperationPolicyClusterAutoUpgradeArgs']]:
        """
        Automatic cluster upgrade policy. See `cluster_auto_upgrade` below.
        """
        return pulumi.get(self, "cluster_auto_upgrade")

    @cluster_auto_upgrade.setter
    def cluster_auto_upgrade(self, value: Optional[pulumi.Input['ManagedKubernetesOperationPolicyClusterAutoUpgradeArgs']]):
        pulumi.set(self, "cluster_auto_upgrade", value)


if not MYPY:
    class ManagedKubernetesOperationPolicyClusterAutoUpgradeArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The automatic cluster upgrade channel. Valid values: `patch`, `stable`, `rapid`.

        for example:
        ```
        operation_policy {
        cluster_auto_upgrade {
        enabled = true
        channel = "stable"
        }
        }
        ```
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the RRSA feature has been enabled.
        """
elif False:
    ManagedKubernetesOperationPolicyClusterAutoUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesOperationPolicyClusterAutoUpgradeArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The automatic cluster upgrade channel. Valid values: `patch`, `stable`, `rapid`.
               
               for example:
               ```
               operation_policy {
               cluster_auto_upgrade {
               enabled = true
               channel = "stable"
               }
               }
               ```
        :param pulumi.Input[_builtins.bool] enabled: Whether the RRSA feature has been enabled.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The automatic cluster upgrade channel. Valid values: `patch`, `stable`, `rapid`.

        for example:
        ```
        operation_policy {
        cluster_auto_upgrade {
        enabled = true
        channel = "stable"
        }
        }
        ```
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ManagedKubernetesRrsaMetadataArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the RRSA feature has been enabled.
        """
        ram_oidc_provider_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arn of OIDC provider that was registered in RAM.
        """
        ram_oidc_provider_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of OIDC Provider that was registered in RAM.
        """
        rrsa_oidc_issuer_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer URL of RRSA OIDC Token.
        """
elif False:
    ManagedKubernetesRrsaMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedKubernetesRrsaMetadataArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ram_oidc_provider_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 ram_oidc_provider_name: Optional[pulumi.Input[_builtins.str]] = None,
                 rrsa_oidc_issuer_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the RRSA feature has been enabled.
        :param pulumi.Input[_builtins.str] ram_oidc_provider_arn: The arn of OIDC provider that was registered in RAM.
        :param pulumi.Input[_builtins.str] ram_oidc_provider_name: The name of OIDC Provider that was registered in RAM.
        :param pulumi.Input[_builtins.str] rrsa_oidc_issuer_url: The issuer URL of RRSA OIDC Token.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ram_oidc_provider_arn is not None:
            pulumi.set(__self__, "ram_oidc_provider_arn", ram_oidc_provider_arn)
        if ram_oidc_provider_name is not None:
            pulumi.set(__self__, "ram_oidc_provider_name", ram_oidc_provider_name)
        if rrsa_oidc_issuer_url is not None:
            pulumi.set(__self__, "rrsa_oidc_issuer_url", rrsa_oidc_issuer_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="ramOidcProviderArn")
    def ram_oidc_provider_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arn of OIDC provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_arn")

    @ram_oidc_provider_arn.setter
    def ram_oidc_provider_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ram_oidc_provider_arn", value)

    @_builtins.property
    @pulumi.getter(name="ramOidcProviderName")
    def ram_oidc_provider_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of OIDC Provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_name")

    @ram_oidc_provider_name.setter
    def ram_oidc_provider_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ram_oidc_provider_name", value)

    @_builtins.property
    @pulumi.getter(name="rrsaOidcIssuerUrl")
    def rrsa_oidc_issuer_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer URL of RRSA OIDC Token.
        """
        return pulumi.get(self, "rrsa_oidc_issuer_url")

    @rrsa_oidc_issuer_url.setter
    def rrsa_oidc_issuer_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rrsa_oidc_issuer_url", value)


if not MYPY:
    class NodePoolDataDiskArgsDict(TypedDict):
        auto_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to automatically mount the data disk. Valid values: true and false.
        """
        auto_snapshot_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the automatic snapshot policy that you want to apply to the system disk.
        """
        bursting_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the data disk is enabled with Burst (performance Burst). This is configured when the disk type is cloud_auto.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of data disk. Default value: `cloud_efficiency`. Valid values:
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        """
        encrypted: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        """
        file_system: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the mounted file system. Works when auto_format is true. Optional value: `ext4`, `xfs`.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        """
        mount_target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Mount path. Works when auto_format is true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The length is 2~128 English or Chinese characters. It must start with an uppercase or lowr letter or a Chinese character and cannot start with http:// or https. Can contain numbers, colons (:), underscores (_), or dashes (-). It will be overwritten if auto_format is set.
        """
        performance_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        provisioned_iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The read/write IOPS preconfigured for the data disk, which is configured when the disk type is cloud_auto.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
elif False:
    NodePoolDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolDataDiskArgs:
    def __init__(__self__, *,
                 auto_format: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_snapshot_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bursting_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted: Optional[pulumi.Input[_builtins.str]] = None,
                 file_system: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_target: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 performance_level: Optional[pulumi.Input[_builtins.str]] = None,
                 provisioned_iops: Optional[pulumi.Input[_builtins.int]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auto_format: Whether to automatically mount the data disk. Valid values: true and false.
        :param pulumi.Input[_builtins.str] auto_snapshot_policy_id: The ID of the automatic snapshot policy that you want to apply to the system disk.
        :param pulumi.Input[_builtins.bool] bursting_enabled: Whether the data disk is enabled with Burst (performance Burst). This is configured when the disk type is cloud_auto.
        :param pulumi.Input[_builtins.str] category: The type of data disk. Default value: `cloud_efficiency`. Valid values:
        :param pulumi.Input[_builtins.str] device: The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        :param pulumi.Input[_builtins.str] encrypted: Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        :param pulumi.Input[_builtins.str] file_system: The type of the mounted file system. Works when auto_format is true. Optional value: `ext4`, `xfs`.
        :param pulumi.Input[_builtins.str] kms_key_id: The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        :param pulumi.Input[_builtins.str] mount_target: The Mount path. Works when auto_format is true.
        :param pulumi.Input[_builtins.str] name: The length is 2~128 English or Chinese characters. It must start with an uppercase or lowr letter or a Chinese character and cannot start with http:// or https. Can contain numbers, colons (:), underscores (_), or dashes (-). It will be overwritten if auto_format is set.
        :param pulumi.Input[_builtins.str] performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param pulumi.Input[_builtins.int] provisioned_iops: The read/write IOPS preconfigured for the data disk, which is configured when the disk type is cloud_auto.
        :param pulumi.Input[_builtins.int] size: The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
        if auto_format is not None:
            pulumi.set(__self__, "auto_format", auto_format)
        if auto_snapshot_policy_id is not None:
            pulumi.set(__self__, "auto_snapshot_policy_id", auto_snapshot_policy_id)
        if bursting_enabled is not None:
            pulumi.set(__self__, "bursting_enabled", bursting_enabled)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mount_target is not None:
            pulumi.set(__self__, "mount_target", mount_target)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if performance_level is not None:
            pulumi.set(__self__, "performance_level", performance_level)
        if provisioned_iops is not None:
            pulumi.set(__self__, "provisioned_iops", provisioned_iops)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @_builtins.property
    @pulumi.getter(name="autoFormat")
    def auto_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to automatically mount the data disk. Valid values: true and false.
        """
        return pulumi.get(self, "auto_format")

    @auto_format.setter
    def auto_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_format", value)

    @_builtins.property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the automatic snapshot policy that you want to apply to the system disk.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @auto_snapshot_policy_id.setter
    def auto_snapshot_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_snapshot_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="burstingEnabled")
    def bursting_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the data disk is enabled with Burst (performance Burst). This is configured when the disk type is cloud_auto.
        """
        return pulumi.get(self, "bursting_enabled")

    @bursting_enabled.setter
    def bursting_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bursting_enabled", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of data disk. Default value: `cloud_efficiency`. Valid values:
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the mounted file system. Works when auto_format is true. Optional value: `ext4`, `xfs`.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="mountTarget")
    def mount_target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Mount path. Works when auto_format is true.
        """
        return pulumi.get(self, "mount_target")

    @mount_target.setter
    def mount_target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_target", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The length is 2~128 English or Chinese characters. It must start with an uppercase or lowr letter or a Chinese character and cannot start with http:// or https. Can contain numbers, colons (:), underscores (_), or dashes (-). It will be overwritten if auto_format is set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "performance_level", value)

    @_builtins.property
    @pulumi.getter(name="provisionedIops")
    def provisioned_iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The read/write IOPS preconfigured for the data disk, which is configured when the disk type is cloud_auto.
        """
        return pulumi.get(self, "provisioned_iops")

    @provisioned_iops.setter
    def provisioned_iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "provisioned_iops", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)


if not MYPY:
    class NodePoolEfloNodeGroupArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the associated Lingjun cluster is required when creating a Lingjun node pool.
        """
        group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When creating a Lingjun node pool, you need the Lingjun group ID of the associated Lingjun cluster.
        """
elif False:
    NodePoolEfloNodeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolEfloNodeGroupArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: The ID of the associated Lingjun cluster is required when creating a Lingjun node pool.
        :param pulumi.Input[_builtins.str] group_id: When creating a Lingjun node pool, you need the Lingjun group ID of the associated Lingjun cluster.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the associated Lingjun cluster is required when creating a Lingjun node pool.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When creating a Lingjun node pool, you need the Lingjun group ID of the associated Lingjun cluster.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_id", value)


if not MYPY:
    class NodePoolKubeletConfigurationArgsDict(TypedDict):
        allowed_unsafe_sysctls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed sysctl mode whitelist.
        """
        cluster_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of IP addresses of the cluster DNS servers.
        """
        container_log_max_files: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum number of log files that can exist in each container.
        """
        container_log_max_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum size that can be reached before a log file is rotated.
        """
        container_log_max_workers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the maximum number of concurrent workers required to perform log rotation operations.
        """
        container_log_monitor_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the duration for which container logs are monitored for log rotation.
        """
        cpu_cfs_quota: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU CFS quota constraint switch.
        """
        cpu_cfs_quota_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU CFS quota period value.
        """
        cpu_manager_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        """
        event_burst: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        """
        event_record_qps: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        """
        eviction_hard: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        eviction_soft: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        eviction_soft_grace_period: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        """
        feature_gates: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]]
        """
        Feature switch to enable configuration of experimental features.
        """
        image_gc_high_threshold_percent: NotRequired[pulumi.Input[_builtins.str]]
        """
        If the image usage exceeds this threshold, image garbage collection will continue.
        """
        image_gc_low_threshold_percent: NotRequired[pulumi.Input[_builtins.str]]
        """
        Image garbage collection is not performed when the image usage is below this threshold.
        """
        kube_api_burst: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        """
        kube_api_qps: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        """
        kube_reserved: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        max_pods: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum number of running pods.
        """
        memory_manager_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy to be used by the memory manager.
        """
        pod_pids_limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum number of PIDs that can be used in a Pod.
        """
        read_only_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Read-only port number.
        """
        registry_burst: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        """
        registry_pull_qps: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        """
        reserved_memories: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodePoolKubeletConfigurationReservedMemoryArgsDict']]]]
        """
        Reserve memory for NUMA nodes. See `reserved_memory` below.
        """
        serialize_image_pulls: NotRequired[pulumi.Input[_builtins.str]]
        """
        Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        """
        system_reserved: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        topology_manager_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Topology Manager policy used.
        """
        tracing: NotRequired[pulumi.Input['NodePoolKubeletConfigurationTracingArgsDict']]
        """
        OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
        """
elif False:
    NodePoolKubeletConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolKubeletConfigurationArgs:
    def __init__(__self__, *,
                 allowed_unsafe_sysctls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 cluster_dns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 container_log_max_files: Optional[pulumi.Input[_builtins.str]] = None,
                 container_log_max_size: Optional[pulumi.Input[_builtins.str]] = None,
                 container_log_max_workers: Optional[pulumi.Input[_builtins.str]] = None,
                 container_log_monitor_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_cfs_quota: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_cfs_quota_period: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_manager_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 event_burst: Optional[pulumi.Input[_builtins.str]] = None,
                 event_record_qps: Optional[pulumi.Input[_builtins.str]] = None,
                 eviction_hard: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 eviction_soft: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 eviction_soft_grace_period: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 feature_gates: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]] = None,
                 image_gc_high_threshold_percent: Optional[pulumi.Input[_builtins.str]] = None,
                 image_gc_low_threshold_percent: Optional[pulumi.Input[_builtins.str]] = None,
                 kube_api_burst: Optional[pulumi.Input[_builtins.str]] = None,
                 kube_api_qps: Optional[pulumi.Input[_builtins.str]] = None,
                 kube_reserved: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_pods: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_manager_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_pids_limit: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only_port: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_burst: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_pull_qps: Optional[pulumi.Input[_builtins.str]] = None,
                 reserved_memories: Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolKubeletConfigurationReservedMemoryArgs']]]] = None,
                 serialize_image_pulls: Optional[pulumi.Input[_builtins.str]] = None,
                 system_reserved: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 topology_manager_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 tracing: Optional[pulumi.Input['NodePoolKubeletConfigurationTracingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_unsafe_sysctls: Allowed sysctl mode whitelist.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cluster_dns: The list of IP addresses of the cluster DNS servers.
        :param pulumi.Input[_builtins.str] container_log_max_files: The maximum number of log files that can exist in each container.
        :param pulumi.Input[_builtins.str] container_log_max_size: The maximum size that can be reached before a log file is rotated.
        :param pulumi.Input[_builtins.str] container_log_max_workers: Specifies the maximum number of concurrent workers required to perform log rotation operations.
        :param pulumi.Input[_builtins.str] container_log_monitor_interval: Specifies the duration for which container logs are monitored for log rotation.
        :param pulumi.Input[_builtins.str] cpu_cfs_quota: CPU CFS quota constraint switch.
        :param pulumi.Input[_builtins.str] cpu_cfs_quota_period: CPU CFS quota period value.
        :param pulumi.Input[_builtins.str] cpu_manager_policy: Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        :param pulumi.Input[_builtins.str] event_burst: Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        :param pulumi.Input[_builtins.str] event_record_qps: Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] eviction_hard: Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] eviction_soft: Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] eviction_soft_grace_period: Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]] feature_gates: Feature switch to enable configuration of experimental features.
        :param pulumi.Input[_builtins.str] image_gc_high_threshold_percent: If the image usage exceeds this threshold, image garbage collection will continue.
        :param pulumi.Input[_builtins.str] image_gc_low_threshold_percent: Image garbage collection is not performed when the image usage is below this threshold.
        :param pulumi.Input[_builtins.str] kube_api_burst: Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        :param pulumi.Input[_builtins.str] kube_api_qps: Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] kube_reserved: Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        :param pulumi.Input[_builtins.str] max_pods: The maximum number of running pods.
        :param pulumi.Input[_builtins.str] memory_manager_policy: The policy to be used by the memory manager.
        :param pulumi.Input[_builtins.str] pod_pids_limit: The maximum number of PIDs that can be used in a Pod.
        :param pulumi.Input[_builtins.str] read_only_port: Read-only port number.
        :param pulumi.Input[_builtins.str] registry_burst: Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        :param pulumi.Input[_builtins.str] registry_pull_qps: Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        :param pulumi.Input[Sequence[pulumi.Input['NodePoolKubeletConfigurationReservedMemoryArgs']]] reserved_memories: Reserve memory for NUMA nodes. See `reserved_memory` below.
        :param pulumi.Input[_builtins.str] serialize_image_pulls: Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] system_reserved: Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        :param pulumi.Input[_builtins.str] topology_manager_policy: Name of the Topology Manager policy used.
        :param pulumi.Input['NodePoolKubeletConfigurationTracingArgs'] tracing: OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
        """
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if cluster_dns is not None:
            pulumi.set(__self__, "cluster_dns", cluster_dns)
        if container_log_max_files is not None:
            pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        if container_log_max_size is not None:
            pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        if container_log_max_workers is not None:
            pulumi.set(__self__, "container_log_max_workers", container_log_max_workers)
        if container_log_monitor_interval is not None:
            pulumi.set(__self__, "container_log_monitor_interval", container_log_monitor_interval)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if event_burst is not None:
            pulumi.set(__self__, "event_burst", event_burst)
        if event_record_qps is not None:
            pulumi.set(__self__, "event_record_qps", event_record_qps)
        if eviction_hard is not None:
            pulumi.set(__self__, "eviction_hard", eviction_hard)
        if eviction_soft is not None:
            pulumi.set(__self__, "eviction_soft", eviction_soft)
        if eviction_soft_grace_period is not None:
            pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if image_gc_high_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        if image_gc_low_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        if kube_api_burst is not None:
            pulumi.set(__self__, "kube_api_burst", kube_api_burst)
        if kube_api_qps is not None:
            pulumi.set(__self__, "kube_api_qps", kube_api_qps)
        if kube_reserved is not None:
            pulumi.set(__self__, "kube_reserved", kube_reserved)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if memory_manager_policy is not None:
            pulumi.set(__self__, "memory_manager_policy", memory_manager_policy)
        if pod_pids_limit is not None:
            pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        if read_only_port is not None:
            pulumi.set(__self__, "read_only_port", read_only_port)
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if reserved_memories is not None:
            pulumi.set(__self__, "reserved_memories", reserved_memories)
        if serialize_image_pulls is not None:
            pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        if system_reserved is not None:
            pulumi.set(__self__, "system_reserved", system_reserved)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @_builtins.property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed sysctl mode whitelist.
        """
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @allowed_unsafe_sysctls.setter
    def allowed_unsafe_sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_unsafe_sysctls", value)

    @_builtins.property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of IP addresses of the cluster DNS servers.
        """
        return pulumi.get(self, "cluster_dns")

    @cluster_dns.setter
    def cluster_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cluster_dns", value)

    @_builtins.property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum number of log files that can exist in each container.
        """
        return pulumi.get(self, "container_log_max_files")

    @container_log_max_files.setter
    def container_log_max_files(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_log_max_files", value)

    @_builtins.property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size that can be reached before a log file is rotated.
        """
        return pulumi.get(self, "container_log_max_size")

    @container_log_max_size.setter
    def container_log_max_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_log_max_size", value)

    @_builtins.property
    @pulumi.getter(name="containerLogMaxWorkers")
    def container_log_max_workers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the maximum number of concurrent workers required to perform log rotation operations.
        """
        return pulumi.get(self, "container_log_max_workers")

    @container_log_max_workers.setter
    def container_log_max_workers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_log_max_workers", value)

    @_builtins.property
    @pulumi.getter(name="containerLogMonitorInterval")
    def container_log_monitor_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the duration for which container logs are monitored for log rotation.
        """
        return pulumi.get(self, "container_log_monitor_interval")

    @container_log_monitor_interval.setter
    def container_log_monitor_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_log_monitor_interval", value)

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU CFS quota constraint switch.
        """
        return pulumi.get(self, "cpu_cfs_quota")

    @cpu_cfs_quota.setter
    def cpu_cfs_quota(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_cfs_quota", value)

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU CFS quota period value.
        """
        return pulumi.get(self, "cpu_cfs_quota_period")

    @cpu_cfs_quota_period.setter
    def cpu_cfs_quota_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_cfs_quota_period", value)

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @_builtins.property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "event_burst")

    @event_burst.setter
    def event_burst(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_burst", value)

    @_builtins.property
    @pulumi.getter(name="eventRecordQps")
    def event_record_qps(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "event_record_qps")

    @event_record_qps.setter
    def event_record_qps(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_record_qps", value)

    @_builtins.property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        return pulumi.get(self, "eviction_hard")

    @eviction_hard.setter
    def eviction_hard(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "eviction_hard", value)

    @_builtins.property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        return pulumi.get(self, "eviction_soft")

    @eviction_soft.setter
    def eviction_soft(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "eviction_soft", value)

    @_builtins.property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        """
        return pulumi.get(self, "eviction_soft_grace_period")

    @eviction_soft_grace_period.setter
    def eviction_soft_grace_period(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "eviction_soft_grace_period", value)

    @_builtins.property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]]:
        """
        Feature switch to enable configuration of experimental features.
        """
        return pulumi.get(self, "feature_gates")

    @feature_gates.setter
    def feature_gates(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]]):
        pulumi.set(self, "feature_gates", value)

    @_builtins.property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If the image usage exceeds this threshold, image garbage collection will continue.
        """
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @image_gc_high_threshold_percent.setter
    def image_gc_high_threshold_percent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_gc_high_threshold_percent", value)

    @_builtins.property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Image garbage collection is not performed when the image usage is below this threshold.
        """
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @image_gc_low_threshold_percent.setter
    def image_gc_low_threshold_percent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_gc_low_threshold_percent", value)

    @_builtins.property
    @pulumi.getter(name="kubeApiBurst")
    def kube_api_burst(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "kube_api_burst")

    @kube_api_burst.setter
    def kube_api_burst(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kube_api_burst", value)

    @_builtins.property
    @pulumi.getter(name="kubeApiQps")
    def kube_api_qps(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "kube_api_qps")

    @kube_api_qps.setter
    def kube_api_qps(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kube_api_qps", value)

    @_builtins.property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        return pulumi.get(self, "kube_reserved")

    @kube_reserved.setter
    def kube_reserved(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "kube_reserved", value)

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum number of running pods.
        """
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_pods", value)

    @_builtins.property
    @pulumi.getter(name="memoryManagerPolicy")
    def memory_manager_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy to be used by the memory manager.
        """
        return pulumi.get(self, "memory_manager_policy")

    @memory_manager_policy.setter
    def memory_manager_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "memory_manager_policy", value)

    @_builtins.property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum number of PIDs that can be used in a Pod.
        """
        return pulumi.get(self, "pod_pids_limit")

    @pod_pids_limit.setter
    def pod_pids_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_pids_limit", value)

    @_builtins.property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Read-only port number.
        """
        return pulumi.get(self, "read_only_port")

    @read_only_port.setter
    def read_only_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read_only_port", value)

    @_builtins.property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "registry_burst")

    @registry_burst.setter
    def registry_burst(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_burst", value)

    @_builtins.property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "registry_pull_qps")

    @registry_pull_qps.setter
    def registry_pull_qps(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_pull_qps", value)

    @_builtins.property
    @pulumi.getter(name="reservedMemories")
    def reserved_memories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolKubeletConfigurationReservedMemoryArgs']]]]:
        """
        Reserve memory for NUMA nodes. See `reserved_memory` below.
        """
        return pulumi.get(self, "reserved_memories")

    @reserved_memories.setter
    def reserved_memories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodePoolKubeletConfigurationReservedMemoryArgs']]]]):
        pulumi.set(self, "reserved_memories", value)

    @_builtins.property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        """
        return pulumi.get(self, "serialize_image_pulls")

    @serialize_image_pulls.setter
    def serialize_image_pulls(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serialize_image_pulls", value)

    @_builtins.property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        return pulumi.get(self, "system_reserved")

    @system_reserved.setter
    def system_reserved(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_reserved", value)

    @_builtins.property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Topology Manager policy used.
        """
        return pulumi.get(self, "topology_manager_policy")

    @topology_manager_policy.setter
    def topology_manager_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topology_manager_policy", value)

    @_builtins.property
    @pulumi.getter
    def tracing(self) -> Optional[pulumi.Input['NodePoolKubeletConfigurationTracingArgs']]:
        """
        OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
        """
        return pulumi.get(self, "tracing")

    @tracing.setter
    def tracing(self, value: Optional[pulumi.Input['NodePoolKubeletConfigurationTracingArgs']]):
        pulumi.set(self, "tracing", value)


if not MYPY:
    class NodePoolKubeletConfigurationReservedMemoryArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Memory resource limit.
        """
        numa_node: NotRequired[pulumi.Input[_builtins.int]]
        """
        The NUMA node.
        """
elif False:
    NodePoolKubeletConfigurationReservedMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolKubeletConfigurationReservedMemoryArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 numa_node: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] limits: Memory resource limit.
        :param pulumi.Input[_builtins.int] numa_node: The NUMA node.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if numa_node is not None:
            pulumi.set(__self__, "numa_node", numa_node)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Memory resource limit.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter(name="numaNode")
    def numa_node(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The NUMA node.
        """
        return pulumi.get(self, "numa_node")

    @numa_node.setter
    def numa_node(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "numa_node", value)


if not MYPY:
    class NodePoolKubeletConfigurationTracingArgsDict(TypedDict):
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint of the collector.
        """
        sampling_rate_per_million: NotRequired[pulumi.Input[_builtins.str]]
        """
        Number of samples to be collected per million span.
        """
elif False:
    NodePoolKubeletConfigurationTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolKubeletConfigurationTracingArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 sampling_rate_per_million: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The endpoint of the collector.
        :param pulumi.Input[_builtins.str] sampling_rate_per_million: Number of samples to be collected per million span.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if sampling_rate_per_million is not None:
            pulumi.set(__self__, "sampling_rate_per_million", sampling_rate_per_million)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint of the collector.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="samplingRatePerMillion")
    def sampling_rate_per_million(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Number of samples to be collected per million span.
        """
        return pulumi.get(self, "sampling_rate_per_million")

    @sampling_rate_per_million.setter
    def sampling_rate_per_million(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sampling_rate_per_million", value)


if not MYPY:
    class NodePoolLabelArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The label key.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The label value.
        """
elif False:
    NodePoolLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The label key.
        :param pulumi.Input[_builtins.str] value: The label value.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodePoolManagementArgsDict(TypedDict):
        auto_repair: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable automatic repair. Valid values: `true`: Automatic repair. `false`: not automatically repaired.
        """
        auto_repair_policy: NotRequired[pulumi.Input['NodePoolManagementAutoRepairPolicyArgsDict']]
        """
        Automatic repair node policy. See `auto_repair_policy` below.
        """
        auto_upgrade: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable auto update. Valid values: `true`: enables auto update. `false`: disables auto update.
        """
        auto_upgrade_policy: NotRequired[pulumi.Input['NodePoolManagementAutoUpgradePolicyArgsDict']]
        """
        The auto update policy. See `auto_upgrade_policy` below.
        """
        auto_vul_fix: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to automatically patch CVE vulnerabilities. Valid values: `true`, `false`.
        """
        auto_vul_fix_policy: NotRequired[pulumi.Input['NodePoolManagementAutoVulFixPolicyArgsDict']]
        """
        The auto CVE patching policy. See `auto_vul_fix_policy` below.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the managed node pool feature. Valid values: `true`: enables the managed node pool feature. `false`: disables the managed node pool feature. Other parameters in this section take effect only when you specify enable=true.
        """
        max_unavailable: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of unavailable nodes. Default value: 1. Value range:\\[1,1000\\].
        """
        surge: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of additional nodes. You have to specify one of surge, surge_percentage.
        """
        surge_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
elif False:
    NodePoolManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolManagementArgs:
    def __init__(__self__, *,
                 auto_repair: Optional[pulumi.Input[_builtins.bool]] = None,
                 auto_repair_policy: Optional[pulumi.Input['NodePoolManagementAutoRepairPolicyArgs']] = None,
                 auto_upgrade: Optional[pulumi.Input[_builtins.bool]] = None,
                 auto_upgrade_policy: Optional[pulumi.Input['NodePoolManagementAutoUpgradePolicyArgs']] = None,
                 auto_vul_fix: Optional[pulumi.Input[_builtins.bool]] = None,
                 auto_vul_fix_policy: Optional[pulumi.Input['NodePoolManagementAutoVulFixPolicyArgs']] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_unavailable: Optional[pulumi.Input[_builtins.int]] = None,
                 surge: Optional[pulumi.Input[_builtins.int]] = None,
                 surge_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_repair: Whether to enable automatic repair. Valid values: `true`: Automatic repair. `false`: not automatically repaired.
        :param pulumi.Input['NodePoolManagementAutoRepairPolicyArgs'] auto_repair_policy: Automatic repair node policy. See `auto_repair_policy` below.
        :param pulumi.Input[_builtins.bool] auto_upgrade: Specifies whether to enable auto update. Valid values: `true`: enables auto update. `false`: disables auto update.
        :param pulumi.Input['NodePoolManagementAutoUpgradePolicyArgs'] auto_upgrade_policy: The auto update policy. See `auto_upgrade_policy` below.
        :param pulumi.Input[_builtins.bool] auto_vul_fix: Specifies whether to automatically patch CVE vulnerabilities. Valid values: `true`, `false`.
        :param pulumi.Input['NodePoolManagementAutoVulFixPolicyArgs'] auto_vul_fix_policy: The auto CVE patching policy. See `auto_vul_fix_policy` below.
        :param pulumi.Input[_builtins.bool] enable: Specifies whether to enable the managed node pool feature. Valid values: `true`: enables the managed node pool feature. `false`: disables the managed node pool feature. Other parameters in this section take effect only when you specify enable=true.
        :param pulumi.Input[_builtins.int] max_unavailable: Maximum number of unavailable nodes. Default value: 1. Value range:\\[1,1000\\].
        :param pulumi.Input[_builtins.int] surge: Number of additional nodes. You have to specify one of surge, surge_percentage.
        :param pulumi.Input[_builtins.int] surge_percentage: Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
        if auto_repair is not None:
            pulumi.set(__self__, "auto_repair", auto_repair)
        if auto_repair_policy is not None:
            pulumi.set(__self__, "auto_repair_policy", auto_repair_policy)
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if auto_upgrade_policy is not None:
            pulumi.set(__self__, "auto_upgrade_policy", auto_upgrade_policy)
        if auto_vul_fix is not None:
            pulumi.set(__self__, "auto_vul_fix", auto_vul_fix)
        if auto_vul_fix_policy is not None:
            pulumi.set(__self__, "auto_vul_fix_policy", auto_vul_fix_policy)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if surge is not None:
            warnings.warn("""Field 'surge' has been deprecated from provider version 1.219.0. Number of additional nodes. You have to specify one of surge, surge_percentage.""", DeprecationWarning)
            pulumi.log.warn("""surge is deprecated: Field 'surge' has been deprecated from provider version 1.219.0. Number of additional nodes. You have to specify one of surge, surge_percentage.""")
        if surge is not None:
            pulumi.set(__self__, "surge", surge)
        if surge_percentage is not None:
            warnings.warn("""Field 'surge_percentage' has been deprecated from provider version 1.219.0. Proportion of additional nodes. You have to specify one of surge, surge_percentage.""", DeprecationWarning)
            pulumi.log.warn("""surge_percentage is deprecated: Field 'surge_percentage' has been deprecated from provider version 1.219.0. Proportion of additional nodes. You have to specify one of surge, surge_percentage.""")
        if surge_percentage is not None:
            pulumi.set(__self__, "surge_percentage", surge_percentage)

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable automatic repair. Valid values: `true`: Automatic repair. `false`: not automatically repaired.
        """
        return pulumi.get(self, "auto_repair")

    @auto_repair.setter
    def auto_repair(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_repair", value)

    @_builtins.property
    @pulumi.getter(name="autoRepairPolicy")
    def auto_repair_policy(self) -> Optional[pulumi.Input['NodePoolManagementAutoRepairPolicyArgs']]:
        """
        Automatic repair node policy. See `auto_repair_policy` below.
        """
        return pulumi.get(self, "auto_repair_policy")

    @auto_repair_policy.setter
    def auto_repair_policy(self, value: Optional[pulumi.Input['NodePoolManagementAutoRepairPolicyArgs']]):
        pulumi.set(self, "auto_repair_policy", value)

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable auto update. Valid values: `true`: enables auto update. `false`: disables auto update.
        """
        return pulumi.get(self, "auto_upgrade")

    @auto_upgrade.setter
    def auto_upgrade(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_upgrade", value)

    @_builtins.property
    @pulumi.getter(name="autoUpgradePolicy")
    def auto_upgrade_policy(self) -> Optional[pulumi.Input['NodePoolManagementAutoUpgradePolicyArgs']]:
        """
        The auto update policy. See `auto_upgrade_policy` below.
        """
        return pulumi.get(self, "auto_upgrade_policy")

    @auto_upgrade_policy.setter
    def auto_upgrade_policy(self, value: Optional[pulumi.Input['NodePoolManagementAutoUpgradePolicyArgs']]):
        pulumi.set(self, "auto_upgrade_policy", value)

    @_builtins.property
    @pulumi.getter(name="autoVulFix")
    def auto_vul_fix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to automatically patch CVE vulnerabilities. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "auto_vul_fix")

    @auto_vul_fix.setter
    def auto_vul_fix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_vul_fix", value)

    @_builtins.property
    @pulumi.getter(name="autoVulFixPolicy")
    def auto_vul_fix_policy(self) -> Optional[pulumi.Input['NodePoolManagementAutoVulFixPolicyArgs']]:
        """
        The auto CVE patching policy. See `auto_vul_fix_policy` below.
        """
        return pulumi.get(self, "auto_vul_fix_policy")

    @auto_vul_fix_policy.setter
    def auto_vul_fix_policy(self, value: Optional[pulumi.Input['NodePoolManagementAutoVulFixPolicyArgs']]):
        pulumi.set(self, "auto_vul_fix_policy", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the managed node pool feature. Valid values: `true`: enables the managed node pool feature. `false`: disables the managed node pool feature. Other parameters in this section take effect only when you specify enable=true.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of unavailable nodes. Default value: 1. Value range:\\[1,1000\\].
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unavailable", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Field 'surge' has been deprecated from provider version 1.219.0. Number of additional nodes. You have to specify one of surge, surge_percentage.""")
    def surge(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of additional nodes. You have to specify one of surge, surge_percentage.
        """
        return pulumi.get(self, "surge")

    @surge.setter
    def surge(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "surge", value)

    @_builtins.property
    @pulumi.getter(name="surgePercentage")
    @_utilities.deprecated("""Field 'surge_percentage' has been deprecated from provider version 1.219.0. Proportion of additional nodes. You have to specify one of surge, surge_percentage.""")
    def surge_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
        return pulumi.get(self, "surge_percentage")

    @surge_percentage.setter
    def surge_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "surge_percentage", value)


if not MYPY:
    class NodePoolManagementAutoRepairPolicyArgsDict(TypedDict):
        restart_node: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to automatically restart nodes after patching CVE vulnerabilities. Valid values: `true`, `false`.
        """
elif False:
    NodePoolManagementAutoRepairPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolManagementAutoRepairPolicyArgs:
    def __init__(__self__, *,
                 restart_node: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] restart_node: Specifies whether to automatically restart nodes after patching CVE vulnerabilities. Valid values: `true`, `false`.
        """
        if restart_node is not None:
            pulumi.set(__self__, "restart_node", restart_node)

    @_builtins.property
    @pulumi.getter(name="restartNode")
    def restart_node(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to automatically restart nodes after patching CVE vulnerabilities. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "restart_node")

    @restart_node.setter
    def restart_node(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "restart_node", value)


if not MYPY:
    class NodePoolManagementAutoUpgradePolicyArgsDict(TypedDict):
        auto_upgrade_kubelet: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether  to automatically update the kubelet. Valid values: `true`: yes; `false`: no.
        """
elif False:
    NodePoolManagementAutoUpgradePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolManagementAutoUpgradePolicyArgs:
    def __init__(__self__, *,
                 auto_upgrade_kubelet: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_upgrade_kubelet: Specifies whether  to automatically update the kubelet. Valid values: `true`: yes; `false`: no.
        """
        if auto_upgrade_kubelet is not None:
            pulumi.set(__self__, "auto_upgrade_kubelet", auto_upgrade_kubelet)

    @_builtins.property
    @pulumi.getter(name="autoUpgradeKubelet")
    def auto_upgrade_kubelet(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether  to automatically update the kubelet. Valid values: `true`: yes; `false`: no.
        """
        return pulumi.get(self, "auto_upgrade_kubelet")

    @auto_upgrade_kubelet.setter
    def auto_upgrade_kubelet(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_upgrade_kubelet", value)


if not MYPY:
    class NodePoolManagementAutoVulFixPolicyArgsDict(TypedDict):
        restart_node: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to automatically restart nodes after patching CVE vulnerabilities. Valid values: `true`, `false`.
        """
        vul_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        The severity levels of vulnerabilities that is allowed to automatically patch. Multiple severity levels are separated by commas (,).
        """
elif False:
    NodePoolManagementAutoVulFixPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolManagementAutoVulFixPolicyArgs:
    def __init__(__self__, *,
                 restart_node: Optional[pulumi.Input[_builtins.bool]] = None,
                 vul_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] restart_node: Specifies whether to automatically restart nodes after patching CVE vulnerabilities. Valid values: `true`, `false`.
        :param pulumi.Input[_builtins.str] vul_level: The severity levels of vulnerabilities that is allowed to automatically patch. Multiple severity levels are separated by commas (,).
        """
        if restart_node is not None:
            pulumi.set(__self__, "restart_node", restart_node)
        if vul_level is not None:
            pulumi.set(__self__, "vul_level", vul_level)

    @_builtins.property
    @pulumi.getter(name="restartNode")
    def restart_node(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to automatically restart nodes after patching CVE vulnerabilities. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "restart_node")

    @restart_node.setter
    def restart_node(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "restart_node", value)

    @_builtins.property
    @pulumi.getter(name="vulLevel")
    def vul_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The severity levels of vulnerabilities that is allowed to automatically patch. Multiple severity levels are separated by commas (,).
        """
        return pulumi.get(self, "vul_level")

    @vul_level.setter
    def vul_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vul_level", value)


if not MYPY:
    class NodePoolPrivatePoolOptionsArgsDict(TypedDict):
        private_pool_options_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the private node pool.
        """
        private_pool_options_match_criteria: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of private node pool. This parameter specifies the type of the private pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values: `Open`: specifies an open private node pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used. `Target`: specifies a private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be started. `None`: no private node pool is used. The resources of private node pools are not used to launch the instances.
        """
elif False:
    NodePoolPrivatePoolOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolPrivatePoolOptionsArgs:
    def __init__(__self__, *,
                 private_pool_options_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_pool_options_match_criteria: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_pool_options_id: The ID of the private node pool.
        :param pulumi.Input[_builtins.str] private_pool_options_match_criteria: The type of private node pool. This parameter specifies the type of the private pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values: `Open`: specifies an open private node pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used. `Target`: specifies a private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be started. `None`: no private node pool is used. The resources of private node pools are not used to launch the instances.
        """
        if private_pool_options_id is not None:
            pulumi.set(__self__, "private_pool_options_id", private_pool_options_id)
        if private_pool_options_match_criteria is not None:
            pulumi.set(__self__, "private_pool_options_match_criteria", private_pool_options_match_criteria)

    @_builtins.property
    @pulumi.getter(name="privatePoolOptionsId")
    def private_pool_options_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the private node pool.
        """
        return pulumi.get(self, "private_pool_options_id")

    @private_pool_options_id.setter
    def private_pool_options_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_pool_options_id", value)

    @_builtins.property
    @pulumi.getter(name="privatePoolOptionsMatchCriteria")
    def private_pool_options_match_criteria(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of private node pool. This parameter specifies the type of the private pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values: `Open`: specifies an open private node pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used. `Target`: specifies a private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be started. `None`: no private node pool is used. The resources of private node pools are not used to launch the instances.
        """
        return pulumi.get(self, "private_pool_options_match_criteria")

    @private_pool_options_match_criteria.setter
    def private_pool_options_match_criteria(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_pool_options_match_criteria", value)


if not MYPY:
    class NodePoolRollingPolicyArgsDict(TypedDict):
        max_parallelism: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of unusable nodes.
        """
elif False:
    NodePoolRollingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolRollingPolicyArgs:
    def __init__(__self__, *,
                 max_parallelism: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_parallelism: The maximum number of unusable nodes.
        """
        if max_parallelism is not None:
            pulumi.set(__self__, "max_parallelism", max_parallelism)

    @_builtins.property
    @pulumi.getter(name="maxParallelism")
    def max_parallelism(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of unusable nodes.
        """
        return pulumi.get(self, "max_parallelism")

    @max_parallelism.setter
    def max_parallelism(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_parallelism", value)


if not MYPY:
    class NodePoolScalingConfigArgsDict(TypedDict):
        eip_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Peak EIP bandwidth. Its valid value range [1~500] in Mbps. It works if `is_bond_eip=true`. Default to `5`.
        """
        eip_internet_charge_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. It works if `is_bond_eip=true`, conflict with `internet_charge_type`. EIP and public network IP can only choose one.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable automatic scaling. Value:
        """
        is_bond_eip: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to bind EIP for an instance. Default: `false`.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        """
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Min number of instances in a auto scaling group, its valid value range [0~1000].
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
elif False:
    NodePoolScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolScalingConfigArgs:
    def __init__(__self__, *,
                 eip_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 eip_internet_charge_type: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_bond_eip: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] eip_bandwidth: Peak EIP bandwidth. Its valid value range [1~500] in Mbps. It works if `is_bond_eip=true`. Default to `5`.
        :param pulumi.Input[_builtins.str] eip_internet_charge_type: EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. It works if `is_bond_eip=true`, conflict with `internet_charge_type`. EIP and public network IP can only choose one.
        :param pulumi.Input[_builtins.bool] enable: Whether to enable automatic scaling. Value:
        :param pulumi.Input[_builtins.bool] is_bond_eip: Whether to bind EIP for an instance. Default: `false`.
        :param pulumi.Input[_builtins.int] max_size: Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        :param pulumi.Input[_builtins.int] min_size: Min number of instances in a auto scaling group, its valid value range [0~1000].
        :param pulumi.Input[_builtins.str] type: Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
        if eip_bandwidth is not None:
            pulumi.set(__self__, "eip_bandwidth", eip_bandwidth)
        if eip_internet_charge_type is not None:
            pulumi.set(__self__, "eip_internet_charge_type", eip_internet_charge_type)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if is_bond_eip is not None:
            pulumi.set(__self__, "is_bond_eip", is_bond_eip)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="eipBandwidth")
    def eip_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Peak EIP bandwidth. Its valid value range [1~500] in Mbps. It works if `is_bond_eip=true`. Default to `5`.
        """
        return pulumi.get(self, "eip_bandwidth")

    @eip_bandwidth.setter
    def eip_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "eip_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="eipInternetChargeType")
    def eip_internet_charge_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. It works if `is_bond_eip=true`, conflict with `internet_charge_type`. EIP and public network IP can only choose one.
        """
        return pulumi.get(self, "eip_internet_charge_type")

    @eip_internet_charge_type.setter
    def eip_internet_charge_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip_internet_charge_type", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable automatic scaling. Value:
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="isBondEip")
    def is_bond_eip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to bind EIP for an instance. Default: `false`.
        """
        return pulumi.get(self, "is_bond_eip")

    @is_bond_eip.setter
    def is_bond_eip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_bond_eip", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Min number of instances in a auto scaling group, its valid value range [0~1000].
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodePoolSpotPriceLimitArgsDict(TypedDict):
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the preemptible instance.
        """
        price_limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum price of a single instance.
        """
elif False:
    NodePoolSpotPriceLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolSpotPriceLimitArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 price_limit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_type: The type of the preemptible instance.
        :param pulumi.Input[_builtins.str] price_limit: The maximum price of a single instance.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if price_limit is not None:
            pulumi.set(__self__, "price_limit", price_limit)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the preemptible instance.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="priceLimit")
    def price_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum price of a single instance.
        """
        return pulumi.get(self, "price_limit")

    @price_limit.setter
    def price_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "price_limit", value)


if not MYPY:
    class NodePoolTaintArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of a taint.
        """
        effect: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheduling policy.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of a taint.
        """
elif False:
    NodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of a taint.
        :param pulumi.Input[_builtins.str] effect: The scheduling policy.
        :param pulumi.Input[_builtins.str] value: The value of a taint.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of a taint.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheduling policy.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of a taint.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodePoolTeeConfigArgsDict(TypedDict):
        tee_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable confidential computing for the cluster.
        """
elif False:
    NodePoolTeeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolTeeConfigArgs:
    def __init__(__self__, *,
                 tee_enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] tee_enable: Specifies whether to enable confidential computing for the cluster.
        """
        if tee_enable is not None:
            pulumi.set(__self__, "tee_enable", tee_enable)

    @_builtins.property
    @pulumi.getter(name="teeEnable")
    def tee_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable confidential computing for the cluster.
        """
        return pulumi.get(self, "tee_enable")

    @tee_enable.setter
    def tee_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tee_enable", value)


if not MYPY:
    class ServerlessKubernetesAddonArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:

        ```
        # install nginx ingress, conflict with ALB ingress
        addons {
        name = "nginx-ingress-controller"
        # use internet
        config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        # if use intranet, detail below.
        # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        }
        # install ALB ingress, conflict with nginx ingress
        addons {
        name = "alb-ingress-controller"
        }
        # install metric server
        addons {
        name = "metrics-server"
        }
        # install knative
        addons {
        name = "knative"
        }
        # install prometheus
        addons {
        name = "arms-prometheus"
        }
        ```
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        It specifies the version of the component.
        """
elif False:
    ServerlessKubernetesAddonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessKubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config: The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        :param pulumi.Input[_builtins.bool] disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
               
               ```
               # install nginx ingress, conflict with ALB ingress
               addons {
               name = "nginx-ingress-controller"
               # use internet
               config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
               # if use intranet, detail below.
               # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
               }
               # install ALB ingress, conflict with nginx ingress
               addons {
               name = "alb-ingress-controller"
               }
               # install metric server
               addons {
               name = "metrics-server"
               }
               # install knative
               addons {
               name = "knative"
               }
               # install prometheus
               addons {
               name = "arms-prometheus"
               }
               ```
        :param pulumi.Input[_builtins.str] name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        :param pulumi.Input[_builtins.str] version: It specifies the version of the component.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ACK add-on configurations. For more config information, see cs_kubernetes_addon_metadata.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:

        ```
        # install nginx ingress, conflict with ALB ingress
        addons {
        name = "nginx-ingress-controller"
        # use internet
        config = "{\\"IngressSlbNetworkType\\":\\"internet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        # if use intranet, detail below.
        # config = "{\\"IngressSlbNetworkType\\":\\"intranet",\\"IngressSlbSpec\\":\\"slb.s2.small\\"}"
        }
        # install ALB ingress, conflict with nginx ingress
        addons {
        name = "alb-ingress-controller"
        }
        # install metric server
        addons {
        name = "metrics-server"
        }
        # install knative
        addons {
        name = "knative"
        }
        # install prometheus
        addons {
        name = "arms-prometheus"
        }
        ```
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        It specifies the version of the component.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerlessKubernetesDeleteOptionArgsDict(TypedDict):
        delete_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resources that are created by cluster. Valid values:
        - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
        - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
        - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
        - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.
        - `PrivateZone`: PrivateZone resources created by the cluster, default behavior is to retain, option to delete is available.
        ```
        ...
        // Specify delete_options as below when deleting cluster
        // delete SLB resources created by the Nginx Ingress Service
        delete_options {
        delete_mode = "delete"
        resource_type = "SLB"
        }
        // delete ALB resources created by the ALB Ingress Controller
        delete_options {
        delete_mode = "delete"
        resource_type = "ALB"
        }
        // delete SLS Project used by the cluster logging feature
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_Data"
        }
        // delete SLS Project used for the managed cluster control plane logs
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_ControlPlane"
        }
        // delete PrivateZone resources created by the cluster
        delete_options {
        delete_mode = "delete"
        resource_type = "PrivateZone"
        }
        ```
        """
elif False:
    ServerlessKubernetesDeleteOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessKubernetesDeleteOptionArgs:
    def __init__(__self__, *,
                 delete_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete_mode: The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        :param pulumi.Input[_builtins.str] resource_type: The type of resources that are created by cluster. Valid values:
               - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
               - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
               - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
               - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.
               - `PrivateZone`: PrivateZone resources created by the cluster, default behavior is to retain, option to delete is available.
               ```
               ...
               // Specify delete_options as below when deleting cluster
               // delete SLB resources created by the Nginx Ingress Service
               delete_options {
               delete_mode = "delete"
               resource_type = "SLB"
               }
               // delete ALB resources created by the ALB Ingress Controller
               delete_options {
               delete_mode = "delete"
               resource_type = "ALB"
               }
               // delete SLS Project used by the cluster logging feature
               delete_options {
               delete_mode = "delete"
               resource_type = "SLS_Data"
               }
               // delete SLS Project used for the managed cluster control plane logs
               delete_options {
               delete_mode = "delete"
               resource_type = "SLS_ControlPlane"
               }
               // delete PrivateZone resources created by the cluster
               delete_options {
               delete_mode = "delete"
               resource_type = "PrivateZone"
               }
               ```
        """
        if delete_mode is not None:
            pulumi.set(__self__, "delete_mode", delete_mode)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="deleteMode")
    def delete_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The deletion mode of the cluster. Different resources may have different default behavior, see `resource_type` for details. Valid values:
        """
        return pulumi.get(self, "delete_mode")

    @delete_mode.setter
    def delete_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resources that are created by cluster. Valid values:
        - `SLB`: SLB resources created by the Nginx Ingress Service, default behavior is to delete, option to retain is available.
        - `ALB`: ALB resources created by the ALB Ingress Controller, default behavior is to retain, option to delete is available.
        - `SLS_Data`: SLS Project used by the cluster logging feature, default behavior is to retain, option to delete is available.
        - `SLS_ControlPlane`: SLS Project used for the managed cluster control plane logs, default behavior is to retain, option to delete is available.
        - `PrivateZone`: PrivateZone resources created by the cluster, default behavior is to retain, option to delete is available.
        ```
        ...
        // Specify delete_options as below when deleting cluster
        // delete SLB resources created by the Nginx Ingress Service
        delete_options {
        delete_mode = "delete"
        resource_type = "SLB"
        }
        // delete ALB resources created by the ALB Ingress Controller
        delete_options {
        delete_mode = "delete"
        resource_type = "ALB"
        }
        // delete SLS Project used by the cluster logging feature
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_Data"
        }
        // delete SLS Project used for the managed cluster control plane logs
        delete_options {
        delete_mode = "delete"
        resource_type = "SLS_ControlPlane"
        }
        // delete PrivateZone resources created by the cluster
        delete_options {
        delete_mode = "delete"
        resource_type = "PrivateZone"
        }
        ```
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class ServerlessKubernetesMaintenanceWindowArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        """
        maintenance_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Initial maintenance time, RFC3339 format. For example: "2024-10-15T12:31:00.000+08:00".
        """
        weekly_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.

        for example:
        ```
        maintenance_window {
        enable            = true
        maintenance_time  = "2024-10-15T12:31:00.000+08:00"
        duration          = "3h"
        weekly_period     = "Monday,Friday"
        }
        ```
        """
elif False:
    ServerlessKubernetesMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessKubernetesMaintenanceWindowArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 maintenance_time: Optional[pulumi.Input[_builtins.str]] = None,
                 weekly_period: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] duration: The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        :param pulumi.Input[_builtins.bool] enable: Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        :param pulumi.Input[_builtins.str] maintenance_time: Initial maintenance time, RFC3339 format. For example: "2024-10-15T12:31:00.000+08:00".
        :param pulumi.Input[_builtins.str] weekly_period: Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
               
               for example:
               ```
               maintenance_window {
               enable            = true
               maintenance_time  = "2024-10-15T12:31:00.000+08:00"
               duration          = "3h"
               weekly_period     = "Monday,Friday"
               }
               ```
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if maintenance_time is not None:
            pulumi.set(__self__, "maintenance_time", maintenance_time)
        if weekly_period is not None:
            pulumi.set(__self__, "weekly_period", weekly_period)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Initial maintenance time, RFC3339 format. For example: "2024-10-15T12:31:00.000+08:00".
        """
        return pulumi.get(self, "maintenance_time")

    @maintenance_time.setter
    def maintenance_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maintenance_time", value)

    @_builtins.property
    @pulumi.getter(name="weeklyPeriod")
    def weekly_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.

        for example:
        ```
        maintenance_window {
        enable            = true
        maintenance_time  = "2024-10-15T12:31:00.000+08:00"
        duration          = "3h"
        weekly_period     = "Monday,Friday"
        }
        ```
        """
        return pulumi.get(self, "weekly_period")

    @weekly_period.setter
    def weekly_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "weekly_period", value)


if not MYPY:
    class ServerlessKubernetesOperationPolicyArgsDict(TypedDict):
        cluster_auto_upgrade: NotRequired[pulumi.Input['ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgsDict']]
        """
        Automatic cluster upgrade policy. See `cluster_auto_upgrade` below.
        """
elif False:
    ServerlessKubernetesOperationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessKubernetesOperationPolicyArgs:
    def __init__(__self__, *,
                 cluster_auto_upgrade: Optional[pulumi.Input['ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgs']] = None):
        """
        :param pulumi.Input['ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgs'] cluster_auto_upgrade: Automatic cluster upgrade policy. See `cluster_auto_upgrade` below.
        """
        if cluster_auto_upgrade is not None:
            pulumi.set(__self__, "cluster_auto_upgrade", cluster_auto_upgrade)

    @_builtins.property
    @pulumi.getter(name="clusterAutoUpgrade")
    def cluster_auto_upgrade(self) -> Optional[pulumi.Input['ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgs']]:
        """
        Automatic cluster upgrade policy. See `cluster_auto_upgrade` below.
        """
        return pulumi.get(self, "cluster_auto_upgrade")

    @cluster_auto_upgrade.setter
    def cluster_auto_upgrade(self, value: Optional[pulumi.Input['ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgs']]):
        pulumi.set(self, "cluster_auto_upgrade", value)


if not MYPY:
    class ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The automatic cluster upgrade channel. Valid values: `patch`, `stable`, `rapid`.

        for example:
        ```
        operation_policy {
        cluster_auto_upgrade {
        enabled = true
        channel = "stable"
        }
        }
        ```
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the RRSA feature has been enabled.
        """
elif False:
    ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessKubernetesOperationPolicyClusterAutoUpgradeArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The automatic cluster upgrade channel. Valid values: `patch`, `stable`, `rapid`.
               
               for example:
               ```
               operation_policy {
               cluster_auto_upgrade {
               enabled = true
               channel = "stable"
               }
               }
               ```
        :param pulumi.Input[_builtins.bool] enabled: Whether the RRSA feature has been enabled.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The automatic cluster upgrade channel. Valid values: `patch`, `stable`, `rapid`.

        for example:
        ```
        operation_policy {
        cluster_auto_upgrade {
        enabled = true
        channel = "stable"
        }
        }
        ```
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ServerlessKubernetesRrsaMetadataArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the RRSA feature has been enabled.
        """
        ram_oidc_provider_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The arn of OIDC provider that was registered in RAM.
        """
        ram_oidc_provider_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of OIDC Provider that was registered in RAM.
        """
        rrsa_oidc_issuer_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer URL of RRSA OIDC Token.
        """
elif False:
    ServerlessKubernetesRrsaMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessKubernetesRrsaMetadataArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ram_oidc_provider_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 ram_oidc_provider_name: Optional[pulumi.Input[_builtins.str]] = None,
                 rrsa_oidc_issuer_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the RRSA feature has been enabled.
        :param pulumi.Input[_builtins.str] ram_oidc_provider_arn: The arn of OIDC provider that was registered in RAM.
        :param pulumi.Input[_builtins.str] ram_oidc_provider_name: The name of OIDC Provider that was registered in RAM.
        :param pulumi.Input[_builtins.str] rrsa_oidc_issuer_url: The issuer URL of RRSA OIDC Token.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ram_oidc_provider_arn is not None:
            pulumi.set(__self__, "ram_oidc_provider_arn", ram_oidc_provider_arn)
        if ram_oidc_provider_name is not None:
            pulumi.set(__self__, "ram_oidc_provider_name", ram_oidc_provider_name)
        if rrsa_oidc_issuer_url is not None:
            pulumi.set(__self__, "rrsa_oidc_issuer_url", rrsa_oidc_issuer_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="ramOidcProviderArn")
    def ram_oidc_provider_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The arn of OIDC provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_arn")

    @ram_oidc_provider_arn.setter
    def ram_oidc_provider_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ram_oidc_provider_arn", value)

    @_builtins.property
    @pulumi.getter(name="ramOidcProviderName")
    def ram_oidc_provider_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of OIDC Provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_name")

    @ram_oidc_provider_name.setter
    def ram_oidc_provider_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ram_oidc_provider_name", value)

    @_builtins.property
    @pulumi.getter(name="rrsaOidcIssuerUrl")
    def rrsa_oidc_issuer_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer URL of RRSA OIDC Token.
        """
        return pulumi.get(self, "rrsa_oidc_issuer_url")

    @rrsa_oidc_issuer_url.setter
    def rrsa_oidc_issuer_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rrsa_oidc_issuer_url", value)


if not MYPY:
    class SwarmNodeArgsDict(TypedDict):
        eip: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SwarmNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwarmNodeArgs:
    def __init__(__self__, *,
                 eip: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        if eip is not None:
            pulumi.set(__self__, "eip", eip)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


