# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ApplicationServiceArgs',
    'ClusterNodeArgs',
    'EdgeKubernetesAddonArgs',
    'EdgeKubernetesCertificateAuthorityArgs',
    'EdgeKubernetesConnectionsArgs',
    'EdgeKubernetesLogConfigArgs',
    'EdgeKubernetesRuntimeArgs',
    'EdgeKubernetesWorkerDataDiskArgs',
    'EdgeKubernetesWorkerNodeArgs',
    'KubernetesAddonArgs',
    'KubernetesAutoscalerNodepoolArgs',
    'KubernetesCertificateAuthorityArgs',
    'KubernetesConnectionsArgs',
    'KubernetesMasterNodeArgs',
    'KubernetesPermissionPermissionArgs',
    'KubernetesRuntimeArgs',
    'KubernetesTaintArgs',
    'KubernetesWorkerDataDiskArgs',
    'KubernetesWorkerNodeArgs',
    'ManagedKubernetesAddonArgs',
    'ManagedKubernetesCertificateAuthorityArgs',
    'ManagedKubernetesConnectionsArgs',
    'ManagedKubernetesMaintenanceWindowArgs',
    'ManagedKubernetesRrsaMetadataArgs',
    'ManagedKubernetesRuntimeArgs',
    'ManagedKubernetesTaintArgs',
    'ManagedKubernetesWorkerDataDiskArgs',
    'ManagedKubernetesWorkerNodeArgs',
    'NodePoolDataDiskArgs',
    'NodePoolKubeletConfigurationArgs',
    'NodePoolLabelArgs',
    'NodePoolManagementArgs',
    'NodePoolRollingPolicyArgs',
    'NodePoolRolloutPolicyArgs',
    'NodePoolScalingConfigArgs',
    'NodePoolSpotPriceLimitArgs',
    'NodePoolTaintArgs',
    'ServerlessKubernetesAddonArgs',
    'ServerlessKubernetesRrsaMetadataArgs',
    'SwarmNodeArgs',
    'GetKubernetesPermissionPermissionArgs',
]

@pulumi.input_type
class ApplicationServiceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        ApplicationServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class ClusterNodeArgs:
    def __init__(__self__, *,
                 eip: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        ClusterNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            eip=eip,
            id=id,
            name=name,
            private_ip=private_ip,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             eip: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if eip is not None:
            _setter("eip", eip)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def eip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eip", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class EdgeKubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config: The ACK add-on configurations.
        :param pulumi.Input[bool] disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
        :param pulumi.Input[str] name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        EdgeKubernetesAddonArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[pulumi.Input[str]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[str]]:
        """
        The ACK add-on configurations.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class EdgeKubernetesCertificateAuthorityArgs:
    def __init__(__self__, *,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_cert: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_cert: The path of client certificate, like `~/.kube/client-cert.pem`.
        :param pulumi.Input[str] client_key: The path of client key, like `~/.kube/client-key.pem`.
        :param pulumi.Input[str] cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        EdgeKubernetesCertificateAuthorityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[pulumi.Input[str]] = None,
             client_key: Optional[pulumi.Input[str]] = None,
             cluster_cert: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']

        if client_cert is not None:
            _setter("client_cert", client_cert)
        if client_key is not None:
            _setter("client_key", client_key)
        if cluster_cert is not None:
            _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path of client certificate, like `~/.kube/client-cert.pem`.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The path of client key, like `~/.kube/client-key.pem`.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")

    @cluster_cert.setter
    def cluster_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_cert", value)


@pulumi.input_type
class EdgeKubernetesConnectionsArgs:
    def __init__(__self__, *,
                 api_server_internet: Optional[pulumi.Input[str]] = None,
                 api_server_intranet: Optional[pulumi.Input[str]] = None,
                 master_public_ip: Optional[pulumi.Input[str]] = None,
                 service_domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_server_internet: API Server Internet endpoint.
        :param pulumi.Input[str] api_server_intranet: API Server Intranet endpoint.
        :param pulumi.Input[str] master_public_ip: Master node SSH IP address.
        :param pulumi.Input[str] service_domain: Service Access Domain.
        """
        EdgeKubernetesConnectionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[pulumi.Input[str]] = None,
             api_server_intranet: Optional[pulumi.Input[str]] = None,
             master_public_ip: Optional[pulumi.Input[str]] = None,
             service_domain: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']

        if api_server_internet is not None:
            _setter("api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            _setter("api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            _setter("master_public_ip", master_public_ip)
        if service_domain is not None:
            _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[pulumi.Input[str]]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @api_server_internet.setter
    def api_server_internet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server_internet", value)

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[pulumi.Input[str]]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @api_server_intranet.setter
    def api_server_intranet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server_intranet", value)

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @master_public_ip.setter
    def master_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_public_ip", value)

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_domain", value)


@pulumi.input_type
class EdgeKubernetesLogConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 project: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of collecting logs, only `SLS` are supported currently.
        :param pulumi.Input[str] project: Log Service project name, cluster logs will output to this project.
        """
        EdgeKubernetesLogConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            project=project,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             project: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        if project is not None:
            _setter("project", project)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of collecting logs, only `SLS` are supported currently.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        Log Service project name, cluster logs will output to this project.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)


@pulumi.input_type
class EdgeKubernetesRuntimeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param pulumi.Input[str] version: Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        EdgeKubernetesRuntimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class EdgeKubernetesWorkerDataDiskArgs:
    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 device: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 performance_level: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auto_snapshot_policy_id: Worker node data disk auto snapshot policy.
        :param pulumi.Input[str] category: The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param pulumi.Input[str] device: The device of the data disks.
        :param pulumi.Input[str] encrypted: Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        :param pulumi.Input[str] kms_key_id: The id of the kms key.
        :param pulumi.Input[str] name: The name of the data disks.
        :param pulumi.Input[str] performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param pulumi.Input[str] size: The size of a data disk, at least 40. Unit: GiB.
        :param pulumi.Input[str] snapshot_id: The id of snapshot.
        """
        EdgeKubernetesWorkerDataDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
             category: Optional[pulumi.Input[str]] = None,
             device: Optional[pulumi.Input[str]] = None,
             encrypted: Optional[pulumi.Input[str]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             performance_level: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[str]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @auto_snapshot_policy_id.setter
    def auto_snapshot_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_snapshot_policy_id", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device of the data disks.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the kms key.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the data disks.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[str]]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "performance_level", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)


@pulumi.input_type
class EdgeKubernetesWorkerNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the node.
        :param pulumi.Input[str] name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param pulumi.Input[str] private_ip: The private IP address of node.
        """
        EdgeKubernetesWorkerNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)


@pulumi.input_type
class KubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config: The ACK add-on configurations.
        :param pulumi.Input[bool] disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
        :param pulumi.Input[str] name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        KubernetesAddonArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[pulumi.Input[str]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[str]]:
        """
        The ACK add-on configurations.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesAutoscalerNodepoolArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The scaling group id of the groups configured for cluster-autoscaler.
        :param pulumi.Input[str] labels: The labels for the nodes in scaling group.
        :param pulumi.Input[str] taints: The taints for the nodes in scaling group.
        """
        KubernetesAutoscalerNodepoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             labels: Optional[pulumi.Input[str]] = None,
             taints: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The scaling group id of the groups configured for cluster-autoscaler.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[str]]:
        """
        The labels for the nodes in scaling group.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[str]]:
        """
        The taints for the nodes in scaling group.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class KubernetesCertificateAuthorityArgs:
    def __init__(__self__, *,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_cert: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_cert: The path of client certificate, like `~/.kube/client-cert.pem`.
        :param pulumi.Input[str] client_key: The path of client key, like `~/.kube/client-key.pem`.
        :param pulumi.Input[str] cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        KubernetesCertificateAuthorityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[pulumi.Input[str]] = None,
             client_key: Optional[pulumi.Input[str]] = None,
             cluster_cert: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']

        if client_cert is not None:
            _setter("client_cert", client_cert)
        if client_key is not None:
            _setter("client_key", client_key)
        if cluster_cert is not None:
            _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path of client certificate, like `~/.kube/client-cert.pem`.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The path of client key, like `~/.kube/client-key.pem`.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")

    @cluster_cert.setter
    def cluster_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_cert", value)


@pulumi.input_type
class KubernetesConnectionsArgs:
    def __init__(__self__, *,
                 api_server_internet: Optional[pulumi.Input[str]] = None,
                 api_server_intranet: Optional[pulumi.Input[str]] = None,
                 master_public_ip: Optional[pulumi.Input[str]] = None,
                 service_domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_server_internet: API Server Internet endpoint.
        :param pulumi.Input[str] api_server_intranet: API Server Intranet endpoint.
        :param pulumi.Input[str] master_public_ip: Master node SSH IP address.
        :param pulumi.Input[str] service_domain: Service Access Domain.
        """
        KubernetesConnectionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[pulumi.Input[str]] = None,
             api_server_intranet: Optional[pulumi.Input[str]] = None,
             master_public_ip: Optional[pulumi.Input[str]] = None,
             service_domain: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']

        if api_server_internet is not None:
            _setter("api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            _setter("api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            _setter("master_public_ip", master_public_ip)
        if service_domain is not None:
            _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[pulumi.Input[str]]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @api_server_internet.setter
    def api_server_internet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server_internet", value)

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[pulumi.Input[str]]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @api_server_intranet.setter
    def api_server_intranet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server_intranet", value)

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @master_public_ip.setter
    def master_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_public_ip", value)

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_domain", value)


@pulumi.input_type
class KubernetesMasterNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of a node.
        :param pulumi.Input[str] name: The name of a node.
        :param pulumi.Input[str] private_ip: The private ip of a node.
        """
        KubernetesMasterNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of a node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The private ip of a node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)


@pulumi.input_type
class KubernetesPermissionPermissionArgs:
    def __init__(__self__, *,
                 cluster: pulumi.Input[str],
                 role_name: pulumi.Input[str],
                 role_type: pulumi.Input[str],
                 is_custom: Optional[pulumi.Input[bool]] = None,
                 is_ram_role: Optional[pulumi.Input[bool]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster: The ID of the cluster that you want to manage.
        :param pulumi.Input[str] role_name: Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        :param pulumi.Input[str] role_type: The authorization type. Valid values `cluster`, `namespace`.
        :param pulumi.Input[bool] is_custom: Specifies whether to perform a custom authorization. To perform a custom authorization, set `role_name` to a custom cluster role.
        :param pulumi.Input[bool] is_ram_role: Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        :param pulumi.Input[str] namespace: The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
        KubernetesPermissionPermissionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster=cluster,
            role_name=role_name,
            role_type=role_type,
            is_custom=is_custom,
            is_ram_role=is_ram_role,
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster: pulumi.Input[str],
             role_name: pulumi.Input[str],
             role_type: pulumi.Input[str],
             is_custom: Optional[pulumi.Input[bool]] = None,
             is_ram_role: Optional[pulumi.Input[bool]] = None,
             namespace: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleName' in kwargs:
            role_name = kwargs['roleName']
        if 'roleType' in kwargs:
            role_type = kwargs['roleType']
        if 'isCustom' in kwargs:
            is_custom = kwargs['isCustom']
        if 'isRamRole' in kwargs:
            is_ram_role = kwargs['isRamRole']

        _setter("cluster", cluster)
        _setter("role_name", role_name)
        _setter("role_type", role_type)
        if is_custom is not None:
            _setter("is_custom", is_custom)
        if is_ram_role is not None:
            _setter("is_ram_role", is_ram_role)
        if namespace is not None:
            _setter("namespace", namespace)

    @property
    @pulumi.getter
    def cluster(self) -> pulumi.Input[str]:
        """
        The ID of the cluster that you want to manage.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> pulumi.Input[str]:
        """
        The authorization type. Valid values `cluster`, `namespace`.
        """
        return pulumi.get(self, "role_type")

    @role_type.setter
    def role_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_type", value)

    @property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to perform a custom authorization. To perform a custom authorization, set `role_name` to a custom cluster role.
        """
        return pulumi.get(self, "is_custom")

    @is_custom.setter
    def is_custom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom", value)

    @property
    @pulumi.getter(name="isRamRole")
    def is_ram_role(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        """
        return pulumi.get(self, "is_ram_role")

    @is_ram_role.setter
    def is_ram_role(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ram_role", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class KubernetesRuntimeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param pulumi.Input[str] version: Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        KubernetesRuntimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KubernetesTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: The scheduling policy. Valid values: NoSchedule | NoExecute | PreferNoSchedule. Default value: NoSchedule.
        :param pulumi.Input[str] key: The key of a taint.
        :param pulumi.Input[str] value: The key of a taint.
        """
        KubernetesTaintArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The scheduling policy. Valid values: NoSchedule | NoExecute | PreferNoSchedule. Default value: NoSchedule.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of a taint.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The key of a taint.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KubernetesWorkerDataDiskArgs:
    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 device: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 performance_level: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auto_snapshot_policy_id: Worker node data disk auto snapshot policy.
        :param pulumi.Input[str] category: The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param pulumi.Input[str] device: The device of the data disks.
        :param pulumi.Input[str] encrypted: Specifies whether to encrypt data disks. Valid values: true and false.
        :param pulumi.Input[str] kms_key_id: The id of the kms key.
        :param pulumi.Input[str] name: The name of the data disks.
        :param pulumi.Input[str] performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param pulumi.Input[str] size: The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
        :param pulumi.Input[str] snapshot_id: The id of snapshot.
        """
        KubernetesWorkerDataDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
             category: Optional[pulumi.Input[str]] = None,
             device: Optional[pulumi.Input[str]] = None,
             encrypted: Optional[pulumi.Input[str]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             performance_level: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[str]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @auto_snapshot_policy_id.setter
    def auto_snapshot_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_snapshot_policy_id", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device of the data disks.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the kms key.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the data disks.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[str]]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "performance_level", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)


@pulumi.input_type
class KubernetesWorkerNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the node.
        :param pulumi.Input[str] name: Node name.
        :param pulumi.Input[str] private_ip: The private IP address of node.
        """
        KubernetesWorkerNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)


@pulumi.input_type
class ManagedKubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config: If this parameter is left empty, no configurations are required.
        :param pulumi.Input[bool] disabled: It specifies whether to disable automatic installation. 
               
               It is a new field since 1.75.0. You can specific network plugin,log component,ingress component and so on.
               
               You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.
               
               `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.
               
               `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.
               
               The `main.tf`:
               
               
               The `varibales.tf`:
        :param pulumi.Input[str] name: This parameter specifies the name of the component.
        """
        ManagedKubernetesAddonArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[pulumi.Input[str]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[str]]:
        """
        If this parameter is left empty, no configurations are required.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        It specifies whether to disable automatic installation. 

        It is a new field since 1.75.0. You can specific network plugin,log component,ingress component and so on.

        You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.

        `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.

        `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.

        The `main.tf`:


        The `varibales.tf`:
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ManagedKubernetesCertificateAuthorityArgs:
    def __init__(__self__, *,
                 client_cert: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_cert: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_cert: The path of client certificate, like `~/.kube/client-cert.pem`.
        :param pulumi.Input[str] client_key: The path of client key, like `~/.kube/client-key.pem`.
        :param pulumi.Input[str] cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        ManagedKubernetesCertificateAuthorityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[pulumi.Input[str]] = None,
             client_key: Optional[pulumi.Input[str]] = None,
             cluster_cert: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']

        if client_cert is not None:
            _setter("client_cert", client_cert)
        if client_key is not None:
            _setter("client_key", client_key)
        if cluster_cert is not None:
            _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The path of client certificate, like `~/.kube/client-cert.pem`.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The path of client key, like `~/.kube/client-key.pem`.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")

    @cluster_cert.setter
    def cluster_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_cert", value)


@pulumi.input_type
class ManagedKubernetesConnectionsArgs:
    def __init__(__self__, *,
                 api_server_internet: Optional[pulumi.Input[str]] = None,
                 api_server_intranet: Optional[pulumi.Input[str]] = None,
                 master_public_ip: Optional[pulumi.Input[str]] = None,
                 service_domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_server_internet: API Server Internet endpoint.
        :param pulumi.Input[str] api_server_intranet: API Server Intranet endpoint.
        :param pulumi.Input[str] master_public_ip: Master node SSH IP address.
        :param pulumi.Input[str] service_domain: Service Access Domain.
        """
        ManagedKubernetesConnectionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[pulumi.Input[str]] = None,
             api_server_intranet: Optional[pulumi.Input[str]] = None,
             master_public_ip: Optional[pulumi.Input[str]] = None,
             service_domain: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']

        if api_server_internet is not None:
            _setter("api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            _setter("api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            _setter("master_public_ip", master_public_ip)
        if service_domain is not None:
            _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[pulumi.Input[str]]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @api_server_internet.setter
    def api_server_internet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server_internet", value)

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[pulumi.Input[str]]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @api_server_intranet.setter
    def api_server_intranet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server_intranet", value)

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @master_public_ip.setter
    def master_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_public_ip", value)

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_domain", value)


@pulumi.input_type
class ManagedKubernetesMaintenanceWindowArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 enable: pulumi.Input[bool],
                 maintenance_time: pulumi.Input[str],
                 weekly_period: pulumi.Input[str]):
        """
        :param pulumi.Input[str] duration: The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        :param pulumi.Input[bool] enable: Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        :param pulumi.Input[str] maintenance_time: Initial maintenance time, For example:"03:00:00Z".
        :param pulumi.Input[str] weekly_period: Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
               
               for example:
               ```python
               import pulumi
               ```
        """
        ManagedKubernetesMaintenanceWindowArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
            enable=enable,
            maintenance_time=maintenance_time,
            weekly_period=weekly_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: pulumi.Input[str],
             enable: pulumi.Input[bool],
             maintenance_time: pulumi.Input[str],
             weekly_period: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maintenanceTime' in kwargs:
            maintenance_time = kwargs['maintenanceTime']
        if 'weeklyPeriod' in kwargs:
            weekly_period = kwargs['weeklyPeriod']

        _setter("duration", duration)
        _setter("enable", enable)
        _setter("maintenance_time", maintenance_time)
        _setter("weekly_period", weekly_period)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def enable(self) -> pulumi.Input[bool]:
        """
        Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> pulumi.Input[str]:
        """
        Initial maintenance time, For example:"03:00:00Z".
        """
        return pulumi.get(self, "maintenance_time")

    @maintenance_time.setter
    def maintenance_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "maintenance_time", value)

    @property
    @pulumi.getter(name="weeklyPeriod")
    def weekly_period(self) -> pulumi.Input[str]:
        """
        Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.

        for example:
        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "weekly_period")

    @weekly_period.setter
    def weekly_period(self, value: pulumi.Input[str]):
        pulumi.set(self, "weekly_period", value)


@pulumi.input_type
class ManagedKubernetesRrsaMetadataArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 ram_oidc_provider_arn: Optional[pulumi.Input[str]] = None,
                 ram_oidc_provider_name: Optional[pulumi.Input[str]] = None,
                 rrsa_oidc_issuer_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether the RRSA feature has been enabled.
        :param pulumi.Input[str] ram_oidc_provider_arn: The arn of OIDC provider that was registered in RAM.
        :param pulumi.Input[str] ram_oidc_provider_name: The name of OIDC Provider that was registered in RAM.
        :param pulumi.Input[str] rrsa_oidc_issuer_url: The issuer URL of RRSA OIDC Token.
        """
        ManagedKubernetesRrsaMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            ram_oidc_provider_arn=ram_oidc_provider_arn,
            ram_oidc_provider_name=ram_oidc_provider_name,
            rrsa_oidc_issuer_url=rrsa_oidc_issuer_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             ram_oidc_provider_arn: Optional[pulumi.Input[str]] = None,
             ram_oidc_provider_name: Optional[pulumi.Input[str]] = None,
             rrsa_oidc_issuer_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ramOidcProviderArn' in kwargs:
            ram_oidc_provider_arn = kwargs['ramOidcProviderArn']
        if 'ramOidcProviderName' in kwargs:
            ram_oidc_provider_name = kwargs['ramOidcProviderName']
        if 'rrsaOidcIssuerUrl' in kwargs:
            rrsa_oidc_issuer_url = kwargs['rrsaOidcIssuerUrl']

        if enabled is not None:
            _setter("enabled", enabled)
        if ram_oidc_provider_arn is not None:
            _setter("ram_oidc_provider_arn", ram_oidc_provider_arn)
        if ram_oidc_provider_name is not None:
            _setter("ram_oidc_provider_name", ram_oidc_provider_name)
        if rrsa_oidc_issuer_url is not None:
            _setter("rrsa_oidc_issuer_url", rrsa_oidc_issuer_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="ramOidcProviderArn")
    def ram_oidc_provider_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The arn of OIDC provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_arn")

    @ram_oidc_provider_arn.setter
    def ram_oidc_provider_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ram_oidc_provider_arn", value)

    @property
    @pulumi.getter(name="ramOidcProviderName")
    def ram_oidc_provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of OIDC Provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_name")

    @ram_oidc_provider_name.setter
    def ram_oidc_provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ram_oidc_provider_name", value)

    @property
    @pulumi.getter(name="rrsaOidcIssuerUrl")
    def rrsa_oidc_issuer_url(self) -> Optional[pulumi.Input[str]]:
        """
        The issuer URL of RRSA OIDC Token.
        """
        return pulumi.get(self, "rrsa_oidc_issuer_url")

    @rrsa_oidc_issuer_url.setter
    def rrsa_oidc_issuer_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rrsa_oidc_issuer_url", value)


@pulumi.input_type
class ManagedKubernetesRuntimeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: This parameter specifies the name of the component.
        :param pulumi.Input[str] version: Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        ManagedKubernetesRuntimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class ManagedKubernetesTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: The taint effect.
               
               The following example is the definition of taints block:
               
               ```python
               import pulumi
               import pulumi_alicloud as alicloud
               
               k8s = alicloud.cs.ManagedKubernetes("k8s", taints=[
                   alicloud.cs.ManagedKubernetesTaintArgs(
                       effect="NoSchedule",
                       key="key-a",
                       value="value-a",
                   ),
                   alicloud.cs.ManagedKubernetesTaintArgs(
                       effect="NoSchedule",
                       key="key-b",
                       value="value-b",
                   ),
               ])
               ```
        :param pulumi.Input[str] key: The taint key.
        :param pulumi.Input[str] value: The taint value.
        """
        ManagedKubernetesTaintArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The taint effect.

        The following example is the definition of taints block:

        ```python
        import pulumi
        import pulumi_alicloud as alicloud

        k8s = alicloud.cs.ManagedKubernetes("k8s", taints=[
            alicloud.cs.ManagedKubernetesTaintArgs(
                effect="NoSchedule",
                key="key-a",
                value="value-a",
            ),
            alicloud.cs.ManagedKubernetesTaintArgs(
                effect="NoSchedule",
                key="key-b",
                value="value-b",
            ),
        ])
        ```
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The taint key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ManagedKubernetesWorkerDataDiskArgs:
    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 device: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 performance_level: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auto_snapshot_policy_id: (Optional, Available in 1.120.0+) Worker node data disk auto snapshot policy.
        :param pulumi.Input[str] category: (Optional)The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param pulumi.Input[str] device: The mount point of data disk N.
        :param pulumi.Input[str] encrypted: (Optional)Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        :param pulumi.Input[str] kms_key_id: The ID of the Key Management Service (KMS) key to use for data disk N.
        :param pulumi.Input[str] name: The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (.), underscores (_), and hyphens (-).
        :param pulumi.Input[str] performance_level: (Optional, Available in 1.120.0+) Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param pulumi.Input[str] size: (Optional)The size of a data disk, at least 40. Unit: GiB.
        :param pulumi.Input[str] snapshot_id: The ID of the snapshot to be used to create data disk N. Valid values of N: 1 to 16. When DataDisk.N.SnapshotId is specified, DataDisk.N.Size is ignored. The data disk is created based on the size of the specified snapshot. Use snapshots that were created on or after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        """
        ManagedKubernetesWorkerDataDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
             category: Optional[pulumi.Input[str]] = None,
             device: Optional[pulumi.Input[str]] = None,
             encrypted: Optional[pulumi.Input[str]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             performance_level: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[str]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional, Available in 1.120.0+) Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @auto_snapshot_policy_id.setter
    def auto_snapshot_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_snapshot_policy_id", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional)The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The mount point of data disk N.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional)Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Key Management Service (KMS) key to use for data disk N.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (.), underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional, Available in 1.120.0+) Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "performance_level", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional)The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the snapshot to be used to create data disk N. Valid values of N: 1 to 16. When DataDisk.N.SnapshotId is specified, DataDisk.N.Size is ignored. The data disk is created based on the size of the specified snapshot. Use snapshots that were created on or after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)


@pulumi.input_type
class ManagedKubernetesWorkerNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: (Deprecated from version 1.177.0) ID of the node.
        :param pulumi.Input[str] name: This parameter specifies the name of the component.
        :param pulumi.Input[str] private_ip: (Deprecated from version 1.177.0) The private IP address of node.
        """
        ManagedKubernetesWorkerNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Deprecated from version 1.177.0) ID of the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Deprecated from version 1.177.0) The private IP address of node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)


@pulumi.input_type
class NodePoolDataDiskArgs:
    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
                 category: Optional[pulumi.Input[str]] = None,
                 device: Optional[pulumi.Input[str]] = None,
                 encrypted: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 performance_level: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auto_snapshot_policy_id: The ID of the automatic snapshot policy that you want to apply to the system disk.
        :param pulumi.Input[str] category: The type of the data disks. Valid values:`cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`.
        :param pulumi.Input[str] device: The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        :param pulumi.Input[str] encrypted: Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        :param pulumi.Input[str] kms_key_id: The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        :param pulumi.Input[str] name: The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        :param pulumi.Input[str] performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param pulumi.Input[int] size: The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        :param pulumi.Input[str] snapshot_id: The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
        NodePoolDataDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[pulumi.Input[str]] = None,
             category: Optional[pulumi.Input[str]] = None,
             device: Optional[pulumi.Input[str]] = None,
             encrypted: Optional[pulumi.Input[str]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             performance_level: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[int]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the automatic snapshot policy that you want to apply to the system disk.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @auto_snapshot_policy_id.setter
    def auto_snapshot_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_snapshot_policy_id", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the data disks. Valid values:`cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[str]]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "performance_level", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)


@pulumi.input_type
class NodePoolKubeletConfigurationArgs:
    def __init__(__self__, *,
                 cpu_manager_policy: Optional[pulumi.Input[str]] = None,
                 event_burst: Optional[pulumi.Input[str]] = None,
                 event_record_qps: Optional[pulumi.Input[str]] = None,
                 eviction_hard: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 eviction_soft: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 eviction_soft_grace_period: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 kube_api_burst: Optional[pulumi.Input[str]] = None,
                 kube_api_qps: Optional[pulumi.Input[str]] = None,
                 kube_reserved: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 registry_burst: Optional[pulumi.Input[str]] = None,
                 registry_pull_qps: Optional[pulumi.Input[str]] = None,
                 serialize_image_pulls: Optional[pulumi.Input[str]] = None,
                 system_reserved: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] cpu_manager_policy: Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        :param pulumi.Input[str] event_burst: Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        :param pulumi.Input[str] event_record_qps: Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        :param pulumi.Input[Mapping[str, Any]] eviction_hard: Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        :param pulumi.Input[Mapping[str, Any]] eviction_soft: Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        :param pulumi.Input[Mapping[str, Any]] eviction_soft_grace_period: Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        :param pulumi.Input[str] kube_api_burst: Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        :param pulumi.Input[str] kube_api_qps: Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        :param pulumi.Input[Mapping[str, Any]] kube_reserved: Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        :param pulumi.Input[str] registry_burst: Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        :param pulumi.Input[str] registry_pull_qps: Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        :param pulumi.Input[str] serialize_image_pulls: Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        :param pulumi.Input[Mapping[str, Any]] system_reserved: Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        NodePoolKubeletConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_manager_policy=cpu_manager_policy,
            event_burst=event_burst,
            event_record_qps=event_record_qps,
            eviction_hard=eviction_hard,
            eviction_soft=eviction_soft,
            eviction_soft_grace_period=eviction_soft_grace_period,
            kube_api_burst=kube_api_burst,
            kube_api_qps=kube_api_qps,
            kube_reserved=kube_reserved,
            registry_burst=registry_burst,
            registry_pull_qps=registry_pull_qps,
            serialize_image_pulls=serialize_image_pulls,
            system_reserved=system_reserved,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_manager_policy: Optional[pulumi.Input[str]] = None,
             event_burst: Optional[pulumi.Input[str]] = None,
             event_record_qps: Optional[pulumi.Input[str]] = None,
             eviction_hard: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             eviction_soft: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             eviction_soft_grace_period: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             kube_api_burst: Optional[pulumi.Input[str]] = None,
             kube_api_qps: Optional[pulumi.Input[str]] = None,
             kube_reserved: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             registry_burst: Optional[pulumi.Input[str]] = None,
             registry_pull_qps: Optional[pulumi.Input[str]] = None,
             serialize_image_pulls: Optional[pulumi.Input[str]] = None,
             system_reserved: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cpuManagerPolicy' in kwargs:
            cpu_manager_policy = kwargs['cpuManagerPolicy']
        if 'eventBurst' in kwargs:
            event_burst = kwargs['eventBurst']
        if 'eventRecordQps' in kwargs:
            event_record_qps = kwargs['eventRecordQps']
        if 'evictionHard' in kwargs:
            eviction_hard = kwargs['evictionHard']
        if 'evictionSoft' in kwargs:
            eviction_soft = kwargs['evictionSoft']
        if 'evictionSoftGracePeriod' in kwargs:
            eviction_soft_grace_period = kwargs['evictionSoftGracePeriod']
        if 'kubeApiBurst' in kwargs:
            kube_api_burst = kwargs['kubeApiBurst']
        if 'kubeApiQps' in kwargs:
            kube_api_qps = kwargs['kubeApiQps']
        if 'kubeReserved' in kwargs:
            kube_reserved = kwargs['kubeReserved']
        if 'registryBurst' in kwargs:
            registry_burst = kwargs['registryBurst']
        if 'registryPullQps' in kwargs:
            registry_pull_qps = kwargs['registryPullQps']
        if 'serializeImagePulls' in kwargs:
            serialize_image_pulls = kwargs['serializeImagePulls']
        if 'systemReserved' in kwargs:
            system_reserved = kwargs['systemReserved']

        if cpu_manager_policy is not None:
            _setter("cpu_manager_policy", cpu_manager_policy)
        if event_burst is not None:
            _setter("event_burst", event_burst)
        if event_record_qps is not None:
            _setter("event_record_qps", event_record_qps)
        if eviction_hard is not None:
            _setter("eviction_hard", eviction_hard)
        if eviction_soft is not None:
            _setter("eviction_soft", eviction_soft)
        if eviction_soft_grace_period is not None:
            _setter("eviction_soft_grace_period", eviction_soft_grace_period)
        if kube_api_burst is not None:
            _setter("kube_api_burst", kube_api_burst)
        if kube_api_qps is not None:
            _setter("kube_api_qps", kube_api_qps)
        if kube_reserved is not None:
            _setter("kube_reserved", kube_reserved)
        if registry_burst is not None:
            _setter("registry_burst", registry_burst)
        if registry_pull_qps is not None:
            _setter("registry_pull_qps", registry_pull_qps)
        if serialize_image_pulls is not None:
            _setter("serialize_image_pulls", serialize_image_pulls)
        if system_reserved is not None:
            _setter("system_reserved", system_reserved)

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> Optional[pulumi.Input[str]]:
        """
        Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "event_burst")

    @event_burst.setter
    def event_burst(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_burst", value)

    @property
    @pulumi.getter(name="eventRecordQps")
    def event_record_qps(self) -> Optional[pulumi.Input[str]]:
        """
        Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "event_record_qps")

    @event_record_qps.setter
    def event_record_qps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_record_qps", value)

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        return pulumi.get(self, "eviction_hard")

    @eviction_hard.setter
    def eviction_hard(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "eviction_hard", value)

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        return pulumi.get(self, "eviction_soft")

    @eviction_soft.setter
    def eviction_soft(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "eviction_soft", value)

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        """
        return pulumi.get(self, "eviction_soft_grace_period")

    @eviction_soft_grace_period.setter
    def eviction_soft_grace_period(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "eviction_soft_grace_period", value)

    @property
    @pulumi.getter(name="kubeApiBurst")
    def kube_api_burst(self) -> Optional[pulumi.Input[str]]:
        """
        Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "kube_api_burst")

    @kube_api_burst.setter
    def kube_api_burst(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kube_api_burst", value)

    @property
    @pulumi.getter(name="kubeApiQps")
    def kube_api_qps(self) -> Optional[pulumi.Input[str]]:
        """
        Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "kube_api_qps")

    @kube_api_qps.setter
    def kube_api_qps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kube_api_qps", value)

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        return pulumi.get(self, "kube_reserved")

    @kube_reserved.setter
    def kube_reserved(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "kube_reserved", value)

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[pulumi.Input[str]]:
        """
        Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "registry_burst")

    @registry_burst.setter
    def registry_burst(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_burst", value)

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[pulumi.Input[str]]:
        """
        Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "registry_pull_qps")

    @registry_pull_qps.setter
    def registry_pull_qps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_pull_qps", value)

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> Optional[pulumi.Input[str]]:
        """
        Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        """
        return pulumi.get(self, "serialize_image_pulls")

    @serialize_image_pulls.setter
    def serialize_image_pulls(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serialize_image_pulls", value)

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        return pulumi.get(self, "system_reserved")

    @system_reserved.setter
    def system_reserved(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "system_reserved", value)


@pulumi.input_type
class NodePoolLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        NodePoolLabelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NodePoolManagementArgs:
    def __init__(__self__, *,
                 max_unavailable: pulumi.Input[int],
                 auto_repair: Optional[pulumi.Input[bool]] = None,
                 auto_upgrade: Optional[pulumi.Input[bool]] = None,
                 surge: Optional[pulumi.Input[int]] = None,
                 surge_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_unavailable: Max number of unavailable nodes. Default to `1`.
        :param pulumi.Input[bool] auto_repair: Whether automatic repair, Default to `false`.
        :param pulumi.Input[bool] auto_upgrade: Whether auto upgrade, Default to `false`.
        :param pulumi.Input[int] surge: Number of additional nodes. You have to specify one of surge, surge_percentage.
        :param pulumi.Input[int] surge_percentage: Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
        NodePoolManagementArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_unavailable=max_unavailable,
            auto_repair=auto_repair,
            auto_upgrade=auto_upgrade,
            surge=surge,
            surge_percentage=surge_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_unavailable: pulumi.Input[int],
             auto_repair: Optional[pulumi.Input[bool]] = None,
             auto_upgrade: Optional[pulumi.Input[bool]] = None,
             surge: Optional[pulumi.Input[int]] = None,
             surge_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']
        if 'autoRepair' in kwargs:
            auto_repair = kwargs['autoRepair']
        if 'autoUpgrade' in kwargs:
            auto_upgrade = kwargs['autoUpgrade']
        if 'surgePercentage' in kwargs:
            surge_percentage = kwargs['surgePercentage']

        _setter("max_unavailable", max_unavailable)
        if auto_repair is not None:
            _setter("auto_repair", auto_repair)
        if auto_upgrade is not None:
            _setter("auto_upgrade", auto_upgrade)
        if surge is not None:
            _setter("surge", surge)
        if surge_percentage is not None:
            _setter("surge_percentage", surge_percentage)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> pulumi.Input[int]:
        """
        Max number of unavailable nodes. Default to `1`.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether automatic repair, Default to `false`.
        """
        return pulumi.get(self, "auto_repair")

    @auto_repair.setter
    def auto_repair(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_repair", value)

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether auto upgrade, Default to `false`.
        """
        return pulumi.get(self, "auto_upgrade")

    @auto_upgrade.setter
    def auto_upgrade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade", value)

    @property
    @pulumi.getter
    def surge(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional nodes. You have to specify one of surge, surge_percentage.
        """
        return pulumi.get(self, "surge")

    @surge.setter
    def surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "surge", value)

    @property
    @pulumi.getter(name="surgePercentage")
    def surge_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
        return pulumi.get(self, "surge_percentage")

    @surge_percentage.setter
    def surge_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "surge_percentage", value)


@pulumi.input_type
class NodePoolRollingPolicyArgs:
    def __init__(__self__, *,
                 max_parallelism: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_parallelism: Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used.
        """
        NodePoolRollingPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_parallelism=max_parallelism,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_parallelism: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxParallelism' in kwargs:
            max_parallelism = kwargs['maxParallelism']

        if max_parallelism is not None:
            _setter("max_parallelism", max_parallelism)

    @property
    @pulumi.getter(name="maxParallelism")
    def max_parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used.
        """
        return pulumi.get(self, "max_parallelism")

    @max_parallelism.setter
    def max_parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallelism", value)


@pulumi.input_type
class NodePoolRolloutPolicyArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used. Please use `max_parallelism` to instead it from provider version 1.185.0.
        """
        NodePoolRolloutPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_unavailable=max_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_unavailable: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']

        if max_unavailable is not None:
            _setter("max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used. Please use `max_parallelism` to instead it from provider version 1.185.0.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


@pulumi.input_type
class NodePoolScalingConfigArgs:
    def __init__(__self__, *,
                 max_size: pulumi.Input[int],
                 min_size: pulumi.Input[int],
                 eip_bandwidth: Optional[pulumi.Input[int]] = None,
                 eip_internet_charge_type: Optional[pulumi.Input[str]] = None,
                 is_bond_eip: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] max_size: Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        :param pulumi.Input[int] min_size: Min number of instances in a auto scaling group, its valid value range [0~1000].
        :param pulumi.Input[int] eip_bandwidth: Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
        :param pulumi.Input[str] eip_internet_charge_type: EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internet_charge_type`, EIP and public network IP can only choose one.
        :param pulumi.Input[bool] is_bond_eip: Whether to bind EIP for an instance. Default: `false`.
        :param pulumi.Input[str] type: Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
        NodePoolScalingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            min_size=min_size,
            eip_bandwidth=eip_bandwidth,
            eip_internet_charge_type=eip_internet_charge_type,
            is_bond_eip=is_bond_eip,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: pulumi.Input[int],
             min_size: pulumi.Input[int],
             eip_bandwidth: Optional[pulumi.Input[int]] = None,
             eip_internet_charge_type: Optional[pulumi.Input[str]] = None,
             is_bond_eip: Optional[pulumi.Input[bool]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if 'eipBandwidth' in kwargs:
            eip_bandwidth = kwargs['eipBandwidth']
        if 'eipInternetChargeType' in kwargs:
            eip_internet_charge_type = kwargs['eipInternetChargeType']
        if 'isBondEip' in kwargs:
            is_bond_eip = kwargs['isBondEip']

        _setter("max_size", max_size)
        _setter("min_size", min_size)
        if eip_bandwidth is not None:
            _setter("eip_bandwidth", eip_bandwidth)
        if eip_internet_charge_type is not None:
            _setter("eip_internet_charge_type", eip_internet_charge_type)
        if is_bond_eip is not None:
            _setter("is_bond_eip", is_bond_eip)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[int]:
        """
        Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> pulumi.Input[int]:
        """
        Min number of instances in a auto scaling group, its valid value range [0~1000].
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_size", value)

    @property
    @pulumi.getter(name="eipBandwidth")
    def eip_bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
        """
        return pulumi.get(self, "eip_bandwidth")

    @eip_bandwidth.setter
    def eip_bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eip_bandwidth", value)

    @property
    @pulumi.getter(name="eipInternetChargeType")
    def eip_internet_charge_type(self) -> Optional[pulumi.Input[str]]:
        """
        EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internet_charge_type`, EIP and public network IP can only choose one.
        """
        return pulumi.get(self, "eip_internet_charge_type")

    @eip_internet_charge_type.setter
    def eip_internet_charge_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eip_internet_charge_type", value)

    @property
    @pulumi.getter(name="isBondEip")
    def is_bond_eip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to bind EIP for an instance. Default: `false`.
        """
        return pulumi.get(self, "is_bond_eip")

    @is_bond_eip.setter
    def is_bond_eip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_bond_eip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NodePoolSpotPriceLimitArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 price_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_type: Spot instance type.
        :param pulumi.Input[str] price_limit: The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
        """
        NodePoolSpotPriceLimitArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            price_limit=price_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: Optional[pulumi.Input[str]] = None,
             price_limit: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if 'priceLimit' in kwargs:
            price_limit = kwargs['priceLimit']

        if instance_type is not None:
            _setter("instance_type", instance_type)
        if price_limit is not None:
            _setter("price_limit", price_limit)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Spot instance type.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="priceLimit")
    def price_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
        """
        return pulumi.get(self, "price_limit")

    @price_limit.setter
    def price_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "price_limit", value)


@pulumi.input_type
class NodePoolTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of a taint.
        :param pulumi.Input[str] effect: The scheduling policy.
        :param pulumi.Input[str] value: The value of a taint.
        """
        NodePoolTaintArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            effect=effect,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             effect: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)
        if effect is not None:
            _setter("effect", effect)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of a taint.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The scheduling policy.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of a taint.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServerlessKubernetesAddonArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config: The ACK add-on configurations.
        :param pulumi.Input[bool] disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
        :param pulumi.Input[str] name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        ServerlessKubernetesAddonArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[pulumi.Input[str]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[str]]:
        """
        The ACK add-on configurations.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ServerlessKubernetesRrsaMetadataArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 ram_oidc_provider_arn: Optional[pulumi.Input[str]] = None,
                 ram_oidc_provider_name: Optional[pulumi.Input[str]] = None,
                 rrsa_oidc_issuer_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether the RRSA feature has been enabled.
        :param pulumi.Input[str] ram_oidc_provider_arn: The arn of OIDC provider that was registered in RAM.
        :param pulumi.Input[str] ram_oidc_provider_name: The name of OIDC Provider that was registered in RAM.
        :param pulumi.Input[str] rrsa_oidc_issuer_url: The issuer URL of RRSA OIDC Token.
        """
        ServerlessKubernetesRrsaMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            ram_oidc_provider_arn=ram_oidc_provider_arn,
            ram_oidc_provider_name=ram_oidc_provider_name,
            rrsa_oidc_issuer_url=rrsa_oidc_issuer_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             ram_oidc_provider_arn: Optional[pulumi.Input[str]] = None,
             ram_oidc_provider_name: Optional[pulumi.Input[str]] = None,
             rrsa_oidc_issuer_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ramOidcProviderArn' in kwargs:
            ram_oidc_provider_arn = kwargs['ramOidcProviderArn']
        if 'ramOidcProviderName' in kwargs:
            ram_oidc_provider_name = kwargs['ramOidcProviderName']
        if 'rrsaOidcIssuerUrl' in kwargs:
            rrsa_oidc_issuer_url = kwargs['rrsaOidcIssuerUrl']

        if enabled is not None:
            _setter("enabled", enabled)
        if ram_oidc_provider_arn is not None:
            _setter("ram_oidc_provider_arn", ram_oidc_provider_arn)
        if ram_oidc_provider_name is not None:
            _setter("ram_oidc_provider_name", ram_oidc_provider_name)
        if rrsa_oidc_issuer_url is not None:
            _setter("rrsa_oidc_issuer_url", rrsa_oidc_issuer_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="ramOidcProviderArn")
    def ram_oidc_provider_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The arn of OIDC provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_arn")

    @ram_oidc_provider_arn.setter
    def ram_oidc_provider_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ram_oidc_provider_arn", value)

    @property
    @pulumi.getter(name="ramOidcProviderName")
    def ram_oidc_provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of OIDC Provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_name")

    @ram_oidc_provider_name.setter
    def ram_oidc_provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ram_oidc_provider_name", value)

    @property
    @pulumi.getter(name="rrsaOidcIssuerUrl")
    def rrsa_oidc_issuer_url(self) -> Optional[pulumi.Input[str]]:
        """
        The issuer URL of RRSA OIDC Token.
        """
        return pulumi.get(self, "rrsa_oidc_issuer_url")

    @rrsa_oidc_issuer_url.setter
    def rrsa_oidc_issuer_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rrsa_oidc_issuer_url", value)


@pulumi.input_type
class SwarmNodeArgs:
    def __init__(__self__, *,
                 eip: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        SwarmNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            eip=eip,
            id=id,
            name=name,
            private_ip=private_ip,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             eip: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if eip is not None:
            _setter("eip", eip)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def eip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eip", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class GetKubernetesPermissionPermissionArgs:
    def __init__(__self__, *,
                 resource_id: str,
                 resource_type: str,
                 role_name: str,
                 is_owner: Optional[bool] = None,
                 is_ram_role: Optional[bool] = None,
                 role_type: Optional[str] = None):
        """
        :param str resource_id: The permission settings to manage ACK clusters.
        :param str resource_type: The authorization type. Valid values `cluster`, `namespace` and `console`.
        :param str role_name: The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
        :param bool is_owner: ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
        :param bool is_ram_role: Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
        :param str role_type: The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
        """
        GetKubernetesPermissionPermissionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_id=resource_id,
            resource_type=resource_type,
            role_name=role_name,
            is_owner=is_owner,
            is_ram_role=is_ram_role,
            role_type=role_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_id: str,
             resource_type: str,
             role_name: str,
             is_owner: Optional[bool] = None,
             is_ram_role: Optional[bool] = None,
             role_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'roleName' in kwargs:
            role_name = kwargs['roleName']
        if 'isOwner' in kwargs:
            is_owner = kwargs['isOwner']
        if 'isRamRole' in kwargs:
            is_ram_role = kwargs['isRamRole']
        if 'roleType' in kwargs:
            role_type = kwargs['roleType']

        _setter("resource_id", resource_id)
        _setter("resource_type", resource_type)
        _setter("role_name", role_name)
        if is_owner is not None:
            _setter("is_owner", is_owner)
        if is_ram_role is not None:
            _setter("is_ram_role", is_ram_role)
        if role_type is not None:
            _setter("role_type", role_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The permission settings to manage ACK clusters.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: str):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        The authorization type. Valid values `cluster`, `namespace` and `console`.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: str):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: str):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter(name="isOwner")
    def is_owner(self) -> Optional[bool]:
        """
        ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
        """
        return pulumi.get(self, "is_owner")

    @is_owner.setter
    def is_owner(self, value: Optional[bool]):
        pulumi.set(self, "is_owner", value)

    @property
    @pulumi.getter(name="isRamRole")
    def is_ram_role(self) -> Optional[bool]:
        """
        Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
        """
        return pulumi.get(self, "is_ram_role")

    @is_ram_role.setter
    def is_ram_role(self, value: Optional[bool]):
        pulumi.set(self, "is_ram_role", value)

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> Optional[str]:
        """
        The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
        """
        return pulumi.get(self, "role_type")

    @role_type.setter
    def role_type(self, value: Optional[str]):
        pulumi.set(self, "role_type", value)


