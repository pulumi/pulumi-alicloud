# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationService',
    'ClusterNode',
    'EdgeKubernetesAddon',
    'EdgeKubernetesCertificateAuthority',
    'EdgeKubernetesConnections',
    'EdgeKubernetesLogConfig',
    'EdgeKubernetesRuntime',
    'EdgeKubernetesWorkerDataDisk',
    'EdgeKubernetesWorkerNode',
    'KubernetesAddon',
    'KubernetesAutoscalerNodepool',
    'KubernetesCertificateAuthority',
    'KubernetesConnections',
    'KubernetesMasterNode',
    'KubernetesPermissionPermission',
    'KubernetesRuntime',
    'KubernetesTaint',
    'KubernetesWorkerDataDisk',
    'KubernetesWorkerNode',
    'ManagedKubernetesAddon',
    'ManagedKubernetesCertificateAuthority',
    'ManagedKubernetesConnections',
    'ManagedKubernetesMaintenanceWindow',
    'ManagedKubernetesRrsaMetadata',
    'ManagedKubernetesRuntime',
    'ManagedKubernetesTaint',
    'ManagedKubernetesWorkerDataDisk',
    'ManagedKubernetesWorkerNode',
    'NodePoolDataDisk',
    'NodePoolKubeletConfiguration',
    'NodePoolLabel',
    'NodePoolManagement',
    'NodePoolRollingPolicy',
    'NodePoolRolloutPolicy',
    'NodePoolScalingConfig',
    'NodePoolSpotPriceLimit',
    'NodePoolTaint',
    'ServerlessKubernetesAddon',
    'ServerlessKubernetesRrsaMetadata',
    'SwarmNode',
    'GetClusterCredentialCertificateAuthorityResult',
    'GetEdgeKubernetesClustersClusterResult',
    'GetEdgeKubernetesClustersClusterConnectionsResult',
    'GetEdgeKubernetesClustersClusterWorkerNodeResult',
    'GetKubernetesAddonsAddonResult',
    'GetKubernetesClustersClusterResult',
    'GetKubernetesClustersClusterConnectionsResult',
    'GetKubernetesClustersClusterLogConfigResult',
    'GetKubernetesClustersClusterMasterNodeResult',
    'GetKubernetesClustersClusterWorkerNodeResult',
    'GetKubernetesPermissionPermissionResult',
    'GetKubernetesVersionMetadataResult',
    'GetKubernetesVersionMetadataRuntimeResult',
    'GetManagedKubernetesClustersClusterResult',
    'GetManagedKubernetesClustersClusterConnectionsResult',
    'GetManagedKubernetesClustersClusterLogConfigResult',
    'GetManagedKubernetesClustersClusterWorkerNodeResult',
    'GetRegistryEnterpriseInstancesInstanceResult',
    'GetRegistryEnterpriseNamespacesNamespaceResult',
    'GetRegistryEnterpriseReposRepoResult',
    'GetRegistryEnterpriseReposRepoTagResult',
    'GetRegistryEnterpriseSyncRulesRuleResult',
    'GetServerlessKubernetesClustersClusterResult',
    'GetServerlessKubernetesClustersClusterConnectionsResult',
]

@pulumi.output_type
class ApplicationService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 status: Optional[str] = None,
                 version: Optional[str] = None):
        ApplicationService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            status=status,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             status: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if status is not None:
            _setter("status", status)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eip: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 status: Optional[str] = None):
        ClusterNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            eip=eip,
            id=id,
            name=name,
            private_ip=private_ip,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             eip: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if eip is not None:
            _setter("eip", eip)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def eip(self) -> Optional[str]:
        return pulumi.get(self, "eip")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class EdgeKubernetesAddon(dict):
    def __init__(__self__, *,
                 config: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str config: The ACK add-on configurations.
        :param bool disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
        :param str name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        EdgeKubernetesAddon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[str] = None,
             disabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[str]:
        """
        The ACK add-on configurations.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class EdgeKubernetesCertificateAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCert":
            suggest = "cluster_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgeKubernetesCertificateAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgeKubernetesCertificateAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgeKubernetesCertificateAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 cluster_cert: Optional[str] = None):
        """
        :param str client_cert: The path of client certificate, like `~/.kube/client-cert.pem`.
        :param str client_key: The path of client key, like `~/.kube/client-key.pem`.
        :param str cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        EdgeKubernetesCertificateAuthority._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[str] = None,
             client_key: Optional[str] = None,
             cluster_cert: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_cert is None and 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if client_key is None and 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if cluster_cert is None and 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']

        if client_cert is not None:
            _setter("client_cert", client_cert)
        if client_key is not None:
            _setter("client_key", client_key)
        if cluster_cert is not None:
            _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        The path of client certificate, like `~/.kube/client-cert.pem`.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The path of client key, like `~/.kube/client-key.pem`.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[str]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")


@pulumi.output_type
class EdgeKubernetesConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServerInternet":
            suggest = "api_server_internet"
        elif key == "apiServerIntranet":
            suggest = "api_server_intranet"
        elif key == "masterPublicIp":
            suggest = "master_public_ip"
        elif key == "serviceDomain":
            suggest = "service_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgeKubernetesConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgeKubernetesConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgeKubernetesConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server_internet: Optional[str] = None,
                 api_server_intranet: Optional[str] = None,
                 master_public_ip: Optional[str] = None,
                 service_domain: Optional[str] = None):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        :param str master_public_ip: Master node SSH IP address.
        :param str service_domain: Service Access Domain.
        """
        EdgeKubernetesConnections._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             master_public_ip: Optional[str] = None,
             service_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if master_public_ip is None and 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if service_domain is None and 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']

        if api_server_internet is not None:
            _setter("api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            _setter("api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            _setter("master_public_ip", master_public_ip)
        if service_domain is not None:
            _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[str]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[str]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[str]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[str]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")


@pulumi.output_type
class EdgeKubernetesLogConfig(dict):
    def __init__(__self__, *,
                 type: str,
                 project: Optional[str] = None):
        """
        :param str type: Type of collecting logs, only `SLS` are supported currently.
        :param str project: Log Service project name, cluster logs will output to this project.
        """
        EdgeKubernetesLogConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            project=project,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             project: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)
        if project is not None:
            _setter("project", project)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of collecting logs, only `SLS` are supported currently.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        Log Service project name, cluster logs will output to this project.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class EdgeKubernetesRuntime(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param str version: Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        EdgeKubernetesRuntime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EdgeKubernetesWorkerDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSnapshotPolicyId":
            suggest = "auto_snapshot_policy_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgeKubernetesWorkerDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgeKubernetesWorkerDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgeKubernetesWorkerDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[str] = None,
                 category: Optional[str] = None,
                 device: Optional[str] = None,
                 encrypted: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str auto_snapshot_policy_id: Worker node data disk auto snapshot policy.
        :param str category: The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param str device: The device of the data disks.
        :param str encrypted: Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        :param str kms_key_id: The id of the kms key.
        :param str name: The name of the data disks.
        :param str performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param str size: The size of a data disk, at least 40. Unit: GiB.
        :param str snapshot_id: The id of snapshot.
        """
        EdgeKubernetesWorkerDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[str] = None,
             category: Optional[str] = None,
             device: Optional[str] = None,
             encrypted: Optional[str] = None,
             kms_key_id: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[str]:
        """
        Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The device of the data disks.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[str]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default is `false`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The id of the kms key.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disks.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The id of snapshot.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class EdgeKubernetesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgeKubernetesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgeKubernetesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgeKubernetesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None):
        """
        :param str id: ID of the node.
        :param str name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param str private_ip: The private IP address of node.
        """
        EdgeKubernetesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class KubernetesAddon(dict):
    def __init__(__self__, *,
                 config: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str config: The ACK add-on configurations.
        :param bool disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
        :param str name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        KubernetesAddon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[str] = None,
             disabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[str]:
        """
        The ACK add-on configurations.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class KubernetesAutoscalerNodepool(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 labels: Optional[str] = None,
                 taints: Optional[str] = None):
        """
        :param str id: The scaling group id of the groups configured for cluster-autoscaler.
        :param str labels: The labels for the nodes in scaling group.
        :param str taints: The taints for the nodes in scaling group.
        """
        KubernetesAutoscalerNodepool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             labels: Optional[str] = None,
             taints: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The scaling group id of the groups configured for cluster-autoscaler.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[str]:
        """
        The labels for the nodes in scaling group.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[str]:
        """
        The taints for the nodes in scaling group.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class KubernetesCertificateAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCert":
            suggest = "cluster_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesCertificateAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesCertificateAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesCertificateAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 cluster_cert: Optional[str] = None):
        """
        :param str client_cert: The path of client certificate, like `~/.kube/client-cert.pem`.
        :param str client_key: The path of client key, like `~/.kube/client-key.pem`.
        :param str cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        KubernetesCertificateAuthority._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[str] = None,
             client_key: Optional[str] = None,
             cluster_cert: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_cert is None and 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if client_key is None and 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if cluster_cert is None and 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']

        if client_cert is not None:
            _setter("client_cert", client_cert)
        if client_key is not None:
            _setter("client_key", client_key)
        if cluster_cert is not None:
            _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        The path of client certificate, like `~/.kube/client-cert.pem`.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The path of client key, like `~/.kube/client-key.pem`.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[str]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")


@pulumi.output_type
class KubernetesConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServerInternet":
            suggest = "api_server_internet"
        elif key == "apiServerIntranet":
            suggest = "api_server_intranet"
        elif key == "masterPublicIp":
            suggest = "master_public_ip"
        elif key == "serviceDomain":
            suggest = "service_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server_internet: Optional[str] = None,
                 api_server_intranet: Optional[str] = None,
                 master_public_ip: Optional[str] = None,
                 service_domain: Optional[str] = None):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        :param str master_public_ip: Master node SSH IP address.
        :param str service_domain: Service Access Domain.
        """
        KubernetesConnections._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             master_public_ip: Optional[str] = None,
             service_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if master_public_ip is None and 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if service_domain is None and 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']

        if api_server_internet is not None:
            _setter("api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            _setter("api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            _setter("master_public_ip", master_public_ip)
        if service_domain is not None:
            _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[str]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[str]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[str]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[str]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")


@pulumi.output_type
class KubernetesMasterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesMasterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesMasterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesMasterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None):
        """
        :param str id: The id of a node.
        :param str name: The name of a node.
        :param str private_ip: The private ip of a node.
        """
        KubernetesMasterNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of a node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of a node.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        The private ip of a node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class KubernetesPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleName":
            suggest = "role_name"
        elif key == "roleType":
            suggest = "role_type"
        elif key == "isCustom":
            suggest = "is_custom"
        elif key == "isRamRole":
            suggest = "is_ram_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: str,
                 role_name: str,
                 role_type: str,
                 is_custom: Optional[bool] = None,
                 is_ram_role: Optional[bool] = None,
                 namespace: Optional[str] = None):
        """
        :param str cluster: The ID of the cluster that you want to manage.
        :param str role_name: Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        :param str role_type: The authorization type. Valid values `cluster`, `namespace`.
        :param bool is_custom: Specifies whether to perform a custom authorization. To perform a custom authorization, set `role_name` to a custom cluster role.
        :param bool is_ram_role: Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        :param str namespace: The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
        KubernetesPermissionPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster=cluster,
            role_name=role_name,
            role_type=role_type,
            is_custom=is_custom,
            is_ram_role=is_ram_role,
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster: Optional[str] = None,
             role_name: Optional[str] = None,
             role_type: Optional[str] = None,
             is_custom: Optional[bool] = None,
             is_ram_role: Optional[bool] = None,
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cluster is None:
            raise TypeError("Missing 'cluster' argument")
        if role_name is None and 'roleName' in kwargs:
            role_name = kwargs['roleName']
        if role_name is None:
            raise TypeError("Missing 'role_name' argument")
        if role_type is None and 'roleType' in kwargs:
            role_type = kwargs['roleType']
        if role_type is None:
            raise TypeError("Missing 'role_type' argument")
        if is_custom is None and 'isCustom' in kwargs:
            is_custom = kwargs['isCustom']
        if is_ram_role is None and 'isRamRole' in kwargs:
            is_ram_role = kwargs['isRamRole']

        _setter("cluster", cluster)
        _setter("role_name", role_name)
        _setter("role_type", role_type)
        if is_custom is not None:
            _setter("is_custom", is_custom)
        if is_ram_role is not None:
            _setter("is_ram_role", is_ram_role)
        if namespace is not None:
            _setter("namespace", namespace)

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        The ID of the cluster that you want to manage.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Specifies the predefined role that you want to assign. Valid values `admin`, `ops`, `dev`, `restricted` and the custom cluster roles.
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> str:
        """
        The authorization type. Valid values `cluster`, `namespace`.
        """
        return pulumi.get(self, "role_type")

    @property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[bool]:
        """
        Specifies whether to perform a custom authorization. To perform a custom authorization, set `role_name` to a custom cluster role.
        """
        return pulumi.get(self, "is_custom")

    @property
    @pulumi.getter(name="isRamRole")
    def is_ram_role(self) -> Optional[bool]:
        """
        Specifies whether the permissions are granted to a RAM role. When `uid` is ram role id, the value of `is_ram_role` must be `true`.
        """
        return pulumi.get(self, "is_ram_role")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to which the permissions are scoped. This parameter is required only if you set role_type to namespace.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class KubernetesRuntime(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The kubernetes cluster's name. It is unique in one Alicloud account.
        :param str version: Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        KubernetesRuntime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The kubernetes cluster's name. It is unique in one Alicloud account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class KubernetesTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: The scheduling policy. Valid values: NoSchedule | NoExecute | PreferNoSchedule. Default value: NoSchedule.
        :param str key: The key of a taint.
        :param str value: The key of a taint.
        """
        KubernetesTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        The scheduling policy. Valid values: NoSchedule | NoExecute | PreferNoSchedule. Default value: NoSchedule.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of a taint.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The key of a taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KubernetesWorkerDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSnapshotPolicyId":
            suggest = "auto_snapshot_policy_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesWorkerDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesWorkerDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesWorkerDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[str] = None,
                 category: Optional[str] = None,
                 device: Optional[str] = None,
                 encrypted: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str auto_snapshot_policy_id: Worker node data disk auto snapshot policy.
        :param str category: The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param str device: The device of the data disks.
        :param str encrypted: Specifies whether to encrypt data disks. Valid values: true and false.
        :param str kms_key_id: The id of the kms key.
        :param str name: The name of the data disks.
        :param str performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param str size: The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
        :param str snapshot_id: The id of snapshot.
        """
        KubernetesWorkerDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[str] = None,
             category: Optional[str] = None,
             device: Optional[str] = None,
             encrypted: Optional[str] = None,
             kms_key_id: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[str]:
        """
        Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The device of the data disks.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[str]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The id of the kms key.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the data disks.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The size of a data disk, Its valid value range [40~32768] in GB. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The id of snapshot.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class KubernetesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None):
        """
        :param str id: ID of the node.
        :param str name: Node name.
        :param str private_ip: The private IP address of node.
        """
        KubernetesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class ManagedKubernetesAddon(dict):
    def __init__(__self__, *,
                 config: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str config: If this parameter is left empty, no configurations are required.
        :param bool disabled: It specifies whether to disable automatic installation. 
               
               It is a new field since 1.75.0. You can specific network plugin,log component,ingress component and so on.
               
               You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.
               
               `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.
               
               `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.
               
               The `main.tf`:
               
               
               The `varibales.tf`:
        :param str name: This parameter specifies the name of the component.
        """
        ManagedKubernetesAddon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[str] = None,
             disabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[str]:
        """
        If this parameter is left empty, no configurations are required.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        It specifies whether to disable automatic installation. 

        It is a new field since 1.75.0. You can specific network plugin,log component,ingress component and so on.

        You can get more information about addons on ACK web console. When you create a ACK cluster. You can get openapi-spec before creating the cluster on submission page.

        `logtail-ds` - You can specify `IngressDashboardEnabled` and `sls_project_name` in config. If you switch on `IngressDashboardEnabled` and `sls_project_name`,then logtail-ds would use `sls_project_name` as default log store.

        `nginx-ingress-controller` - You can specific `IngressSlbNetworkType` in config. Options: internet|intranet.

        The `main.tf`:


        The `varibales.tf`:
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedKubernetesCertificateAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCert":
            suggest = "cluster_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedKubernetesCertificateAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedKubernetesCertificateAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedKubernetesCertificateAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert: Optional[str] = None,
                 client_key: Optional[str] = None,
                 cluster_cert: Optional[str] = None):
        """
        :param str client_cert: The path of client certificate, like `~/.kube/client-cert.pem`.
        :param str client_key: The path of client key, like `~/.kube/client-key.pem`.
        :param str cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        ManagedKubernetesCertificateAuthority._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[str] = None,
             client_key: Optional[str] = None,
             cluster_cert: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_cert is None and 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if client_key is None and 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if cluster_cert is None and 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']

        if client_cert is not None:
            _setter("client_cert", client_cert)
        if client_key is not None:
            _setter("client_key", client_key)
        if cluster_cert is not None:
            _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[str]:
        """
        The path of client certificate, like `~/.kube/client-cert.pem`.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The path of client key, like `~/.kube/client-key.pem`.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> Optional[str]:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kubeconfig file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")


@pulumi.output_type
class ManagedKubernetesConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServerInternet":
            suggest = "api_server_internet"
        elif key == "apiServerIntranet":
            suggest = "api_server_intranet"
        elif key == "masterPublicIp":
            suggest = "master_public_ip"
        elif key == "serviceDomain":
            suggest = "service_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedKubernetesConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedKubernetesConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedKubernetesConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server_internet: Optional[str] = None,
                 api_server_intranet: Optional[str] = None,
                 master_public_ip: Optional[str] = None,
                 service_domain: Optional[str] = None):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        :param str master_public_ip: Master node SSH IP address.
        :param str service_domain: Service Access Domain.
        """
        ManagedKubernetesConnections._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             master_public_ip: Optional[str] = None,
             service_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if master_public_ip is None and 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if service_domain is None and 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']

        if api_server_internet is not None:
            _setter("api_server_internet", api_server_internet)
        if api_server_intranet is not None:
            _setter("api_server_intranet", api_server_intranet)
        if master_public_ip is not None:
            _setter("master_public_ip", master_public_ip)
        if service_domain is not None:
            _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> Optional[str]:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> Optional[str]:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> Optional[str]:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[str]:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")


@pulumi.output_type
class ManagedKubernetesMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceTime":
            suggest = "maintenance_time"
        elif key == "weeklyPeriod":
            suggest = "weekly_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedKubernetesMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedKubernetesMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedKubernetesMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: str,
                 enable: bool,
                 maintenance_time: str,
                 weekly_period: str):
        """
        :param str duration: The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        :param bool enable: Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        :param str maintenance_time: Initial maintenance time, For example:"03:00:00Z".
        :param str weekly_period: Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.
               
               for example:
        """
        ManagedKubernetesMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
            enable=enable,
            maintenance_time=maintenance_time,
            weekly_period=weekly_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: Optional[str] = None,
             enable: Optional[bool] = None,
             maintenance_time: Optional[str] = None,
             weekly_period: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if duration is None:
            raise TypeError("Missing 'duration' argument")
        if enable is None:
            raise TypeError("Missing 'enable' argument")
        if maintenance_time is None and 'maintenanceTime' in kwargs:
            maintenance_time = kwargs['maintenanceTime']
        if maintenance_time is None:
            raise TypeError("Missing 'maintenance_time' argument")
        if weekly_period is None and 'weeklyPeriod' in kwargs:
            weekly_period = kwargs['weeklyPeriod']
        if weekly_period is None:
            raise TypeError("Missing 'weekly_period' argument")

        _setter("duration", duration)
        _setter("enable", enable)
        _setter("maintenance_time", maintenance_time)
        _setter("weekly_period", weekly_period)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The maintenance time, values range from 1 to 24,unit is hour. For example: "3h".
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Whether to open the maintenance window. The following parameters take effect only `enable = true`.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> str:
        """
        Initial maintenance time, For example:"03:00:00Z".
        """
        return pulumi.get(self, "maintenance_time")

    @property
    @pulumi.getter(name="weeklyPeriod")
    def weekly_period(self) -> str:
        """
        Maintenance cycle, you can set the values from Monday to Sunday, separated by commas when the values are multiple. The default is Thursday.

        for example:
        """
        return pulumi.get(self, "weekly_period")


@pulumi.output_type
class ManagedKubernetesRrsaMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ramOidcProviderArn":
            suggest = "ram_oidc_provider_arn"
        elif key == "ramOidcProviderName":
            suggest = "ram_oidc_provider_name"
        elif key == "rrsaOidcIssuerUrl":
            suggest = "rrsa_oidc_issuer_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedKubernetesRrsaMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedKubernetesRrsaMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedKubernetesRrsaMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 ram_oidc_provider_arn: Optional[str] = None,
                 ram_oidc_provider_name: Optional[str] = None,
                 rrsa_oidc_issuer_url: Optional[str] = None):
        """
        :param bool enabled: Whether the RRSA feature has been enabled.
        :param str ram_oidc_provider_arn: The arn of OIDC provider that was registered in RAM.
        :param str ram_oidc_provider_name: The name of OIDC Provider that was registered in RAM.
        :param str rrsa_oidc_issuer_url: The issuer URL of RRSA OIDC Token.
        """
        ManagedKubernetesRrsaMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            ram_oidc_provider_arn=ram_oidc_provider_arn,
            ram_oidc_provider_name=ram_oidc_provider_name,
            rrsa_oidc_issuer_url=rrsa_oidc_issuer_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             ram_oidc_provider_arn: Optional[str] = None,
             ram_oidc_provider_name: Optional[str] = None,
             rrsa_oidc_issuer_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ram_oidc_provider_arn is None and 'ramOidcProviderArn' in kwargs:
            ram_oidc_provider_arn = kwargs['ramOidcProviderArn']
        if ram_oidc_provider_name is None and 'ramOidcProviderName' in kwargs:
            ram_oidc_provider_name = kwargs['ramOidcProviderName']
        if rrsa_oidc_issuer_url is None and 'rrsaOidcIssuerUrl' in kwargs:
            rrsa_oidc_issuer_url = kwargs['rrsaOidcIssuerUrl']

        if enabled is not None:
            _setter("enabled", enabled)
        if ram_oidc_provider_arn is not None:
            _setter("ram_oidc_provider_arn", ram_oidc_provider_arn)
        if ram_oidc_provider_name is not None:
            _setter("ram_oidc_provider_name", ram_oidc_provider_name)
        if rrsa_oidc_issuer_url is not None:
            _setter("rrsa_oidc_issuer_url", rrsa_oidc_issuer_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ramOidcProviderArn")
    def ram_oidc_provider_arn(self) -> Optional[str]:
        """
        The arn of OIDC provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_arn")

    @property
    @pulumi.getter(name="ramOidcProviderName")
    def ram_oidc_provider_name(self) -> Optional[str]:
        """
        The name of OIDC Provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_name")

    @property
    @pulumi.getter(name="rrsaOidcIssuerUrl")
    def rrsa_oidc_issuer_url(self) -> Optional[str]:
        """
        The issuer URL of RRSA OIDC Token.
        """
        return pulumi.get(self, "rrsa_oidc_issuer_url")


@pulumi.output_type
class ManagedKubernetesRuntime(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: This parameter specifies the name of the component.
        :param str version: Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        ManagedKubernetesRuntime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Desired Kubernetes version. If you do not specify a value, the latest available version at resource creation is used and no upgrades will occur except you set a higher version number. The value must be configured and increased to upgrade the version when desired. Downgrades are not supported by ACK.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ManagedKubernetesTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: The taint effect.
               
               The following example is the definition of taints block:
        :param str key: The taint key.
        :param str value: The taint value.
        """
        ManagedKubernetesTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        The taint effect.

        The following example is the definition of taints block:
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The taint key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagedKubernetesWorkerDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSnapshotPolicyId":
            suggest = "auto_snapshot_policy_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedKubernetesWorkerDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedKubernetesWorkerDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedKubernetesWorkerDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[str] = None,
                 category: Optional[str] = None,
                 device: Optional[str] = None,
                 encrypted: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str auto_snapshot_policy_id: (Optional, Available in 1.120.0+) Worker node data disk auto snapshot policy.
        :param str category: (Optional)The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        :param str device: The mount point of data disk N.
        :param str encrypted: (Optional)Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        :param str kms_key_id: The ID of the Key Management Service (KMS) key to use for data disk N.
        :param str name: The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (.), underscores (_), and hyphens (-).
        :param str performance_level: (Optional, Available in 1.120.0+) Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param str size: (Optional)The size of a data disk, at least 40. Unit: GiB.
        :param str snapshot_id: The ID of the snapshot to be used to create data disk N. Valid values of N: 1 to 16. When DataDisk.N.SnapshotId is specified, DataDisk.N.Size is ignored. The data disk is created based on the size of the specified snapshot. Use snapshots that were created on or after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        """
        ManagedKubernetesWorkerDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[str] = None,
             category: Optional[str] = None,
             device: Optional[str] = None,
             encrypted: Optional[str] = None,
             kms_key_id: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[str] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[str]:
        """
        (Optional, Available in 1.120.0+) Worker node data disk auto snapshot policy.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        (Optional)The type of the data disks. Valid values: `cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`. Default to `cloud_efficiency`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The mount point of data disk N.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[str]:
        """
        (Optional)Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ID of the Key Management Service (KMS) key to use for data disk N.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (.), underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        (Optional, Available in 1.120.0+) Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        (Optional)The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The ID of the snapshot to be used to create data disk N. Valid values of N: 1 to 16. When DataDisk.N.SnapshotId is specified, DataDisk.N.Size is ignored. The data disk is created based on the size of the specified snapshot. Use snapshots that were created on or after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class ManagedKubernetesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedKubernetesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedKubernetesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedKubernetesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None):
        """
        :param str id: (Deprecated from version 1.177.0) ID of the node.
        :param str name: This parameter specifies the name of the component.
        :param str private_ip: (Deprecated from version 1.177.0) The private IP address of node.
        """
        ManagedKubernetesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Deprecated from version 1.177.0) ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        This parameter specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        (Deprecated from version 1.177.0) The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class NodePoolDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSnapshotPolicyId":
            suggest = "auto_snapshot_policy_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "performanceLevel":
            suggest = "performance_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_snapshot_policy_id: Optional[str] = None,
                 category: Optional[str] = None,
                 device: Optional[str] = None,
                 encrypted: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 name: Optional[str] = None,
                 performance_level: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None):
        """
        :param str auto_snapshot_policy_id: The ID of the automatic snapshot policy that you want to apply to the system disk.
        :param str category: The type of the data disks. Valid values:`cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`.
        :param str device: The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        :param str encrypted: Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        :param str kms_key_id: The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        :param str name: The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        :param str performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        :param int size: The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        :param str snapshot_id: The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
        NodePoolDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_snapshot_policy_id=auto_snapshot_policy_id,
            category=category,
            device=device,
            encrypted=encrypted,
            kms_key_id=kms_key_id,
            name=name,
            performance_level=performance_level,
            size=size,
            snapshot_id=snapshot_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_snapshot_policy_id: Optional[str] = None,
             category: Optional[str] = None,
             device: Optional[str] = None,
             encrypted: Optional[str] = None,
             kms_key_id: Optional[str] = None,
             name: Optional[str] = None,
             performance_level: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_snapshot_policy_id is None and 'autoSnapshotPolicyId' in kwargs:
            auto_snapshot_policy_id = kwargs['autoSnapshotPolicyId']
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if performance_level is None and 'performanceLevel' in kwargs:
            performance_level = kwargs['performanceLevel']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']

        if auto_snapshot_policy_id is not None:
            _setter("auto_snapshot_policy_id", auto_snapshot_policy_id)
        if category is not None:
            _setter("category", category)
        if device is not None:
            _setter("device", device)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if name is not None:
            _setter("name", name)
        if performance_level is not None:
            _setter("performance_level", performance_level)
        if size is not None:
            _setter("size", size)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="autoSnapshotPolicyId")
    def auto_snapshot_policy_id(self) -> Optional[str]:
        """
        The ID of the automatic snapshot policy that you want to apply to the system disk.
        """
        return pulumi.get(self, "auto_snapshot_policy_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The type of the data disks. Valid values:`cloud`, `cloud_efficiency`, `cloud_ssd` and `cloud_essd`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[str]:
        """
        Specifies whether to encrypt data disks. Valid values: true and false. Default to `false`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The kms key id used to encrypt the data disk. It takes effect when `encrypted` is true.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of data disk N. Valid values of N: 1 to 16. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (_), and hyphens (-). The name must start with a letter but cannot start with http:// or https://.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity. For more information, see [Enhanced SSDs](https://www.alibabacloud.com/help/doc-detail/122389.htm). Default is `PL1`.
        """
        return pulumi.get(self, "performance_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of a data disk, Its valid value range [40~32768] in GB. Default to `40`.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class NodePoolKubeletConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "eventBurst":
            suggest = "event_burst"
        elif key == "eventRecordQps":
            suggest = "event_record_qps"
        elif key == "evictionHard":
            suggest = "eviction_hard"
        elif key == "evictionSoft":
            suggest = "eviction_soft"
        elif key == "evictionSoftGracePeriod":
            suggest = "eviction_soft_grace_period"
        elif key == "kubeApiBurst":
            suggest = "kube_api_burst"
        elif key == "kubeApiQps":
            suggest = "kube_api_qps"
        elif key == "kubeReserved":
            suggest = "kube_reserved"
        elif key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "serializeImagePulls":
            suggest = "serialize_image_pulls"
        elif key == "systemReserved":
            suggest = "system_reserved"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolKubeletConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolKubeletConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolKubeletConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_manager_policy: Optional[str] = None,
                 event_burst: Optional[str] = None,
                 event_record_qps: Optional[str] = None,
                 eviction_hard: Optional[Mapping[str, Any]] = None,
                 eviction_soft: Optional[Mapping[str, Any]] = None,
                 eviction_soft_grace_period: Optional[Mapping[str, Any]] = None,
                 kube_api_burst: Optional[str] = None,
                 kube_api_qps: Optional[str] = None,
                 kube_reserved: Optional[Mapping[str, Any]] = None,
                 registry_burst: Optional[str] = None,
                 registry_pull_qps: Optional[str] = None,
                 serialize_image_pulls: Optional[str] = None,
                 system_reserved: Optional[Mapping[str, Any]] = None):
        """
        :param str cpu_manager_policy: Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        :param str event_burst: Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        :param str event_record_qps: Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        :param Mapping[str, Any] eviction_hard: Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        :param Mapping[str, Any] eviction_soft: Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        :param Mapping[str, Any] eviction_soft_grace_period: Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        :param str kube_api_burst: Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        :param str kube_api_qps: Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        :param Mapping[str, Any] kube_reserved: Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        :param str registry_burst: Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        :param str registry_pull_qps: Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        :param str serialize_image_pulls: Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        :param Mapping[str, Any] system_reserved: Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        NodePoolKubeletConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_manager_policy=cpu_manager_policy,
            event_burst=event_burst,
            event_record_qps=event_record_qps,
            eviction_hard=eviction_hard,
            eviction_soft=eviction_soft,
            eviction_soft_grace_period=eviction_soft_grace_period,
            kube_api_burst=kube_api_burst,
            kube_api_qps=kube_api_qps,
            kube_reserved=kube_reserved,
            registry_burst=registry_burst,
            registry_pull_qps=registry_pull_qps,
            serialize_image_pulls=serialize_image_pulls,
            system_reserved=system_reserved,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_manager_policy: Optional[str] = None,
             event_burst: Optional[str] = None,
             event_record_qps: Optional[str] = None,
             eviction_hard: Optional[Mapping[str, Any]] = None,
             eviction_soft: Optional[Mapping[str, Any]] = None,
             eviction_soft_grace_period: Optional[Mapping[str, Any]] = None,
             kube_api_burst: Optional[str] = None,
             kube_api_qps: Optional[str] = None,
             kube_reserved: Optional[Mapping[str, Any]] = None,
             registry_burst: Optional[str] = None,
             registry_pull_qps: Optional[str] = None,
             serialize_image_pulls: Optional[str] = None,
             system_reserved: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_manager_policy is None and 'cpuManagerPolicy' in kwargs:
            cpu_manager_policy = kwargs['cpuManagerPolicy']
        if event_burst is None and 'eventBurst' in kwargs:
            event_burst = kwargs['eventBurst']
        if event_record_qps is None and 'eventRecordQps' in kwargs:
            event_record_qps = kwargs['eventRecordQps']
        if eviction_hard is None and 'evictionHard' in kwargs:
            eviction_hard = kwargs['evictionHard']
        if eviction_soft is None and 'evictionSoft' in kwargs:
            eviction_soft = kwargs['evictionSoft']
        if eviction_soft_grace_period is None and 'evictionSoftGracePeriod' in kwargs:
            eviction_soft_grace_period = kwargs['evictionSoftGracePeriod']
        if kube_api_burst is None and 'kubeApiBurst' in kwargs:
            kube_api_burst = kwargs['kubeApiBurst']
        if kube_api_qps is None and 'kubeApiQps' in kwargs:
            kube_api_qps = kwargs['kubeApiQps']
        if kube_reserved is None and 'kubeReserved' in kwargs:
            kube_reserved = kwargs['kubeReserved']
        if registry_burst is None and 'registryBurst' in kwargs:
            registry_burst = kwargs['registryBurst']
        if registry_pull_qps is None and 'registryPullQps' in kwargs:
            registry_pull_qps = kwargs['registryPullQps']
        if serialize_image_pulls is None and 'serializeImagePulls' in kwargs:
            serialize_image_pulls = kwargs['serializeImagePulls']
        if system_reserved is None and 'systemReserved' in kwargs:
            system_reserved = kwargs['systemReserved']

        if cpu_manager_policy is not None:
            _setter("cpu_manager_policy", cpu_manager_policy)
        if event_burst is not None:
            _setter("event_burst", event_burst)
        if event_record_qps is not None:
            _setter("event_record_qps", event_record_qps)
        if eviction_hard is not None:
            _setter("eviction_hard", eviction_hard)
        if eviction_soft is not None:
            _setter("eviction_soft", eviction_soft)
        if eviction_soft_grace_period is not None:
            _setter("eviction_soft_grace_period", eviction_soft_grace_period)
        if kube_api_burst is not None:
            _setter("kube_api_burst", kube_api_burst)
        if kube_api_qps is not None:
            _setter("kube_api_qps", kube_api_qps)
        if kube_reserved is not None:
            _setter("kube_reserved", kube_reserved)
        if registry_burst is not None:
            _setter("registry_burst", registry_burst)
        if registry_pull_qps is not None:
            _setter("registry_pull_qps", registry_pull_qps)
        if serialize_image_pulls is not None:
            _setter("serialize_image_pulls", serialize_image_pulls)
        if system_reserved is not None:
            _setter("system_reserved", system_reserved)

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[str]:
        """
        Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> Optional[str]:
        """
        Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventRecordQps")
    def event_record_qps(self) -> Optional[str]:
        """
        Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "event_record_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> Optional[Mapping[str, Any]]:
        """
        Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> Optional[Mapping[str, Any]]:
        """
        Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{"memory.available" = "300Mi"}`.
        """
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> Optional[Mapping[str, Any]]:
        """
        Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{"memory.available" = "30s"}`.
        """
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="kubeApiBurst")
    def kube_api_burst(self) -> Optional[str]:
        """
        Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "kube_api_burst")

    @property
    @pulumi.getter(name="kubeApiQps")
    def kube_api_qps(self) -> Optional[str]:
        """
        Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "kube_api_qps")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Optional[Mapping[str, Any]]:
        """
        Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[str]:
        """
        Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
        """
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[str]:
        """
        Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
        """
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> Optional[str]:
        """
        Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
        """
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Optional[Mapping[str, Any]]:
        """
        Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
        """
        return pulumi.get(self, "system_reserved")


@pulumi.output_type
class NodePoolLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: The label key.
        :param str value: The label value.
        """
        NodePoolLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodePoolManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "autoRepair":
            suggest = "auto_repair"
        elif key == "autoUpgrade":
            suggest = "auto_upgrade"
        elif key == "surgePercentage":
            suggest = "surge_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: int,
                 auto_repair: Optional[bool] = None,
                 auto_upgrade: Optional[bool] = None,
                 surge: Optional[int] = None,
                 surge_percentage: Optional[int] = None):
        """
        :param int max_unavailable: Max number of unavailable nodes. Default to `1`.
        :param bool auto_repair: Whether automatic repair, Default to `false`.
        :param bool auto_upgrade: Whether auto upgrade, Default to `false`.
        :param int surge: Number of additional nodes. You have to specify one of surge, surge_percentage.
        :param int surge_percentage: Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
        NodePoolManagement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_unavailable=max_unavailable,
            auto_repair=auto_repair,
            auto_upgrade=auto_upgrade,
            surge=surge,
            surge_percentage=surge_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_unavailable: Optional[int] = None,
             auto_repair: Optional[bool] = None,
             auto_upgrade: Optional[bool] = None,
             surge: Optional[int] = None,
             surge_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_unavailable is None and 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']
        if max_unavailable is None:
            raise TypeError("Missing 'max_unavailable' argument")
        if auto_repair is None and 'autoRepair' in kwargs:
            auto_repair = kwargs['autoRepair']
        if auto_upgrade is None and 'autoUpgrade' in kwargs:
            auto_upgrade = kwargs['autoUpgrade']
        if surge_percentage is None and 'surgePercentage' in kwargs:
            surge_percentage = kwargs['surgePercentage']

        _setter("max_unavailable", max_unavailable)
        if auto_repair is not None:
            _setter("auto_repair", auto_repair)
        if auto_upgrade is not None:
            _setter("auto_upgrade", auto_upgrade)
        if surge is not None:
            _setter("surge", surge)
        if surge_percentage is not None:
            _setter("surge_percentage", surge_percentage)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        """
        Max number of unavailable nodes. Default to `1`.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> Optional[bool]:
        """
        Whether automatic repair, Default to `false`.
        """
        return pulumi.get(self, "auto_repair")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[bool]:
        """
        Whether auto upgrade, Default to `false`.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter
    def surge(self) -> Optional[int]:
        """
        Number of additional nodes. You have to specify one of surge, surge_percentage.
        """
        return pulumi.get(self, "surge")

    @property
    @pulumi.getter(name="surgePercentage")
    def surge_percentage(self) -> Optional[int]:
        """
        Proportion of additional nodes. You have to specify one of surge, surge_percentage.
        """
        return pulumi.get(self, "surge_percentage")


@pulumi.output_type
class NodePoolRollingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxParallelism":
            suggest = "max_parallelism"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolRollingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolRollingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolRollingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_parallelism: Optional[int] = None):
        """
        :param int max_parallelism: Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used.
        """
        NodePoolRollingPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_parallelism=max_parallelism,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_parallelism: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_parallelism is None and 'maxParallelism' in kwargs:
            max_parallelism = kwargs['maxParallelism']

        if max_parallelism is not None:
            _setter("max_parallelism", max_parallelism)

    @property
    @pulumi.getter(name="maxParallelism")
    def max_parallelism(self) -> Optional[int]:
        """
        Maximum parallel number nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used.
        """
        return pulumi.get(self, "max_parallelism")


@pulumi.output_type
class NodePoolRolloutPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolRolloutPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolRolloutPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolRolloutPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None):
        """
        :param int max_unavailable: Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used. Please use `max_parallelism` to instead it from provider version 1.185.0.
        """
        NodePoolRolloutPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_unavailable=max_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_unavailable: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_unavailable is None and 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']

        if max_unavailable is not None:
            _setter("max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than `0`, and if it's set to a number less than or equal to `0`, the default setting will be used. Please use `max_parallelism` to instead it from provider version 1.185.0.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class NodePoolScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "eipBandwidth":
            suggest = "eip_bandwidth"
        elif key == "eipInternetChargeType":
            suggest = "eip_internet_charge_type"
        elif key == "isBondEip":
            suggest = "is_bond_eip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: int,
                 min_size: int,
                 eip_bandwidth: Optional[int] = None,
                 eip_internet_charge_type: Optional[str] = None,
                 is_bond_eip: Optional[bool] = None,
                 type: Optional[str] = None):
        """
        :param int max_size: Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        :param int min_size: Min number of instances in a auto scaling group, its valid value range [0~1000].
        :param int eip_bandwidth: Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
        :param str eip_internet_charge_type: EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internet_charge_type`, EIP and public network IP can only choose one.
        :param bool is_bond_eip: Whether to bind EIP for an instance. Default: `false`.
        :param str type: Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
        NodePoolScalingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_size=max_size,
            min_size=min_size,
            eip_bandwidth=eip_bandwidth,
            eip_internet_charge_type=eip_internet_charge_type,
            is_bond_eip=is_bond_eip,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             eip_bandwidth: Optional[int] = None,
             eip_internet_charge_type: Optional[str] = None,
             is_bond_eip: Optional[bool] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if max_size is None:
            raise TypeError("Missing 'max_size' argument")
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if min_size is None:
            raise TypeError("Missing 'min_size' argument")
        if eip_bandwidth is None and 'eipBandwidth' in kwargs:
            eip_bandwidth = kwargs['eipBandwidth']
        if eip_internet_charge_type is None and 'eipInternetChargeType' in kwargs:
            eip_internet_charge_type = kwargs['eipInternetChargeType']
        if is_bond_eip is None and 'isBondEip' in kwargs:
            is_bond_eip = kwargs['isBondEip']

        _setter("max_size", max_size)
        _setter("min_size", min_size)
        if eip_bandwidth is not None:
            _setter("eip_bandwidth", eip_bandwidth)
        if eip_internet_charge_type is not None:
            _setter("eip_internet_charge_type", eip_internet_charge_type)
        if is_bond_eip is not None:
            _setter("is_bond_eip", is_bond_eip)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> int:
        """
        Max number of instances in a auto scaling group, its valid value range [0~1000]. `max_size` has to be greater than `min_size`.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> int:
        """
        Min number of instances in a auto scaling group, its valid value range [0~1000].
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="eipBandwidth")
    def eip_bandwidth(self) -> Optional[int]:
        """
        Peak EIP bandwidth. Its valid value range [1~500] in Mbps. Default to `5`.
        """
        return pulumi.get(self, "eip_bandwidth")

    @property
    @pulumi.getter(name="eipInternetChargeType")
    def eip_internet_charge_type(self) -> Optional[str]:
        """
        EIP billing type. `PayByBandwidth`: Charged at fixed bandwidth. `PayByTraffic`: Billed as used traffic. Default: `PayByBandwidth`. Conflict with `internet_charge_type`, EIP and public network IP can only choose one.
        """
        return pulumi.get(self, "eip_internet_charge_type")

    @property
    @pulumi.getter(name="isBondEip")
    def is_bond_eip(self) -> Optional[bool]:
        """
        Whether to bind EIP for an instance. Default: `false`.
        """
        return pulumi.get(self, "is_bond_eip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Instance classification, not required. Vaild value: `cpu`, `gpu`, `gpushare` and `spot`. Default: `cpu`. The actual instance type is determined by `instance_types`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NodePoolSpotPriceLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "priceLimit":
            suggest = "price_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolSpotPriceLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolSpotPriceLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolSpotPriceLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[str] = None,
                 price_limit: Optional[str] = None):
        """
        :param str instance_type: Spot instance type.
        :param str price_limit: The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
        """
        NodePoolSpotPriceLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            price_limit=price_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: Optional[str] = None,
             price_limit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if price_limit is None and 'priceLimit' in kwargs:
            price_limit = kwargs['priceLimit']

        if instance_type is not None:
            _setter("instance_type", instance_type)
        if price_limit is not None:
            _setter("price_limit", price_limit)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Spot instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="priceLimit")
    def price_limit(self) -> Optional[str]:
        """
        The maximum hourly price of the spot instance. A maximum of three decimal places are allowed.
        """
        return pulumi.get(self, "price_limit")


@pulumi.output_type
class NodePoolTaint(dict):
    def __init__(__self__, *,
                 key: str,
                 effect: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of a taint.
        :param str effect: The scheduling policy.
        :param str value: The value of a taint.
        """
        NodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            effect=effect,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             effect: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if effect is not None:
            _setter("effect", effect)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of a taint.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        The scheduling policy.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of a taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServerlessKubernetesAddon(dict):
    def __init__(__self__, *,
                 config: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str config: The ACK add-on configurations.
        :param bool disabled: Disables the automatic installation of a component. Default is `false`.
               
               The following example is the definition of addons block, The type of this field is list:
        :param str name: Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        ServerlessKubernetesAddon._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            disabled=disabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[str] = None,
             disabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if config is not None:
            _setter("config", config)
        if disabled is not None:
            _setter("disabled", disabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def config(self) -> Optional[str]:
        """
        The ACK add-on configurations.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Disables the automatic installation of a component. Default is `false`.

        The following example is the definition of addons block, The type of this field is list:
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ACK add-on. The name must match one of the names returned by [DescribeAddons](https://help.aliyun.com/document_detail/171524.html).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServerlessKubernetesRrsaMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ramOidcProviderArn":
            suggest = "ram_oidc_provider_arn"
        elif key == "ramOidcProviderName":
            suggest = "ram_oidc_provider_name"
        elif key == "rrsaOidcIssuerUrl":
            suggest = "rrsa_oidc_issuer_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessKubernetesRrsaMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessKubernetesRrsaMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessKubernetesRrsaMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 ram_oidc_provider_arn: Optional[str] = None,
                 ram_oidc_provider_name: Optional[str] = None,
                 rrsa_oidc_issuer_url: Optional[str] = None):
        """
        :param bool enabled: Whether the RRSA feature has been enabled.
        :param str ram_oidc_provider_arn: The arn of OIDC provider that was registered in RAM.
        :param str ram_oidc_provider_name: The name of OIDC Provider that was registered in RAM.
        :param str rrsa_oidc_issuer_url: The issuer URL of RRSA OIDC Token.
        """
        ServerlessKubernetesRrsaMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            ram_oidc_provider_arn=ram_oidc_provider_arn,
            ram_oidc_provider_name=ram_oidc_provider_name,
            rrsa_oidc_issuer_url=rrsa_oidc_issuer_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             ram_oidc_provider_arn: Optional[str] = None,
             ram_oidc_provider_name: Optional[str] = None,
             rrsa_oidc_issuer_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ram_oidc_provider_arn is None and 'ramOidcProviderArn' in kwargs:
            ram_oidc_provider_arn = kwargs['ramOidcProviderArn']
        if ram_oidc_provider_name is None and 'ramOidcProviderName' in kwargs:
            ram_oidc_provider_name = kwargs['ramOidcProviderName']
        if rrsa_oidc_issuer_url is None and 'rrsaOidcIssuerUrl' in kwargs:
            rrsa_oidc_issuer_url = kwargs['rrsaOidcIssuerUrl']

        if enabled is not None:
            _setter("enabled", enabled)
        if ram_oidc_provider_arn is not None:
            _setter("ram_oidc_provider_arn", ram_oidc_provider_arn)
        if ram_oidc_provider_name is not None:
            _setter("ram_oidc_provider_name", ram_oidc_provider_name)
        if rrsa_oidc_issuer_url is not None:
            _setter("rrsa_oidc_issuer_url", rrsa_oidc_issuer_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the RRSA feature has been enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ramOidcProviderArn")
    def ram_oidc_provider_arn(self) -> Optional[str]:
        """
        The arn of OIDC provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_arn")

    @property
    @pulumi.getter(name="ramOidcProviderName")
    def ram_oidc_provider_name(self) -> Optional[str]:
        """
        The name of OIDC Provider that was registered in RAM.
        """
        return pulumi.get(self, "ram_oidc_provider_name")

    @property
    @pulumi.getter(name="rrsaOidcIssuerUrl")
    def rrsa_oidc_issuer_url(self) -> Optional[str]:
        """
        The issuer URL of RRSA OIDC Token.
        """
        return pulumi.get(self, "rrsa_oidc_issuer_url")


@pulumi.output_type
class SwarmNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwarmNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwarmNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwarmNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eip: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 status: Optional[str] = None):
        SwarmNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            eip=eip,
            id=id,
            name=name,
            private_ip=private_ip,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             eip: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']

        if eip is not None:
            _setter("eip", eip)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def eip(self) -> Optional[str]:
        return pulumi.get(self, "eip")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetClusterCredentialCertificateAuthorityResult(dict):
    def __init__(__self__, *,
                 client_cert: str,
                 client_key: str,
                 cluster_cert: str):
        """
        :param str client_cert: The base64 encoded client certificate data required to communicate with your cluster. Add this to the client-certificate-data section of the kube config file for your cluster.
        :param str client_key: The base64 encoded client key data required to communicate with your cluster. Add this to the client-key-data section of the kube config file for your cluster.
        :param str cluster_cert: The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kube config file for your cluster.
        """
        GetClusterCredentialCertificateAuthorityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_cert=client_cert,
            client_key=client_key,
            cluster_cert=cluster_cert,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_cert: Optional[str] = None,
             client_key: Optional[str] = None,
             cluster_cert: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_cert is None and 'clientCert' in kwargs:
            client_cert = kwargs['clientCert']
        if client_cert is None:
            raise TypeError("Missing 'client_cert' argument")
        if client_key is None and 'clientKey' in kwargs:
            client_key = kwargs['clientKey']
        if client_key is None:
            raise TypeError("Missing 'client_key' argument")
        if cluster_cert is None and 'clusterCert' in kwargs:
            cluster_cert = kwargs['clusterCert']
        if cluster_cert is None:
            raise TypeError("Missing 'cluster_cert' argument")

        _setter("client_cert", client_cert)
        _setter("client_key", client_key)
        _setter("cluster_cert", cluster_cert)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> str:
        """
        The base64 encoded client certificate data required to communicate with your cluster. Add this to the client-certificate-data section of the kube config file for your cluster.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        The base64 encoded client key data required to communicate with your cluster. Add this to the client-key-data section of the kube config file for your cluster.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCert")
    def cluster_cert(self) -> str:
        """
        The base64 encoded cluster certificate data required to communicate with your cluster. Add this to the certificate-authority-data section of the kube config file for your cluster.
        """
        return pulumi.get(self, "cluster_cert")


@pulumi.output_type
class GetEdgeKubernetesClustersClusterResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 connections: 'outputs.GetEdgeKubernetesClustersClusterConnectionsResult',
                 id: str,
                 name: str,
                 nat_gateway_id: str,
                 security_group_id: str,
                 vpc_id: str,
                 worker_nodes: Sequence['outputs.GetEdgeKubernetesClustersClusterWorkerNodeResult']):
        """
        :param str availability_zone: The ID of availability zone.
        :param 'GetEdgeKubernetesClustersClusterConnectionsArgs' connections: Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
        :param str id: ID of the node.
        :param str name: Node name.
        :param str nat_gateway_id: The ID of nat gateway used to launch kubernetes cluster.
        :param str security_group_id: The ID of security group where the current cluster worker node is located.
        :param str vpc_id: The ID of VPC where the current cluster is located.
        :param Sequence['GetEdgeKubernetesClustersClusterWorkerNodeArgs'] worker_nodes: List of cluster worker nodes. It contains several attributes to `Block Nodes`.
        """
        GetEdgeKubernetesClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            connections=connections,
            id=id,
            name=name,
            nat_gateway_id=nat_gateway_id,
            security_group_id=security_group_id,
            vpc_id=vpc_id,
            worker_nodes=worker_nodes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             connections: Optional['outputs.GetEdgeKubernetesClustersClusterConnectionsResult'] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             security_group_id: Optional[str] = None,
             vpc_id: Optional[str] = None,
             worker_nodes: Optional[Sequence['outputs.GetEdgeKubernetesClustersClusterWorkerNodeResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if connections is None:
            raise TypeError("Missing 'connections' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if worker_nodes is None and 'workerNodes' in kwargs:
            worker_nodes = kwargs['workerNodes']
        if worker_nodes is None:
            raise TypeError("Missing 'worker_nodes' argument")

        _setter("availability_zone", availability_zone)
        _setter("connections", connections)
        _setter("id", id)
        _setter("name", name)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("security_group_id", security_group_id)
        _setter("vpc_id", vpc_id)
        _setter("worker_nodes", worker_nodes)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of availability zone.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def connections(self) -> 'outputs.GetEdgeKubernetesClustersClusterConnectionsResult':
        """
        Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        """
        The ID of nat gateway used to launch kubernetes cluster.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of security group where the current cluster worker node is located.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of VPC where the current cluster is located.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="workerNodes")
    def worker_nodes(self) -> Sequence['outputs.GetEdgeKubernetesClustersClusterWorkerNodeResult']:
        """
        List of cluster worker nodes. It contains several attributes to `Block Nodes`.
        """
        return pulumi.get(self, "worker_nodes")


@pulumi.output_type
class GetEdgeKubernetesClustersClusterConnectionsResult(dict):
    def __init__(__self__, *,
                 api_server_internet: str,
                 api_server_intranet: str):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        """
        GetEdgeKubernetesClustersClusterConnectionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_internet is None:
            raise TypeError("Missing 'api_server_internet' argument")
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if api_server_intranet is None:
            raise TypeError("Missing 'api_server_intranet' argument")

        _setter("api_server_internet", api_server_internet)
        _setter("api_server_intranet", api_server_intranet)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> str:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> str:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")


@pulumi.output_type
class GetEdgeKubernetesClustersClusterWorkerNodeResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_ip: str):
        """
        :param str id: ID of the node.
        :param str name: Node name.
        :param str private_ip: The private IP address of node.
        """
        GetEdgeKubernetesClustersClusterWorkerNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class GetKubernetesAddonsAddonResult(dict):
    def __init__(__self__, *,
                 current_config: str,
                 current_version: str,
                 name: str,
                 next_version: str,
                 required: bool):
        """
        :param str current_config: The current custom configuration of the addon. **Note:** Available in v1.166.0+
        :param str current_version: The current version of addon, if this field is an empty string, it means that the addon is not installed.
        :param str name: The name of addon.
        :param str next_version: The next version of this addon can be upgraded to.
        :param bool required: Whether the addon is a system addon.
        """
        GetKubernetesAddonsAddonResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_config=current_config,
            current_version=current_version,
            name=name,
            next_version=next_version,
            required=required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_config: Optional[str] = None,
             current_version: Optional[str] = None,
             name: Optional[str] = None,
             next_version: Optional[str] = None,
             required: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if current_config is None and 'currentConfig' in kwargs:
            current_config = kwargs['currentConfig']
        if current_config is None:
            raise TypeError("Missing 'current_config' argument")
        if current_version is None and 'currentVersion' in kwargs:
            current_version = kwargs['currentVersion']
        if current_version is None:
            raise TypeError("Missing 'current_version' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if next_version is None and 'nextVersion' in kwargs:
            next_version = kwargs['nextVersion']
        if next_version is None:
            raise TypeError("Missing 'next_version' argument")
        if required is None:
            raise TypeError("Missing 'required' argument")

        _setter("current_config", current_config)
        _setter("current_version", current_version)
        _setter("name", name)
        _setter("next_version", next_version)
        _setter("required", required)

    @property
    @pulumi.getter(name="currentConfig")
    def current_config(self) -> str:
        """
        The current custom configuration of the addon. **Note:** Available in v1.166.0+
        """
        return pulumi.get(self, "current_config")

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> str:
        """
        The current version of addon, if this field is an empty string, it means that the addon is not installed.
        """
        return pulumi.get(self, "current_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of addon.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next version of this addon can be upgraded to.
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Whether the addon is a system addon.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class GetKubernetesClustersClusterResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 cluster_network_type: str,
                 connections: 'outputs.GetKubernetesClustersClusterConnectionsResult',
                 id: str,
                 image_id: str,
                 key_name: str,
                 log_configs: Sequence['outputs.GetKubernetesClustersClusterLogConfigResult'],
                 master_auto_renew: bool,
                 master_auto_renew_period: int,
                 master_disk_category: str,
                 master_disk_size: int,
                 master_instance_charge_type: str,
                 master_instance_types: Sequence[str],
                 master_nodes: Sequence['outputs.GetKubernetesClustersClusterMasterNodeResult'],
                 master_period: int,
                 master_period_unit: str,
                 name: str,
                 nat_gateway_id: str,
                 node_cidr_mask: int,
                 pod_cidr: str,
                 security_group_id: str,
                 service_cidr: str,
                 slb_internet_enabled: bool,
                 vpc_id: str,
                 vswitch_ids: Sequence[str],
                 worker_auto_renew: bool,
                 worker_auto_renew_period: int,
                 worker_data_disk_category: str,
                 worker_data_disk_size: int,
                 worker_disk_category: str,
                 worker_disk_size: int,
                 worker_instance_charge_type: str,
                 worker_instance_types: Sequence[str],
                 worker_nodes: Sequence['outputs.GetKubernetesClustersClusterWorkerNodeResult'],
                 worker_numbers: Sequence[int],
                 worker_period: int,
                 worker_period_unit: str):
        """
        :param str availability_zone: The ID of availability zone.
        :param 'GetKubernetesClustersClusterConnectionsArgs' connections: Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
        :param str id: ID of the node.
        :param str image_id: The ID of node image.
        :param str key_name: The keypair of ssh login cluster node, you have to create it first.
        :param Sequence['GetKubernetesClustersClusterLogConfigArgs'] log_configs: A list of one element containing information about the associated log store. It contains the following attributes:
        :param str master_disk_category: The system disk category of master node.
        :param int master_disk_size: The system disk size of master node.
        :param Sequence[str] master_instance_types: The instance type of master node.
        :param Sequence['GetKubernetesClustersClusterMasterNodeArgs'] master_nodes: List of cluster master nodes. It contains several attributes to `Block Nodes`.
        :param str name: Node name.
        :param str nat_gateway_id: The ID of nat gateway used to launch kubernetes cluster.
        :param int node_cidr_mask: The network mask used on pods for each node.
        :param str security_group_id: The ID of security group where the current cluster worker node is located.
        :param bool slb_internet_enabled: Whether internet load balancer for API Server is created
        :param str vpc_id: The ID of VPC where the current cluster is located.
        :param Sequence[str] vswitch_ids: The ID of VSwitches where the current cluster is located.
        :param str worker_data_disk_category: The data disk size of worker node.
        :param int worker_data_disk_size: The data disk category of worker node.
        :param str worker_disk_category: The system disk category of worker node.
        :param int worker_disk_size: The system disk size of worker node.
        :param Sequence[str] worker_instance_types: The instance type of worker node.
        :param Sequence['GetKubernetesClustersClusterWorkerNodeArgs'] worker_nodes: List of cluster worker nodes. It contains several attributes to `Block Nodes`.
        :param Sequence[int] worker_numbers: The ECS instance node number in the current container cluster.
        """
        GetKubernetesClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            cluster_network_type=cluster_network_type,
            connections=connections,
            id=id,
            image_id=image_id,
            key_name=key_name,
            log_configs=log_configs,
            master_auto_renew=master_auto_renew,
            master_auto_renew_period=master_auto_renew_period,
            master_disk_category=master_disk_category,
            master_disk_size=master_disk_size,
            master_instance_charge_type=master_instance_charge_type,
            master_instance_types=master_instance_types,
            master_nodes=master_nodes,
            master_period=master_period,
            master_period_unit=master_period_unit,
            name=name,
            nat_gateway_id=nat_gateway_id,
            node_cidr_mask=node_cidr_mask,
            pod_cidr=pod_cidr,
            security_group_id=security_group_id,
            service_cidr=service_cidr,
            slb_internet_enabled=slb_internet_enabled,
            vpc_id=vpc_id,
            vswitch_ids=vswitch_ids,
            worker_auto_renew=worker_auto_renew,
            worker_auto_renew_period=worker_auto_renew_period,
            worker_data_disk_category=worker_data_disk_category,
            worker_data_disk_size=worker_data_disk_size,
            worker_disk_category=worker_disk_category,
            worker_disk_size=worker_disk_size,
            worker_instance_charge_type=worker_instance_charge_type,
            worker_instance_types=worker_instance_types,
            worker_nodes=worker_nodes,
            worker_numbers=worker_numbers,
            worker_period=worker_period,
            worker_period_unit=worker_period_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             cluster_network_type: Optional[str] = None,
             connections: Optional['outputs.GetKubernetesClustersClusterConnectionsResult'] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             key_name: Optional[str] = None,
             log_configs: Optional[Sequence['outputs.GetKubernetesClustersClusterLogConfigResult']] = None,
             master_auto_renew: Optional[bool] = None,
             master_auto_renew_period: Optional[int] = None,
             master_disk_category: Optional[str] = None,
             master_disk_size: Optional[int] = None,
             master_instance_charge_type: Optional[str] = None,
             master_instance_types: Optional[Sequence[str]] = None,
             master_nodes: Optional[Sequence['outputs.GetKubernetesClustersClusterMasterNodeResult']] = None,
             master_period: Optional[int] = None,
             master_period_unit: Optional[str] = None,
             name: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             node_cidr_mask: Optional[int] = None,
             pod_cidr: Optional[str] = None,
             security_group_id: Optional[str] = None,
             service_cidr: Optional[str] = None,
             slb_internet_enabled: Optional[bool] = None,
             vpc_id: Optional[str] = None,
             vswitch_ids: Optional[Sequence[str]] = None,
             worker_auto_renew: Optional[bool] = None,
             worker_auto_renew_period: Optional[int] = None,
             worker_data_disk_category: Optional[str] = None,
             worker_data_disk_size: Optional[int] = None,
             worker_disk_category: Optional[str] = None,
             worker_disk_size: Optional[int] = None,
             worker_instance_charge_type: Optional[str] = None,
             worker_instance_types: Optional[Sequence[str]] = None,
             worker_nodes: Optional[Sequence['outputs.GetKubernetesClustersClusterWorkerNodeResult']] = None,
             worker_numbers: Optional[Sequence[int]] = None,
             worker_period: Optional[int] = None,
             worker_period_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if cluster_network_type is None and 'clusterNetworkType' in kwargs:
            cluster_network_type = kwargs['clusterNetworkType']
        if cluster_network_type is None:
            raise TypeError("Missing 'cluster_network_type' argument")
        if connections is None:
            raise TypeError("Missing 'connections' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if log_configs is None and 'logConfigs' in kwargs:
            log_configs = kwargs['logConfigs']
        if log_configs is None:
            raise TypeError("Missing 'log_configs' argument")
        if master_auto_renew is None and 'masterAutoRenew' in kwargs:
            master_auto_renew = kwargs['masterAutoRenew']
        if master_auto_renew is None:
            raise TypeError("Missing 'master_auto_renew' argument")
        if master_auto_renew_period is None and 'masterAutoRenewPeriod' in kwargs:
            master_auto_renew_period = kwargs['masterAutoRenewPeriod']
        if master_auto_renew_period is None:
            raise TypeError("Missing 'master_auto_renew_period' argument")
        if master_disk_category is None and 'masterDiskCategory' in kwargs:
            master_disk_category = kwargs['masterDiskCategory']
        if master_disk_category is None:
            raise TypeError("Missing 'master_disk_category' argument")
        if master_disk_size is None and 'masterDiskSize' in kwargs:
            master_disk_size = kwargs['masterDiskSize']
        if master_disk_size is None:
            raise TypeError("Missing 'master_disk_size' argument")
        if master_instance_charge_type is None and 'masterInstanceChargeType' in kwargs:
            master_instance_charge_type = kwargs['masterInstanceChargeType']
        if master_instance_charge_type is None:
            raise TypeError("Missing 'master_instance_charge_type' argument")
        if master_instance_types is None and 'masterInstanceTypes' in kwargs:
            master_instance_types = kwargs['masterInstanceTypes']
        if master_instance_types is None:
            raise TypeError("Missing 'master_instance_types' argument")
        if master_nodes is None and 'masterNodes' in kwargs:
            master_nodes = kwargs['masterNodes']
        if master_nodes is None:
            raise TypeError("Missing 'master_nodes' argument")
        if master_period is None and 'masterPeriod' in kwargs:
            master_period = kwargs['masterPeriod']
        if master_period is None:
            raise TypeError("Missing 'master_period' argument")
        if master_period_unit is None and 'masterPeriodUnit' in kwargs:
            master_period_unit = kwargs['masterPeriodUnit']
        if master_period_unit is None:
            raise TypeError("Missing 'master_period_unit' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if node_cidr_mask is None and 'nodeCidrMask' in kwargs:
            node_cidr_mask = kwargs['nodeCidrMask']
        if node_cidr_mask is None:
            raise TypeError("Missing 'node_cidr_mask' argument")
        if pod_cidr is None and 'podCidr' in kwargs:
            pod_cidr = kwargs['podCidr']
        if pod_cidr is None:
            raise TypeError("Missing 'pod_cidr' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if service_cidr is None and 'serviceCidr' in kwargs:
            service_cidr = kwargs['serviceCidr']
        if service_cidr is None:
            raise TypeError("Missing 'service_cidr' argument")
        if slb_internet_enabled is None and 'slbInternetEnabled' in kwargs:
            slb_internet_enabled = kwargs['slbInternetEnabled']
        if slb_internet_enabled is None:
            raise TypeError("Missing 'slb_internet_enabled' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_ids is None and 'vswitchIds' in kwargs:
            vswitch_ids = kwargs['vswitchIds']
        if vswitch_ids is None:
            raise TypeError("Missing 'vswitch_ids' argument")
        if worker_auto_renew is None and 'workerAutoRenew' in kwargs:
            worker_auto_renew = kwargs['workerAutoRenew']
        if worker_auto_renew is None:
            raise TypeError("Missing 'worker_auto_renew' argument")
        if worker_auto_renew_period is None and 'workerAutoRenewPeriod' in kwargs:
            worker_auto_renew_period = kwargs['workerAutoRenewPeriod']
        if worker_auto_renew_period is None:
            raise TypeError("Missing 'worker_auto_renew_period' argument")
        if worker_data_disk_category is None and 'workerDataDiskCategory' in kwargs:
            worker_data_disk_category = kwargs['workerDataDiskCategory']
        if worker_data_disk_category is None:
            raise TypeError("Missing 'worker_data_disk_category' argument")
        if worker_data_disk_size is None and 'workerDataDiskSize' in kwargs:
            worker_data_disk_size = kwargs['workerDataDiskSize']
        if worker_data_disk_size is None:
            raise TypeError("Missing 'worker_data_disk_size' argument")
        if worker_disk_category is None and 'workerDiskCategory' in kwargs:
            worker_disk_category = kwargs['workerDiskCategory']
        if worker_disk_category is None:
            raise TypeError("Missing 'worker_disk_category' argument")
        if worker_disk_size is None and 'workerDiskSize' in kwargs:
            worker_disk_size = kwargs['workerDiskSize']
        if worker_disk_size is None:
            raise TypeError("Missing 'worker_disk_size' argument")
        if worker_instance_charge_type is None and 'workerInstanceChargeType' in kwargs:
            worker_instance_charge_type = kwargs['workerInstanceChargeType']
        if worker_instance_charge_type is None:
            raise TypeError("Missing 'worker_instance_charge_type' argument")
        if worker_instance_types is None and 'workerInstanceTypes' in kwargs:
            worker_instance_types = kwargs['workerInstanceTypes']
        if worker_instance_types is None:
            raise TypeError("Missing 'worker_instance_types' argument")
        if worker_nodes is None and 'workerNodes' in kwargs:
            worker_nodes = kwargs['workerNodes']
        if worker_nodes is None:
            raise TypeError("Missing 'worker_nodes' argument")
        if worker_numbers is None and 'workerNumbers' in kwargs:
            worker_numbers = kwargs['workerNumbers']
        if worker_numbers is None:
            raise TypeError("Missing 'worker_numbers' argument")
        if worker_period is None and 'workerPeriod' in kwargs:
            worker_period = kwargs['workerPeriod']
        if worker_period is None:
            raise TypeError("Missing 'worker_period' argument")
        if worker_period_unit is None and 'workerPeriodUnit' in kwargs:
            worker_period_unit = kwargs['workerPeriodUnit']
        if worker_period_unit is None:
            raise TypeError("Missing 'worker_period_unit' argument")

        _setter("availability_zone", availability_zone)
        _setter("cluster_network_type", cluster_network_type)
        _setter("connections", connections)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("key_name", key_name)
        _setter("log_configs", log_configs)
        _setter("master_auto_renew", master_auto_renew)
        _setter("master_auto_renew_period", master_auto_renew_period)
        _setter("master_disk_category", master_disk_category)
        _setter("master_disk_size", master_disk_size)
        _setter("master_instance_charge_type", master_instance_charge_type)
        _setter("master_instance_types", master_instance_types)
        _setter("master_nodes", master_nodes)
        _setter("master_period", master_period)
        _setter("master_period_unit", master_period_unit)
        _setter("name", name)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("node_cidr_mask", node_cidr_mask)
        _setter("pod_cidr", pod_cidr)
        _setter("security_group_id", security_group_id)
        _setter("service_cidr", service_cidr)
        _setter("slb_internet_enabled", slb_internet_enabled)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_ids", vswitch_ids)
        _setter("worker_auto_renew", worker_auto_renew)
        _setter("worker_auto_renew_period", worker_auto_renew_period)
        _setter("worker_data_disk_category", worker_data_disk_category)
        _setter("worker_data_disk_size", worker_data_disk_size)
        _setter("worker_disk_category", worker_disk_category)
        _setter("worker_disk_size", worker_disk_size)
        _setter("worker_instance_charge_type", worker_instance_charge_type)
        _setter("worker_instance_types", worker_instance_types)
        _setter("worker_nodes", worker_nodes)
        _setter("worker_numbers", worker_numbers)
        _setter("worker_period", worker_period)
        _setter("worker_period_unit", worker_period_unit)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of availability zone.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="clusterNetworkType")
    def cluster_network_type(self) -> str:
        return pulumi.get(self, "cluster_network_type")

    @property
    @pulumi.getter
    def connections(self) -> 'outputs.GetKubernetesClustersClusterConnectionsResult':
        """
        Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The ID of node image.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The keypair of ssh login cluster node, you have to create it first.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="logConfigs")
    def log_configs(self) -> Sequence['outputs.GetKubernetesClustersClusterLogConfigResult']:
        """
        A list of one element containing information about the associated log store. It contains the following attributes:
        """
        return pulumi.get(self, "log_configs")

    @property
    @pulumi.getter(name="masterAutoRenew")
    def master_auto_renew(self) -> bool:
        return pulumi.get(self, "master_auto_renew")

    @property
    @pulumi.getter(name="masterAutoRenewPeriod")
    def master_auto_renew_period(self) -> int:
        return pulumi.get(self, "master_auto_renew_period")

    @property
    @pulumi.getter(name="masterDiskCategory")
    def master_disk_category(self) -> str:
        """
        The system disk category of master node.
        """
        return pulumi.get(self, "master_disk_category")

    @property
    @pulumi.getter(name="masterDiskSize")
    def master_disk_size(self) -> int:
        """
        The system disk size of master node.
        """
        return pulumi.get(self, "master_disk_size")

    @property
    @pulumi.getter(name="masterInstanceChargeType")
    def master_instance_charge_type(self) -> str:
        return pulumi.get(self, "master_instance_charge_type")

    @property
    @pulumi.getter(name="masterInstanceTypes")
    def master_instance_types(self) -> Sequence[str]:
        """
        The instance type of master node.
        """
        return pulumi.get(self, "master_instance_types")

    @property
    @pulumi.getter(name="masterNodes")
    def master_nodes(self) -> Sequence['outputs.GetKubernetesClustersClusterMasterNodeResult']:
        """
        List of cluster master nodes. It contains several attributes to `Block Nodes`.
        """
        return pulumi.get(self, "master_nodes")

    @property
    @pulumi.getter(name="masterPeriod")
    def master_period(self) -> int:
        return pulumi.get(self, "master_period")

    @property
    @pulumi.getter(name="masterPeriodUnit")
    def master_period_unit(self) -> str:
        return pulumi.get(self, "master_period_unit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        """
        The ID of nat gateway used to launch kubernetes cluster.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="nodeCidrMask")
    def node_cidr_mask(self) -> int:
        """
        The network mask used on pods for each node.
        """
        return pulumi.get(self, "node_cidr_mask")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> str:
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of security group where the current cluster worker node is located.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> str:
        return pulumi.get(self, "service_cidr")

    @property
    @pulumi.getter(name="slbInternetEnabled")
    def slb_internet_enabled(self) -> bool:
        """
        Whether internet load balancer for API Server is created
        """
        return pulumi.get(self, "slb_internet_enabled")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of VPC where the current cluster is located.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchIds")
    def vswitch_ids(self) -> Sequence[str]:
        """
        The ID of VSwitches where the current cluster is located.
        """
        return pulumi.get(self, "vswitch_ids")

    @property
    @pulumi.getter(name="workerAutoRenew")
    def worker_auto_renew(self) -> bool:
        return pulumi.get(self, "worker_auto_renew")

    @property
    @pulumi.getter(name="workerAutoRenewPeriod")
    def worker_auto_renew_period(self) -> int:
        return pulumi.get(self, "worker_auto_renew_period")

    @property
    @pulumi.getter(name="workerDataDiskCategory")
    def worker_data_disk_category(self) -> str:
        """
        The data disk size of worker node.
        """
        return pulumi.get(self, "worker_data_disk_category")

    @property
    @pulumi.getter(name="workerDataDiskSize")
    def worker_data_disk_size(self) -> int:
        """
        The data disk category of worker node.
        """
        return pulumi.get(self, "worker_data_disk_size")

    @property
    @pulumi.getter(name="workerDiskCategory")
    def worker_disk_category(self) -> str:
        """
        The system disk category of worker node.
        """
        return pulumi.get(self, "worker_disk_category")

    @property
    @pulumi.getter(name="workerDiskSize")
    def worker_disk_size(self) -> int:
        """
        The system disk size of worker node.
        """
        return pulumi.get(self, "worker_disk_size")

    @property
    @pulumi.getter(name="workerInstanceChargeType")
    def worker_instance_charge_type(self) -> str:
        return pulumi.get(self, "worker_instance_charge_type")

    @property
    @pulumi.getter(name="workerInstanceTypes")
    def worker_instance_types(self) -> Sequence[str]:
        """
        The instance type of worker node.
        """
        return pulumi.get(self, "worker_instance_types")

    @property
    @pulumi.getter(name="workerNodes")
    def worker_nodes(self) -> Sequence['outputs.GetKubernetesClustersClusterWorkerNodeResult']:
        """
        List of cluster worker nodes. It contains several attributes to `Block Nodes`.
        """
        return pulumi.get(self, "worker_nodes")

    @property
    @pulumi.getter(name="workerNumbers")
    def worker_numbers(self) -> Sequence[int]:
        """
        The ECS instance node number in the current container cluster.
        """
        return pulumi.get(self, "worker_numbers")

    @property
    @pulumi.getter(name="workerPeriod")
    def worker_period(self) -> int:
        return pulumi.get(self, "worker_period")

    @property
    @pulumi.getter(name="workerPeriodUnit")
    def worker_period_unit(self) -> str:
        return pulumi.get(self, "worker_period_unit")


@pulumi.output_type
class GetKubernetesClustersClusterConnectionsResult(dict):
    def __init__(__self__, *,
                 api_server_internet: str,
                 api_server_intranet: str,
                 master_public_ip: str,
                 service_domain: str):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        :param str master_public_ip: Master node SSH IP address.
        :param str service_domain: Service Access Domain.
        """
        GetKubernetesClustersClusterConnectionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             master_public_ip: Optional[str] = None,
             service_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_internet is None:
            raise TypeError("Missing 'api_server_internet' argument")
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if api_server_intranet is None:
            raise TypeError("Missing 'api_server_intranet' argument")
        if master_public_ip is None and 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if master_public_ip is None:
            raise TypeError("Missing 'master_public_ip' argument")
        if service_domain is None and 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']
        if service_domain is None:
            raise TypeError("Missing 'service_domain' argument")

        _setter("api_server_internet", api_server_internet)
        _setter("api_server_intranet", api_server_intranet)
        _setter("master_public_ip", master_public_ip)
        _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> str:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> str:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> str:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> str:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")


@pulumi.output_type
class GetKubernetesClustersClusterLogConfigResult(dict):
    def __init__(__self__, *,
                 project: str,
                 type: str):
        """
        :param str project: Log Service project name.
        :param str type: Type of collecting logs.
        """
        GetKubernetesClustersClusterLogConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project=project,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project is None:
            raise TypeError("Missing 'project' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("project", project)
        _setter("type", type)

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        Log Service project name.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of collecting logs.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesClustersClusterMasterNodeResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_ip: str):
        """
        :param str id: ID of the node.
        :param str name: Node name.
        :param str private_ip: The private IP address of node.
        """
        GetKubernetesClustersClusterMasterNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class GetKubernetesClustersClusterWorkerNodeResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_ip: str):
        """
        :param str id: ID of the node.
        :param str name: Node name.
        :param str private_ip: The private IP address of node.
        """
        GetKubernetesClustersClusterWorkerNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class GetKubernetesPermissionPermissionResult(dict):
    def __init__(__self__, *,
                 resource_id: str,
                 resource_type: str,
                 role_name: str,
                 is_owner: Optional[bool] = None,
                 is_ram_role: Optional[bool] = None,
                 role_type: Optional[str] = None):
        """
        :param str resource_id: The permission settings to manage ACK clusters.
        :param str resource_type: The authorization type. Valid values `cluster`, `namespace` and `console`.
        :param str role_name: The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
        :param bool is_owner: ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
        :param bool is_ram_role: Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
        :param str role_type: The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
        """
        GetKubernetesPermissionPermissionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_id=resource_id,
            resource_type=resource_type,
            role_name=role_name,
            is_owner=is_owner,
            is_ram_role=is_ram_role,
            role_type=role_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_id: Optional[str] = None,
             resource_type: Optional[str] = None,
             role_name: Optional[str] = None,
             is_owner: Optional[bool] = None,
             is_ram_role: Optional[bool] = None,
             role_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if resource_type is None:
            raise TypeError("Missing 'resource_type' argument")
        if role_name is None and 'roleName' in kwargs:
            role_name = kwargs['roleName']
        if role_name is None:
            raise TypeError("Missing 'role_name' argument")
        if is_owner is None and 'isOwner' in kwargs:
            is_owner = kwargs['isOwner']
        if is_ram_role is None and 'isRamRole' in kwargs:
            is_ram_role = kwargs['isRamRole']
        if role_type is None and 'roleType' in kwargs:
            role_type = kwargs['roleType']

        _setter("resource_id", resource_id)
        _setter("resource_type", resource_type)
        _setter("role_name", role_name)
        if is_owner is not None:
            _setter("is_owner", is_owner)
        if is_ram_role is not None:
            _setter("is_ram_role", is_ram_role)
        if role_type is not None:
            _setter("role_type", role_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The permission settings to manage ACK clusters.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        The authorization type. Valid values `cluster`, `namespace` and `console`.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        The name of the predefined role. If a custom role is assigned, the value is the name of the assigined custom role.
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="isOwner")
    def is_owner(self) -> Optional[bool]:
        """
        ndicates whether the permissions are granted to the cluster owner. Valid values `0`, `1`.
        """
        return pulumi.get(self, "is_owner")

    @property
    @pulumi.getter(name="isRamRole")
    def is_ram_role(self) -> Optional[bool]:
        """
        Indicates whether the permissions are granted to the RAM role. Valid values `0`,`1`.
        """
        return pulumi.get(self, "is_ram_role")

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> Optional[str]:
        """
        The predefined role. Valid values `admin`,`ops`,`dev`,`restricted` and `custom`.
        """
        return pulumi.get(self, "role_type")


@pulumi.output_type
class GetKubernetesVersionMetadataResult(dict):
    def __init__(__self__, *,
                 runtimes: Sequence['outputs.GetKubernetesVersionMetadataRuntimeResult'],
                 version: str):
        """
        :param Sequence['GetKubernetesVersionMetadataRuntimeArgs'] runtimes: The list of supported runtime.
        :param str version: The runtime version.
        """
        GetKubernetesVersionMetadataResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            runtimes=runtimes,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             runtimes: Optional[Sequence['outputs.GetKubernetesVersionMetadataRuntimeResult']] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if runtimes is None:
            raise TypeError("Missing 'runtimes' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("runtimes", runtimes)
        _setter("version", version)

    @property
    @pulumi.getter
    def runtimes(self) -> Sequence['outputs.GetKubernetesVersionMetadataRuntimeResult']:
        """
        The list of supported runtime.
        """
        return pulumi.get(self, "runtimes")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The runtime version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetKubernetesVersionMetadataRuntimeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 version: str):
        """
        :param str name: The runtime name.
        :param str version: The runtime version.
        """
        GetKubernetesVersionMetadataRuntimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("name", name)
        _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The runtime name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The runtime version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetManagedKubernetesClustersClusterResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 cluster_network_type: str,
                 connections: 'outputs.GetManagedKubernetesClustersClusterConnectionsResult',
                 id: str,
                 image_id: str,
                 key_name: str,
                 log_configs: Sequence['outputs.GetManagedKubernetesClustersClusterLogConfigResult'],
                 name: str,
                 nat_gateway_id: str,
                 pod_cidr: str,
                 security_group_id: str,
                 service_cidr: str,
                 slb_internet_enabled: bool,
                 vpc_id: str,
                 vswitch_ids: Sequence[str],
                 worker_auto_renew: bool,
                 worker_auto_renew_period: int,
                 worker_data_disk_category: str,
                 worker_data_disk_size: int,
                 worker_disk_category: str,
                 worker_disk_size: int,
                 worker_instance_charge_type: str,
                 worker_instance_types: Sequence[str],
                 worker_nodes: Sequence['outputs.GetManagedKubernetesClustersClusterWorkerNodeResult'],
                 worker_numbers: Sequence[int],
                 worker_period: int,
                 worker_period_unit: str):
        """
        :param str availability_zone: The ID of availability zone.
        :param 'GetManagedKubernetesClustersClusterConnectionsArgs' connections: Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
        :param str id: ID of the node.
        :param str key_name: The keypair of ssh login cluster node, you have to create it first.
        :param Sequence['GetManagedKubernetesClustersClusterLogConfigArgs'] log_configs: A list of one element containing information about the associated log store. It contains the following attributes:
        :param str name: Node name.
        :param str nat_gateway_id: The ID of nat gateway used to launch kubernetes cluster.
        :param str security_group_id: The ID of security group where the current cluster worker node is located.
        :param str vpc_id: The ID of VPC where the current cluster is located.
        :param Sequence[str] vswitch_ids: The ID of VSwitches where the current cluster is located.
        :param Sequence['GetManagedKubernetesClustersClusterWorkerNodeArgs'] worker_nodes: List of cluster worker nodes. It contains several attributes to `Block Nodes`.
        :param Sequence[int] worker_numbers: The ECS instance node number in the current container cluster.
        """
        GetManagedKubernetesClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            cluster_network_type=cluster_network_type,
            connections=connections,
            id=id,
            image_id=image_id,
            key_name=key_name,
            log_configs=log_configs,
            name=name,
            nat_gateway_id=nat_gateway_id,
            pod_cidr=pod_cidr,
            security_group_id=security_group_id,
            service_cidr=service_cidr,
            slb_internet_enabled=slb_internet_enabled,
            vpc_id=vpc_id,
            vswitch_ids=vswitch_ids,
            worker_auto_renew=worker_auto_renew,
            worker_auto_renew_period=worker_auto_renew_period,
            worker_data_disk_category=worker_data_disk_category,
            worker_data_disk_size=worker_data_disk_size,
            worker_disk_category=worker_disk_category,
            worker_disk_size=worker_disk_size,
            worker_instance_charge_type=worker_instance_charge_type,
            worker_instance_types=worker_instance_types,
            worker_nodes=worker_nodes,
            worker_numbers=worker_numbers,
            worker_period=worker_period,
            worker_period_unit=worker_period_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             cluster_network_type: Optional[str] = None,
             connections: Optional['outputs.GetManagedKubernetesClustersClusterConnectionsResult'] = None,
             id: Optional[str] = None,
             image_id: Optional[str] = None,
             key_name: Optional[str] = None,
             log_configs: Optional[Sequence['outputs.GetManagedKubernetesClustersClusterLogConfigResult']] = None,
             name: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             pod_cidr: Optional[str] = None,
             security_group_id: Optional[str] = None,
             service_cidr: Optional[str] = None,
             slb_internet_enabled: Optional[bool] = None,
             vpc_id: Optional[str] = None,
             vswitch_ids: Optional[Sequence[str]] = None,
             worker_auto_renew: Optional[bool] = None,
             worker_auto_renew_period: Optional[int] = None,
             worker_data_disk_category: Optional[str] = None,
             worker_data_disk_size: Optional[int] = None,
             worker_disk_category: Optional[str] = None,
             worker_disk_size: Optional[int] = None,
             worker_instance_charge_type: Optional[str] = None,
             worker_instance_types: Optional[Sequence[str]] = None,
             worker_nodes: Optional[Sequence['outputs.GetManagedKubernetesClustersClusterWorkerNodeResult']] = None,
             worker_numbers: Optional[Sequence[int]] = None,
             worker_period: Optional[int] = None,
             worker_period_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if cluster_network_type is None and 'clusterNetworkType' in kwargs:
            cluster_network_type = kwargs['clusterNetworkType']
        if cluster_network_type is None:
            raise TypeError("Missing 'cluster_network_type' argument")
        if connections is None:
            raise TypeError("Missing 'connections' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if log_configs is None and 'logConfigs' in kwargs:
            log_configs = kwargs['logConfigs']
        if log_configs is None:
            raise TypeError("Missing 'log_configs' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if pod_cidr is None and 'podCidr' in kwargs:
            pod_cidr = kwargs['podCidr']
        if pod_cidr is None:
            raise TypeError("Missing 'pod_cidr' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if service_cidr is None and 'serviceCidr' in kwargs:
            service_cidr = kwargs['serviceCidr']
        if service_cidr is None:
            raise TypeError("Missing 'service_cidr' argument")
        if slb_internet_enabled is None and 'slbInternetEnabled' in kwargs:
            slb_internet_enabled = kwargs['slbInternetEnabled']
        if slb_internet_enabled is None:
            raise TypeError("Missing 'slb_internet_enabled' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_ids is None and 'vswitchIds' in kwargs:
            vswitch_ids = kwargs['vswitchIds']
        if vswitch_ids is None:
            raise TypeError("Missing 'vswitch_ids' argument")
        if worker_auto_renew is None and 'workerAutoRenew' in kwargs:
            worker_auto_renew = kwargs['workerAutoRenew']
        if worker_auto_renew is None:
            raise TypeError("Missing 'worker_auto_renew' argument")
        if worker_auto_renew_period is None and 'workerAutoRenewPeriod' in kwargs:
            worker_auto_renew_period = kwargs['workerAutoRenewPeriod']
        if worker_auto_renew_period is None:
            raise TypeError("Missing 'worker_auto_renew_period' argument")
        if worker_data_disk_category is None and 'workerDataDiskCategory' in kwargs:
            worker_data_disk_category = kwargs['workerDataDiskCategory']
        if worker_data_disk_category is None:
            raise TypeError("Missing 'worker_data_disk_category' argument")
        if worker_data_disk_size is None and 'workerDataDiskSize' in kwargs:
            worker_data_disk_size = kwargs['workerDataDiskSize']
        if worker_data_disk_size is None:
            raise TypeError("Missing 'worker_data_disk_size' argument")
        if worker_disk_category is None and 'workerDiskCategory' in kwargs:
            worker_disk_category = kwargs['workerDiskCategory']
        if worker_disk_category is None:
            raise TypeError("Missing 'worker_disk_category' argument")
        if worker_disk_size is None and 'workerDiskSize' in kwargs:
            worker_disk_size = kwargs['workerDiskSize']
        if worker_disk_size is None:
            raise TypeError("Missing 'worker_disk_size' argument")
        if worker_instance_charge_type is None and 'workerInstanceChargeType' in kwargs:
            worker_instance_charge_type = kwargs['workerInstanceChargeType']
        if worker_instance_charge_type is None:
            raise TypeError("Missing 'worker_instance_charge_type' argument")
        if worker_instance_types is None and 'workerInstanceTypes' in kwargs:
            worker_instance_types = kwargs['workerInstanceTypes']
        if worker_instance_types is None:
            raise TypeError("Missing 'worker_instance_types' argument")
        if worker_nodes is None and 'workerNodes' in kwargs:
            worker_nodes = kwargs['workerNodes']
        if worker_nodes is None:
            raise TypeError("Missing 'worker_nodes' argument")
        if worker_numbers is None and 'workerNumbers' in kwargs:
            worker_numbers = kwargs['workerNumbers']
        if worker_numbers is None:
            raise TypeError("Missing 'worker_numbers' argument")
        if worker_period is None and 'workerPeriod' in kwargs:
            worker_period = kwargs['workerPeriod']
        if worker_period is None:
            raise TypeError("Missing 'worker_period' argument")
        if worker_period_unit is None and 'workerPeriodUnit' in kwargs:
            worker_period_unit = kwargs['workerPeriodUnit']
        if worker_period_unit is None:
            raise TypeError("Missing 'worker_period_unit' argument")

        _setter("availability_zone", availability_zone)
        _setter("cluster_network_type", cluster_network_type)
        _setter("connections", connections)
        _setter("id", id)
        _setter("image_id", image_id)
        _setter("key_name", key_name)
        _setter("log_configs", log_configs)
        _setter("name", name)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("pod_cidr", pod_cidr)
        _setter("security_group_id", security_group_id)
        _setter("service_cidr", service_cidr)
        _setter("slb_internet_enabled", slb_internet_enabled)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_ids", vswitch_ids)
        _setter("worker_auto_renew", worker_auto_renew)
        _setter("worker_auto_renew_period", worker_auto_renew_period)
        _setter("worker_data_disk_category", worker_data_disk_category)
        _setter("worker_data_disk_size", worker_data_disk_size)
        _setter("worker_disk_category", worker_disk_category)
        _setter("worker_disk_size", worker_disk_size)
        _setter("worker_instance_charge_type", worker_instance_charge_type)
        _setter("worker_instance_types", worker_instance_types)
        _setter("worker_nodes", worker_nodes)
        _setter("worker_numbers", worker_numbers)
        _setter("worker_period", worker_period)
        _setter("worker_period_unit", worker_period_unit)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The ID of availability zone.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="clusterNetworkType")
    def cluster_network_type(self) -> str:
        return pulumi.get(self, "cluster_network_type")

    @property
    @pulumi.getter
    def connections(self) -> 'outputs.GetManagedKubernetesClustersClusterConnectionsResult':
        """
        Map of kubernetes cluster connection information. It contains several attributes to `Block Connections`.
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The keypair of ssh login cluster node, you have to create it first.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="logConfigs")
    def log_configs(self) -> Sequence['outputs.GetManagedKubernetesClustersClusterLogConfigResult']:
        """
        A list of one element containing information about the associated log store. It contains the following attributes:
        """
        return pulumi.get(self, "log_configs")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        """
        The ID of nat gateway used to launch kubernetes cluster.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> str:
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of security group where the current cluster worker node is located.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> str:
        return pulumi.get(self, "service_cidr")

    @property
    @pulumi.getter(name="slbInternetEnabled")
    def slb_internet_enabled(self) -> bool:
        return pulumi.get(self, "slb_internet_enabled")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of VPC where the current cluster is located.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchIds")
    def vswitch_ids(self) -> Sequence[str]:
        """
        The ID of VSwitches where the current cluster is located.
        """
        return pulumi.get(self, "vswitch_ids")

    @property
    @pulumi.getter(name="workerAutoRenew")
    def worker_auto_renew(self) -> bool:
        return pulumi.get(self, "worker_auto_renew")

    @property
    @pulumi.getter(name="workerAutoRenewPeriod")
    def worker_auto_renew_period(self) -> int:
        return pulumi.get(self, "worker_auto_renew_period")

    @property
    @pulumi.getter(name="workerDataDiskCategory")
    def worker_data_disk_category(self) -> str:
        return pulumi.get(self, "worker_data_disk_category")

    @property
    @pulumi.getter(name="workerDataDiskSize")
    def worker_data_disk_size(self) -> int:
        return pulumi.get(self, "worker_data_disk_size")

    @property
    @pulumi.getter(name="workerDiskCategory")
    def worker_disk_category(self) -> str:
        return pulumi.get(self, "worker_disk_category")

    @property
    @pulumi.getter(name="workerDiskSize")
    def worker_disk_size(self) -> int:
        return pulumi.get(self, "worker_disk_size")

    @property
    @pulumi.getter(name="workerInstanceChargeType")
    def worker_instance_charge_type(self) -> str:
        return pulumi.get(self, "worker_instance_charge_type")

    @property
    @pulumi.getter(name="workerInstanceTypes")
    def worker_instance_types(self) -> Sequence[str]:
        return pulumi.get(self, "worker_instance_types")

    @property
    @pulumi.getter(name="workerNodes")
    def worker_nodes(self) -> Sequence['outputs.GetManagedKubernetesClustersClusterWorkerNodeResult']:
        """
        List of cluster worker nodes. It contains several attributes to `Block Nodes`.
        """
        return pulumi.get(self, "worker_nodes")

    @property
    @pulumi.getter(name="workerNumbers")
    def worker_numbers(self) -> Sequence[int]:
        """
        The ECS instance node number in the current container cluster.
        """
        return pulumi.get(self, "worker_numbers")

    @property
    @pulumi.getter(name="workerPeriod")
    def worker_period(self) -> int:
        return pulumi.get(self, "worker_period")

    @property
    @pulumi.getter(name="workerPeriodUnit")
    def worker_period_unit(self) -> str:
        return pulumi.get(self, "worker_period_unit")


@pulumi.output_type
class GetManagedKubernetesClustersClusterConnectionsResult(dict):
    def __init__(__self__, *,
                 api_server_internet: str,
                 api_server_intranet: str,
                 master_public_ip: str,
                 service_domain: str):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        :param str master_public_ip: Master node SSH IP address.
        :param str service_domain: Service Access Domain.
        """
        GetManagedKubernetesClustersClusterConnectionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
            service_domain=service_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             master_public_ip: Optional[str] = None,
             service_domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_internet is None:
            raise TypeError("Missing 'api_server_internet' argument")
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if api_server_intranet is None:
            raise TypeError("Missing 'api_server_intranet' argument")
        if master_public_ip is None and 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if master_public_ip is None:
            raise TypeError("Missing 'master_public_ip' argument")
        if service_domain is None and 'serviceDomain' in kwargs:
            service_domain = kwargs['serviceDomain']
        if service_domain is None:
            raise TypeError("Missing 'service_domain' argument")

        _setter("api_server_internet", api_server_internet)
        _setter("api_server_intranet", api_server_intranet)
        _setter("master_public_ip", master_public_ip)
        _setter("service_domain", service_domain)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> str:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> str:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> str:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> str:
        """
        Service Access Domain.
        """
        return pulumi.get(self, "service_domain")


@pulumi.output_type
class GetManagedKubernetesClustersClusterLogConfigResult(dict):
    def __init__(__self__, *,
                 project: str,
                 type: str):
        """
        :param str project: Log Service project name.
        :param str type: Type of collecting logs.
        """
        GetManagedKubernetesClustersClusterLogConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project=project,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project is None:
            raise TypeError("Missing 'project' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("project", project)
        _setter("type", type)

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        Log Service project name.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of collecting logs.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetManagedKubernetesClustersClusterWorkerNodeResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_ip: str):
        """
        :param str id: ID of the node.
        :param str name: Node name.
        :param str private_ip: The private IP address of node.
        """
        GetManagedKubernetesClustersClusterWorkerNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            private_ip=private_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if private_ip is None:
            raise TypeError("Missing 'private_ip' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("private_ip", private_ip)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Node name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address of node.
        """
        return pulumi.get(self, "private_ip")


@pulumi.output_type
class GetRegistryEnterpriseInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 authorization_token: str,
                 id: str,
                 name: str,
                 namespace_quota: str,
                 namespace_usage: str,
                 public_endpoints: Sequence[str],
                 region: str,
                 repo_quota: str,
                 repo_usage: str,
                 specification: str,
                 temp_username: str,
                 vpc_endpoints: Sequence[str]):
        """
        :param str authorization_token: The password that was used to log on to the registry.
        :param str id: ID of Container Registry Enterprise Edition instance.
        :param str name: Name of Container Registry Enterprise Edition instance.
        :param str namespace_quota: The max number of namespaces that an instance can create.
        :param str namespace_usage: The number of namespaces already created.
        :param Sequence[str] public_endpoints: A list of domains for access on internet network.
        :param str region: Region of Container Registry Enterprise Edition instance.
        :param str repo_quota: The max number of repos that an instance can create.
        :param str repo_usage: The number of repos already created.
        :param str specification: Specification of Container Registry Enterprise Edition instance.
        :param str temp_username: The username that was used to log on to the registry.
        :param Sequence[str] vpc_endpoints: A list of domains for access on vpc network.
        """
        GetRegistryEnterpriseInstancesInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_token=authorization_token,
            id=id,
            name=name,
            namespace_quota=namespace_quota,
            namespace_usage=namespace_usage,
            public_endpoints=public_endpoints,
            region=region,
            repo_quota=repo_quota,
            repo_usage=repo_usage,
            specification=specification,
            temp_username=temp_username,
            vpc_endpoints=vpc_endpoints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_token: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             namespace_quota: Optional[str] = None,
             namespace_usage: Optional[str] = None,
             public_endpoints: Optional[Sequence[str]] = None,
             region: Optional[str] = None,
             repo_quota: Optional[str] = None,
             repo_usage: Optional[str] = None,
             specification: Optional[str] = None,
             temp_username: Optional[str] = None,
             vpc_endpoints: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorization_token is None and 'authorizationToken' in kwargs:
            authorization_token = kwargs['authorizationToken']
        if authorization_token is None:
            raise TypeError("Missing 'authorization_token' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if namespace_quota is None and 'namespaceQuota' in kwargs:
            namespace_quota = kwargs['namespaceQuota']
        if namespace_quota is None:
            raise TypeError("Missing 'namespace_quota' argument")
        if namespace_usage is None and 'namespaceUsage' in kwargs:
            namespace_usage = kwargs['namespaceUsage']
        if namespace_usage is None:
            raise TypeError("Missing 'namespace_usage' argument")
        if public_endpoints is None and 'publicEndpoints' in kwargs:
            public_endpoints = kwargs['publicEndpoints']
        if public_endpoints is None:
            raise TypeError("Missing 'public_endpoints' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")
        if repo_quota is None and 'repoQuota' in kwargs:
            repo_quota = kwargs['repoQuota']
        if repo_quota is None:
            raise TypeError("Missing 'repo_quota' argument")
        if repo_usage is None and 'repoUsage' in kwargs:
            repo_usage = kwargs['repoUsage']
        if repo_usage is None:
            raise TypeError("Missing 'repo_usage' argument")
        if specification is None:
            raise TypeError("Missing 'specification' argument")
        if temp_username is None and 'tempUsername' in kwargs:
            temp_username = kwargs['tempUsername']
        if temp_username is None:
            raise TypeError("Missing 'temp_username' argument")
        if vpc_endpoints is None and 'vpcEndpoints' in kwargs:
            vpc_endpoints = kwargs['vpcEndpoints']
        if vpc_endpoints is None:
            raise TypeError("Missing 'vpc_endpoints' argument")

        _setter("authorization_token", authorization_token)
        _setter("id", id)
        _setter("name", name)
        _setter("namespace_quota", namespace_quota)
        _setter("namespace_usage", namespace_usage)
        _setter("public_endpoints", public_endpoints)
        _setter("region", region)
        _setter("repo_quota", repo_quota)
        _setter("repo_usage", repo_usage)
        _setter("specification", specification)
        _setter("temp_username", temp_username)
        _setter("vpc_endpoints", vpc_endpoints)

    @property
    @pulumi.getter(name="authorizationToken")
    def authorization_token(self) -> str:
        """
        The password that was used to log on to the registry.
        """
        return pulumi.get(self, "authorization_token")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Container Registry Enterprise Edition instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Container Registry Enterprise Edition instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceQuota")
    def namespace_quota(self) -> str:
        """
        The max number of namespaces that an instance can create.
        """
        return pulumi.get(self, "namespace_quota")

    @property
    @pulumi.getter(name="namespaceUsage")
    def namespace_usage(self) -> str:
        """
        The number of namespaces already created.
        """
        return pulumi.get(self, "namespace_usage")

    @property
    @pulumi.getter(name="publicEndpoints")
    def public_endpoints(self) -> Sequence[str]:
        """
        A list of domains for access on internet network.
        """
        return pulumi.get(self, "public_endpoints")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of Container Registry Enterprise Edition instance.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="repoQuota")
    def repo_quota(self) -> str:
        """
        The max number of repos that an instance can create.
        """
        return pulumi.get(self, "repo_quota")

    @property
    @pulumi.getter(name="repoUsage")
    def repo_usage(self) -> str:
        """
        The number of repos already created.
        """
        return pulumi.get(self, "repo_usage")

    @property
    @pulumi.getter
    def specification(self) -> str:
        """
        Specification of Container Registry Enterprise Edition instance.
        """
        return pulumi.get(self, "specification")

    @property
    @pulumi.getter(name="tempUsername")
    def temp_username(self) -> str:
        """
        The username that was used to log on to the registry.
        """
        return pulumi.get(self, "temp_username")

    @property
    @pulumi.getter(name="vpcEndpoints")
    def vpc_endpoints(self) -> Sequence[str]:
        """
        A list of domains for access on vpc network.
        """
        return pulumi.get(self, "vpc_endpoints")


@pulumi.output_type
class GetRegistryEnterpriseNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 auto_create: bool,
                 default_visibility: str,
                 id: str,
                 instance_id: str,
                 name: str,
                 namespace_id: str,
                 namespace_name: str):
        """
        :param bool auto_create: Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
        :param str default_visibility: `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
        :param str id: ID of Container Registry Enterprise Edition namespace. It formats as `<instance_id>:<namespace_name>`. Before 1.161.0, it is a namespace uuid.
        :param str instance_id: ID of Container Registry Enterprise Edition instance.
        :param str name: Name of Container Registry Enterprise Edition namespace.
        :param str namespace_id: Container Registry Enterprise Edition namespace id. It is a uuid.
        :param str namespace_name: Name of Container Registry Enterprise Edition namespace.
        """
        GetRegistryEnterpriseNamespacesNamespaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_create=auto_create,
            default_visibility=default_visibility,
            id=id,
            instance_id=instance_id,
            name=name,
            namespace_id=namespace_id,
            namespace_name=namespace_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_create: Optional[bool] = None,
             default_visibility: Optional[str] = None,
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             name: Optional[str] = None,
             namespace_id: Optional[str] = None,
             namespace_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_create is None and 'autoCreate' in kwargs:
            auto_create = kwargs['autoCreate']
        if auto_create is None:
            raise TypeError("Missing 'auto_create' argument")
        if default_visibility is None and 'defaultVisibility' in kwargs:
            default_visibility = kwargs['defaultVisibility']
        if default_visibility is None:
            raise TypeError("Missing 'default_visibility' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if namespace_id is None and 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if namespace_id is None:
            raise TypeError("Missing 'namespace_id' argument")
        if namespace_name is None and 'namespaceName' in kwargs:
            namespace_name = kwargs['namespaceName']
        if namespace_name is None:
            raise TypeError("Missing 'namespace_name' argument")

        _setter("auto_create", auto_create)
        _setter("default_visibility", default_visibility)
        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("name", name)
        _setter("namespace_id", namespace_id)
        _setter("namespace_name", namespace_name)

    @property
    @pulumi.getter(name="autoCreate")
    def auto_create(self) -> bool:
        """
        Boolean, when it set to true, repositories are automatically created when pushing new images. If it set to false, you create repository for images before pushing.
        """
        return pulumi.get(self, "auto_create")

    @property
    @pulumi.getter(name="defaultVisibility")
    def default_visibility(self) -> str:
        """
        `PUBLIC` or `PRIVATE`, default repository visibility in this namespace.
        """
        return pulumi.get(self, "default_visibility")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Container Registry Enterprise Edition namespace. It formats as `<instance_id>:<namespace_name>`. Before 1.161.0, it is a namespace uuid.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of Container Registry Enterprise Edition instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Container Registry Enterprise Edition namespace.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        Container Registry Enterprise Edition namespace id. It is a uuid.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> str:
        """
        Name of Container Registry Enterprise Edition namespace.
        """
        return pulumi.get(self, "namespace_name")


@pulumi.output_type
class GetRegistryEnterpriseReposRepoResult(dict):
    def __init__(__self__, *,
                 id: str,
                 instance_id: str,
                 name: str,
                 namespace: str,
                 repo_type: str,
                 summary: str,
                 tags: Sequence['outputs.GetRegistryEnterpriseReposRepoTagResult']):
        """
        :param str id: ID of Container Registry Enterprise Edition repository.
        :param str instance_id: ID of Container Registry Enterprise Edition instance.
        :param str name: Name of Container Registry Enterprise Edition repository.
        :param str namespace: Name of Container Registry Enterprise Edition namespace where the repositories are located in.
        :param str repo_type: `PUBLIC` or `PRIVATE`, repository's visibility.
        :param str summary: The repository general information.
        :param Sequence['GetRegistryEnterpriseReposRepoTagArgs'] tags: A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
        """
        GetRegistryEnterpriseReposRepoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            instance_id=instance_id,
            name=name,
            namespace=namespace,
            repo_type=repo_type,
            summary=summary,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             name: Optional[str] = None,
             namespace: Optional[str] = None,
             repo_type: Optional[str] = None,
             summary: Optional[str] = None,
             tags: Optional[Sequence['outputs.GetRegistryEnterpriseReposRepoTagResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if repo_type is None and 'repoType' in kwargs:
            repo_type = kwargs['repoType']
        if repo_type is None:
            raise TypeError("Missing 'repo_type' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("name", name)
        _setter("namespace", namespace)
        _setter("repo_type", repo_type)
        _setter("summary", summary)
        _setter("tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Container Registry Enterprise Edition repository.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of Container Registry Enterprise Edition instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Container Registry Enterprise Edition repository.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of Container Registry Enterprise Edition namespace where the repositories are located in.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> str:
        """
        `PUBLIC` or `PRIVATE`, repository's visibility.
        """
        return pulumi.get(self, "repo_type")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The repository general information.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetRegistryEnterpriseReposRepoTagResult']:
        """
        A list of image tags belong to this repository. Each contains several attributes, see `Block Tag`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetRegistryEnterpriseReposRepoTagResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 image_create: str,
                 image_id: str,
                 image_size: int,
                 image_update: str,
                 status: str,
                 tag: str):
        """
        :param str digest: Digest of this image.
        :param str image_create: Create time of this image, unix time in nanoseconds.
        :param str image_id: Id of this image.
        :param int image_size: Status of this image, in bytes.
        :param str image_update: Last update time of this image, unix time in nanoseconds.
        :param str status: Status of this image.
        :param str tag: Tag of this image.
        """
        GetRegistryEnterpriseReposRepoTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            image_create=image_create,
            image_id=image_id,
            image_size=image_size,
            image_update=image_update,
            status=status,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: Optional[str] = None,
             image_create: Optional[str] = None,
             image_id: Optional[str] = None,
             image_size: Optional[int] = None,
             image_update: Optional[str] = None,
             status: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if digest is None:
            raise TypeError("Missing 'digest' argument")
        if image_create is None and 'imageCreate' in kwargs:
            image_create = kwargs['imageCreate']
        if image_create is None:
            raise TypeError("Missing 'image_create' argument")
        if image_id is None and 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if image_id is None:
            raise TypeError("Missing 'image_id' argument")
        if image_size is None and 'imageSize' in kwargs:
            image_size = kwargs['imageSize']
        if image_size is None:
            raise TypeError("Missing 'image_size' argument")
        if image_update is None and 'imageUpdate' in kwargs:
            image_update = kwargs['imageUpdate']
        if image_update is None:
            raise TypeError("Missing 'image_update' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tag is None:
            raise TypeError("Missing 'tag' argument")

        _setter("digest", digest)
        _setter("image_create", image_create)
        _setter("image_id", image_id)
        _setter("image_size", image_size)
        _setter("image_update", image_update)
        _setter("status", status)
        _setter("tag", tag)

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        Digest of this image.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="imageCreate")
    def image_create(self) -> str:
        """
        Create time of this image, unix time in nanoseconds.
        """
        return pulumi.get(self, "image_create")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        Id of this image.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="imageSize")
    def image_size(self) -> int:
        """
        Status of this image, in bytes.
        """
        return pulumi.get(self, "image_size")

    @property
    @pulumi.getter(name="imageUpdate")
    def image_update(self) -> str:
        """
        Last update time of this image, unix time in nanoseconds.
        """
        return pulumi.get(self, "image_update")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of this image.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Tag of this image.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetRegistryEnterpriseSyncRulesRuleResult(dict):
    def __init__(__self__, *,
                 id: str,
                 instance_id: str,
                 name: str,
                 namespace_name: str,
                 region_id: str,
                 repo_name: str,
                 sync_direction: str,
                 sync_scope: str,
                 sync_trigger: str,
                 tag_filter: str,
                 target_instance_id: str,
                 target_namespace_name: str,
                 target_region_id: str,
                 target_repo_name: str):
        """
        :param str id: ID of Container Registry Enterprise Edition sync rule.
        :param str instance_id: ID of Container Registry Enterprise Edition local instance.
        :param str name: Name of Container Registry Enterprise Edition sync rule.
        :param str namespace_name: Name of Container Registry Enterprise Edition local namespace.
        :param str region_id: Region of Container Registry Enterprise Edition local instance.
        :param str repo_name: Name of Container Registry Enterprise Edition local repo.
        :param str sync_direction: `FROM` or `TO`, the direction of synchronization. `FROM` indicates that the local instance is the source instance. `TO` indicates that the local instance is the target instance to be synchronized.
        :param str sync_scope: `REPO` or `NAMESPACE`,the scope that the synchronization rule applies.
        :param str sync_trigger: `PASSIVE` or `INITIATIVE`, the policy configured to trigger the synchronization rule.
        :param str tag_filter: The regular expression used to filter image tags for synchronization in the source repository.
        :param str target_instance_id: ID of Container Registry Enterprise Edition target instance.
        :param str target_namespace_name: Name of Container Registry Enterprise Edition target namespace.
        :param str target_region_id: Region of Container Registry Enterprise Edition target instance.
        :param str target_repo_name: Name of Container Registry Enterprise Edition target repo.
        """
        GetRegistryEnterpriseSyncRulesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            instance_id=instance_id,
            name=name,
            namespace_name=namespace_name,
            region_id=region_id,
            repo_name=repo_name,
            sync_direction=sync_direction,
            sync_scope=sync_scope,
            sync_trigger=sync_trigger,
            tag_filter=tag_filter,
            target_instance_id=target_instance_id,
            target_namespace_name=target_namespace_name,
            target_region_id=target_region_id,
            target_repo_name=target_repo_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             instance_id: Optional[str] = None,
             name: Optional[str] = None,
             namespace_name: Optional[str] = None,
             region_id: Optional[str] = None,
             repo_name: Optional[str] = None,
             sync_direction: Optional[str] = None,
             sync_scope: Optional[str] = None,
             sync_trigger: Optional[str] = None,
             tag_filter: Optional[str] = None,
             target_instance_id: Optional[str] = None,
             target_namespace_name: Optional[str] = None,
             target_region_id: Optional[str] = None,
             target_repo_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if namespace_name is None and 'namespaceName' in kwargs:
            namespace_name = kwargs['namespaceName']
        if namespace_name is None:
            raise TypeError("Missing 'namespace_name' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")
        if repo_name is None and 'repoName' in kwargs:
            repo_name = kwargs['repoName']
        if repo_name is None:
            raise TypeError("Missing 'repo_name' argument")
        if sync_direction is None and 'syncDirection' in kwargs:
            sync_direction = kwargs['syncDirection']
        if sync_direction is None:
            raise TypeError("Missing 'sync_direction' argument")
        if sync_scope is None and 'syncScope' in kwargs:
            sync_scope = kwargs['syncScope']
        if sync_scope is None:
            raise TypeError("Missing 'sync_scope' argument")
        if sync_trigger is None and 'syncTrigger' in kwargs:
            sync_trigger = kwargs['syncTrigger']
        if sync_trigger is None:
            raise TypeError("Missing 'sync_trigger' argument")
        if tag_filter is None and 'tagFilter' in kwargs:
            tag_filter = kwargs['tagFilter']
        if tag_filter is None:
            raise TypeError("Missing 'tag_filter' argument")
        if target_instance_id is None and 'targetInstanceId' in kwargs:
            target_instance_id = kwargs['targetInstanceId']
        if target_instance_id is None:
            raise TypeError("Missing 'target_instance_id' argument")
        if target_namespace_name is None and 'targetNamespaceName' in kwargs:
            target_namespace_name = kwargs['targetNamespaceName']
        if target_namespace_name is None:
            raise TypeError("Missing 'target_namespace_name' argument")
        if target_region_id is None and 'targetRegionId' in kwargs:
            target_region_id = kwargs['targetRegionId']
        if target_region_id is None:
            raise TypeError("Missing 'target_region_id' argument")
        if target_repo_name is None and 'targetRepoName' in kwargs:
            target_repo_name = kwargs['targetRepoName']
        if target_repo_name is None:
            raise TypeError("Missing 'target_repo_name' argument")

        _setter("id", id)
        _setter("instance_id", instance_id)
        _setter("name", name)
        _setter("namespace_name", namespace_name)
        _setter("region_id", region_id)
        _setter("repo_name", repo_name)
        _setter("sync_direction", sync_direction)
        _setter("sync_scope", sync_scope)
        _setter("sync_trigger", sync_trigger)
        _setter("tag_filter", tag_filter)
        _setter("target_instance_id", target_instance_id)
        _setter("target_namespace_name", target_namespace_name)
        _setter("target_region_id", target_region_id)
        _setter("target_repo_name", target_repo_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Container Registry Enterprise Edition sync rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        ID of Container Registry Enterprise Edition local instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Container Registry Enterprise Edition sync rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> str:
        """
        Name of Container Registry Enterprise Edition local namespace.
        """
        return pulumi.get(self, "namespace_name")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        Region of Container Registry Enterprise Edition local instance.
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Name of Container Registry Enterprise Edition local repo.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="syncDirection")
    def sync_direction(self) -> str:
        """
        `FROM` or `TO`, the direction of synchronization. `FROM` indicates that the local instance is the source instance. `TO` indicates that the local instance is the target instance to be synchronized.
        """
        return pulumi.get(self, "sync_direction")

    @property
    @pulumi.getter(name="syncScope")
    def sync_scope(self) -> str:
        """
        `REPO` or `NAMESPACE`,the scope that the synchronization rule applies.
        """
        return pulumi.get(self, "sync_scope")

    @property
    @pulumi.getter(name="syncTrigger")
    def sync_trigger(self) -> str:
        """
        `PASSIVE` or `INITIATIVE`, the policy configured to trigger the synchronization rule.
        """
        return pulumi.get(self, "sync_trigger")

    @property
    @pulumi.getter(name="tagFilter")
    def tag_filter(self) -> str:
        """
        The regular expression used to filter image tags for synchronization in the source repository.
        """
        return pulumi.get(self, "tag_filter")

    @property
    @pulumi.getter(name="targetInstanceId")
    def target_instance_id(self) -> str:
        """
        ID of Container Registry Enterprise Edition target instance.
        """
        return pulumi.get(self, "target_instance_id")

    @property
    @pulumi.getter(name="targetNamespaceName")
    def target_namespace_name(self) -> str:
        """
        Name of Container Registry Enterprise Edition target namespace.
        """
        return pulumi.get(self, "target_namespace_name")

    @property
    @pulumi.getter(name="targetRegionId")
    def target_region_id(self) -> str:
        """
        Region of Container Registry Enterprise Edition target instance.
        """
        return pulumi.get(self, "target_region_id")

    @property
    @pulumi.getter(name="targetRepoName")
    def target_repo_name(self) -> str:
        """
        Name of Container Registry Enterprise Edition target repo.
        """
        return pulumi.get(self, "target_repo_name")


@pulumi.output_type
class GetServerlessKubernetesClustersClusterResult(dict):
    def __init__(__self__, *,
                 connections: 'outputs.GetServerlessKubernetesClustersClusterConnectionsResult',
                 deletion_protection: bool,
                 endpoint_public_access_enabled: bool,
                 id: str,
                 name: str,
                 nat_gateway_id: str,
                 security_group_id: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 vswitch_id: str):
        """
        :param 'GetServerlessKubernetesClustersClusterConnectionsArgs' connections: Map of serverless cluster connection information. It contains several attributes to `Block Connections`.
        :param bool deletion_protection: Whether the cluster support delete protection.
        :param str id: The ID of the container cluster.
        :param str name: The name of the container cluster.
        :param str nat_gateway_id: The ID of nat gateway used to launch kubernetes cluster.
        :param str security_group_id: The ID of security group where the current cluster  is located.
        :param str vpc_id: The ID of VPC where the current cluster is located.
        :param str vswitch_id: The ID of VSwitch where the current cluster is located.
        """
        GetServerlessKubernetesClustersClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connections=connections,
            deletion_protection=deletion_protection,
            endpoint_public_access_enabled=endpoint_public_access_enabled,
            id=id,
            name=name,
            nat_gateway_id=nat_gateway_id,
            security_group_id=security_group_id,
            tags=tags,
            vpc_id=vpc_id,
            vswitch_id=vswitch_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connections: Optional['outputs.GetServerlessKubernetesClustersClusterConnectionsResult'] = None,
             deletion_protection: Optional[bool] = None,
             endpoint_public_access_enabled: Optional[bool] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             nat_gateway_id: Optional[str] = None,
             security_group_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             vpc_id: Optional[str] = None,
             vswitch_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connections is None:
            raise TypeError("Missing 'connections' argument")
        if deletion_protection is None and 'deletionProtection' in kwargs:
            deletion_protection = kwargs['deletionProtection']
        if deletion_protection is None:
            raise TypeError("Missing 'deletion_protection' argument")
        if endpoint_public_access_enabled is None and 'endpointPublicAccessEnabled' in kwargs:
            endpoint_public_access_enabled = kwargs['endpointPublicAccessEnabled']
        if endpoint_public_access_enabled is None:
            raise TypeError("Missing 'endpoint_public_access_enabled' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if nat_gateway_id is None and 'natGatewayId' in kwargs:
            nat_gateway_id = kwargs['natGatewayId']
        if nat_gateway_id is None:
            raise TypeError("Missing 'nat_gateway_id' argument")
        if security_group_id is None and 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']
        if security_group_id is None:
            raise TypeError("Missing 'security_group_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if vswitch_id is None and 'vswitchId' in kwargs:
            vswitch_id = kwargs['vswitchId']
        if vswitch_id is None:
            raise TypeError("Missing 'vswitch_id' argument")

        _setter("connections", connections)
        _setter("deletion_protection", deletion_protection)
        _setter("endpoint_public_access_enabled", endpoint_public_access_enabled)
        _setter("id", id)
        _setter("name", name)
        _setter("nat_gateway_id", nat_gateway_id)
        _setter("security_group_id", security_group_id)
        _setter("tags", tags)
        _setter("vpc_id", vpc_id)
        _setter("vswitch_id", vswitch_id)

    @property
    @pulumi.getter
    def connections(self) -> 'outputs.GetServerlessKubernetesClustersClusterConnectionsResult':
        """
        Map of serverless cluster connection information. It contains several attributes to `Block Connections`.
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> bool:
        """
        Whether the cluster support delete protection.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter(name="endpointPublicAccessEnabled")
    def endpoint_public_access_enabled(self) -> bool:
        return pulumi.get(self, "endpoint_public_access_enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the container cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the container cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> str:
        """
        The ID of nat gateway used to launch kubernetes cluster.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The ID of security group where the current cluster  is located.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of VPC where the current cluster is located.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of VSwitch where the current cluster is located.
        """
        return pulumi.get(self, "vswitch_id")


@pulumi.output_type
class GetServerlessKubernetesClustersClusterConnectionsResult(dict):
    def __init__(__self__, *,
                 api_server_internet: str,
                 api_server_intranet: str,
                 master_public_ip: str):
        """
        :param str api_server_internet: API Server Internet endpoint.
        :param str api_server_intranet: API Server Intranet endpoint.
        :param str master_public_ip: Master node SSH IP address.
        """
        GetServerlessKubernetesClustersClusterConnectionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_server_internet=api_server_internet,
            api_server_intranet=api_server_intranet,
            master_public_ip=master_public_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_server_internet: Optional[str] = None,
             api_server_intranet: Optional[str] = None,
             master_public_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_server_internet is None and 'apiServerInternet' in kwargs:
            api_server_internet = kwargs['apiServerInternet']
        if api_server_internet is None:
            raise TypeError("Missing 'api_server_internet' argument")
        if api_server_intranet is None and 'apiServerIntranet' in kwargs:
            api_server_intranet = kwargs['apiServerIntranet']
        if api_server_intranet is None:
            raise TypeError("Missing 'api_server_intranet' argument")
        if master_public_ip is None and 'masterPublicIp' in kwargs:
            master_public_ip = kwargs['masterPublicIp']
        if master_public_ip is None:
            raise TypeError("Missing 'master_public_ip' argument")

        _setter("api_server_internet", api_server_internet)
        _setter("api_server_intranet", api_server_intranet)
        _setter("master_public_ip", master_public_ip)

    @property
    @pulumi.getter(name="apiServerInternet")
    def api_server_internet(self) -> str:
        """
        API Server Internet endpoint.
        """
        return pulumi.get(self, "api_server_internet")

    @property
    @pulumi.getter(name="apiServerIntranet")
    def api_server_intranet(self) -> str:
        """
        API Server Intranet endpoint.
        """
        return pulumi.get(self, "api_server_intranet")

    @property
    @pulumi.getter(name="masterPublicIp")
    def master_public_ip(self) -> str:
        """
        Master node SSH IP address.
        """
        return pulumi.get(self, "master_public_ip")


