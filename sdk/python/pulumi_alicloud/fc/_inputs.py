# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AliasRoutingConfigArgs',
    'AliasRoutingConfigArgsDict',
    'CustomDomainCertConfigArgs',
    'CustomDomainCertConfigArgsDict',
    'CustomDomainRouteConfigArgs',
    'CustomDomainRouteConfigArgsDict',
    'FunctionAsyncInvokeConfigDestinationConfigArgs',
    'FunctionAsyncInvokeConfigDestinationConfigArgsDict',
    'FunctionAsyncInvokeConfigDestinationConfigOnFailureArgs',
    'FunctionAsyncInvokeConfigDestinationConfigOnFailureArgsDict',
    'FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgs',
    'FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgsDict',
    'FunctionCustomContainerConfigArgs',
    'FunctionCustomContainerConfigArgsDict',
    'ServiceLogConfigArgs',
    'ServiceLogConfigArgsDict',
    'ServiceNasConfigArgs',
    'ServiceNasConfigArgsDict',
    'ServiceNasConfigMountPointArgs',
    'ServiceNasConfigMountPointArgsDict',
    'ServiceTracingConfigArgs',
    'ServiceTracingConfigArgsDict',
    'ServiceVpcConfigArgs',
    'ServiceVpcConfigArgsDict',
    'V2FunctionCodeArgs',
    'V2FunctionCodeArgsDict',
    'V2FunctionCustomContainerConfigArgs',
    'V2FunctionCustomContainerConfigArgsDict',
    'V2FunctionCustomDnsArgs',
    'V2FunctionCustomDnsArgsDict',
    'V2FunctionCustomDnsDnsOptionArgs',
    'V2FunctionCustomDnsDnsOptionArgsDict',
    'V2FunctionCustomHealthCheckConfigArgs',
    'V2FunctionCustomHealthCheckConfigArgsDict',
    'V2FunctionCustomRuntimeConfigArgs',
    'V2FunctionCustomRuntimeConfigArgsDict',
    'V2FunctionInstanceLifecycleConfigArgs',
    'V2FunctionInstanceLifecycleConfigArgsDict',
    'V2FunctionInstanceLifecycleConfigPreFreezeArgs',
    'V2FunctionInstanceLifecycleConfigPreFreezeArgsDict',
    'V2FunctionInstanceLifecycleConfigPreStopArgs',
    'V2FunctionInstanceLifecycleConfigPreStopArgsDict',
    'V3AsyncInvokeConfigDestinationConfigArgs',
    'V3AsyncInvokeConfigDestinationConfigArgsDict',
    'V3AsyncInvokeConfigDestinationConfigOnFailureArgs',
    'V3AsyncInvokeConfigDestinationConfigOnFailureArgsDict',
    'V3AsyncInvokeConfigDestinationConfigOnSuccessArgs',
    'V3AsyncInvokeConfigDestinationConfigOnSuccessArgsDict',
    'V3CustomDomainAuthConfigArgs',
    'V3CustomDomainAuthConfigArgsDict',
    'V3CustomDomainCertConfigArgs',
    'V3CustomDomainCertConfigArgsDict',
    'V3CustomDomainRouteConfigArgs',
    'V3CustomDomainRouteConfigArgsDict',
    'V3CustomDomainRouteConfigRouteArgs',
    'V3CustomDomainRouteConfigRouteArgsDict',
    'V3CustomDomainRouteConfigRouteRewriteConfigArgs',
    'V3CustomDomainRouteConfigRouteRewriteConfigArgsDict',
    'V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgs',
    'V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgsDict',
    'V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgs',
    'V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgsDict',
    'V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgs',
    'V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgsDict',
    'V3CustomDomainTlsConfigArgs',
    'V3CustomDomainTlsConfigArgsDict',
    'V3CustomDomainWafConfigArgs',
    'V3CustomDomainWafConfigArgsDict',
    'V3FunctionCodeArgs',
    'V3FunctionCodeArgsDict',
    'V3FunctionCustomContainerConfigArgs',
    'V3FunctionCustomContainerConfigArgsDict',
    'V3FunctionCustomContainerConfigAccelerationInfoArgs',
    'V3FunctionCustomContainerConfigAccelerationInfoArgsDict',
    'V3FunctionCustomContainerConfigHealthCheckConfigArgs',
    'V3FunctionCustomContainerConfigHealthCheckConfigArgsDict',
    'V3FunctionCustomDnsArgs',
    'V3FunctionCustomDnsArgsDict',
    'V3FunctionCustomDnsDnsOptionArgs',
    'V3FunctionCustomDnsDnsOptionArgsDict',
    'V3FunctionCustomRuntimeConfigArgs',
    'V3FunctionCustomRuntimeConfigArgsDict',
    'V3FunctionCustomRuntimeConfigHealthCheckConfigArgs',
    'V3FunctionCustomRuntimeConfigHealthCheckConfigArgsDict',
    'V3FunctionGpuConfigArgs',
    'V3FunctionGpuConfigArgsDict',
    'V3FunctionInstanceLifecycleConfigArgs',
    'V3FunctionInstanceLifecycleConfigArgsDict',
    'V3FunctionInstanceLifecycleConfigInitializerArgs',
    'V3FunctionInstanceLifecycleConfigInitializerArgsDict',
    'V3FunctionInstanceLifecycleConfigPreStopArgs',
    'V3FunctionInstanceLifecycleConfigPreStopArgsDict',
    'V3FunctionLogConfigArgs',
    'V3FunctionLogConfigArgsDict',
    'V3FunctionNasConfigArgs',
    'V3FunctionNasConfigArgsDict',
    'V3FunctionNasConfigMountPointArgs',
    'V3FunctionNasConfigMountPointArgsDict',
    'V3FunctionOssMountConfigArgs',
    'V3FunctionOssMountConfigArgsDict',
    'V3FunctionOssMountConfigMountPointArgs',
    'V3FunctionOssMountConfigMountPointArgsDict',
    'V3FunctionTracingConfigArgs',
    'V3FunctionTracingConfigArgsDict',
    'V3FunctionVpcConfigArgs',
    'V3FunctionVpcConfigArgsDict',
    'V3LayerVersionCodeArgs',
    'V3LayerVersionCodeArgsDict',
    'V3ProvisionConfigScheduledActionArgs',
    'V3ProvisionConfigScheduledActionArgsDict',
    'V3ProvisionConfigTargetTrackingPolicyArgs',
    'V3ProvisionConfigTargetTrackingPolicyArgsDict',
    'V3TriggerHttpTriggerArgs',
    'V3TriggerHttpTriggerArgsDict',
]

MYPY = False

if not MYPY:
    class AliasRoutingConfigArgsDict(TypedDict):
        additional_version_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[float]]]]
        """
        A map that defines the proportion of events that should be sent to different versions of a Function Compute service.
        """
elif False:
    AliasRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] additional_version_weights: A map that defines the proportion of events that should be sent to different versions of a Function Compute service.
        """
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A map that defines the proportion of events that should be sent to different versions of a Function Compute service.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class CustomDomainCertConfigArgsDict(TypedDict):
        cert_name: pulumi.Input[str]
        """
        The name of the certificate, used to distinguish different certificates.
        """
        certificate: pulumi.Input[str]
        """
        Certificate data of the HTTPS certificates, follow the 'pem' format.
        """
        private_key: pulumi.Input[str]
        """
        Private key of the HTTPS certificates, follow the 'pem' format.
        """
elif False:
    CustomDomainCertConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainCertConfigArgs:
    def __init__(__self__, *,
                 cert_name: pulumi.Input[str],
                 certificate: pulumi.Input[str],
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cert_name: The name of the certificate, used to distinguish different certificates.
        :param pulumi.Input[str] certificate: Certificate data of the HTTPS certificates, follow the 'pem' format.
        :param pulumi.Input[str] private_key: Private key of the HTTPS certificates, follow the 'pem' format.
        """
        pulumi.set(__self__, "cert_name", cert_name)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certName")
    def cert_name(self) -> pulumi.Input[str]:
        """
        The name of the certificate, used to distinguish different certificates.
        """
        return pulumi.get(self, "cert_name")

    @cert_name.setter
    def cert_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cert_name", value)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        Certificate data of the HTTPS certificates, follow the 'pem' format.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private key of the HTTPS certificates, follow the 'pem' format.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class CustomDomainRouteConfigArgsDict(TypedDict):
        function_name: pulumi.Input[str]
        """
        The name of the Function Compute function that requests are routed to.
        """
        path: pulumi.Input[str]
        """
        The path that requests are routed from.
        """
        service_name: pulumi.Input[str]
        """
        The name of the Function Compute service that requests are routed to.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
        """
        qualifier: NotRequired[pulumi.Input[str]]
        """
        The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service. For detail information about version and alias, please refer to the [developer guide](https://www.alibabacloud.com/help/doc-detail/96464.htm).
        """
elif False:
    CustomDomainRouteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainRouteConfigArgs:
    def __init__(__self__, *,
                 function_name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 service_name: pulumi.Input[str],
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 qualifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] function_name: The name of the Function Compute function that requests are routed to.
        :param pulumi.Input[str] path: The path that requests are routed from.
        :param pulumi.Input[str] service_name: The name of the Function Compute service that requests are routed to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
        :param pulumi.Input[str] qualifier: The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service. For detail information about version and alias, please refer to the [developer guide](https://www.alibabacloud.com/help/doc-detail/96464.htm).
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service_name", service_name)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> pulumi.Input[str]:
        """
        The name of the Function Compute function that requests are routed to.
        """
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path that requests are routed from.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        The name of the Function Compute service that requests are routed to.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The requests of the specified HTTP methos are routed from. Valid method: GET, POST, DELETE, HEAD, PUT and PATCH. For example, "GET, HEAD" methods indicate that only requests from GET and HEAD methods are routed.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def qualifier(self) -> Optional[pulumi.Input[str]]:
        """
        The version or alias of the Function Compute service that requests are routed to. For example, qualifier v1 indicates that the requests are routed to the version 1 Function Compute service. For detail information about version and alias, please refer to the [developer guide](https://www.alibabacloud.com/help/doc-detail/96464.htm).
        """
        return pulumi.get(self, "qualifier")

    @qualifier.setter
    def qualifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "qualifier", value)


if not MYPY:
    class FunctionAsyncInvokeConfigDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnFailureArgsDict']]
        """
        Configuration block with destination configuration for failed asynchronous invocations. See `on_failure` below.
        """
        on_success: NotRequired[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgsDict']]
        """
        Configuration block with destination configuration for successful asynchronous invocations. See `on_success` below.
        """
elif False:
    FunctionAsyncInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAsyncInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        """
        :param pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnFailureArgs'] on_failure: Configuration block with destination configuration for failed asynchronous invocations. See `on_failure` below.
        :param pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgs'] on_success: Configuration block with destination configuration for successful asynchronous invocations. See `on_success` below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnFailureArgs']]:
        """
        Configuration block with destination configuration for failed asynchronous invocations. See `on_failure` below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgs']]:
        """
        Configuration block with destination configuration for successful asynchronous invocations. See `on_success` below.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class FunctionAsyncInvokeConfigDestinationConfigOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
        """
elif False:
    FunctionAsyncInvokeConfigDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAsyncInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
        """
elif False:
    FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAsyncInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Alicloud Resource Name (ARN) of the destination resource. See the [Developer Guide](https://www.alibabacloud.com/help/doc-detail/181866.htm) for acceptable resource types and associated RAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionCustomContainerConfigArgsDict(TypedDict):
        image: pulumi.Input[str]
        """
        The container image address.
        """
        args: NotRequired[pulumi.Input[str]]
        """
        The args field specifies the arguments passed to the command.
        """
        command: NotRequired[pulumi.Input[str]]
        """
        The entry point of the container, which specifies the actual command run by the container.
        """
elif False:
    FunctionCustomContainerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCustomContainerConfigArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 args: Optional[pulumi.Input[str]] = None,
                 command: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image: The container image address.
        :param pulumi.Input[str] args: The args field specifies the arguments passed to the command.
        :param pulumi.Input[str] command: The entry point of the container, which specifies the actual command run by the container.
        """
        pulumi.set(__self__, "image", image)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        The container image address.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[str]]:
        """
        The args field specifies the arguments passed to the command.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        The entry point of the container, which specifies the actual command run by the container.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class ServiceLogConfigArgsDict(TypedDict):
        logstore: pulumi.Input[str]
        """
        The log store name of Alicloud Simple Log Service.
        """
        project: pulumi.Input[str]
        """
        The project name of the Alicloud Simple Log Service.
        """
        enable_instance_metrics: NotRequired[pulumi.Input[bool]]
        """
        Enable instance level metrics.
        """
        enable_request_metrics: NotRequired[pulumi.Input[bool]]
        """
        Enable request level metrics.
        """
elif False:
    ServiceLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceLogConfigArgs:
    def __init__(__self__, *,
                 logstore: pulumi.Input[str],
                 project: pulumi.Input[str],
                 enable_instance_metrics: Optional[pulumi.Input[bool]] = None,
                 enable_request_metrics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] logstore: The log store name of Alicloud Simple Log Service.
        :param pulumi.Input[str] project: The project name of the Alicloud Simple Log Service.
        :param pulumi.Input[bool] enable_instance_metrics: Enable instance level metrics.
        :param pulumi.Input[bool] enable_request_metrics: Enable request level metrics.
        """
        pulumi.set(__self__, "logstore", logstore)
        pulumi.set(__self__, "project", project)
        if enable_instance_metrics is not None:
            pulumi.set(__self__, "enable_instance_metrics", enable_instance_metrics)
        if enable_request_metrics is not None:
            pulumi.set(__self__, "enable_request_metrics", enable_request_metrics)

    @property
    @pulumi.getter
    def logstore(self) -> pulumi.Input[str]:
        """
        The log store name of Alicloud Simple Log Service.
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: pulumi.Input[str]):
        pulumi.set(self, "logstore", value)

    @property
    @pulumi.getter
    def project(self) -> pulumi.Input[str]:
        """
        The project name of the Alicloud Simple Log Service.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[str]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="enableInstanceMetrics")
    def enable_instance_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable instance level metrics.
        """
        return pulumi.get(self, "enable_instance_metrics")

    @enable_instance_metrics.setter
    def enable_instance_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_instance_metrics", value)

    @property
    @pulumi.getter(name="enableRequestMetrics")
    def enable_request_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable request level metrics.
        """
        return pulumi.get(self, "enable_request_metrics")

    @enable_request_metrics.setter
    def enable_request_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_request_metrics", value)


if not MYPY:
    class ServiceNasConfigArgsDict(TypedDict):
        group_id: pulumi.Input[int]
        """
        The group id of your NAS file system.
        """
        mount_points: pulumi.Input[Sequence[pulumi.Input['ServiceNasConfigMountPointArgsDict']]]
        """
        Config the NAS mount points.See `mount_points` below.
        """
        user_id: pulumi.Input[int]
        """
        The user id of your NAS file system.
        """
elif False:
    ServiceNasConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNasConfigArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[int],
                 mount_points: pulumi.Input[Sequence[pulumi.Input['ServiceNasConfigMountPointArgs']]],
                 user_id: pulumi.Input[int]):
        """
        :param pulumi.Input[int] group_id: The group id of your NAS file system.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceNasConfigMountPointArgs']]] mount_points: Config the NAS mount points.See `mount_points` below.
        :param pulumi.Input[int] user_id: The user id of your NAS file system.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "mount_points", mount_points)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[int]:
        """
        The group id of your NAS file system.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="mountPoints")
    def mount_points(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceNasConfigMountPointArgs']]]:
        """
        Config the NAS mount points.See `mount_points` below.
        """
        return pulumi.get(self, "mount_points")

    @mount_points.setter
    def mount_points(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceNasConfigMountPointArgs']]]):
        pulumi.set(self, "mount_points", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[int]:
        """
        The user id of your NAS file system.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ServiceNasConfigMountPointArgsDict(TypedDict):
        mount_dir: pulumi.Input[str]
        """
        The local address where to mount your remote NAS directory.
        """
        server_addr: pulumi.Input[str]
        """
        The address of the remote NAS directory.
        """
elif False:
    ServiceNasConfigMountPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNasConfigMountPointArgs:
    def __init__(__self__, *,
                 mount_dir: pulumi.Input[str],
                 server_addr: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mount_dir: The local address where to mount your remote NAS directory.
        :param pulumi.Input[str] server_addr: The address of the remote NAS directory.
        """
        pulumi.set(__self__, "mount_dir", mount_dir)
        pulumi.set(__self__, "server_addr", server_addr)

    @property
    @pulumi.getter(name="mountDir")
    def mount_dir(self) -> pulumi.Input[str]:
        """
        The local address where to mount your remote NAS directory.
        """
        return pulumi.get(self, "mount_dir")

    @mount_dir.setter
    def mount_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_dir", value)

    @property
    @pulumi.getter(name="serverAddr")
    def server_addr(self) -> pulumi.Input[str]:
        """
        The address of the remote NAS directory.
        """
        return pulumi.get(self, "server_addr")

    @server_addr.setter
    def server_addr(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_addr", value)


if not MYPY:
    class ServiceTracingConfigArgsDict(TypedDict):
        params: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Tracing parameters, which type is map[string]string. When the protocol type is Jaeger, the key is "endpoint" and the value is your tracing intranet endpoint. For example endpoint: http://tracing-analysis-dc-hz.aliyuncs.com/adapt_xxx/api/traces.
        """
        type: pulumi.Input[str]
        """
        Tracing protocol type. Currently, only Jaeger is supported.
        """
elif False:
    ServiceTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTracingConfigArgs:
    def __init__(__self__, *,
                 params: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] params: Tracing parameters, which type is map[string]string. When the protocol type is Jaeger, the key is "endpoint" and the value is your tracing intranet endpoint. For example endpoint: http://tracing-analysis-dc-hz.aliyuncs.com/adapt_xxx/api/traces.
        :param pulumi.Input[str] type: Tracing protocol type. Currently, only Jaeger is supported.
        """
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def params(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Tracing parameters, which type is map[string]string. When the protocol type is Jaeger, the key is "endpoint" and the value is your tracing intranet endpoint. For example endpoint: http://tracing-analysis-dc-hz.aliyuncs.com/adapt_xxx/api/traces.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Tracing protocol type. Currently, only Jaeger is supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceVpcConfigArgsDict(TypedDict):
        security_group_id: pulumi.Input[str]
        """
        A security group ID associated with the Function Compute Service.
        """
        vswitch_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of vswitch IDs associated with the Function Compute Service.
        """
        vpc_id: NotRequired[pulumi.Input[str]]
        """
        A vpc ID associated with the Function Compute Service.
        """
elif False:
    ServiceVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_id: pulumi.Input[str],
                 vswitch_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] security_group_id: A security group ID associated with the Function Compute Service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vswitch_ids: A list of vswitch IDs associated with the Function Compute Service.
        :param pulumi.Input[str] vpc_id: A vpc ID associated with the Function Compute Service.
        """
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "vswitch_ids", vswitch_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> pulumi.Input[str]:
        """
        A security group ID associated with the Function Compute Service.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="vswitchIds")
    def vswitch_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of vswitch IDs associated with the Function Compute Service.
        """
        return pulumi.get(self, "vswitch_ids")

    @vswitch_ids.setter
    def vswitch_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "vswitch_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        A vpc ID associated with the Function Compute Service.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class V2FunctionCodeArgsDict(TypedDict):
        oss_bucket_name: NotRequired[pulumi.Input[str]]
        """
        The OSS bucket name of the function code package.
        """
        oss_object_name: NotRequired[pulumi.Input[str]]
        """
        The OSS object name of the function code package.
        """
        zip_file: NotRequired[pulumi.Input[str]]
        """
        Upload the base64 encoding of the code zip package directly in the request body.
        """
elif False:
    V2FunctionCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionCodeArgs:
    def __init__(__self__, *,
                 oss_bucket_name: Optional[pulumi.Input[str]] = None,
                 oss_object_name: Optional[pulumi.Input[str]] = None,
                 zip_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] oss_bucket_name: The OSS bucket name of the function code package.
        :param pulumi.Input[str] oss_object_name: The OSS object name of the function code package.
        :param pulumi.Input[str] zip_file: Upload the base64 encoding of the code zip package directly in the request body.
        """
        if oss_bucket_name is not None:
            pulumi.set(__self__, "oss_bucket_name", oss_bucket_name)
        if oss_object_name is not None:
            pulumi.set(__self__, "oss_object_name", oss_object_name)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @property
    @pulumi.getter(name="ossBucketName")
    def oss_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The OSS bucket name of the function code package.
        """
        return pulumi.get(self, "oss_bucket_name")

    @oss_bucket_name.setter
    def oss_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oss_bucket_name", value)

    @property
    @pulumi.getter(name="ossObjectName")
    def oss_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        The OSS object name of the function code package.
        """
        return pulumi.get(self, "oss_object_name")

    @oss_object_name.setter
    def oss_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oss_object_name", value)

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[str]]:
        """
        Upload the base64 encoding of the code zip package directly in the request body.
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zip_file", value)


if not MYPY:
    class V2FunctionCustomContainerConfigArgsDict(TypedDict):
        acceleration_type: NotRequired[pulumi.Input[str]]
        """
        Image acceleration type. The value Default is to enable acceleration and None is to disable acceleration.
        """
        args: NotRequired[pulumi.Input[str]]
        """
        Container startup parameters.
        """
        command: NotRequired[pulumi.Input[str]]
        """
        Container start command, equivalent to Docker ENTRYPOINT.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Container Image address. Example value: registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1.
        """
        web_server_mode: NotRequired[pulumi.Input[bool]]
        """
        Whether the image is run in Web Server mode. The value of true needs to implement the Web Server in the container image to listen to the port and process the request. The value of false needs to actively exit the process after the container runs, and the ExitCode needs to be 0. Default true.
        """
elif False:
    V2FunctionCustomContainerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionCustomContainerConfigArgs:
    def __init__(__self__, *,
                 acceleration_type: Optional[pulumi.Input[str]] = None,
                 args: Optional[pulumi.Input[str]] = None,
                 command: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 web_server_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] acceleration_type: Image acceleration type. The value Default is to enable acceleration and None is to disable acceleration.
        :param pulumi.Input[str] args: Container startup parameters.
        :param pulumi.Input[str] command: Container start command, equivalent to Docker ENTRYPOINT.
        :param pulumi.Input[str] image: Container Image address. Example value: registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1.
        :param pulumi.Input[bool] web_server_mode: Whether the image is run in Web Server mode. The value of true needs to implement the Web Server in the container image to listen to the port and process the request. The value of false needs to actively exit the process after the container runs, and the ExitCode needs to be 0. Default true.
        """
        if acceleration_type is not None:
            pulumi.set(__self__, "acceleration_type", acceleration_type)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if web_server_mode is not None:
            pulumi.set(__self__, "web_server_mode", web_server_mode)

    @property
    @pulumi.getter(name="accelerationType")
    def acceleration_type(self) -> Optional[pulumi.Input[str]]:
        """
        Image acceleration type. The value Default is to enable acceleration and None is to disable acceleration.
        """
        return pulumi.get(self, "acceleration_type")

    @acceleration_type.setter
    def acceleration_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acceleration_type", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[str]]:
        """
        Container startup parameters.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        Container start command, equivalent to Docker ENTRYPOINT.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container Image address. Example value: registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="webServerMode")
    def web_server_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the image is run in Web Server mode. The value of true needs to implement the Web Server in the container image to listen to the port and process the request. The value of false needs to actively exit the process after the container runs, and the ExitCode needs to be 0. Default true.
        """
        return pulumi.get(self, "web_server_mode")

    @web_server_mode.setter
    def web_server_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_server_mode", value)


if not MYPY:
    class V2FunctionCustomDnsArgsDict(TypedDict):
        dns_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['V2FunctionCustomDnsDnsOptionArgsDict']]]]
        """
        DNS resolver configuration parameter list. See `dns_options` below.
        """
        name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP addresses of DNS servers.
        """
        searches: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of DNS search domains.
        """
elif False:
    V2FunctionCustomDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionCustomDnsArgs:
    def __init__(__self__, *,
                 dns_options: Optional[pulumi.Input[Sequence[pulumi.Input['V2FunctionCustomDnsDnsOptionArgs']]]] = None,
                 name_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 searches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['V2FunctionCustomDnsDnsOptionArgs']]] dns_options: DNS resolver configuration parameter list. See `dns_options` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] name_servers: List of IP addresses of DNS servers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] searches: List of DNS search domains.
        """
        if dns_options is not None:
            pulumi.set(__self__, "dns_options", dns_options)
        if name_servers is not None:
            pulumi.set(__self__, "name_servers", name_servers)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter(name="dnsOptions")
    def dns_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V2FunctionCustomDnsDnsOptionArgs']]]]:
        """
        DNS resolver configuration parameter list. See `dns_options` below.
        """
        return pulumi.get(self, "dns_options")

    @dns_options.setter
    def dns_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V2FunctionCustomDnsDnsOptionArgs']]]]):
        pulumi.set(self, "dns_options", value)

    @property
    @pulumi.getter(name="nameServers")
    def name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP addresses of DNS servers.
        """
        return pulumi.get(self, "name_servers")

    @name_servers.setter
    def name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "name_servers", value)

    @property
    @pulumi.getter
    def searches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of DNS search domains.
        """
        return pulumi.get(self, "searches")

    @searches.setter
    def searches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "searches", value)


if not MYPY:
    class V2FunctionCustomDnsDnsOptionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        DNS option name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        DNS option value.
        """
elif False:
    V2FunctionCustomDnsDnsOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionCustomDnsDnsOptionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: DNS option name.
        :param pulumi.Input[str] value: DNS option value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS option name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        DNS option value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class V2FunctionCustomHealthCheckConfigArgsDict(TypedDict):
        failure_threshold: NotRequired[pulumi.Input[int]]
        """
        The threshold for the number of health check failures. The system considers the check failed after the health check fails.
        """
        http_get_url: NotRequired[pulumi.Input[str]]
        """
        Container custom health check URL address.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        """
        Delay from container startup to initiation of health check.
        """
        period_seconds: NotRequired[pulumi.Input[int]]
        """
        Health check cycle.
        """
        success_threshold: NotRequired[pulumi.Input[int]]
        """
        The threshold for the number of successful health checks. After the health check is reached, the system considers the check successful.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Health check timeout.
        """
elif False:
    V2FunctionCustomHealthCheckConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionCustomHealthCheckConfigArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_get_url: Optional[pulumi.Input[str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failure_threshold: The threshold for the number of health check failures. The system considers the check failed after the health check fails.
        :param pulumi.Input[str] http_get_url: Container custom health check URL address.
        :param pulumi.Input[int] initial_delay_seconds: Delay from container startup to initiation of health check.
        :param pulumi.Input[int] period_seconds: Health check cycle.
        :param pulumi.Input[int] success_threshold: The threshold for the number of successful health checks. After the health check is reached, the system considers the check successful.
        :param pulumi.Input[int] timeout_seconds: Health check timeout.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get_url is not None:
            pulumi.set(__self__, "http_get_url", http_get_url)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The threshold for the number of health check failures. The system considers the check failed after the health check fails.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGetUrl")
    def http_get_url(self) -> Optional[pulumi.Input[str]]:
        """
        Container custom health check URL address.
        """
        return pulumi.get(self, "http_get_url")

    @http_get_url.setter
    def http_get_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_get_url", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Delay from container startup to initiation of health check.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Health check cycle.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The threshold for the number of successful health checks. After the health check is reached, the system considers the check successful.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Health check timeout.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class V2FunctionCustomRuntimeConfigArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameters received by the start entry command.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Custom entry commands started by Custom Runtime. When there are multiple commands in the list, they are spliced in sequence.
        """
elif False:
    V2FunctionCustomRuntimeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionCustomRuntimeConfigArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Parameters received by the start entry command.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: List of Custom entry commands started by Custom Runtime. When there are multiple commands in the list, they are spliced in sequence.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters received by the start entry command.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Custom entry commands started by Custom Runtime. When there are multiple commands in the list, they are spliced in sequence.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class V2FunctionInstanceLifecycleConfigArgsDict(TypedDict):
        pre_freeze: NotRequired[pulumi.Input['V2FunctionInstanceLifecycleConfigPreFreezeArgsDict']]
        """
        PreFreeze function configuration. See `pre_freeze` below.
        """
        pre_stop: NotRequired[pulumi.Input['V2FunctionInstanceLifecycleConfigPreStopArgsDict']]
        """
        PreStop function configuration. See `pre_stop` below.
        """
elif False:
    V2FunctionInstanceLifecycleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionInstanceLifecycleConfigArgs:
    def __init__(__self__, *,
                 pre_freeze: Optional[pulumi.Input['V2FunctionInstanceLifecycleConfigPreFreezeArgs']] = None,
                 pre_stop: Optional[pulumi.Input['V2FunctionInstanceLifecycleConfigPreStopArgs']] = None):
        """
        :param pulumi.Input['V2FunctionInstanceLifecycleConfigPreFreezeArgs'] pre_freeze: PreFreeze function configuration. See `pre_freeze` below.
        :param pulumi.Input['V2FunctionInstanceLifecycleConfigPreStopArgs'] pre_stop: PreStop function configuration. See `pre_stop` below.
        """
        if pre_freeze is not None:
            pulumi.set(__self__, "pre_freeze", pre_freeze)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @property
    @pulumi.getter(name="preFreeze")
    def pre_freeze(self) -> Optional[pulumi.Input['V2FunctionInstanceLifecycleConfigPreFreezeArgs']]:
        """
        PreFreeze function configuration. See `pre_freeze` below.
        """
        return pulumi.get(self, "pre_freeze")

    @pre_freeze.setter
    def pre_freeze(self, value: Optional[pulumi.Input['V2FunctionInstanceLifecycleConfigPreFreezeArgs']]):
        pulumi.set(self, "pre_freeze", value)

    @property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['V2FunctionInstanceLifecycleConfigPreStopArgs']]:
        """
        PreStop function configuration. See `pre_stop` below.
        """
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['V2FunctionInstanceLifecycleConfigPreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class V2FunctionInstanceLifecycleConfigPreFreezeArgsDict(TypedDict):
        handler: NotRequired[pulumi.Input[str]]
        """
        entry point of function.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        max running time of function.
        """
elif False:
    V2FunctionInstanceLifecycleConfigPreFreezeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionInstanceLifecycleConfigPreFreezeArgs:
    def __init__(__self__, *,
                 handler: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] handler: entry point of function.
        :param pulumi.Input[int] timeout: max running time of function.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        entry point of function.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        max running time of function.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class V2FunctionInstanceLifecycleConfigPreStopArgsDict(TypedDict):
        handler: NotRequired[pulumi.Input[str]]
        """
        entry point of function.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        max running time of function.
        """
elif False:
    V2FunctionInstanceLifecycleConfigPreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V2FunctionInstanceLifecycleConfigPreStopArgs:
    def __init__(__self__, *,
                 handler: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] handler: entry point of function.
        :param pulumi.Input[int] timeout: max running time of function.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        entry point of function.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        max running time of function.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class V3AsyncInvokeConfigDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnFailureArgsDict']]
        """
        Failed callback target structure See `on_failure` below.
        """
        on_success: NotRequired[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnSuccessArgsDict']]
        """
        Successful callback target structure See `on_success` below.
        """
elif False:
    V3AsyncInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3AsyncInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        """
        :param pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnFailureArgs'] on_failure: Failed callback target structure See `on_failure` below.
        :param pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnSuccessArgs'] on_success: Successful callback target structure See `on_success` below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnFailureArgs']]:
        """
        Failed callback target structure See `on_failure` below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnSuccessArgs']]:
        """
        Successful callback target structure See `on_success` below.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['V3AsyncInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class V3AsyncInvokeConfigDestinationConfigOnFailureArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[str]]
        """
        Asynchronous call target Resource Descriptor
        """
elif False:
    V3AsyncInvokeConfigDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3AsyncInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: Asynchronous call target Resource Descriptor
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        Asynchronous call target Resource Descriptor
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class V3AsyncInvokeConfigDestinationConfigOnSuccessArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[str]]
        """
        Asynchronous call target Resource Descriptor
        """
elif False:
    V3AsyncInvokeConfigDestinationConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3AsyncInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: Asynchronous call target Resource Descriptor
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        Asynchronous call target Resource Descriptor
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class V3CustomDomainAuthConfigArgsDict(TypedDict):
        auth_info: NotRequired[pulumi.Input[str]]
        """
        Authentication Information
        """
        auth_type: NotRequired[pulumi.Input[str]]
        """
        Authentication type. anonymous, function, or jwt.
        """
elif False:
    V3CustomDomainAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainAuthConfigArgs:
    def __init__(__self__, *,
                 auth_info: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_info: Authentication Information
        :param pulumi.Input[str] auth_type: Authentication type. anonymous, function, or jwt.
        """
        if auth_info is not None:
            pulumi.set(__self__, "auth_info", auth_info)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)

    @property
    @pulumi.getter(name="authInfo")
    def auth_info(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication Information
        """
        return pulumi.get(self, "auth_info")

    @auth_info.setter
    def auth_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_info", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication type. anonymous, function, or jwt.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_type", value)


if not MYPY:
    class V3CustomDomainCertConfigArgsDict(TypedDict):
        cert_name: NotRequired[pulumi.Input[str]]
        """
        Certificate Name
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        PEM format certificate
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        Private Key in PEM format
        """
elif False:
    V3CustomDomainCertConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainCertConfigArgs:
    def __init__(__self__, *,
                 cert_name: Optional[pulumi.Input[str]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cert_name: Certificate Name
        :param pulumi.Input[str] certificate: PEM format certificate
        :param pulumi.Input[str] private_key: Private Key in PEM format
        """
        if cert_name is not None:
            pulumi.set(__self__, "cert_name", cert_name)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate Name
        """
        return pulumi.get(self, "cert_name")

    @cert_name.setter
    def cert_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert_name", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        PEM format certificate
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private Key in PEM format
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class V3CustomDomainRouteConfigArgsDict(TypedDict):
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteArgsDict']]]]
        """
        Routing Configuration List See `routes` below.
        """
elif False:
    V3CustomDomainRouteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainRouteConfigArgs:
    def __init__(__self__, *,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteArgs']]] routes: Routing Configuration List See `routes` below.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteArgs']]]]:
        """
        Routing Configuration List See `routes` below.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteArgs']]]]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class V3CustomDomainRouteConfigRouteArgsDict(TypedDict):
        function_name: NotRequired[pulumi.Input[str]]
        """
        Function name
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of supported HTTP methods
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Route matching rule
        """
        qualifier: NotRequired[pulumi.Input[str]]
        """
        Version or Alias
        """
        rewrite_config: NotRequired[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigArgsDict']]
        """
        Override Configuration See `rewrite_config` below.
        """
elif False:
    V3CustomDomainRouteConfigRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainRouteConfigRouteArgs:
    def __init__(__self__, *,
                 function_name: Optional[pulumi.Input[str]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 qualifier: Optional[pulumi.Input[str]] = None,
                 rewrite_config: Optional[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigArgs']] = None):
        """
        :param pulumi.Input[str] function_name: Function name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: List of supported HTTP methods
        :param pulumi.Input[str] path: Route matching rule
        :param pulumi.Input[str] qualifier: Version or Alias
        :param pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigArgs'] rewrite_config: Override Configuration See `rewrite_config` below.
        """
        if function_name is not None:
            pulumi.set(__self__, "function_name", function_name)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)
        if rewrite_config is not None:
            pulumi.set(__self__, "rewrite_config", rewrite_config)

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[pulumi.Input[str]]:
        """
        Function name
        """
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_name", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of supported HTTP methods
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Route matching rule
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def qualifier(self) -> Optional[pulumi.Input[str]]:
        """
        Version or Alias
        """
        return pulumi.get(self, "qualifier")

    @qualifier.setter
    def qualifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "qualifier", value)

    @property
    @pulumi.getter(name="rewriteConfig")
    def rewrite_config(self) -> Optional[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigArgs']]:
        """
        Override Configuration See `rewrite_config` below.
        """
        return pulumi.get(self, "rewrite_config")

    @rewrite_config.setter
    def rewrite_config(self, value: Optional[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigArgs']]):
        pulumi.set(self, "rewrite_config", value)


if not MYPY:
    class V3CustomDomainRouteConfigRouteRewriteConfigArgsDict(TypedDict):
        equal_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgsDict']]]]
        """
        Exact Match Rule List See `equal_rules` below.
        """
        regex_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgsDict']]]]
        """
        Regular match rule list See `regex_rules` below.
        """
        wildcard_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgsDict']]]]
        """
        List of wildcard matching rules See `wildcard_rules` below.
        """
elif False:
    V3CustomDomainRouteConfigRouteRewriteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainRouteConfigRouteRewriteConfigArgs:
    def __init__(__self__, *,
                 equal_rules: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgs']]]] = None,
                 regex_rules: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgs']]]] = None,
                 wildcard_rules: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgs']]] equal_rules: Exact Match Rule List See `equal_rules` below.
        :param pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgs']]] regex_rules: Regular match rule list See `regex_rules` below.
        :param pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgs']]] wildcard_rules: List of wildcard matching rules See `wildcard_rules` below.
        """
        if equal_rules is not None:
            pulumi.set(__self__, "equal_rules", equal_rules)
        if regex_rules is not None:
            pulumi.set(__self__, "regex_rules", regex_rules)
        if wildcard_rules is not None:
            pulumi.set(__self__, "wildcard_rules", wildcard_rules)

    @property
    @pulumi.getter(name="equalRules")
    def equal_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgs']]]]:
        """
        Exact Match Rule List See `equal_rules` below.
        """
        return pulumi.get(self, "equal_rules")

    @equal_rules.setter
    def equal_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgs']]]]):
        pulumi.set(self, "equal_rules", value)

    @property
    @pulumi.getter(name="regexRules")
    def regex_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgs']]]]:
        """
        Regular match rule list See `regex_rules` below.
        """
        return pulumi.get(self, "regex_rules")

    @regex_rules.setter
    def regex_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgs']]]]):
        pulumi.set(self, "regex_rules", value)

    @property
    @pulumi.getter(name="wildcardRules")
    def wildcard_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgs']]]]:
        """
        List of wildcard matching rules See `wildcard_rules` below.
        """
        return pulumi.get(self, "wildcard_rules")

    @wildcard_rules.setter
    def wildcard_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgs']]]]):
        pulumi.set(self, "wildcard_rules", value)


if not MYPY:
    class V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgsDict(TypedDict):
        match: NotRequired[pulumi.Input[str]]
        """
        Matching Rules
        """
        replacement: NotRequired[pulumi.Input[str]]
        """
        Replace Rules
        """
elif False:
    V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainRouteConfigRouteRewriteConfigEqualRuleArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match: Matching Rules
        :param pulumi.Input[str] replacement: Replace Rules
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        """
        Matching Rules
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        """
        Replace Rules
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)


if not MYPY:
    class V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgsDict(TypedDict):
        match: NotRequired[pulumi.Input[str]]
        """
        Matching Rules
        """
        replacement: NotRequired[pulumi.Input[str]]
        """
        Replace Rules
        """
elif False:
    V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainRouteConfigRouteRewriteConfigRegexRuleArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match: Matching Rules
        :param pulumi.Input[str] replacement: Replace Rules
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        """
        Matching Rules
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        """
        Replace Rules
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)


if not MYPY:
    class V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgsDict(TypedDict):
        match: NotRequired[pulumi.Input[str]]
        """
        Matching Rules
        """
        replacement: NotRequired[pulumi.Input[str]]
        """
        Replace Rules
        """
elif False:
    V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainRouteConfigRouteRewriteConfigWildcardRuleArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match: Matching Rules
        :param pulumi.Input[str] replacement: Replace Rules
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        """
        Matching Rules
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        """
        Replace Rules
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)


if not MYPY:
    class V3CustomDomainTlsConfigArgsDict(TypedDict):
        cipher_suites: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of TLS cipher suites
        """
        max_version: NotRequired[pulumi.Input[str]]
        """
        The maximum version of TLS. Enumeration values: TLSv1.3, TLSv1.2, TLSv1.1, TLSv1.0
        """
        min_version: NotRequired[pulumi.Input[str]]
        """
        TLS minimum version number. Enumeration values: TLSv1.3, TLSv1.2, TLSv1.1, TLSv1.0
        """
elif False:
    V3CustomDomainTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainTlsConfigArgs:
    def __init__(__self__, *,
                 cipher_suites: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_version: Optional[pulumi.Input[str]] = None,
                 min_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cipher_suites: List of TLS cipher suites
        :param pulumi.Input[str] max_version: The maximum version of TLS. Enumeration values: TLSv1.3, TLSv1.2, TLSv1.1, TLSv1.0
        :param pulumi.Input[str] min_version: TLS minimum version number. Enumeration values: TLSv1.3, TLSv1.2, TLSv1.1, TLSv1.0
        """
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if max_version is not None:
            pulumi.set(__self__, "max_version", max_version)
        if min_version is not None:
            pulumi.set(__self__, "min_version", min_version)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of TLS cipher suites
        """
        return pulumi.get(self, "cipher_suites")

    @cipher_suites.setter
    def cipher_suites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cipher_suites", value)

    @property
    @pulumi.getter(name="maxVersion")
    def max_version(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum version of TLS. Enumeration values: TLSv1.3, TLSv1.2, TLSv1.1, TLSv1.0
        """
        return pulumi.get(self, "max_version")

    @max_version.setter
    def max_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_version", value)

    @property
    @pulumi.getter(name="minVersion")
    def min_version(self) -> Optional[pulumi.Input[str]]:
        """
        TLS minimum version number. Enumeration values: TLSv1.3, TLSv1.2, TLSv1.1, TLSv1.0
        """
        return pulumi.get(self, "min_version")

    @min_version.setter
    def min_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_version", value)


if not MYPY:
    class V3CustomDomainWafConfigArgsDict(TypedDict):
        enable_waf: NotRequired[pulumi.Input[bool]]
        """
        Enable WAF protection
        """
elif False:
    V3CustomDomainWafConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3CustomDomainWafConfigArgs:
    def __init__(__self__, *,
                 enable_waf: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_waf: Enable WAF protection
        """
        if enable_waf is not None:
            pulumi.set(__self__, "enable_waf", enable_waf)

    @property
    @pulumi.getter(name="enableWaf")
    def enable_waf(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable WAF protection
        """
        return pulumi.get(self, "enable_waf")

    @enable_waf.setter
    def enable_waf(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_waf", value)


if not MYPY:
    class V3FunctionCodeArgsDict(TypedDict):
        checksum: NotRequired[pulumi.Input[str]]
        """
        The CRC-64 value of the function code package.
        """
        oss_bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the OSS Bucket that stores the function code ZIP package.
        """
        oss_object_name: NotRequired[pulumi.Input[str]]
        """
        The name of the OSS Object that stores the function code ZIP package.
        """
        zip_file: NotRequired[pulumi.Input[str]]
        """
        The Base 64 encoding of the function code ZIP package.
        """
elif False:
    V3FunctionCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCodeArgs:
    def __init__(__self__, *,
                 checksum: Optional[pulumi.Input[str]] = None,
                 oss_bucket_name: Optional[pulumi.Input[str]] = None,
                 oss_object_name: Optional[pulumi.Input[str]] = None,
                 zip_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] checksum: The CRC-64 value of the function code package.
        :param pulumi.Input[str] oss_bucket_name: The name of the OSS Bucket that stores the function code ZIP package.
        :param pulumi.Input[str] oss_object_name: The name of the OSS Object that stores the function code ZIP package.
        :param pulumi.Input[str] zip_file: The Base 64 encoding of the function code ZIP package.
        """
        if checksum is not None:
            pulumi.set(__self__, "checksum", checksum)
        if oss_bucket_name is not None:
            pulumi.set(__self__, "oss_bucket_name", oss_bucket_name)
        if oss_object_name is not None:
            pulumi.set(__self__, "oss_object_name", oss_object_name)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @property
    @pulumi.getter
    def checksum(self) -> Optional[pulumi.Input[str]]:
        """
        The CRC-64 value of the function code package.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter(name="ossBucketName")
    def oss_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the OSS Bucket that stores the function code ZIP package.
        """
        return pulumi.get(self, "oss_bucket_name")

    @oss_bucket_name.setter
    def oss_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oss_bucket_name", value)

    @property
    @pulumi.getter(name="ossObjectName")
    def oss_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the OSS Object that stores the function code ZIP package.
        """
        return pulumi.get(self, "oss_object_name")

    @oss_object_name.setter
    def oss_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oss_object_name", value)

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[str]]:
        """
        The Base 64 encoding of the function code ZIP package.
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zip_file", value)


if not MYPY:
    class V3FunctionCustomContainerConfigArgsDict(TypedDict):
        acceleration_info: NotRequired[pulumi.Input['V3FunctionCustomContainerConfigAccelerationInfoArgsDict']]
        """
        (Deprecated) Image Acceleration Information (Obsolete).
        """
        acceleration_type: NotRequired[pulumi.Input[str]]
        """
        Whether to enable Image acceleration. Default: The Default value, indicating that image acceleration is enabled. None: indicates that image acceleration is disabled. (Obsolete).
        """
        acr_instance_id: NotRequired[pulumi.Input[str]]
        """
        ACR Enterprise version Image Repository ID, which must be entered when using ACR Enterprise version image. (Obsolete).
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Container startup parameters.
        """
        entrypoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Container start command.
        """
        health_check_config: NotRequired[pulumi.Input['V3FunctionCustomContainerConfigHealthCheckConfigArgsDict']]
        """
        Function custom health check configuration See `health_check_config` below.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        The container Image address.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The listening port of the HTTP Server when the custom container runs.
        """
        resolved_image_uri: NotRequired[pulumi.Input[str]]
        """
        The actual digest version of the deployed Image. The code version specified by this digest is used when the function starts.
        """
elif False:
    V3FunctionCustomContainerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomContainerConfigArgs:
    def __init__(__self__, *,
                 acceleration_info: Optional[pulumi.Input['V3FunctionCustomContainerConfigAccelerationInfoArgs']] = None,
                 acceleration_type: Optional[pulumi.Input[str]] = None,
                 acr_instance_id: Optional[pulumi.Input[str]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 entrypoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 health_check_config: Optional[pulumi.Input['V3FunctionCustomContainerConfigHealthCheckConfigArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 resolved_image_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['V3FunctionCustomContainerConfigAccelerationInfoArgs'] acceleration_info: (Deprecated) Image Acceleration Information (Obsolete).
        :param pulumi.Input[str] acceleration_type: Whether to enable Image acceleration. Default: The Default value, indicating that image acceleration is enabled. None: indicates that image acceleration is disabled. (Obsolete).
        :param pulumi.Input[str] acr_instance_id: ACR Enterprise version Image Repository ID, which must be entered when using ACR Enterprise version image. (Obsolete).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Container startup parameters.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] entrypoints: Container start command.
        :param pulumi.Input['V3FunctionCustomContainerConfigHealthCheckConfigArgs'] health_check_config: Function custom health check configuration See `health_check_config` below.
        :param pulumi.Input[str] image: The container Image address.
        :param pulumi.Input[int] port: The listening port of the HTTP Server when the custom container runs.
        :param pulumi.Input[str] resolved_image_uri: The actual digest version of the deployed Image. The code version specified by this digest is used when the function starts.
        """
        if acceleration_info is not None:
            warnings.warn("""Field 'acceleration_info' has been deprecated from provider version 1.228.0. Image Acceleration Information (Obsolete)""", DeprecationWarning)
            pulumi.log.warn("""acceleration_info is deprecated: Field 'acceleration_info' has been deprecated from provider version 1.228.0. Image Acceleration Information (Obsolete)""")
        if acceleration_info is not None:
            pulumi.set(__self__, "acceleration_info", acceleration_info)
        if acceleration_type is not None:
            warnings.warn("""Field 'acceleration_type' has been deprecated from provider version 1.228.0. Whether to enable Image acceleration. Default: The Default value, indicating that image acceleration is enabled. None: indicates that image acceleration is disabled. (Obsolete)""", DeprecationWarning)
            pulumi.log.warn("""acceleration_type is deprecated: Field 'acceleration_type' has been deprecated from provider version 1.228.0. Whether to enable Image acceleration. Default: The Default value, indicating that image acceleration is enabled. None: indicates that image acceleration is disabled. (Obsolete)""")
        if acceleration_type is not None:
            pulumi.set(__self__, "acceleration_type", acceleration_type)
        if acr_instance_id is not None:
            warnings.warn("""Field 'acr_instance_id' has been deprecated from provider version 1.228.0. ACR Enterprise version Image Repository ID, which must be entered when using ACR Enterprise version image. (Obsolete)""", DeprecationWarning)
            pulumi.log.warn("""acr_instance_id is deprecated: Field 'acr_instance_id' has been deprecated from provider version 1.228.0. ACR Enterprise version Image Repository ID, which must be entered when using ACR Enterprise version image. (Obsolete)""")
        if acr_instance_id is not None:
            pulumi.set(__self__, "acr_instance_id", acr_instance_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entrypoints is not None:
            pulumi.set(__self__, "entrypoints", entrypoints)
        if health_check_config is not None:
            pulumi.set(__self__, "health_check_config", health_check_config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if resolved_image_uri is not None:
            pulumi.set(__self__, "resolved_image_uri", resolved_image_uri)

    @property
    @pulumi.getter(name="accelerationInfo")
    @_utilities.deprecated("""Field 'acceleration_info' has been deprecated from provider version 1.228.0. Image Acceleration Information (Obsolete)""")
    def acceleration_info(self) -> Optional[pulumi.Input['V3FunctionCustomContainerConfigAccelerationInfoArgs']]:
        """
        (Deprecated) Image Acceleration Information (Obsolete).
        """
        return pulumi.get(self, "acceleration_info")

    @acceleration_info.setter
    def acceleration_info(self, value: Optional[pulumi.Input['V3FunctionCustomContainerConfigAccelerationInfoArgs']]):
        pulumi.set(self, "acceleration_info", value)

    @property
    @pulumi.getter(name="accelerationType")
    @_utilities.deprecated("""Field 'acceleration_type' has been deprecated from provider version 1.228.0. Whether to enable Image acceleration. Default: The Default value, indicating that image acceleration is enabled. None: indicates that image acceleration is disabled. (Obsolete)""")
    def acceleration_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable Image acceleration. Default: The Default value, indicating that image acceleration is enabled. None: indicates that image acceleration is disabled. (Obsolete).
        """
        return pulumi.get(self, "acceleration_type")

    @acceleration_type.setter
    def acceleration_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acceleration_type", value)

    @property
    @pulumi.getter(name="acrInstanceId")
    @_utilities.deprecated("""Field 'acr_instance_id' has been deprecated from provider version 1.228.0. ACR Enterprise version Image Repository ID, which must be entered when using ACR Enterprise version image. (Obsolete)""")
    def acr_instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        ACR Enterprise version Image Repository ID, which must be entered when using ACR Enterprise version image. (Obsolete).
        """
        return pulumi.get(self, "acr_instance_id")

    @acr_instance_id.setter
    def acr_instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acr_instance_id", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container startup parameters.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def entrypoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "entrypoints")

    @entrypoints.setter
    def entrypoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "entrypoints", value)

    @property
    @pulumi.getter(name="healthCheckConfig")
    def health_check_config(self) -> Optional[pulumi.Input['V3FunctionCustomContainerConfigHealthCheckConfigArgs']]:
        """
        Function custom health check configuration See `health_check_config` below.
        """
        return pulumi.get(self, "health_check_config")

    @health_check_config.setter
    def health_check_config(self, value: Optional[pulumi.Input['V3FunctionCustomContainerConfigHealthCheckConfigArgs']]):
        pulumi.set(self, "health_check_config", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The container Image address.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The listening port of the HTTP Server when the custom container runs.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="resolvedImageUri")
    def resolved_image_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The actual digest version of the deployed Image. The code version specified by this digest is used when the function starts.
        """
        return pulumi.get(self, "resolved_image_uri")

    @resolved_image_uri.setter
    def resolved_image_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolved_image_uri", value)


if not MYPY:
    class V3FunctionCustomContainerConfigAccelerationInfoArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        Image Acceleration Status (Deprecated).
        """
elif False:
    V3FunctionCustomContainerConfigAccelerationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomContainerConfigAccelerationInfoArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: Image Acceleration Status (Deprecated).
        """
        if status is not None:
            warnings.warn("""Field 'status' has been deprecated from provider version 1.228.0. Image Acceleration Status (Deprecated)""", DeprecationWarning)
            pulumi.log.warn("""status is deprecated: Field 'status' has been deprecated from provider version 1.228.0. Image Acceleration Status (Deprecated)""")
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Field 'status' has been deprecated from provider version 1.228.0. Image Acceleration Status (Deprecated)""")
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Image Acceleration Status (Deprecated).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class V3FunctionCustomContainerConfigHealthCheckConfigArgsDict(TypedDict):
        failure_threshold: NotRequired[pulumi.Input[int]]
        http_get_url: NotRequired[pulumi.Input[str]]
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        period_seconds: NotRequired[pulumi.Input[int]]
        success_threshold: NotRequired[pulumi.Input[int]]
        timeout_seconds: NotRequired[pulumi.Input[int]]
elif False:
    V3FunctionCustomContainerConfigHealthCheckConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomContainerConfigHealthCheckConfigArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_get_url: Optional[pulumi.Input[str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get_url is not None:
            pulumi.set(__self__, "http_get_url", http_get_url)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGetUrl")
    def http_get_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_get_url")

    @http_get_url.setter
    def http_get_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_get_url", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class V3FunctionCustomDnsArgsDict(TypedDict):
        dns_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3FunctionCustomDnsDnsOptionArgsDict']]]]
        """
        List of configuration items in the resolv.conf file. Each item corresponds to a key-value pair in the format of key:value, where the key is required. See `dns_options` below.
        """
        name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP Address List of DNS servers.
        """
        searches: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        DNS search domain list.
        """
elif False:
    V3FunctionCustomDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomDnsArgs:
    def __init__(__self__, *,
                 dns_options: Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionCustomDnsDnsOptionArgs']]]] = None,
                 name_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 searches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['V3FunctionCustomDnsDnsOptionArgs']]] dns_options: List of configuration items in the resolv.conf file. Each item corresponds to a key-value pair in the format of key:value, where the key is required. See `dns_options` below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] name_servers: IP Address List of DNS servers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] searches: DNS search domain list.
        """
        if dns_options is not None:
            pulumi.set(__self__, "dns_options", dns_options)
        if name_servers is not None:
            pulumi.set(__self__, "name_servers", name_servers)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter(name="dnsOptions")
    def dns_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionCustomDnsDnsOptionArgs']]]]:
        """
        List of configuration items in the resolv.conf file. Each item corresponds to a key-value pair in the format of key:value, where the key is required. See `dns_options` below.
        """
        return pulumi.get(self, "dns_options")

    @dns_options.setter
    def dns_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionCustomDnsDnsOptionArgs']]]]):
        pulumi.set(self, "dns_options", value)

    @property
    @pulumi.getter(name="nameServers")
    def name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP Address List of DNS servers.
        """
        return pulumi.get(self, "name_servers")

    @name_servers.setter
    def name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "name_servers", value)

    @property
    @pulumi.getter
    def searches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS search domain list.
        """
        return pulumi.get(self, "searches")

    @searches.setter
    def searches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "searches", value)


if not MYPY:
    class V3FunctionCustomDnsDnsOptionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration Item Name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration Item Value.
        """
elif False:
    V3FunctionCustomDnsDnsOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomDnsDnsOptionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Configuration Item Name.
        :param pulumi.Input[str] value: Configuration Item Value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration Item Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration Item Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class V3FunctionCustomRuntimeConfigArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Instance startup parameters.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Instance start command.
        """
        health_check_config: NotRequired[pulumi.Input['V3FunctionCustomRuntimeConfigHealthCheckConfigArgsDict']]
        """
        Function custom health check configuration. See `health_check_config` below.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The listening port of the HTTP Server.
        """
elif False:
    V3FunctionCustomRuntimeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomRuntimeConfigArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 health_check_config: Optional[pulumi.Input['V3FunctionCustomRuntimeConfigHealthCheckConfigArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Instance startup parameters.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Instance start command.
        :param pulumi.Input['V3FunctionCustomRuntimeConfigHealthCheckConfigArgs'] health_check_config: Function custom health check configuration. See `health_check_config` below.
        :param pulumi.Input[int] port: The listening port of the HTTP Server.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if health_check_config is not None:
            pulumi.set(__self__, "health_check_config", health_check_config)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Instance startup parameters.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Instance start command.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter(name="healthCheckConfig")
    def health_check_config(self) -> Optional[pulumi.Input['V3FunctionCustomRuntimeConfigHealthCheckConfigArgs']]:
        """
        Function custom health check configuration. See `health_check_config` below.
        """
        return pulumi.get(self, "health_check_config")

    @health_check_config.setter
    def health_check_config(self, value: Optional[pulumi.Input['V3FunctionCustomRuntimeConfigHealthCheckConfigArgs']]):
        pulumi.set(self, "health_check_config", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The listening port of the HTTP Server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class V3FunctionCustomRuntimeConfigHealthCheckConfigArgsDict(TypedDict):
        failure_threshold: NotRequired[pulumi.Input[int]]
        http_get_url: NotRequired[pulumi.Input[str]]
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        period_seconds: NotRequired[pulumi.Input[int]]
        success_threshold: NotRequired[pulumi.Input[int]]
        timeout_seconds: NotRequired[pulumi.Input[int]]
elif False:
    V3FunctionCustomRuntimeConfigHealthCheckConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionCustomRuntimeConfigHealthCheckConfigArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_get_url: Optional[pulumi.Input[str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get_url is not None:
            pulumi.set(__self__, "http_get_url", http_get_url)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGetUrl")
    def http_get_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_get_url")

    @http_get_url.setter
    def http_get_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_get_url", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class V3FunctionGpuConfigArgsDict(TypedDict):
        gpu_memory_size: NotRequired[pulumi.Input[int]]
        """
        GPU memory specification, unit: MB, multiple of 1024MB.
        """
        gpu_type: NotRequired[pulumi.Input[str]]
        """
        GPU card architecture.
        - fc.gpu.tesla indicates the type of the Tesla Architecture Series card of the GPU instance (the same as the NVIDIA T4 card type).
        - fc.gpu.ampere indicates the GPU instance type of Ampere Architecture Series card (same as NVIDIA A10 card type).
        - fc.gpu.ada Indicates the GPU instance Ada Lovelace architecture family card type.
        """
elif False:
    V3FunctionGpuConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionGpuConfigArgs:
    def __init__(__self__, *,
                 gpu_memory_size: Optional[pulumi.Input[int]] = None,
                 gpu_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] gpu_memory_size: GPU memory specification, unit: MB, multiple of 1024MB.
        :param pulumi.Input[str] gpu_type: GPU card architecture.
               - fc.gpu.tesla indicates the type of the Tesla Architecture Series card of the GPU instance (the same as the NVIDIA T4 card type).
               - fc.gpu.ampere indicates the GPU instance type of Ampere Architecture Series card (same as NVIDIA A10 card type).
               - fc.gpu.ada Indicates the GPU instance Ada Lovelace architecture family card type.
        """
        if gpu_memory_size is not None:
            pulumi.set(__self__, "gpu_memory_size", gpu_memory_size)
        if gpu_type is not None:
            pulumi.set(__self__, "gpu_type", gpu_type)

    @property
    @pulumi.getter(name="gpuMemorySize")
    def gpu_memory_size(self) -> Optional[pulumi.Input[int]]:
        """
        GPU memory specification, unit: MB, multiple of 1024MB.
        """
        return pulumi.get(self, "gpu_memory_size")

    @gpu_memory_size.setter
    def gpu_memory_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_memory_size", value)

    @property
    @pulumi.getter(name="gpuType")
    def gpu_type(self) -> Optional[pulumi.Input[str]]:
        """
        GPU card architecture.
        - fc.gpu.tesla indicates the type of the Tesla Architecture Series card of the GPU instance (the same as the NVIDIA T4 card type).
        - fc.gpu.ampere indicates the GPU instance type of Ampere Architecture Series card (same as NVIDIA A10 card type).
        - fc.gpu.ada Indicates the GPU instance Ada Lovelace architecture family card type.
        """
        return pulumi.get(self, "gpu_type")

    @gpu_type.setter
    def gpu_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gpu_type", value)


if not MYPY:
    class V3FunctionInstanceLifecycleConfigArgsDict(TypedDict):
        initializer: NotRequired[pulumi.Input['V3FunctionInstanceLifecycleConfigInitializerArgsDict']]
        """
        Initializer handler method configuration See `initializer` below.
        """
        pre_stop: NotRequired[pulumi.Input['V3FunctionInstanceLifecycleConfigPreStopArgsDict']]
        """
        PreStop handler method configuration See `pre_stop` below.
        """
elif False:
    V3FunctionInstanceLifecycleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionInstanceLifecycleConfigArgs:
    def __init__(__self__, *,
                 initializer: Optional[pulumi.Input['V3FunctionInstanceLifecycleConfigInitializerArgs']] = None,
                 pre_stop: Optional[pulumi.Input['V3FunctionInstanceLifecycleConfigPreStopArgs']] = None):
        """
        :param pulumi.Input['V3FunctionInstanceLifecycleConfigInitializerArgs'] initializer: Initializer handler method configuration See `initializer` below.
        :param pulumi.Input['V3FunctionInstanceLifecycleConfigPreStopArgs'] pre_stop: PreStop handler method configuration See `pre_stop` below.
        """
        if initializer is not None:
            pulumi.set(__self__, "initializer", initializer)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @property
    @pulumi.getter
    def initializer(self) -> Optional[pulumi.Input['V3FunctionInstanceLifecycleConfigInitializerArgs']]:
        """
        Initializer handler method configuration See `initializer` below.
        """
        return pulumi.get(self, "initializer")

    @initializer.setter
    def initializer(self, value: Optional[pulumi.Input['V3FunctionInstanceLifecycleConfigInitializerArgs']]):
        pulumi.set(self, "initializer", value)

    @property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['V3FunctionInstanceLifecycleConfigPreStopArgs']]:
        """
        PreStop handler method configuration See `pre_stop` below.
        """
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['V3FunctionInstanceLifecycleConfigPreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class V3FunctionInstanceLifecycleConfigInitializerArgsDict(TypedDict):
        handler: NotRequired[pulumi.Input[str]]
        """
        Function Handler: the call entry for the function compute system to run your function.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The maximum running time of the function, in seconds.
        """
elif False:
    V3FunctionInstanceLifecycleConfigInitializerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionInstanceLifecycleConfigInitializerArgs:
    def __init__(__self__, *,
                 handler: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] handler: Function Handler: the call entry for the function compute system to run your function.
        :param pulumi.Input[int] timeout: The maximum running time of the function, in seconds.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        Function Handler: the call entry for the function compute system to run your function.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum running time of the function, in seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class V3FunctionInstanceLifecycleConfigPreStopArgsDict(TypedDict):
        handler: NotRequired[pulumi.Input[str]]
        """
        Function Handler: the call entry for the function compute system to run your function.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The maximum running time of the function, in seconds.
        """
elif False:
    V3FunctionInstanceLifecycleConfigPreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionInstanceLifecycleConfigPreStopArgs:
    def __init__(__self__, *,
                 handler: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] handler: Function Handler: the call entry for the function compute system to run your function.
        :param pulumi.Input[int] timeout: The maximum running time of the function, in seconds.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        Function Handler: the call entry for the function compute system to run your function.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum running time of the function, in seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class V3FunctionLogConfigArgsDict(TypedDict):
        enable_instance_metrics: NotRequired[pulumi.Input[bool]]
        """
        After this feature is enabled, you can view core metrics such as instance-level CPU usage, memory usage, instance network status, and the number of requests within an instance. false: The default value, which means that instance-level metrics are turned off. true: indicates that instance-level metrics are enabled.
        """
        enable_request_metrics: NotRequired[pulumi.Input[bool]]
        """
        After this function is enabled, you can view the time and memory consumed by a call to all functions under this service. false: indicates that request-level metrics are turned off. true: The default value, indicating that request-level metrics are enabled.
        """
        log_begin_rule: NotRequired[pulumi.Input[str]]
        """
        Log Line First Matching Rules.
        """
        logstore: NotRequired[pulumi.Input[str]]
        """
        The Logstore name of log service.
        """
        project: NotRequired[pulumi.Input[str]]
        """
        The name of the log service Project.
        """
elif False:
    V3FunctionLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionLogConfigArgs:
    def __init__(__self__, *,
                 enable_instance_metrics: Optional[pulumi.Input[bool]] = None,
                 enable_request_metrics: Optional[pulumi.Input[bool]] = None,
                 log_begin_rule: Optional[pulumi.Input[str]] = None,
                 logstore: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_instance_metrics: After this feature is enabled, you can view core metrics such as instance-level CPU usage, memory usage, instance network status, and the number of requests within an instance. false: The default value, which means that instance-level metrics are turned off. true: indicates that instance-level metrics are enabled.
        :param pulumi.Input[bool] enable_request_metrics: After this function is enabled, you can view the time and memory consumed by a call to all functions under this service. false: indicates that request-level metrics are turned off. true: The default value, indicating that request-level metrics are enabled.
        :param pulumi.Input[str] log_begin_rule: Log Line First Matching Rules.
        :param pulumi.Input[str] logstore: The Logstore name of log service.
        :param pulumi.Input[str] project: The name of the log service Project.
        """
        if enable_instance_metrics is not None:
            pulumi.set(__self__, "enable_instance_metrics", enable_instance_metrics)
        if enable_request_metrics is not None:
            pulumi.set(__self__, "enable_request_metrics", enable_request_metrics)
        if log_begin_rule is not None:
            pulumi.set(__self__, "log_begin_rule", log_begin_rule)
        if logstore is not None:
            pulumi.set(__self__, "logstore", logstore)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter(name="enableInstanceMetrics")
    def enable_instance_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        After this feature is enabled, you can view core metrics such as instance-level CPU usage, memory usage, instance network status, and the number of requests within an instance. false: The default value, which means that instance-level metrics are turned off. true: indicates that instance-level metrics are enabled.
        """
        return pulumi.get(self, "enable_instance_metrics")

    @enable_instance_metrics.setter
    def enable_instance_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_instance_metrics", value)

    @property
    @pulumi.getter(name="enableRequestMetrics")
    def enable_request_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        After this function is enabled, you can view the time and memory consumed by a call to all functions under this service. false: indicates that request-level metrics are turned off. true: The default value, indicating that request-level metrics are enabled.
        """
        return pulumi.get(self, "enable_request_metrics")

    @enable_request_metrics.setter
    def enable_request_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_request_metrics", value)

    @property
    @pulumi.getter(name="logBeginRule")
    def log_begin_rule(self) -> Optional[pulumi.Input[str]]:
        """
        Log Line First Matching Rules.
        """
        return pulumi.get(self, "log_begin_rule")

    @log_begin_rule.setter
    def log_begin_rule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_begin_rule", value)

    @property
    @pulumi.getter
    def logstore(self) -> Optional[pulumi.Input[str]]:
        """
        The Logstore name of log service.
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logstore", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the log service Project.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class V3FunctionNasConfigArgsDict(TypedDict):
        group_id: NotRequired[pulumi.Input[int]]
        """
        Group ID.
        """
        mount_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3FunctionNasConfigMountPointArgsDict']]]]
        """
        Mount point list. See `mount_points` below.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        Account ID.
        """
elif False:
    V3FunctionNasConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionNasConfigArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[int]] = None,
                 mount_points: Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionNasConfigMountPointArgs']]]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] group_id: Group ID.
        :param pulumi.Input[Sequence[pulumi.Input['V3FunctionNasConfigMountPointArgs']]] mount_points: Mount point list. See `mount_points` below.
        :param pulumi.Input[int] user_id: Account ID.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if mount_points is not None:
            pulumi.set(__self__, "mount_points", mount_points)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        Group ID.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="mountPoints")
    def mount_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionNasConfigMountPointArgs']]]]:
        """
        Mount point list. See `mount_points` below.
        """
        return pulumi.get(self, "mount_points")

    @mount_points.setter
    def mount_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionNasConfigMountPointArgs']]]]):
        pulumi.set(self, "mount_points", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        Account ID.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class V3FunctionNasConfigMountPointArgsDict(TypedDict):
        enable_tls: NotRequired[pulumi.Input[bool]]
        """
        Use transport encryption to mount. Note: only general-purpose NAS supports transmission encryption.
        """
        mount_dir: NotRequired[pulumi.Input[str]]
        server_addr: NotRequired[pulumi.Input[str]]
        """
        NAS server address.
        """
elif False:
    V3FunctionNasConfigMountPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionNasConfigMountPointArgs:
    def __init__(__self__, *,
                 enable_tls: Optional[pulumi.Input[bool]] = None,
                 mount_dir: Optional[pulumi.Input[str]] = None,
                 server_addr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_tls: Use transport encryption to mount. Note: only general-purpose NAS supports transmission encryption.
        :param pulumi.Input[str] server_addr: NAS server address.
        """
        if enable_tls is not None:
            pulumi.set(__self__, "enable_tls", enable_tls)
        if mount_dir is not None:
            pulumi.set(__self__, "mount_dir", mount_dir)
        if server_addr is not None:
            pulumi.set(__self__, "server_addr", server_addr)

    @property
    @pulumi.getter(name="enableTls")
    def enable_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Use transport encryption to mount. Note: only general-purpose NAS supports transmission encryption.
        """
        return pulumi.get(self, "enable_tls")

    @enable_tls.setter
    def enable_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_tls", value)

    @property
    @pulumi.getter(name="mountDir")
    def mount_dir(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_dir")

    @mount_dir.setter
    def mount_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_dir", value)

    @property
    @pulumi.getter(name="serverAddr")
    def server_addr(self) -> Optional[pulumi.Input[str]]:
        """
        NAS server address.
        """
        return pulumi.get(self, "server_addr")

    @server_addr.setter
    def server_addr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_addr", value)


if not MYPY:
    class V3FunctionOssMountConfigArgsDict(TypedDict):
        mount_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['V3FunctionOssMountConfigMountPointArgsDict']]]]
        """
        OSS mount point list. See `mount_points` below.
        """
elif False:
    V3FunctionOssMountConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionOssMountConfigArgs:
    def __init__(__self__, *,
                 mount_points: Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionOssMountConfigMountPointArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['V3FunctionOssMountConfigMountPointArgs']]] mount_points: OSS mount point list. See `mount_points` below.
        """
        if mount_points is not None:
            pulumi.set(__self__, "mount_points", mount_points)

    @property
    @pulumi.getter(name="mountPoints")
    def mount_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionOssMountConfigMountPointArgs']]]]:
        """
        OSS mount point list. See `mount_points` below.
        """
        return pulumi.get(self, "mount_points")

    @mount_points.setter
    def mount_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['V3FunctionOssMountConfigMountPointArgs']]]]):
        pulumi.set(self, "mount_points", value)


if not MYPY:
    class V3FunctionOssMountConfigMountPointArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        OSS Bucket name.
        """
        bucket_path: NotRequired[pulumi.Input[str]]
        """
        Path of the mounted OSS Bucket.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        OSS access endpoint.
        """
        mount_dir: NotRequired[pulumi.Input[str]]
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Read-only.
        """
elif False:
    V3FunctionOssMountConfigMountPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionOssMountConfigMountPointArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 bucket_path: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 mount_dir: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket_name: OSS Bucket name.
        :param pulumi.Input[str] bucket_path: Path of the mounted OSS Bucket.
        :param pulumi.Input[str] endpoint: OSS access endpoint.
        :param pulumi.Input[bool] read_only: Read-only.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_path is not None:
            pulumi.set(__self__, "bucket_path", bucket_path)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if mount_dir is not None:
            pulumi.set(__self__, "mount_dir", mount_dir)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        OSS Bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="bucketPath")
    def bucket_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the mounted OSS Bucket.
        """
        return pulumi.get(self, "bucket_path")

    @bucket_path.setter
    def bucket_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_path", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        OSS access endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="mountDir")
    def mount_dir(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_dir")

    @mount_dir.setter
    def mount_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_dir", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Read-only.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class V3FunctionTracingConfigArgsDict(TypedDict):
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tracing parameters.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The tracing protocol type. Currently, only Jaeger is supported.
        """
elif False:
    V3FunctionTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] params: Tracing parameters.
        :param pulumi.Input[str] type: The tracing protocol type. Currently, only Jaeger is supported.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tracing parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The tracing protocol type. Currently, only Jaeger is supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class V3FunctionVpcConfigArgsDict(TypedDict):
        security_group_id: NotRequired[pulumi.Input[str]]
        """
        Security group ID.
        """
        vpc_id: NotRequired[pulumi.Input[str]]
        """
        VPC network ID.
        """
        vswitch_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Switch List.
        """
elif False:
    V3FunctionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_id: Optional[pulumi.Input[str]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None,
                 vswitch_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] security_group_id: Security group ID.
        :param pulumi.Input[str] vpc_id: VPC network ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vswitch_ids: Switch List.
        """
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vswitch_ids is not None:
            pulumi.set(__self__, "vswitch_ids", vswitch_ids)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        VPC network ID.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter(name="vswitchIds")
    def vswitch_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Switch List.
        """
        return pulumi.get(self, "vswitch_ids")

    @vswitch_ids.setter
    def vswitch_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vswitch_ids", value)


if not MYPY:
    class V3LayerVersionCodeArgsDict(TypedDict):
        checksum: NotRequired[pulumi.Input[str]]
        """
        The CRC-64 value of the code package. If checksum is provided, Function Compute checks whether the checksum of the code package is consistent with the provided checksum.
        """
        oss_bucket_name: NotRequired[pulumi.Input[str]]
        """
        Name of the OSS Bucket where the user stores the Layer Code ZIP package
        """
        oss_object_name: NotRequired[pulumi.Input[str]]
        """
        Name of the OSS Object where the user stores the Layer Code ZIP package
        """
        zip_file: NotRequired[pulumi.Input[str]]
        """
        Base 64 encoding of Layer Code ZIP package
        """
elif False:
    V3LayerVersionCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3LayerVersionCodeArgs:
    def __init__(__self__, *,
                 checksum: Optional[pulumi.Input[str]] = None,
                 oss_bucket_name: Optional[pulumi.Input[str]] = None,
                 oss_object_name: Optional[pulumi.Input[str]] = None,
                 zip_file: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] checksum: The CRC-64 value of the code package. If checksum is provided, Function Compute checks whether the checksum of the code package is consistent with the provided checksum.
        :param pulumi.Input[str] oss_bucket_name: Name of the OSS Bucket where the user stores the Layer Code ZIP package
        :param pulumi.Input[str] oss_object_name: Name of the OSS Object where the user stores the Layer Code ZIP package
        :param pulumi.Input[str] zip_file: Base 64 encoding of Layer Code ZIP package
        """
        if checksum is not None:
            pulumi.set(__self__, "checksum", checksum)
        if oss_bucket_name is not None:
            pulumi.set(__self__, "oss_bucket_name", oss_bucket_name)
        if oss_object_name is not None:
            pulumi.set(__self__, "oss_object_name", oss_object_name)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @property
    @pulumi.getter
    def checksum(self) -> Optional[pulumi.Input[str]]:
        """
        The CRC-64 value of the code package. If checksum is provided, Function Compute checks whether the checksum of the code package is consistent with the provided checksum.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter(name="ossBucketName")
    def oss_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the OSS Bucket where the user stores the Layer Code ZIP package
        """
        return pulumi.get(self, "oss_bucket_name")

    @oss_bucket_name.setter
    def oss_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oss_bucket_name", value)

    @property
    @pulumi.getter(name="ossObjectName")
    def oss_object_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the OSS Object where the user stores the Layer Code ZIP package
        """
        return pulumi.get(self, "oss_object_name")

    @oss_object_name.setter
    def oss_object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oss_object_name", value)

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[pulumi.Input[str]]:
        """
        Base 64 encoding of Layer Code ZIP package
        """
        return pulumi.get(self, "zip_file")

    @zip_file.setter
    def zip_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zip_file", value)


if not MYPY:
    class V3ProvisionConfigScheduledActionArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[str]]
        """
        Policy expiration time
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Policy Name
        """
        schedule_expression: NotRequired[pulumi.Input[str]]
        """
        Timing Configuration
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Policy effective time
        """
        target: NotRequired[pulumi.Input[int]]
        """
        Number of reserved target resources
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        Time zone.
        """
elif False:
    V3ProvisionConfigScheduledActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3ProvisionConfigScheduledActionArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 schedule_expression: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[int]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_time: Policy expiration time
        :param pulumi.Input[str] name: Policy Name
        :param pulumi.Input[str] schedule_expression: Timing Configuration
        :param pulumi.Input[str] start_time: Policy effective time
        :param pulumi.Input[int] target: Number of reserved target resources
        :param pulumi.Input[str] time_zone: Time zone.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schedule_expression is not None:
            pulumi.set(__self__, "schedule_expression", schedule_expression)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Policy expiration time
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Policy Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Timing Configuration
        """
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_expression", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Policy effective time
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[int]]:
        """
        Number of reserved target resources
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class V3ProvisionConfigTargetTrackingPolicyArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[str]]
        """
        Policy expiration time
        """
        max_capacity: NotRequired[pulumi.Input[int]]
        """
        Maximum value of expansion
        """
        metric_target: NotRequired[pulumi.Input[float]]
        """
        Tracking value of the indicator
        """
        metric_type: NotRequired[pulumi.Input[str]]
        """
        Provisionedconcurrency utilization: Concurrency utilization of reserved mode instances. CPU utilization: CPU utilization. GPUMemUtilization:GPU utilization
        """
        min_capacity: NotRequired[pulumi.Input[int]]
        """
        Minimum Shrinkage
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Policy Name
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Policy Effective Time
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        Time zone.
        """
elif False:
    V3ProvisionConfigTargetTrackingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3ProvisionConfigTargetTrackingPolicyArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[str]] = None,
                 max_capacity: Optional[pulumi.Input[int]] = None,
                 metric_target: Optional[pulumi.Input[float]] = None,
                 metric_type: Optional[pulumi.Input[str]] = None,
                 min_capacity: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_time: Policy expiration time
        :param pulumi.Input[int] max_capacity: Maximum value of expansion
        :param pulumi.Input[float] metric_target: Tracking value of the indicator
        :param pulumi.Input[str] metric_type: Provisionedconcurrency utilization: Concurrency utilization of reserved mode instances. CPU utilization: CPU utilization. GPUMemUtilization:GPU utilization
        :param pulumi.Input[int] min_capacity: Minimum Shrinkage
        :param pulumi.Input[str] name: Policy Name
        :param pulumi.Input[str] start_time: Policy Effective Time
        :param pulumi.Input[str] time_zone: Time zone.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if metric_target is not None:
            pulumi.set(__self__, "metric_target", metric_target)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Policy expiration time
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum value of expansion
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="metricTarget")
    def metric_target(self) -> Optional[pulumi.Input[float]]:
        """
        Tracking value of the indicator
        """
        return pulumi.get(self, "metric_target")

    @metric_target.setter
    def metric_target(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "metric_target", value)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[str]]:
        """
        Provisionedconcurrency utilization: Concurrency utilization of reserved mode instances. CPU utilization: CPU utilization. GPUMemUtilization:GPU utilization
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum Shrinkage
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_capacity", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Policy Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Policy Effective Time
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class V3TriggerHttpTriggerArgsDict(TypedDict):
        url_internet: NotRequired[pulumi.Input[str]]
        """
        The public domain name address. On the Internet, you can access the HTTP Trigger through the HTTP protocol or HTTPS protocol.
        """
        url_intranet: NotRequired[pulumi.Input[str]]
        """
        The private domain name address. In a VPC, you can access the HTTP Trigger through HTTP or HTTPS.
        """
elif False:
    V3TriggerHttpTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V3TriggerHttpTriggerArgs:
    def __init__(__self__, *,
                 url_internet: Optional[pulumi.Input[str]] = None,
                 url_intranet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url_internet: The public domain name address. On the Internet, you can access the HTTP Trigger through the HTTP protocol or HTTPS protocol.
        :param pulumi.Input[str] url_intranet: The private domain name address. In a VPC, you can access the HTTP Trigger through HTTP or HTTPS.
        """
        if url_internet is not None:
            pulumi.set(__self__, "url_internet", url_internet)
        if url_intranet is not None:
            pulumi.set(__self__, "url_intranet", url_intranet)

    @property
    @pulumi.getter(name="urlInternet")
    def url_internet(self) -> Optional[pulumi.Input[str]]:
        """
        The public domain name address. On the Internet, you can access the HTTP Trigger through the HTTP protocol or HTTPS protocol.
        """
        return pulumi.get(self, "url_internet")

    @url_internet.setter
    def url_internet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_internet", value)

    @property
    @pulumi.getter(name="urlIntranet")
    def url_intranet(self) -> Optional[pulumi.Input[str]]:
        """
        The private domain name address. In a VPC, you can access the HTTP Trigger through HTTP or HTTPS.
        """
        return pulumi.get(self, "url_intranet")

    @url_intranet.setter
    def url_intranet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_intranet", value)


