# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConsumerGroupConsumeRetryPolicyArgs',
    'ConsumerGroupConsumeRetryPolicyArgsDict',
    'RocketMQInstanceNetworkInfoArgs',
    'RocketMQInstanceNetworkInfoArgsDict',
    'RocketMQInstanceNetworkInfoEndpointArgs',
    'RocketMQInstanceNetworkInfoEndpointArgsDict',
    'RocketMQInstanceNetworkInfoInternetInfoArgs',
    'RocketMQInstanceNetworkInfoInternetInfoArgsDict',
    'RocketMQInstanceNetworkInfoVpcInfoArgs',
    'RocketMQInstanceNetworkInfoVpcInfoArgsDict',
    'RocketMQInstanceNetworkInfoVpcInfoVswitchArgs',
    'RocketMQInstanceNetworkInfoVpcInfoVswitchArgsDict',
    'RocketMQInstanceProductInfoArgs',
    'RocketMQInstanceProductInfoArgsDict',
    'RocketMQInstanceSoftwareArgs',
    'RocketMQInstanceSoftwareArgsDict',
]

MYPY = False

if not MYPY:
    class ConsumerGroupConsumeRetryPolicyArgsDict(TypedDict):
        max_retry_times: NotRequired[pulumi.Input[int]]
        """
        Maximum number of retries.
        """
        retry_policy: NotRequired[pulumi.Input[str]]
        """
        Consume retry policy.
        """
elif False:
    ConsumerGroupConsumeRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConsumerGroupConsumeRetryPolicyArgs:
    def __init__(__self__, *,
                 max_retry_times: Optional[pulumi.Input[int]] = None,
                 retry_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] max_retry_times: Maximum number of retries.
        :param pulumi.Input[str] retry_policy: Consume retry policy.
        """
        if max_retry_times is not None:
            pulumi.set(__self__, "max_retry_times", max_retry_times)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)

    @property
    @pulumi.getter(name="maxRetryTimes")
    def max_retry_times(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of retries.
        """
        return pulumi.get(self, "max_retry_times")

    @max_retry_times.setter
    def max_retry_times(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retry_times", value)

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Consume retry policy.
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_policy", value)


if not MYPY:
    class RocketMQInstanceNetworkInfoArgsDict(TypedDict):
        internet_info: pulumi.Input['RocketMQInstanceNetworkInfoInternetInfoArgsDict']
        """
        instance internet info. See `internet_info` below.
        """
        vpc_info: pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoArgsDict']
        """
        Proprietary network information. See `vpc_info` below.
        """
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoEndpointArgsDict']]]]
        """
        Access point list.
        """
elif False:
    RocketMQInstanceNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceNetworkInfoArgs:
    def __init__(__self__, *,
                 internet_info: pulumi.Input['RocketMQInstanceNetworkInfoInternetInfoArgs'],
                 vpc_info: pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoArgs'],
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoEndpointArgs']]]] = None):
        """
        :param pulumi.Input['RocketMQInstanceNetworkInfoInternetInfoArgs'] internet_info: instance internet info. See `internet_info` below.
        :param pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoArgs'] vpc_info: Proprietary network information. See `vpc_info` below.
        :param pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoEndpointArgs']]] endpoints: Access point list.
        """
        pulumi.set(__self__, "internet_info", internet_info)
        pulumi.set(__self__, "vpc_info", vpc_info)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter(name="internetInfo")
    def internet_info(self) -> pulumi.Input['RocketMQInstanceNetworkInfoInternetInfoArgs']:
        """
        instance internet info. See `internet_info` below.
        """
        return pulumi.get(self, "internet_info")

    @internet_info.setter
    def internet_info(self, value: pulumi.Input['RocketMQInstanceNetworkInfoInternetInfoArgs']):
        pulumi.set(self, "internet_info", value)

    @property
    @pulumi.getter(name="vpcInfo")
    def vpc_info(self) -> pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoArgs']:
        """
        Proprietary network information. See `vpc_info` below.
        """
        return pulumi.get(self, "vpc_info")

    @vpc_info.setter
    def vpc_info(self, value: pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoArgs']):
        pulumi.set(self, "vpc_info", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoEndpointArgs']]]]:
        """
        Access point list.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class RocketMQInstanceNetworkInfoEndpointArgsDict(TypedDict):
        endpoint_type: NotRequired[pulumi.Input[str]]
        """
        Access point type.
        """
        endpoint_url: NotRequired[pulumi.Input[str]]
        """
        Access point address.
        """
        ip_white_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        White list of access addresses.
        """
elif False:
    RocketMQInstanceNetworkInfoEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceNetworkInfoEndpointArgs:
    def __init__(__self__, *,
                 endpoint_type: Optional[pulumi.Input[str]] = None,
                 endpoint_url: Optional[pulumi.Input[str]] = None,
                 ip_white_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] endpoint_type: Access point type.
        :param pulumi.Input[str] endpoint_url: Access point address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_white_lists: White list of access addresses.
        """
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if ip_white_lists is not None:
            pulumi.set(__self__, "ip_white_lists", ip_white_lists)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[str]]:
        """
        Access point type.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[str]]:
        """
        Access point address.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="ipWhiteLists")
    def ip_white_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        White list of access addresses.
        """
        return pulumi.get(self, "ip_white_lists")

    @ip_white_lists.setter
    def ip_white_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_white_lists", value)


if not MYPY:
    class RocketMQInstanceNetworkInfoInternetInfoArgsDict(TypedDict):
        flow_out_type: pulumi.Input[str]
        """
        Public network billing type.  Parameter values are as follows:
        - payByBandwidth: Fixed bandwidth billing. This parameter must be set to the value when public network access is enabled.
        - uninvolved: Not involved. This parameter must be set to the value when public network access is disabled.
        """
        internet_spec: pulumi.Input[str]
        """
        Whether to enable public network access.  The parameter values are as follows:
        - enable: Enable public network access
        - disable: Disable public network access   Instances by default support VPC access. If public network access is enabled, Alibaba Cloud Message Queue RocketMQ version will incur charges for public network outbound bandwidth. For specific billing information, please refer to [Public Network Access Fees](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/internet-access-fee).
        """
        flow_out_bandwidth: NotRequired[pulumi.Input[int]]
        """
        Public network bandwidth specification. Unit: Mb/s.  This field should only be filled when the public network billing type is set to payByBandwidth.  The value range is [1 - 1000].
        """
        ip_whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        internet ip whitelist.
        """
elif False:
    RocketMQInstanceNetworkInfoInternetInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceNetworkInfoInternetInfoArgs:
    def __init__(__self__, *,
                 flow_out_type: pulumi.Input[str],
                 internet_spec: pulumi.Input[str],
                 flow_out_bandwidth: Optional[pulumi.Input[int]] = None,
                 ip_whitelists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] flow_out_type: Public network billing type.  Parameter values are as follows:
               - payByBandwidth: Fixed bandwidth billing. This parameter must be set to the value when public network access is enabled.
               - uninvolved: Not involved. This parameter must be set to the value when public network access is disabled.
        :param pulumi.Input[str] internet_spec: Whether to enable public network access.  The parameter values are as follows:
               - enable: Enable public network access
               - disable: Disable public network access   Instances by default support VPC access. If public network access is enabled, Alibaba Cloud Message Queue RocketMQ version will incur charges for public network outbound bandwidth. For specific billing information, please refer to [Public Network Access Fees](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/internet-access-fee).
        :param pulumi.Input[int] flow_out_bandwidth: Public network bandwidth specification. Unit: Mb/s.  This field should only be filled when the public network billing type is set to payByBandwidth.  The value range is [1 - 1000].
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_whitelists: internet ip whitelist.
        """
        pulumi.set(__self__, "flow_out_type", flow_out_type)
        pulumi.set(__self__, "internet_spec", internet_spec)
        if flow_out_bandwidth is not None:
            pulumi.set(__self__, "flow_out_bandwidth", flow_out_bandwidth)
        if ip_whitelists is not None:
            pulumi.set(__self__, "ip_whitelists", ip_whitelists)

    @property
    @pulumi.getter(name="flowOutType")
    def flow_out_type(self) -> pulumi.Input[str]:
        """
        Public network billing type.  Parameter values are as follows:
        - payByBandwidth: Fixed bandwidth billing. This parameter must be set to the value when public network access is enabled.
        - uninvolved: Not involved. This parameter must be set to the value when public network access is disabled.
        """
        return pulumi.get(self, "flow_out_type")

    @flow_out_type.setter
    def flow_out_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "flow_out_type", value)

    @property
    @pulumi.getter(name="internetSpec")
    def internet_spec(self) -> pulumi.Input[str]:
        """
        Whether to enable public network access.  The parameter values are as follows:
        - enable: Enable public network access
        - disable: Disable public network access   Instances by default support VPC access. If public network access is enabled, Alibaba Cloud Message Queue RocketMQ version will incur charges for public network outbound bandwidth. For specific billing information, please refer to [Public Network Access Fees](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/internet-access-fee).
        """
        return pulumi.get(self, "internet_spec")

    @internet_spec.setter
    def internet_spec(self, value: pulumi.Input[str]):
        pulumi.set(self, "internet_spec", value)

    @property
    @pulumi.getter(name="flowOutBandwidth")
    def flow_out_bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        Public network bandwidth specification. Unit: Mb/s.  This field should only be filled when the public network billing type is set to payByBandwidth.  The value range is [1 - 1000].
        """
        return pulumi.get(self, "flow_out_bandwidth")

    @flow_out_bandwidth.setter
    def flow_out_bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flow_out_bandwidth", value)

    @property
    @pulumi.getter(name="ipWhitelists")
    def ip_whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        internet ip whitelist.
        """
        return pulumi.get(self, "ip_whitelists")

    @ip_whitelists.setter
    def ip_whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_whitelists", value)


if not MYPY:
    class RocketMQInstanceNetworkInfoVpcInfoArgsDict(TypedDict):
        vpc_id: pulumi.Input[str]
        """
        Proprietary Network.
        """
        security_group_ids: NotRequired[pulumi.Input[str]]
        """
        Security group id.
        """
        vswitch_id: NotRequired[pulumi.Input[str]]
        """
        VPC switch id.
        """
        vswitches: NotRequired[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoVswitchArgsDict']]]]
        """
        Multiple VSwitches. At least two VSwitches are required for a serverless instance. See `vswitches` below.
        """
elif False:
    RocketMQInstanceNetworkInfoVpcInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceNetworkInfoVpcInfoArgs:
    def __init__(__self__, *,
                 vpc_id: pulumi.Input[str],
                 security_group_ids: Optional[pulumi.Input[str]] = None,
                 vswitch_id: Optional[pulumi.Input[str]] = None,
                 vswitches: Optional[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoVswitchArgs']]]] = None):
        """
        :param pulumi.Input[str] vpc_id: Proprietary Network.
        :param pulumi.Input[str] security_group_ids: Security group id.
        :param pulumi.Input[str] vswitch_id: VPC switch id.
        :param pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoVswitchArgs']]] vswitches: Multiple VSwitches. At least two VSwitches are required for a serverless instance. See `vswitches` below.
        """
        pulumi.set(__self__, "vpc_id", vpc_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if vswitch_id is not None:
            pulumi.set(__self__, "vswitch_id", vswitch_id)
        if vswitches is not None:
            pulumi.set(__self__, "vswitches", vswitches)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        """
        Proprietary Network.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[str]]:
        """
        Security group id.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[pulumi.Input[str]]:
        """
        VPC switch id.
        """
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vswitch_id", value)

    @property
    @pulumi.getter
    def vswitches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoVswitchArgs']]]]:
        """
        Multiple VSwitches. At least two VSwitches are required for a serverless instance. See `vswitches` below.
        """
        return pulumi.get(self, "vswitches")

    @vswitches.setter
    def vswitches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RocketMQInstanceNetworkInfoVpcInfoVswitchArgs']]]]):
        pulumi.set(self, "vswitches", value)


if not MYPY:
    class RocketMQInstanceNetworkInfoVpcInfoVswitchArgsDict(TypedDict):
        vswitch_id: NotRequired[pulumi.Input[str]]
        """
        VPC switch id.
        """
elif False:
    RocketMQInstanceNetworkInfoVpcInfoVswitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceNetworkInfoVpcInfoVswitchArgs:
    def __init__(__self__, *,
                 vswitch_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vswitch_id: VPC switch id.
        """
        if vswitch_id is not None:
            pulumi.set(__self__, "vswitch_id", vswitch_id)

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[pulumi.Input[str]]:
        """
        VPC switch id.
        """
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vswitch_id", value)


if not MYPY:
    class RocketMQInstanceProductInfoArgsDict(TypedDict):
        msg_process_spec: pulumi.Input[str]
        """
        Message sending and receiving calculation specifications. For details about the upper limit for sending and receiving messages, see [Instance Specifications](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/instance-specifications).
        """
        auto_scaling: NotRequired[pulumi.Input[bool]]
        """
        is open auto scaling.
        """
        message_retention_time: NotRequired[pulumi.Input[int]]
        """
        Duration of message retention. Unit: hours.  For the range of values, please refer to [Usage Limits](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/usage-limits)>Resource Quotas>Limitations on Message Retention.  The message storage in AlibabaCloud RocketMQ is fully implemented in a serverless and elastic manner, with charges based on the actual storage space. You can control the storage capacity of messages by adjusting the duration of message retention. For more information, please see [Storage Fees](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/storage-fees).
        """
        send_receive_ratio: NotRequired[pulumi.Input[float]]
        """
        message send receive ratio.  Value range: [0.2, 0.5].
        """
        support_auto_scaling: NotRequired[pulumi.Input[bool]]
        """
        is support auto scaling.
        """
elif False:
    RocketMQInstanceProductInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceProductInfoArgs:
    def __init__(__self__, *,
                 msg_process_spec: pulumi.Input[str],
                 auto_scaling: Optional[pulumi.Input[bool]] = None,
                 message_retention_time: Optional[pulumi.Input[int]] = None,
                 send_receive_ratio: Optional[pulumi.Input[float]] = None,
                 support_auto_scaling: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] msg_process_spec: Message sending and receiving calculation specifications. For details about the upper limit for sending and receiving messages, see [Instance Specifications](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/instance-specifications).
        :param pulumi.Input[bool] auto_scaling: is open auto scaling.
        :param pulumi.Input[int] message_retention_time: Duration of message retention. Unit: hours.  For the range of values, please refer to [Usage Limits](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/usage-limits)>Resource Quotas>Limitations on Message Retention.  The message storage in AlibabaCloud RocketMQ is fully implemented in a serverless and elastic manner, with charges based on the actual storage space. You can control the storage capacity of messages by adjusting the duration of message retention. For more information, please see [Storage Fees](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/storage-fees).
        :param pulumi.Input[float] send_receive_ratio: message send receive ratio.  Value range: [0.2, 0.5].
        :param pulumi.Input[bool] support_auto_scaling: is support auto scaling.
        """
        pulumi.set(__self__, "msg_process_spec", msg_process_spec)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if message_retention_time is not None:
            pulumi.set(__self__, "message_retention_time", message_retention_time)
        if send_receive_ratio is not None:
            pulumi.set(__self__, "send_receive_ratio", send_receive_ratio)
        if support_auto_scaling is not None:
            pulumi.set(__self__, "support_auto_scaling", support_auto_scaling)

    @property
    @pulumi.getter(name="msgProcessSpec")
    def msg_process_spec(self) -> pulumi.Input[str]:
        """
        Message sending and receiving calculation specifications. For details about the upper limit for sending and receiving messages, see [Instance Specifications](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/instance-specifications).
        """
        return pulumi.get(self, "msg_process_spec")

    @msg_process_spec.setter
    def msg_process_spec(self, value: pulumi.Input[str]):
        pulumi.set(self, "msg_process_spec", value)

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional[pulumi.Input[bool]]:
        """
        is open auto scaling.
        """
        return pulumi.get(self, "auto_scaling")

    @auto_scaling.setter
    def auto_scaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_scaling", value)

    @property
    @pulumi.getter(name="messageRetentionTime")
    def message_retention_time(self) -> Optional[pulumi.Input[int]]:
        """
        Duration of message retention. Unit: hours.  For the range of values, please refer to [Usage Limits](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/usage-limits)>Resource Quotas>Limitations on Message Retention.  The message storage in AlibabaCloud RocketMQ is fully implemented in a serverless and elastic manner, with charges based on the actual storage space. You can control the storage capacity of messages by adjusting the duration of message retention. For more information, please see [Storage Fees](https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-5-x-series/product-overview/storage-fees).
        """
        return pulumi.get(self, "message_retention_time")

    @message_retention_time.setter
    def message_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "message_retention_time", value)

    @property
    @pulumi.getter(name="sendReceiveRatio")
    def send_receive_ratio(self) -> Optional[pulumi.Input[float]]:
        """
        message send receive ratio.  Value range: [0.2, 0.5].
        """
        return pulumi.get(self, "send_receive_ratio")

    @send_receive_ratio.setter
    def send_receive_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "send_receive_ratio", value)

    @property
    @pulumi.getter(name="supportAutoScaling")
    def support_auto_scaling(self) -> Optional[pulumi.Input[bool]]:
        """
        is support auto scaling.
        """
        return pulumi.get(self, "support_auto_scaling")

    @support_auto_scaling.setter
    def support_auto_scaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_auto_scaling", value)


if not MYPY:
    class RocketMQInstanceSoftwareArgsDict(TypedDict):
        maintain_time: NotRequired[pulumi.Input[str]]
        """
        Upgrade time period.
        """
        software_version: NotRequired[pulumi.Input[str]]
        """
        Software version.
        """
        upgrade_method: NotRequired[pulumi.Input[str]]
        """
        Upgrade method.
        """
elif False:
    RocketMQInstanceSoftwareArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketMQInstanceSoftwareArgs:
    def __init__(__self__, *,
                 maintain_time: Optional[pulumi.Input[str]] = None,
                 software_version: Optional[pulumi.Input[str]] = None,
                 upgrade_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] maintain_time: Upgrade time period.
        :param pulumi.Input[str] software_version: Software version.
        :param pulumi.Input[str] upgrade_method: Upgrade method.
        """
        if maintain_time is not None:
            pulumi.set(__self__, "maintain_time", maintain_time)
        if software_version is not None:
            pulumi.set(__self__, "software_version", software_version)
        if upgrade_method is not None:
            pulumi.set(__self__, "upgrade_method", upgrade_method)

    @property
    @pulumi.getter(name="maintainTime")
    def maintain_time(self) -> Optional[pulumi.Input[str]]:
        """
        Upgrade time period.
        """
        return pulumi.get(self, "maintain_time")

    @maintain_time.setter
    def maintain_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintain_time", value)

    @property
    @pulumi.getter(name="softwareVersion")
    def software_version(self) -> Optional[pulumi.Input[str]]:
        """
        Software version.
        """
        return pulumi.get(self, "software_version")

    @software_version.setter
    def software_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_version", value)

    @property
    @pulumi.getter(name="upgradeMethod")
    def upgrade_method(self) -> Optional[pulumi.Input[str]]:
        """
        Upgrade method.
        """
        return pulumi.get(self, "upgrade_method")

    @upgrade_method.setter
    def upgrade_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upgrade_method", value)


