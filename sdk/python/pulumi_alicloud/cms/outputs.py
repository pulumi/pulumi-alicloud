# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AlarmEscalationsCritical',
    'AlarmEscalationsInfo',
    'AlarmEscalationsWarn',
    'AlarmPrometheus',
    'DynamicTagGroupMatchExpress',
    'EventRuleContactParameter',
    'EventRuleEventPattern',
    'EventRuleFcParameter',
    'EventRuleMnsParameter',
    'EventRuleOpenApiParameter',
    'EventRuleSlsParameter',
    'EventRuleWebhookParameter',
    'GroupMetricRuleEscalations',
    'GroupMetricRuleEscalationsCritical',
    'GroupMetricRuleEscalationsInfo',
    'GroupMetricRuleEscalationsWarn',
    'GroupMetricRuleTarget',
    'HybridMonitorSlsTaskAttachLabel',
    'HybridMonitorSlsTaskSlsProcessConfig',
    'HybridMonitorSlsTaskSlsProcessConfigExpress',
    'HybridMonitorSlsTaskSlsProcessConfigFilter',
    'HybridMonitorSlsTaskSlsProcessConfigFilterFilter',
    'HybridMonitorSlsTaskSlsProcessConfigGroupBy',
    'HybridMonitorSlsTaskSlsProcessConfigStatistic',
    'MetricRuleBlackListMetric',
    'MetricRuleTemplateAlertTemplate',
    'MetricRuleTemplateAlertTemplateEscalations',
    'MetricRuleTemplateAlertTemplateEscalationsCritical',
    'MetricRuleTemplateAlertTemplateEscalationsInfo',
    'MetricRuleTemplateAlertTemplateEscalationsWarn',
    'MonitorGroupInstancesInstance',
    'SiteMonitorIspCity',
    'SlsGroupSlsGroupConfig',
    'GetAlarmContactGroupsGroupResult',
    'GetAlarmContactsContactResult',
    'GetDynamicTagGroupsGroupResult',
    'GetDynamicTagGroupsGroupMatchExpressResult',
    'GetEventRulesRuleResult',
    'GetEventRulesRuleEventPatternResult',
    'GetEventRulesRuleEventPatternKeywordFilterResult',
    'GetGroupMetricRulesRuleResult',
    'GetGroupMetricRulesRuleEscalationResult',
    'GetGroupMetricRulesRuleEscalationCriticalResult',
    'GetGroupMetricRulesRuleEscalationInfoResult',
    'GetGroupMetricRulesRuleEscalationWarnResult',
    'GetHybridMonitorDatasDataResult',
    'GetHybridMonitorDatasDataLabelResult',
    'GetHybridMonitorDatasDataValueResult',
    'GetHybridMonitorFcTasksTaskResult',
    'GetHybridMonitorSlsTasksTaskResult',
    'GetHybridMonitorSlsTasksTaskAttachLabelResult',
    'GetHybridMonitorSlsTasksTaskMatchExpressResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult',
    'GetMetricRuleBlackListsListResult',
    'GetMetricRuleBlackListsListMetricResult',
    'GetMetricRuleTemplatesTemplateResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult',
    'GetMonitorGroupInstancesInstanceResult',
    'GetMonitorGroupInstancesInstanceInstanceResult',
    'GetMonitorGroupsGroupResult',
    'GetNamespacesNamespaceResult',
    'GetSlsGroupsGroupResult',
    'GetSlsGroupsGroupSlsGroupConfigResult',
]

@pulumi.output_type
class AlarmEscalationsCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmEscalationsCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmEscalationsCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmEscalationsCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param str comparison_operator: Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
        :param str statistics: Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        :param str threshold: Critical level alarm threshold value, which must be a numeric value currently.
        :param int times: Critical level alarm retry times. Default to 3.
        """
        AlarmEscalationsCritical._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        Critical level alarm threshold value, which must be a numeric value currently.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        Critical level alarm retry times. Default to 3.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmEscalationsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmEscalationsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmEscalationsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmEscalationsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param str comparison_operator: Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
        :param str statistics: Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        :param str threshold: Critical level alarm threshold value, which must be a numeric value currently.
        :param int times: Critical level alarm retry times. Default to 3.
        """
        AlarmEscalationsInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        Critical level alarm threshold value, which must be a numeric value currently.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        Critical level alarm retry times. Default to 3.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmEscalationsWarn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmEscalationsWarn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmEscalationsWarn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmEscalationsWarn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param str comparison_operator: Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
        :param str statistics: Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        :param str threshold: Critical level alarm threshold value, which must be a numeric value currently.
        :param int times: Critical level alarm retry times. Default to 3.
        """
        AlarmEscalationsWarn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        Critical level alarm comparison operator. Valid values: ["<=", "<", ">", ">=", "==", "!="]. Default to "==".
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        Critical level alarm threshold value, which must be a numeric value currently.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        Critical level alarm retry times. Default to 3.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmPrometheus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promQl":
            suggest = "prom_ql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPrometheus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPrometheus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPrometheus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 level: Optional[str] = None,
                 prom_ql: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param Mapping[str, Any] annotations: The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
        :param str level: The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        :param str prom_ql: The PromQL query statement. **Note:** The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
        :param int times: The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        """
        AlarmPrometheus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotations=annotations,
            level=level,
            prom_ql=prom_ql,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotations: Optional[Mapping[str, Any]] = None,
             level: Optional[str] = None,
             prom_ql: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if prom_ql is None and 'promQl' in kwargs:
            prom_ql = kwargs['promQl']

        if annotations is not None:
            _setter("annotations", annotations)
        if level is not None:
            _setter("level", level)
        if prom_ql is not None:
            _setter("prom_ql", prom_ql)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="promQl")
    def prom_ql(self) -> Optional[str]:
        """
        The PromQL query statement. **Note:** The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
        """
        return pulumi.get(self, "prom_ql")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class DynamicTagGroupMatchExpress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagValue":
            suggest = "tag_value"
        elif key == "tagValueMatchFunction":
            suggest = "tag_value_match_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicTagGroupMatchExpress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicTagGroupMatchExpress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicTagGroupMatchExpress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_value: str,
                 tag_value_match_function: str):
        """
        :param str tag_value: The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
        :param str tag_value_match_function: Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
        """
        DynamicTagGroupMatchExpress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_value=tag_value,
            tag_value_match_function=tag_value_match_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_value: Optional[str] = None,
             tag_value_match_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tag_value is None and 'tagValue' in kwargs:
            tag_value = kwargs['tagValue']
        if tag_value is None:
            raise TypeError("Missing 'tag_value' argument")
        if tag_value_match_function is None and 'tagValueMatchFunction' in kwargs:
            tag_value_match_function = kwargs['tagValueMatchFunction']
        if tag_value_match_function is None:
            raise TypeError("Missing 'tag_value_match_function' argument")

        _setter("tag_value", tag_value)
        _setter("tag_value_match_function", tag_value_match_function)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> str:
        """
        The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
        """
        return pulumi.get(self, "tag_value")

    @property
    @pulumi.getter(name="tagValueMatchFunction")
    def tag_value_match_function(self) -> str:
        """
        Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
        """
        return pulumi.get(self, "tag_value_match_function")


@pulumi.output_type
class EventRuleContactParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactGroupName":
            suggest = "contact_group_name"
        elif key == "contactParametersId":
            suggest = "contact_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleContactParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleContactParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleContactParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_group_name: Optional[str] = None,
                 contact_parameters_id: Optional[str] = None,
                 level: Optional[str] = None):
        """
        :param str contact_group_name: The name of the alert contact group.
        :param str contact_parameters_id: The ID of the recipient that receives alert notifications.
        :param str level: The alert level and the corresponding notification methods.
        """
        EventRuleContactParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contact_group_name=contact_group_name,
            contact_parameters_id=contact_parameters_id,
            level=level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contact_group_name: Optional[str] = None,
             contact_parameters_id: Optional[str] = None,
             level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contact_group_name is None and 'contactGroupName' in kwargs:
            contact_group_name = kwargs['contactGroupName']
        if contact_parameters_id is None and 'contactParametersId' in kwargs:
            contact_parameters_id = kwargs['contactParametersId']

        if contact_group_name is not None:
            _setter("contact_group_name", contact_group_name)
        if contact_parameters_id is not None:
            _setter("contact_parameters_id", contact_parameters_id)
        if level is not None:
            _setter("level", level)

    @property
    @pulumi.getter(name="contactGroupName")
    def contact_group_name(self) -> Optional[str]:
        """
        The name of the alert contact group.
        """
        return pulumi.get(self, "contact_group_name")

    @property
    @pulumi.getter(name="contactParametersId")
    def contact_parameters_id(self) -> Optional[str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "contact_parameters_id")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The alert level and the corresponding notification methods.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class EventRuleEventPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventTypeLists":
            suggest = "event_type_lists"
        elif key == "levelLists":
            suggest = "level_lists"
        elif key == "nameLists":
            suggest = "name_lists"
        elif key == "sqlFilter":
            suggest = "sql_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleEventPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleEventPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleEventPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 product: str,
                 event_type_lists: Optional[Sequence[str]] = None,
                 level_lists: Optional[Sequence[str]] = None,
                 name_lists: Optional[Sequence[str]] = None,
                 sql_filter: Optional[str] = None):
        """
        :param str product: The type of the cloud service.
        :param Sequence[str] event_type_lists: The type of the event-triggered alert rule. Valid values:
        :param Sequence[str] level_lists: The level of the event-triggered alert rule. Valid values:
        :param Sequence[str] name_lists: The name of the event-triggered alert rule.
        :param str sql_filter: The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
        """
        EventRuleEventPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            product=product,
            event_type_lists=event_type_lists,
            level_lists=level_lists,
            name_lists=name_lists,
            sql_filter=sql_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             product: Optional[str] = None,
             event_type_lists: Optional[Sequence[str]] = None,
             level_lists: Optional[Sequence[str]] = None,
             name_lists: Optional[Sequence[str]] = None,
             sql_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if product is None:
            raise TypeError("Missing 'product' argument")
        if event_type_lists is None and 'eventTypeLists' in kwargs:
            event_type_lists = kwargs['eventTypeLists']
        if level_lists is None and 'levelLists' in kwargs:
            level_lists = kwargs['levelLists']
        if name_lists is None and 'nameLists' in kwargs:
            name_lists = kwargs['nameLists']
        if sql_filter is None and 'sqlFilter' in kwargs:
            sql_filter = kwargs['sqlFilter']

        _setter("product", product)
        if event_type_lists is not None:
            _setter("event_type_lists", event_type_lists)
        if level_lists is not None:
            _setter("level_lists", level_lists)
        if name_lists is not None:
            _setter("name_lists", name_lists)
        if sql_filter is not None:
            _setter("sql_filter", sql_filter)

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        The type of the cloud service.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter(name="eventTypeLists")
    def event_type_lists(self) -> Optional[Sequence[str]]:
        """
        The type of the event-triggered alert rule. Valid values:
        """
        return pulumi.get(self, "event_type_lists")

    @property
    @pulumi.getter(name="levelLists")
    def level_lists(self) -> Optional[Sequence[str]]:
        """
        The level of the event-triggered alert rule. Valid values:
        """
        return pulumi.get(self, "level_lists")

    @property
    @pulumi.getter(name="nameLists")
    def name_lists(self) -> Optional[Sequence[str]]:
        """
        The name of the event-triggered alert rule.
        """
        return pulumi.get(self, "name_lists")

    @property
    @pulumi.getter(name="sqlFilter")
    def sql_filter(self) -> Optional[str]:
        """
        The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
        """
        return pulumi.get(self, "sql_filter")


@pulumi.output_type
class EventRuleFcParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fcParametersId":
            suggest = "fc_parameters_id"
        elif key == "functionName":
            suggest = "function_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleFcParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleFcParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleFcParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 fc_parameters_id: Optional[str] = None,
                 function_name: Optional[str] = None,
                 region: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        :param str arn: (Available since v1.211.1) The ARN of the API operation.
        :param str fc_parameters_id: The ID of the recipient that receives alert notifications.
        :param str function_name: The name of the function.
        :param str region: The region where Function Compute is deployed.
        :param str service_name: The name of the Function Compute service.
        """
        EventRuleFcParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            fc_parameters_id=fc_parameters_id,
            function_name=function_name,
            region=region,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             fc_parameters_id: Optional[str] = None,
             function_name: Optional[str] = None,
             region: Optional[str] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fc_parameters_id is None and 'fcParametersId' in kwargs:
            fc_parameters_id = kwargs['fcParametersId']
        if function_name is None and 'functionName' in kwargs:
            function_name = kwargs['functionName']
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        if arn is not None:
            _setter("arn", arn)
        if fc_parameters_id is not None:
            _setter("fc_parameters_id", fc_parameters_id)
        if function_name is not None:
            _setter("function_name", function_name)
        if region is not None:
            _setter("region", region)
        if service_name is not None:
            _setter("service_name", service_name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="fcParametersId")
    def fc_parameters_id(self) -> Optional[str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "fc_parameters_id")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[str]:
        """
        The name of the function.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region where Function Compute is deployed.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the Function Compute service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class EventRuleMnsParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mnsParametersId":
            suggest = "mns_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleMnsParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleMnsParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleMnsParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 mns_parameters_id: Optional[str] = None,
                 queue: Optional[str] = None,
                 region: Optional[str] = None,
                 topic: Optional[str] = None):
        """
        :param str arn: (Available since v1.211.1) The ARN of the API operation.
        :param str mns_parameters_id: The ID of the recipient that receives alert notifications.
        :param str queue: The name of the MNS queue.
        :param str region: The region where Message Service (MNS) is deployed.
        :param str topic: The MNS topic.
        """
        EventRuleMnsParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            mns_parameters_id=mns_parameters_id,
            queue=queue,
            region=region,
            topic=topic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             mns_parameters_id: Optional[str] = None,
             queue: Optional[str] = None,
             region: Optional[str] = None,
             topic: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mns_parameters_id is None and 'mnsParametersId' in kwargs:
            mns_parameters_id = kwargs['mnsParametersId']

        if arn is not None:
            _setter("arn", arn)
        if mns_parameters_id is not None:
            _setter("mns_parameters_id", mns_parameters_id)
        if queue is not None:
            _setter("queue", queue)
        if region is not None:
            _setter("region", region)
        if topic is not None:
            _setter("topic", topic)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="mnsParametersId")
    def mns_parameters_id(self) -> Optional[str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "mns_parameters_id")

    @property
    @pulumi.getter
    def queue(self) -> Optional[str]:
        """
        The name of the MNS queue.
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region where Message Service (MNS) is deployed.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        The MNS topic.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class EventRuleOpenApiParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openApiParametersId":
            suggest = "open_api_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleOpenApiParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleOpenApiParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleOpenApiParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 arn: Optional[str] = None,
                 open_api_parameters_id: Optional[str] = None,
                 product: Optional[str] = None,
                 region: Optional[str] = None,
                 role: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str action: The API name.
        :param str arn: (Available since v1.211.1) The ARN of the API operation.
        :param str open_api_parameters_id: The ID of the recipient that receives alert notifications sent by an API callback.
        :param str product: The ID of the cloud service to which the API operation belongs.
        :param str region: The region where the resource resides.
        :param str role: The name of the role.
        :param str version: The version of the API.
        """
        EventRuleOpenApiParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            arn=arn,
            open_api_parameters_id=open_api_parameters_id,
            product=product,
            region=region,
            role=role,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             arn: Optional[str] = None,
             open_api_parameters_id: Optional[str] = None,
             product: Optional[str] = None,
             region: Optional[str] = None,
             role: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if open_api_parameters_id is None and 'openApiParametersId' in kwargs:
            open_api_parameters_id = kwargs['openApiParametersId']

        if action is not None:
            _setter("action", action)
        if arn is not None:
            _setter("arn", arn)
        if open_api_parameters_id is not None:
            _setter("open_api_parameters_id", open_api_parameters_id)
        if product is not None:
            _setter("product", product)
        if region is not None:
            _setter("region", region)
        if role is not None:
            _setter("role", role)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The API name.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="openApiParametersId")
    def open_api_parameters_id(self) -> Optional[str]:
        """
        The ID of the recipient that receives alert notifications sent by an API callback.
        """
        return pulumi.get(self, "open_api_parameters_id")

    @property
    @pulumi.getter
    def product(self) -> Optional[str]:
        """
        The ID of the cloud service to which the API operation belongs.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region where the resource resides.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The name of the role.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of the API.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EventRuleSlsParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logStore":
            suggest = "log_store"
        elif key == "slsParametersId":
            suggest = "sls_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleSlsParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleSlsParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleSlsParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 log_store: Optional[str] = None,
                 project: Optional[str] = None,
                 region: Optional[str] = None,
                 sls_parameters_id: Optional[str] = None):
        """
        :param str arn: (Available since v1.211.1) The ARN of the API operation.
        :param str log_store: The name of the Simple Log Service Logstore.
        :param str project: The name of the Simple Log Service project.
        :param str region: The region where Simple Log Service is deployed.
        :param str sls_parameters_id: The ID of the recipient that receives alert notifications.
        """
        EventRuleSlsParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            log_store=log_store,
            project=project,
            region=region,
            sls_parameters_id=sls_parameters_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             log_store: Optional[str] = None,
             project: Optional[str] = None,
             region: Optional[str] = None,
             sls_parameters_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_store is None and 'logStore' in kwargs:
            log_store = kwargs['logStore']
        if sls_parameters_id is None and 'slsParametersId' in kwargs:
            sls_parameters_id = kwargs['slsParametersId']

        if arn is not None:
            _setter("arn", arn)
        if log_store is not None:
            _setter("log_store", log_store)
        if project is not None:
            _setter("project", project)
        if region is not None:
            _setter("region", region)
        if sls_parameters_id is not None:
            _setter("sls_parameters_id", sls_parameters_id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="logStore")
    def log_store(self) -> Optional[str]:
        """
        The name of the Simple Log Service Logstore.
        """
        return pulumi.get(self, "log_store")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The name of the Simple Log Service project.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region where Simple Log Service is deployed.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="slsParametersId")
    def sls_parameters_id(self) -> Optional[str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "sls_parameters_id")


@pulumi.output_type
class EventRuleWebhookParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webhookParametersId":
            suggest = "webhook_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleWebhookParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleWebhookParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleWebhookParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[str] = None,
                 protocol: Optional[str] = None,
                 url: Optional[str] = None,
                 webhook_parameters_id: Optional[str] = None):
        """
        :param str method: The HTTP request method.
        :param str protocol: The name of the protocol.
        :param str url: The callback URL.
        :param str webhook_parameters_id: The ID of the recipient that receives alert notifications.
        """
        EventRuleWebhookParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            method=method,
            protocol=protocol,
            url=url,
            webhook_parameters_id=webhook_parameters_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             method: Optional[str] = None,
             protocol: Optional[str] = None,
             url: Optional[str] = None,
             webhook_parameters_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if webhook_parameters_id is None and 'webhookParametersId' in kwargs:
            webhook_parameters_id = kwargs['webhookParametersId']

        if method is not None:
            _setter("method", method)
        if protocol is not None:
            _setter("protocol", protocol)
        if url is not None:
            _setter("url", url)
        if webhook_parameters_id is not None:
            _setter("webhook_parameters_id", webhook_parameters_id)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP request method.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The name of the protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The callback URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="webhookParametersId")
    def webhook_parameters_id(self) -> Optional[str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "webhook_parameters_id")


@pulumi.output_type
class GroupMetricRuleEscalations(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.GroupMetricRuleEscalationsCritical'] = None,
                 info: Optional['outputs.GroupMetricRuleEscalationsInfo'] = None,
                 warn: Optional['outputs.GroupMetricRuleEscalationsWarn'] = None):
        """
        :param 'GroupMetricRuleEscalationsCriticalArgs' critical: The critical level. See `critical` below.
        :param 'GroupMetricRuleEscalationsInfoArgs' info: The info level. See `info` below.
        :param 'GroupMetricRuleEscalationsWarnArgs' warn: The warn level. See `warn` below.
        """
        GroupMetricRuleEscalations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            critical=critical,
            info=info,
            warn=warn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             critical: Optional['outputs.GroupMetricRuleEscalationsCritical'] = None,
             info: Optional['outputs.GroupMetricRuleEscalationsInfo'] = None,
             warn: Optional['outputs.GroupMetricRuleEscalationsWarn'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if critical is not None:
            _setter("critical", critical)
        if info is not None:
            _setter("info", info)
        if warn is not None:
            _setter("warn", warn)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.GroupMetricRuleEscalationsCritical']:
        """
        The critical level. See `critical` below.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def info(self) -> Optional['outputs.GroupMetricRuleEscalationsInfo']:
        """
        The info level. See `info` below.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def warn(self) -> Optional['outputs.GroupMetricRuleEscalationsWarn']:
        """
        The warn level. See `warn` below.
        """
        return pulumi.get(self, "warn")


@pulumi.output_type
class GroupMetricRuleEscalationsCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleEscalationsCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleEscalationsCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleEscalationsCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        GroupMetricRuleEscalationsCritical._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GroupMetricRuleEscalationsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleEscalationsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleEscalationsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleEscalationsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        GroupMetricRuleEscalationsInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GroupMetricRuleEscalationsWarn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleEscalationsWarn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleEscalationsWarn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleEscalationsWarn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[int] = None):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        GroupMetricRuleEscalationsWarn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[int]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GroupMetricRuleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonParams":
            suggest = "json_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 json_params: Optional[str] = None,
                 level: Optional[str] = None):
        """
        :param str arn: The Alibaba Cloud Resource Name (ARN) of the resource.
        :param str id: The ID of the resource for which alerts are triggered.
        :param str json_params: The parameters of the alert callback. The parameters are in the JSON format.
               
               > **NOTE:** Currently, the Alibaba Cloud Resource Name (ARN) of the resource. To use, please [submit an application](https://www.alibabacloud.com/help/en/cloudmonitor/latest/describemetricruletargets).
        :param str level: The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        GroupMetricRuleTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            id=id,
            json_params=json_params,
            level=level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             id: Optional[str] = None,
             json_params: Optional[str] = None,
             level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if json_params is None and 'jsonParams' in kwargs:
            json_params = kwargs['jsonParams']

        if arn is not None:
            _setter("arn", arn)
        if id is not None:
            _setter("id", id)
        if json_params is not None:
            _setter("json_params", json_params)
        if level is not None:
            _setter("level", level)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Alibaba Cloud Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the resource for which alerts are triggered.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="jsonParams")
    def json_params(self) -> Optional[str]:
        """
        The parameters of the alert callback. The parameters are in the JSON format.

        > **NOTE:** Currently, the Alibaba Cloud Resource Name (ARN) of the resource. To use, please [submit an application](https://www.alibabacloud.com/help/en/cloudmonitor/latest/describemetricruletargets).
        """
        return pulumi.get(self, "json_params")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HybridMonitorSlsTaskAttachLabel(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The tag key of the metric.
        :param str value: The tag value of the metric.
        """
        HybridMonitorSlsTaskAttachLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The tag key of the metric.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value of the metric.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expresses: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigExpress']] = None,
                 filter: Optional['outputs.HybridMonitorSlsTaskSlsProcessConfigFilter'] = None,
                 group_bies: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigGroupBy']] = None,
                 statistics: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigStatistic']] = None):
        """
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigExpressArgs'] expresses: The extended field that specifies the result of basic operations that are performed on aggregation results.
        :param 'HybridMonitorSlsTaskSlsProcessConfigFilterArgs' filter: The conditions that are used to filter logs imported from Log Service. See `filter` below.
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigGroupByArgs'] group_bies: The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. See `group_by` below.
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigStatisticArgs'] statistics: The method that is used to aggregate logs imported from Log Service. See `statistics` below.
        """
        HybridMonitorSlsTaskSlsProcessConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expresses=expresses,
            filter=filter,
            group_bies=group_bies,
            statistics=statistics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expresses: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigExpress']] = None,
             filter: Optional['outputs.HybridMonitorSlsTaskSlsProcessConfigFilter'] = None,
             group_bies: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigGroupBy']] = None,
             statistics: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigStatistic']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_bies is None and 'groupBies' in kwargs:
            group_bies = kwargs['groupBies']

        if expresses is not None:
            _setter("expresses", expresses)
        if filter is not None:
            _setter("filter", filter)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if statistics is not None:
            _setter("statistics", statistics)

    @property
    @pulumi.getter
    def expresses(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigExpress']]:
        """
        The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "expresses")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.HybridMonitorSlsTaskSlsProcessConfigFilter']:
        """
        The conditions that are used to filter logs imported from Log Service. See `filter` below.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigGroupBy']]:
        """
        The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. See `group_by` below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigStatistic']]:
        """
        The method that is used to aggregate logs imported from Log Service. See `statistics` below.
        """
        return pulumi.get(self, "statistics")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigExpress(dict):
    def __init__(__self__, *,
                 alias: Optional[str] = None,
                 express: Optional[str] = None):
        """
        :param str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param str express: The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        HybridMonitorSlsTaskSlsProcessConfigExpress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            express=express,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             express: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if alias is not None:
            _setter("alias", alias)
        if express is not None:
            _setter("express", express)

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def express(self) -> Optional[str]:
        """
        The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "express")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigFilterFilter']] = None,
                 relation: Optional[str] = None):
        """
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigFilterFilterArgs'] filters: The conditions that are used to filter logs imported from Log Service. See `filters` below.
        :param str relation: The relationship between multiple filter conditions. Valid values: `and`(default value), `or`.
        """
        HybridMonitorSlsTaskSlsProcessConfigFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            relation=relation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigFilterFilter']] = None,
             relation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if filters is not None:
            _setter("filters", filters)
        if relation is not None:
            _setter("relation", relation)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigFilterFilter']]:
        """
        The conditions that are used to filter logs imported from Log Service. See `filters` below.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def relation(self) -> Optional[str]:
        """
        The relationship between multiple filter conditions. Valid values: `and`(default value), `or`.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slsKeyName":
            suggest = "sls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfigFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 sls_key_name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: The method that is used to filter logs imported from Log Service. Valid values: `>`, `>=`, `=`, `<=`, `<`, `!=`, `contain`, `notContain`.
        :param str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        :param str value: The tag value of the metric.
        """
        HybridMonitorSlsTaskSlsProcessConfigFilterFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            sls_key_name=sls_key_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[str] = None,
             sls_key_name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sls_key_name is None and 'slsKeyName' in kwargs:
            sls_key_name = kwargs['slsKeyName']

        if operator is not None:
            _setter("operator", operator)
        if sls_key_name is not None:
            _setter("sls_key_name", sls_key_name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The method that is used to filter logs imported from Log Service. Valid values: `>`, `>=`, `=`, `<=`, `<`, `!=`, `contain`, `notContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> Optional[str]:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value of the metric.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slsKeyName":
            suggest = "sls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfigGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[str] = None,
                 sls_key_name: Optional[str] = None):
        """
        :param str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        HybridMonitorSlsTaskSlsProcessConfigGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            sls_key_name=sls_key_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             sls_key_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sls_key_name is None and 'slsKeyName' in kwargs:
            sls_key_name = kwargs['slsKeyName']

        if alias is not None:
            _setter("alias", alias)
        if sls_key_name is not None:
            _setter("sls_key_name", sls_key_name)

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> Optional[str]:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigStatistic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterOne":
            suggest = "parameter_one"
        elif key == "parameterTwo":
            suggest = "parameter_two"
        elif key == "slsKeyName":
            suggest = "sls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfigStatistic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigStatistic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigStatistic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[str] = None,
                 function: Optional[str] = None,
                 parameter_one: Optional[str] = None,
                 parameter_two: Optional[str] = None,
                 sls_key_name: Optional[str] = None):
        """
        :param str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param str function: The function that is used to aggregate log data within a statistical period. Valid values: `count`, `sum`, `avg`, `max`, `min`, `value`, `countps`, `sumps`, `distinct`, `distribution`, `percentile`.
        :param str parameter_one: The value of the function that is used to aggregate logs imported from Log Service.
               - If you set the `function` parameter to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
               - If you set the `function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
        :param str parameter_two: The value of the function that is used to aggregate logs imported from Log Service. **Note:** This parameter is required only if the `function` parameter is set to `distribution`. This parameter specifies the upper limit of the statistical interval.
        :param str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        HybridMonitorSlsTaskSlsProcessConfigStatistic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            function=function,
            parameter_one=parameter_one,
            parameter_two=parameter_two,
            sls_key_name=sls_key_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             function: Optional[str] = None,
             parameter_one: Optional[str] = None,
             parameter_two: Optional[str] = None,
             sls_key_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if parameter_one is None and 'parameterOne' in kwargs:
            parameter_one = kwargs['parameterOne']
        if parameter_two is None and 'parameterTwo' in kwargs:
            parameter_two = kwargs['parameterTwo']
        if sls_key_name is None and 'slsKeyName' in kwargs:
            sls_key_name = kwargs['slsKeyName']

        if alias is not None:
            _setter("alias", alias)
        if function is not None:
            _setter("function", function)
        if parameter_one is not None:
            _setter("parameter_one", parameter_one)
        if parameter_two is not None:
            _setter("parameter_two", parameter_two)
        if sls_key_name is not None:
            _setter("sls_key_name", sls_key_name)

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        """
        The function that is used to aggregate log data within a statistical period. Valid values: `count`, `sum`, `avg`, `max`, `min`, `value`, `countps`, `sumps`, `distinct`, `distribution`, `percentile`.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter(name="parameterOne")
    def parameter_one(self) -> Optional[str]:
        """
        The value of the function that is used to aggregate logs imported from Log Service.
        - If you set the `function` parameter to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
        - If you set the `function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
        """
        return pulumi.get(self, "parameter_one")

    @property
    @pulumi.getter(name="parameterTwo")
    def parameter_two(self) -> Optional[str]:
        """
        The value of the function that is used to aggregate logs imported from Log Service. **Note:** This parameter is required only if the `function` parameter is set to `distribution`. This parameter specifies the upper limit of the statistical interval.
        """
        return pulumi.get(self, "parameter_two")

    @property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> Optional[str]:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class MetricRuleBlackListMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleBlackListMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleBlackListMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleBlackListMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 resource: Optional[str] = None):
        """
        :param str metric_name: The name of the monitoring indicator.
        :param str resource: The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        MetricRuleBlackListMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: Optional[str] = None,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")

        _setter("metric_name", metric_name)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the monitoring indicator.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class MetricRuleTemplateAlertTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "ruleName":
            suggest = "rule_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 metric_name: str,
                 namespace: str,
                 rule_name: str,
                 escalations: Optional['outputs.MetricRuleTemplateAlertTemplateEscalations'] = None,
                 webhook: Optional[str] = None):
        """
        :param str category: The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iot_edge`, `kvstore_sharding`, `kvstore_splitrw`, `kvstore_standard`, `memcache`, `mns`, `mongodb`, `mongodb_cluster`, `mongodb_sharding`, `mq_topic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
        :param str metric_name: The name of the metric.
               
               > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        :param str namespace: The namespace of the service.
               
               > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        :param str rule_name: The name of the alert rule.
        :param 'MetricRuleTemplateAlertTemplateEscalationsArgs' escalations: The information about the trigger condition based on the alert level. See `escalations` below.
        :param str webhook: The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        MetricRuleTemplateAlertTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            metric_name=metric_name,
            namespace=namespace,
            rule_name=rule_name,
            escalations=escalations,
            webhook=webhook,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             metric_name: Optional[str] = None,
             namespace: Optional[str] = None,
             rule_name: Optional[str] = None,
             escalations: Optional['outputs.MetricRuleTemplateAlertTemplateEscalations'] = None,
             webhook: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if rule_name is None and 'ruleName' in kwargs:
            rule_name = kwargs['ruleName']
        if rule_name is None:
            raise TypeError("Missing 'rule_name' argument")

        _setter("category", category)
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("rule_name", rule_name)
        if escalations is not None:
            _setter("escalations", escalations)
        if webhook is not None:
            _setter("webhook", webhook)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iot_edge`, `kvstore_sharding`, `kvstore_splitrw`, `kvstore_standard`, `memcache`, `mns`, `mongodb`, `mongodb_cluster`, `mongodb_sharding`, `mq_topic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric.

        > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace of the service.

        > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter
    def escalations(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalations']:
        """
        The information about the trigger condition based on the alert level. See `escalations` below.
        """
        return pulumi.get(self, "escalations")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalations(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsCritical'] = None,
                 info: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsInfo'] = None,
                 warn: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsWarn'] = None):
        """
        :param 'MetricRuleTemplateAlertTemplateEscalationsCriticalArgs' critical: The condition for triggering critical-level alerts. See `critical` below.
        :param 'MetricRuleTemplateAlertTemplateEscalationsInfoArgs' info: The condition for triggering info-level alerts. See `info` below.
        :param 'MetricRuleTemplateAlertTemplateEscalationsWarnArgs' warn: The condition for triggering warn-level alerts. See `warn` below.
        """
        MetricRuleTemplateAlertTemplateEscalations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            critical=critical,
            info=info,
            warn=warn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             critical: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsCritical'] = None,
             info: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsInfo'] = None,
             warn: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsWarn'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if critical is not None:
            _setter("critical", critical)
        if info is not None:
            _setter("info", info)
        if warn is not None:
            _setter("warn", warn)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsCritical']:
        """
        The condition for triggering critical-level alerts. See `critical` below.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def info(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsInfo']:
        """
        The condition for triggering info-level alerts. See `info` below.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def warn(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsWarn']:
        """
        The condition for triggering warn-level alerts. See `warn` below.
        """
        return pulumi.get(self, "warn")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalationsCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplateEscalationsCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[str] = None):
        """
        :param str comparison_operator: The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param str statistics: The statistical aggregation method for critical-level alerts.
        :param str threshold: The threshold for critical-level alerts.
        :param str times: The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        MetricRuleTemplateAlertTemplateEscalationsCritical._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        The statistical aggregation method for critical-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        The threshold for critical-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[str]:
        """
        The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalationsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplateEscalationsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[str] = None):
        """
        :param str comparison_operator: The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param str statistics: The statistical aggregation method for critical-level alerts.
        :param str threshold: The threshold for critical-level alerts.
        :param str times: The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        MetricRuleTemplateAlertTemplateEscalationsInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        The statistical aggregation method for critical-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        The threshold for critical-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[str]:
        """
        The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalationsWarn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplateEscalationsWarn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsWarn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsWarn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[str] = None,
                 statistics: Optional[str] = None,
                 threshold: Optional[str] = None,
                 times: Optional[str] = None):
        """
        :param str comparison_operator: The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param str statistics: The statistical aggregation method for critical-level alerts.
        :param str threshold: The threshold for critical-level alerts.
        :param str times: The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        MetricRuleTemplateAlertTemplateEscalationsWarn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']

        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if statistics is not None:
            _setter("statistics", statistics)
        if threshold is not None:
            _setter("threshold", threshold)
        if times is not None:
            _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The comparison operator of the threshold for critical-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> Optional[str]:
        """
        The statistical aggregation method for critical-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[str]:
        """
        The threshold for critical-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> Optional[str]:
        """
        The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class MonitorGroupInstancesInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "regionId":
            suggest = "region_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorGroupInstancesInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorGroupInstancesInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorGroupInstancesInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 instance_id: str,
                 instance_name: str,
                 region_id: str):
        """
        :param str category: The category of instance.
        :param str instance_id: The id of instance.
        :param str instance_name: The name of instance.
        :param str region_id: The region id of instance.
        """
        MonitorGroupInstancesInstance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            instance_id=instance_id,
            instance_name=instance_name,
            region_id=region_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_name: Optional[str] = None,
             region_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")

        _setter("category", category)
        _setter("instance_id", instance_id)
        _setter("instance_name", instance_name)
        _setter("region_id", region_id)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of instance.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The id of instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        The name of instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        """
        The region id of instance.
        """
        return pulumi.get(self, "region_id")


@pulumi.output_type
class SiteMonitorIspCity(dict):
    def __init__(__self__, *,
                 city: str,
                 isp: str):
        """
        :param str city: The ID of the city.
        :param str isp: The ID of the carrier.
        """
        SiteMonitorIspCity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            isp=isp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             isp: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if city is None:
            raise TypeError("Missing 'city' argument")
        if isp is None:
            raise TypeError("Missing 'isp' argument")

        _setter("city", city)
        _setter("isp", isp)

    @property
    @pulumi.getter
    def city(self) -> str:
        """
        The ID of the city.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def isp(self) -> str:
        """
        The ID of the carrier.
        """
        return pulumi.get(self, "isp")


@pulumi.output_type
class SlsGroupSlsGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slsLogstore":
            suggest = "sls_logstore"
        elif key == "slsProject":
            suggest = "sls_project"
        elif key == "slsRegion":
            suggest = "sls_region"
        elif key == "slsUserId":
            suggest = "sls_user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlsGroupSlsGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlsGroupSlsGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlsGroupSlsGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sls_logstore: str,
                 sls_project: str,
                 sls_region: str,
                 sls_user_id: Optional[str] = None):
        """
        :param str sls_logstore: The name of the Log Store.
        :param str sls_project: The name of the Project.
        :param str sls_region: The Sls Region.
        :param str sls_user_id: The ID of the Sls User.
        """
        SlsGroupSlsGroupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sls_logstore=sls_logstore,
            sls_project=sls_project,
            sls_region=sls_region,
            sls_user_id=sls_user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sls_logstore: Optional[str] = None,
             sls_project: Optional[str] = None,
             sls_region: Optional[str] = None,
             sls_user_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sls_logstore is None and 'slsLogstore' in kwargs:
            sls_logstore = kwargs['slsLogstore']
        if sls_logstore is None:
            raise TypeError("Missing 'sls_logstore' argument")
        if sls_project is None and 'slsProject' in kwargs:
            sls_project = kwargs['slsProject']
        if sls_project is None:
            raise TypeError("Missing 'sls_project' argument")
        if sls_region is None and 'slsRegion' in kwargs:
            sls_region = kwargs['slsRegion']
        if sls_region is None:
            raise TypeError("Missing 'sls_region' argument")
        if sls_user_id is None and 'slsUserId' in kwargs:
            sls_user_id = kwargs['slsUserId']

        _setter("sls_logstore", sls_logstore)
        _setter("sls_project", sls_project)
        _setter("sls_region", sls_region)
        if sls_user_id is not None:
            _setter("sls_user_id", sls_user_id)

    @property
    @pulumi.getter(name="slsLogstore")
    def sls_logstore(self) -> str:
        """
        The name of the Log Store.
        """
        return pulumi.get(self, "sls_logstore")

    @property
    @pulumi.getter(name="slsProject")
    def sls_project(self) -> str:
        """
        The name of the Project.
        """
        return pulumi.get(self, "sls_project")

    @property
    @pulumi.getter(name="slsRegion")
    def sls_region(self) -> str:
        """
        The Sls Region.
        """
        return pulumi.get(self, "sls_region")

    @property
    @pulumi.getter(name="slsUserId")
    def sls_user_id(self) -> Optional[str]:
        """
        The ID of the Sls User.
        """
        return pulumi.get(self, "sls_user_id")


@pulumi.output_type
class GetAlarmContactGroupsGroupResult(dict):
    def __init__(__self__, *,
                 alarm_contact_group_name: str,
                 contacts: Sequence[str],
                 describe: str,
                 enable_subscribed: bool,
                 id: str):
        """
        :param str alarm_contact_group_name: The name of Alarm Contact Group.
        :param Sequence[str] contacts: The alarm contacts in the alarm group.
        :param str describe: The description of the Alarm Group.
        :param bool enable_subscribed: Indicates whether the alarm group subscribes to weekly reports.
        :param str id: The ID of the CMS.
        """
        GetAlarmContactGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarm_contact_group_name=alarm_contact_group_name,
            contacts=contacts,
            describe=describe,
            enable_subscribed=enable_subscribed,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarm_contact_group_name: Optional[str] = None,
             contacts: Optional[Sequence[str]] = None,
             describe: Optional[str] = None,
             enable_subscribed: Optional[bool] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alarm_contact_group_name is None and 'alarmContactGroupName' in kwargs:
            alarm_contact_group_name = kwargs['alarmContactGroupName']
        if alarm_contact_group_name is None:
            raise TypeError("Missing 'alarm_contact_group_name' argument")
        if contacts is None:
            raise TypeError("Missing 'contacts' argument")
        if describe is None:
            raise TypeError("Missing 'describe' argument")
        if enable_subscribed is None and 'enableSubscribed' in kwargs:
            enable_subscribed = kwargs['enableSubscribed']
        if enable_subscribed is None:
            raise TypeError("Missing 'enable_subscribed' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("alarm_contact_group_name", alarm_contact_group_name)
        _setter("contacts", contacts)
        _setter("describe", describe)
        _setter("enable_subscribed", enable_subscribed)
        _setter("id", id)

    @property
    @pulumi.getter(name="alarmContactGroupName")
    def alarm_contact_group_name(self) -> str:
        """
        The name of Alarm Contact Group.
        """
        return pulumi.get(self, "alarm_contact_group_name")

    @property
    @pulumi.getter
    def contacts(self) -> Sequence[str]:
        """
        The alarm contacts in the alarm group.
        """
        return pulumi.get(self, "contacts")

    @property
    @pulumi.getter
    def describe(self) -> str:
        """
        The description of the Alarm Group.
        """
        return pulumi.get(self, "describe")

    @property
    @pulumi.getter(name="enableSubscribed")
    def enable_subscribed(self) -> bool:
        """
        Indicates whether the alarm group subscribes to weekly reports.
        """
        return pulumi.get(self, "enable_subscribed")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the CMS.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAlarmContactsContactResult(dict):
    def __init__(__self__, *,
                 alarm_contact_name: str,
                 channels_aliim: str,
                 channels_ding_web_hook: str,
                 channels_mail: str,
                 channels_sms: str,
                 channels_state_aliim: str,
                 channels_state_ding_web_hook: str,
                 channels_state_mail: str,
                 channels_status_sms: str,
                 contact_groups: Sequence[str],
                 describe: str,
                 id: str,
                 lang: str):
        """
        :param str alarm_contact_name: The name of the alarm contact.
        :param str channels_aliim: The TradeManager ID of the alarm contact.
        :param str channels_ding_web_hook: The webhook URL of the DingTalk chatbot.
        :param str channels_mail: The email address of the alarm contact.
        :param str channels_sms: The phone number of the alarm contact.
        :param str channels_state_aliim: Indicates whether the TradeManager ID is valid.
        :param str channels_state_ding_web_hook: Indicates whether the DingTalk chatbot is normal.
        :param str channels_state_mail: The status of the email address.
        :param str channels_status_sms: The status of the phone number.
        :param Sequence[str] contact_groups: The alert groups to which the alarm contact is added.
        :param str describe: The description of the alarm contact.
        :param str id: The ID of the alarm contact.
        """
        GetAlarmContactsContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarm_contact_name=alarm_contact_name,
            channels_aliim=channels_aliim,
            channels_ding_web_hook=channels_ding_web_hook,
            channels_mail=channels_mail,
            channels_sms=channels_sms,
            channels_state_aliim=channels_state_aliim,
            channels_state_ding_web_hook=channels_state_ding_web_hook,
            channels_state_mail=channels_state_mail,
            channels_status_sms=channels_status_sms,
            contact_groups=contact_groups,
            describe=describe,
            id=id,
            lang=lang,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarm_contact_name: Optional[str] = None,
             channels_aliim: Optional[str] = None,
             channels_ding_web_hook: Optional[str] = None,
             channels_mail: Optional[str] = None,
             channels_sms: Optional[str] = None,
             channels_state_aliim: Optional[str] = None,
             channels_state_ding_web_hook: Optional[str] = None,
             channels_state_mail: Optional[str] = None,
             channels_status_sms: Optional[str] = None,
             contact_groups: Optional[Sequence[str]] = None,
             describe: Optional[str] = None,
             id: Optional[str] = None,
             lang: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alarm_contact_name is None and 'alarmContactName' in kwargs:
            alarm_contact_name = kwargs['alarmContactName']
        if alarm_contact_name is None:
            raise TypeError("Missing 'alarm_contact_name' argument")
        if channels_aliim is None and 'channelsAliim' in kwargs:
            channels_aliim = kwargs['channelsAliim']
        if channels_aliim is None:
            raise TypeError("Missing 'channels_aliim' argument")
        if channels_ding_web_hook is None and 'channelsDingWebHook' in kwargs:
            channels_ding_web_hook = kwargs['channelsDingWebHook']
        if channels_ding_web_hook is None:
            raise TypeError("Missing 'channels_ding_web_hook' argument")
        if channels_mail is None and 'channelsMail' in kwargs:
            channels_mail = kwargs['channelsMail']
        if channels_mail is None:
            raise TypeError("Missing 'channels_mail' argument")
        if channels_sms is None and 'channelsSms' in kwargs:
            channels_sms = kwargs['channelsSms']
        if channels_sms is None:
            raise TypeError("Missing 'channels_sms' argument")
        if channels_state_aliim is None and 'channelsStateAliim' in kwargs:
            channels_state_aliim = kwargs['channelsStateAliim']
        if channels_state_aliim is None:
            raise TypeError("Missing 'channels_state_aliim' argument")
        if channels_state_ding_web_hook is None and 'channelsStateDingWebHook' in kwargs:
            channels_state_ding_web_hook = kwargs['channelsStateDingWebHook']
        if channels_state_ding_web_hook is None:
            raise TypeError("Missing 'channels_state_ding_web_hook' argument")
        if channels_state_mail is None and 'channelsStateMail' in kwargs:
            channels_state_mail = kwargs['channelsStateMail']
        if channels_state_mail is None:
            raise TypeError("Missing 'channels_state_mail' argument")
        if channels_status_sms is None and 'channelsStatusSms' in kwargs:
            channels_status_sms = kwargs['channelsStatusSms']
        if channels_status_sms is None:
            raise TypeError("Missing 'channels_status_sms' argument")
        if contact_groups is None and 'contactGroups' in kwargs:
            contact_groups = kwargs['contactGroups']
        if contact_groups is None:
            raise TypeError("Missing 'contact_groups' argument")
        if describe is None:
            raise TypeError("Missing 'describe' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if lang is None:
            raise TypeError("Missing 'lang' argument")

        _setter("alarm_contact_name", alarm_contact_name)
        _setter("channels_aliim", channels_aliim)
        _setter("channels_ding_web_hook", channels_ding_web_hook)
        _setter("channels_mail", channels_mail)
        _setter("channels_sms", channels_sms)
        _setter("channels_state_aliim", channels_state_aliim)
        _setter("channels_state_ding_web_hook", channels_state_ding_web_hook)
        _setter("channels_state_mail", channels_state_mail)
        _setter("channels_status_sms", channels_status_sms)
        _setter("contact_groups", contact_groups)
        _setter("describe", describe)
        _setter("id", id)
        _setter("lang", lang)

    @property
    @pulumi.getter(name="alarmContactName")
    def alarm_contact_name(self) -> str:
        """
        The name of the alarm contact.
        """
        return pulumi.get(self, "alarm_contact_name")

    @property
    @pulumi.getter(name="channelsAliim")
    def channels_aliim(self) -> str:
        """
        The TradeManager ID of the alarm contact.
        """
        return pulumi.get(self, "channels_aliim")

    @property
    @pulumi.getter(name="channelsDingWebHook")
    def channels_ding_web_hook(self) -> str:
        """
        The webhook URL of the DingTalk chatbot.
        """
        return pulumi.get(self, "channels_ding_web_hook")

    @property
    @pulumi.getter(name="channelsMail")
    def channels_mail(self) -> str:
        """
        The email address of the alarm contact.
        """
        return pulumi.get(self, "channels_mail")

    @property
    @pulumi.getter(name="channelsSms")
    def channels_sms(self) -> str:
        """
        The phone number of the alarm contact.
        """
        return pulumi.get(self, "channels_sms")

    @property
    @pulumi.getter(name="channelsStateAliim")
    def channels_state_aliim(self) -> str:
        """
        Indicates whether the TradeManager ID is valid.
        """
        return pulumi.get(self, "channels_state_aliim")

    @property
    @pulumi.getter(name="channelsStateDingWebHook")
    def channels_state_ding_web_hook(self) -> str:
        """
        Indicates whether the DingTalk chatbot is normal.
        """
        return pulumi.get(self, "channels_state_ding_web_hook")

    @property
    @pulumi.getter(name="channelsStateMail")
    def channels_state_mail(self) -> str:
        """
        The status of the email address.
        """
        return pulumi.get(self, "channels_state_mail")

    @property
    @pulumi.getter(name="channelsStatusSms")
    def channels_status_sms(self) -> str:
        """
        The status of the phone number.
        """
        return pulumi.get(self, "channels_status_sms")

    @property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> Sequence[str]:
        """
        The alert groups to which the alarm contact is added.
        """
        return pulumi.get(self, "contact_groups")

    @property
    @pulumi.getter
    def describe(self) -> str:
        """
        The description of the alarm contact.
        """
        return pulumi.get(self, "describe")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the alarm contact.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def lang(self) -> str:
        return pulumi.get(self, "lang")


@pulumi.output_type
class GetDynamicTagGroupsGroupResult(dict):
    def __init__(__self__, *,
                 dynamic_tag_rule_id: str,
                 id: str,
                 match_express_filter_relation: str,
                 match_expresses: Sequence['outputs.GetDynamicTagGroupsGroupMatchExpressResult'],
                 status: str,
                 tag_key: str):
        """
        :param str dynamic_tag_rule_id: The ID of the tag rule.
        :param str id: The ID of the Dynamic Tag Group.
        :param str match_express_filter_relation: The relationship between conditional expressions. Valid values: `and`, `or`.
        :param Sequence['GetDynamicTagGroupsGroupMatchExpressArgs'] match_expresses: The label generates a matching expression that applies the grouping. See the following `Block match_express`.
        :param str status: The status of the resource. Valid values: `RUNNING`, `FINISH`.
        :param str tag_key: The tag key of the tag.
        """
        GetDynamicTagGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamic_tag_rule_id=dynamic_tag_rule_id,
            id=id,
            match_express_filter_relation=match_express_filter_relation,
            match_expresses=match_expresses,
            status=status,
            tag_key=tag_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamic_tag_rule_id: Optional[str] = None,
             id: Optional[str] = None,
             match_express_filter_relation: Optional[str] = None,
             match_expresses: Optional[Sequence['outputs.GetDynamicTagGroupsGroupMatchExpressResult']] = None,
             status: Optional[str] = None,
             tag_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dynamic_tag_rule_id is None and 'dynamicTagRuleId' in kwargs:
            dynamic_tag_rule_id = kwargs['dynamicTagRuleId']
        if dynamic_tag_rule_id is None:
            raise TypeError("Missing 'dynamic_tag_rule_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if match_express_filter_relation is None and 'matchExpressFilterRelation' in kwargs:
            match_express_filter_relation = kwargs['matchExpressFilterRelation']
        if match_express_filter_relation is None:
            raise TypeError("Missing 'match_express_filter_relation' argument")
        if match_expresses is None and 'matchExpresses' in kwargs:
            match_expresses = kwargs['matchExpresses']
        if match_expresses is None:
            raise TypeError("Missing 'match_expresses' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tag_key is None and 'tagKey' in kwargs:
            tag_key = kwargs['tagKey']
        if tag_key is None:
            raise TypeError("Missing 'tag_key' argument")

        _setter("dynamic_tag_rule_id", dynamic_tag_rule_id)
        _setter("id", id)
        _setter("match_express_filter_relation", match_express_filter_relation)
        _setter("match_expresses", match_expresses)
        _setter("status", status)
        _setter("tag_key", tag_key)

    @property
    @pulumi.getter(name="dynamicTagRuleId")
    def dynamic_tag_rule_id(self) -> str:
        """
        The ID of the tag rule.
        """
        return pulumi.get(self, "dynamic_tag_rule_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Dynamic Tag Group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="matchExpressFilterRelation")
    def match_express_filter_relation(self) -> str:
        """
        The relationship between conditional expressions. Valid values: `and`, `or`.
        """
        return pulumi.get(self, "match_express_filter_relation")

    @property
    @pulumi.getter(name="matchExpresses")
    def match_expresses(self) -> Sequence['outputs.GetDynamicTagGroupsGroupMatchExpressResult']:
        """
        The label generates a matching expression that applies the grouping. See the following `Block match_express`.
        """
        return pulumi.get(self, "match_expresses")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource. Valid values: `RUNNING`, `FINISH`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        The tag key of the tag.
        """
        return pulumi.get(self, "tag_key")


@pulumi.output_type
class GetDynamicTagGroupsGroupMatchExpressResult(dict):
    def __init__(__self__, *,
                 tag_value: str,
                 tag_value_match_function: str):
        """
        :param str tag_value: The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
        :param str tag_value_match_function: Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
        """
        GetDynamicTagGroupsGroupMatchExpressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_value=tag_value,
            tag_value_match_function=tag_value_match_function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_value: Optional[str] = None,
             tag_value_match_function: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tag_value is None and 'tagValue' in kwargs:
            tag_value = kwargs['tagValue']
        if tag_value is None:
            raise TypeError("Missing 'tag_value' argument")
        if tag_value_match_function is None and 'tagValueMatchFunction' in kwargs:
            tag_value_match_function = kwargs['tagValueMatchFunction']
        if tag_value_match_function is None:
            raise TypeError("Missing 'tag_value_match_function' argument")

        _setter("tag_value", tag_value)
        _setter("tag_value_match_function", tag_value_match_function)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> str:
        """
        The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
        """
        return pulumi.get(self, "tag_value")

    @property
    @pulumi.getter(name="tagValueMatchFunction")
    def tag_value_match_function(self) -> str:
        """
        Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
        """
        return pulumi.get(self, "tag_value_match_function")


@pulumi.output_type
class GetEventRulesRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 event_patterns: Sequence['outputs.GetEventRulesRuleEventPatternResult'],
                 event_rule_name: str,
                 event_type: str,
                 group_id: str,
                 id: str,
                 silence_time: int,
                 status: str):
        """
        :param str description: The description of the rule.
        :param Sequence['GetEventRulesRuleEventPatternArgs'] event_patterns: Event mode, used to describe the trigger conditions for this event.
        :param str event_rule_name: The name of the event rule.
        :param str event_type: The type of event.
        :param str group_id: The ID of the application Group.
        :param str id: The ID of the Event Rule. Its value is same as Event Rule Name.
        :param int silence_time: The mute period during which new alerts are not sent even if the trigger conditions are met.
        :param str status: The status of the resource.
        """
        GetEventRulesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            event_patterns=event_patterns,
            event_rule_name=event_rule_name,
            event_type=event_type,
            group_id=group_id,
            id=id,
            silence_time=silence_time,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             event_patterns: Optional[Sequence['outputs.GetEventRulesRuleEventPatternResult']] = None,
             event_rule_name: Optional[str] = None,
             event_type: Optional[str] = None,
             group_id: Optional[str] = None,
             id: Optional[str] = None,
             silence_time: Optional[int] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if event_patterns is None and 'eventPatterns' in kwargs:
            event_patterns = kwargs['eventPatterns']
        if event_patterns is None:
            raise TypeError("Missing 'event_patterns' argument")
        if event_rule_name is None and 'eventRuleName' in kwargs:
            event_rule_name = kwargs['eventRuleName']
        if event_rule_name is None:
            raise TypeError("Missing 'event_rule_name' argument")
        if event_type is None and 'eventType' in kwargs:
            event_type = kwargs['eventType']
        if event_type is None:
            raise TypeError("Missing 'event_type' argument")
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if silence_time is None and 'silenceTime' in kwargs:
            silence_time = kwargs['silenceTime']
        if silence_time is None:
            raise TypeError("Missing 'silence_time' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("description", description)
        _setter("event_patterns", event_patterns)
        _setter("event_rule_name", event_rule_name)
        _setter("event_type", event_type)
        _setter("group_id", group_id)
        _setter("id", id)
        _setter("silence_time", silence_time)
        _setter("status", status)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence['outputs.GetEventRulesRuleEventPatternResult']:
        """
        Event mode, used to describe the trigger conditions for this event.
        """
        return pulumi.get(self, "event_patterns")

    @property
    @pulumi.getter(name="eventRuleName")
    def event_rule_name(self) -> str:
        """
        The name of the event rule.
        """
        return pulumi.get(self, "event_rule_name")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        The type of event.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The ID of the application Group.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Event Rule. Its value is same as Event Rule Name.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="silenceTime")
    def silence_time(self) -> int:
        """
        The mute period during which new alerts are not sent even if the trigger conditions are met.
        """
        return pulumi.get(self, "silence_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEventRulesRuleEventPatternResult(dict):
    def __init__(__self__, *,
                 event_type_lists: Sequence[str],
                 keyword_filters: Sequence['outputs.GetEventRulesRuleEventPatternKeywordFilterResult'],
                 level_lists: Sequence[str],
                 name_lists: Sequence[str],
                 product: str,
                 sql_filter: str):
        """
        :param Sequence[str] event_type_lists: The list of event types.
        :param Sequence['GetEventRulesRuleEventPatternKeywordFilterArgs'] keyword_filters: The filter keyword.
        :param Sequence[str] level_lists: The list of event levels.
        :param Sequence[str] name_lists: The list of event names.
        :param str product: The type of the cloud service.
        :param str sql_filter: The SQL condition that is used to filter events.
        """
        GetEventRulesRuleEventPatternResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_type_lists=event_type_lists,
            keyword_filters=keyword_filters,
            level_lists=level_lists,
            name_lists=name_lists,
            product=product,
            sql_filter=sql_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_type_lists: Optional[Sequence[str]] = None,
             keyword_filters: Optional[Sequence['outputs.GetEventRulesRuleEventPatternKeywordFilterResult']] = None,
             level_lists: Optional[Sequence[str]] = None,
             name_lists: Optional[Sequence[str]] = None,
             product: Optional[str] = None,
             sql_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if event_type_lists is None and 'eventTypeLists' in kwargs:
            event_type_lists = kwargs['eventTypeLists']
        if event_type_lists is None:
            raise TypeError("Missing 'event_type_lists' argument")
        if keyword_filters is None and 'keywordFilters' in kwargs:
            keyword_filters = kwargs['keywordFilters']
        if keyword_filters is None:
            raise TypeError("Missing 'keyword_filters' argument")
        if level_lists is None and 'levelLists' in kwargs:
            level_lists = kwargs['levelLists']
        if level_lists is None:
            raise TypeError("Missing 'level_lists' argument")
        if name_lists is None and 'nameLists' in kwargs:
            name_lists = kwargs['nameLists']
        if name_lists is None:
            raise TypeError("Missing 'name_lists' argument")
        if product is None:
            raise TypeError("Missing 'product' argument")
        if sql_filter is None and 'sqlFilter' in kwargs:
            sql_filter = kwargs['sqlFilter']
        if sql_filter is None:
            raise TypeError("Missing 'sql_filter' argument")

        _setter("event_type_lists", event_type_lists)
        _setter("keyword_filters", keyword_filters)
        _setter("level_lists", level_lists)
        _setter("name_lists", name_lists)
        _setter("product", product)
        _setter("sql_filter", sql_filter)

    @property
    @pulumi.getter(name="eventTypeLists")
    def event_type_lists(self) -> Sequence[str]:
        """
        The list of event types.
        """
        return pulumi.get(self, "event_type_lists")

    @property
    @pulumi.getter(name="keywordFilters")
    def keyword_filters(self) -> Sequence['outputs.GetEventRulesRuleEventPatternKeywordFilterResult']:
        """
        The filter keyword.
        """
        return pulumi.get(self, "keyword_filters")

    @property
    @pulumi.getter(name="levelLists")
    def level_lists(self) -> Sequence[str]:
        """
        The list of event levels.
        """
        return pulumi.get(self, "level_lists")

    @property
    @pulumi.getter(name="nameLists")
    def name_lists(self) -> Sequence[str]:
        """
        The list of event names.
        """
        return pulumi.get(self, "name_lists")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        The type of the cloud service.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter(name="sqlFilter")
    def sql_filter(self) -> str:
        """
        The SQL condition that is used to filter events.
        """
        return pulumi.get(self, "sql_filter")


@pulumi.output_type
class GetEventRulesRuleEventPatternKeywordFilterResult(dict):
    def __init__(__self__, *,
                 key_words: Sequence[str],
                 relation: str):
        """
        :param Sequence[str] key_words: The keywords that are used to match events.
        :param str relation: The relationship between multiple keywords in a condition.
        """
        GetEventRulesRuleEventPatternKeywordFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_words=key_words,
            relation=relation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_words: Optional[Sequence[str]] = None,
             relation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_words is None and 'keyWords' in kwargs:
            key_words = kwargs['keyWords']
        if key_words is None:
            raise TypeError("Missing 'key_words' argument")
        if relation is None:
            raise TypeError("Missing 'relation' argument")

        _setter("key_words", key_words)
        _setter("relation", relation)

    @property
    @pulumi.getter(name="keyWords")
    def key_words(self) -> Sequence[str]:
        """
        The keywords that are used to match events.
        """
        return pulumi.get(self, "key_words")

    @property
    @pulumi.getter
    def relation(self) -> str:
        """
        The relationship between multiple keywords in a condition.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class GetGroupMetricRulesRuleResult(dict):
    def __init__(__self__, *,
                 contact_groups: str,
                 dimensions: str,
                 effective_interval: str,
                 email_subject: str,
                 enable_state: bool,
                 escalations: Sequence['outputs.GetGroupMetricRulesRuleEscalationResult'],
                 group_id: str,
                 group_metric_rule_name: str,
                 id: str,
                 metric_name: str,
                 namespace: str,
                 no_effective_interval: str,
                 period: int,
                 resources: str,
                 rule_id: str,
                 silence_time: int,
                 source_type: str,
                 status: str,
                 webhook: str):
        """
        :param str contact_groups: Alarm contact group.
        :param str dimensions: The dimensions that specify the resources to be associated with the alert rule.
        :param str effective_interval: The time period during which the alert rule is effective.
        :param str email_subject: The subject of the alert notification email.
        :param bool enable_state: Indicates whether the alert rule is enabled.
        :param Sequence['GetGroupMetricRulesRuleEscalationArgs'] escalations: Alarm level.
        :param str group_id: The ID of the application group.
        :param str group_metric_rule_name: The name of the alert rule.
        :param str id: The ID of the Group Metric Rule.
        :param str metric_name: The name of the metric.
        :param str namespace: The namespace of the service.
        :param str no_effective_interval: The time period during which the alert rule is ineffective.
        :param int period: The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
        :param str resources: The resources that are associated with the alert rule.
        :param str rule_id: The ID of the alert rule.
        :param int silence_time: The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
        :param str source_type: The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
        :param str status: The status of Group Metric Rule..
        :param str webhook: The callback URL.
        """
        GetGroupMetricRulesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contact_groups=contact_groups,
            dimensions=dimensions,
            effective_interval=effective_interval,
            email_subject=email_subject,
            enable_state=enable_state,
            escalations=escalations,
            group_id=group_id,
            group_metric_rule_name=group_metric_rule_name,
            id=id,
            metric_name=metric_name,
            namespace=namespace,
            no_effective_interval=no_effective_interval,
            period=period,
            resources=resources,
            rule_id=rule_id,
            silence_time=silence_time,
            source_type=source_type,
            status=status,
            webhook=webhook,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contact_groups: Optional[str] = None,
             dimensions: Optional[str] = None,
             effective_interval: Optional[str] = None,
             email_subject: Optional[str] = None,
             enable_state: Optional[bool] = None,
             escalations: Optional[Sequence['outputs.GetGroupMetricRulesRuleEscalationResult']] = None,
             group_id: Optional[str] = None,
             group_metric_rule_name: Optional[str] = None,
             id: Optional[str] = None,
             metric_name: Optional[str] = None,
             namespace: Optional[str] = None,
             no_effective_interval: Optional[str] = None,
             period: Optional[int] = None,
             resources: Optional[str] = None,
             rule_id: Optional[str] = None,
             silence_time: Optional[int] = None,
             source_type: Optional[str] = None,
             status: Optional[str] = None,
             webhook: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contact_groups is None and 'contactGroups' in kwargs:
            contact_groups = kwargs['contactGroups']
        if contact_groups is None:
            raise TypeError("Missing 'contact_groups' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if effective_interval is None and 'effectiveInterval' in kwargs:
            effective_interval = kwargs['effectiveInterval']
        if effective_interval is None:
            raise TypeError("Missing 'effective_interval' argument")
        if email_subject is None and 'emailSubject' in kwargs:
            email_subject = kwargs['emailSubject']
        if email_subject is None:
            raise TypeError("Missing 'email_subject' argument")
        if enable_state is None and 'enableState' in kwargs:
            enable_state = kwargs['enableState']
        if enable_state is None:
            raise TypeError("Missing 'enable_state' argument")
        if escalations is None:
            raise TypeError("Missing 'escalations' argument")
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if group_metric_rule_name is None and 'groupMetricRuleName' in kwargs:
            group_metric_rule_name = kwargs['groupMetricRuleName']
        if group_metric_rule_name is None:
            raise TypeError("Missing 'group_metric_rule_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if no_effective_interval is None and 'noEffectiveInterval' in kwargs:
            no_effective_interval = kwargs['noEffectiveInterval']
        if no_effective_interval is None:
            raise TypeError("Missing 'no_effective_interval' argument")
        if period is None:
            raise TypeError("Missing 'period' argument")
        if resources is None:
            raise TypeError("Missing 'resources' argument")
        if rule_id is None and 'ruleId' in kwargs:
            rule_id = kwargs['ruleId']
        if rule_id is None:
            raise TypeError("Missing 'rule_id' argument")
        if silence_time is None and 'silenceTime' in kwargs:
            silence_time = kwargs['silenceTime']
        if silence_time is None:
            raise TypeError("Missing 'silence_time' argument")
        if source_type is None and 'sourceType' in kwargs:
            source_type = kwargs['sourceType']
        if source_type is None:
            raise TypeError("Missing 'source_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if webhook is None:
            raise TypeError("Missing 'webhook' argument")

        _setter("contact_groups", contact_groups)
        _setter("dimensions", dimensions)
        _setter("effective_interval", effective_interval)
        _setter("email_subject", email_subject)
        _setter("enable_state", enable_state)
        _setter("escalations", escalations)
        _setter("group_id", group_id)
        _setter("group_metric_rule_name", group_metric_rule_name)
        _setter("id", id)
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("no_effective_interval", no_effective_interval)
        _setter("period", period)
        _setter("resources", resources)
        _setter("rule_id", rule_id)
        _setter("silence_time", silence_time)
        _setter("source_type", source_type)
        _setter("status", status)
        _setter("webhook", webhook)

    @property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> str:
        """
        Alarm contact group.
        """
        return pulumi.get(self, "contact_groups")

    @property
    @pulumi.getter
    def dimensions(self) -> str:
        """
        The dimensions that specify the resources to be associated with the alert rule.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="effectiveInterval")
    def effective_interval(self) -> str:
        """
        The time period during which the alert rule is effective.
        """
        return pulumi.get(self, "effective_interval")

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> str:
        """
        The subject of the alert notification email.
        """
        return pulumi.get(self, "email_subject")

    @property
    @pulumi.getter(name="enableState")
    def enable_state(self) -> bool:
        """
        Indicates whether the alert rule is enabled.
        """
        return pulumi.get(self, "enable_state")

    @property
    @pulumi.getter
    def escalations(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationResult']:
        """
        Alarm level.
        """
        return pulumi.get(self, "escalations")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The ID of the application group.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupMetricRuleName")
    def group_metric_rule_name(self) -> str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "group_metric_rule_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Group Metric Rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace of the service.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="noEffectiveInterval")
    def no_effective_interval(self) -> str:
        """
        The time period during which the alert rule is ineffective.
        """
        return pulumi.get(self, "no_effective_interval")

    @property
    @pulumi.getter
    def period(self) -> int:
        """
        The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def resources(self) -> str:
        """
        The resources that are associated with the alert rule.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        The ID of the alert rule.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="silenceTime")
    def silence_time(self) -> int:
        """
        The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
        """
        return pulumi.get(self, "silence_time")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of Group Metric Rule..
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def webhook(self) -> str:
        """
        The callback URL.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationResult(dict):
    def __init__(__self__, *,
                 criticals: Sequence['outputs.GetGroupMetricRulesRuleEscalationCriticalResult'],
                 infos: Sequence['outputs.GetGroupMetricRulesRuleEscalationInfoResult'],
                 warns: Sequence['outputs.GetGroupMetricRulesRuleEscalationWarnResult']):
        """
        :param Sequence['GetGroupMetricRulesRuleEscalationCriticalArgs'] criticals: The critical level.
        :param Sequence['GetGroupMetricRulesRuleEscalationInfoArgs'] infos: The info level.
        :param Sequence['GetGroupMetricRulesRuleEscalationWarnArgs'] warns: The warn level.
        """
        GetGroupMetricRulesRuleEscalationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            criticals=criticals,
            infos=infos,
            warns=warns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             criticals: Optional[Sequence['outputs.GetGroupMetricRulesRuleEscalationCriticalResult']] = None,
             infos: Optional[Sequence['outputs.GetGroupMetricRulesRuleEscalationInfoResult']] = None,
             warns: Optional[Sequence['outputs.GetGroupMetricRulesRuleEscalationWarnResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if criticals is None:
            raise TypeError("Missing 'criticals' argument")
        if infos is None:
            raise TypeError("Missing 'infos' argument")
        if warns is None:
            raise TypeError("Missing 'warns' argument")

        _setter("criticals", criticals)
        _setter("infos", infos)
        _setter("warns", warns)

    @property
    @pulumi.getter
    def criticals(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationCriticalResult']:
        """
        The critical level.
        """
        return pulumi.get(self, "criticals")

    @property
    @pulumi.getter
    def infos(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationInfoResult']:
        """
        The info level.
        """
        return pulumi.get(self, "infos")

    @property
    @pulumi.getter
    def warns(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationWarnResult']:
        """
        The warn level.
        """
        return pulumi.get(self, "warns")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationCriticalResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 statistics: str,
                 threshold: str,
                 times: int):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        GetGroupMetricRulesRuleEscalationCriticalResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if times is None:
            raise TypeError("Missing 'times' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("statistics", statistics)
        _setter("threshold", threshold)
        _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationInfoResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 statistics: str,
                 threshold: str,
                 times: int):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        GetGroupMetricRulesRuleEscalationInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if times is None:
            raise TypeError("Missing 'times' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("statistics", statistics)
        _setter("threshold", threshold)
        _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationWarnResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 statistics: str,
                 threshold: str,
                 times: int):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        GetGroupMetricRulesRuleEscalationWarnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if times is None:
            raise TypeError("Missing 'times' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("statistics", statistics)
        _setter("threshold", threshold)
        _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetHybridMonitorDatasDataResult(dict):
    def __init__(__self__, *,
                 labels: Sequence['outputs.GetHybridMonitorDatasDataLabelResult'],
                 metric_name: str,
                 values: Sequence['outputs.GetHybridMonitorDatasDataValueResult']):
        """
        :param Sequence['GetHybridMonitorDatasDataLabelArgs'] labels: The label of the time dimension.
        :param str metric_name: The name of the monitoring indicator.
        :param Sequence['GetHybridMonitorDatasDataValueArgs'] values: The metric values that are collected at different timestamps.
        """
        GetHybridMonitorDatasDataResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            metric_name=metric_name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Sequence['outputs.GetHybridMonitorDatasDataLabelResult']] = None,
             metric_name: Optional[str] = None,
             values: Optional[Sequence['outputs.GetHybridMonitorDatasDataValueResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if labels is None:
            raise TypeError("Missing 'labels' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("labels", labels)
        _setter("metric_name", metric_name)
        _setter("values", values)

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetHybridMonitorDatasDataLabelResult']:
        """
        The label of the time dimension.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the monitoring indicator.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetHybridMonitorDatasDataValueResult']:
        """
        The metric values that are collected at different timestamps.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetHybridMonitorDatasDataLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Label key.
        :param str value: Label value.
        """
        GetHybridMonitorDatasDataLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Label key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Label value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorDatasDataValueResult(dict):
    def __init__(__self__, *,
                 ts: str,
                 value: str):
        """
        :param str ts: The timestamp that indicates the time when the metric value is collected. Unit: seconds.
        :param str value: Label value.
        """
        GetHybridMonitorDatasDataValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ts=ts,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ts: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ts is None:
            raise TypeError("Missing 'ts' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("ts", ts)
        _setter("value", value)

    @property
    @pulumi.getter
    def ts(self) -> str:
        """
        The timestamp that indicates the time when the metric value is collected. Unit: seconds.
        """
        return pulumi.get(self, "ts")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Label value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorFcTasksTaskResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 hybrid_monitor_fc_task_id: str,
                 id: str,
                 namespace: str,
                 target_user_id: str,
                 yarm_config: str):
        """
        :param str create_time: Create the timestamp of the monitoring task. Unit: milliseconds.
        :param str hybrid_monitor_fc_task_id: The ID of the monitoring task.
        :param str id: The ID of the Hybrid Monitor Fc Task. The value formats as `<hybrid_monitor_fc_task_id>:<namespace>`.
        :param str namespace: The index warehouse where the host belongs.
        :param str target_user_id: The ID of the member account.
        :param str yarm_config: The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
        """
        GetHybridMonitorFcTasksTaskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_time=create_time,
            hybrid_monitor_fc_task_id=hybrid_monitor_fc_task_id,
            id=id,
            namespace=namespace,
            target_user_id=target_user_id,
            yarm_config=yarm_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_time: Optional[str] = None,
             hybrid_monitor_fc_task_id: Optional[str] = None,
             id: Optional[str] = None,
             namespace: Optional[str] = None,
             target_user_id: Optional[str] = None,
             yarm_config: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if hybrid_monitor_fc_task_id is None and 'hybridMonitorFcTaskId' in kwargs:
            hybrid_monitor_fc_task_id = kwargs['hybridMonitorFcTaskId']
        if hybrid_monitor_fc_task_id is None:
            raise TypeError("Missing 'hybrid_monitor_fc_task_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if target_user_id is None and 'targetUserId' in kwargs:
            target_user_id = kwargs['targetUserId']
        if target_user_id is None:
            raise TypeError("Missing 'target_user_id' argument")
        if yarm_config is None and 'yarmConfig' in kwargs:
            yarm_config = kwargs['yarmConfig']
        if yarm_config is None:
            raise TypeError("Missing 'yarm_config' argument")

        _setter("create_time", create_time)
        _setter("hybrid_monitor_fc_task_id", hybrid_monitor_fc_task_id)
        _setter("id", id)
        _setter("namespace", namespace)
        _setter("target_user_id", target_user_id)
        _setter("yarm_config", yarm_config)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create the timestamp of the monitoring task. Unit: milliseconds.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="hybridMonitorFcTaskId")
    def hybrid_monitor_fc_task_id(self) -> str:
        """
        The ID of the monitoring task.
        """
        return pulumi.get(self, "hybrid_monitor_fc_task_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Hybrid Monitor Fc Task. The value formats as `<hybrid_monitor_fc_task_id>:<namespace>`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The index warehouse where the host belongs.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="targetUserId")
    def target_user_id(self) -> str:
        """
        The ID of the member account.
        """
        return pulumi.get(self, "target_user_id")

    @property
    @pulumi.getter(name="yarmConfig")
    def yarm_config(self) -> str:
        """
        The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
        """
        return pulumi.get(self, "yarm_config")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskResult(dict):
    def __init__(__self__, *,
                 attach_labels: Sequence['outputs.GetHybridMonitorSlsTasksTaskAttachLabelResult'],
                 collect_interval: int,
                 collect_target_endpoint: str,
                 collect_target_path: str,
                 collect_target_type: str,
                 collect_timout: int,
                 create_time: str,
                 description: str,
                 extra_info: str,
                 group_id: str,
                 hybrid_monitor_sls_task_id: str,
                 id: str,
                 instances: Sequence[str],
                 log_file_path: str,
                 log_process: str,
                 log_sample: str,
                 log_split: str,
                 match_express_relation: str,
                 match_expresses: Sequence['outputs.GetHybridMonitorSlsTasksTaskMatchExpressResult'],
                 namespace: str,
                 network_type: str,
                 sls_process: str,
                 sls_process_configs: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigResult'],
                 task_name: str,
                 task_type: str,
                 upload_region: str,
                 yarm_config: str):
        """
        :param Sequence['GetHybridMonitorSlsTasksTaskAttachLabelArgs'] attach_labels: The tags of the metric import task.
        :param int collect_interval: The interval between the cloud monitoring plug-in collecting host monitoring data.
        :param str collect_target_endpoint: The address where the cloudmonitor Plug-In collects the monitoring data of the host.
        :param str collect_target_path: When the cloud monitor Agent collects, the relative path of the collection.
        :param str collect_target_type: The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, MySQL, and AWS.
        :param int collect_timout: The timeout period for the cloudmonitor plug-in to collect host monitoring data.
        :param str create_time: Create the timestamp of the monitoring task. Unit: milliseconds.
        :param str description: Monitoring task description.
        :param str extra_info: Additional information for the instance.
        :param str group_id: The ID of the application Group.
        :param str hybrid_monitor_sls_task_id: The ID of the monitoring task.
        :param str id: The ID of the Hybrid Monitor Sls Task.
        :param Sequence[str] instances: A list of instances where monitoring data is collected in batches.
        :param str log_file_path: The path where on-premises log data is stored. On-premises log data is stored in the specified path of the host where CloudMonitor is deployed.
        :param str log_process: Local Log Monitoring and calculation method.
        :param str log_sample: The sample on-premises log.
        :param str log_split: The local log data is divided according to different matching patterns.
        :param str match_express_relation: The filter condition of the instance of the monitoring task.
        :param Sequence['GetHybridMonitorSlsTasksTaskMatchExpressArgs'] match_expresses: The matching condition of the instance in the application Group.
        :param str namespace: The namespace to which the host belongs.
        :param str network_type: The network type of the host.
        :param str sls_process: The configurations of the logs that are imported from Log Service.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigArgs'] sls_process_configs: The configurations of the logs that are imported from Log Service.
        :param str task_name: The name of the metric import task.
        :param str task_type: Monitoring Task type.
        :param str upload_region: The region where the host resides.
        """
        GetHybridMonitorSlsTasksTaskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attach_labels=attach_labels,
            collect_interval=collect_interval,
            collect_target_endpoint=collect_target_endpoint,
            collect_target_path=collect_target_path,
            collect_target_type=collect_target_type,
            collect_timout=collect_timout,
            create_time=create_time,
            description=description,
            extra_info=extra_info,
            group_id=group_id,
            hybrid_monitor_sls_task_id=hybrid_monitor_sls_task_id,
            id=id,
            instances=instances,
            log_file_path=log_file_path,
            log_process=log_process,
            log_sample=log_sample,
            log_split=log_split,
            match_express_relation=match_express_relation,
            match_expresses=match_expresses,
            namespace=namespace,
            network_type=network_type,
            sls_process=sls_process,
            sls_process_configs=sls_process_configs,
            task_name=task_name,
            task_type=task_type,
            upload_region=upload_region,
            yarm_config=yarm_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attach_labels: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskAttachLabelResult']] = None,
             collect_interval: Optional[int] = None,
             collect_target_endpoint: Optional[str] = None,
             collect_target_path: Optional[str] = None,
             collect_target_type: Optional[str] = None,
             collect_timout: Optional[int] = None,
             create_time: Optional[str] = None,
             description: Optional[str] = None,
             extra_info: Optional[str] = None,
             group_id: Optional[str] = None,
             hybrid_monitor_sls_task_id: Optional[str] = None,
             id: Optional[str] = None,
             instances: Optional[Sequence[str]] = None,
             log_file_path: Optional[str] = None,
             log_process: Optional[str] = None,
             log_sample: Optional[str] = None,
             log_split: Optional[str] = None,
             match_express_relation: Optional[str] = None,
             match_expresses: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskMatchExpressResult']] = None,
             namespace: Optional[str] = None,
             network_type: Optional[str] = None,
             sls_process: Optional[str] = None,
             sls_process_configs: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigResult']] = None,
             task_name: Optional[str] = None,
             task_type: Optional[str] = None,
             upload_region: Optional[str] = None,
             yarm_config: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attach_labels is None and 'attachLabels' in kwargs:
            attach_labels = kwargs['attachLabels']
        if attach_labels is None:
            raise TypeError("Missing 'attach_labels' argument")
        if collect_interval is None and 'collectInterval' in kwargs:
            collect_interval = kwargs['collectInterval']
        if collect_interval is None:
            raise TypeError("Missing 'collect_interval' argument")
        if collect_target_endpoint is None and 'collectTargetEndpoint' in kwargs:
            collect_target_endpoint = kwargs['collectTargetEndpoint']
        if collect_target_endpoint is None:
            raise TypeError("Missing 'collect_target_endpoint' argument")
        if collect_target_path is None and 'collectTargetPath' in kwargs:
            collect_target_path = kwargs['collectTargetPath']
        if collect_target_path is None:
            raise TypeError("Missing 'collect_target_path' argument")
        if collect_target_type is None and 'collectTargetType' in kwargs:
            collect_target_type = kwargs['collectTargetType']
        if collect_target_type is None:
            raise TypeError("Missing 'collect_target_type' argument")
        if collect_timout is None and 'collectTimout' in kwargs:
            collect_timout = kwargs['collectTimout']
        if collect_timout is None:
            raise TypeError("Missing 'collect_timout' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if extra_info is None and 'extraInfo' in kwargs:
            extra_info = kwargs['extraInfo']
        if extra_info is None:
            raise TypeError("Missing 'extra_info' argument")
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if hybrid_monitor_sls_task_id is None and 'hybridMonitorSlsTaskId' in kwargs:
            hybrid_monitor_sls_task_id = kwargs['hybridMonitorSlsTaskId']
        if hybrid_monitor_sls_task_id is None:
            raise TypeError("Missing 'hybrid_monitor_sls_task_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instances is None:
            raise TypeError("Missing 'instances' argument")
        if log_file_path is None and 'logFilePath' in kwargs:
            log_file_path = kwargs['logFilePath']
        if log_file_path is None:
            raise TypeError("Missing 'log_file_path' argument")
        if log_process is None and 'logProcess' in kwargs:
            log_process = kwargs['logProcess']
        if log_process is None:
            raise TypeError("Missing 'log_process' argument")
        if log_sample is None and 'logSample' in kwargs:
            log_sample = kwargs['logSample']
        if log_sample is None:
            raise TypeError("Missing 'log_sample' argument")
        if log_split is None and 'logSplit' in kwargs:
            log_split = kwargs['logSplit']
        if log_split is None:
            raise TypeError("Missing 'log_split' argument")
        if match_express_relation is None and 'matchExpressRelation' in kwargs:
            match_express_relation = kwargs['matchExpressRelation']
        if match_express_relation is None:
            raise TypeError("Missing 'match_express_relation' argument")
        if match_expresses is None and 'matchExpresses' in kwargs:
            match_expresses = kwargs['matchExpresses']
        if match_expresses is None:
            raise TypeError("Missing 'match_expresses' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if network_type is None and 'networkType' in kwargs:
            network_type = kwargs['networkType']
        if network_type is None:
            raise TypeError("Missing 'network_type' argument")
        if sls_process is None and 'slsProcess' in kwargs:
            sls_process = kwargs['slsProcess']
        if sls_process is None:
            raise TypeError("Missing 'sls_process' argument")
        if sls_process_configs is None and 'slsProcessConfigs' in kwargs:
            sls_process_configs = kwargs['slsProcessConfigs']
        if sls_process_configs is None:
            raise TypeError("Missing 'sls_process_configs' argument")
        if task_name is None and 'taskName' in kwargs:
            task_name = kwargs['taskName']
        if task_name is None:
            raise TypeError("Missing 'task_name' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if upload_region is None and 'uploadRegion' in kwargs:
            upload_region = kwargs['uploadRegion']
        if upload_region is None:
            raise TypeError("Missing 'upload_region' argument")
        if yarm_config is None and 'yarmConfig' in kwargs:
            yarm_config = kwargs['yarmConfig']
        if yarm_config is None:
            raise TypeError("Missing 'yarm_config' argument")

        _setter("attach_labels", attach_labels)
        _setter("collect_interval", collect_interval)
        _setter("collect_target_endpoint", collect_target_endpoint)
        _setter("collect_target_path", collect_target_path)
        _setter("collect_target_type", collect_target_type)
        _setter("collect_timout", collect_timout)
        _setter("create_time", create_time)
        _setter("description", description)
        _setter("extra_info", extra_info)
        _setter("group_id", group_id)
        _setter("hybrid_monitor_sls_task_id", hybrid_monitor_sls_task_id)
        _setter("id", id)
        _setter("instances", instances)
        _setter("log_file_path", log_file_path)
        _setter("log_process", log_process)
        _setter("log_sample", log_sample)
        _setter("log_split", log_split)
        _setter("match_express_relation", match_express_relation)
        _setter("match_expresses", match_expresses)
        _setter("namespace", namespace)
        _setter("network_type", network_type)
        _setter("sls_process", sls_process)
        _setter("sls_process_configs", sls_process_configs)
        _setter("task_name", task_name)
        _setter("task_type", task_type)
        _setter("upload_region", upload_region)
        _setter("yarm_config", yarm_config)

    @property
    @pulumi.getter(name="attachLabels")
    def attach_labels(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskAttachLabelResult']:
        """
        The tags of the metric import task.
        """
        return pulumi.get(self, "attach_labels")

    @property
    @pulumi.getter(name="collectInterval")
    def collect_interval(self) -> int:
        """
        The interval between the cloud monitoring plug-in collecting host monitoring data.
        """
        return pulumi.get(self, "collect_interval")

    @property
    @pulumi.getter(name="collectTargetEndpoint")
    def collect_target_endpoint(self) -> str:
        """
        The address where the cloudmonitor Plug-In collects the monitoring data of the host.
        """
        return pulumi.get(self, "collect_target_endpoint")

    @property
    @pulumi.getter(name="collectTargetPath")
    def collect_target_path(self) -> str:
        """
        When the cloud monitor Agent collects, the relative path of the collection.
        """
        return pulumi.get(self, "collect_target_path")

    @property
    @pulumi.getter(name="collectTargetType")
    def collect_target_type(self) -> str:
        """
        The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, MySQL, and AWS.
        """
        return pulumi.get(self, "collect_target_type")

    @property
    @pulumi.getter(name="collectTimout")
    def collect_timout(self) -> int:
        """
        The timeout period for the cloudmonitor plug-in to collect host monitoring data.
        """
        return pulumi.get(self, "collect_timout")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create the timestamp of the monitoring task. Unit: milliseconds.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Monitoring task description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="extraInfo")
    def extra_info(self) -> str:
        """
        Additional information for the instance.
        """
        return pulumi.get(self, "extra_info")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The ID of the application Group.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="hybridMonitorSlsTaskId")
    def hybrid_monitor_sls_task_id(self) -> str:
        """
        The ID of the monitoring task.
        """
        return pulumi.get(self, "hybrid_monitor_sls_task_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Hybrid Monitor Sls Task.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence[str]:
        """
        A list of instances where monitoring data is collected in batches.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="logFilePath")
    def log_file_path(self) -> str:
        """
        The path where on-premises log data is stored. On-premises log data is stored in the specified path of the host where CloudMonitor is deployed.
        """
        return pulumi.get(self, "log_file_path")

    @property
    @pulumi.getter(name="logProcess")
    def log_process(self) -> str:
        """
        Local Log Monitoring and calculation method.
        """
        return pulumi.get(self, "log_process")

    @property
    @pulumi.getter(name="logSample")
    def log_sample(self) -> str:
        """
        The sample on-premises log.
        """
        return pulumi.get(self, "log_sample")

    @property
    @pulumi.getter(name="logSplit")
    def log_split(self) -> str:
        """
        The local log data is divided according to different matching patterns.
        """
        return pulumi.get(self, "log_split")

    @property
    @pulumi.getter(name="matchExpressRelation")
    def match_express_relation(self) -> str:
        """
        The filter condition of the instance of the monitoring task.
        """
        return pulumi.get(self, "match_express_relation")

    @property
    @pulumi.getter(name="matchExpresses")
    def match_expresses(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskMatchExpressResult']:
        """
        The matching condition of the instance in the application Group.
        """
        return pulumi.get(self, "match_expresses")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to which the host belongs.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type of the host.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="slsProcess")
    def sls_process(self) -> str:
        """
        The configurations of the logs that are imported from Log Service.
        """
        return pulumi.get(self, "sls_process")

    @property
    @pulumi.getter(name="slsProcessConfigs")
    def sls_process_configs(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigResult']:
        """
        The configurations of the logs that are imported from Log Service.
        """
        return pulumi.get(self, "sls_process_configs")

    @property
    @pulumi.getter(name="taskName")
    def task_name(self) -> str:
        """
        The name of the metric import task.
        """
        return pulumi.get(self, "task_name")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Monitoring Task type.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="uploadRegion")
    def upload_region(self) -> str:
        """
        The region where the host resides.
        """
        return pulumi.get(self, "upload_region")

    @property
    @pulumi.getter(name="yarmConfig")
    def yarm_config(self) -> str:
        return pulumi.get(self, "yarm_config")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskAttachLabelResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the instance.
        :param str value: The value of the key that is used to filter logs imported from Log Service.
        """
        GetHybridMonitorSlsTasksTaskAttachLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskMatchExpressResult(dict):
    def __init__(__self__, *,
                 function: str,
                 name: str,
                 value: str):
        """
        :param str function: The function that is used to aggregate log data within a statistical period.
        :param str name: The name of the instance.
        :param str value: The value of the key that is used to filter logs imported from Log Service.
        """
        GetHybridMonitorSlsTasksTaskMatchExpressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function=function,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if function is None:
            raise TypeError("Missing 'function' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("function", function)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        The function that is used to aggregate log data within a statistical period.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigResult(dict):
    def __init__(__self__, *,
                 expresses: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult'],
                 filters: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult'],
                 group_bies: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult'],
                 statistics: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult']):
        """
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressArgs'] expresses: The extended field that specifies the result of basic operations that are performed on aggregation results.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterArgs'] filters: The conditions that are used to filter logs imported from Log Service.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByArgs'] group_bies: The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticArgs'] statistics: The method that is used to aggregate logs imported from Log Service.
        """
        GetHybridMonitorSlsTasksTaskSlsProcessConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expresses=expresses,
            filters=filters,
            group_bies=group_bies,
            statistics=statistics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expresses: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult']] = None,
             filters: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult']] = None,
             group_bies: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult']] = None,
             statistics: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expresses is None:
            raise TypeError("Missing 'expresses' argument")
        if filters is None:
            raise TypeError("Missing 'filters' argument")
        if group_bies is None and 'groupBies' in kwargs:
            group_bies = kwargs['groupBies']
        if group_bies is None:
            raise TypeError("Missing 'group_bies' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")

        _setter("expresses", expresses)
        _setter("filters", filters)
        _setter("group_bies", group_bies)
        _setter("statistics", statistics)

    @property
    @pulumi.getter
    def expresses(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult']:
        """
        The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "expresses")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult']:
        """
        The conditions that are used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult']:
        """
        The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def statistics(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult']:
        """
        The method that is used to aggregate logs imported from Log Service.
        """
        return pulumi.get(self, "statistics")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult(dict):
    def __init__(__self__, *,
                 alias: str,
                 express: str):
        """
        :param str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param str express: The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            express=express,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             express: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if express is None:
            raise TypeError("Missing 'express' argument")

        _setter("alias", alias)
        _setter("express", express)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def express(self) -> str:
        """
        The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "express")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult'],
                 relation: str):
        """
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterArgs'] filters: The conditions that are used to filter logs imported from Log Service.
        :param str relation: The relationship between multiple filter conditions.
        """
        GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            relation=relation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Optional[Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult']] = None,
             relation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if filters is None:
            raise TypeError("Missing 'filters' argument")
        if relation is None:
            raise TypeError("Missing 'relation' argument")

        _setter("filters", filters)
        _setter("relation", relation)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult']:
        """
        The conditions that are used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def relation(self) -> str:
        """
        The relationship between multiple filter conditions.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 sls_key_name: str,
                 value: str):
        """
        :param str operator: The method that is used to filter logs imported from Log Service.
        :param str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        :param str value: The value of the key that is used to filter logs imported from Log Service.
        """
        GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            sls_key_name=sls_key_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[str] = None,
             sls_key_name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if sls_key_name is None and 'slsKeyName' in kwargs:
            sls_key_name = kwargs['slsKeyName']
        if sls_key_name is None:
            raise TypeError("Missing 'sls_key_name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("operator", operator)
        _setter("sls_key_name", sls_key_name)
        _setter("value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The method that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> str:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult(dict):
    def __init__(__self__, *,
                 alias: str,
                 sls_key_name: str):
        """
        :param str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            sls_key_name=sls_key_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             sls_key_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if sls_key_name is None and 'slsKeyName' in kwargs:
            sls_key_name = kwargs['slsKeyName']
        if sls_key_name is None:
            raise TypeError("Missing 'sls_key_name' argument")

        _setter("alias", alias)
        _setter("sls_key_name", sls_key_name)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> str:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult(dict):
    def __init__(__self__, *,
                 alias: str,
                 function: str,
                 parameter_one: str,
                 parameter_two: str,
                 sls_key_name: str):
        """
        :param str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param str function: The function that is used to aggregate log data within a statistical period.
        :param str parameter_one: The value of the function that is used to aggregate logs imported from Log Service.
        :param str parameter_two: The value of the function that is used to aggregate logs imported from Log Service.
        :param str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            function=function,
            parameter_one=parameter_one,
            parameter_two=parameter_two,
            sls_key_name=sls_key_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             function: Optional[str] = None,
             parameter_one: Optional[str] = None,
             parameter_two: Optional[str] = None,
             sls_key_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if function is None:
            raise TypeError("Missing 'function' argument")
        if parameter_one is None and 'parameterOne' in kwargs:
            parameter_one = kwargs['parameterOne']
        if parameter_one is None:
            raise TypeError("Missing 'parameter_one' argument")
        if parameter_two is None and 'parameterTwo' in kwargs:
            parameter_two = kwargs['parameterTwo']
        if parameter_two is None:
            raise TypeError("Missing 'parameter_two' argument")
        if sls_key_name is None and 'slsKeyName' in kwargs:
            sls_key_name = kwargs['slsKeyName']
        if sls_key_name is None:
            raise TypeError("Missing 'sls_key_name' argument")

        _setter("alias", alias)
        _setter("function", function)
        _setter("parameter_one", parameter_one)
        _setter("parameter_two", parameter_two)
        _setter("sls_key_name", sls_key_name)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        The function that is used to aggregate log data within a statistical period.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter(name="parameterOne")
    def parameter_one(self) -> str:
        """
        The value of the function that is used to aggregate logs imported from Log Service.
        """
        return pulumi.get(self, "parameter_one")

    @property
    @pulumi.getter(name="parameterTwo")
    def parameter_two(self) -> str:
        """
        The value of the function that is used to aggregate logs imported from Log Service.
        """
        return pulumi.get(self, "parameter_two")

    @property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> str:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class GetMetricRuleBlackListsListResult(dict):
    def __init__(__self__, *,
                 category: str,
                 create_time: str,
                 effective_time: str,
                 enable_end_time: str,
                 enable_start_time: str,
                 id: str,
                 instances: Sequence[str],
                 is_enable: bool,
                 metric_rule_black_list_id: str,
                 metric_rule_black_list_name: str,
                 metrics: Sequence['outputs.GetMetricRuleBlackListsListMetricResult'],
                 namespace: str,
                 scope_type: str,
                 scope_values: Sequence[str]):
        """
        :param str category: Cloud service classification. For example, Redis includes kvstore_standard, kvstore_sharding, and kvstore_splitrw.
        :param str create_time: The timestamp for creating an alert blacklist policy.Unit: milliseconds.
        :param str effective_time: The effective time range of the alert blacklist policy.
        :param str enable_end_time: The start timestamp of the alert blacklist policy.Unit: milliseconds.
        :param str enable_start_time: The end timestamp of the alert blacklist policy.Unit: milliseconds.
        :param Sequence[str] instances: The list of instances of cloud services specified in the alert blacklist policy.
        :param bool is_enable: The status of the alert blacklist policy. Value:-true: enabled.-false: disabled.
        :param str metric_rule_black_list_id: The first ID of the resource
        :param str metric_rule_black_list_name: The name of the alert blacklist policy.
        :param Sequence['GetMetricRuleBlackListsListMetricArgs'] metrics: Monitoring metrics in the instance.
        :param str namespace: The data namespace of the cloud service.
        :param str scope_type: The effective range of the alert blacklist policy. Value:-USER: The alert blacklist policy only takes effect in the current Alibaba cloud account.-GROUP: The alert blacklist policy takes effect in the specified application GROUP.
        :param Sequence[str] scope_values: Application Group ID list. The format is JSON Array.> This parameter is displayed only when 'ScopeType' is 'GROUP.
        """
        GetMetricRuleBlackListsListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            create_time=create_time,
            effective_time=effective_time,
            enable_end_time=enable_end_time,
            enable_start_time=enable_start_time,
            id=id,
            instances=instances,
            is_enable=is_enable,
            metric_rule_black_list_id=metric_rule_black_list_id,
            metric_rule_black_list_name=metric_rule_black_list_name,
            metrics=metrics,
            namespace=namespace,
            scope_type=scope_type,
            scope_values=scope_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             create_time: Optional[str] = None,
             effective_time: Optional[str] = None,
             enable_end_time: Optional[str] = None,
             enable_start_time: Optional[str] = None,
             id: Optional[str] = None,
             instances: Optional[Sequence[str]] = None,
             is_enable: Optional[bool] = None,
             metric_rule_black_list_id: Optional[str] = None,
             metric_rule_black_list_name: Optional[str] = None,
             metrics: Optional[Sequence['outputs.GetMetricRuleBlackListsListMetricResult']] = None,
             namespace: Optional[str] = None,
             scope_type: Optional[str] = None,
             scope_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if effective_time is None and 'effectiveTime' in kwargs:
            effective_time = kwargs['effectiveTime']
        if effective_time is None:
            raise TypeError("Missing 'effective_time' argument")
        if enable_end_time is None and 'enableEndTime' in kwargs:
            enable_end_time = kwargs['enableEndTime']
        if enable_end_time is None:
            raise TypeError("Missing 'enable_end_time' argument")
        if enable_start_time is None and 'enableStartTime' in kwargs:
            enable_start_time = kwargs['enableStartTime']
        if enable_start_time is None:
            raise TypeError("Missing 'enable_start_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if instances is None:
            raise TypeError("Missing 'instances' argument")
        if is_enable is None and 'isEnable' in kwargs:
            is_enable = kwargs['isEnable']
        if is_enable is None:
            raise TypeError("Missing 'is_enable' argument")
        if metric_rule_black_list_id is None and 'metricRuleBlackListId' in kwargs:
            metric_rule_black_list_id = kwargs['metricRuleBlackListId']
        if metric_rule_black_list_id is None:
            raise TypeError("Missing 'metric_rule_black_list_id' argument")
        if metric_rule_black_list_name is None and 'metricRuleBlackListName' in kwargs:
            metric_rule_black_list_name = kwargs['metricRuleBlackListName']
        if metric_rule_black_list_name is None:
            raise TypeError("Missing 'metric_rule_black_list_name' argument")
        if metrics is None:
            raise TypeError("Missing 'metrics' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if scope_type is None and 'scopeType' in kwargs:
            scope_type = kwargs['scopeType']
        if scope_type is None:
            raise TypeError("Missing 'scope_type' argument")
        if scope_values is None and 'scopeValues' in kwargs:
            scope_values = kwargs['scopeValues']
        if scope_values is None:
            raise TypeError("Missing 'scope_values' argument")

        _setter("category", category)
        _setter("create_time", create_time)
        _setter("effective_time", effective_time)
        _setter("enable_end_time", enable_end_time)
        _setter("enable_start_time", enable_start_time)
        _setter("id", id)
        _setter("instances", instances)
        _setter("is_enable", is_enable)
        _setter("metric_rule_black_list_id", metric_rule_black_list_id)
        _setter("metric_rule_black_list_name", metric_rule_black_list_name)
        _setter("metrics", metrics)
        _setter("namespace", namespace)
        _setter("scope_type", scope_type)
        _setter("scope_values", scope_values)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Cloud service classification. For example, Redis includes kvstore_standard, kvstore_sharding, and kvstore_splitrw.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The timestamp for creating an alert blacklist policy.Unit: milliseconds.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="effectiveTime")
    def effective_time(self) -> str:
        """
        The effective time range of the alert blacklist policy.
        """
        return pulumi.get(self, "effective_time")

    @property
    @pulumi.getter(name="enableEndTime")
    def enable_end_time(self) -> str:
        """
        The start timestamp of the alert blacklist policy.Unit: milliseconds.
        """
        return pulumi.get(self, "enable_end_time")

    @property
    @pulumi.getter(name="enableStartTime")
    def enable_start_time(self) -> str:
        """
        The end timestamp of the alert blacklist policy.Unit: milliseconds.
        """
        return pulumi.get(self, "enable_start_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence[str]:
        """
        The list of instances of cloud services specified in the alert blacklist policy.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="isEnable")
    def is_enable(self) -> bool:
        """
        The status of the alert blacklist policy. Value:-true: enabled.-false: disabled.
        """
        return pulumi.get(self, "is_enable")

    @property
    @pulumi.getter(name="metricRuleBlackListId")
    def metric_rule_black_list_id(self) -> str:
        """
        The first ID of the resource
        """
        return pulumi.get(self, "metric_rule_black_list_id")

    @property
    @pulumi.getter(name="metricRuleBlackListName")
    def metric_rule_black_list_name(self) -> str:
        """
        The name of the alert blacklist policy.
        """
        return pulumi.get(self, "metric_rule_black_list_name")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetMetricRuleBlackListsListMetricResult']:
        """
        Monitoring metrics in the instance.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The data namespace of the cloud service.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> str:
        """
        The effective range of the alert blacklist policy. Value:-USER: The alert blacklist policy only takes effect in the current Alibaba cloud account.-GROUP: The alert blacklist policy takes effect in the specified application GROUP.
        """
        return pulumi.get(self, "scope_type")

    @property
    @pulumi.getter(name="scopeValues")
    def scope_values(self) -> Sequence[str]:
        """
        Application Group ID list. The format is JSON Array.> This parameter is displayed only when 'ScopeType' is 'GROUP.
        """
        return pulumi.get(self, "scope_values")


@pulumi.output_type
class GetMetricRuleBlackListsListMetricResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 resource: str):
        """
        :param str metric_name: The name of the monitoring indicator.
        :param str resource: The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        GetMetricRuleBlackListsListMetricResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: Optional[str] = None,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if resource is None:
            raise TypeError("Missing 'resource' argument")

        _setter("metric_name", metric_name)
        _setter("resource", resource)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the monitoring indicator.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 alert_templates: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateResult'],
                 description: str,
                 group_id: str,
                 id: str,
                 metric_rule_template_name: str,
                 rest_version: str,
                 template_id: str):
        """
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateArgs'] alert_templates: The details of alert rules that are generated based on the alert template.
        :param str description: The description of the alert template.
        :param str group_id: GroupId.
        :param str id: The ID of the Metric Rule Template.
        :param str metric_rule_template_name: The name of the alert template.
        :param str rest_version: The version of the alert template.
               
               > **NOTE:** The version changes with the number of times that the alert template is modified.
        :param str template_id: The ID of the alert template.
        """
        GetMetricRuleTemplatesTemplateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_templates=alert_templates,
            description=description,
            group_id=group_id,
            id=id,
            metric_rule_template_name=metric_rule_template_name,
            rest_version=rest_version,
            template_id=template_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_templates: Optional[Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateResult']] = None,
             description: Optional[str] = None,
             group_id: Optional[str] = None,
             id: Optional[str] = None,
             metric_rule_template_name: Optional[str] = None,
             rest_version: Optional[str] = None,
             template_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_templates is None and 'alertTemplates' in kwargs:
            alert_templates = kwargs['alertTemplates']
        if alert_templates is None:
            raise TypeError("Missing 'alert_templates' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if metric_rule_template_name is None and 'metricRuleTemplateName' in kwargs:
            metric_rule_template_name = kwargs['metricRuleTemplateName']
        if metric_rule_template_name is None:
            raise TypeError("Missing 'metric_rule_template_name' argument")
        if rest_version is None and 'restVersion' in kwargs:
            rest_version = kwargs['restVersion']
        if rest_version is None:
            raise TypeError("Missing 'rest_version' argument")
        if template_id is None and 'templateId' in kwargs:
            template_id = kwargs['templateId']
        if template_id is None:
            raise TypeError("Missing 'template_id' argument")

        _setter("alert_templates", alert_templates)
        _setter("description", description)
        _setter("group_id", group_id)
        _setter("id", id)
        _setter("metric_rule_template_name", metric_rule_template_name)
        _setter("rest_version", rest_version)
        _setter("template_id", template_id)

    @property
    @pulumi.getter(name="alertTemplates")
    def alert_templates(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateResult']:
        """
        The details of alert rules that are generated based on the alert template.
        """
        return pulumi.get(self, "alert_templates")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the alert template.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        GroupId.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Metric Rule Template.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="metricRuleTemplateName")
    def metric_rule_template_name(self) -> str:
        """
        The name of the alert template.
        """
        return pulumi.get(self, "metric_rule_template_name")

    @property
    @pulumi.getter(name="restVersion")
    def rest_version(self) -> str:
        """
        The version of the alert template.

        > **NOTE:** The version changes with the number of times that the alert template is modified.
        """
        return pulumi.get(self, "rest_version")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        """
        The ID of the alert template.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateResult(dict):
    def __init__(__self__, *,
                 category: str,
                 escalations: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult'],
                 metric_name: str,
                 namespace: str,
                 rule_name: str,
                 selector: str,
                 webhook: str):
        """
        :param str category: The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iot_edge`, `kvstore_sharding`, `kvstore_splitrw`, `kvstore_standard`, `memcache`, `mns`, `mongodb`, `mongodb_cluster`, `mongodb_sharding`, `mq_topic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationArgs'] escalations: The information about the trigger condition based on the alert level.
        :param str metric_name: The name of the metric.
        :param str namespace: The namespace of the service.
        :param str rule_name: The name of the alert rule.
        :param str webhook: The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        GetMetricRuleTemplatesTemplateAlertTemplateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            escalations=escalations,
            metric_name=metric_name,
            namespace=namespace,
            rule_name=rule_name,
            selector=selector,
            webhook=webhook,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             escalations: Optional[Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult']] = None,
             metric_name: Optional[str] = None,
             namespace: Optional[str] = None,
             rule_name: Optional[str] = None,
             selector: Optional[str] = None,
             webhook: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if escalations is None:
            raise TypeError("Missing 'escalations' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if rule_name is None and 'ruleName' in kwargs:
            rule_name = kwargs['ruleName']
        if rule_name is None:
            raise TypeError("Missing 'rule_name' argument")
        if selector is None:
            raise TypeError("Missing 'selector' argument")
        if webhook is None:
            raise TypeError("Missing 'webhook' argument")

        _setter("category", category)
        _setter("escalations", escalations)
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("rule_name", rule_name)
        _setter("selector", selector)
        _setter("webhook", webhook)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iot_edge`, `kvstore_sharding`, `kvstore_splitrw`, `kvstore_standard`, `memcache`, `mns`, `mongodb`, `mongodb_cluster`, `mongodb_sharding`, `mq_topic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def escalations(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult']:
        """
        The information about the trigger condition based on the alert level.
        """
        return pulumi.get(self, "escalations")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace of the service.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def webhook(self) -> str:
        """
        The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult(dict):
    def __init__(__self__, *,
                 criticals: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult'],
                 infos: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult'],
                 warns: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult']):
        """
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalArgs'] criticals: The condition for triggering critical-level alerts.
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoArgs'] infos: The condition for triggering info-level alerts.
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnArgs'] warns: The condition for triggering warn-level alerts.
        """
        GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            criticals=criticals,
            infos=infos,
            warns=warns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             criticals: Optional[Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult']] = None,
             infos: Optional[Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult']] = None,
             warns: Optional[Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if criticals is None:
            raise TypeError("Missing 'criticals' argument")
        if infos is None:
            raise TypeError("Missing 'infos' argument")
        if warns is None:
            raise TypeError("Missing 'warns' argument")

        _setter("criticals", criticals)
        _setter("infos", infos)
        _setter("warns", warns)

    @property
    @pulumi.getter
    def criticals(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult']:
        """
        The condition for triggering critical-level alerts.
        """
        return pulumi.get(self, "criticals")

    @property
    @pulumi.getter
    def infos(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult']:
        """
        The condition for triggering info-level alerts.
        """
        return pulumi.get(self, "infos")

    @property
    @pulumi.getter
    def warns(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult']:
        """
        The condition for triggering warn-level alerts.
        """
        return pulumi.get(self, "warns")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 statistics: str,
                 threshold: str,
                 times: str):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param str times: The consecutive number of times for which the metric value is measured before a warn-level
               alert is triggered.
        """
        GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if times is None:
            raise TypeError("Missing 'times' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("statistics", statistics)
        _setter("threshold", threshold)
        _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> str:
        """
        The consecutive number of times for which the metric value is measured before a warn-level
        alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 statistics: str,
                 threshold: str,
                 times: str):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param str times: The consecutive number of times for which the metric value is measured before a warn-level
               alert is triggered.
        """
        GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if times is None:
            raise TypeError("Missing 'times' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("statistics", statistics)
        _setter("threshold", threshold)
        _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> str:
        """
        The consecutive number of times for which the metric value is measured before a warn-level
        alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 statistics: str,
                 threshold: str,
                 times: str):
        """
        :param str comparison_operator: The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param str statistics: The statistical aggregation method for warn-level alerts.
        :param str threshold: The threshold for warn-level alerts.
        :param str times: The consecutive number of times for which the metric value is measured before a warn-level
               alert is triggered.
        """
        GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            statistics=statistics,
            threshold=threshold,
            times=times,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             statistics: Optional[str] = None,
             threshold: Optional[str] = None,
             times: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if statistics is None:
            raise TypeError("Missing 'statistics' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if times is None:
            raise TypeError("Missing 'times' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("statistics", statistics)
        _setter("threshold", threshold)
        _setter("times", times)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def times(self) -> str:
        """
        The consecutive number of times for which the metric value is measured before a warn-level
        alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetMonitorGroupInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 instances: Sequence['outputs.GetMonitorGroupInstancesInstanceInstanceResult']):
        GetMonitorGroupInstancesInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instances=instances,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instances: Optional[Sequence['outputs.GetMonitorGroupInstancesInstanceInstanceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instances is None:
            raise TypeError("Missing 'instances' argument")

        _setter("instances", instances)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetMonitorGroupInstancesInstanceInstanceResult']:
        return pulumi.get(self, "instances")


@pulumi.output_type
class GetMonitorGroupInstancesInstanceInstanceResult(dict):
    def __init__(__self__, *,
                 category: str,
                 instance_id: str,
                 instance_name: str,
                 region_id: str):
        GetMonitorGroupInstancesInstanceInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            instance_id=instance_id,
            instance_name=instance_name,
            region_id=region_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             instance_id: Optional[str] = None,
             instance_name: Optional[str] = None,
             region_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if category is None:
            raise TypeError("Missing 'category' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")
        if instance_name is None and 'instanceName' in kwargs:
            instance_name = kwargs['instanceName']
        if instance_name is None:
            raise TypeError("Missing 'instance_name' argument")
        if region_id is None and 'regionId' in kwargs:
            region_id = kwargs['regionId']
        if region_id is None:
            raise TypeError("Missing 'region_id' argument")

        _setter("category", category)
        _setter("instance_id", instance_id)
        _setter("instance_name", instance_name)
        _setter("region_id", region_id)

    @property
    @pulumi.getter
    def category(self) -> str:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> str:
        return pulumi.get(self, "region_id")


@pulumi.output_type
class GetMonitorGroupsGroupResult(dict):
    def __init__(__self__, *,
                 bind_url: str,
                 contact_groups: Sequence[str],
                 dynamic_tag_rule_id: str,
                 gmt_create: int,
                 gmt_modified: int,
                 group_id: str,
                 id: str,
                 monitor_group_name: str,
                 service_id: str,
                 tags: Mapping[str, Any],
                 template_ids: Sequence[str],
                 type: str):
        """
        :param str bind_url: The URL of the Kubernetes cluster from which the application group is synchronized.
        :param Sequence[str] contact_groups: The list of  alert groups that receive alert notifications for the application group.
        :param str dynamic_tag_rule_id: The ID of the tag rule.
        :param int gmt_create: The time when the application group was created.
        :param int gmt_modified: The time when the application group was modified.
        :param str group_id: The ID of the application group.
        :param str id: The ID of the Monitor Group.
        :param str monitor_group_name: The name of the application group.
        :param str service_id: The ID of the Alibaba Cloud service.
        :param Mapping[str, Any] tags: A map of tags assigned to the Cms Monitor Group.
        :param Sequence[str] template_ids: The alert templates applied to the application group.
        :param str type: The type of the application group.
        """
        GetMonitorGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bind_url=bind_url,
            contact_groups=contact_groups,
            dynamic_tag_rule_id=dynamic_tag_rule_id,
            gmt_create=gmt_create,
            gmt_modified=gmt_modified,
            group_id=group_id,
            id=id,
            monitor_group_name=monitor_group_name,
            service_id=service_id,
            tags=tags,
            template_ids=template_ids,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bind_url: Optional[str] = None,
             contact_groups: Optional[Sequence[str]] = None,
             dynamic_tag_rule_id: Optional[str] = None,
             gmt_create: Optional[int] = None,
             gmt_modified: Optional[int] = None,
             group_id: Optional[str] = None,
             id: Optional[str] = None,
             monitor_group_name: Optional[str] = None,
             service_id: Optional[str] = None,
             tags: Optional[Mapping[str, Any]] = None,
             template_ids: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bind_url is None and 'bindUrl' in kwargs:
            bind_url = kwargs['bindUrl']
        if bind_url is None:
            raise TypeError("Missing 'bind_url' argument")
        if contact_groups is None and 'contactGroups' in kwargs:
            contact_groups = kwargs['contactGroups']
        if contact_groups is None:
            raise TypeError("Missing 'contact_groups' argument")
        if dynamic_tag_rule_id is None and 'dynamicTagRuleId' in kwargs:
            dynamic_tag_rule_id = kwargs['dynamicTagRuleId']
        if dynamic_tag_rule_id is None:
            raise TypeError("Missing 'dynamic_tag_rule_id' argument")
        if gmt_create is None and 'gmtCreate' in kwargs:
            gmt_create = kwargs['gmtCreate']
        if gmt_create is None:
            raise TypeError("Missing 'gmt_create' argument")
        if gmt_modified is None and 'gmtModified' in kwargs:
            gmt_modified = kwargs['gmtModified']
        if gmt_modified is None:
            raise TypeError("Missing 'gmt_modified' argument")
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if group_id is None:
            raise TypeError("Missing 'group_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if monitor_group_name is None and 'monitorGroupName' in kwargs:
            monitor_group_name = kwargs['monitorGroupName']
        if monitor_group_name is None:
            raise TypeError("Missing 'monitor_group_name' argument")
        if service_id is None and 'serviceId' in kwargs:
            service_id = kwargs['serviceId']
        if service_id is None:
            raise TypeError("Missing 'service_id' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")
        if template_ids is None and 'templateIds' in kwargs:
            template_ids = kwargs['templateIds']
        if template_ids is None:
            raise TypeError("Missing 'template_ids' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("bind_url", bind_url)
        _setter("contact_groups", contact_groups)
        _setter("dynamic_tag_rule_id", dynamic_tag_rule_id)
        _setter("gmt_create", gmt_create)
        _setter("gmt_modified", gmt_modified)
        _setter("group_id", group_id)
        _setter("id", id)
        _setter("monitor_group_name", monitor_group_name)
        _setter("service_id", service_id)
        _setter("tags", tags)
        _setter("template_ids", template_ids)
        _setter("type", type)

    @property
    @pulumi.getter(name="bindUrl")
    def bind_url(self) -> str:
        """
        The URL of the Kubernetes cluster from which the application group is synchronized.
        """
        return pulumi.get(self, "bind_url")

    @property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> Sequence[str]:
        """
        The list of  alert groups that receive alert notifications for the application group.
        """
        return pulumi.get(self, "contact_groups")

    @property
    @pulumi.getter(name="dynamicTagRuleId")
    def dynamic_tag_rule_id(self) -> str:
        """
        The ID of the tag rule.
        """
        return pulumi.get(self, "dynamic_tag_rule_id")

    @property
    @pulumi.getter(name="gmtCreate")
    def gmt_create(self) -> int:
        """
        The time when the application group was created.
        """
        return pulumi.get(self, "gmt_create")

    @property
    @pulumi.getter(name="gmtModified")
    def gmt_modified(self) -> int:
        """
        The time when the application group was modified.
        """
        return pulumi.get(self, "gmt_modified")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The ID of the application group.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Monitor Group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="monitorGroupName")
    def monitor_group_name(self) -> str:
        """
        The name of the application group.
        """
        return pulumi.get(self, "monitor_group_name")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> str:
        """
        The ID of the Alibaba Cloud service.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        A map of tags assigned to the Cms Monitor Group.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="templateIds")
    def template_ids(self) -> Sequence[str]:
        """
        The alert templates applied to the application group.
        """
        return pulumi.get(self, "template_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the application group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 description: str,
                 id: str,
                 modify_time: str,
                 namespace: str,
                 namespace_id: str,
                 specification: str):
        """
        :param str create_time: Create the timestamp of the indicator warehouse.
        :param str description: Description of indicator warehouse.
        :param str id: The ID of the Namespace.
        :param str modify_time: The timestamp of the last modification indicator warehouse.
        :param str namespace: Indicator warehouse name.
        :param str namespace_id: The ID of the Namespace.
        :param str specification: Data storage duration.
        """
        GetNamespacesNamespaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_time=create_time,
            description=description,
            id=id,
            modify_time=modify_time,
            namespace=namespace,
            namespace_id=namespace_id,
            specification=specification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_time: Optional[str] = None,
             description: Optional[str] = None,
             id: Optional[str] = None,
             modify_time: Optional[str] = None,
             namespace: Optional[str] = None,
             namespace_id: Optional[str] = None,
             specification: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if modify_time is None and 'modifyTime' in kwargs:
            modify_time = kwargs['modifyTime']
        if modify_time is None:
            raise TypeError("Missing 'modify_time' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if namespace_id is None and 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if namespace_id is None:
            raise TypeError("Missing 'namespace_id' argument")
        if specification is None:
            raise TypeError("Missing 'specification' argument")

        _setter("create_time", create_time)
        _setter("description", description)
        _setter("id", id)
        _setter("modify_time", modify_time)
        _setter("namespace", namespace)
        _setter("namespace_id", namespace_id)
        _setter("specification", specification)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create the timestamp of the indicator warehouse.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of indicator warehouse.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Namespace.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> str:
        """
        The timestamp of the last modification indicator warehouse.
        """
        return pulumi.get(self, "modify_time")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Indicator warehouse name.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> str:
        """
        The ID of the Namespace.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter
    def specification(self) -> str:
        """
        Data storage duration.
        """
        return pulumi.get(self, "specification")


@pulumi.output_type
class GetSlsGroupsGroupResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 id: str,
                 sls_group_configs: Sequence['outputs.GetSlsGroupsGroupSlsGroupConfigResult'],
                 sls_group_description: str,
                 sls_group_name: str):
        """
        :param str create_time: The creation time of the resource.
        :param str id: The ID of the Sls Group. Its value is same as Queue Name.
        :param Sequence['GetSlsGroupsGroupSlsGroupConfigArgs'] sls_group_configs: The Config of the Sls Group.
        :param str sls_group_description: The Description of the Sls Group.
        :param str sls_group_name: The name of the resource.
        """
        GetSlsGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_time=create_time,
            id=id,
            sls_group_configs=sls_group_configs,
            sls_group_description=sls_group_description,
            sls_group_name=sls_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_time: Optional[str] = None,
             id: Optional[str] = None,
             sls_group_configs: Optional[Sequence['outputs.GetSlsGroupsGroupSlsGroupConfigResult']] = None,
             sls_group_description: Optional[str] = None,
             sls_group_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_time is None and 'createTime' in kwargs:
            create_time = kwargs['createTime']
        if create_time is None:
            raise TypeError("Missing 'create_time' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if sls_group_configs is None and 'slsGroupConfigs' in kwargs:
            sls_group_configs = kwargs['slsGroupConfigs']
        if sls_group_configs is None:
            raise TypeError("Missing 'sls_group_configs' argument")
        if sls_group_description is None and 'slsGroupDescription' in kwargs:
            sls_group_description = kwargs['slsGroupDescription']
        if sls_group_description is None:
            raise TypeError("Missing 'sls_group_description' argument")
        if sls_group_name is None and 'slsGroupName' in kwargs:
            sls_group_name = kwargs['slsGroupName']
        if sls_group_name is None:
            raise TypeError("Missing 'sls_group_name' argument")

        _setter("create_time", create_time)
        _setter("id", id)
        _setter("sls_group_configs", sls_group_configs)
        _setter("sls_group_description", sls_group_description)
        _setter("sls_group_name", sls_group_name)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Sls Group. Its value is same as Queue Name.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="slsGroupConfigs")
    def sls_group_configs(self) -> Sequence['outputs.GetSlsGroupsGroupSlsGroupConfigResult']:
        """
        The Config of the Sls Group.
        """
        return pulumi.get(self, "sls_group_configs")

    @property
    @pulumi.getter(name="slsGroupDescription")
    def sls_group_description(self) -> str:
        """
        The Description of the Sls Group.
        """
        return pulumi.get(self, "sls_group_description")

    @property
    @pulumi.getter(name="slsGroupName")
    def sls_group_name(self) -> str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "sls_group_name")


@pulumi.output_type
class GetSlsGroupsGroupSlsGroupConfigResult(dict):
    def __init__(__self__, *,
                 sls_logstore: str,
                 sls_project: str,
                 sls_region: str,
                 sls_user_id: str):
        """
        :param str sls_logstore: The name of the Log Store.
        :param str sls_project: The name of the Project.
        :param str sls_region: The Sls Region.
        :param str sls_user_id: The ID of the Sls User.
        """
        GetSlsGroupsGroupSlsGroupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sls_logstore=sls_logstore,
            sls_project=sls_project,
            sls_region=sls_region,
            sls_user_id=sls_user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sls_logstore: Optional[str] = None,
             sls_project: Optional[str] = None,
             sls_region: Optional[str] = None,
             sls_user_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sls_logstore is None and 'slsLogstore' in kwargs:
            sls_logstore = kwargs['slsLogstore']
        if sls_logstore is None:
            raise TypeError("Missing 'sls_logstore' argument")
        if sls_project is None and 'slsProject' in kwargs:
            sls_project = kwargs['slsProject']
        if sls_project is None:
            raise TypeError("Missing 'sls_project' argument")
        if sls_region is None and 'slsRegion' in kwargs:
            sls_region = kwargs['slsRegion']
        if sls_region is None:
            raise TypeError("Missing 'sls_region' argument")
        if sls_user_id is None and 'slsUserId' in kwargs:
            sls_user_id = kwargs['slsUserId']
        if sls_user_id is None:
            raise TypeError("Missing 'sls_user_id' argument")

        _setter("sls_logstore", sls_logstore)
        _setter("sls_project", sls_project)
        _setter("sls_region", sls_region)
        _setter("sls_user_id", sls_user_id)

    @property
    @pulumi.getter(name="slsLogstore")
    def sls_logstore(self) -> str:
        """
        The name of the Log Store.
        """
        return pulumi.get(self, "sls_logstore")

    @property
    @pulumi.getter(name="slsProject")
    def sls_project(self) -> str:
        """
        The name of the Project.
        """
        return pulumi.get(self, "sls_project")

    @property
    @pulumi.getter(name="slsRegion")
    def sls_region(self) -> str:
        """
        The Sls Region.
        """
        return pulumi.get(self, "sls_region")

    @property
    @pulumi.getter(name="slsUserId")
    def sls_user_id(self) -> str:
        """
        The ID of the Sls User.
        """
        return pulumi.get(self, "sls_user_id")


