# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AlarmCompositeExpression',
    'AlarmCompositeExpressionExpressionList',
    'AlarmEscalationsCritical',
    'AlarmEscalationsInfo',
    'AlarmEscalationsWarn',
    'AlarmPrometheus',
    'AlarmTarget',
    'DynamicTagGroupMatchExpress',
    'EventRuleContactParameter',
    'EventRuleEventPattern',
    'EventRuleFcParameter',
    'EventRuleMnsParameter',
    'EventRuleOpenApiParameter',
    'EventRuleSlsParameter',
    'EventRuleWebhookParameter',
    'GroupMetricRuleEscalations',
    'GroupMetricRuleEscalationsCritical',
    'GroupMetricRuleEscalationsInfo',
    'GroupMetricRuleEscalationsWarn',
    'GroupMetricRuleTarget',
    'HybridMonitorSlsTaskAttachLabel',
    'HybridMonitorSlsTaskSlsProcessConfig',
    'HybridMonitorSlsTaskSlsProcessConfigExpress',
    'HybridMonitorSlsTaskSlsProcessConfigFilter',
    'HybridMonitorSlsTaskSlsProcessConfigFilterFilter',
    'HybridMonitorSlsTaskSlsProcessConfigGroupBy',
    'HybridMonitorSlsTaskSlsProcessConfigStatistic',
    'MetricRuleBlackListMetric',
    'MetricRuleTemplateAlertTemplate',
    'MetricRuleTemplateAlertTemplateEscalations',
    'MetricRuleTemplateAlertTemplateEscalationsCritical',
    'MetricRuleTemplateAlertTemplateEscalationsInfo',
    'MetricRuleTemplateAlertTemplateEscalationsWarn',
    'MonitorGroupInstancesInstance',
    'SiteMonitorCustomSchedule',
    'SiteMonitorIspCity',
    'SiteMonitorOptionJson',
    'SiteMonitorOptionJsonAssertion',
    'SlsGroupSlsGroupConfig',
    'GetAlarmContactGroupsGroupResult',
    'GetAlarmContactsContactResult',
    'GetDynamicTagGroupsGroupResult',
    'GetDynamicTagGroupsGroupMatchExpressResult',
    'GetEventRulesRuleResult',
    'GetEventRulesRuleEventPatternResult',
    'GetEventRulesRuleEventPatternKeywordFilterResult',
    'GetGroupMetricRulesRuleResult',
    'GetGroupMetricRulesRuleEscalationResult',
    'GetGroupMetricRulesRuleEscalationCriticalResult',
    'GetGroupMetricRulesRuleEscalationInfoResult',
    'GetGroupMetricRulesRuleEscalationWarnResult',
    'GetHybridMonitorDatasDataResult',
    'GetHybridMonitorDatasDataLabelResult',
    'GetHybridMonitorDatasDataValueResult',
    'GetHybridMonitorFcTasksTaskResult',
    'GetHybridMonitorSlsTasksTaskResult',
    'GetHybridMonitorSlsTasksTaskAttachLabelResult',
    'GetHybridMonitorSlsTasksTaskMatchExpressResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult',
    'GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult',
    'GetMetricRuleBlackListsListResult',
    'GetMetricRuleBlackListsListMetricResult',
    'GetMetricRuleTemplatesTemplateResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult',
    'GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult',
    'GetMonitorGroupInstancesInstanceResult',
    'GetMonitorGroupInstancesInstanceInstanceResult',
    'GetMonitorGroupsGroupResult',
    'GetNamespacesNamespaceResult',
    'GetSiteMonitorsMonitorResult',
    'GetSlsGroupsGroupResult',
    'GetSlsGroupsGroupSlsGroupConfigResult',
]

@pulumi.output_type
class AlarmCompositeExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expressionListJoin":
            suggest = "expression_list_join"
        elif key == "expressionLists":
            suggest = "expression_lists"
        elif key == "expressionRaw":
            suggest = "expression_raw"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmCompositeExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmCompositeExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmCompositeExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression_list_join: Optional[_builtins.str] = None,
                 expression_lists: Optional[Sequence['outputs.AlarmCompositeExpressionExpressionList']] = None,
                 expression_raw: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str expression_list_join: The relationship between the trigger conditions for multiple metrics. Valid values: `&&`, `||`.
        :param Sequence['AlarmCompositeExpressionExpressionListArgs'] expression_lists: The trigger conditions that are created in standard mode. See `expression_list` below.
        :param _builtins.str expression_raw: The trigger conditions that are created by using expressions.
        :param _builtins.str level: The level of the alert. Valid values: `CRITICAL`, `WARN`, `INFO`.
        :param _builtins.int times: The number of consecutive triggers.
        """
        if expression_list_join is not None:
            pulumi.set(__self__, "expression_list_join", expression_list_join)
        if expression_lists is not None:
            pulumi.set(__self__, "expression_lists", expression_lists)
        if expression_raw is not None:
            pulumi.set(__self__, "expression_raw", expression_raw)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="expressionListJoin")
    def expression_list_join(self) -> Optional[_builtins.str]:
        """
        The relationship between the trigger conditions for multiple metrics. Valid values: `&&`, `||`.
        """
        return pulumi.get(self, "expression_list_join")

    @_builtins.property
    @pulumi.getter(name="expressionLists")
    def expression_lists(self) -> Optional[Sequence['outputs.AlarmCompositeExpressionExpressionList']]:
        """
        The trigger conditions that are created in standard mode. See `expression_list` below.
        """
        return pulumi.get(self, "expression_lists")

    @_builtins.property
    @pulumi.getter(name="expressionRaw")
    def expression_raw(self) -> Optional[_builtins.str]:
        """
        The trigger conditions that are created by using expressions.
        """
        return pulumi.get(self, "expression_raw")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The level of the alert. Valid values: `CRITICAL`, `WARN`, `INFO`.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        The number of consecutive triggers.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmCompositeExpressionExpressionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmCompositeExpressionExpressionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmCompositeExpressionExpressionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmCompositeExpressionExpressionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 metric_name: Optional[_builtins.str] = None,
                 period: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: The metric that is used to monitor the cloud service.
        :param _builtins.str period: The statistical period of the metric. Unit: seconds. Default value: `300`.
        :param _builtins.str statistics: Field `statistics` has been removed from provider version 1.216.0. New field `escalations_critical.statistics` instead.
        :param _builtins.str threshold: Field `threshold` has been removed from provider version 1.216.0. New field `escalations_critical.threshold` instead.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        The metric that is used to monitor the cloud service.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.str]:
        """
        The statistical period of the metric. Unit: seconds. Default value: `300`.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        Field `statistics` has been removed from provider version 1.216.0. New field `escalations_critical.statistics` instead.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Field `threshold` has been removed from provider version 1.216.0. New field `escalations_critical.threshold` instead.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AlarmEscalationsCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmEscalationsCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmEscalationsCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmEscalationsCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str comparison_operator: Critical level alarm comparison operator. Default value: `>`. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `==`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`. **NOTE:** From version 1.231.0, `comparison_operator` can be set to `==`.
        :param _builtins.str statistics: Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        :param _builtins.str threshold: Critical level alarm threshold value, which must be a numeric value currently.
        :param _builtins.int times: Critical level alarm retry times. Default value: `3`.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        Critical level alarm comparison operator. Default value: `>`. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `==`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`. **NOTE:** From version 1.231.0, `comparison_operator` can be set to `==`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        Critical level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Critical level alarm threshold value, which must be a numeric value currently.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        Critical level alarm retry times. Default value: `3`.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmEscalationsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmEscalationsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmEscalationsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmEscalationsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str comparison_operator: Info level alarm comparison operator. Default value: `>`. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `==`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`. **NOTE:** From version 1.231.0, `comparison_operator` can be set to `==`.
        :param _builtins.str statistics: Info level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        :param _builtins.str threshold: Info level alarm threshold value, which must be a numeric value currently.
        :param _builtins.int times: Info level alarm retry times. Default value: `3`.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        Info level alarm comparison operator. Default value: `>`. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `==`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`. **NOTE:** From version 1.231.0, `comparison_operator` can be set to `==`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        Info level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Info level alarm threshold value, which must be a numeric value currently.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        Info level alarm retry times. Default value: `3`.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmEscalationsWarn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmEscalationsWarn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmEscalationsWarn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmEscalationsWarn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str comparison_operator: Warn level alarm comparison operator. Default value: `>`. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `==`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`. **NOTE:** From version 1.231.0, `comparison_operator` can be set to `==`.
        :param _builtins.str statistics: Warn level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        :param _builtins.str threshold: Warn level alarm threshold value, which must be a numeric value currently.
        :param _builtins.int times: Warn level alarm retry times. Default value: `3`.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        Warn level alarm comparison operator. Default value: `>`. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `==`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`. **NOTE:** From version 1.231.0, `comparison_operator` can be set to `==`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        Warn level alarm statistics method. It must be consistent with that defined for metrics. For more information, see [How to use it](https://cms.console.aliyun.com/metric-meta/acs_ecs_dashboard/ecs).
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Warn level alarm threshold value, which must be a numeric value currently.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        Warn level alarm retry times. Default value: `3`.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmPrometheus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promQl":
            suggest = "prom_ql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPrometheus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPrometheus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPrometheus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 level: Optional[_builtins.str] = None,
                 prom_ql: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param Mapping[str, _builtins.str] annotations: The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
        :param _builtins.str level: The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        :param _builtins.str prom_ql: The PromQL query statement. **Note:** The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
        :param _builtins.int times: The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if prom_ql is not None:
            pulumi.set(__self__, "prom_ql", prom_ql)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="promQl")
    def prom_ql(self) -> Optional[_builtins.str]:
        """
        The PromQL query statement. **Note:** The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
        """
        return pulumi.get(self, "prom_ql")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class AlarmTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonParams":
            suggest = "json_params"
        elif key == "targetId":
            suggest = "target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 json_params: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None,
                 target_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: The Alibaba Cloud Resource Name (ARN) of the resource. Simple Message Queue (formerly MNS) (SMQ), Auto Scaling, Simple Log Service, and Function Compute are supported:
               - SMQ: `acs:mns:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. {regionId}: the region ID of the SMQ queue or topic. {userId}: the ID of the Alibaba Cloud account that owns the resource. {Resource type}: the type of the resource for which alerts are triggered. Valid values:queues, topics. {Resource name}: the resource name. If the resource type is queues, the resource name is the queue name. If the resource type is topics, the resource name is the topic name.
               - Auto Scaling: `acs:ess:{regionId}:{userId}:scalingGroupId/{Scaling group ID}:scalingRuleId/{Scaling rule ID}`
               - Simple Log Service: `acs:log:{regionId}:{userId}:project/{Project name}/logstore/{Logstore name}`
               - Function Compute: `acs:fc:{regionId}:{userId}:services/{Service name}/functions/{Function name}`
        :param _builtins.str json_params: The parameters of the alert callback. The parameters are in the JSON format.
        :param _builtins.str level: The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        :param _builtins.str target_id: The ID of the resource for which alerts are triggered. For more information about how to obtain the ID of the resource for which alerts are triggered, see [DescribeMetricRuleTargets](https://www.alibabacloud.com/help/en/cms/developer-reference/api-describemetricruletargets) .
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if json_params is not None:
            pulumi.set(__self__, "json_params", json_params)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Alibaba Cloud Resource Name (ARN) of the resource. Simple Message Queue (formerly MNS) (SMQ), Auto Scaling, Simple Log Service, and Function Compute are supported:
        - SMQ: `acs:mns:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. {regionId}: the region ID of the SMQ queue or topic. {userId}: the ID of the Alibaba Cloud account that owns the resource. {Resource type}: the type of the resource for which alerts are triggered. Valid values:queues, topics. {Resource name}: the resource name. If the resource type is queues, the resource name is the queue name. If the resource type is topics, the resource name is the topic name.
        - Auto Scaling: `acs:ess:{regionId}:{userId}:scalingGroupId/{Scaling group ID}:scalingRuleId/{Scaling rule ID}`
        - Simple Log Service: `acs:log:{regionId}:{userId}:project/{Project name}/logstore/{Logstore name}`
        - Function Compute: `acs:fc:{regionId}:{userId}:services/{Service name}/functions/{Function name}`
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="jsonParams")
    def json_params(self) -> Optional[_builtins.str]:
        """
        The parameters of the alert callback. The parameters are in the JSON format.
        """
        return pulumi.get(self, "json_params")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[_builtins.str]:
        """
        The ID of the resource for which alerts are triggered. For more information about how to obtain the ID of the resource for which alerts are triggered, see [DescribeMetricRuleTargets](https://www.alibabacloud.com/help/en/cms/developer-reference/api-describemetricruletargets) .
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class DynamicTagGroupMatchExpress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagValue":
            suggest = "tag_value"
        elif key == "tagValueMatchFunction":
            suggest = "tag_value_match_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicTagGroupMatchExpress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicTagGroupMatchExpress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicTagGroupMatchExpress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_value: _builtins.str,
                 tag_value_match_function: _builtins.str):
        """
        :param _builtins.str tag_value: The tag values of the cloud resources.
        :param _builtins.str tag_value_match_function: The method that is used to match the tag values of the cloud resources. Valid values: `all`, `startWith`, `endWith`, `contains`, `notContains`, `equals`.
        """
        pulumi.set(__self__, "tag_value", tag_value)
        pulumi.set(__self__, "tag_value_match_function", tag_value_match_function)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> _builtins.str:
        """
        The tag values of the cloud resources.
        """
        return pulumi.get(self, "tag_value")

    @_builtins.property
    @pulumi.getter(name="tagValueMatchFunction")
    def tag_value_match_function(self) -> _builtins.str:
        """
        The method that is used to match the tag values of the cloud resources. Valid values: `all`, `startWith`, `endWith`, `contains`, `notContains`, `equals`.
        """
        return pulumi.get(self, "tag_value_match_function")


@pulumi.output_type
class EventRuleContactParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactGroupName":
            suggest = "contact_group_name"
        elif key == "contactParametersId":
            suggest = "contact_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleContactParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleContactParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleContactParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_group_name: Optional[_builtins.str] = None,
                 contact_parameters_id: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None):
        """
        :param _builtins.str contact_group_name: The name of the alert contact group.
        :param _builtins.str contact_parameters_id: The ID of the recipient that receives alert notifications.
        :param _builtins.str level: The alert level and the corresponding notification methods.
        """
        if contact_group_name is not None:
            pulumi.set(__self__, "contact_group_name", contact_group_name)
        if contact_parameters_id is not None:
            pulumi.set(__self__, "contact_parameters_id", contact_parameters_id)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter(name="contactGroupName")
    def contact_group_name(self) -> Optional[_builtins.str]:
        """
        The name of the alert contact group.
        """
        return pulumi.get(self, "contact_group_name")

    @_builtins.property
    @pulumi.getter(name="contactParametersId")
    def contact_parameters_id(self) -> Optional[_builtins.str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "contact_parameters_id")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The alert level and the corresponding notification methods.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class EventRuleEventPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventTypeLists":
            suggest = "event_type_lists"
        elif key == "levelLists":
            suggest = "level_lists"
        elif key == "nameLists":
            suggest = "name_lists"
        elif key == "sqlFilter":
            suggest = "sql_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleEventPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleEventPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleEventPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 product: _builtins.str,
                 event_type_lists: Optional[Sequence[_builtins.str]] = None,
                 level_lists: Optional[Sequence[_builtins.str]] = None,
                 name_lists: Optional[Sequence[_builtins.str]] = None,
                 sql_filter: Optional[_builtins.str] = None):
        """
        :param _builtins.str product: The type of the cloud service.
        :param Sequence[_builtins.str] event_type_lists: The type of the event-triggered alert rule. Valid values:
               - `StatusNotification`: fault notifications.
               - `Exception`: exceptions.
               - `Maintenance`: O&M.
               - `*`: all types.
        :param Sequence[_builtins.str] level_lists: The level of the event-triggered alert rule. Valid values:
               - `CRITICAL`: critical.
               - `WARN`: warning.
               - `INFO`: information.
               - `*`: all types.
        :param Sequence[_builtins.str] name_lists: The name of the event-triggered alert rule.
        :param _builtins.str sql_filter: The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
        """
        pulumi.set(__self__, "product", product)
        if event_type_lists is not None:
            pulumi.set(__self__, "event_type_lists", event_type_lists)
        if level_lists is not None:
            pulumi.set(__self__, "level_lists", level_lists)
        if name_lists is not None:
            pulumi.set(__self__, "name_lists", name_lists)
        if sql_filter is not None:
            pulumi.set(__self__, "sql_filter", sql_filter)

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        The type of the cloud service.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter(name="eventTypeLists")
    def event_type_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of the event-triggered alert rule. Valid values:
        - `StatusNotification`: fault notifications.
        - `Exception`: exceptions.
        - `Maintenance`: O&M.
        - `*`: all types.
        """
        return pulumi.get(self, "event_type_lists")

    @_builtins.property
    @pulumi.getter(name="levelLists")
    def level_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The level of the event-triggered alert rule. Valid values:
        - `CRITICAL`: critical.
        - `WARN`: warning.
        - `INFO`: information.
        - `*`: all types.
        """
        return pulumi.get(self, "level_lists")

    @_builtins.property
    @pulumi.getter(name="nameLists")
    def name_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The name of the event-triggered alert rule.
        """
        return pulumi.get(self, "name_lists")

    @_builtins.property
    @pulumi.getter(name="sqlFilter")
    def sql_filter(self) -> Optional[_builtins.str]:
        """
        The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
        """
        return pulumi.get(self, "sql_filter")


@pulumi.output_type
class EventRuleFcParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fcParametersId":
            suggest = "fc_parameters_id"
        elif key == "functionName":
            suggest = "function_name"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleFcParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleFcParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleFcParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 fc_parameters_id: Optional[_builtins.str] = None,
                 function_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 service_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: (Available since v1.211.1) The ARN of the API operation.
        :param _builtins.str fc_parameters_id: The ID of the recipient that receives alert notifications.
        :param _builtins.str function_name: The name of the function.
        :param _builtins.str region: The region where Function Compute is deployed.
        :param _builtins.str service_name: The name of the Function Compute service.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if fc_parameters_id is not None:
            pulumi.set(__self__, "fc_parameters_id", fc_parameters_id)
        if function_name is not None:
            pulumi.set(__self__, "function_name", function_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="fcParametersId")
    def fc_parameters_id(self) -> Optional[_builtins.str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "fc_parameters_id")

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[_builtins.str]:
        """
        The name of the function.
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region where Function Compute is deployed.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        The name of the Function Compute service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class EventRuleMnsParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mnsParametersId":
            suggest = "mns_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleMnsParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleMnsParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleMnsParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 mns_parameters_id: Optional[_builtins.str] = None,
                 queue: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 topic: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: (Available since v1.211.1) The ARN of the API operation.
        :param _builtins.str mns_parameters_id: The ID of the recipient that receives alert notifications.
        :param _builtins.str queue: The name of the MNS queue.
        :param _builtins.str region: The region where Message Service (MNS) is deployed.
        :param _builtins.str topic: The MNS topic.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if mns_parameters_id is not None:
            pulumi.set(__self__, "mns_parameters_id", mns_parameters_id)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="mnsParametersId")
    def mns_parameters_id(self) -> Optional[_builtins.str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "mns_parameters_id")

    @_builtins.property
    @pulumi.getter
    def queue(self) -> Optional[_builtins.str]:
        """
        The name of the MNS queue.
        """
        return pulumi.get(self, "queue")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region where Message Service (MNS) is deployed.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[_builtins.str]:
        """
        The MNS topic.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class EventRuleOpenApiParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openApiParametersId":
            suggest = "open_api_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleOpenApiParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleOpenApiParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleOpenApiParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 arn: Optional[_builtins.str] = None,
                 open_api_parameters_id: Optional[_builtins.str] = None,
                 product: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: The API name.
        :param _builtins.str arn: (Available since v1.211.1) The ARN of the API operation.
        :param _builtins.str open_api_parameters_id: The ID of the recipient that receives alert notifications sent by an API callback.
        :param _builtins.str product: The ID of the cloud service to which the API operation belongs.
        :param _builtins.str region: The region where the resource resides.
        :param _builtins.str role: The name of the role.
        :param _builtins.str version: The version of the API.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if open_api_parameters_id is not None:
            pulumi.set(__self__, "open_api_parameters_id", open_api_parameters_id)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        The API name.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="openApiParametersId")
    def open_api_parameters_id(self) -> Optional[_builtins.str]:
        """
        The ID of the recipient that receives alert notifications sent by an API callback.
        """
        return pulumi.get(self, "open_api_parameters_id")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[_builtins.str]:
        """
        The ID of the cloud service to which the API operation belongs.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region where the resource resides.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The name of the role.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the API.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EventRuleSlsParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logStore":
            suggest = "log_store"
        elif key == "slsParametersId":
            suggest = "sls_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleSlsParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleSlsParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleSlsParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 log_store: Optional[_builtins.str] = None,
                 project: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 sls_parameters_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: (Available since v1.211.1) The ARN of the API operation.
        :param _builtins.str log_store: The name of the Simple Log Service Logstore.
        :param _builtins.str project: The name of the Simple Log Service project.
        :param _builtins.str region: The region where Simple Log Service is deployed.
        :param _builtins.str sls_parameters_id: The ID of the recipient that receives alert notifications.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if log_store is not None:
            pulumi.set(__self__, "log_store", log_store)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sls_parameters_id is not None:
            pulumi.set(__self__, "sls_parameters_id", sls_parameters_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        (Available since v1.211.1) The ARN of the API operation.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="logStore")
    def log_store(self) -> Optional[_builtins.str]:
        """
        The name of the Simple Log Service Logstore.
        """
        return pulumi.get(self, "log_store")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[_builtins.str]:
        """
        The name of the Simple Log Service project.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region where Simple Log Service is deployed.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="slsParametersId")
    def sls_parameters_id(self) -> Optional[_builtins.str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "sls_parameters_id")


@pulumi.output_type
class EventRuleWebhookParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webhookParametersId":
            suggest = "webhook_parameters_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventRuleWebhookParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventRuleWebhookParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventRuleWebhookParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 webhook_parameters_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str method: The HTTP request method.
        :param _builtins.str protocol: The name of the protocol.
        :param _builtins.str url: The callback URL.
        :param _builtins.str webhook_parameters_id: The ID of the recipient that receives alert notifications.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if webhook_parameters_id is not None:
            pulumi.set(__self__, "webhook_parameters_id", webhook_parameters_id)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The HTTP request method.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The name of the protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The callback URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="webhookParametersId")
    def webhook_parameters_id(self) -> Optional[_builtins.str]:
        """
        The ID of the recipient that receives alert notifications.
        """
        return pulumi.get(self, "webhook_parameters_id")


@pulumi.output_type
class GroupMetricRuleEscalations(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.GroupMetricRuleEscalationsCritical'] = None,
                 info: Optional['outputs.GroupMetricRuleEscalationsInfo'] = None,
                 warn: Optional['outputs.GroupMetricRuleEscalationsWarn'] = None):
        """
        :param 'GroupMetricRuleEscalationsCriticalArgs' critical: The critical level. See `critical` below.
        :param 'GroupMetricRuleEscalationsInfoArgs' info: The info level. See `info` below.
        :param 'GroupMetricRuleEscalationsWarnArgs' warn: The warn level. See `warn` below.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional['outputs.GroupMetricRuleEscalationsCritical']:
        """
        The critical level. See `critical` below.
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def info(self) -> Optional['outputs.GroupMetricRuleEscalationsInfo']:
        """
        The info level. See `info` below.
        """
        return pulumi.get(self, "info")

    @_builtins.property
    @pulumi.getter
    def warn(self) -> Optional['outputs.GroupMetricRuleEscalationsWarn']:
        """
        The warn level. See `warn` below.
        """
        return pulumi.get(self, "warn")


@pulumi.output_type
class GroupMetricRuleEscalationsCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleEscalationsCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleEscalationsCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleEscalationsCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GroupMetricRuleEscalationsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleEscalationsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleEscalationsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleEscalationsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GroupMetricRuleEscalationsWarn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleEscalationsWarn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleEscalationsWarn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleEscalationsWarn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.int] = None):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.int]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GroupMetricRuleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonParams":
            suggest = "json_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMetricRuleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMetricRuleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMetricRuleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 json_params: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: The Alibaba Cloud Resource Name (ARN) of the resource.
               > **NOTE:** Currently, the Alibaba Cloud Resource Name (ARN) of the resource. To use, please [submit an application](https://www.alibabacloud.com/help/en/cloudmonitor/latest/describemetricruletargets).
        :param _builtins.str id: The ID of the resource for which alerts are triggered.
        :param _builtins.str json_params: The parameters of the alert callback. The parameters are in the JSON format.
        :param _builtins.str level: The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if json_params is not None:
            pulumi.set(__self__, "json_params", json_params)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Alibaba Cloud Resource Name (ARN) of the resource.
        > **NOTE:** Currently, the Alibaba Cloud Resource Name (ARN) of the resource. To use, please [submit an application](https://www.alibabacloud.com/help/en/cloudmonitor/latest/describemetricruletargets).
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the resource for which alerts are triggered.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="jsonParams")
    def json_params(self) -> Optional[_builtins.str]:
        """
        The parameters of the alert callback. The parameters are in the JSON format.
        """
        return pulumi.get(self, "json_params")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The level of the alert. Valid values: `Critical`, `Warn`, `Info`.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HybridMonitorSlsTaskAttachLabel(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The tag key of the metric.
        :param _builtins.str value: The tag value of the metric.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The tag key of the metric.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The tag value of the metric.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expresses: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigExpress']] = None,
                 filter: Optional['outputs.HybridMonitorSlsTaskSlsProcessConfigFilter'] = None,
                 group_bies: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigGroupBy']] = None,
                 statistics: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigStatistic']] = None):
        """
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigExpressArgs'] expresses: The extended field that specifies the result of basic operations that are performed on aggregation results.
        :param 'HybridMonitorSlsTaskSlsProcessConfigFilterArgs' filter: The conditions that are used to filter logs imported from Log Service. See `filter` below.
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigGroupByArgs'] group_bies: The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. See `group_by` below.
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigStatisticArgs'] statistics: The method that is used to aggregate logs imported from Log Service. See `statistics` below.
        """
        if expresses is not None:
            pulumi.set(__self__, "expresses", expresses)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)

    @_builtins.property
    @pulumi.getter
    def expresses(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigExpress']]:
        """
        The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "expresses")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional['outputs.HybridMonitorSlsTaskSlsProcessConfigFilter']:
        """
        The conditions that are used to filter logs imported from Log Service. See `filter` below.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigGroupBy']]:
        """
        The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. See `group_by` below.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigStatistic']]:
        """
        The method that is used to aggregate logs imported from Log Service. See `statistics` below.
        """
        return pulumi.get(self, "statistics")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigExpress(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 express: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param _builtins.str express: The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if express is not None:
            pulumi.set(__self__, "express", express)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def express(self) -> Optional[_builtins.str]:
        """
        The extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "express")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigFilterFilter']] = None,
                 relation: Optional[_builtins.str] = None):
        """
        :param Sequence['HybridMonitorSlsTaskSlsProcessConfigFilterFilterArgs'] filters: The conditions that are used to filter logs imported from Log Service. See `filters` below.
        :param _builtins.str relation: The relationship between multiple filter conditions. Valid values: `and`(default value), `or`.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if relation is not None:
            pulumi.set(__self__, "relation", relation)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.HybridMonitorSlsTaskSlsProcessConfigFilterFilter']]:
        """
        The conditions that are used to filter logs imported from Log Service. See `filters` below.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def relation(self) -> Optional[_builtins.str]:
        """
        The relationship between multiple filter conditions. Valid values: `and`(default value), `or`.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slsKeyName":
            suggest = "sls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfigFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 sls_key_name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: The method that is used to filter logs imported from Log Service. Valid values: `>`, `>=`, `=`, `<=`, `<`, `!=`, `contain`, `notContain`.
        :param _builtins.str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if sls_key_name is not None:
            pulumi.set(__self__, "sls_key_name", sls_key_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The method that is used to filter logs imported from Log Service. Valid values: `>`, `>=`, `=`, `<=`, `<`, `!=`, `contain`, `notContain`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> Optional[_builtins.str]:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slsKeyName":
            suggest = "sls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfigGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 sls_key_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param _builtins.str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if sls_key_name is not None:
            pulumi.set(__self__, "sls_key_name", sls_key_name)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> Optional[_builtins.str]:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class HybridMonitorSlsTaskSlsProcessConfigStatistic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterOne":
            suggest = "parameter_one"
        elif key == "parameterTwo":
            suggest = "parameter_two"
        elif key == "slsKeyName":
            suggest = "sls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridMonitorSlsTaskSlsProcessConfigStatistic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigStatistic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridMonitorSlsTaskSlsProcessConfigStatistic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 function: Optional[_builtins.str] = None,
                 parameter_one: Optional[_builtins.str] = None,
                 parameter_two: Optional[_builtins.str] = None,
                 sls_key_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        :param _builtins.str function: The function that is used to aggregate log data within a statistical period. Valid values: `count`, `sum`, `avg`, `max`, `min`, `value`, `countps`, `sumps`, `distinct`, `distribution`, `percentile`.
        :param _builtins.str parameter_one: The value of the function that is used to aggregate logs imported from Log Service.
               - If you set the `function` parameter to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
               - If you set the `function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
        :param _builtins.str parameter_two: The value of the function that is used to aggregate logs imported from Log Service. **Note:** This parameter is required only if the `function` parameter is set to `distribution`. This parameter specifies the upper limit of the statistical interval.
        :param _builtins.str sls_key_name: The name of the key that is used to filter logs imported from Log Service.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if parameter_one is not None:
            pulumi.set(__self__, "parameter_one", parameter_one)
        if parameter_two is not None:
            pulumi.set(__self__, "parameter_two", parameter_two)
        if sls_key_name is not None:
            pulumi.set(__self__, "sls_key_name", sls_key_name)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.str]:
        """
        The function that is used to aggregate log data within a statistical period. Valid values: `count`, `sum`, `avg`, `max`, `min`, `value`, `countps`, `sumps`, `distinct`, `distribution`, `percentile`.
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter(name="parameterOne")
    def parameter_one(self) -> Optional[_builtins.str]:
        """
        The value of the function that is used to aggregate logs imported from Log Service.
        - If you set the `function` parameter to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
        - If you set the `function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
        """
        return pulumi.get(self, "parameter_one")

    @_builtins.property
    @pulumi.getter(name="parameterTwo")
    def parameter_two(self) -> Optional[_builtins.str]:
        """
        The value of the function that is used to aggregate logs imported from Log Service. **Note:** This parameter is required only if the `function` parameter is set to `distribution`. This parameter specifies the upper limit of the statistical interval.
        """
        return pulumi.get(self, "parameter_two")

    @_builtins.property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> Optional[_builtins.str]:
        """
        The name of the key that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class MetricRuleBlackListMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleBlackListMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleBlackListMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleBlackListMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 resource: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: The name of the monitoring indicator.
        :param _builtins.str resource: The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of the monitoring indicator.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[_builtins.str]:
        """
        The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class MetricRuleTemplateAlertTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "ruleName":
            suggest = "rule_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: _builtins.str,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 rule_name: _builtins.str,
                 escalations: Optional['outputs.MetricRuleTemplateAlertTemplateEscalations'] = None,
                 webhook: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: The abbreviation of the Alibaba Cloud service name.
               > **NOTE:** To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](https://www.alibabacloud.com/help/en/cms/developer-reference/api-cms-2019-01-01-describeprojectmeta) operation. The metricCategory tag in the Labels response parameter indicates the abbreviation of the Alibaba Cloud service name.
        :param _builtins.str metric_name: The name of the metric.
               > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        :param _builtins.str namespace: The namespace of the cloud service.
               > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        :param _builtins.str rule_name: The name of the alert rule.
        :param 'MetricRuleTemplateAlertTemplateEscalationsArgs' escalations: The information about the trigger condition based on the alert level. See `escalations` below.
        :param _builtins.str webhook: The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "rule_name", rule_name)
        if escalations is not None:
            pulumi.set(__self__, "escalations", escalations)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The abbreviation of the Alibaba Cloud service name.
        > **NOTE:** To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](https://www.alibabacloud.com/help/en/cms/developer-reference/api-cms-2019-01-01-describeprojectmeta) operation. The metricCategory tag in the Labels response parameter indicates the abbreviation of the Alibaba Cloud service name.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of the metric.
        > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace of the cloud service.
        > **NOTE:** For more information, see [DescribeMetricMetaList](https://www.alibabacloud.com/help/doc-detail/98846.htm) or [Appendix 1: Metrics](https://www.alibabacloud.com/help/doc-detail/28619.htm).
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> _builtins.str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter
    def escalations(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalations']:
        """
        The information about the trigger condition based on the alert level. See `escalations` below.
        """
        return pulumi.get(self, "escalations")

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[_builtins.str]:
        """
        The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalations(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsCritical'] = None,
                 info: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsInfo'] = None,
                 warn: Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsWarn'] = None):
        """
        :param 'MetricRuleTemplateAlertTemplateEscalationsCriticalArgs' critical: The condition for triggering critical-level alerts. See `critical` below.
        :param 'MetricRuleTemplateAlertTemplateEscalationsInfoArgs' info: The condition for triggering info-level alerts. See `info` below.
        :param 'MetricRuleTemplateAlertTemplateEscalationsWarnArgs' warn: The condition for triggering warn-level alerts. See `warn` below.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsCritical']:
        """
        The condition for triggering critical-level alerts. See `critical` below.
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def info(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsInfo']:
        """
        The condition for triggering info-level alerts. See `info` below.
        """
        return pulumi.get(self, "info")

    @_builtins.property
    @pulumi.getter
    def warn(self) -> Optional['outputs.MetricRuleTemplateAlertTemplateEscalationsWarn']:
        """
        The condition for triggering warn-level alerts. See `warn` below.
        """
        return pulumi.get(self, "warn")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalationsCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplateEscalationsCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.str times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.str]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalationsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplateEscalationsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.str times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.str]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class MetricRuleTemplateAlertTemplateEscalationsWarn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleTemplateAlertTemplateEscalationsWarn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsWarn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleTemplateAlertTemplateEscalationsWarn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional[_builtins.str] = None,
                 statistics: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 times: Optional[_builtins.str] = None):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.str times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[_builtins.str]:
        """
        The comparison operator of the threshold for warn-level alerts. Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Optional[_builtins.str]:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> Optional[_builtins.str]:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class MonitorGroupInstancesInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "regionId":
            suggest = "region_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorGroupInstancesInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorGroupInstancesInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorGroupInstancesInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str,
                 region_id: _builtins.str):
        """
        :param _builtins.str category: The category of instance.
        :param _builtins.str instance_id: The id of instance.
        :param _builtins.str instance_name: The name of instance.
        :param _builtins.str region_id: The region id of instance.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "region_id", region_id)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The category of instance.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The id of instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The name of instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        """
        The region id of instance.
        """
        return pulumi.get(self, "region_id")


@pulumi.output_type
class SiteMonitorCustomSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHour":
            suggest = "end_hour"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteMonitorCustomSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteMonitorCustomSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteMonitorCustomSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[_builtins.int]] = None,
                 end_hour: Optional[_builtins.int] = None,
                 start_hour: Optional[_builtins.int] = None,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] days: The days in a week.
        :param _builtins.int end_hour: The end time of the detection. Unit: hours.
        :param _builtins.int start_hour: The start time of the detection. Unit: hours.
        :param _builtins.str time_zone: The time zone of the detection.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[Sequence[_builtins.int]]:
        """
        The days in a week.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[_builtins.int]:
        """
        The end time of the detection. Unit: hours.
        """
        return pulumi.get(self, "end_hour")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[_builtins.int]:
        """
        The start time of the detection. Unit: hours.
        """
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone of the detection.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class SiteMonitorIspCity(dict):
    def __init__(__self__, *,
                 city: Optional[_builtins.str] = None,
                 isp: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str city: The ID of the city.
        :param _builtins.str isp: The ID of the carrier.
        :param _builtins.str type: The network type of the detection point. Valid values: `IDC`, `LASTMILE`, and `MOBILE`.
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if isp is not None:
            pulumi.set(__self__, "isp", isp)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        The ID of the city.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter
    def isp(self) -> Optional[_builtins.str]:
        """
        The ID of the carrier.
        """
        return pulumi.get(self, "isp")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The network type of the detection point. Valid values: `IDC`, `LASTMILE`, and `MOBILE`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SiteMonitorOptionJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diagnosisMtr":
            suggest = "diagnosis_mtr"
        elif key == "diagnosisPing":
            suggest = "diagnosis_ping"
        elif key == "dnsHijackWhitelist":
            suggest = "dns_hijack_whitelist"
        elif key == "dnsMatchRule":
            suggest = "dns_match_rule"
        elif key == "dnsServer":
            suggest = "dns_server"
        elif key == "dnsType":
            suggest = "dns_type"
        elif key == "expectValue":
            suggest = "expect_value"
        elif key == "failureRate":
            suggest = "failure_rate"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "isBaseEncode":
            suggest = "is_base_encode"
        elif key == "matchRule":
            suggest = "match_rule"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "pingNum":
            suggest = "ping_num"
        elif key == "pingPort":
            suggest = "ping_port"
        elif key == "pingType":
            suggest = "ping_type"
        elif key == "requestContent":
            suggest = "request_content"
        elif key == "requestFormat":
            suggest = "request_format"
        elif key == "responseContent":
            suggest = "response_content"
        elif key == "responseFormat":
            suggest = "response_format"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteMonitorOptionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteMonitorOptionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteMonitorOptionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assertions: Optional[Sequence['outputs.SiteMonitorOptionJsonAssertion']] = None,
                 attempts: Optional[_builtins.int] = None,
                 cookie: Optional[_builtins.str] = None,
                 diagnosis_mtr: Optional[_builtins.bool] = None,
                 diagnosis_ping: Optional[_builtins.bool] = None,
                 dns_hijack_whitelist: Optional[_builtins.str] = None,
                 dns_match_rule: Optional[_builtins.str] = None,
                 dns_server: Optional[_builtins.str] = None,
                 dns_type: Optional[_builtins.str] = None,
                 expect_value: Optional[_builtins.str] = None,
                 failure_rate: Optional[_builtins.str] = None,
                 header: Optional[_builtins.str] = None,
                 http_method: Optional[_builtins.str] = None,
                 is_base_encode: Optional[_builtins.bool] = None,
                 match_rule: Optional[_builtins.int] = None,
                 min_tls_version: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 ping_num: Optional[_builtins.int] = None,
                 ping_port: Optional[_builtins.int] = None,
                 ping_type: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 request_content: Optional[_builtins.str] = None,
                 request_format: Optional[_builtins.str] = None,
                 response_content: Optional[_builtins.str] = None,
                 response_format: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.int] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param Sequence['SiteMonitorOptionJsonAssertionArgs'] assertions: Assertion configuration group. See `assertions` below.
        :param _builtins.int attempts: Number of retries after DNS failed.
        :param _builtins.str cookie: The Cookie that sends the HTTP request.
        :param _builtins.bool diagnosis_mtr: Whether to enable automatic MTR network diagnosis after a task failure. Value:
               - false: does not enable automatic MTR network diagnosis.
               - true to turn on automatic MTR network diagnostics.
        :param _builtins.bool diagnosis_ping: Whether to enable the automatic PING network delay detection after the task fails. Value:
               - false: does not enable automatic PING network delay detection.
               - true: Enable automatic PING network delay detection.
        :param _builtins.str dns_hijack_whitelist: List of DNS hijacking configurations.
        :param _builtins.str dns_match_rule: Matching Rules for DNS. Value:
               - IN_DNS: The alias or IP address that is expected to be resolved is in the DNS response.
               - DNS_IN: All DNS responses appear in the alias or IP address that is expected to be resolved.
               - EQUAL: the DNS response is exactly the same as the alias or IP address that is expected to be resolved.
               - ANY:DNS response and the alias or IP address expected to be resolved have an intersection.
        :param _builtins.str dns_server: The IP address of the DNS server.
               
               > **NOTE:**  only applicable to DNS probe types.
        :param _builtins.str dns_type: DNS resolution type. Only applicable to DNS probe types. Value:
               - A (default): specifies the IP address corresponding to the host name or domain name.
               - CNAME: maps multiple domain names to another domain name.
               - NS: specifies that the domain name is resolved by a DNS server.
               - MX: point domain name to a mail server address.
               - TXT: Description of host name or domain name. The text length is limited to 512 bytes, which is usually used as SPF(Sender Policy Framework) record, that is, anti-spam.
        :param _builtins.str expect_value: The alias or address to be resolved.
               
               > **NOTE:**  This parameter applies only to DNS probe types.
        :param _builtins.str failure_rate: Packet loss rate.
               
               > **NOTE:**  This parameter only applies to PING probe types.
        :param _builtins.str header: HTTP request header.
        :param _builtins.str http_method: HTTP request method. Value:
               - get
               - post
               - head
        :param _builtins.bool is_base_encode: Whether the parameter' Password' is Base64 encoded.
               - true: Yes.
               - false: No.
        :param _builtins.int match_rule: Whether alarm rules are included. Value:
               - 0: Yes.
               - 1: No.
        :param _builtins.str min_tls_version: Minimum TLS version. By default, TLS1.2 and later versions are supported. TLS1.0 and 1.1 have been disabled. If they still need to be supported, the configuration can be changed.
        :param _builtins.str password: The password of the SMTP, POP3, or FTP probe type.
        :param _builtins.int ping_num: The heartbeat of the PING probe type.
        :param _builtins.int ping_port: PING the port. Applies to TCP PING.
        :param _builtins.str ping_type: The PING protocol type. Value:
               - icmp
               - tcp
               - udp
        :param _builtins.int port: Ports of TCP, UDP, SMTP, and POP3 probe types.
        :param _builtins.str request_content: The request content of the HTTP probe type.
        :param _builtins.str request_format: HTTP request content format. Value:
               - hex: hexadecimal format.
               - text: text format.
        :param _builtins.str response_content: Match the response content.
        :param _builtins.str response_format: HTTP response content format. Value:
               - hex: hexadecimal format.
               - text: text format.
        :param _builtins.int timeout: Timeout time. Unit: milliseconds.
        :param _builtins.str user_name: The username of FTP, SMTP, or pop3.
        """
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if diagnosis_mtr is not None:
            pulumi.set(__self__, "diagnosis_mtr", diagnosis_mtr)
        if diagnosis_ping is not None:
            pulumi.set(__self__, "diagnosis_ping", diagnosis_ping)
        if dns_hijack_whitelist is not None:
            pulumi.set(__self__, "dns_hijack_whitelist", dns_hijack_whitelist)
        if dns_match_rule is not None:
            pulumi.set(__self__, "dns_match_rule", dns_match_rule)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_type is not None:
            pulumi.set(__self__, "dns_type", dns_type)
        if expect_value is not None:
            pulumi.set(__self__, "expect_value", expect_value)
        if failure_rate is not None:
            pulumi.set(__self__, "failure_rate", failure_rate)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if is_base_encode is not None:
            pulumi.set(__self__, "is_base_encode", is_base_encode)
        if match_rule is not None:
            pulumi.set(__self__, "match_rule", match_rule)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ping_num is not None:
            pulumi.set(__self__, "ping_num", ping_num)
        if ping_port is not None:
            pulumi.set(__self__, "ping_port", ping_port)
        if ping_type is not None:
            pulumi.set(__self__, "ping_type", ping_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if request_content is not None:
            pulumi.set(__self__, "request_content", request_content)
        if request_format is not None:
            pulumi.set(__self__, "request_format", request_format)
        if response_content is not None:
            pulumi.set(__self__, "response_content", response_content)
        if response_format is not None:
            pulumi.set(__self__, "response_format", response_format)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.SiteMonitorOptionJsonAssertion']]:
        """
        Assertion configuration group. See `assertions` below.
        """
        return pulumi.get(self, "assertions")

    @_builtins.property
    @pulumi.getter
    def attempts(self) -> Optional[_builtins.int]:
        """
        Number of retries after DNS failed.
        """
        return pulumi.get(self, "attempts")

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[_builtins.str]:
        """
        The Cookie that sends the HTTP request.
        """
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter(name="diagnosisMtr")
    def diagnosis_mtr(self) -> Optional[_builtins.bool]:
        """
        Whether to enable automatic MTR network diagnosis after a task failure. Value:
        - false: does not enable automatic MTR network diagnosis.
        - true to turn on automatic MTR network diagnostics.
        """
        return pulumi.get(self, "diagnosis_mtr")

    @_builtins.property
    @pulumi.getter(name="diagnosisPing")
    def diagnosis_ping(self) -> Optional[_builtins.bool]:
        """
        Whether to enable the automatic PING network delay detection after the task fails. Value:
        - false: does not enable automatic PING network delay detection.
        - true: Enable automatic PING network delay detection.
        """
        return pulumi.get(self, "diagnosis_ping")

    @_builtins.property
    @pulumi.getter(name="dnsHijackWhitelist")
    def dns_hijack_whitelist(self) -> Optional[_builtins.str]:
        """
        List of DNS hijacking configurations.
        """
        return pulumi.get(self, "dns_hijack_whitelist")

    @_builtins.property
    @pulumi.getter(name="dnsMatchRule")
    def dns_match_rule(self) -> Optional[_builtins.str]:
        """
        Matching Rules for DNS. Value:
        - IN_DNS: The alias or IP address that is expected to be resolved is in the DNS response.
        - DNS_IN: All DNS responses appear in the alias or IP address that is expected to be resolved.
        - EQUAL: the DNS response is exactly the same as the alias or IP address that is expected to be resolved.
        - ANY:DNS response and the alias or IP address expected to be resolved have an intersection.
        """
        return pulumi.get(self, "dns_match_rule")

    @_builtins.property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[_builtins.str]:
        """
        The IP address of the DNS server.

        > **NOTE:**  only applicable to DNS probe types.
        """
        return pulumi.get(self, "dns_server")

    @_builtins.property
    @pulumi.getter(name="dnsType")
    def dns_type(self) -> Optional[_builtins.str]:
        """
        DNS resolution type. Only applicable to DNS probe types. Value:
        - A (default): specifies the IP address corresponding to the host name or domain name.
        - CNAME: maps multiple domain names to another domain name.
        - NS: specifies that the domain name is resolved by a DNS server.
        - MX: point domain name to a mail server address.
        - TXT: Description of host name or domain name. The text length is limited to 512 bytes, which is usually used as SPF(Sender Policy Framework) record, that is, anti-spam.
        """
        return pulumi.get(self, "dns_type")

    @_builtins.property
    @pulumi.getter(name="expectValue")
    def expect_value(self) -> Optional[_builtins.str]:
        """
        The alias or address to be resolved.

        > **NOTE:**  This parameter applies only to DNS probe types.
        """
        return pulumi.get(self, "expect_value")

    @_builtins.property
    @pulumi.getter(name="failureRate")
    def failure_rate(self) -> Optional[_builtins.str]:
        """
        Packet loss rate.

        > **NOTE:**  This parameter only applies to PING probe types.
        """
        return pulumi.get(self, "failure_rate")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[_builtins.str]:
        """
        HTTP request header.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[_builtins.str]:
        """
        HTTP request method. Value:
        - get
        - post
        - head
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="isBaseEncode")
    def is_base_encode(self) -> Optional[_builtins.bool]:
        """
        Whether the parameter' Password' is Base64 encoded.
        - true: Yes.
        - false: No.
        """
        return pulumi.get(self, "is_base_encode")

    @_builtins.property
    @pulumi.getter(name="matchRule")
    def match_rule(self) -> Optional[_builtins.int]:
        """
        Whether alarm rules are included. Value:
        - 0: Yes.
        - 1: No.
        """
        return pulumi.get(self, "match_rule")

    @_builtins.property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[_builtins.str]:
        """
        Minimum TLS version. By default, TLS1.2 and later versions are supported. TLS1.0 and 1.1 have been disabled. If they still need to be supported, the configuration can be changed.
        """
        return pulumi.get(self, "min_tls_version")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the SMTP, POP3, or FTP probe type.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="pingNum")
    def ping_num(self) -> Optional[_builtins.int]:
        """
        The heartbeat of the PING probe type.
        """
        return pulumi.get(self, "ping_num")

    @_builtins.property
    @pulumi.getter(name="pingPort")
    def ping_port(self) -> Optional[_builtins.int]:
        """
        PING the port. Applies to TCP PING.
        """
        return pulumi.get(self, "ping_port")

    @_builtins.property
    @pulumi.getter(name="pingType")
    def ping_type(self) -> Optional[_builtins.str]:
        """
        The PING protocol type. Value:
        - icmp
        - tcp
        - udp
        """
        return pulumi.get(self, "ping_type")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Ports of TCP, UDP, SMTP, and POP3 probe types.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requestContent")
    def request_content(self) -> Optional[_builtins.str]:
        """
        The request content of the HTTP probe type.
        """
        return pulumi.get(self, "request_content")

    @_builtins.property
    @pulumi.getter(name="requestFormat")
    def request_format(self) -> Optional[_builtins.str]:
        """
        HTTP request content format. Value:
        - hex: hexadecimal format.
        - text: text format.
        """
        return pulumi.get(self, "request_format")

    @_builtins.property
    @pulumi.getter(name="responseContent")
    def response_content(self) -> Optional[_builtins.str]:
        """
        Match the response content.
        """
        return pulumi.get(self, "response_content")

    @_builtins.property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> Optional[_builtins.str]:
        """
        HTTP response content format. Value:
        - hex: hexadecimal format.
        - text: text format.
        """
        return pulumi.get(self, "response_format")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Timeout time. Unit: milliseconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        The username of FTP, SMTP, or pop3.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class SiteMonitorOptionJsonAssertion(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: Assertion comparison operator. Value:
               - contains: contains.
               - doesNotContain: does not contain.
               - matches: regular matching.
               - doesNotMatch: regular mismatch.
               - is: Numeric equals or character matches equals.
               - isNot: not equal.
               - Lesthan: less.
               - moreThan: Greater.
        :param _builtins.str target: Assertion matches the target numeric value or character of the comparison.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Assertion comparison operator. Value:
        - contains: contains.
        - doesNotContain: does not contain.
        - matches: regular matching.
        - doesNotMatch: regular mismatch.
        - is: Numeric equals or character matches equals.
        - isNot: not equal.
        - Lesthan: less.
        - moreThan: Greater.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Assertion matches the target numeric value or character of the comparison.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SlsGroupSlsGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slsLogstore":
            suggest = "sls_logstore"
        elif key == "slsProject":
            suggest = "sls_project"
        elif key == "slsRegion":
            suggest = "sls_region"
        elif key == "slsUserId":
            suggest = "sls_user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlsGroupSlsGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlsGroupSlsGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlsGroupSlsGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sls_logstore: _builtins.str,
                 sls_project: _builtins.str,
                 sls_region: _builtins.str,
                 sls_user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str sls_logstore: The name of the Log Store.
        :param _builtins.str sls_project: The name of the Project.
        :param _builtins.str sls_region: The Sls Region.
        :param _builtins.str sls_user_id: The ID of the Sls User.
        """
        pulumi.set(__self__, "sls_logstore", sls_logstore)
        pulumi.set(__self__, "sls_project", sls_project)
        pulumi.set(__self__, "sls_region", sls_region)
        if sls_user_id is not None:
            pulumi.set(__self__, "sls_user_id", sls_user_id)

    @_builtins.property
    @pulumi.getter(name="slsLogstore")
    def sls_logstore(self) -> _builtins.str:
        """
        The name of the Log Store.
        """
        return pulumi.get(self, "sls_logstore")

    @_builtins.property
    @pulumi.getter(name="slsProject")
    def sls_project(self) -> _builtins.str:
        """
        The name of the Project.
        """
        return pulumi.get(self, "sls_project")

    @_builtins.property
    @pulumi.getter(name="slsRegion")
    def sls_region(self) -> _builtins.str:
        """
        The Sls Region.
        """
        return pulumi.get(self, "sls_region")

    @_builtins.property
    @pulumi.getter(name="slsUserId")
    def sls_user_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Sls User.
        """
        return pulumi.get(self, "sls_user_id")


@pulumi.output_type
class GetAlarmContactGroupsGroupResult(dict):
    def __init__(__self__, *,
                 alarm_contact_group_name: _builtins.str,
                 contacts: Sequence[_builtins.str],
                 describe: _builtins.str,
                 enable_subscribed: _builtins.bool,
                 id: _builtins.str):
        """
        :param _builtins.str alarm_contact_group_name: The name of Alarm Contact Group.
        :param Sequence[_builtins.str] contacts: The alarm contacts in the alarm group.
        :param _builtins.str describe: The description of the Alarm Group.
        :param _builtins.bool enable_subscribed: Indicates whether the alarm group subscribes to weekly reports.
        :param _builtins.str id: The ID of the CMS.
        """
        pulumi.set(__self__, "alarm_contact_group_name", alarm_contact_group_name)
        pulumi.set(__self__, "contacts", contacts)
        pulumi.set(__self__, "describe", describe)
        pulumi.set(__self__, "enable_subscribed", enable_subscribed)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="alarmContactGroupName")
    def alarm_contact_group_name(self) -> _builtins.str:
        """
        The name of Alarm Contact Group.
        """
        return pulumi.get(self, "alarm_contact_group_name")

    @_builtins.property
    @pulumi.getter
    def contacts(self) -> Sequence[_builtins.str]:
        """
        The alarm contacts in the alarm group.
        """
        return pulumi.get(self, "contacts")

    @_builtins.property
    @pulumi.getter
    def describe(self) -> _builtins.str:
        """
        The description of the Alarm Group.
        """
        return pulumi.get(self, "describe")

    @_builtins.property
    @pulumi.getter(name="enableSubscribed")
    def enable_subscribed(self) -> _builtins.bool:
        """
        Indicates whether the alarm group subscribes to weekly reports.
        """
        return pulumi.get(self, "enable_subscribed")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the CMS.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAlarmContactsContactResult(dict):
    def __init__(__self__, *,
                 alarm_contact_name: _builtins.str,
                 channels_aliim: _builtins.str,
                 channels_ding_web_hook: _builtins.str,
                 channels_mail: _builtins.str,
                 channels_sms: _builtins.str,
                 channels_state_aliim: _builtins.str,
                 channels_state_ding_web_hook: _builtins.str,
                 channels_state_mail: _builtins.str,
                 channels_status_sms: _builtins.str,
                 contact_groups: Sequence[_builtins.str],
                 describe: _builtins.str,
                 id: _builtins.str,
                 lang: _builtins.str):
        """
        :param _builtins.str alarm_contact_name: The name of the alarm contact.
        :param _builtins.str channels_aliim: The TradeManager ID of the alarm contact.
        :param _builtins.str channels_ding_web_hook: The webhook URL of the DingTalk chatbot.
        :param _builtins.str channels_mail: The email address of the alarm contact.
        :param _builtins.str channels_sms: The phone number of the alarm contact.
        :param _builtins.str channels_state_aliim: Indicates whether the TradeManager ID is valid.
        :param _builtins.str channels_state_ding_web_hook: Indicates whether the DingTalk chatbot is normal.
        :param _builtins.str channels_state_mail: The status of the email address.
        :param _builtins.str channels_status_sms: The status of the phone number.
               * `Lang` - The language type of the alarm.
        :param Sequence[_builtins.str] contact_groups: The alert groups to which the alarm contact is added.
        :param _builtins.str describe: The description of the alarm contact.
        :param _builtins.str id: The ID of the alarm contact.
        """
        pulumi.set(__self__, "alarm_contact_name", alarm_contact_name)
        pulumi.set(__self__, "channels_aliim", channels_aliim)
        pulumi.set(__self__, "channels_ding_web_hook", channels_ding_web_hook)
        pulumi.set(__self__, "channels_mail", channels_mail)
        pulumi.set(__self__, "channels_sms", channels_sms)
        pulumi.set(__self__, "channels_state_aliim", channels_state_aliim)
        pulumi.set(__self__, "channels_state_ding_web_hook", channels_state_ding_web_hook)
        pulumi.set(__self__, "channels_state_mail", channels_state_mail)
        pulumi.set(__self__, "channels_status_sms", channels_status_sms)
        pulumi.set(__self__, "contact_groups", contact_groups)
        pulumi.set(__self__, "describe", describe)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lang", lang)

    @_builtins.property
    @pulumi.getter(name="alarmContactName")
    def alarm_contact_name(self) -> _builtins.str:
        """
        The name of the alarm contact.
        """
        return pulumi.get(self, "alarm_contact_name")

    @_builtins.property
    @pulumi.getter(name="channelsAliim")
    def channels_aliim(self) -> _builtins.str:
        """
        The TradeManager ID of the alarm contact.
        """
        return pulumi.get(self, "channels_aliim")

    @_builtins.property
    @pulumi.getter(name="channelsDingWebHook")
    def channels_ding_web_hook(self) -> _builtins.str:
        """
        The webhook URL of the DingTalk chatbot.
        """
        return pulumi.get(self, "channels_ding_web_hook")

    @_builtins.property
    @pulumi.getter(name="channelsMail")
    def channels_mail(self) -> _builtins.str:
        """
        The email address of the alarm contact.
        """
        return pulumi.get(self, "channels_mail")

    @_builtins.property
    @pulumi.getter(name="channelsSms")
    def channels_sms(self) -> _builtins.str:
        """
        The phone number of the alarm contact.
        """
        return pulumi.get(self, "channels_sms")

    @_builtins.property
    @pulumi.getter(name="channelsStateAliim")
    def channels_state_aliim(self) -> _builtins.str:
        """
        Indicates whether the TradeManager ID is valid.
        """
        return pulumi.get(self, "channels_state_aliim")

    @_builtins.property
    @pulumi.getter(name="channelsStateDingWebHook")
    def channels_state_ding_web_hook(self) -> _builtins.str:
        """
        Indicates whether the DingTalk chatbot is normal.
        """
        return pulumi.get(self, "channels_state_ding_web_hook")

    @_builtins.property
    @pulumi.getter(name="channelsStateMail")
    def channels_state_mail(self) -> _builtins.str:
        """
        The status of the email address.
        """
        return pulumi.get(self, "channels_state_mail")

    @_builtins.property
    @pulumi.getter(name="channelsStatusSms")
    def channels_status_sms(self) -> _builtins.str:
        """
        The status of the phone number.
        * `Lang` - The language type of the alarm.
        """
        return pulumi.get(self, "channels_status_sms")

    @_builtins.property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> Sequence[_builtins.str]:
        """
        The alert groups to which the alarm contact is added.
        """
        return pulumi.get(self, "contact_groups")

    @_builtins.property
    @pulumi.getter
    def describe(self) -> _builtins.str:
        """
        The description of the alarm contact.
        """
        return pulumi.get(self, "describe")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the alarm contact.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def lang(self) -> _builtins.str:
        return pulumi.get(self, "lang")


@pulumi.output_type
class GetDynamicTagGroupsGroupResult(dict):
    def __init__(__self__, *,
                 dynamic_tag_rule_id: _builtins.str,
                 id: _builtins.str,
                 match_express_filter_relation: _builtins.str,
                 match_expresses: Sequence['outputs.GetDynamicTagGroupsGroupMatchExpressResult'],
                 status: _builtins.str,
                 tag_key: _builtins.str):
        """
        :param _builtins.str dynamic_tag_rule_id: The ID of the tag rule.
        :param _builtins.str id: The ID of the Dynamic Tag Group.
        :param _builtins.str match_express_filter_relation: The relationship between conditional expressions. Valid values: `and`, `or`.
        :param Sequence['GetDynamicTagGroupsGroupMatchExpressArgs'] match_expresses: The label generates a matching expression that applies the grouping. See the following `Block match_express`.
        :param _builtins.str status: The status of the resource. Valid values: `RUNNING`, `FINISH`.
        :param _builtins.str tag_key: The tag key of the tag.
        """
        pulumi.set(__self__, "dynamic_tag_rule_id", dynamic_tag_rule_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "match_express_filter_relation", match_express_filter_relation)
        pulumi.set(__self__, "match_expresses", match_expresses)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tag_key", tag_key)

    @_builtins.property
    @pulumi.getter(name="dynamicTagRuleId")
    def dynamic_tag_rule_id(self) -> _builtins.str:
        """
        The ID of the tag rule.
        """
        return pulumi.get(self, "dynamic_tag_rule_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Dynamic Tag Group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="matchExpressFilterRelation")
    def match_express_filter_relation(self) -> _builtins.str:
        """
        The relationship between conditional expressions. Valid values: `and`, `or`.
        """
        return pulumi.get(self, "match_express_filter_relation")

    @_builtins.property
    @pulumi.getter(name="matchExpresses")
    def match_expresses(self) -> Sequence['outputs.GetDynamicTagGroupsGroupMatchExpressResult']:
        """
        The label generates a matching expression that applies the grouping. See the following `Block match_express`.
        """
        return pulumi.get(self, "match_expresses")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the resource. Valid values: `RUNNING`, `FINISH`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> _builtins.str:
        """
        The tag key of the tag.
        """
        return pulumi.get(self, "tag_key")


@pulumi.output_type
class GetDynamicTagGroupsGroupMatchExpressResult(dict):
    def __init__(__self__, *,
                 tag_value: _builtins.str,
                 tag_value_match_function: _builtins.str):
        """
        :param _builtins.str tag_value: The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
        :param _builtins.str tag_value_match_function: Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
        """
        pulumi.set(__self__, "tag_value", tag_value)
        pulumi.set(__self__, "tag_value_match_function", tag_value_match_function)

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> _builtins.str:
        """
        The tag value. The Tag value must be used in conjunction with the tag value matching method TagValueMatchFunction.
        """
        return pulumi.get(self, "tag_value")

    @_builtins.property
    @pulumi.getter(name="tagValueMatchFunction")
    def tag_value_match_function(self) -> _builtins.str:
        """
        Matching method of tag value. Valid values: `all`, `startWith`,`endWith`,`contains`,`notContains`,`equals`.
        """
        return pulumi.get(self, "tag_value_match_function")


@pulumi.output_type
class GetEventRulesRuleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 event_patterns: Sequence['outputs.GetEventRulesRuleEventPatternResult'],
                 event_rule_name: _builtins.str,
                 event_type: _builtins.str,
                 group_id: _builtins.str,
                 id: _builtins.str,
                 silence_time: _builtins.int,
                 status: _builtins.str):
        """
        :param _builtins.str description: The description of the rule.
        :param Sequence['GetEventRulesRuleEventPatternArgs'] event_patterns: Event mode, used to describe the trigger conditions for this event.
        :param _builtins.str event_rule_name: The name of the event rule.
        :param _builtins.str event_type: The type of event.
        :param _builtins.str group_id: The ID of the application Group.
        :param _builtins.str id: The ID of the Event Rule. Its value is same as Event Rule Name.
        :param _builtins.int silence_time: The mute period during which new alerts are not sent even if the trigger conditions are met.
        :param _builtins.str status: The status of the resource.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "event_patterns", event_patterns)
        pulumi.set(__self__, "event_rule_name", event_rule_name)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "silence_time", silence_time)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence['outputs.GetEventRulesRuleEventPatternResult']:
        """
        Event mode, used to describe the trigger conditions for this event.
        """
        return pulumi.get(self, "event_patterns")

    @_builtins.property
    @pulumi.getter(name="eventRuleName")
    def event_rule_name(self) -> _builtins.str:
        """
        The name of the event rule.
        """
        return pulumi.get(self, "event_rule_name")

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        """
        The type of event.
        """
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        The ID of the application Group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Event Rule. Its value is same as Event Rule Name.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="silenceTime")
    def silence_time(self) -> _builtins.int:
        """
        The mute period during which new alerts are not sent even if the trigger conditions are met.
        """
        return pulumi.get(self, "silence_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEventRulesRuleEventPatternResult(dict):
    def __init__(__self__, *,
                 event_type_lists: Sequence[_builtins.str],
                 keyword_filters: Sequence['outputs.GetEventRulesRuleEventPatternKeywordFilterResult'],
                 level_lists: Sequence[_builtins.str],
                 name_lists: Sequence[_builtins.str],
                 product: _builtins.str,
                 sql_filter: _builtins.str):
        """
        :param Sequence[_builtins.str] event_type_lists: The list of event types.
        :param Sequence['GetEventRulesRuleEventPatternKeywordFilterArgs'] keyword_filters: The filter keyword.
        :param Sequence[_builtins.str] level_lists: The list of event levels.
        :param Sequence[_builtins.str] name_lists: The list of event names.
        :param _builtins.str product: The type of the cloud service.
        :param _builtins.str sql_filter: The SQL condition that is used to filter events.
        """
        pulumi.set(__self__, "event_type_lists", event_type_lists)
        pulumi.set(__self__, "keyword_filters", keyword_filters)
        pulumi.set(__self__, "level_lists", level_lists)
        pulumi.set(__self__, "name_lists", name_lists)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "sql_filter", sql_filter)

    @_builtins.property
    @pulumi.getter(name="eventTypeLists")
    def event_type_lists(self) -> Sequence[_builtins.str]:
        """
        The list of event types.
        """
        return pulumi.get(self, "event_type_lists")

    @_builtins.property
    @pulumi.getter(name="keywordFilters")
    def keyword_filters(self) -> Sequence['outputs.GetEventRulesRuleEventPatternKeywordFilterResult']:
        """
        The filter keyword.
        """
        return pulumi.get(self, "keyword_filters")

    @_builtins.property
    @pulumi.getter(name="levelLists")
    def level_lists(self) -> Sequence[_builtins.str]:
        """
        The list of event levels.
        """
        return pulumi.get(self, "level_lists")

    @_builtins.property
    @pulumi.getter(name="nameLists")
    def name_lists(self) -> Sequence[_builtins.str]:
        """
        The list of event names.
        """
        return pulumi.get(self, "name_lists")

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        The type of the cloud service.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter(name="sqlFilter")
    def sql_filter(self) -> _builtins.str:
        """
        The SQL condition that is used to filter events.
        """
        return pulumi.get(self, "sql_filter")


@pulumi.output_type
class GetEventRulesRuleEventPatternKeywordFilterResult(dict):
    def __init__(__self__, *,
                 key_words: Sequence[_builtins.str],
                 relation: _builtins.str):
        """
        :param Sequence[_builtins.str] key_words: The keywords that are used to match events.
        :param _builtins.str relation: The relationship between multiple keywords in a condition.
        """
        pulumi.set(__self__, "key_words", key_words)
        pulumi.set(__self__, "relation", relation)

    @_builtins.property
    @pulumi.getter(name="keyWords")
    def key_words(self) -> Sequence[_builtins.str]:
        """
        The keywords that are used to match events.
        """
        return pulumi.get(self, "key_words")

    @_builtins.property
    @pulumi.getter
    def relation(self) -> _builtins.str:
        """
        The relationship between multiple keywords in a condition.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class GetGroupMetricRulesRuleResult(dict):
    def __init__(__self__, *,
                 contact_groups: _builtins.str,
                 dimensions: _builtins.str,
                 effective_interval: _builtins.str,
                 email_subject: _builtins.str,
                 enable_state: _builtins.bool,
                 escalations: Sequence['outputs.GetGroupMetricRulesRuleEscalationResult'],
                 group_id: _builtins.str,
                 group_metric_rule_name: _builtins.str,
                 id: _builtins.str,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 no_effective_interval: _builtins.str,
                 period: _builtins.int,
                 resources: _builtins.str,
                 rule_id: _builtins.str,
                 silence_time: _builtins.int,
                 source_type: _builtins.str,
                 status: _builtins.str,
                 webhook: _builtins.str):
        """
        :param _builtins.str contact_groups: Alarm contact group.
        :param _builtins.str dimensions: The dimensions that specify the resources to be associated with the alert rule.
        :param _builtins.str effective_interval: The time period during which the alert rule is effective.
        :param _builtins.str email_subject: The subject of the alert notification email.
        :param _builtins.bool enable_state: Indicates whether the alert rule is enabled.
        :param Sequence['GetGroupMetricRulesRuleEscalationArgs'] escalations: Alarm level.
        :param _builtins.str group_id: The ID of the application group.
        :param _builtins.str group_metric_rule_name: The name of the alert rule.
        :param _builtins.str id: The ID of the Group Metric Rule.
        :param _builtins.str metric_name: The name of the metric.
        :param _builtins.str namespace: The namespace of the service.
        :param _builtins.str no_effective_interval: The time period during which the alert rule is ineffective.
        :param _builtins.int period: The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
        :param _builtins.str resources: The resources that are associated with the alert rule.
        :param _builtins.str rule_id: The ID of the alert rule.
        :param _builtins.int silence_time: The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
        :param _builtins.str source_type: The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
        :param _builtins.str status: The status of Group Metric Rule..
        :param _builtins.str webhook: The callback URL.
        """
        pulumi.set(__self__, "contact_groups", contact_groups)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "effective_interval", effective_interval)
        pulumi.set(__self__, "email_subject", email_subject)
        pulumi.set(__self__, "enable_state", enable_state)
        pulumi.set(__self__, "escalations", escalations)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_metric_rule_name", group_metric_rule_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "no_effective_interval", no_effective_interval)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "silence_time", silence_time)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> _builtins.str:
        """
        Alarm contact group.
        """
        return pulumi.get(self, "contact_groups")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> _builtins.str:
        """
        The dimensions that specify the resources to be associated with the alert rule.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="effectiveInterval")
    def effective_interval(self) -> _builtins.str:
        """
        The time period during which the alert rule is effective.
        """
        return pulumi.get(self, "effective_interval")

    @_builtins.property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> _builtins.str:
        """
        The subject of the alert notification email.
        """
        return pulumi.get(self, "email_subject")

    @_builtins.property
    @pulumi.getter(name="enableState")
    def enable_state(self) -> _builtins.bool:
        """
        Indicates whether the alert rule is enabled.
        """
        return pulumi.get(self, "enable_state")

    @_builtins.property
    @pulumi.getter
    def escalations(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationResult']:
        """
        Alarm level.
        """
        return pulumi.get(self, "escalations")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        The ID of the application group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupMetricRuleName")
    def group_metric_rule_name(self) -> _builtins.str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "group_metric_rule_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Group Metric Rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace of the service.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="noEffectiveInterval")
    def no_effective_interval(self) -> _builtins.str:
        """
        The time period during which the alert rule is ineffective.
        """
        return pulumi.get(self, "no_effective_interval")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        The aggregation period of the monitoring data. Unit: seconds. The value is an integral multiple of 60. Default value: `300`.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> _builtins.str:
        """
        The resources that are associated with the alert rule.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.str:
        """
        The ID of the alert rule.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="silenceTime")
    def silence_time(self) -> _builtins.int:
        """
        The mute period during which new alerts are not reported even if the alert trigger conditions are met. Unit: seconds. Default value: `86400`, which is equivalent to one day.
        """
        return pulumi.get(self, "silence_time")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        The type of the alert rule. The value is fixed to METRIC, indicating an alert rule for time series metrics.
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of Group Metric Rule..
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> _builtins.str:
        """
        The callback URL.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationResult(dict):
    def __init__(__self__, *,
                 criticals: Sequence['outputs.GetGroupMetricRulesRuleEscalationCriticalResult'],
                 infos: Sequence['outputs.GetGroupMetricRulesRuleEscalationInfoResult'],
                 warns: Sequence['outputs.GetGroupMetricRulesRuleEscalationWarnResult']):
        """
        :param Sequence['GetGroupMetricRulesRuleEscalationCriticalArgs'] criticals: The critical level.
        :param Sequence['GetGroupMetricRulesRuleEscalationInfoArgs'] infos: The info level.
        :param Sequence['GetGroupMetricRulesRuleEscalationWarnArgs'] warns: The warn level.
        """
        pulumi.set(__self__, "criticals", criticals)
        pulumi.set(__self__, "infos", infos)
        pulumi.set(__self__, "warns", warns)

    @_builtins.property
    @pulumi.getter
    def criticals(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationCriticalResult']:
        """
        The critical level.
        """
        return pulumi.get(self, "criticals")

    @_builtins.property
    @pulumi.getter
    def infos(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationInfoResult']:
        """
        The info level.
        """
        return pulumi.get(self, "infos")

    @_builtins.property
    @pulumi.getter
    def warns(self) -> Sequence['outputs.GetGroupMetricRulesRuleEscalationWarnResult']:
        """
        The warn level.
        """
        return pulumi.get(self, "warns")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationCriticalResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 statistics: _builtins.str,
                 threshold: _builtins.str,
                 times: _builtins.int):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for critical-level alerts.
        :param _builtins.str statistics: The statistical aggregation method for critical-level alerts.
        :param _builtins.str threshold: The threshold for critical-level alerts.
        :param _builtins.int times: The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        The comparison operator of the threshold for critical-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> _builtins.str:
        """
        The statistical aggregation method for critical-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The threshold for critical-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.int:
        """
        The consecutive number of times for which the metric value is measured before a critical-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationInfoResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 statistics: _builtins.str,
                 threshold: _builtins.str,
                 times: _builtins.int):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for info-level alerts.
        :param _builtins.str statistics: The statistical aggregation method for info-level alerts.
        :param _builtins.str threshold: The threshold for info-level alerts.
        :param _builtins.int times: The consecutive number of times for which the metric value is measured before a info-level alert is triggered.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        The comparison operator of the threshold for info-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> _builtins.str:
        """
        The statistical aggregation method for info-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The threshold for info-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.int:
        """
        The consecutive number of times for which the metric value is measured before a info-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetGroupMetricRulesRuleEscalationWarnResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 statistics: _builtins.str,
                 threshold: _builtins.str,
                 times: _builtins.int):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.int times: The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        The comparison operator of the threshold for warn-level alerts.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> _builtins.str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.int:
        """
        The consecutive number of times for which the metric value is measured before a warn-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetHybridMonitorDatasDataResult(dict):
    def __init__(__self__, *,
                 labels: Sequence['outputs.GetHybridMonitorDatasDataLabelResult'],
                 metric_name: _builtins.str,
                 values: Sequence['outputs.GetHybridMonitorDatasDataValueResult']):
        """
        :param Sequence['GetHybridMonitorDatasDataLabelArgs'] labels: The label of the time dimension.
        :param _builtins.str metric_name: The name of the monitoring indicator.
        :param Sequence['GetHybridMonitorDatasDataValueArgs'] values: The metric values that are collected at different timestamps.
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetHybridMonitorDatasDataLabelResult']:
        """
        The label of the time dimension.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of the monitoring indicator.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetHybridMonitorDatasDataValueResult']:
        """
        The metric values that are collected at different timestamps.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetHybridMonitorDatasDataLabelResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Label key.
        :param _builtins.str value: Label value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Label key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Label value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorDatasDataValueResult(dict):
    def __init__(__self__, *,
                 ts: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str ts: The timestamp that indicates the time when the metric value is collected. Unit: seconds.
        :param _builtins.str value: The value of the monitoring indicator.
        """
        pulumi.set(__self__, "ts", ts)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def ts(self) -> _builtins.str:
        """
        The timestamp that indicates the time when the metric value is collected. Unit: seconds.
        """
        return pulumi.get(self, "ts")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the monitoring indicator.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorFcTasksTaskResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 hybrid_monitor_fc_task_id: _builtins.str,
                 id: _builtins.str,
                 namespace: _builtins.str,
                 target_user_id: _builtins.str,
                 yarm_config: _builtins.str):
        """
        :param _builtins.str create_time: Create the timestamp of the monitoring task. Unit: milliseconds.
        :param _builtins.str hybrid_monitor_fc_task_id: The ID of the monitoring task.
        :param _builtins.str id: The ID of the Hybrid Monitor Fc Task. The value formats as `<hybrid_monitor_fc_task_id>:<namespace>`.
        :param _builtins.str namespace: The index warehouse where the host belongs.
        :param _builtins.str target_user_id: The ID of the member account.
        :param _builtins.str yarm_config: The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "hybrid_monitor_fc_task_id", hybrid_monitor_fc_task_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "target_user_id", target_user_id)
        pulumi.set(__self__, "yarm_config", yarm_config)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create the timestamp of the monitoring task. Unit: milliseconds.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="hybridMonitorFcTaskId")
    def hybrid_monitor_fc_task_id(self) -> _builtins.str:
        """
        The ID of the monitoring task.
        """
        return pulumi.get(self, "hybrid_monitor_fc_task_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Hybrid Monitor Fc Task. The value formats as `<hybrid_monitor_fc_task_id>:<namespace>`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The index warehouse where the host belongs.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="targetUserId")
    def target_user_id(self) -> _builtins.str:
        """
        The ID of the member account.
        """
        return pulumi.get(self, "target_user_id")

    @_builtins.property
    @pulumi.getter(name="yarmConfig")
    def yarm_config(self) -> _builtins.str:
        """
        The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
        """
        return pulumi.get(self, "yarm_config")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskResult(dict):
    def __init__(__self__, *,
                 attach_labels: Sequence['outputs.GetHybridMonitorSlsTasksTaskAttachLabelResult'],
                 collect_interval: _builtins.int,
                 collect_target_endpoint: _builtins.str,
                 collect_target_path: _builtins.str,
                 collect_target_type: _builtins.str,
                 collect_timout: _builtins.int,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 extra_info: _builtins.str,
                 group_id: _builtins.str,
                 hybrid_monitor_sls_task_id: _builtins.str,
                 id: _builtins.str,
                 instances: Sequence[_builtins.str],
                 log_file_path: _builtins.str,
                 log_process: _builtins.str,
                 log_sample: _builtins.str,
                 log_split: _builtins.str,
                 match_express_relation: _builtins.str,
                 match_expresses: Sequence['outputs.GetHybridMonitorSlsTasksTaskMatchExpressResult'],
                 namespace: _builtins.str,
                 network_type: _builtins.str,
                 sls_process: _builtins.str,
                 sls_process_configs: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigResult'],
                 task_name: _builtins.str,
                 task_type: _builtins.str,
                 upload_region: _builtins.str,
                 yarm_config: _builtins.str):
        """
        :param Sequence['GetHybridMonitorSlsTasksTaskAttachLabelArgs'] attach_labels: The tags of the metric import task.
        :param _builtins.int collect_interval: The interval between the cloud monitoring plug-in collecting host monitoring data.
        :param _builtins.str collect_target_endpoint: The address where the cloudmonitor Plug-In collects the monitoring data of the host.
        :param _builtins.str collect_target_path: When the cloud monitor Agent collects, the relative path of the collection.
        :param _builtins.str collect_target_type: The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, MySQL, and AWS.
        :param _builtins.int collect_timout: The timeout period for the cloudmonitor plug-in to collect host monitoring data.
        :param _builtins.str create_time: Create the timestamp of the monitoring task. Unit: milliseconds.
        :param _builtins.str description: Monitoring task description.
        :param _builtins.str extra_info: Additional information for the instance.
        :param _builtins.str group_id: The ID of the application Group.
        :param _builtins.str hybrid_monitor_sls_task_id: The ID of the monitoring task.
        :param _builtins.str id: The ID of the Hybrid Monitor Sls Task.
        :param Sequence[_builtins.str] instances: A list of instances where monitoring data is collected in batches.
        :param _builtins.str log_file_path: The path where on-premises log data is stored. On-premises log data is stored in the specified path of the host where CloudMonitor is deployed.
        :param _builtins.str log_process: Local Log Monitoring and calculation method.
        :param _builtins.str log_sample: The sample on-premises log.
        :param _builtins.str log_split: The local log data is divided according to different matching patterns.
        :param _builtins.str match_express_relation: The filter condition of the instance of the monitoring task.
        :param Sequence['GetHybridMonitorSlsTasksTaskMatchExpressArgs'] match_expresses: The matching condition of the instance in the application Group.
        :param _builtins.str namespace: The namespace to which the host belongs.
        :param _builtins.str network_type: The network type of the host.
        :param _builtins.str sls_process: The configurations of the logs that are imported from Log Service.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigArgs'] sls_process_configs: The configurations of the logs that are imported from Log Service.
        :param _builtins.str task_name: The name of the metric import task.
        :param _builtins.str task_type: Monitoring Task type.
        :param _builtins.str upload_region: The region where the host resides.
        """
        pulumi.set(__self__, "attach_labels", attach_labels)
        pulumi.set(__self__, "collect_interval", collect_interval)
        pulumi.set(__self__, "collect_target_endpoint", collect_target_endpoint)
        pulumi.set(__self__, "collect_target_path", collect_target_path)
        pulumi.set(__self__, "collect_target_type", collect_target_type)
        pulumi.set(__self__, "collect_timout", collect_timout)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "extra_info", extra_info)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "hybrid_monitor_sls_task_id", hybrid_monitor_sls_task_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "log_file_path", log_file_path)
        pulumi.set(__self__, "log_process", log_process)
        pulumi.set(__self__, "log_sample", log_sample)
        pulumi.set(__self__, "log_split", log_split)
        pulumi.set(__self__, "match_express_relation", match_express_relation)
        pulumi.set(__self__, "match_expresses", match_expresses)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "sls_process", sls_process)
        pulumi.set(__self__, "sls_process_configs", sls_process_configs)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "upload_region", upload_region)
        pulumi.set(__self__, "yarm_config", yarm_config)

    @_builtins.property
    @pulumi.getter(name="attachLabels")
    def attach_labels(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskAttachLabelResult']:
        """
        The tags of the metric import task.
        """
        return pulumi.get(self, "attach_labels")

    @_builtins.property
    @pulumi.getter(name="collectInterval")
    def collect_interval(self) -> _builtins.int:
        """
        The interval between the cloud monitoring plug-in collecting host monitoring data.
        """
        return pulumi.get(self, "collect_interval")

    @_builtins.property
    @pulumi.getter(name="collectTargetEndpoint")
    def collect_target_endpoint(self) -> _builtins.str:
        """
        The address where the cloudmonitor Plug-In collects the monitoring data of the host.
        """
        return pulumi.get(self, "collect_target_endpoint")

    @_builtins.property
    @pulumi.getter(name="collectTargetPath")
    def collect_target_path(self) -> _builtins.str:
        """
        When the cloud monitor Agent collects, the relative path of the collection.
        """
        return pulumi.get(self, "collect_target_path")

    @_builtins.property
    @pulumi.getter(name="collectTargetType")
    def collect_target_type(self) -> _builtins.str:
        """
        The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, MySQL, and AWS.
        """
        return pulumi.get(self, "collect_target_type")

    @_builtins.property
    @pulumi.getter(name="collectTimout")
    def collect_timout(self) -> _builtins.int:
        """
        The timeout period for the cloudmonitor plug-in to collect host monitoring data.
        """
        return pulumi.get(self, "collect_timout")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create the timestamp of the monitoring task. Unit: milliseconds.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Monitoring task description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="extraInfo")
    def extra_info(self) -> _builtins.str:
        """
        Additional information for the instance.
        """
        return pulumi.get(self, "extra_info")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        The ID of the application Group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="hybridMonitorSlsTaskId")
    def hybrid_monitor_sls_task_id(self) -> _builtins.str:
        """
        The ID of the monitoring task.
        """
        return pulumi.get(self, "hybrid_monitor_sls_task_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Hybrid Monitor Sls Task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Sequence[_builtins.str]:
        """
        A list of instances where monitoring data is collected in batches.
        """
        return pulumi.get(self, "instances")

    @_builtins.property
    @pulumi.getter(name="logFilePath")
    def log_file_path(self) -> _builtins.str:
        """
        The path where on-premises log data is stored. On-premises log data is stored in the specified path of the host where CloudMonitor is deployed.
        """
        return pulumi.get(self, "log_file_path")

    @_builtins.property
    @pulumi.getter(name="logProcess")
    def log_process(self) -> _builtins.str:
        """
        Local Log Monitoring and calculation method.
        """
        return pulumi.get(self, "log_process")

    @_builtins.property
    @pulumi.getter(name="logSample")
    def log_sample(self) -> _builtins.str:
        """
        The sample on-premises log.
        """
        return pulumi.get(self, "log_sample")

    @_builtins.property
    @pulumi.getter(name="logSplit")
    def log_split(self) -> _builtins.str:
        """
        The local log data is divided according to different matching patterns.
        """
        return pulumi.get(self, "log_split")

    @_builtins.property
    @pulumi.getter(name="matchExpressRelation")
    def match_express_relation(self) -> _builtins.str:
        """
        The filter condition of the instance of the monitoring task.
        """
        return pulumi.get(self, "match_express_relation")

    @_builtins.property
    @pulumi.getter(name="matchExpresses")
    def match_expresses(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskMatchExpressResult']:
        """
        The matching condition of the instance in the application Group.
        """
        return pulumi.get(self, "match_expresses")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace to which the host belongs.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> _builtins.str:
        """
        The network type of the host.
        """
        return pulumi.get(self, "network_type")

    @_builtins.property
    @pulumi.getter(name="slsProcess")
    def sls_process(self) -> _builtins.str:
        """
        The configurations of the logs that are imported from Log Service.
        """
        return pulumi.get(self, "sls_process")

    @_builtins.property
    @pulumi.getter(name="slsProcessConfigs")
    def sls_process_configs(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigResult']:
        """
        The configurations of the logs that are imported from Log Service.
        """
        return pulumi.get(self, "sls_process_configs")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        The name of the metric import task.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Monitoring Task type.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="uploadRegion")
    def upload_region(self) -> _builtins.str:
        """
        The region where the host resides.
        """
        return pulumi.get(self, "upload_region")

    @_builtins.property
    @pulumi.getter(name="yarmConfig")
    def yarm_config(self) -> _builtins.str:
        return pulumi.get(self, "yarm_config")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskAttachLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The key of the tag.
        :param _builtins.str value: The value of the tag.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The key of the tag.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskMatchExpressResult(dict):
    def __init__(__self__, *,
                 function: _builtins.str,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str function: The method that is used to match the instance name.
        :param _builtins.str name: The name of the instance.
        :param _builtins.str value: The keyword that corresponds to the instance name.
        """
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def function(self) -> _builtins.str:
        """
        The method that is used to match the instance name.
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The keyword that corresponds to the instance name.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigResult(dict):
    def __init__(__self__, *,
                 expresses: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult'],
                 filters: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult'],
                 group_bies: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult'],
                 statistics: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult']):
        """
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterArgs'] filters: The conditions that are used to filter logs imported from Log Service.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByArgs'] group_bies: The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticArgs'] statistics: The method that is used to aggregate logs imported from Log Service.
        """
        pulumi.set(__self__, "expresses", expresses)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "statistics", statistics)

    @_builtins.property
    @pulumi.getter
    def expresses(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult']:
        return pulumi.get(self, "expresses")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult']:
        """
        The conditions that are used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult']:
        """
        The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult']:
        """
        The method that is used to aggregate logs imported from Log Service.
        """
        return pulumi.get(self, "statistics")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigExpressResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 express: _builtins.str):
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "express", express)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def express(self) -> _builtins.str:
        return pulumi.get(self, "express")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterResult(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult'],
                 relation: _builtins.str):
        """
        :param Sequence['GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterArgs'] filters: The conditions that are used to filter logs imported from Log Service.
        :param _builtins.str relation: The relationship between multiple filter conditions.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "relation", relation)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult']:
        """
        The conditions that are used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def relation(self) -> _builtins.str:
        """
        The relationship between multiple filter conditions.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilterResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 sls_key_name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str operator: The method that is used to filter logs imported from Log Service.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "sls_key_name", sls_key_name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The method that is used to filter logs imported from Log Service.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> _builtins.str:
        return pulumi.get(self, "sls_key_name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigGroupByResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 sls_key_name: _builtins.str):
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "sls_key_name", sls_key_name)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> _builtins.str:
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class GetHybridMonitorSlsTasksTaskSlsProcessConfigStatisticResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 function: _builtins.str,
                 parameter_one: _builtins.str,
                 parameter_two: _builtins.str,
                 sls_key_name: _builtins.str):
        """
        :param _builtins.str parameter_one: The value of the function that is used to aggregate logs imported from Log Service.
        :param _builtins.str parameter_two: The value of the function that is used to aggregate logs imported from Log Service.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "parameter_one", parameter_one)
        pulumi.set(__self__, "parameter_two", parameter_two)
        pulumi.set(__self__, "sls_key_name", sls_key_name)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def function(self) -> _builtins.str:
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter(name="parameterOne")
    def parameter_one(self) -> _builtins.str:
        """
        The value of the function that is used to aggregate logs imported from Log Service.
        """
        return pulumi.get(self, "parameter_one")

    @_builtins.property
    @pulumi.getter(name="parameterTwo")
    def parameter_two(self) -> _builtins.str:
        """
        The value of the function that is used to aggregate logs imported from Log Service.
        """
        return pulumi.get(self, "parameter_two")

    @_builtins.property
    @pulumi.getter(name="slsKeyName")
    def sls_key_name(self) -> _builtins.str:
        return pulumi.get(self, "sls_key_name")


@pulumi.output_type
class GetMetricRuleBlackListsListResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 create_time: _builtins.str,
                 effective_time: _builtins.str,
                 enable_end_time: _builtins.str,
                 enable_start_time: _builtins.str,
                 id: _builtins.str,
                 instances: Sequence[_builtins.str],
                 is_enable: _builtins.bool,
                 metric_rule_black_list_id: _builtins.str,
                 metric_rule_black_list_name: _builtins.str,
                 metrics: Sequence['outputs.GetMetricRuleBlackListsListMetricResult'],
                 namespace: _builtins.str,
                 scope_type: _builtins.str,
                 scope_values: Sequence[_builtins.str]):
        """
        :param _builtins.str category: Cloud service classification. For example, Redis includes kvstore_standard, kvstore_sharding, and kvstore_splitrw.
        :param _builtins.str create_time: The timestamp for creating an alert blacklist policy.Unit: milliseconds.
        :param _builtins.str effective_time: The effective time range of the alert blacklist policy.
        :param _builtins.str enable_end_time: The start timestamp of the alert blacklist policy.Unit: milliseconds.
        :param _builtins.str enable_start_time: The end timestamp of the alert blacklist policy.Unit: milliseconds.
        :param Sequence[_builtins.str] instances: The list of instances of cloud services specified in the alert blacklist policy.
        :param _builtins.bool is_enable: The status of the alert blacklist policy. Value:-true: enabled.-false: disabled.
        :param _builtins.str metric_rule_black_list_id: The first ID of the resource
        :param _builtins.str metric_rule_black_list_name: The name of the alert blacklist policy.
        :param Sequence['GetMetricRuleBlackListsListMetricArgs'] metrics: Monitoring metrics in the instance.
        :param _builtins.str namespace: The data namespace of the cloud service.
        :param _builtins.str scope_type: The effective range of the alert blacklist policy. Value:-USER: The alert blacklist policy only takes effect in the current Alibaba cloud account.-GROUP: The alert blacklist policy takes effect in the specified application GROUP.
        :param Sequence[_builtins.str] scope_values: Application Group ID list. The format is JSON Array.> This parameter is displayed only when 'ScopeType' is 'GROUP.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "effective_time", effective_time)
        pulumi.set(__self__, "enable_end_time", enable_end_time)
        pulumi.set(__self__, "enable_start_time", enable_start_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "is_enable", is_enable)
        pulumi.set(__self__, "metric_rule_black_list_id", metric_rule_black_list_id)
        pulumi.set(__self__, "metric_rule_black_list_name", metric_rule_black_list_name)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "scope_type", scope_type)
        pulumi.set(__self__, "scope_values", scope_values)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Cloud service classification. For example, Redis includes kvstore_standard, kvstore_sharding, and kvstore_splitrw.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The timestamp for creating an alert blacklist policy.Unit: milliseconds.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="effectiveTime")
    def effective_time(self) -> _builtins.str:
        """
        The effective time range of the alert blacklist policy.
        """
        return pulumi.get(self, "effective_time")

    @_builtins.property
    @pulumi.getter(name="enableEndTime")
    def enable_end_time(self) -> _builtins.str:
        """
        The start timestamp of the alert blacklist policy.Unit: milliseconds.
        """
        return pulumi.get(self, "enable_end_time")

    @_builtins.property
    @pulumi.getter(name="enableStartTime")
    def enable_start_time(self) -> _builtins.str:
        """
        The end timestamp of the alert blacklist policy.Unit: milliseconds.
        """
        return pulumi.get(self, "enable_start_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Sequence[_builtins.str]:
        """
        The list of instances of cloud services specified in the alert blacklist policy.
        """
        return pulumi.get(self, "instances")

    @_builtins.property
    @pulumi.getter(name="isEnable")
    def is_enable(self) -> _builtins.bool:
        """
        The status of the alert blacklist policy. Value:-true: enabled.-false: disabled.
        """
        return pulumi.get(self, "is_enable")

    @_builtins.property
    @pulumi.getter(name="metricRuleBlackListId")
    def metric_rule_black_list_id(self) -> _builtins.str:
        """
        The first ID of the resource
        """
        return pulumi.get(self, "metric_rule_black_list_id")

    @_builtins.property
    @pulumi.getter(name="metricRuleBlackListName")
    def metric_rule_black_list_name(self) -> _builtins.str:
        """
        The name of the alert blacklist policy.
        """
        return pulumi.get(self, "metric_rule_black_list_name")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetMetricRuleBlackListsListMetricResult']:
        """
        Monitoring metrics in the instance.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The data namespace of the cloud service.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> _builtins.str:
        """
        The effective range of the alert blacklist policy. Value:-USER: The alert blacklist policy only takes effect in the current Alibaba cloud account.-GROUP: The alert blacklist policy takes effect in the specified application GROUP.
        """
        return pulumi.get(self, "scope_type")

    @_builtins.property
    @pulumi.getter(name="scopeValues")
    def scope_values(self) -> Sequence[_builtins.str]:
        """
        Application Group ID list. The format is JSON Array.> This parameter is displayed only when 'ScopeType' is 'GROUP.
        """
        return pulumi.get(self, "scope_values")


@pulumi.output_type
class GetMetricRuleBlackListsListMetricResult(dict):
    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 resource: _builtins.str):
        """
        :param _builtins.str metric_name: The name of the monitoring indicator.
        :param _builtins.str resource: The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of the monitoring indicator.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        The extended dimension information of the instance. For example, '{"device":"C:"}' indicates that the blacklist policy is applied to all C disks under the ECS instance.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 alert_templates: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateResult'],
                 description: _builtins.str,
                 group_id: _builtins.str,
                 id: _builtins.str,
                 metric_rule_template_name: _builtins.str,
                 rest_version: _builtins.str,
                 template_id: _builtins.str):
        """
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateArgs'] alert_templates: The details of alert rules that are generated based on the alert template.
        :param _builtins.str description: The description of the alert template.
        :param _builtins.str group_id: GroupId.
        :param _builtins.str id: The ID of the Metric Rule Template.
        :param _builtins.str metric_rule_template_name: The name of the alert template.
        :param _builtins.str rest_version: The version of the alert template.
               
               > **NOTE:** The version changes with the number of times that the alert template is modified.
        :param _builtins.str template_id: The ID of the alert template.
        """
        pulumi.set(__self__, "alert_templates", alert_templates)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metric_rule_template_name", metric_rule_template_name)
        pulumi.set(__self__, "rest_version", rest_version)
        pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="alertTemplates")
    def alert_templates(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateResult']:
        """
        The details of alert rules that are generated based on the alert template.
        """
        return pulumi.get(self, "alert_templates")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the alert template.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        GroupId.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Metric Rule Template.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="metricRuleTemplateName")
    def metric_rule_template_name(self) -> _builtins.str:
        """
        The name of the alert template.
        """
        return pulumi.get(self, "metric_rule_template_name")

    @_builtins.property
    @pulumi.getter(name="restVersion")
    def rest_version(self) -> _builtins.str:
        """
        The version of the alert template.

        > **NOTE:** The version changes with the number of times that the alert template is modified.
        """
        return pulumi.get(self, "rest_version")

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        The ID of the alert template.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 escalations: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult'],
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 rule_name: _builtins.str,
                 selector: _builtins.str,
                 webhook: _builtins.str):
        """
        :param _builtins.str category: The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iot_edge`, `kvstore_sharding`, `kvstore_splitrw`, `kvstore_standard`, `memcache`, `mns`, `mongodb`, `mongodb_cluster`, `mongodb_sharding`, `mq_topic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationArgs'] escalations: The information about the trigger condition based on the alert level.
        :param _builtins.str metric_name: The name of the metric.
        :param _builtins.str namespace: The namespace of the service.
        :param _builtins.str rule_name: The name of the alert rule.
        :param _builtins.str webhook: The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "escalations", escalations)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The abbreviation of the service name. Valid values: `ecs`, `rds`, `ads`, `slb`, `vpc`, `apigateway`, `cdn`, `cs`, `dcdn`, `ddos`, `eip`, `elasticsearch`, `emr`, `ess`, `hbase`, `iot_edge`, `kvstore_sharding`, `kvstore_splitrw`, `kvstore_standard`, `memcache`, `mns`, `mongodb`, `mongodb_cluster`, `mongodb_sharding`, `mq_topic`, `ocs`, `opensearch`, `oss`, `polardb`, `petadata`, `scdn`, `sharebandwidthpackages`, `sls`, `vpn`.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def escalations(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult']:
        """
        The information about the trigger condition based on the alert level.
        """
        return pulumi.get(self, "escalations")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace of the service.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> _builtins.str:
        """
        The name of the alert rule.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> _builtins.str:
        return pulumi.get(self, "selector")

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> _builtins.str:
        """
        The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationResult(dict):
    def __init__(__self__, *,
                 criticals: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult'],
                 infos: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult'],
                 warns: Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult']):
        """
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalArgs'] criticals: The condition for triggering critical-level alerts.
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoArgs'] infos: The condition for triggering info-level alerts.
        :param Sequence['GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnArgs'] warns: The condition for triggering warn-level alerts.
        """
        pulumi.set(__self__, "criticals", criticals)
        pulumi.set(__self__, "infos", infos)
        pulumi.set(__self__, "warns", warns)

    @_builtins.property
    @pulumi.getter
    def criticals(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult']:
        """
        The condition for triggering critical-level alerts.
        """
        return pulumi.get(self, "criticals")

    @_builtins.property
    @pulumi.getter
    def infos(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult']:
        """
        The condition for triggering info-level alerts.
        """
        return pulumi.get(self, "infos")

    @_builtins.property
    @pulumi.getter
    def warns(self) -> Sequence['outputs.GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult']:
        """
        The condition for triggering warn-level alerts.
        """
        return pulumi.get(self, "warns")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationCriticalResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 statistics: _builtins.str,
                 threshold: _builtins.str,
                 times: _builtins.str):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for critical-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param _builtins.str statistics: The statistical aggregation method for critical-level alerts.
        :param _builtins.str threshold: The threshold for critical-level alerts.
        :param _builtins.str times: The consecutive number of times for which the metric value is measured before a
               critical-level alert is triggered.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        The comparison operator of the threshold for critical-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> _builtins.str:
        """
        The statistical aggregation method for critical-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The threshold for critical-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.str:
        """
        The consecutive number of times for which the metric value is measured before a
        critical-level alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationInfoResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 statistics: _builtins.str,
                 threshold: _builtins.str,
                 times: _builtins.str):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for info-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param _builtins.str statistics: The statistical aggregation method for info-level alerts.
        :param _builtins.str threshold: The threshold for info-level alerts.
        :param _builtins.str times: The consecutive number of times for which the metric value is measured before an info-level
               alert is triggered.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        The comparison operator of the threshold for info-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> _builtins.str:
        """
        The statistical aggregation method for info-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The threshold for info-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.str:
        """
        The consecutive number of times for which the metric value is measured before an info-level
        alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetMetricRuleTemplatesTemplateAlertTemplateEscalationWarnResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 statistics: _builtins.str,
                 threshold: _builtins.str,
                 times: _builtins.str):
        """
        :param _builtins.str comparison_operator: The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        :param _builtins.str statistics: The statistical aggregation method for warn-level alerts.
        :param _builtins.str threshold: The threshold for warn-level alerts.
        :param _builtins.str times: The consecutive number of times for which the metric value is measured before a warn-level
               alert is triggered.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "times", times)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        The comparison operator of the threshold for warn-level alerts.Valid values: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanOrEqualToThreshold`, `LessThanThreshold`, `NotEqualToThreshold`, `GreaterThanYesterday`, `LessThanYesterday`, `GreaterThanLastWeek`, `LessThanLastWeek`, `GreaterThanLastPeriod`, `LessThanLastPeriod`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> _builtins.str:
        """
        The statistical aggregation method for warn-level alerts.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The threshold for warn-level alerts.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.str:
        """
        The consecutive number of times for which the metric value is measured before a warn-level
        alert is triggered.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetMonitorGroupInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 instances: Sequence['outputs.GetMonitorGroupInstancesInstanceInstanceResult']):
        pulumi.set(__self__, "instances", instances)

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetMonitorGroupInstancesInstanceInstanceResult']:
        return pulumi.get(self, "instances")


@pulumi.output_type
class GetMonitorGroupInstancesInstanceInstanceResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str,
                 region_id: _builtins.str):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "region_id", region_id)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        return pulumi.get(self, "region_id")


@pulumi.output_type
class GetMonitorGroupsGroupResult(dict):
    def __init__(__self__, *,
                 bind_url: _builtins.str,
                 contact_groups: Sequence[_builtins.str],
                 dynamic_tag_rule_id: _builtins.str,
                 gmt_create: _builtins.int,
                 gmt_modified: _builtins.int,
                 group_id: _builtins.str,
                 id: _builtins.str,
                 monitor_group_name: _builtins.str,
                 service_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 template_ids: Sequence[_builtins.str],
                 type: _builtins.str):
        """
        :param _builtins.str bind_url: The URL of the Kubernetes cluster from which the application group is synchronized.
        :param Sequence[_builtins.str] contact_groups: The list of  alert groups that receive alert notifications for the application group.
        :param _builtins.str dynamic_tag_rule_id: The ID of the tag rule.
        :param _builtins.int gmt_create: The time when the application group was created.
        :param _builtins.int gmt_modified: The time when the application group was modified.
        :param _builtins.str group_id: The ID of the application group.
        :param _builtins.str id: The ID of the Monitor Group.
        :param _builtins.str monitor_group_name: The name of the application group.
        :param _builtins.str service_id: The ID of the Alibaba Cloud service.
        :param Mapping[str, _builtins.str] tags: A map of tags assigned to the Cms Monitor Group.
        :param Sequence[_builtins.str] template_ids: The alert templates applied to the application group.
        :param _builtins.str type: The type of the application group.
        """
        pulumi.set(__self__, "bind_url", bind_url)
        pulumi.set(__self__, "contact_groups", contact_groups)
        pulumi.set(__self__, "dynamic_tag_rule_id", dynamic_tag_rule_id)
        pulumi.set(__self__, "gmt_create", gmt_create)
        pulumi.set(__self__, "gmt_modified", gmt_modified)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "monitor_group_name", monitor_group_name)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "template_ids", template_ids)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bindUrl")
    def bind_url(self) -> _builtins.str:
        """
        The URL of the Kubernetes cluster from which the application group is synchronized.
        """
        return pulumi.get(self, "bind_url")

    @_builtins.property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> Sequence[_builtins.str]:
        """
        The list of  alert groups that receive alert notifications for the application group.
        """
        return pulumi.get(self, "contact_groups")

    @_builtins.property
    @pulumi.getter(name="dynamicTagRuleId")
    def dynamic_tag_rule_id(self) -> _builtins.str:
        """
        The ID of the tag rule.
        """
        return pulumi.get(self, "dynamic_tag_rule_id")

    @_builtins.property
    @pulumi.getter(name="gmtCreate")
    def gmt_create(self) -> _builtins.int:
        """
        The time when the application group was created.
        """
        return pulumi.get(self, "gmt_create")

    @_builtins.property
    @pulumi.getter(name="gmtModified")
    def gmt_modified(self) -> _builtins.int:
        """
        The time when the application group was modified.
        """
        return pulumi.get(self, "gmt_modified")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        The ID of the application group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Monitor Group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="monitorGroupName")
    def monitor_group_name(self) -> _builtins.str:
        """
        The name of the application group.
        """
        return pulumi.get(self, "monitor_group_name")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The ID of the Alibaba Cloud service.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A map of tags assigned to the Cms Monitor Group.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="templateIds")
    def template_ids(self) -> Sequence[_builtins.str]:
        """
        The alert templates applied to the application group.
        """
        return pulumi.get(self, "template_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the application group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 modify_time: _builtins.str,
                 namespace: _builtins.str,
                 namespace_id: _builtins.str,
                 specification: _builtins.str):
        """
        :param _builtins.str create_time: Create the timestamp of the indicator warehouse.
        :param _builtins.str description: Description of indicator warehouse.
        :param _builtins.str id: The ID of the Namespace.
        :param _builtins.str modify_time: The timestamp of the last modification indicator warehouse.
        :param _builtins.str namespace: Indicator warehouse name.
        :param _builtins.str namespace_id: The ID of the Namespace.
        :param _builtins.str specification: Data storage duration.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "specification", specification)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        Create the timestamp of the indicator warehouse.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of indicator warehouse.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Namespace.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        The timestamp of the last modification indicator warehouse.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Indicator warehouse name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> _builtins.str:
        """
        The ID of the Namespace.
        """
        return pulumi.get(self, "namespace_id")

    @_builtins.property
    @pulumi.getter
    def specification(self) -> _builtins.str:
        """
        Data storage duration.
        """
        return pulumi.get(self, "specification")


@pulumi.output_type
class GetSiteMonitorsMonitorResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 create_time: _builtins.str,
                 interval: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 task_type: _builtins.str):
        """
        :param _builtins.str address: Address.
        :param _builtins.str create_time: CreateTime.
        :param _builtins.str interval: Monitoring frequency.
        :param _builtins.str task_id: Task ID.
        :param _builtins.str task_name: Task Name.
        :param _builtins.str task_type: Task Type.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "task_type", task_type)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        CreateTime.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Monitoring frequency.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Task Name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Task Type.
        """
        return pulumi.get(self, "task_type")


@pulumi.output_type
class GetSlsGroupsGroupResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 id: _builtins.str,
                 sls_group_configs: Sequence['outputs.GetSlsGroupsGroupSlsGroupConfigResult'],
                 sls_group_description: _builtins.str,
                 sls_group_name: _builtins.str):
        """
        :param _builtins.str create_time: The creation time of the resource.
        :param _builtins.str id: The ID of the Sls Group. Its value is same as Queue Name.
        :param Sequence['GetSlsGroupsGroupSlsGroupConfigArgs'] sls_group_configs: The Config of the Sls Group.
        :param _builtins.str sls_group_description: The Description of the Sls Group.
        :param _builtins.str sls_group_name: The name of the resource.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "sls_group_configs", sls_group_configs)
        pulumi.set(__self__, "sls_group_description", sls_group_description)
        pulumi.set(__self__, "sls_group_name", sls_group_name)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Sls Group. Its value is same as Queue Name.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="slsGroupConfigs")
    def sls_group_configs(self) -> Sequence['outputs.GetSlsGroupsGroupSlsGroupConfigResult']:
        """
        The Config of the Sls Group.
        """
        return pulumi.get(self, "sls_group_configs")

    @_builtins.property
    @pulumi.getter(name="slsGroupDescription")
    def sls_group_description(self) -> _builtins.str:
        """
        The Description of the Sls Group.
        """
        return pulumi.get(self, "sls_group_description")

    @_builtins.property
    @pulumi.getter(name="slsGroupName")
    def sls_group_name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "sls_group_name")


@pulumi.output_type
class GetSlsGroupsGroupSlsGroupConfigResult(dict):
    def __init__(__self__, *,
                 sls_logstore: _builtins.str,
                 sls_project: _builtins.str,
                 sls_region: _builtins.str,
                 sls_user_id: _builtins.str):
        """
        :param _builtins.str sls_logstore: The name of the Log Store.
        :param _builtins.str sls_project: The name of the Project.
        :param _builtins.str sls_region: The Sls Region.
        :param _builtins.str sls_user_id: The ID of the Sls User.
        """
        pulumi.set(__self__, "sls_logstore", sls_logstore)
        pulumi.set(__self__, "sls_project", sls_project)
        pulumi.set(__self__, "sls_region", sls_region)
        pulumi.set(__self__, "sls_user_id", sls_user_id)

    @_builtins.property
    @pulumi.getter(name="slsLogstore")
    def sls_logstore(self) -> _builtins.str:
        """
        The name of the Log Store.
        """
        return pulumi.get(self, "sls_logstore")

    @_builtins.property
    @pulumi.getter(name="slsProject")
    def sls_project(self) -> _builtins.str:
        """
        The name of the Project.
        """
        return pulumi.get(self, "sls_project")

    @_builtins.property
    @pulumi.getter(name="slsRegion")
    def sls_region(self) -> _builtins.str:
        """
        The Sls Region.
        """
        return pulumi.get(self, "sls_region")

    @_builtins.property
    @pulumi.getter(name="slsUserId")
    def sls_user_id(self) -> _builtins.str:
        """
        The ID of the Sls User.
        """
        return pulumi.get(self, "sls_user_id")


