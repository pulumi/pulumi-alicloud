# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities, _tables

__all__ = [
    'AlertNotificationListArgs',
    'AlertQueryListArgs',
    'EtlEtlSinkArgs',
    'StoreIndexFieldSearchArgs',
    'StoreIndexFieldSearchJsonKeyArgs',
    'StoreIndexFullTextArgs',
    'StoreShardArgs',
]

@pulumi.input_type
class AlertNotificationListArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 type: pulumi.Input[str],
                 email_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mobile_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Notice content of alarm.
        :param pulumi.Input[str] type: Notification type. support Email, SMS, DingTalk, MessageCenter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_lists: Email address list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mobile_lists: SMS sending mobile number.
        :param pulumi.Input[str] service_uri: Request address.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "type", type)
        if email_lists is not None:
            pulumi.set(__self__, "email_lists", email_lists)
        if mobile_lists is not None:
            pulumi.set(__self__, "mobile_lists", mobile_lists)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Notice content of alarm.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Notification type. support Email, SMS, DingTalk, MessageCenter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="emailLists")
    def email_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Email address list.
        """
        return pulumi.get(self, "email_lists")

    @email_lists.setter
    def email_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_lists", value)

    @property
    @pulumi.getter(name="mobileLists")
    def mobile_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        SMS sending mobile number.
        """
        return pulumi.get(self, "mobile_lists")

    @mobile_lists.setter
    def mobile_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mobile_lists", value)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Request address.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_uri", value)


@pulumi.input_type
class AlertQueryListArgs:
    def __init__(__self__, *,
                 chart_title: pulumi.Input[str],
                 end: pulumi.Input[str],
                 logstore: pulumi.Input[str],
                 query: pulumi.Input[str],
                 start: pulumi.Input[str],
                 time_span_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] chart_title: chart title
        :param pulumi.Input[str] end: end time. example: 20s.
        :param pulumi.Input[str] logstore: Query logstore
        :param pulumi.Input[str] query: query corresponding to chart. example: * AND aliyun.
        :param pulumi.Input[str] start: begin time. example: -60s.
        :param pulumi.Input[str] time_span_type: default Custom. No need to configure this parameter.
        """
        pulumi.set(__self__, "chart_title", chart_title)
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "logstore", logstore)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "start", start)
        if time_span_type is not None:
            pulumi.set(__self__, "time_span_type", time_span_type)

    @property
    @pulumi.getter(name="chartTitle")
    def chart_title(self) -> pulumi.Input[str]:
        """
        chart title
        """
        return pulumi.get(self, "chart_title")

    @chart_title.setter
    def chart_title(self, value: pulumi.Input[str]):
        pulumi.set(self, "chart_title", value)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        end time. example: 20s.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def logstore(self) -> pulumi.Input[str]:
        """
        Query logstore
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: pulumi.Input[str]):
        pulumi.set(self, "logstore", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        query corresponding to chart. example: * AND aliyun.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        begin time. example: -60s.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter(name="timeSpanType")
    def time_span_type(self) -> Optional[pulumi.Input[str]]:
        """
        default Custom. No need to configure this parameter.
        """
        return pulumi.get(self, "time_span_type")

    @time_span_type.setter
    def time_span_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_span_type", value)


@pulumi.input_type
class EtlEtlSinkArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 logstore: pulumi.Input[str],
                 name: pulumi.Input[str],
                 project: pulumi.Input[str],
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 access_key_secret: Optional[pulumi.Input[str]] = None,
                 kms_encrypted_access_key_id: Optional[pulumi.Input[str]] = None,
                 kms_encrypted_access_key_secret: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint: Delivery target logstore region.
        :param pulumi.Input[str] logstore: Delivery target logstore.
        :param pulumi.Input[str] name: Delivery target name.
        :param pulumi.Input[str] project: The project where the target logstore is delivered.
        :param pulumi.Input[str] access_key_id: Dekms_encryption_access_key_id_contextlivery target logstore access key id.
        :param pulumi.Input[str] access_key_secret: Delivery target logstore access key secret.
        :param pulumi.Input[str] kms_encrypted_access_key_id: An KMS encrypts access key id used to a log etl job. If the `access_key_id` is filled in, this field will be ignored.
        :param pulumi.Input[str] kms_encrypted_access_key_secret: An KMS encrypts access key secret used to a log etl job. If the `access_key_secret` is filled in, this field will be ignored.
        :param pulumi.Input[str] role_arn: Sts role info.
        :param pulumi.Input[str] type: ETL sinks type, the default value is AliyunLOG.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "logstore", logstore)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if access_key_secret is not None:
            pulumi.set(__self__, "access_key_secret", access_key_secret)
        if kms_encrypted_access_key_id is not None:
            pulumi.set(__self__, "kms_encrypted_access_key_id", kms_encrypted_access_key_id)
        if kms_encrypted_access_key_secret is not None:
            pulumi.set(__self__, "kms_encrypted_access_key_secret", kms_encrypted_access_key_secret)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Delivery target logstore region.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def logstore(self) -> pulumi.Input[str]:
        """
        Delivery target logstore.
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: pulumi.Input[str]):
        pulumi.set(self, "logstore", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Delivery target name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def project(self) -> pulumi.Input[str]:
        """
        The project where the target logstore is delivered.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[str]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Dekms_encryption_access_key_id_contextlivery target logstore access key id.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="accessKeySecret")
    def access_key_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Delivery target logstore access key secret.
        """
        return pulumi.get(self, "access_key_secret")

    @access_key_secret.setter
    def access_key_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_secret", value)

    @property
    @pulumi.getter(name="kmsEncryptedAccessKeyId")
    def kms_encrypted_access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        An KMS encrypts access key id used to a log etl job. If the `access_key_id` is filled in, this field will be ignored.
        """
        return pulumi.get(self, "kms_encrypted_access_key_id")

    @kms_encrypted_access_key_id.setter
    def kms_encrypted_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_encrypted_access_key_id", value)

    @property
    @pulumi.getter(name="kmsEncryptedAccessKeySecret")
    def kms_encrypted_access_key_secret(self) -> Optional[pulumi.Input[str]]:
        """
        An KMS encrypts access key secret used to a log etl job. If the `access_key_secret` is filled in, this field will be ignored.
        """
        return pulumi.get(self, "kms_encrypted_access_key_secret")

    @kms_encrypted_access_key_secret.setter
    def kms_encrypted_access_key_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_encrypted_access_key_secret", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Sts role info.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        ETL sinks type, the default value is AliyunLOG.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class StoreIndexFieldSearchArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 enable_analytics: Optional[pulumi.Input[bool]] = None,
                 include_chinese: Optional[pulumi.Input[bool]] = None,
                 json_keys: Optional[pulumi.Input[Sequence[pulumi.Input['StoreIndexFieldSearchJsonKeyArgs']]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: When using the json_keys field, this field is required.
        :param pulumi.Input[str] alias: The alias of one field.
        :param pulumi.Input[bool] case_sensitive: Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
        :param pulumi.Input[bool] enable_analytics: Whether to enable field analytics. Default to true.
        :param pulumi.Input[bool] include_chinese: Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
        :param pulumi.Input[Sequence[pulumi.Input['StoreIndexFieldSearchJsonKeyArgs']]] json_keys: Use nested index when type is json
        :param pulumi.Input[str] token: The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
        :param pulumi.Input[str] type: The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enable_analytics is not None:
            pulumi.set(__self__, "enable_analytics", enable_analytics)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if json_keys is not None:
            pulumi.set(__self__, "json_keys", json_keys)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        When using the json_keys field, this field is required.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The alias of one field.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="enableAnalytics")
    def enable_analytics(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable field analytics. Default to true.
        """
        return pulumi.get(self, "enable_analytics")

    @enable_analytics.setter
    def enable_analytics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_analytics", value)

    @property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_chinese", value)

    @property
    @pulumi.getter(name="jsonKeys")
    def json_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StoreIndexFieldSearchJsonKeyArgs']]]]:
        """
        Use nested index when type is json
        """
        return pulumi.get(self, "json_keys")

    @json_keys.setter
    def json_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StoreIndexFieldSearchJsonKeyArgs']]]]):
        pulumi.set(self, "json_keys", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class StoreIndexFieldSearchJsonKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 doc_value: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: When using the json_keys field, this field is required.
        :param pulumi.Input[str] alias: The alias of one field.
        :param pulumi.Input[bool] doc_value: Whether to enable statistics. default to true.
        :param pulumi.Input[str] type: The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if doc_value is not None:
            pulumi.set(__self__, "doc_value", doc_value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        When using the json_keys field, this field is required.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The alias of one field.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="docValue")
    def doc_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable statistics. default to true.
        """
        return pulumi.get(self, "doc_value")

    @doc_value.setter
    def doc_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "doc_value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of one field. Valid values: ["long", "text", "double"]. Default to "long"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class StoreIndexFullTextArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 include_chinese: Optional[pulumi.Input[bool]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] case_sensitive: Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
        :param pulumi.Input[bool] include_chinese: Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
        :param pulumi.Input[str] token: The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the case sensitive for the field. Default to false. It is valid when "type" is "text" or "json".
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether includes the chinese for the field. Default to false. It is valid when "type" is "text" or "json".
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_chinese", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The string of several split words, like "\r", "#". It is valid when "type" is "text" or "json".
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class StoreShardArgs:
    def __init__(__self__, *,
                 begin_key: Optional[pulumi.Input[str]] = None,
                 end_key: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] id: The ID of the log project. It formats of `<project>:<name>`.
        """
        if begin_key is not None:
            pulumi.set(__self__, "begin_key", begin_key)
        if end_key is not None:
            pulumi.set(__self__, "end_key", end_key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="beginKey")
    def begin_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "begin_key")

    @begin_key.setter
    def begin_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "begin_key", value)

    @property
    @pulumi.getter(name="endKey")
    def end_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "end_key")

    @end_key.setter
    def end_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_key", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the log project. It formats of `<project>:<name>`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


