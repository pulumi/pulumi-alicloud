# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DiAlarmRuleNotificationSettingsArgs',
    'DiAlarmRuleNotificationSettingsArgsDict',
    'DiAlarmRuleNotificationSettingsNotificationChannelArgs',
    'DiAlarmRuleNotificationSettingsNotificationChannelArgsDict',
    'DiAlarmRuleNotificationSettingsNotificationReceiverArgs',
    'DiAlarmRuleNotificationSettingsNotificationReceiverArgsDict',
    'DiAlarmRuleTriggerConditionArgs',
    'DiAlarmRuleTriggerConditionArgsDict',
    'DiJobDestinationDataSourceSettingArgs',
    'DiJobDestinationDataSourceSettingArgsDict',
    'DiJobJobSettingsArgs',
    'DiJobJobSettingsArgsDict',
    'DiJobJobSettingsColumnDataTypeSettingArgs',
    'DiJobJobSettingsColumnDataTypeSettingArgsDict',
    'DiJobJobSettingsCycleScheduleSettingsArgs',
    'DiJobJobSettingsCycleScheduleSettingsArgsDict',
    'DiJobJobSettingsDdlHandlingSettingArgs',
    'DiJobJobSettingsDdlHandlingSettingArgsDict',
    'DiJobJobSettingsRuntimeSettingArgs',
    'DiJobJobSettingsRuntimeSettingArgsDict',
    'DiJobResourceSettingsArgs',
    'DiJobResourceSettingsArgsDict',
    'DiJobResourceSettingsOfflineResourceSettingsArgs',
    'DiJobResourceSettingsOfflineResourceSettingsArgsDict',
    'DiJobResourceSettingsRealtimeResourceSettingsArgs',
    'DiJobResourceSettingsRealtimeResourceSettingsArgsDict',
    'DiJobResourceSettingsScheduleResourceSettingsArgs',
    'DiJobResourceSettingsScheduleResourceSettingsArgsDict',
    'DiJobSourceDataSourceSettingArgs',
    'DiJobSourceDataSourceSettingArgsDict',
    'DiJobSourceDataSourceSettingDataSourcePropertiesArgs',
    'DiJobSourceDataSourceSettingDataSourcePropertiesArgsDict',
    'DiJobTableMappingArgs',
    'DiJobTableMappingArgsDict',
    'DiJobTableMappingSourceObjectSelectionRuleArgs',
    'DiJobTableMappingSourceObjectSelectionRuleArgsDict',
    'DiJobTableMappingTransformationRuleArgs',
    'DiJobTableMappingTransformationRuleArgsDict',
    'DiJobTransformationRuleArgs',
    'DiJobTransformationRuleArgsDict',
    'ProjectMemberRoleArgs',
    'ProjectMemberRoleArgsDict',
]

MYPY = False

if not MYPY:
    class DiAlarmRuleNotificationSettingsArgsDict(TypedDict):
        inhibition_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm suppression interval, in minutes
        """
        notification_channels: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationChannelArgsDict']]]]
        """
        Alarm notification Channel See `notification_channels` below.
        """
        notification_receivers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationReceiverArgsDict']]]]
        """
        List of alert notification recipients See `notification_receivers` below.
        """
elif False:
    DiAlarmRuleNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiAlarmRuleNotificationSettingsArgs:
    def __init__(__self__, *,
                 inhibition_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 notification_channels: Optional[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationChannelArgs']]]] = None,
                 notification_receivers: Optional[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationReceiverArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] inhibition_interval: Alarm suppression interval, in minutes
        :param pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationChannelArgs']]] notification_channels: Alarm notification Channel See `notification_channels` below.
        :param pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationReceiverArgs']]] notification_receivers: List of alert notification recipients See `notification_receivers` below.
        """
        if inhibition_interval is not None:
            pulumi.set(__self__, "inhibition_interval", inhibition_interval)
        if notification_channels is not None:
            pulumi.set(__self__, "notification_channels", notification_channels)
        if notification_receivers is not None:
            pulumi.set(__self__, "notification_receivers", notification_receivers)

    @_builtins.property
    @pulumi.getter(name="inhibitionInterval")
    def inhibition_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm suppression interval, in minutes
        """
        return pulumi.get(self, "inhibition_interval")

    @inhibition_interval.setter
    def inhibition_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "inhibition_interval", value)

    @_builtins.property
    @pulumi.getter(name="notificationChannels")
    def notification_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationChannelArgs']]]]:
        """
        Alarm notification Channel See `notification_channels` below.
        """
        return pulumi.get(self, "notification_channels")

    @notification_channels.setter
    def notification_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationChannelArgs']]]]):
        pulumi.set(self, "notification_channels", value)

    @_builtins.property
    @pulumi.getter(name="notificationReceivers")
    def notification_receivers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationReceiverArgs']]]]:
        """
        List of alert notification recipients See `notification_receivers` below.
        """
        return pulumi.get(self, "notification_receivers")

    @notification_receivers.setter
    def notification_receivers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiAlarmRuleNotificationSettingsNotificationReceiverArgs']]]]):
        pulumi.set(self, "notification_receivers", value)


if not MYPY:
    class DiAlarmRuleNotificationSettingsNotificationChannelArgsDict(TypedDict):
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Channel, optional enumeration value:

        Mail (Mail)

        Phone (Phone)

        Sms (Sms)

        Ding (DingTalk)
        """
        severity: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DiAlarmRuleNotificationSettingsNotificationChannelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiAlarmRuleNotificationSettingsNotificationChannelArgs:
    def __init__(__self__, *,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 severity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] channels: Channel, optional enumeration value:
               
               Mail (Mail)
               
               Phone (Phone)
               
               Sms (Sms)
               
               Ding (DingTalk)
        """
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Channel, optional enumeration value:

        Mail (Mail)

        Phone (Phone)

        Sms (Sms)

        Ding (DingTalk)
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "channels", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class DiAlarmRuleNotificationSettingsNotificationReceiverArgsDict(TypedDict):
        receiver_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the receiver. Valid values: AliyunUid/DingToken/FeishuToken/WebHookUrl.
        """
        receiver_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Receiver Value List
        """
elif False:
    DiAlarmRuleNotificationSettingsNotificationReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiAlarmRuleNotificationSettingsNotificationReceiverArgs:
    def __init__(__self__, *,
                 receiver_type: Optional[pulumi.Input[_builtins.str]] = None,
                 receiver_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] receiver_type: The type of the receiver. Valid values: AliyunUid/DingToken/FeishuToken/WebHookUrl.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] receiver_values: Receiver Value List
        """
        if receiver_type is not None:
            pulumi.set(__self__, "receiver_type", receiver_type)
        if receiver_values is not None:
            pulumi.set(__self__, "receiver_values", receiver_values)

    @_builtins.property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the receiver. Valid values: AliyunUid/DingToken/FeishuToken/WebHookUrl.
        """
        return pulumi.get(self, "receiver_type")

    @receiver_type.setter
    def receiver_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "receiver_type", value)

    @_builtins.property
    @pulumi.getter(name="receiverValues")
    def receiver_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Receiver Value List
        """
        return pulumi.get(self, "receiver_values")

    @receiver_values.setter
    def receiver_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "receiver_values", value)


if not MYPY:
    class DiAlarmRuleTriggerConditionArgsDict(TypedDict):
        ddl_report_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        It takes effect only when the DDL notification is issued. The list of effective DDLs is required.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm calculation time interval, unit minute
        """
        severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Severity, optional enumeration value:

        Warning

        Critical
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm threshold.

        Task status alarm: no need to fill in the threshold.

        failover alarm: The threshold is the number of failover alarms.

        Task Delay Alarm: The threshold is the delay duration, in seconds.
        """
elif False:
    DiAlarmRuleTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiAlarmRuleTriggerConditionArgs:
    def __init__(__self__, *,
                 ddl_report_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 severity: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ddl_report_tags: It takes effect only when the DDL notification is issued. The list of effective DDLs is required.
        :param pulumi.Input[_builtins.int] duration: Alarm calculation time interval, unit minute
        :param pulumi.Input[_builtins.str] severity: Severity, optional enumeration value:
               
               Warning
               
               Critical
        :param pulumi.Input[_builtins.int] threshold: Alarm threshold.
               
               Task status alarm: no need to fill in the threshold.
               
               failover alarm: The threshold is the number of failover alarms.
               
               Task Delay Alarm: The threshold is the delay duration, in seconds.
        """
        if ddl_report_tags is not None:
            pulumi.set(__self__, "ddl_report_tags", ddl_report_tags)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="ddlReportTags")
    def ddl_report_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        It takes effect only when the DDL notification is issued. The list of effective DDLs is required.
        """
        return pulumi.get(self, "ddl_report_tags")

    @ddl_report_tags.setter
    def ddl_report_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ddl_report_tags", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm calculation time interval, unit minute
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Severity, optional enumeration value:

        Warning

        Critical
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm threshold.

        Task status alarm: no need to fill in the threshold.

        failover alarm: The threshold is the number of failover alarms.

        Task Delay Alarm: The threshold is the delay duration, in seconds.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class DiJobDestinationDataSourceSettingArgsDict(TypedDict):
        data_source_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination data source name
        """
elif False:
    DiJobDestinationDataSourceSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobDestinationDataSourceSettingArgs:
    def __init__(__self__, *,
                 data_source_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_source_name: Destination data source name
        """
        if data_source_name is not None:
            pulumi.set(__self__, "data_source_name", data_source_name)

    @_builtins.property
    @pulumi.getter(name="dataSourceName")
    def data_source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination data source name
        """
        return pulumi.get(self, "data_source_name")

    @data_source_name.setter
    def data_source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_name", value)


if not MYPY:
    class DiJobJobSettingsArgsDict(TypedDict):
        channel_settings: NotRequired[pulumi.Input[_builtins.str]]
        """
        Channel-related task settings, in the form of a Json String.

        For example,
        {"structInfo":"MANAGED","storageType":"TEXTFILE","writeMode":"APPEND","partitionColumns":[{"columnName":"pt","columnType":"STRING","comment":""}],"fieldDelimiter":""}
        """
        column_data_type_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsColumnDataTypeSettingArgsDict']]]]
        """
        Column type mapping of the synchronization task See `column_data_type_settings` below.
        """
        cycle_schedule_settings: NotRequired[pulumi.Input['DiJobJobSettingsCycleScheduleSettingsArgsDict']]
        """
        Periodic scheduling settings See `cycle_schedule_settings` below.
        """
        ddl_handling_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsDdlHandlingSettingArgsDict']]]]
        """
        List of DDL processing settings for synchronization tasks See `ddl_handling_settings` below.
        """
        runtime_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsRuntimeSettingArgsDict']]]]
        """
        Run-time setting parameter list See `runtime_settings` below.
        """
elif False:
    DiJobJobSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobJobSettingsArgs:
    def __init__(__self__, *,
                 channel_settings: Optional[pulumi.Input[_builtins.str]] = None,
                 column_data_type_settings: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsColumnDataTypeSettingArgs']]]] = None,
                 cycle_schedule_settings: Optional[pulumi.Input['DiJobJobSettingsCycleScheduleSettingsArgs']] = None,
                 ddl_handling_settings: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsDdlHandlingSettingArgs']]]] = None,
                 runtime_settings: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsRuntimeSettingArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] channel_settings: Channel-related task settings, in the form of a Json String.
               
               For example,
               {"structInfo":"MANAGED","storageType":"TEXTFILE","writeMode":"APPEND","partitionColumns":[{"columnName":"pt","columnType":"STRING","comment":""}],"fieldDelimiter":""}
        :param pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsColumnDataTypeSettingArgs']]] column_data_type_settings: Column type mapping of the synchronization task See `column_data_type_settings` below.
        :param pulumi.Input['DiJobJobSettingsCycleScheduleSettingsArgs'] cycle_schedule_settings: Periodic scheduling settings See `cycle_schedule_settings` below.
        :param pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsDdlHandlingSettingArgs']]] ddl_handling_settings: List of DDL processing settings for synchronization tasks See `ddl_handling_settings` below.
        :param pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsRuntimeSettingArgs']]] runtime_settings: Run-time setting parameter list See `runtime_settings` below.
        """
        if channel_settings is not None:
            pulumi.set(__self__, "channel_settings", channel_settings)
        if column_data_type_settings is not None:
            pulumi.set(__self__, "column_data_type_settings", column_data_type_settings)
        if cycle_schedule_settings is not None:
            pulumi.set(__self__, "cycle_schedule_settings", cycle_schedule_settings)
        if ddl_handling_settings is not None:
            pulumi.set(__self__, "ddl_handling_settings", ddl_handling_settings)
        if runtime_settings is not None:
            pulumi.set(__self__, "runtime_settings", runtime_settings)

    @_builtins.property
    @pulumi.getter(name="channelSettings")
    def channel_settings(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Channel-related task settings, in the form of a Json String.

        For example,
        {"structInfo":"MANAGED","storageType":"TEXTFILE","writeMode":"APPEND","partitionColumns":[{"columnName":"pt","columnType":"STRING","comment":""}],"fieldDelimiter":""}
        """
        return pulumi.get(self, "channel_settings")

    @channel_settings.setter
    def channel_settings(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_settings", value)

    @_builtins.property
    @pulumi.getter(name="columnDataTypeSettings")
    def column_data_type_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsColumnDataTypeSettingArgs']]]]:
        """
        Column type mapping of the synchronization task See `column_data_type_settings` below.
        """
        return pulumi.get(self, "column_data_type_settings")

    @column_data_type_settings.setter
    def column_data_type_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsColumnDataTypeSettingArgs']]]]):
        pulumi.set(self, "column_data_type_settings", value)

    @_builtins.property
    @pulumi.getter(name="cycleScheduleSettings")
    def cycle_schedule_settings(self) -> Optional[pulumi.Input['DiJobJobSettingsCycleScheduleSettingsArgs']]:
        """
        Periodic scheduling settings See `cycle_schedule_settings` below.
        """
        return pulumi.get(self, "cycle_schedule_settings")

    @cycle_schedule_settings.setter
    def cycle_schedule_settings(self, value: Optional[pulumi.Input['DiJobJobSettingsCycleScheduleSettingsArgs']]):
        pulumi.set(self, "cycle_schedule_settings", value)

    @_builtins.property
    @pulumi.getter(name="ddlHandlingSettings")
    def ddl_handling_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsDdlHandlingSettingArgs']]]]:
        """
        List of DDL processing settings for synchronization tasks See `ddl_handling_settings` below.
        """
        return pulumi.get(self, "ddl_handling_settings")

    @ddl_handling_settings.setter
    def ddl_handling_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsDdlHandlingSettingArgs']]]]):
        pulumi.set(self, "ddl_handling_settings", value)

    @_builtins.property
    @pulumi.getter(name="runtimeSettings")
    def runtime_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsRuntimeSettingArgs']]]]:
        """
        Run-time setting parameter list See `runtime_settings` below.
        """
        return pulumi.get(self, "runtime_settings")

    @runtime_settings.setter
    def runtime_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobJobSettingsRuntimeSettingArgs']]]]):
        pulumi.set(self, "runtime_settings", value)


if not MYPY:
    class DiJobJobSettingsColumnDataTypeSettingArgsDict(TypedDict):
        destination_data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The destination type of the mapping relationship
        """
        source_data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source type of the mapping type
        """
elif False:
    DiJobJobSettingsColumnDataTypeSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobJobSettingsColumnDataTypeSettingArgs:
    def __init__(__self__, *,
                 destination_data_type: Optional[pulumi.Input[_builtins.str]] = None,
                 source_data_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_data_type: The destination type of the mapping relationship
        :param pulumi.Input[_builtins.str] source_data_type: The source type of the mapping type
        """
        if destination_data_type is not None:
            pulumi.set(__self__, "destination_data_type", destination_data_type)
        if source_data_type is not None:
            pulumi.set(__self__, "source_data_type", source_data_type)

    @_builtins.property
    @pulumi.getter(name="destinationDataType")
    def destination_data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The destination type of the mapping relationship
        """
        return pulumi.get(self, "destination_data_type")

    @destination_data_type.setter
    def destination_data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_data_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceDataType")
    def source_data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source type of the mapping type
        """
        return pulumi.get(self, "source_data_type")

    @source_data_type.setter
    def source_data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_data_type", value)


if not MYPY:
    class DiJobJobSettingsCycleScheduleSettingsArgsDict(TypedDict):
        cycle_migration_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of synchronization that requires periodic scheduling. Value range:

        Full: Full

        OfflineIncremental: offline increment
        """
        schedule_parameters: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling Parameters
        """
elif False:
    DiJobJobSettingsCycleScheduleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobJobSettingsCycleScheduleSettingsArgs:
    def __init__(__self__, *,
                 cycle_migration_type: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule_parameters: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cycle_migration_type: The type of synchronization that requires periodic scheduling. Value range:
               
               Full: Full
               
               OfflineIncremental: offline increment
        :param pulumi.Input[_builtins.str] schedule_parameters: Scheduling Parameters
        """
        if cycle_migration_type is not None:
            pulumi.set(__self__, "cycle_migration_type", cycle_migration_type)
        if schedule_parameters is not None:
            pulumi.set(__self__, "schedule_parameters", schedule_parameters)

    @_builtins.property
    @pulumi.getter(name="cycleMigrationType")
    def cycle_migration_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of synchronization that requires periodic scheduling. Value range:

        Full: Full

        OfflineIncremental: offline increment
        """
        return pulumi.get(self, "cycle_migration_type")

    @cycle_migration_type.setter
    def cycle_migration_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cycle_migration_type", value)

    @_builtins.property
    @pulumi.getter(name="scheduleParameters")
    def schedule_parameters(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling Parameters
        """
        return pulumi.get(self, "schedule_parameters")

    @schedule_parameters.setter
    def schedule_parameters(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_parameters", value)


if not MYPY:
    class DiJobJobSettingsDdlHandlingSettingArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        DDL type, optional enumeration value:

        RenameColumn (rename column)

        ModifyColumn (rename column)

        CreateTable (Rename Column)

        TruncateTable (empty table)

        DropTable (delete table)
        """
elif False:
    DiJobJobSettingsDdlHandlingSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobJobSettingsDdlHandlingSettingArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: DDL type, optional enumeration value:
               
               RenameColumn (rename column)
               
               ModifyColumn (rename column)
               
               CreateTable (Rename Column)
               
               TruncateTable (empty table)
               
               DropTable (delete table)
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DDL type, optional enumeration value:

        RenameColumn (rename column)

        ModifyColumn (rename column)

        CreateTable (Rename Column)

        TruncateTable (empty table)

        DropTable (delete table)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DiJobJobSettingsRuntimeSettingArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set name, optional ENUM value:

        runtime.offline.speed.limit.mb (valid when runtime.offline.speed.limit.enable = true)

        runtime.offline.speed.limit.enable

        dst.offline.connection.max (the maximum number of write connections for offline batch tasks)

        runtime.offline.concurrent (offline batch synchronization task concurrency)

        dst.realtime.connection.max (maximum number of write connections for real-time tasks)

        runtime.enable.auto.create.schema (whether to automatically create a schema on the target side)

        src.offline.datasource.max.connection (maximum number of source connections for offline batch tasks)

        runtime.realtime.concurrent (real-time task concurrency)
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Runtime setting value
        """
elif False:
    DiJobJobSettingsRuntimeSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobJobSettingsRuntimeSettingArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Set name, optional ENUM value:
               
               runtime.offline.speed.limit.mb (valid when runtime.offline.speed.limit.enable = true)
               
               runtime.offline.speed.limit.enable
               
               dst.offline.connection.max (the maximum number of write connections for offline batch tasks)
               
               runtime.offline.concurrent (offline batch synchronization task concurrency)
               
               dst.realtime.connection.max (maximum number of write connections for real-time tasks)
               
               runtime.enable.auto.create.schema (whether to automatically create a schema on the target side)
               
               src.offline.datasource.max.connection (maximum number of source connections for offline batch tasks)
               
               runtime.realtime.concurrent (real-time task concurrency)
        :param pulumi.Input[_builtins.str] value: Runtime setting value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set name, optional ENUM value:

        runtime.offline.speed.limit.mb (valid when runtime.offline.speed.limit.enable = true)

        runtime.offline.speed.limit.enable

        dst.offline.connection.max (the maximum number of write connections for offline batch tasks)

        runtime.offline.concurrent (offline batch synchronization task concurrency)

        dst.realtime.connection.max (maximum number of write connections for real-time tasks)

        runtime.enable.auto.create.schema (whether to automatically create a schema on the target side)

        src.offline.datasource.max.connection (maximum number of source connections for offline batch tasks)

        runtime.realtime.concurrent (real-time task concurrency)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Runtime setting value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DiJobResourceSettingsArgsDict(TypedDict):
        offline_resource_settings: NotRequired[pulumi.Input['DiJobResourceSettingsOfflineResourceSettingsArgsDict']]
        """
        Offline Resource Group configuration See `offline_resource_settings` below.
        """
        realtime_resource_settings: NotRequired[pulumi.Input['DiJobResourceSettingsRealtimeResourceSettingsArgsDict']]
        """
        Real-time Resource Group See `realtime_resource_settings` below.
        """
        schedule_resource_settings: NotRequired[pulumi.Input['DiJobResourceSettingsScheduleResourceSettingsArgsDict']]
        """
        Scheduling Resource Groups See `schedule_resource_settings` below.
        """
elif False:
    DiJobResourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobResourceSettingsArgs:
    def __init__(__self__, *,
                 offline_resource_settings: Optional[pulumi.Input['DiJobResourceSettingsOfflineResourceSettingsArgs']] = None,
                 realtime_resource_settings: Optional[pulumi.Input['DiJobResourceSettingsRealtimeResourceSettingsArgs']] = None,
                 schedule_resource_settings: Optional[pulumi.Input['DiJobResourceSettingsScheduleResourceSettingsArgs']] = None):
        """
        :param pulumi.Input['DiJobResourceSettingsOfflineResourceSettingsArgs'] offline_resource_settings: Offline Resource Group configuration See `offline_resource_settings` below.
        :param pulumi.Input['DiJobResourceSettingsRealtimeResourceSettingsArgs'] realtime_resource_settings: Real-time Resource Group See `realtime_resource_settings` below.
        :param pulumi.Input['DiJobResourceSettingsScheduleResourceSettingsArgs'] schedule_resource_settings: Scheduling Resource Groups See `schedule_resource_settings` below.
        """
        if offline_resource_settings is not None:
            pulumi.set(__self__, "offline_resource_settings", offline_resource_settings)
        if realtime_resource_settings is not None:
            pulumi.set(__self__, "realtime_resource_settings", realtime_resource_settings)
        if schedule_resource_settings is not None:
            pulumi.set(__self__, "schedule_resource_settings", schedule_resource_settings)

    @_builtins.property
    @pulumi.getter(name="offlineResourceSettings")
    def offline_resource_settings(self) -> Optional[pulumi.Input['DiJobResourceSettingsOfflineResourceSettingsArgs']]:
        """
        Offline Resource Group configuration See `offline_resource_settings` below.
        """
        return pulumi.get(self, "offline_resource_settings")

    @offline_resource_settings.setter
    def offline_resource_settings(self, value: Optional[pulumi.Input['DiJobResourceSettingsOfflineResourceSettingsArgs']]):
        pulumi.set(self, "offline_resource_settings", value)

    @_builtins.property
    @pulumi.getter(name="realtimeResourceSettings")
    def realtime_resource_settings(self) -> Optional[pulumi.Input['DiJobResourceSettingsRealtimeResourceSettingsArgs']]:
        """
        Real-time Resource Group See `realtime_resource_settings` below.
        """
        return pulumi.get(self, "realtime_resource_settings")

    @realtime_resource_settings.setter
    def realtime_resource_settings(self, value: Optional[pulumi.Input['DiJobResourceSettingsRealtimeResourceSettingsArgs']]):
        pulumi.set(self, "realtime_resource_settings", value)

    @_builtins.property
    @pulumi.getter(name="scheduleResourceSettings")
    def schedule_resource_settings(self) -> Optional[pulumi.Input['DiJobResourceSettingsScheduleResourceSettingsArgs']]:
        """
        Scheduling Resource Groups See `schedule_resource_settings` below.
        """
        return pulumi.get(self, "schedule_resource_settings")

    @schedule_resource_settings.setter
    def schedule_resource_settings(self, value: Optional[pulumi.Input['DiJobResourceSettingsScheduleResourceSettingsArgs']]):
        pulumi.set(self, "schedule_resource_settings", value)


if not MYPY:
    class DiJobResourceSettingsOfflineResourceSettingsArgsDict(TypedDict):
        requested_cu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Scheduling resource group cu
        """
        resource_group_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling resource group name
        """
elif False:
    DiJobResourceSettingsOfflineResourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobResourceSettingsOfflineResourceSettingsArgs:
    def __init__(__self__, *,
                 requested_cu: Optional[pulumi.Input[_builtins.float]] = None,
                 resource_group_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] requested_cu: Scheduling resource group cu
        :param pulumi.Input[_builtins.str] resource_group_identifier: Scheduling resource group name
        """
        if requested_cu is not None:
            pulumi.set(__self__, "requested_cu", requested_cu)
        if resource_group_identifier is not None:
            pulumi.set(__self__, "resource_group_identifier", resource_group_identifier)

    @_builtins.property
    @pulumi.getter(name="requestedCu")
    def requested_cu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Scheduling resource group cu
        """
        return pulumi.get(self, "requested_cu")

    @requested_cu.setter
    def requested_cu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "requested_cu", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupIdentifier")
    def resource_group_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling resource group name
        """
        return pulumi.get(self, "resource_group_identifier")

    @resource_group_identifier.setter
    def resource_group_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group_identifier", value)


if not MYPY:
    class DiJobResourceSettingsRealtimeResourceSettingsArgsDict(TypedDict):
        requested_cu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Scheduling resource group cu
        """
        resource_group_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling resource group name
        """
elif False:
    DiJobResourceSettingsRealtimeResourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobResourceSettingsRealtimeResourceSettingsArgs:
    def __init__(__self__, *,
                 requested_cu: Optional[pulumi.Input[_builtins.float]] = None,
                 resource_group_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] requested_cu: Scheduling resource group cu
        :param pulumi.Input[_builtins.str] resource_group_identifier: Scheduling resource group name
        """
        if requested_cu is not None:
            pulumi.set(__self__, "requested_cu", requested_cu)
        if resource_group_identifier is not None:
            pulumi.set(__self__, "resource_group_identifier", resource_group_identifier)

    @_builtins.property
    @pulumi.getter(name="requestedCu")
    def requested_cu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Scheduling resource group cu
        """
        return pulumi.get(self, "requested_cu")

    @requested_cu.setter
    def requested_cu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "requested_cu", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupIdentifier")
    def resource_group_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling resource group name
        """
        return pulumi.get(self, "resource_group_identifier")

    @resource_group_identifier.setter
    def resource_group_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group_identifier", value)


if not MYPY:
    class DiJobResourceSettingsScheduleResourceSettingsArgsDict(TypedDict):
        requested_cu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Scheduling resource group cu
        """
        resource_group_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scheduling resource group name
        """
elif False:
    DiJobResourceSettingsScheduleResourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobResourceSettingsScheduleResourceSettingsArgs:
    def __init__(__self__, *,
                 requested_cu: Optional[pulumi.Input[_builtins.float]] = None,
                 resource_group_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] requested_cu: Scheduling resource group cu
        :param pulumi.Input[_builtins.str] resource_group_identifier: Scheduling resource group name
        """
        if requested_cu is not None:
            pulumi.set(__self__, "requested_cu", requested_cu)
        if resource_group_identifier is not None:
            pulumi.set(__self__, "resource_group_identifier", resource_group_identifier)

    @_builtins.property
    @pulumi.getter(name="requestedCu")
    def requested_cu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Scheduling resource group cu
        """
        return pulumi.get(self, "requested_cu")

    @requested_cu.setter
    def requested_cu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "requested_cu", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupIdentifier")
    def resource_group_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scheduling resource group name
        """
        return pulumi.get(self, "resource_group_identifier")

    @resource_group_identifier.setter
    def resource_group_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group_identifier", value)


if not MYPY:
    class DiJobSourceDataSourceSettingArgsDict(TypedDict):
        data_source_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source name of a single source
        """
        data_source_properties: NotRequired[pulumi.Input['DiJobSourceDataSourceSettingDataSourcePropertiesArgsDict']]
        """
        Single Source Data Source Properties See `data_source_properties` below.
        """
elif False:
    DiJobSourceDataSourceSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobSourceDataSourceSettingArgs:
    def __init__(__self__, *,
                 data_source_name: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_properties: Optional[pulumi.Input['DiJobSourceDataSourceSettingDataSourcePropertiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] data_source_name: Data source name of a single source
        :param pulumi.Input['DiJobSourceDataSourceSettingDataSourcePropertiesArgs'] data_source_properties: Single Source Data Source Properties See `data_source_properties` below.
        """
        if data_source_name is not None:
            pulumi.set(__self__, "data_source_name", data_source_name)
        if data_source_properties is not None:
            pulumi.set(__self__, "data_source_properties", data_source_properties)

    @_builtins.property
    @pulumi.getter(name="dataSourceName")
    def data_source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source name of a single source
        """
        return pulumi.get(self, "data_source_name")

    @data_source_name.setter
    def data_source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source_name", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceProperties")
    def data_source_properties(self) -> Optional[pulumi.Input['DiJobSourceDataSourceSettingDataSourcePropertiesArgs']]:
        """
        Single Source Data Source Properties See `data_source_properties` below.
        """
        return pulumi.get(self, "data_source_properties")

    @data_source_properties.setter
    def data_source_properties(self, value: Optional[pulumi.Input['DiJobSourceDataSourceSettingDataSourcePropertiesArgs']]):
        pulumi.set(self, "data_source_properties", value)


if not MYPY:
    class DiJobSourceDataSourceSettingDataSourcePropertiesArgsDict(TypedDict):
        encoding: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data Source Encoding
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data Source Time Zone
        """
elif False:
    DiJobSourceDataSourceSettingDataSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobSourceDataSourceSettingDataSourcePropertiesArgs:
    def __init__(__self__, *,
                 encoding: Optional[pulumi.Input[_builtins.str]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encoding: Data Source Encoding
        :param pulumi.Input[_builtins.str] timezone: Data Source Time Zone
        """
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data Source Encoding
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encoding", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data Source Time Zone
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class DiJobTableMappingArgsDict(TypedDict):
        source_object_selection_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingSourceObjectSelectionRuleArgsDict']]]]
        """
        Each rule can select different types of source objects to be synchronized, such as source database and source data table. See `source_object_selection_rules` below.
        """
        transformation_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingTransformationRuleArgsDict']]]]
        """
        A list of conversion rule definitions for a synchronization object. Each element in the list defines a conversion rule. See `transformation_rules` below.
        """
elif False:
    DiJobTableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobTableMappingArgs:
    def __init__(__self__, *,
                 source_object_selection_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingSourceObjectSelectionRuleArgs']]]] = None,
                 transformation_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingTransformationRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingSourceObjectSelectionRuleArgs']]] source_object_selection_rules: Each rule can select different types of source objects to be synchronized, such as source database and source data table. See `source_object_selection_rules` below.
        :param pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingTransformationRuleArgs']]] transformation_rules: A list of conversion rule definitions for a synchronization object. Each element in the list defines a conversion rule. See `transformation_rules` below.
        """
        if source_object_selection_rules is not None:
            pulumi.set(__self__, "source_object_selection_rules", source_object_selection_rules)
        if transformation_rules is not None:
            pulumi.set(__self__, "transformation_rules", transformation_rules)

    @_builtins.property
    @pulumi.getter(name="sourceObjectSelectionRules")
    def source_object_selection_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingSourceObjectSelectionRuleArgs']]]]:
        """
        Each rule can select different types of source objects to be synchronized, such as source database and source data table. See `source_object_selection_rules` below.
        """
        return pulumi.get(self, "source_object_selection_rules")

    @source_object_selection_rules.setter
    def source_object_selection_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingSourceObjectSelectionRuleArgs']]]]):
        pulumi.set(self, "source_object_selection_rules", value)

    @_builtins.property
    @pulumi.getter(name="transformationRules")
    def transformation_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingTransformationRuleArgs']]]]:
        """
        A list of conversion rule definitions for a synchronization object. Each element in the list defines a conversion rule. See `transformation_rules` below.
        """
        return pulumi.get(self, "transformation_rules")

    @transformation_rules.setter
    def transformation_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiJobTableMappingTransformationRuleArgs']]]]):
        pulumi.set(self, "transformation_rules", value)


if not MYPY:
    class DiJobTableMappingSourceObjectSelectionRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expression, such as mysql_table_1
        """
        expression_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expression type, value range: Exact/Regex
        """
        object_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object type, optional enumeration value:

        Table (Table)

        Database
        """
elif False:
    DiJobTableMappingSourceObjectSelectionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobTableMappingSourceObjectSelectionRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 expression_type: Optional[pulumi.Input[_builtins.str]] = None,
                 object_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: Expression, such as mysql_table_1
        :param pulumi.Input[_builtins.str] expression_type: Expression type, value range: Exact/Regex
        :param pulumi.Input[_builtins.str] object_type: Object type, optional enumeration value:
               
               Table (Table)
               
               Database
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if expression_type is not None:
            pulumi.set(__self__, "expression_type", expression_type)
        if object_type is not None:
            pulumi.set(__self__, "object_type", object_type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expression, such as mysql_table_1
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="expressionType")
    def expression_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expression type, value range: Exact/Regex
        """
        return pulumi.get(self, "expression_type")

    @expression_type.setter
    def expression_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression_type", value)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object type, optional enumeration value:

        Table (Table)

        Database
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class DiJobTableMappingTransformationRuleArgsDict(TypedDict):
        rule_action_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action type, optional enumeration value:

        DefinePrimaryKey (defines the primary key)

        Rename

        AddColumn (increase column)

        HandleDml(DML handling)

        DefineIncrementalCondition
        """
        rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule Name
        """
        rule_target_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target type of action, optional enumeration value:

        Table (Table)

        Schema(schema)
        """
elif False:
    DiJobTableMappingTransformationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobTableMappingTransformationRuleArgs:
    def __init__(__self__, *,
                 rule_action_type: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_name: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_target_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rule_action_type: Action type, optional enumeration value:
               
               DefinePrimaryKey (defines the primary key)
               
               Rename
               
               AddColumn (increase column)
               
               HandleDml(DML handling)
               
               DefineIncrementalCondition
        :param pulumi.Input[_builtins.str] rule_name: Rule Name
        :param pulumi.Input[_builtins.str] rule_target_type: Target type of action, optional enumeration value:
               
               Table (Table)
               
               Schema(schema)
        """
        if rule_action_type is not None:
            pulumi.set(__self__, "rule_action_type", rule_action_type)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if rule_target_type is not None:
            pulumi.set(__self__, "rule_target_type", rule_target_type)

    @_builtins.property
    @pulumi.getter(name="ruleActionType")
    def rule_action_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action type, optional enumeration value:

        DefinePrimaryKey (defines the primary key)

        Rename

        AddColumn (increase column)

        HandleDml(DML handling)

        DefineIncrementalCondition
        """
        return pulumi.get(self, "rule_action_type")

    @rule_action_type.setter
    def rule_action_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_action_type", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule Name
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_name", value)

    @_builtins.property
    @pulumi.getter(name="ruleTargetType")
    def rule_target_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target type of action, optional enumeration value:

        Table (Table)

        Schema(schema)
        """
        return pulumi.get(self, "rule_target_type")

    @rule_target_type.setter
    def rule_target_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_target_type", value)


if not MYPY:
    class DiJobTransformationRuleArgsDict(TypedDict):
        rule_action_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action type, optional enumeration value:

        DefinePrimaryKey (defines the primary key)

        Rename

        AddColumn (increase column)

        HandleDml(DML handling)

        DefineIncrementalCondition
        """
        rule_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regular expression, in json string format.

        Example renaming rule (Rename): {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922","variables":[{"variableName":"srcDatabaseName","variableRules":[{"from":"fromdb","to":"todb"}]}]}
        """
        rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule Name
        """
        rule_target_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target type of action, optional enumeration value:

        Table (Table)

        Schema(schema)
        """
elif False:
    DiJobTransformationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiJobTransformationRuleArgs:
    def __init__(__self__, *,
                 rule_action_type: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_name: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_target_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rule_action_type: Action type, optional enumeration value:
               
               DefinePrimaryKey (defines the primary key)
               
               Rename
               
               AddColumn (increase column)
               
               HandleDml(DML handling)
               
               DefineIncrementalCondition
        :param pulumi.Input[_builtins.str] rule_expression: Regular expression, in json string format.
               
               Example renaming rule (Rename): {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922","variables":[{"variableName":"srcDatabaseName","variableRules":[{"from":"fromdb","to":"todb"}]}]}
        :param pulumi.Input[_builtins.str] rule_name: Rule Name
        :param pulumi.Input[_builtins.str] rule_target_type: Target type of action, optional enumeration value:
               
               Table (Table)
               
               Schema(schema)
        """
        if rule_action_type is not None:
            pulumi.set(__self__, "rule_action_type", rule_action_type)
        if rule_expression is not None:
            pulumi.set(__self__, "rule_expression", rule_expression)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if rule_target_type is not None:
            pulumi.set(__self__, "rule_target_type", rule_target_type)

    @_builtins.property
    @pulumi.getter(name="ruleActionType")
    def rule_action_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action type, optional enumeration value:

        DefinePrimaryKey (defines the primary key)

        Rename

        AddColumn (increase column)

        HandleDml(DML handling)

        DefineIncrementalCondition
        """
        return pulumi.get(self, "rule_action_type")

    @rule_action_type.setter
    def rule_action_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_action_type", value)

    @_builtins.property
    @pulumi.getter(name="ruleExpression")
    def rule_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regular expression, in json string format.

        Example renaming rule (Rename): {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922","variables":[{"variableName":"srcDatabaseName","variableRules":[{"from":"fromdb","to":"todb"}]}]}
        """
        return pulumi.get(self, "rule_expression")

    @rule_expression.setter
    def rule_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_expression", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule Name
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_name", value)

    @_builtins.property
    @pulumi.getter(name="ruleTargetType")
    def rule_target_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target type of action, optional enumeration value:

        Table (Table)

        Schema(schema)
        """
        return pulumi.get(self, "rule_target_type")

    @rule_target_type.setter
    def rule_target_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_target_type", value)


if not MYPY:
    class ProjectMemberRoleArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Role Code.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        project role name
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        project role type
        """
elif False:
    ProjectMemberRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectMemberRoleArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: Project Role Code.
        :param pulumi.Input[_builtins.str] name: project role name
        :param pulumi.Input[_builtins.str] type: project role type
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Role Code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        project role name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        project role type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


