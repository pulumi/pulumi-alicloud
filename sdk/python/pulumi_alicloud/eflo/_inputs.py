# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ClusterComponentArgs',
    'ClusterComponentArgsDict',
    'ClusterComponentComponentConfigArgs',
    'ClusterComponentComponentConfigArgsDict',
    'ClusterNetworksArgs',
    'ClusterNetworksArgsDict',
    'ClusterNetworksIpAllocationPolicyArgs',
    'ClusterNetworksIpAllocationPolicyArgsDict',
    'ClusterNetworksIpAllocationPolicyBondPolicyArgs',
    'ClusterNetworksIpAllocationPolicyBondPolicyArgsDict',
    'ClusterNetworksIpAllocationPolicyBondPolicyBondArgs',
    'ClusterNetworksIpAllocationPolicyBondPolicyBondArgsDict',
    'ClusterNetworksIpAllocationPolicyMachineTypePolicyArgs',
    'ClusterNetworksIpAllocationPolicyMachineTypePolicyArgsDict',
    'ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgs',
    'ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgsDict',
    'ClusterNetworksIpAllocationPolicyNodePolicyArgs',
    'ClusterNetworksIpAllocationPolicyNodePolicyArgsDict',
    'ClusterNetworksIpAllocationPolicyNodePolicyBondArgs',
    'ClusterNetworksIpAllocationPolicyNodePolicyBondArgsDict',
    'ClusterNetworksNewVpdInfoArgs',
    'ClusterNetworksNewVpdInfoArgsDict',
    'ClusterNetworksNewVpdInfoVpdSubnetArgs',
    'ClusterNetworksNewVpdInfoVpdSubnetArgsDict',
    'ClusterNetworksVpdInfoArgs',
    'ClusterNetworksVpdInfoArgsDict',
    'ClusterNodeGroupArgs',
    'ClusterNodeGroupArgsDict',
    'ClusterNodeGroupNodeArgs',
    'ClusterNodeGroupNodeArgsDict',
    'ExperimentPlanTemplateTemplatePipelineArgs',
    'ExperimentPlanTemplateTemplatePipelineArgsDict',
    'ExperimentPlanTemplateTemplatePipelineEnvParamsArgs',
    'ExperimentPlanTemplateTemplatePipelineEnvParamsArgsDict',
    'NodeGroupAttachmentDataDiskArgs',
    'NodeGroupAttachmentDataDiskArgsDict',
    'NodeGroupIpAllocationPolicyArgs',
    'NodeGroupIpAllocationPolicyArgsDict',
    'NodeGroupIpAllocationPolicyBondPolicyArgs',
    'NodeGroupIpAllocationPolicyBondPolicyArgsDict',
    'NodeGroupIpAllocationPolicyBondPolicyBondArgs',
    'NodeGroupIpAllocationPolicyBondPolicyBondArgsDict',
    'NodeGroupIpAllocationPolicyMachineTypePolicyArgs',
    'NodeGroupIpAllocationPolicyMachineTypePolicyArgsDict',
    'NodeGroupIpAllocationPolicyMachineTypePolicyBondArgs',
    'NodeGroupIpAllocationPolicyMachineTypePolicyBondArgsDict',
    'NodeGroupIpAllocationPolicyNodePolicyArgs',
    'NodeGroupIpAllocationPolicyNodePolicyArgsDict',
    'NodeGroupIpAllocationPolicyNodePolicyBondArgs',
    'NodeGroupIpAllocationPolicyNodePolicyBondArgsDict',
    'NodeGroupNodeArgs',
    'NodeGroupNodeArgsDict',
    'ResourceMachineTypesArgs',
    'ResourceMachineTypesArgsDict',
    'ResourceUserAccessParamArgs',
    'ResourceUserAccessParamArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterComponentArgsDict(TypedDict):
        component_config: NotRequired[pulumi.Input['ClusterComponentComponentConfigArgsDict']]
        """
        Component Configuration See `component_config` below.
        """
        component_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Component Type
        """
elif False:
    ClusterComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterComponentArgs:
    def __init__(__self__, *,
                 component_config: Optional[pulumi.Input['ClusterComponentComponentConfigArgs']] = None,
                 component_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ClusterComponentComponentConfigArgs'] component_config: Component Configuration See `component_config` below.
        :param pulumi.Input[_builtins.str] component_type: Component Type
        """
        if component_config is not None:
            pulumi.set(__self__, "component_config", component_config)
        if component_type is not None:
            pulumi.set(__self__, "component_type", component_type)

    @_builtins.property
    @pulumi.getter(name="componentConfig")
    def component_config(self) -> Optional[pulumi.Input['ClusterComponentComponentConfigArgs']]:
        """
        Component Configuration See `component_config` below.
        """
        return pulumi.get(self, "component_config")

    @component_config.setter
    def component_config(self, value: Optional[pulumi.Input['ClusterComponentComponentConfigArgs']]):
        pulumi.set(self, "component_config", value)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Component Type
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "component_type", value)


if not MYPY:
    class ClusterComponentComponentConfigArgsDict(TypedDict):
        basic_args: NotRequired[pulumi.Input[_builtins.str]]
        """
        Component Basic Parameters
        """
        node_units: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Node pool configuration, and is used to establish the corresponding relationship between node groups and node pools. When
        ComponentType = "ACKEdge" is required. Other values are empty.
        """
elif False:
    ClusterComponentComponentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterComponentComponentConfigArgs:
    def __init__(__self__, *,
                 basic_args: Optional[pulumi.Input[_builtins.str]] = None,
                 node_units: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] basic_args: Component Basic Parameters
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] node_units: Node pool configuration, and is used to establish the corresponding relationship between node groups and node pools. When
               ComponentType = "ACKEdge" is required. Other values are empty.
        """
        if basic_args is not None:
            pulumi.set(__self__, "basic_args", basic_args)
        if node_units is not None:
            pulumi.set(__self__, "node_units", node_units)

    @_builtins.property
    @pulumi.getter(name="basicArgs")
    def basic_args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Component Basic Parameters
        """
        return pulumi.get(self, "basic_args")

    @basic_args.setter
    def basic_args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_args", value)

    @_builtins.property
    @pulumi.getter(name="nodeUnits")
    def node_units(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Node pool configuration, and is used to establish the corresponding relationship between node groups and node pools. When
        ComponentType = "ACKEdge" is required. Other values are empty.
        """
        return pulumi.get(self, "node_units")

    @node_units.setter
    def node_units(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "node_units", value)


if not MYPY:
    class ClusterNetworksArgsDict(TypedDict):
        ip_allocation_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyArgsDict']]]]
        """
        IP allocation policy See `ip_allocation_policy` below.
        """
        new_vpd_info: NotRequired[pulumi.Input['ClusterNetworksNewVpdInfoArgsDict']]
        """
        Vpd configuration information See `new_vpd_info` below.
        """
        security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Security group ID
        """
        tail_ip_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP version
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        VPC ID
        """
        vpd_info: NotRequired[pulumi.Input['ClusterNetworksVpdInfoArgsDict']]
        """
        Multiplexing VPD information See `vpd_info` below.
        """
        vswitch_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch ID
        """
        vswitch_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch ZoneID
        """
elif False:
    ClusterNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksArgs:
    def __init__(__self__, *,
                 ip_allocation_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyArgs']]]] = None,
                 new_vpd_info: Optional[pulumi.Input['ClusterNetworksNewVpdInfoArgs']] = None,
                 security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tail_ip_version: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpd_info: Optional[pulumi.Input['ClusterNetworksVpdInfoArgs']] = None,
                 vswitch_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vswitch_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyArgs']]] ip_allocation_policies: IP allocation policy See `ip_allocation_policy` below.
        :param pulumi.Input['ClusterNetworksNewVpdInfoArgs'] new_vpd_info: Vpd configuration information See `new_vpd_info` below.
        :param pulumi.Input[_builtins.str] security_group_id: Security group ID
        :param pulumi.Input[_builtins.str] tail_ip_version: IP version
        :param pulumi.Input[_builtins.str] vpc_id: VPC ID
        :param pulumi.Input['ClusterNetworksVpdInfoArgs'] vpd_info: Multiplexing VPD information See `vpd_info` below.
        :param pulumi.Input[_builtins.str] vswitch_id: Switch ID
        :param pulumi.Input[_builtins.str] vswitch_zone_id: Switch ZoneID
        """
        if ip_allocation_policies is not None:
            pulumi.set(__self__, "ip_allocation_policies", ip_allocation_policies)
        if new_vpd_info is not None:
            pulumi.set(__self__, "new_vpd_info", new_vpd_info)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if tail_ip_version is not None:
            pulumi.set(__self__, "tail_ip_version", tail_ip_version)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vpd_info is not None:
            pulumi.set(__self__, "vpd_info", vpd_info)
        if vswitch_id is not None:
            pulumi.set(__self__, "vswitch_id", vswitch_id)
        if vswitch_zone_id is not None:
            pulumi.set(__self__, "vswitch_zone_id", vswitch_zone_id)

    @_builtins.property
    @pulumi.getter(name="ipAllocationPolicies")
    def ip_allocation_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyArgs']]]]:
        """
        IP allocation policy See `ip_allocation_policy` below.
        """
        return pulumi.get(self, "ip_allocation_policies")

    @ip_allocation_policies.setter
    def ip_allocation_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyArgs']]]]):
        pulumi.set(self, "ip_allocation_policies", value)

    @_builtins.property
    @pulumi.getter(name="newVpdInfo")
    def new_vpd_info(self) -> Optional[pulumi.Input['ClusterNetworksNewVpdInfoArgs']]:
        """
        Vpd configuration information See `new_vpd_info` below.
        """
        return pulumi.get(self, "new_vpd_info")

    @new_vpd_info.setter
    def new_vpd_info(self, value: Optional[pulumi.Input['ClusterNetworksNewVpdInfoArgs']]):
        pulumi.set(self, "new_vpd_info", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Security group ID
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="tailIpVersion")
    def tail_ip_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP version
        """
        return pulumi.get(self, "tail_ip_version")

    @tail_ip_version.setter
    def tail_ip_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tail_ip_version", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VPC ID
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="vpdInfo")
    def vpd_info(self) -> Optional[pulumi.Input['ClusterNetworksVpdInfoArgs']]:
        """
        Multiplexing VPD information See `vpd_info` below.
        """
        return pulumi.get(self, "vpd_info")

    @vpd_info.setter
    def vpd_info(self, value: Optional[pulumi.Input['ClusterNetworksVpdInfoArgs']]):
        pulumi.set(self, "vpd_info", value)

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch ID
        """
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vswitch_id", value)

    @_builtins.property
    @pulumi.getter(name="vswitchZoneId")
    def vswitch_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch ZoneID
        """
        return pulumi.get(self, "vswitch_zone_id")

    @vswitch_zone_id.setter
    def vswitch_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vswitch_zone_id", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyArgsDict(TypedDict):
        bond_policy: NotRequired[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyArgsDict']]
        """
        Bond policy See `bond_policy` below.
        """
        machine_type_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyArgsDict']]]]
        """
        Model Assignment Policy See `machine_type_policy` below.
        """
        node_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyArgsDict']]]]
        """
        Node allocation policy See `node_policy` below.
        """
elif False:
    ClusterNetworksIpAllocationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyArgs:
    def __init__(__self__, *,
                 bond_policy: Optional[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyArgs']] = None,
                 machine_type_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyArgs']]]] = None,
                 node_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyArgs']]]] = None):
        """
        :param pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyArgs'] bond_policy: Bond policy See `bond_policy` below.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyArgs']]] machine_type_policies: Model Assignment Policy See `machine_type_policy` below.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyArgs']]] node_policies: Node allocation policy See `node_policy` below.
        """
        if bond_policy is not None:
            pulumi.set(__self__, "bond_policy", bond_policy)
        if machine_type_policies is not None:
            pulumi.set(__self__, "machine_type_policies", machine_type_policies)
        if node_policies is not None:
            pulumi.set(__self__, "node_policies", node_policies)

    @_builtins.property
    @pulumi.getter(name="bondPolicy")
    def bond_policy(self) -> Optional[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyArgs']]:
        """
        Bond policy See `bond_policy` below.
        """
        return pulumi.get(self, "bond_policy")

    @bond_policy.setter
    def bond_policy(self, value: Optional[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyArgs']]):
        pulumi.set(self, "bond_policy", value)

    @_builtins.property
    @pulumi.getter(name="machineTypePolicies")
    def machine_type_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyArgs']]]]:
        """
        Model Assignment Policy See `machine_type_policy` below.
        """
        return pulumi.get(self, "machine_type_policies")

    @machine_type_policies.setter
    def machine_type_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyArgs']]]]):
        pulumi.set(self, "machine_type_policies", value)

    @_builtins.property
    @pulumi.getter(name="nodePolicies")
    def node_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyArgs']]]]:
        """
        Node allocation policy See `node_policy` below.
        """
        return pulumi.get(self, "node_policies")

    @node_policies.setter
    def node_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyArgs']]]]):
        pulumi.set(self, "node_policies", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyBondPolicyArgsDict(TypedDict):
        bond_default_subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default bond cluster subnet
        """
        bonds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyBondArgsDict']]]]
        """
        Bond information See `bonds` below.
        """
elif False:
    ClusterNetworksIpAllocationPolicyBondPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyBondPolicyArgs:
    def __init__(__self__, *,
                 bond_default_subnet: Optional[pulumi.Input[_builtins.str]] = None,
                 bonds: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyBondArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] bond_default_subnet: Default bond cluster subnet
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyBondArgs']]] bonds: Bond information See `bonds` below.
        """
        if bond_default_subnet is not None:
            pulumi.set(__self__, "bond_default_subnet", bond_default_subnet)
        if bonds is not None:
            pulumi.set(__self__, "bonds", bonds)

    @_builtins.property
    @pulumi.getter(name="bondDefaultSubnet")
    def bond_default_subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default bond cluster subnet
        """
        return pulumi.get(self, "bond_default_subnet")

    @bond_default_subnet.setter
    def bond_default_subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bond_default_subnet", value)

    @_builtins.property
    @pulumi.getter
    def bonds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyBondArgs']]]]:
        """
        Bond information See `bonds` below.
        """
        return pulumi.get(self, "bonds")

    @bonds.setter
    def bonds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyBondPolicyBondArgs']]]]):
        pulumi.set(self, "bonds", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyBondPolicyBondArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bond name
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP source cluster subnet
        """
elif False:
    ClusterNetworksIpAllocationPolicyBondPolicyBondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyBondPolicyBondArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The bond name
        :param pulumi.Input[_builtins.str] subnet: IP source cluster subnet
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bond name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP source cluster subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyMachineTypePolicyArgsDict(TypedDict):
        bonds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgsDict']]]]
        """
        Bond information See `bonds` below.
        """
        machine_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterNetworksIpAllocationPolicyMachineTypePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyMachineTypePolicyArgs:
    def __init__(__self__, *,
                 bonds: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgs']]]] = None,
                 machine_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgs']]] bonds: Bond information See `bonds` below.
        """
        if bonds is not None:
            pulumi.set(__self__, "bonds", bonds)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)

    @_builtins.property
    @pulumi.getter
    def bonds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgs']]]]:
        """
        Bond information See `bonds` below.
        """
        return pulumi.get(self, "bonds")

    @bonds.setter
    def bonds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgs']]]]):
        pulumi.set(self, "bonds", value)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machine_type", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bond name
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP source cluster subnet
        """
elif False:
    ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyMachineTypePolicyBondArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The bond name
        :param pulumi.Input[_builtins.str] subnet: IP source cluster subnet
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bond name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP source cluster subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyNodePolicyArgsDict(TypedDict):
        bonds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyBondArgsDict']]]]
        """
        Bond information See `bonds` below.
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterNetworksIpAllocationPolicyNodePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyNodePolicyArgs:
    def __init__(__self__, *,
                 bonds: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyBondArgs']]]] = None,
                 node_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyBondArgs']]] bonds: Bond information See `bonds` below.
        """
        if bonds is not None:
            pulumi.set(__self__, "bonds", bonds)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)

    @_builtins.property
    @pulumi.getter
    def bonds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyBondArgs']]]]:
        """
        Bond information See `bonds` below.
        """
        return pulumi.get(self, "bonds")

    @bonds.setter
    def bonds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksIpAllocationPolicyNodePolicyBondArgs']]]]):
        pulumi.set(self, "bonds", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)


if not MYPY:
    class ClusterNetworksIpAllocationPolicyNodePolicyBondArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bond name
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP source cluster subnet
        """
elif False:
    ClusterNetworksIpAllocationPolicyNodePolicyBondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksIpAllocationPolicyNodePolicyBondArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The bond name
        :param pulumi.Input[_builtins.str] subnet: IP source cluster subnet
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bond name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP source cluster subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class ClusterNetworksNewVpdInfoArgsDict(TypedDict):
        cen_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud Enterprise Network ID
        """
        cloud_link_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud chain cidr
        """
        cloud_link_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud chain ID
        """
        monitor_vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proprietary Network
        """
        monitor_vswitch_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proprietary network switch
        """
        vpd_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster network segment
        """
        vpd_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksNewVpdInfoVpdSubnetArgsDict']]]]
        """
        List of cluster subnet ID
        """
elif False:
    ClusterNetworksNewVpdInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksNewVpdInfoArgs:
    def __init__(__self__, *,
                 cen_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_link_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_link_id: Optional[pulumi.Input[_builtins.str]] = None,
                 monitor_vpc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 monitor_vswitch_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpd_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 vpd_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksNewVpdInfoVpdSubnetArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] cen_id: Cloud Enterprise Network ID
        :param pulumi.Input[_builtins.str] cloud_link_cidr: Cloud chain cidr
        :param pulumi.Input[_builtins.str] cloud_link_id: Cloud chain ID
        :param pulumi.Input[_builtins.str] monitor_vpc_id: Proprietary Network
        :param pulumi.Input[_builtins.str] monitor_vswitch_id: Proprietary network switch
        :param pulumi.Input[_builtins.str] vpd_cidr: Cluster network segment
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworksNewVpdInfoVpdSubnetArgs']]] vpd_subnets: List of cluster subnet ID
        """
        if cen_id is not None:
            pulumi.set(__self__, "cen_id", cen_id)
        if cloud_link_cidr is not None:
            pulumi.set(__self__, "cloud_link_cidr", cloud_link_cidr)
        if cloud_link_id is not None:
            pulumi.set(__self__, "cloud_link_id", cloud_link_id)
        if monitor_vpc_id is not None:
            pulumi.set(__self__, "monitor_vpc_id", monitor_vpc_id)
        if monitor_vswitch_id is not None:
            pulumi.set(__self__, "monitor_vswitch_id", monitor_vswitch_id)
        if vpd_cidr is not None:
            pulumi.set(__self__, "vpd_cidr", vpd_cidr)
        if vpd_subnets is not None:
            pulumi.set(__self__, "vpd_subnets", vpd_subnets)

    @_builtins.property
    @pulumi.getter(name="cenId")
    def cen_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud Enterprise Network ID
        """
        return pulumi.get(self, "cen_id")

    @cen_id.setter
    def cen_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cen_id", value)

    @_builtins.property
    @pulumi.getter(name="cloudLinkCidr")
    def cloud_link_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud chain cidr
        """
        return pulumi.get(self, "cloud_link_cidr")

    @cloud_link_cidr.setter
    def cloud_link_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_link_cidr", value)

    @_builtins.property
    @pulumi.getter(name="cloudLinkId")
    def cloud_link_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud chain ID
        """
        return pulumi.get(self, "cloud_link_id")

    @cloud_link_id.setter
    def cloud_link_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_link_id", value)

    @_builtins.property
    @pulumi.getter(name="monitorVpcId")
    def monitor_vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proprietary Network
        """
        return pulumi.get(self, "monitor_vpc_id")

    @monitor_vpc_id.setter
    def monitor_vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monitor_vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="monitorVswitchId")
    def monitor_vswitch_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proprietary network switch
        """
        return pulumi.get(self, "monitor_vswitch_id")

    @monitor_vswitch_id.setter
    def monitor_vswitch_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monitor_vswitch_id", value)

    @_builtins.property
    @pulumi.getter(name="vpdCidr")
    def vpd_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster network segment
        """
        return pulumi.get(self, "vpd_cidr")

    @vpd_cidr.setter
    def vpd_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpd_cidr", value)

    @_builtins.property
    @pulumi.getter(name="vpdSubnets")
    def vpd_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksNewVpdInfoVpdSubnetArgs']]]]:
        """
        List of cluster subnet ID
        """
        return pulumi.get(self, "vpd_subnets")

    @vpd_subnets.setter
    def vpd_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworksNewVpdInfoVpdSubnetArgs']]]]):
        pulumi.set(self, "vpd_subnets", value)


if not MYPY:
    class ClusterNetworksNewVpdInfoVpdSubnetArgsDict(TypedDict):
        subnet_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet cidr
        """
        subnet_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet Type
        """
        zone_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterNetworksNewVpdInfoVpdSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksNewVpdInfoVpdSubnetArgs:
    def __init__(__self__, *,
                 subnet_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_type: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_cidr: Subnet cidr
        :param pulumi.Input[_builtins.str] subnet_type: Subnet Type
        """
        if subnet_cidr is not None:
            pulumi.set(__self__, "subnet_cidr", subnet_cidr)
        if subnet_type is not None:
            pulumi.set(__self__, "subnet_type", subnet_type)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet cidr
        """
        return pulumi.get(self, "subnet_cidr")

    @subnet_cidr.setter
    def subnet_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_cidr", value)

    @_builtins.property
    @pulumi.getter(name="subnetType")
    def subnet_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet Type
        """
        return pulumi.get(self, "subnet_type")

    @subnet_type.setter
    def subnet_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_type", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class ClusterNetworksVpdInfoArgsDict(TypedDict):
        vpd_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        VPC ID
        """
        vpd_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of cluster subnet ID
        """
elif False:
    ClusterNetworksVpdInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNetworksVpdInfoArgs:
    def __init__(__self__, *,
                 vpd_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpd_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] vpd_id: VPC ID
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] vpd_subnets: List of cluster subnet ID
        """
        if vpd_id is not None:
            pulumi.set(__self__, "vpd_id", vpd_id)
        if vpd_subnets is not None:
            pulumi.set(__self__, "vpd_subnets", vpd_subnets)

    @_builtins.property
    @pulumi.getter(name="vpdId")
    def vpd_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VPC ID
        """
        return pulumi.get(self, "vpd_id")

    @vpd_id.setter
    def vpd_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpd_id", value)

    @_builtins.property
    @pulumi.getter(name="vpdSubnets")
    def vpd_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of cluster subnet ID
        """
        return pulumi.get(self, "vpd_subnets")

    @vpd_subnets.setter
    def vpd_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "vpd_subnets", value)


if not MYPY:
    class ClusterNodeGroupArgsDict(TypedDict):
        image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        System Image ID
        """
        machine_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Model
        """
        node_group_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node Group Description
        """
        node_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node Group Name
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterNodeGroupNodeArgsDict']]]]
        """
        Node List See `nodes` below.
        """
        user_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance custom data. It needs to be encoded in Base64 mode, and the original data is at most 16KB.
        """
        zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Zone ID
        """
elif False:
    ClusterNodeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeGroupArgs:
    def __init__(__self__, *,
                 image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 machine_type: Optional[pulumi.Input[_builtins.str]] = None,
                 node_group_description: Optional[pulumi.Input[_builtins.str]] = None,
                 node_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNodeGroupNodeArgs']]]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image_id: System Image ID
        :param pulumi.Input[_builtins.str] machine_type: Model
        :param pulumi.Input[_builtins.str] node_group_description: Node Group Description
        :param pulumi.Input[_builtins.str] node_group_name: Node Group Name
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNodeGroupNodeArgs']]] nodes: Node List See `nodes` below.
        :param pulumi.Input[_builtins.str] user_data: Instance custom data. It needs to be encoded in Base64 mode, and the original data is at most 16KB.
        :param pulumi.Input[_builtins.str] zone_id: Zone ID
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if node_group_description is not None:
            pulumi.set(__self__, "node_group_description", node_group_description)
        if node_group_name is not None:
            pulumi.set(__self__, "node_group_name", node_group_name)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        System Image ID
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Model
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machine_type", value)

    @_builtins.property
    @pulumi.getter(name="nodeGroupDescription")
    def node_group_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node Group Description
        """
        return pulumi.get(self, "node_group_description")

    @node_group_description.setter
    def node_group_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_group_description", value)

    @_builtins.property
    @pulumi.getter(name="nodeGroupName")
    def node_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node Group Name
        """
        return pulumi.get(self, "node_group_name")

    @node_group_name.setter
    def node_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_group_name", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNodeGroupNodeArgs']]]]:
        """
        Node List See `nodes` below.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNodeGroupNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance custom data. It needs to be encoded in Base64 mode, and the original data is at most 16KB.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Zone ID
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class ClusterNodeGroupNodeArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name
        """
        login_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Login Password
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        vswitch_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterNodeGroupNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeGroupNodeArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 login_password: Optional[pulumi.Input[_builtins.str]] = None,
                 node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vswitch_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: Host name
        :param pulumi.Input[_builtins.str] login_password: Login Password
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if login_password is not None:
            pulumi.set(__self__, "login_password", login_password)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vswitch_id is not None:
            pulumi.set(__self__, "vswitch_id", vswitch_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="loginPassword")
    def login_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Login Password
        """
        return pulumi.get(self, "login_password")

    @login_password.setter
    def login_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_password", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vswitch_id", value)


if not MYPY:
    class ExperimentPlanTemplateTemplatePipelineArgsDict(TypedDict):
        env_params: pulumi.Input['ExperimentPlanTemplateTemplatePipelineEnvParamsArgsDict']
        """
        Contains a series of parameters related to the environment. See `env_params` below.
        """
        pipeline_order: pulumi.Input[_builtins.int]
        """
        Indicates the sequence number of the pipeline node.
        """
        scene: pulumi.Input[_builtins.str]
        """
        The use of the template scenario. It can have the following optional parameters:
        - baseline: benchmark evaluation
        """
        workload_id: pulumi.Input[_builtins.int]
        """
        Used to uniquely identify a specific payload.
        """
        workload_name: pulumi.Input[_builtins.str]
        """
        The name used to represent a specific payload.
        """
        setting_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Represents additional parameters for the run.
        """
elif False:
    ExperimentPlanTemplateTemplatePipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentPlanTemplateTemplatePipelineArgs:
    def __init__(__self__, *,
                 env_params: pulumi.Input['ExperimentPlanTemplateTemplatePipelineEnvParamsArgs'],
                 pipeline_order: pulumi.Input[_builtins.int],
                 scene: pulumi.Input[_builtins.str],
                 workload_id: pulumi.Input[_builtins.int],
                 workload_name: pulumi.Input[_builtins.str],
                 setting_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['ExperimentPlanTemplateTemplatePipelineEnvParamsArgs'] env_params: Contains a series of parameters related to the environment. See `env_params` below.
        :param pulumi.Input[_builtins.int] pipeline_order: Indicates the sequence number of the pipeline node.
        :param pulumi.Input[_builtins.str] scene: The use of the template scenario. It can have the following optional parameters:
               - baseline: benchmark evaluation
        :param pulumi.Input[_builtins.int] workload_id: Used to uniquely identify a specific payload.
        :param pulumi.Input[_builtins.str] workload_name: The name used to represent a specific payload.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] setting_params: Represents additional parameters for the run.
        """
        pulumi.set(__self__, "env_params", env_params)
        pulumi.set(__self__, "pipeline_order", pipeline_order)
        pulumi.set(__self__, "scene", scene)
        pulumi.set(__self__, "workload_id", workload_id)
        pulumi.set(__self__, "workload_name", workload_name)
        if setting_params is not None:
            pulumi.set(__self__, "setting_params", setting_params)

    @_builtins.property
    @pulumi.getter(name="envParams")
    def env_params(self) -> pulumi.Input['ExperimentPlanTemplateTemplatePipelineEnvParamsArgs']:
        """
        Contains a series of parameters related to the environment. See `env_params` below.
        """
        return pulumi.get(self, "env_params")

    @env_params.setter
    def env_params(self, value: pulumi.Input['ExperimentPlanTemplateTemplatePipelineEnvParamsArgs']):
        pulumi.set(self, "env_params", value)

    @_builtins.property
    @pulumi.getter(name="pipelineOrder")
    def pipeline_order(self) -> pulumi.Input[_builtins.int]:
        """
        Indicates the sequence number of the pipeline node.
        """
        return pulumi.get(self, "pipeline_order")

    @pipeline_order.setter
    def pipeline_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pipeline_order", value)

    @_builtins.property
    @pulumi.getter
    def scene(self) -> pulumi.Input[_builtins.str]:
        """
        The use of the template scenario. It can have the following optional parameters:
        - baseline: benchmark evaluation
        """
        return pulumi.get(self, "scene")

    @scene.setter
    def scene(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scene", value)

    @_builtins.property
    @pulumi.getter(name="workloadId")
    def workload_id(self) -> pulumi.Input[_builtins.int]:
        """
        Used to uniquely identify a specific payload.
        """
        return pulumi.get(self, "workload_id")

    @workload_id.setter
    def workload_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "workload_id", value)

    @_builtins.property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name used to represent a specific payload.
        """
        return pulumi.get(self, "workload_name")

    @workload_name.setter
    def workload_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workload_name", value)

    @_builtins.property
    @pulumi.getter(name="settingParams")
    def setting_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Represents additional parameters for the run.
        """
        return pulumi.get(self, "setting_params")

    @setting_params.setter
    def setting_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "setting_params", value)


if not MYPY:
    class ExperimentPlanTemplateTemplatePipelineEnvParamsArgsDict(TypedDict):
        cpu_per_worker: pulumi.Input[_builtins.int]
        """
        Number of central processing units (CPUs) allocated. This parameter affects the processing power of the computation, especially in tasks that require a large amount of parallel processing.
        """
        gpu_per_worker: pulumi.Input[_builtins.int]
        """
        Number of graphics processing units (GPUs). GPUs are a key component in deep learning and large-scale data processing, so this parameter is very important for tasks that require graphics-accelerated computing.
        """
        memory_per_worker: pulumi.Input[_builtins.int]
        """
        The amount of memory available. Memory size has an important impact on the performance and stability of the program, especially when dealing with large data sets or high-dimensional data.
        """
        share_memory: pulumi.Input[_builtins.int]
        """
        Shared memory GB allocation
        """
        worker_num: pulumi.Input[_builtins.int]
        """
        The total number of nodes. This parameter directly affects the parallelism and computing speed of the task, and a higher number of working nodes usually accelerates the completion of the task.
        """
        cuda_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of CUDA(Compute Unified Device Architecture) used. CUDA is a parallel computing platform and programming model provided by NVIDIA. A specific version may affect the available GPU functions and performance optimization.
        """
        gpu_driver_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the GPU driver used. Driver version may affect GPU performance and compatibility, so it is important to ensure that the correct version is used
        """
        nccl_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The NVIDIA Collective Communications Library(NCCL) version used. NCCL is a library for multi-GPU and multi-node communication. This parameter is particularly important for optimizing data transmission in distributed computing.
        """
        py_torch_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the PyTorch framework used. PyTorch is a widely used deep learning library, and differences between versions may affect the performance and functional support of model training and inference.
        """
elif False:
    ExperimentPlanTemplateTemplatePipelineEnvParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentPlanTemplateTemplatePipelineEnvParamsArgs:
    def __init__(__self__, *,
                 cpu_per_worker: pulumi.Input[_builtins.int],
                 gpu_per_worker: pulumi.Input[_builtins.int],
                 memory_per_worker: pulumi.Input[_builtins.int],
                 share_memory: pulumi.Input[_builtins.int],
                 worker_num: pulumi.Input[_builtins.int],
                 cuda_version: Optional[pulumi.Input[_builtins.str]] = None,
                 gpu_driver_version: Optional[pulumi.Input[_builtins.str]] = None,
                 nccl_version: Optional[pulumi.Input[_builtins.str]] = None,
                 py_torch_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_per_worker: Number of central processing units (CPUs) allocated. This parameter affects the processing power of the computation, especially in tasks that require a large amount of parallel processing.
        :param pulumi.Input[_builtins.int] gpu_per_worker: Number of graphics processing units (GPUs). GPUs are a key component in deep learning and large-scale data processing, so this parameter is very important for tasks that require graphics-accelerated computing.
        :param pulumi.Input[_builtins.int] memory_per_worker: The amount of memory available. Memory size has an important impact on the performance and stability of the program, especially when dealing with large data sets or high-dimensional data.
        :param pulumi.Input[_builtins.int] share_memory: Shared memory GB allocation
        :param pulumi.Input[_builtins.int] worker_num: The total number of nodes. This parameter directly affects the parallelism and computing speed of the task, and a higher number of working nodes usually accelerates the completion of the task.
        :param pulumi.Input[_builtins.str] cuda_version: The version of CUDA(Compute Unified Device Architecture) used. CUDA is a parallel computing platform and programming model provided by NVIDIA. A specific version may affect the available GPU functions and performance optimization.
        :param pulumi.Input[_builtins.str] gpu_driver_version: The version of the GPU driver used. Driver version may affect GPU performance and compatibility, so it is important to ensure that the correct version is used
        :param pulumi.Input[_builtins.str] nccl_version: The NVIDIA Collective Communications Library(NCCL) version used. NCCL is a library for multi-GPU and multi-node communication. This parameter is particularly important for optimizing data transmission in distributed computing.
        :param pulumi.Input[_builtins.str] py_torch_version: The version of the PyTorch framework used. PyTorch is a widely used deep learning library, and differences between versions may affect the performance and functional support of model training and inference.
        """
        pulumi.set(__self__, "cpu_per_worker", cpu_per_worker)
        pulumi.set(__self__, "gpu_per_worker", gpu_per_worker)
        pulumi.set(__self__, "memory_per_worker", memory_per_worker)
        pulumi.set(__self__, "share_memory", share_memory)
        pulumi.set(__self__, "worker_num", worker_num)
        if cuda_version is not None:
            pulumi.set(__self__, "cuda_version", cuda_version)
        if gpu_driver_version is not None:
            pulumi.set(__self__, "gpu_driver_version", gpu_driver_version)
        if nccl_version is not None:
            pulumi.set(__self__, "nccl_version", nccl_version)
        if py_torch_version is not None:
            pulumi.set(__self__, "py_torch_version", py_torch_version)

    @_builtins.property
    @pulumi.getter(name="cpuPerWorker")
    def cpu_per_worker(self) -> pulumi.Input[_builtins.int]:
        """
        Number of central processing units (CPUs) allocated. This parameter affects the processing power of the computation, especially in tasks that require a large amount of parallel processing.
        """
        return pulumi.get(self, "cpu_per_worker")

    @cpu_per_worker.setter
    def cpu_per_worker(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "cpu_per_worker", value)

    @_builtins.property
    @pulumi.getter(name="gpuPerWorker")
    def gpu_per_worker(self) -> pulumi.Input[_builtins.int]:
        """
        Number of graphics processing units (GPUs). GPUs are a key component in deep learning and large-scale data processing, so this parameter is very important for tasks that require graphics-accelerated computing.
        """
        return pulumi.get(self, "gpu_per_worker")

    @gpu_per_worker.setter
    def gpu_per_worker(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "gpu_per_worker", value)

    @_builtins.property
    @pulumi.getter(name="memoryPerWorker")
    def memory_per_worker(self) -> pulumi.Input[_builtins.int]:
        """
        The amount of memory available. Memory size has an important impact on the performance and stability of the program, especially when dealing with large data sets or high-dimensional data.
        """
        return pulumi.get(self, "memory_per_worker")

    @memory_per_worker.setter
    def memory_per_worker(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "memory_per_worker", value)

    @_builtins.property
    @pulumi.getter(name="shareMemory")
    def share_memory(self) -> pulumi.Input[_builtins.int]:
        """
        Shared memory GB allocation
        """
        return pulumi.get(self, "share_memory")

    @share_memory.setter
    def share_memory(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "share_memory", value)

    @_builtins.property
    @pulumi.getter(name="workerNum")
    def worker_num(self) -> pulumi.Input[_builtins.int]:
        """
        The total number of nodes. This parameter directly affects the parallelism and computing speed of the task, and a higher number of working nodes usually accelerates the completion of the task.
        """
        return pulumi.get(self, "worker_num")

    @worker_num.setter
    def worker_num(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "worker_num", value)

    @_builtins.property
    @pulumi.getter(name="cudaVersion")
    def cuda_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of CUDA(Compute Unified Device Architecture) used. CUDA is a parallel computing platform and programming model provided by NVIDIA. A specific version may affect the available GPU functions and performance optimization.
        """
        return pulumi.get(self, "cuda_version")

    @cuda_version.setter
    def cuda_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cuda_version", value)

    @_builtins.property
    @pulumi.getter(name="gpuDriverVersion")
    def gpu_driver_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the GPU driver used. Driver version may affect GPU performance and compatibility, so it is important to ensure that the correct version is used
        """
        return pulumi.get(self, "gpu_driver_version")

    @gpu_driver_version.setter
    def gpu_driver_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gpu_driver_version", value)

    @_builtins.property
    @pulumi.getter(name="ncclVersion")
    def nccl_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The NVIDIA Collective Communications Library(NCCL) version used. NCCL is a library for multi-GPU and multi-node communication. This parameter is particularly important for optimizing data transmission in distributed computing.
        """
        return pulumi.get(self, "nccl_version")

    @nccl_version.setter
    def nccl_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nccl_version", value)

    @_builtins.property
    @pulumi.getter(name="pyTorchVersion")
    def py_torch_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the PyTorch framework used. PyTorch is a widely used deep learning library, and differences between versions may affect the performance and functional support of model training and inference.
        """
        return pulumi.get(self, "py_torch_version")

    @py_torch_version.setter
    def py_torch_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "py_torch_version", value)


if not MYPY:
    class NodeGroupAttachmentDataDiskArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type
        """
        delete_with_node: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate whether the data disk is released with the node. true indicates that the data disk will be released together when the node unsubscribes.
        """
        performance_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Performance level
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Data disk size
        """
elif False:
    NodeGroupAttachmentDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupAttachmentDataDiskArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_with_node: Optional[pulumi.Input[_builtins.bool]] = None,
                 performance_level: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] category: Type
        :param pulumi.Input[_builtins.bool] delete_with_node: Indicate whether the data disk is released with the node. true indicates that the data disk will be released together when the node unsubscribes.
        :param pulumi.Input[_builtins.str] performance_level: Performance level
        :param pulumi.Input[_builtins.int] size: Data disk size
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if delete_with_node is not None:
            pulumi.set(__self__, "delete_with_node", delete_with_node)
        if performance_level is not None:
            pulumi.set(__self__, "performance_level", performance_level)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter(name="deleteWithNode")
    def delete_with_node(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate whether the data disk is released with the node. true indicates that the data disk will be released together when the node unsubscribes.
        """
        return pulumi.get(self, "delete_with_node")

    @delete_with_node.setter
    def delete_with_node(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_with_node", value)

    @_builtins.property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Performance level
        """
        return pulumi.get(self, "performance_level")

    @performance_level.setter
    def performance_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "performance_level", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Data disk size
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyArgsDict(TypedDict):
        bond_policy: NotRequired[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyArgsDict']]
        """
        Specify the cluster subnet ID based on the bond name See `bond_policy` below.
        """
        machine_type_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyArgsDict']]]]
        """
        Model Assignment Policy See `machine_type_policy` below.
        """
        node_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyArgsDict']]]]
        """
        Node allocation policy See `node_policy` below.
        """
elif False:
    NodeGroupIpAllocationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyArgs:
    def __init__(__self__, *,
                 bond_policy: Optional[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyArgs']] = None,
                 machine_type_policies: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyArgs']]]] = None,
                 node_policies: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyArgs']]]] = None):
        """
        :param pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyArgs'] bond_policy: Specify the cluster subnet ID based on the bond name See `bond_policy` below.
        :param pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyArgs']]] machine_type_policies: Model Assignment Policy See `machine_type_policy` below.
        :param pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyArgs']]] node_policies: Node allocation policy See `node_policy` below.
        """
        if bond_policy is not None:
            pulumi.set(__self__, "bond_policy", bond_policy)
        if machine_type_policies is not None:
            pulumi.set(__self__, "machine_type_policies", machine_type_policies)
        if node_policies is not None:
            pulumi.set(__self__, "node_policies", node_policies)

    @_builtins.property
    @pulumi.getter(name="bondPolicy")
    def bond_policy(self) -> Optional[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyArgs']]:
        """
        Specify the cluster subnet ID based on the bond name See `bond_policy` below.
        """
        return pulumi.get(self, "bond_policy")

    @bond_policy.setter
    def bond_policy(self, value: Optional[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyArgs']]):
        pulumi.set(self, "bond_policy", value)

    @_builtins.property
    @pulumi.getter(name="machineTypePolicies")
    def machine_type_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyArgs']]]]:
        """
        Model Assignment Policy See `machine_type_policy` below.
        """
        return pulumi.get(self, "machine_type_policies")

    @machine_type_policies.setter
    def machine_type_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyArgs']]]]):
        pulumi.set(self, "machine_type_policies", value)

    @_builtins.property
    @pulumi.getter(name="nodePolicies")
    def node_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyArgs']]]]:
        """
        Node allocation policy See `node_policy` below.
        """
        return pulumi.get(self, "node_policies")

    @node_policies.setter
    def node_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyArgs']]]]):
        pulumi.set(self, "node_policies", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyBondPolicyArgsDict(TypedDict):
        bond_default_subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default bond cluster subnet
        """
        bonds: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyBondArgsDict']]]]
        """
        Bond information See `bonds` below.
        """
elif False:
    NodeGroupIpAllocationPolicyBondPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyBondPolicyArgs:
    def __init__(__self__, *,
                 bond_default_subnet: Optional[pulumi.Input[_builtins.str]] = None,
                 bonds: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyBondArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] bond_default_subnet: Default bond cluster subnet
        :param pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyBondArgs']]] bonds: Bond information See `bonds` below.
        """
        if bond_default_subnet is not None:
            pulumi.set(__self__, "bond_default_subnet", bond_default_subnet)
        if bonds is not None:
            pulumi.set(__self__, "bonds", bonds)

    @_builtins.property
    @pulumi.getter(name="bondDefaultSubnet")
    def bond_default_subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default bond cluster subnet
        """
        return pulumi.get(self, "bond_default_subnet")

    @bond_default_subnet.setter
    def bond_default_subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bond_default_subnet", value)

    @_builtins.property
    @pulumi.getter
    def bonds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyBondArgs']]]]:
        """
        Bond information See `bonds` below.
        """
        return pulumi.get(self, "bonds")

    @bonds.setter
    def bonds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyBondPolicyBondArgs']]]]):
        pulumi.set(self, "bonds", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyBondPolicyBondArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bond name
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP source cluster subnet
        """
elif False:
    NodeGroupIpAllocationPolicyBondPolicyBondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyBondPolicyBondArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The bond name
        :param pulumi.Input[_builtins.str] subnet: IP source cluster subnet
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bond name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP source cluster subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyMachineTypePolicyArgsDict(TypedDict):
        bonds: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyBondArgsDict']]]]
        """
        Bond information See `bonds` below.
        """
        machine_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Machine type
        """
elif False:
    NodeGroupIpAllocationPolicyMachineTypePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyMachineTypePolicyArgs:
    def __init__(__self__, *,
                 bonds: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyBondArgs']]]] = None,
                 machine_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyBondArgs']]] bonds: Bond information See `bonds` below.
        :param pulumi.Input[_builtins.str] machine_type: Machine type
        """
        if bonds is not None:
            pulumi.set(__self__, "bonds", bonds)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)

    @_builtins.property
    @pulumi.getter
    def bonds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyBondArgs']]]]:
        """
        Bond information See `bonds` below.
        """
        return pulumi.get(self, "bonds")

    @bonds.setter
    def bonds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyMachineTypePolicyBondArgs']]]]):
        pulumi.set(self, "bonds", value)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Machine type
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machine_type", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyMachineTypePolicyBondArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bond name
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP source cluster subnet
        """
elif False:
    NodeGroupIpAllocationPolicyMachineTypePolicyBondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyMachineTypePolicyBondArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The bond name
        :param pulumi.Input[_builtins.str] subnet: IP source cluster subnet
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bond name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP source cluster subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyNodePolicyArgsDict(TypedDict):
        bonds: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyBondArgsDict']]]]
        """
        Bond information See `bonds` below.
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeGroupIpAllocationPolicyNodePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyNodePolicyArgs:
    def __init__(__self__, *,
                 bonds: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyBondArgs']]]] = None,
                 node_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyBondArgs']]] bonds: Bond information See `bonds` below.
        """
        if bonds is not None:
            pulumi.set(__self__, "bonds", bonds)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)

    @_builtins.property
    @pulumi.getter
    def bonds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyBondArgs']]]]:
        """
        Bond information See `bonds` below.
        """
        return pulumi.get(self, "bonds")

    @bonds.setter
    def bonds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGroupIpAllocationPolicyNodePolicyBondArgs']]]]):
        pulumi.set(self, "bonds", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)


if not MYPY:
    class NodeGroupIpAllocationPolicyNodePolicyBondArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bond name
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP source cluster subnet
        """
elif False:
    NodeGroupIpAllocationPolicyNodePolicyBondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupIpAllocationPolicyNodePolicyBondArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The bond name
        :param pulumi.Input[_builtins.str] subnet: IP source cluster subnet
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bond name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP source cluster subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class NodeGroupNodeArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name
        """
        login_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Login Password
        """
        node_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node ID
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        VPC ID
        """
        vswitch_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Switch ID
        """
elif False:
    NodeGroupNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupNodeArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 login_password: Optional[pulumi.Input[_builtins.str]] = None,
                 node_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vswitch_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: Host name
        :param pulumi.Input[_builtins.str] login_password: Login Password
        :param pulumi.Input[_builtins.str] node_id: Node ID
        :param pulumi.Input[_builtins.str] vpc_id: VPC ID
        :param pulumi.Input[_builtins.str] vswitch_id: Switch ID
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if login_password is not None:
            pulumi.set(__self__, "login_password", login_password)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vswitch_id is not None:
            pulumi.set(__self__, "vswitch_id", vswitch_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="loginPassword")
    def login_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Login Password
        """
        return pulumi.get(self, "login_password")

    @login_password.setter
    def login_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_password", value)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node ID
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VPC ID
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Switch ID
        """
        return pulumi.get(self, "vswitch_id")

    @vswitch_id.setter
    def vswitch_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vswitch_id", value)


if not MYPY:
    class ResourceMachineTypesArgsDict(TypedDict):
        cpu_info: pulumi.Input[_builtins.str]
        """
        Provides CPU details, including the number of cores, number of threads, clock frequency, and architecture type. This information helps to evaluate the processing power and identify whether it can meet the performance requirements of a particular application.
        """
        gpu_info: pulumi.Input[_builtins.str]
        """
        Provides detailed information about the GPU, including the number, model, memory size, and computing capability. This information is particularly important for tasks such as deep learning, scientific computing, and graph processing, helping users understand the graph processing capabilities of nodes.
        """
        bond_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        This property specifies the number of network bindings, which relates to the number of physical or virtual network cards connected to the network through the network interface card (NIC). Multiple network bindings can increase bandwidth and redundancy and improve network reliability.
        """
        disk_info: NotRequired[pulumi.Input[_builtins.str]]
        """
        Displays information about the storage device, including the disk type (such as SSD or HDD), capacity, and I/O performance. Storage performance is critical in data-intensive applications such as big data processing and databases.
        """
        memory_info: NotRequired[pulumi.Input[_builtins.str]]
        """
        This property provides memory details, including total memory, available memory, and usage. This helps users understand the memory processing capabilities of compute nodes, especially when running heavy-duty applications.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specification Name.
        """
        network_info: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains detailed information about the network interface, such as network bandwidth, latency, protocol types supported by the network, IP addresses, and network topology. Optimizing network information is essential to ensure efficient data transmission and low latency.
        """
        network_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the network mode, such as bridge mode, NAT mode, or direct connection mode. Different network modes affect the network configuration and data transmission performance of nodes, and affect the network access methods of computing instances.
        """
        node_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the total number of compute nodes. This property is particularly important in distributed computing and cluster environments, because the number of nodes often directly affects the computing power and the ability to parallel processing.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Usually refers to a specific resource type (such as virtual machine, physical server, container, etc.), which is used to distinguish different computing units or resource categories.
        """
elif False:
    ResourceMachineTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMachineTypesArgs:
    def __init__(__self__, *,
                 cpu_info: pulumi.Input[_builtins.str],
                 gpu_info: pulumi.Input[_builtins.str],
                 bond_num: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_info: Optional[pulumi.Input[_builtins.str]] = None,
                 memory_info: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_info: Optional[pulumi.Input[_builtins.str]] = None,
                 network_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 node_count: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu_info: Provides CPU details, including the number of cores, number of threads, clock frequency, and architecture type. This information helps to evaluate the processing power and identify whether it can meet the performance requirements of a particular application.
        :param pulumi.Input[_builtins.str] gpu_info: Provides detailed information about the GPU, including the number, model, memory size, and computing capability. This information is particularly important for tasks such as deep learning, scientific computing, and graph processing, helping users understand the graph processing capabilities of nodes.
        :param pulumi.Input[_builtins.int] bond_num: This property specifies the number of network bindings, which relates to the number of physical or virtual network cards connected to the network through the network interface card (NIC). Multiple network bindings can increase bandwidth and redundancy and improve network reliability.
        :param pulumi.Input[_builtins.str] disk_info: Displays information about the storage device, including the disk type (such as SSD or HDD), capacity, and I/O performance. Storage performance is critical in data-intensive applications such as big data processing and databases.
        :param pulumi.Input[_builtins.str] memory_info: This property provides memory details, including total memory, available memory, and usage. This helps users understand the memory processing capabilities of compute nodes, especially when running heavy-duty applications.
        :param pulumi.Input[_builtins.str] name: Specification Name.
        :param pulumi.Input[_builtins.str] network_info: Contains detailed information about the network interface, such as network bandwidth, latency, protocol types supported by the network, IP addresses, and network topology. Optimizing network information is essential to ensure efficient data transmission and low latency.
        :param pulumi.Input[_builtins.str] network_mode: Specifies the network mode, such as bridge mode, NAT mode, or direct connection mode. Different network modes affect the network configuration and data transmission performance of nodes, and affect the network access methods of computing instances.
        :param pulumi.Input[_builtins.int] node_count: Specifies the total number of compute nodes. This property is particularly important in distributed computing and cluster environments, because the number of nodes often directly affects the computing power and the ability to parallel processing.
        :param pulumi.Input[_builtins.str] type: Usually refers to a specific resource type (such as virtual machine, physical server, container, etc.), which is used to distinguish different computing units or resource categories.
        """
        pulumi.set(__self__, "cpu_info", cpu_info)
        pulumi.set(__self__, "gpu_info", gpu_info)
        if bond_num is not None:
            pulumi.set(__self__, "bond_num", bond_num)
        if disk_info is not None:
            pulumi.set(__self__, "disk_info", disk_info)
        if memory_info is not None:
            pulumi.set(__self__, "memory_info", memory_info)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_info is not None:
            pulumi.set(__self__, "network_info", network_info)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cpuInfo")
    def cpu_info(self) -> pulumi.Input[_builtins.str]:
        """
        Provides CPU details, including the number of cores, number of threads, clock frequency, and architecture type. This information helps to evaluate the processing power and identify whether it can meet the performance requirements of a particular application.
        """
        return pulumi.get(self, "cpu_info")

    @cpu_info.setter
    def cpu_info(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu_info", value)

    @_builtins.property
    @pulumi.getter(name="gpuInfo")
    def gpu_info(self) -> pulumi.Input[_builtins.str]:
        """
        Provides detailed information about the GPU, including the number, model, memory size, and computing capability. This information is particularly important for tasks such as deep learning, scientific computing, and graph processing, helping users understand the graph processing capabilities of nodes.
        """
        return pulumi.get(self, "gpu_info")

    @gpu_info.setter
    def gpu_info(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "gpu_info", value)

    @_builtins.property
    @pulumi.getter(name="bondNum")
    def bond_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        This property specifies the number of network bindings, which relates to the number of physical or virtual network cards connected to the network through the network interface card (NIC). Multiple network bindings can increase bandwidth and redundancy and improve network reliability.
        """
        return pulumi.get(self, "bond_num")

    @bond_num.setter
    def bond_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bond_num", value)

    @_builtins.property
    @pulumi.getter(name="diskInfo")
    def disk_info(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Displays information about the storage device, including the disk type (such as SSD or HDD), capacity, and I/O performance. Storage performance is critical in data-intensive applications such as big data processing and databases.
        """
        return pulumi.get(self, "disk_info")

    @disk_info.setter
    def disk_info(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_info", value)

    @_builtins.property
    @pulumi.getter(name="memoryInfo")
    def memory_info(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This property provides memory details, including total memory, available memory, and usage. This helps users understand the memory processing capabilities of compute nodes, especially when running heavy-duty applications.
        """
        return pulumi.get(self, "memory_info")

    @memory_info.setter
    def memory_info(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "memory_info", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specification Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains detailed information about the network interface, such as network bandwidth, latency, protocol types supported by the network, IP addresses, and network topology. Optimizing network information is essential to ensure efficient data transmission and low latency.
        """
        return pulumi.get(self, "network_info")

    @network_info.setter
    def network_info(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_info", value)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the network mode, such as bridge mode, NAT mode, or direct connection mode. Different network modes affect the network configuration and data transmission performance of nodes, and affect the network access methods of computing instances.
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_mode", value)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the total number of compute nodes. This property is particularly important in distributed computing and cluster environments, because the number of nodes often directly affects the computing power and the ability to parallel processing.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_count", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Usually refers to a specific resource type (such as virtual machine, physical server, container, etc.), which is used to distinguish different computing units or resource categories.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceUserAccessParamArgsDict(TypedDict):
        access_id: pulumi.Input[_builtins.str]
        """
        Access keys are important credentials for authentication.
        """
        access_key: pulumi.Input[_builtins.str]
        """
        A Secret Key is a Secret credential paired with an access Key to verify a user's identity and protect the security of an interface.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        An Endpoint is a network address for accessing a service or API, usually a URL to a specific service instance.
        """
        workspace_id: pulumi.Input[_builtins.str]
        """
        A Workspace generally refers to a separate space created by a user on a particular computing environment or platform.
        """
elif False:
    ResourceUserAccessParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceUserAccessParamArgs:
    def __init__(__self__, *,
                 access_id: pulumi.Input[_builtins.str],
                 access_key: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 workspace_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] access_id: Access keys are important credentials for authentication.
        :param pulumi.Input[_builtins.str] access_key: A Secret Key is a Secret credential paired with an access Key to verify a user's identity and protect the security of an interface.
        :param pulumi.Input[_builtins.str] endpoint: An Endpoint is a network address for accessing a service or API, usually a URL to a specific service instance.
        :param pulumi.Input[_builtins.str] workspace_id: A Workspace generally refers to a separate space created by a user on a particular computing environment or platform.
        """
        pulumi.set(__self__, "access_id", access_id)
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="accessId")
    def access_id(self) -> pulumi.Input[_builtins.str]:
        """
        Access keys are important credentials for authentication.
        """
        return pulumi.get(self, "access_id")

    @access_id.setter
    def access_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_id", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        A Secret Key is a Secret credential paired with an access Key to verify a user's identity and protect the security of an interface.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        An Endpoint is a network address for accessing a service or API, usually a URL to a specific service instance.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[_builtins.str]:
        """
        A Workspace generally refers to a separate space created by a user on a particular computing environment or platform.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_id", value)


