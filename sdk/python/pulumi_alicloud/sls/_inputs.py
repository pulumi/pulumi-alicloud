# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlertConfigurationArgs',
    'AlertConfigurationArgsDict',
    'AlertConfigurationAnnotationArgs',
    'AlertConfigurationAnnotationArgsDict',
    'AlertConfigurationConditionConfigurationArgs',
    'AlertConfigurationConditionConfigurationArgsDict',
    'AlertConfigurationGroupConfigurationArgs',
    'AlertConfigurationGroupConfigurationArgsDict',
    'AlertConfigurationJoinConfigurationArgs',
    'AlertConfigurationJoinConfigurationArgsDict',
    'AlertConfigurationLabelArgs',
    'AlertConfigurationLabelArgsDict',
    'AlertConfigurationPolicyConfigurationArgs',
    'AlertConfigurationPolicyConfigurationArgsDict',
    'AlertConfigurationQueryListArgs',
    'AlertConfigurationQueryListArgsDict',
    'AlertConfigurationSeverityConfigurationArgs',
    'AlertConfigurationSeverityConfigurationArgsDict',
    'AlertConfigurationSeverityConfigurationEvalConditionArgs',
    'AlertConfigurationSeverityConfigurationEvalConditionArgsDict',
    'AlertConfigurationSinkAlerthubArgs',
    'AlertConfigurationSinkAlerthubArgsDict',
    'AlertConfigurationSinkCmsArgs',
    'AlertConfigurationSinkCmsArgsDict',
    'AlertConfigurationSinkEventStoreArgs',
    'AlertConfigurationSinkEventStoreArgsDict',
    'AlertConfigurationTemplateConfigurationArgs',
    'AlertConfigurationTemplateConfigurationArgsDict',
    'AlertScheduleArgs',
    'AlertScheduleArgsDict',
    'CollectionPolicyCentralizeConfigArgs',
    'CollectionPolicyCentralizeConfigArgsDict',
    'CollectionPolicyDataConfigArgs',
    'CollectionPolicyDataConfigArgsDict',
    'CollectionPolicyPolicyConfigArgs',
    'CollectionPolicyPolicyConfigArgsDict',
    'CollectionPolicyResourceDirectoryArgs',
    'CollectionPolicyResourceDirectoryArgsDict',
    'EtlConfigurationArgs',
    'EtlConfigurationArgsDict',
    'EtlConfigurationSinkArgs',
    'EtlConfigurationSinkArgsDict',
    'IndexLineArgs',
    'IndexLineArgsDict',
    'LogtailConfigOutputDetailArgs',
    'LogtailConfigOutputDetailArgsDict',
    'MachineGroupGroupAttributeArgs',
    'MachineGroupGroupAttributeArgsDict',
    'OssExportSinkConfigurationArgs',
    'OssExportSinkConfigurationArgsDict',
    'OssExportSinkConfigurationSinkArgs',
    'OssExportSinkConfigurationSinkArgsDict',
    'ScheduledSqlScheduleArgs',
    'ScheduledSqlScheduleArgsDict',
    'ScheduledSqlScheduledSqlConfigurationArgs',
    'ScheduledSqlScheduledSqlConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AlertConfigurationArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationAnnotationArgsDict']]]]
        """
        Template Annotations.
        """
        auto_annotation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to turn on automatic labeling. true (default): The automatic annotation function is enabled, and the system automatically adds information such as__county__to the alarm. For more information, see Automatic Labeling. false: Turn off the automatic annotation function.
        """
        condition_configuration: NotRequired[pulumi.Input['AlertConfigurationConditionConfigurationArgsDict']]
        """
        Alarm trigger condition. See `condition_configuration` below.
        """
        dashboard: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instrument cluster associated with the alarm. It is recommended to set to internal-alert-analysis.
        """
        group_configuration: NotRequired[pulumi.Input['AlertConfigurationGroupConfigurationArgsDict']]
        """
        Group evaluation configuration. See `group_configuration` below.
        """
        join_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationJoinConfigurationArgsDict']]]]
        """
        Set operation configuration. See `join_configurations` below.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationLabelArgsDict']]]]
        """
        Label. See `labels` below.
        """
        mute_until: NotRequired[pulumi.Input[_builtins.int]]
        """
        Second-level timestamp representing the temporary shutdown deadline.
        """
        no_data_fire: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether no data triggers an alarm. true: If the number of times the query and analysis results (if there are multiple results, the result after the collection operation) is no data exceeds the continuous trigger threshold, an alarm is generated. false (default): Turn off the no data alarm function.
        """
        no_data_severity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm severity when no data triggers an alarm.
        """
        policy_configuration: NotRequired[pulumi.Input['AlertConfigurationPolicyConfigurationArgsDict']]
        """
        Alert policy configuration. See `policy_configuration` below.
        """
        query_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationQueryListArgsDict']]]]
        """
        Query the statistical list. See `query_list` below.
        """
        send_resolved: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send a recovery notification. true: A recovery alarm is triggered when the alarm is restored. false (default): Turn off the alarm recovery notification function.
        """
        severity_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationSeverityConfigurationArgsDict']]]]
        """
        Trigger condition, set at least one trigger condition. See `severity_configurations` below.
        """
        sink_alerthub: NotRequired[pulumi.Input['AlertConfigurationSinkAlerthubArgsDict']]
        """
        Configuration of Alerts Sent to Alerthub. See `sink_alerthub` below.
        """
        sink_cms: NotRequired[pulumi.Input['AlertConfigurationSinkCmsArgsDict']]
        """
        Configure alerts sent to CloudMonitor. See `sink_cms` below.
        """
        sink_event_store: NotRequired[pulumi.Input['AlertConfigurationSinkEventStoreArgsDict']]
        """
        Configuration of sending alarms to EventStore. See `sink_event_store` below.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Customize the category of alarm monitoring rules.
        """
        template_configuration: NotRequired[pulumi.Input['AlertConfigurationTemplateConfigurationArgsDict']]
        """
        Alarm rule template configuration. See `template_configuration` below.
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set the continuous trigger threshold. When the cumulative number of triggers reaches this value, an alarm is generated. The statistics are not counted when the trigger condition is not met.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Type.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Version.
        """
elif False:
    AlertConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationAnnotationArgs']]]] = None,
                 auto_annotation: Optional[pulumi.Input[_builtins.bool]] = None,
                 condition_configuration: Optional[pulumi.Input['AlertConfigurationConditionConfigurationArgs']] = None,
                 dashboard: Optional[pulumi.Input[_builtins.str]] = None,
                 group_configuration: Optional[pulumi.Input['AlertConfigurationGroupConfigurationArgs']] = None,
                 join_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationJoinConfigurationArgs']]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationLabelArgs']]]] = None,
                 mute_until: Optional[pulumi.Input[_builtins.int]] = None,
                 no_data_fire: Optional[pulumi.Input[_builtins.bool]] = None,
                 no_data_severity: Optional[pulumi.Input[_builtins.int]] = None,
                 policy_configuration: Optional[pulumi.Input['AlertConfigurationPolicyConfigurationArgs']] = None,
                 query_lists: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationQueryListArgs']]]] = None,
                 send_resolved: Optional[pulumi.Input[_builtins.bool]] = None,
                 severity_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationSeverityConfigurationArgs']]]] = None,
                 sink_alerthub: Optional[pulumi.Input['AlertConfigurationSinkAlerthubArgs']] = None,
                 sink_cms: Optional[pulumi.Input['AlertConfigurationSinkCmsArgs']] = None,
                 sink_event_store: Optional[pulumi.Input['AlertConfigurationSinkEventStoreArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 template_configuration: Optional[pulumi.Input['AlertConfigurationTemplateConfigurationArgs']] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlertConfigurationAnnotationArgs']]] annotations: Template Annotations.
        :param pulumi.Input[_builtins.bool] auto_annotation: Whether to turn on automatic labeling. true (default): The automatic annotation function is enabled, and the system automatically adds information such as__county__to the alarm. For more information, see Automatic Labeling. false: Turn off the automatic annotation function.
        :param pulumi.Input['AlertConfigurationConditionConfigurationArgs'] condition_configuration: Alarm trigger condition. See `condition_configuration` below.
        :param pulumi.Input[_builtins.str] dashboard: The instrument cluster associated with the alarm. It is recommended to set to internal-alert-analysis.
        :param pulumi.Input['AlertConfigurationGroupConfigurationArgs'] group_configuration: Group evaluation configuration. See `group_configuration` below.
        :param pulumi.Input[Sequence[pulumi.Input['AlertConfigurationJoinConfigurationArgs']]] join_configurations: Set operation configuration. See `join_configurations` below.
        :param pulumi.Input[Sequence[pulumi.Input['AlertConfigurationLabelArgs']]] labels: Label. See `labels` below.
        :param pulumi.Input[_builtins.int] mute_until: Second-level timestamp representing the temporary shutdown deadline.
        :param pulumi.Input[_builtins.bool] no_data_fire: Whether no data triggers an alarm. true: If the number of times the query and analysis results (if there are multiple results, the result after the collection operation) is no data exceeds the continuous trigger threshold, an alarm is generated. false (default): Turn off the no data alarm function.
        :param pulumi.Input[_builtins.int] no_data_severity: Alarm severity when no data triggers an alarm.
        :param pulumi.Input['AlertConfigurationPolicyConfigurationArgs'] policy_configuration: Alert policy configuration. See `policy_configuration` below.
        :param pulumi.Input[Sequence[pulumi.Input['AlertConfigurationQueryListArgs']]] query_lists: Query the statistical list. See `query_list` below.
        :param pulumi.Input[_builtins.bool] send_resolved: Whether to send a recovery notification. true: A recovery alarm is triggered when the alarm is restored. false (default): Turn off the alarm recovery notification function.
        :param pulumi.Input[Sequence[pulumi.Input['AlertConfigurationSeverityConfigurationArgs']]] severity_configurations: Trigger condition, set at least one trigger condition. See `severity_configurations` below.
        :param pulumi.Input['AlertConfigurationSinkAlerthubArgs'] sink_alerthub: Configuration of Alerts Sent to Alerthub. See `sink_alerthub` below.
        :param pulumi.Input['AlertConfigurationSinkCmsArgs'] sink_cms: Configure alerts sent to CloudMonitor. See `sink_cms` below.
        :param pulumi.Input['AlertConfigurationSinkEventStoreArgs'] sink_event_store: Configuration of sending alarms to EventStore. See `sink_event_store` below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Customize the category of alarm monitoring rules.
        :param pulumi.Input['AlertConfigurationTemplateConfigurationArgs'] template_configuration: Alarm rule template configuration. See `template_configuration` below.
        :param pulumi.Input[_builtins.int] threshold: Set the continuous trigger threshold. When the cumulative number of triggers reaches this value, an alarm is generated. The statistics are not counted when the trigger condition is not met.
        :param pulumi.Input[_builtins.str] type: Template Type.
        :param pulumi.Input[_builtins.str] version: Template Version.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auto_annotation is not None:
            pulumi.set(__self__, "auto_annotation", auto_annotation)
        if condition_configuration is not None:
            pulumi.set(__self__, "condition_configuration", condition_configuration)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if group_configuration is not None:
            pulumi.set(__self__, "group_configuration", group_configuration)
        if join_configurations is not None:
            pulumi.set(__self__, "join_configurations", join_configurations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mute_until is not None:
            pulumi.set(__self__, "mute_until", mute_until)
        if no_data_fire is not None:
            pulumi.set(__self__, "no_data_fire", no_data_fire)
        if no_data_severity is not None:
            pulumi.set(__self__, "no_data_severity", no_data_severity)
        if policy_configuration is not None:
            pulumi.set(__self__, "policy_configuration", policy_configuration)
        if query_lists is not None:
            pulumi.set(__self__, "query_lists", query_lists)
        if send_resolved is not None:
            pulumi.set(__self__, "send_resolved", send_resolved)
        if severity_configurations is not None:
            pulumi.set(__self__, "severity_configurations", severity_configurations)
        if sink_alerthub is not None:
            pulumi.set(__self__, "sink_alerthub", sink_alerthub)
        if sink_cms is not None:
            pulumi.set(__self__, "sink_cms", sink_cms)
        if sink_event_store is not None:
            pulumi.set(__self__, "sink_event_store", sink_event_store)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template_configuration is not None:
            pulumi.set(__self__, "template_configuration", template_configuration)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationAnnotationArgs']]]]:
        """
        Template Annotations.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationAnnotationArgs']]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter(name="autoAnnotation")
    def auto_annotation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to turn on automatic labeling. true (default): The automatic annotation function is enabled, and the system automatically adds information such as__county__to the alarm. For more information, see Automatic Labeling. false: Turn off the automatic annotation function.
        """
        return pulumi.get(self, "auto_annotation")

    @auto_annotation.setter
    def auto_annotation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_annotation", value)

    @_builtins.property
    @pulumi.getter(name="conditionConfiguration")
    def condition_configuration(self) -> Optional[pulumi.Input['AlertConfigurationConditionConfigurationArgs']]:
        """
        Alarm trigger condition. See `condition_configuration` below.
        """
        return pulumi.get(self, "condition_configuration")

    @condition_configuration.setter
    def condition_configuration(self, value: Optional[pulumi.Input['AlertConfigurationConditionConfigurationArgs']]):
        pulumi.set(self, "condition_configuration", value)

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instrument cluster associated with the alarm. It is recommended to set to internal-alert-analysis.
        """
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dashboard", value)

    @_builtins.property
    @pulumi.getter(name="groupConfiguration")
    def group_configuration(self) -> Optional[pulumi.Input['AlertConfigurationGroupConfigurationArgs']]:
        """
        Group evaluation configuration. See `group_configuration` below.
        """
        return pulumi.get(self, "group_configuration")

    @group_configuration.setter
    def group_configuration(self, value: Optional[pulumi.Input['AlertConfigurationGroupConfigurationArgs']]):
        pulumi.set(self, "group_configuration", value)

    @_builtins.property
    @pulumi.getter(name="joinConfigurations")
    def join_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationJoinConfigurationArgs']]]]:
        """
        Set operation configuration. See `join_configurations` below.
        """
        return pulumi.get(self, "join_configurations")

    @join_configurations.setter
    def join_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationJoinConfigurationArgs']]]]):
        pulumi.set(self, "join_configurations", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationLabelArgs']]]]:
        """
        Label. See `labels` below.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="muteUntil")
    def mute_until(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Second-level timestamp representing the temporary shutdown deadline.
        """
        return pulumi.get(self, "mute_until")

    @mute_until.setter
    def mute_until(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mute_until", value)

    @_builtins.property
    @pulumi.getter(name="noDataFire")
    def no_data_fire(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether no data triggers an alarm. true: If the number of times the query and analysis results (if there are multiple results, the result after the collection operation) is no data exceeds the continuous trigger threshold, an alarm is generated. false (default): Turn off the no data alarm function.
        """
        return pulumi.get(self, "no_data_fire")

    @no_data_fire.setter
    def no_data_fire(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_data_fire", value)

    @_builtins.property
    @pulumi.getter(name="noDataSeverity")
    def no_data_severity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm severity when no data triggers an alarm.
        """
        return pulumi.get(self, "no_data_severity")

    @no_data_severity.setter
    def no_data_severity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "no_data_severity", value)

    @_builtins.property
    @pulumi.getter(name="policyConfiguration")
    def policy_configuration(self) -> Optional[pulumi.Input['AlertConfigurationPolicyConfigurationArgs']]:
        """
        Alert policy configuration. See `policy_configuration` below.
        """
        return pulumi.get(self, "policy_configuration")

    @policy_configuration.setter
    def policy_configuration(self, value: Optional[pulumi.Input['AlertConfigurationPolicyConfigurationArgs']]):
        pulumi.set(self, "policy_configuration", value)

    @_builtins.property
    @pulumi.getter(name="queryLists")
    def query_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationQueryListArgs']]]]:
        """
        Query the statistical list. See `query_list` below.
        """
        return pulumi.get(self, "query_lists")

    @query_lists.setter
    def query_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationQueryListArgs']]]]):
        pulumi.set(self, "query_lists", value)

    @_builtins.property
    @pulumi.getter(name="sendResolved")
    def send_resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send a recovery notification. true: A recovery alarm is triggered when the alarm is restored. false (default): Turn off the alarm recovery notification function.
        """
        return pulumi.get(self, "send_resolved")

    @send_resolved.setter
    def send_resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_resolved", value)

    @_builtins.property
    @pulumi.getter(name="severityConfigurations")
    def severity_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationSeverityConfigurationArgs']]]]:
        """
        Trigger condition, set at least one trigger condition. See `severity_configurations` below.
        """
        return pulumi.get(self, "severity_configurations")

    @severity_configurations.setter
    def severity_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertConfigurationSeverityConfigurationArgs']]]]):
        pulumi.set(self, "severity_configurations", value)

    @_builtins.property
    @pulumi.getter(name="sinkAlerthub")
    def sink_alerthub(self) -> Optional[pulumi.Input['AlertConfigurationSinkAlerthubArgs']]:
        """
        Configuration of Alerts Sent to Alerthub. See `sink_alerthub` below.
        """
        return pulumi.get(self, "sink_alerthub")

    @sink_alerthub.setter
    def sink_alerthub(self, value: Optional[pulumi.Input['AlertConfigurationSinkAlerthubArgs']]):
        pulumi.set(self, "sink_alerthub", value)

    @_builtins.property
    @pulumi.getter(name="sinkCms")
    def sink_cms(self) -> Optional[pulumi.Input['AlertConfigurationSinkCmsArgs']]:
        """
        Configure alerts sent to CloudMonitor. See `sink_cms` below.
        """
        return pulumi.get(self, "sink_cms")

    @sink_cms.setter
    def sink_cms(self, value: Optional[pulumi.Input['AlertConfigurationSinkCmsArgs']]):
        pulumi.set(self, "sink_cms", value)

    @_builtins.property
    @pulumi.getter(name="sinkEventStore")
    def sink_event_store(self) -> Optional[pulumi.Input['AlertConfigurationSinkEventStoreArgs']]:
        """
        Configuration of sending alarms to EventStore. See `sink_event_store` below.
        """
        return pulumi.get(self, "sink_event_store")

    @sink_event_store.setter
    def sink_event_store(self, value: Optional[pulumi.Input['AlertConfigurationSinkEventStoreArgs']]):
        pulumi.set(self, "sink_event_store", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Customize the category of alarm monitoring rules.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Optional[pulumi.Input['AlertConfigurationTemplateConfigurationArgs']]:
        """
        Alarm rule template configuration. See `template_configuration` below.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: Optional[pulumi.Input['AlertConfigurationTemplateConfigurationArgs']]):
        pulumi.set(self, "template_configuration", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set the continuous trigger threshold. When the cumulative number of triggers reaches this value, an alarm is generated. The statistics are not counted when the trigger condition is not met.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AlertConfigurationAnnotationArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field value.
        """
elif False:
    AlertConfigurationAnnotationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationAnnotationArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Field name.
        :param pulumi.Input[_builtins.str] value: Field value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertConfigurationConditionConfigurationArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        count_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of pieces of data to determine the number of pieces of data to indicate how many pieces of data meet the conditions. If data exists, it is satisfied. Set it to an empty string. In other cases, it needs to be set as an expression, such as__count__> 3.
        """
elif False:
    AlertConfigurationConditionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationConditionConfigurationArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 count_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition: Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        :param pulumi.Input[_builtins.str] count_condition: The number of pieces of data to determine the number of pieces of data to indicate how many pieces of data meet the conditions. If data exists, it is satisfied. Set it to an empty string. In other cases, it needs to be set as an expression, such as__count__> 3.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if count_condition is not None:
            pulumi.set(__self__, "count_condition", count_condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="countCondition")
    def count_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of pieces of data to determine the number of pieces of data to indicate how many pieces of data meet the conditions. If data exists, it is satisfied. Set it to an empty string. In other cases, it needs to be set as an expression, such as__count__> 3.
        """
        return pulumi.get(self, "count_condition")

    @count_condition.setter
    def count_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "count_condition", value)


if not MYPY:
    class AlertConfigurationGroupConfigurationArgsDict(TypedDict):
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The field used for grouping evaluation. When type is set to custom, fields must be set.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AlertConfigurationGroupConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationGroupConfigurationArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] fields: The field used for grouping evaluation. When type is set to custom, fields must be set.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The field used for grouping evaluation. When type is set to custom, fields must be set.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "fields", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlertConfigurationJoinConfigurationArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AlertConfigurationJoinConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationJoinConfigurationArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition: Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlertConfigurationLabelArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field value.
        """
elif False:
    AlertConfigurationLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Field name.
        :param pulumi.Input[_builtins.str] value: Field value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertConfigurationPolicyConfigurationArgsDict(TypedDict):
        action_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the action policy used. If the alert policy is in advanced mode and the selected alert policy is not configured with a dynamic action policy, set the actionPolicyId to an empty string.
        """
        alert_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alarm policy ID. If it is in simple mode or normal mode, set it to sls.builtin.dynamic (dynamic alarm policy built into the system). For advanced mode, set it to the specified alarm policy ID.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Repeat the waiting time. For example, 5m, 1H, etc.
        """
elif False:
    AlertConfigurationPolicyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationPolicyConfigurationArgs:
    def __init__(__self__, *,
                 action_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 alert_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action_policy_id: The ID of the action policy used. If the alert policy is in advanced mode and the selected alert policy is not configured with a dynamic action policy, set the actionPolicyId to an empty string.
        :param pulumi.Input[_builtins.str] alert_policy_id: Alarm policy ID. If it is in simple mode or normal mode, set it to sls.builtin.dynamic (dynamic alarm policy built into the system). For advanced mode, set it to the specified alarm policy ID.
        :param pulumi.Input[_builtins.str] repeat_interval: Repeat the waiting time. For example, 5m, 1H, etc.
        """
        if action_policy_id is not None:
            pulumi.set(__self__, "action_policy_id", action_policy_id)
        if alert_policy_id is not None:
            pulumi.set(__self__, "alert_policy_id", alert_policy_id)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)

    @_builtins.property
    @pulumi.getter(name="actionPolicyId")
    def action_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the action policy used. If the alert policy is in advanced mode and the selected alert policy is not configured with a dynamic action policy, set the actionPolicyId to an empty string.
        """
        return pulumi.get(self, "action_policy_id")

    @action_policy_id.setter
    def action_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="alertPolicyId")
    def alert_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alarm policy ID. If it is in simple mode or normal mode, set it to sls.builtin.dynamic (dynamic alarm policy built into the system). For advanced mode, set it to the specified alarm policy ID.
        """
        return pulumi.get(self, "alert_policy_id")

    @alert_policy_id.setter
    def alert_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alert_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Repeat the waiting time. For example, 5m, 1H, etc.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)


if not MYPY:
    class AlertConfigurationQueryListArgsDict(TypedDict):
        chart_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Chart Name.
        """
        dashboard_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dashboard ID.
        """
        end: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time. When storeType is set to log or metric, end must be set.
        """
        power_sql_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to use exclusive SQL. The value is as follows: auto: automatic switching. enable: Starts. disable: disable.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Name.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        Query and analysis statements. When storeType is set to log or metric, query is set to the query analysis statement. When storeType is set to meta, set query to an empty string.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region of the target Project.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Roles used to write alarm data to the event Library.
        """
        start: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time. When storeType is set to log or metric, start must be set.
        """
        store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Query the Logstore, Metricstore, or resource data associated with the statistics. When storeType is set to log, store is set to the target Logstore. When storeType is set to metric, store is set to the target Metricstore. When storeType is set to meta, store is set to the target resource data name.
        """
        store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Query the data source type. The value is as follows: log: Logstore. metric: Time series Library. meta: resource data.
        """
        time_span_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time Type.
        """
        ui: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use of specific scene alarm front end.
        """
elif False:
    AlertConfigurationQueryListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationQueryListArgs:
    def __init__(__self__, *,
                 chart_title: Optional[pulumi.Input[_builtins.str]] = None,
                 dashboard_id: Optional[pulumi.Input[_builtins.str]] = None,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 power_sql_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None,
                 store: Optional[pulumi.Input[_builtins.str]] = None,
                 store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 time_span_type: Optional[pulumi.Input[_builtins.str]] = None,
                 ui: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] chart_title: Chart Name.
        :param pulumi.Input[_builtins.str] dashboard_id: Dashboard ID.
        :param pulumi.Input[_builtins.str] end: End time. When storeType is set to log or metric, end must be set.
        :param pulumi.Input[_builtins.str] power_sql_mode: Whether to use exclusive SQL. The value is as follows: auto: automatic switching. enable: Starts. disable: disable.
        :param pulumi.Input[_builtins.str] project: Project Name.
        :param pulumi.Input[_builtins.str] query: Query and analysis statements. When storeType is set to log or metric, query is set to the query analysis statement. When storeType is set to meta, set query to an empty string.
        :param pulumi.Input[_builtins.str] region: Region of the target Project.
        :param pulumi.Input[_builtins.str] role_arn: Roles used to write alarm data to the event Library.
        :param pulumi.Input[_builtins.str] start: Start time. When storeType is set to log or metric, start must be set.
        :param pulumi.Input[_builtins.str] store: Query the Logstore, Metricstore, or resource data associated with the statistics. When storeType is set to log, store is set to the target Logstore. When storeType is set to metric, store is set to the target Metricstore. When storeType is set to meta, store is set to the target resource data name.
        :param pulumi.Input[_builtins.str] store_type: Query the data source type. The value is as follows: log: Logstore. metric: Time series Library. meta: resource data.
        :param pulumi.Input[_builtins.str] time_span_type: Time Type.
        :param pulumi.Input[_builtins.str] ui: Use of specific scene alarm front end.
        """
        if chart_title is not None:
            pulumi.set(__self__, "chart_title", chart_title)
        if dashboard_id is not None:
            pulumi.set(__self__, "dashboard_id", dashboard_id)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if power_sql_mode is not None:
            pulumi.set(__self__, "power_sql_mode", power_sql_mode)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if store is not None:
            pulumi.set(__self__, "store", store)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)
        if time_span_type is not None:
            pulumi.set(__self__, "time_span_type", time_span_type)
        if ui is not None:
            pulumi.set(__self__, "ui", ui)

    @_builtins.property
    @pulumi.getter(name="chartTitle")
    def chart_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Chart Name.
        """
        return pulumi.get(self, "chart_title")

    @chart_title.setter
    def chart_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "chart_title", value)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dashboard ID.
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dashboard_id", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time. When storeType is set to log or metric, end must be set.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="powerSqlMode")
    def power_sql_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to use exclusive SQL. The value is as follows: auto: automatic switching. enable: Starts. disable: disable.
        """
        return pulumi.get(self, "power_sql_mode")

    @power_sql_mode.setter
    def power_sql_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "power_sql_mode", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Name.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Query and analysis statements. When storeType is set to log or metric, query is set to the query analysis statement. When storeType is set to meta, set query to an empty string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region of the target Project.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Roles used to write alarm data to the event Library.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time. When storeType is set to log or metric, start must be set.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)

    @_builtins.property
    @pulumi.getter
    def store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Query the Logstore, Metricstore, or resource data associated with the statistics. When storeType is set to log, store is set to the target Logstore. When storeType is set to metric, store is set to the target Metricstore. When storeType is set to meta, store is set to the target resource data name.
        """
        return pulumi.get(self, "store")

    @store.setter
    def store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store", value)

    @_builtins.property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Query the data source type. The value is as follows: log: Logstore. metric: Time series Library. meta: resource data.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_type", value)

    @_builtins.property
    @pulumi.getter(name="timeSpanType")
    def time_span_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time Type.
        """
        return pulumi.get(self, "time_span_type")

    @time_span_type.setter
    def time_span_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_span_type", value)

    @_builtins.property
    @pulumi.getter
    def ui(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use of specific scene alarm front end.
        """
        return pulumi.get(self, "ui")

    @ui.setter
    def ui(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ui", value)


if not MYPY:
    class AlertConfigurationSeverityConfigurationArgsDict(TypedDict):
        eval_condition: NotRequired[pulumi.Input['AlertConfigurationSeverityConfigurationEvalConditionArgsDict']]
        """
        Trigger condition. See `eval_condition` below.
        """
        severity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alarm severity.
        """
elif False:
    AlertConfigurationSeverityConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationSeverityConfigurationArgs:
    def __init__(__self__, *,
                 eval_condition: Optional[pulumi.Input['AlertConfigurationSeverityConfigurationEvalConditionArgs']] = None,
                 severity: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['AlertConfigurationSeverityConfigurationEvalConditionArgs'] eval_condition: Trigger condition. See `eval_condition` below.
        :param pulumi.Input[_builtins.int] severity: Alarm severity.
        """
        if eval_condition is not None:
            pulumi.set(__self__, "eval_condition", eval_condition)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter(name="evalCondition")
    def eval_condition(self) -> Optional[pulumi.Input['AlertConfigurationSeverityConfigurationEvalConditionArgs']]:
        """
        Trigger condition. See `eval_condition` below.
        """
        return pulumi.get(self, "eval_condition")

    @eval_condition.setter
    def eval_condition(self, value: Optional[pulumi.Input['AlertConfigurationSeverityConfigurationEvalConditionArgs']]):
        pulumi.set(self, "eval_condition", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alarm severity.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class AlertConfigurationSeverityConfigurationEvalConditionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        count_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of pieces of data to determine the number of pieces of data to indicate how many pieces of data meet the conditions. If data exists, it is satisfied. Set it to an empty string. In other cases, it needs to be set as an expression, such as__count__> 3.
        """
elif False:
    AlertConfigurationSeverityConfigurationEvalConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationSeverityConfigurationEvalConditionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 count_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition: Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        :param pulumi.Input[_builtins.str] count_condition: The number of pieces of data to determine the number of pieces of data to indicate how many pieces of data meet the conditions. If data exists, it is satisfied. Set it to an empty string. In other cases, it needs to be set as an expression, such as__count__> 3.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if count_condition is not None:
            pulumi.set(__self__, "count_condition", count_condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data matching expression. When the data content does not need to be determined, set it to an empty string. In other cases, it needs to be set as an expression, for example, errCnt> 10.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="countCondition")
    def count_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of pieces of data to determine the number of pieces of data to indicate how many pieces of data meet the conditions. If data exists, it is satisfied. Set it to an empty string. In other cases, it needs to be set as an expression, such as__count__> 3.
        """
        return pulumi.get(self, "count_condition")

    @count_condition.setter
    def count_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "count_condition", value)


if not MYPY:
    class AlertConfigurationSinkAlerthubArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Open.
        """
elif False:
    AlertConfigurationSinkAlerthubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationSinkAlerthubArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Open.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Open.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AlertConfigurationSinkCmsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Open.
        """
elif False:
    AlertConfigurationSinkCmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationSinkCmsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Open.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Open.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AlertConfigurationSinkEventStoreArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Open.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        SLS service endpoint.
        """
        event_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Event Library Name.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project Name.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Roles used to write alarm data to the event Library.
        """
elif False:
    AlertConfigurationSinkEventStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationSinkEventStoreArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 event_store: Optional[pulumi.Input[_builtins.str]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Open.
        :param pulumi.Input[_builtins.str] endpoint: SLS service endpoint.
        :param pulumi.Input[_builtins.str] event_store: Event Library Name.
        :param pulumi.Input[_builtins.str] project: Project Name.
        :param pulumi.Input[_builtins.str] role_arn: Roles used to write alarm data to the event Library.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if event_store is not None:
            pulumi.set(__self__, "event_store", event_store)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Open.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SLS service endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="eventStore")
    def event_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Event Library Name.
        """
        return pulumi.get(self, "event_store")

    @event_store.setter
    def event_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_store", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project Name.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Roles used to write alarm data to the event Library.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class AlertConfigurationTemplateConfigurationArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Template Annotations.
        """
        lang: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Language.
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template ID.
        """
        tokens: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Template Variables.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Template Version.
        """
elif False:
    AlertConfigurationTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationTemplateConfigurationArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 lang: Optional[pulumi.Input[_builtins.str]] = None,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tokens: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Template Annotations.
        :param pulumi.Input[_builtins.str] lang: Template Language.
        :param pulumi.Input[_builtins.str] template_id: Template ID.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tokens: Template Variables.
        :param pulumi.Input[_builtins.str] version: Template Version.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Template Annotations.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Language.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lang", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template ID.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Template Variables.
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Template Version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AlertScheduleArgsDict(TypedDict):
        cron_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cron expression, the minimum accuracy is minutes, 24 hours. For example, 0 0/1 * * * means that the check is conducted every 1 hour from 00:00. When type is set to Cron, cronExpression must be set.
        """
        delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timed task execution delay (unit: s).
        """
        interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fixed interval for scheduling.
        """
        run_immdiately: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Dispatch immediately.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone where the Cron expression is located. The default value is null, indicating the eighth zone in the east.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Check the frequency type. Log Service checks the query and analysis results according to the frequency you configured. The values are as follows: Fixedate: checks query and analysis results at regular intervals. Cron: specifies the time interval by using the Cron expression, and checks the query and analysis results at the specified time interval.
        """
elif False:
    AlertScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertScheduleArgs:
    def __init__(__self__, *,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 delay: Optional[pulumi.Input[_builtins.int]] = None,
                 interval: Optional[pulumi.Input[_builtins.str]] = None,
                 run_immdiately: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cron_expression: Cron expression, the minimum accuracy is minutes, 24 hours. For example, 0 0/1 * * * means that the check is conducted every 1 hour from 00:00. When type is set to Cron, cronExpression must be set.
        :param pulumi.Input[_builtins.int] delay: Timed task execution delay (unit: s).
        :param pulumi.Input[_builtins.str] interval: Fixed interval for scheduling.
        :param pulumi.Input[_builtins.bool] run_immdiately: Dispatch immediately.
        :param pulumi.Input[_builtins.str] time_zone: The time zone where the Cron expression is located. The default value is null, indicating the eighth zone in the east.
        :param pulumi.Input[_builtins.str] type: Check the frequency type. Log Service checks the query and analysis results according to the frequency you configured. The values are as follows: Fixedate: checks query and analysis results at regular intervals. Cron: specifies the time interval by using the Cron expression, and checks the query and analysis results at the specified time interval.
        """
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if run_immdiately is not None:
            pulumi.set(__self__, "run_immdiately", run_immdiately)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cron expression, the minimum accuracy is minutes, 24 hours. For example, 0 0/1 * * * means that the check is conducted every 1 hour from 00:00. When type is set to Cron, cronExpression must be set.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timed task execution delay (unit: s).
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fixed interval for scheduling.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="runImmdiately")
    def run_immdiately(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Dispatch immediately.
        """
        return pulumi.get(self, "run_immdiately")

    @run_immdiately.setter
    def run_immdiately(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_immdiately", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone where the Cron expression is located. The default value is null, indicating the eighth zone in the east.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Check the frequency type. Log Service checks the query and analysis results according to the frequency you configured. The values are as follows: Fixedate: checks query and analysis results at regular intervals. Cron: specifies the time interval by using the Cron expression, and checks the query and analysis results at the specified time interval.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CollectionPolicyCentralizeConfigArgsDict(TypedDict):
        dest_logstore: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the central logstore is transferred to the destination logstore, its geographical attribute should be consistent with the destRegion and belong to the destProject.
        """
        dest_project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The geographical attributes of the centralized transfer project should be consistent with the destRegion.
        """
        dest_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Centralized transfer destination area.
        """
        dest_ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of days for the central transfer destination. This is valid only if the central transfer destination log store is not created for the first time.
        """
elif False:
    CollectionPolicyCentralizeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollectionPolicyCentralizeConfigArgs:
    def __init__(__self__, *,
                 dest_logstore: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_project: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_region: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_ttl: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_logstore: When the central logstore is transferred to the destination logstore, its geographical attribute should be consistent with the destRegion and belong to the destProject.
        :param pulumi.Input[_builtins.str] dest_project: The geographical attributes of the centralized transfer project should be consistent with the destRegion.
        :param pulumi.Input[_builtins.str] dest_region: Centralized transfer destination area.
        :param pulumi.Input[_builtins.int] dest_ttl: The number of days for the central transfer destination. This is valid only if the central transfer destination log store is not created for the first time.
        """
        if dest_logstore is not None:
            pulumi.set(__self__, "dest_logstore", dest_logstore)
        if dest_project is not None:
            pulumi.set(__self__, "dest_project", dest_project)
        if dest_region is not None:
            pulumi.set(__self__, "dest_region", dest_region)
        if dest_ttl is not None:
            pulumi.set(__self__, "dest_ttl", dest_ttl)

    @_builtins.property
    @pulumi.getter(name="destLogstore")
    def dest_logstore(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the central logstore is transferred to the destination logstore, its geographical attribute should be consistent with the destRegion and belong to the destProject.
        """
        return pulumi.get(self, "dest_logstore")

    @dest_logstore.setter
    def dest_logstore(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_logstore", value)

    @_builtins.property
    @pulumi.getter(name="destProject")
    def dest_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The geographical attributes of the centralized transfer project should be consistent with the destRegion.
        """
        return pulumi.get(self, "dest_project")

    @dest_project.setter
    def dest_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_project", value)

    @_builtins.property
    @pulumi.getter(name="destRegion")
    def dest_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Centralized transfer destination area.
        """
        return pulumi.get(self, "dest_region")

    @dest_region.setter
    def dest_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_region", value)

    @_builtins.property
    @pulumi.getter(name="destTtl")
    def dest_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of days for the central transfer destination. This is valid only if the central transfer destination log store is not created for the first time.
        """
        return pulumi.get(self, "dest_ttl")

    @dest_ttl.setter
    def dest_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dest_ttl", value)


if not MYPY:
    class CollectionPolicyDataConfigArgsDict(TypedDict):
        data_project: NotRequired[pulumi.Input[_builtins.str]]
        """
        Valid only when the log type is global. For example, if the productCode is sls, the log is collected to the default dedicated Project of the account in a specific dataRegion.
        """
        data_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        If and only if the log type is global log type, for example, if productCode is sls, global logs will be collected to the corresponding region during the first configuration.
        """
elif False:
    CollectionPolicyDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollectionPolicyDataConfigArgs:
    def __init__(__self__, *,
                 data_project: Optional[pulumi.Input[_builtins.str]] = None,
                 data_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_project: Valid only when the log type is global. For example, if the productCode is sls, the log is collected to the default dedicated Project of the account in a specific dataRegion.
        :param pulumi.Input[_builtins.str] data_region: If and only if the log type is global log type, for example, if productCode is sls, global logs will be collected to the corresponding region during the first configuration.
        """
        if data_project is not None:
            pulumi.set(__self__, "data_project", data_project)
        if data_region is not None:
            pulumi.set(__self__, "data_region", data_region)

    @_builtins.property
    @pulumi.getter(name="dataProject")
    def data_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Valid only when the log type is global. For example, if the productCode is sls, the log is collected to the default dedicated Project of the account in a specific dataRegion.
        """
        return pulumi.get(self, "data_project")

    @data_project.setter
    def data_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_project", value)

    @_builtins.property
    @pulumi.getter(name="dataRegion")
    def data_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If and only if the log type is global log type, for example, if productCode is sls, global logs will be collected to the corresponding region during the first configuration.
        """
        return pulumi.get(self, "data_region")

    @data_region.setter
    def data_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_region", value)


if not MYPY:
    class CollectionPolicyPolicyConfigArgsDict(TypedDict):
        resource_mode: pulumi.Input[_builtins.str]
        """
        Resource collection mode. If all is configured, all instances under the account will be collected to the default logstore. If attributeMode is configured, filtering will be performed according to the region attribute and resource label of the instance. If instanceMode is configured, filtering will be performed according to the instance ID.
        """
        instance_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of instance IDs, valid only if resourceMode is instanceMode. Only instances whose instance ID is in the instance ID collection are collected.
        """
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The region collection to which the instance belongs. Valid only when resourceMode is set to attributeMode. Wildcard characters are supported. If the region collection filter item is an empty array, it means that you do not need to filter by region, and all instances meet the filtering condition of the region collection. Otherwise, only instances with region attributes in the region collection are collected. The region collection and resource label of the instance. The instance objects are collected only when all of them are met.
        """
        resource_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Resource label, valid if and only if resourceMode is attributeMode.

        If the resource label filter item is empty, it means that you do not need to filter by resource label, and all instances meet the resource label filter condition. Otherwise, only instances whose resource label attributes meet the resource label configuration are collected.

        The resource tag and the region collection to which the instance belongs work together. The instance objects are collected only when all of them are met.
        """
elif False:
    CollectionPolicyPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollectionPolicyPolicyConfigArgs:
    def __init__(__self__, *,
                 resource_mode: pulumi.Input[_builtins.str],
                 instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resource_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_mode: Resource collection mode. If all is configured, all instances under the account will be collected to the default logstore. If attributeMode is configured, filtering will be performed according to the region attribute and resource label of the instance. If instanceMode is configured, filtering will be performed according to the instance ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] instance_ids: A collection of instance IDs, valid only if resourceMode is instanceMode. Only instances whose instance ID is in the instance ID collection are collected.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regions: The region collection to which the instance belongs. Valid only when resourceMode is set to attributeMode. Wildcard characters are supported. If the region collection filter item is an empty array, it means that you do not need to filter by region, and all instances meet the filtering condition of the region collection. Otherwise, only instances with region attributes in the region collection are collected. The region collection and resource label of the instance. The instance objects are collected only when all of them are met.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] resource_tags: Resource label, valid if and only if resourceMode is attributeMode.
               
               If the resource label filter item is empty, it means that you do not need to filter by resource label, and all instances meet the resource label filter condition. Otherwise, only instances whose resource label attributes meet the resource label configuration are collected.
               
               The resource tag and the region collection to which the instance belongs work together. The instance objects are collected only when all of them are met.
        """
        pulumi.set(__self__, "resource_mode", resource_mode)
        if instance_ids is not None:
            pulumi.set(__self__, "instance_ids", instance_ids)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)

    @_builtins.property
    @pulumi.getter(name="resourceMode")
    def resource_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Resource collection mode. If all is configured, all instances under the account will be collected to the default logstore. If attributeMode is configured, filtering will be performed according to the region attribute and resource label of the instance. If instanceMode is configured, filtering will be performed according to the instance ID.
        """
        return pulumi.get(self, "resource_mode")

    @resource_mode.setter
    def resource_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_mode", value)

    @_builtins.property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of instance IDs, valid only if resourceMode is instanceMode. Only instances whose instance ID is in the instance ID collection are collected.
        """
        return pulumi.get(self, "instance_ids")

    @instance_ids.setter
    def instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "instance_ids", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The region collection to which the instance belongs. Valid only when resourceMode is set to attributeMode. Wildcard characters are supported. If the region collection filter item is an empty array, it means that you do not need to filter by region, and all instances meet the filtering condition of the region collection. Otherwise, only instances with region attributes in the region collection are collected. The region collection and resource label of the instance. The instance objects are collected only when all of them are met.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Resource label, valid if and only if resourceMode is attributeMode.

        If the resource label filter item is empty, it means that you do not need to filter by resource label, and all instances meet the resource label filter condition. Otherwise, only instances whose resource label attributes meet the resource label configuration are collected.

        The resource tag and the region collection to which the instance belongs work together. The instance objects are collected only when all of them are met.
        """
        return pulumi.get(self, "resource_tags")

    @resource_tags.setter
    def resource_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resource_tags", value)


if not MYPY:
    class CollectionPolicyResourceDirectoryArgsDict(TypedDict):
        account_group_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Support all mode all and custom mode custom under this resource directory
        """
        members: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        When the resource directory is configured in the custom mode, the corresponding member account list
        """
elif False:
    CollectionPolicyResourceDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollectionPolicyResourceDirectoryArgs:
    def __init__(__self__, *,
                 account_group_type: Optional[pulumi.Input[_builtins.str]] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] account_group_type: Support all mode all and custom mode custom under this resource directory
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] members: When the resource directory is configured in the custom mode, the corresponding member account list
        """
        if account_group_type is not None:
            pulumi.set(__self__, "account_group_type", account_group_type)
        if members is not None:
            pulumi.set(__self__, "members", members)

    @_builtins.property
    @pulumi.getter(name="accountGroupType")
    def account_group_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Support all mode all and custom mode custom under this resource directory
        """
        return pulumi.get(self, "account_group_type")

    @account_group_type.setter
    def account_group_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_group_type", value)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        When the resource directory is configured in the custom mode, the corresponding member account list
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "members", value)


if not MYPY:
    class EtlConfigurationArgsDict(TypedDict):
        from_time: pulumi.Input[_builtins.int]
        """
        The beginning of the time range for transformation.
        """
        lang: pulumi.Input[_builtins.str]
        """
        Data processing syntax type.
        """
        logstore: pulumi.Input[_builtins.str]
        """
        Destination Logstore Name.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN role that authorizes writing to the target Logstore.
        """
        script: pulumi.Input[_builtins.str]
        """
        Processing script.
        """
        sinks: pulumi.Input[Sequence[pulumi.Input['EtlConfigurationSinkArgsDict']]]
        """
        Processing result output target list See `sink` below.
        """
        to_time: pulumi.Input[_builtins.int]
        """
        The end of the time range for transformation.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Advanced parameter configuration.
        """
elif False:
    EtlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EtlConfigurationArgs:
    def __init__(__self__, *,
                 from_time: pulumi.Input[_builtins.int],
                 lang: pulumi.Input[_builtins.str],
                 logstore: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 script: pulumi.Input[_builtins.str],
                 sinks: pulumi.Input[Sequence[pulumi.Input['EtlConfigurationSinkArgs']]],
                 to_time: pulumi.Input[_builtins.int],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] from_time: The beginning of the time range for transformation.
        :param pulumi.Input[_builtins.str] lang: Data processing syntax type.
        :param pulumi.Input[_builtins.str] logstore: Destination Logstore Name.
        :param pulumi.Input[_builtins.str] role_arn: The ARN role that authorizes writing to the target Logstore.
        :param pulumi.Input[_builtins.str] script: Processing script.
        :param pulumi.Input[Sequence[pulumi.Input['EtlConfigurationSinkArgs']]] sinks: Processing result output target list See `sink` below.
        :param pulumi.Input[_builtins.int] to_time: The end of the time range for transformation.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameters: Advanced parameter configuration.
        """
        pulumi.set(__self__, "from_time", from_time)
        pulumi.set(__self__, "lang", lang)
        pulumi.set(__self__, "logstore", logstore)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "sinks", sinks)
        pulumi.set(__self__, "to_time", to_time)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="fromTime")
    def from_time(self) -> pulumi.Input[_builtins.int]:
        """
        The beginning of the time range for transformation.
        """
        return pulumi.get(self, "from_time")

    @from_time.setter
    def from_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_time", value)

    @_builtins.property
    @pulumi.getter
    def lang(self) -> pulumi.Input[_builtins.str]:
        """
        Data processing syntax type.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lang", value)

    @_builtins.property
    @pulumi.getter
    def logstore(self) -> pulumi.Input[_builtins.str]:
        """
        Destination Logstore Name.
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "logstore", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN role that authorizes writing to the target Logstore.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def script(self) -> pulumi.Input[_builtins.str]:
        """
        Processing script.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "script", value)

    @_builtins.property
    @pulumi.getter
    def sinks(self) -> pulumi.Input[Sequence[pulumi.Input['EtlConfigurationSinkArgs']]]:
        """
        Processing result output target list See `sink` below.
        """
        return pulumi.get(self, "sinks")

    @sinks.setter
    def sinks(self, value: pulumi.Input[Sequence[pulumi.Input['EtlConfigurationSinkArgs']]]):
        pulumi.set(self, "sinks", value)

    @_builtins.property
    @pulumi.getter(name="toTime")
    def to_time(self) -> pulumi.Input[_builtins.int]:
        """
        The end of the time range for transformation.
        """
        return pulumi.get(self, "to_time")

    @to_time.setter
    def to_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "to_time", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Advanced parameter configuration.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EtlConfigurationSinkArgsDict(TypedDict):
        datasets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Write Result Set.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The endpoint of the region where the target Project is located.
        """
        logstore: pulumi.Input[_builtins.str]
        """
        Destination Logstore Name.
        """
        name: pulumi.Input[_builtins.str]
        """
        Output Destination Name.
        """
        project: pulumi.Input[_builtins.str]
        """
        Project Name.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN role that authorizes writing to the target Logstore.
        """
elif False:
    EtlConfigurationSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EtlConfigurationSinkArgs:
    def __init__(__self__, *,
                 datasets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 endpoint: pulumi.Input[_builtins.str],
                 logstore: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] datasets: Write Result Set.
        :param pulumi.Input[_builtins.str] endpoint: The endpoint of the region where the target Project is located.
        :param pulumi.Input[_builtins.str] logstore: Destination Logstore Name.
        :param pulumi.Input[_builtins.str] name: Output Destination Name.
        :param pulumi.Input[_builtins.str] project: Project Name.
        :param pulumi.Input[_builtins.str] role_arn: The ARN role that authorizes writing to the target Logstore.
        """
        pulumi.set(__self__, "datasets", datasets)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "logstore", logstore)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def datasets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Write Result Set.
        """
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "datasets", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The endpoint of the region where the target Project is located.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logstore(self) -> pulumi.Input[_builtins.str]:
        """
        Destination Logstore Name.
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "logstore", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Output Destination Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        """
        Project Name.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN role that authorizes writing to the target Logstore.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class IndexLineArgsDict(TypedDict):
        case_sensitive: pulumi.Input[_builtins.bool]
        """
        Is case sensitive
        """
        chn: pulumi.Input[_builtins.bool]
        """
        Does it include Chinese
        """
        tokens: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Delimiter
        """
        exclude_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of excluded fields
        """
        include_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Include field list
        """
elif False:
    IndexLineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexLineArgs:
    def __init__(__self__, *,
                 case_sensitive: pulumi.Input[_builtins.bool],
                 chn: pulumi.Input[_builtins.bool],
                 tokens: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] case_sensitive: Is case sensitive
        :param pulumi.Input[_builtins.bool] chn: Does it include Chinese
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tokens: Delimiter
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_keys: List of excluded fields
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_keys: Include field list
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        pulumi.set(__self__, "chn", chn)
        pulumi.set(__self__, "tokens", tokens)
        if exclude_keys is not None:
            pulumi.set(__self__, "exclude_keys", exclude_keys)
        if include_keys is not None:
            pulumi.set(__self__, "include_keys", include_keys)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> pulumi.Input[_builtins.bool]:
        """
        Is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter
    def chn(self) -> pulumi.Input[_builtins.bool]:
        """
        Does it include Chinese
        """
        return pulumi.get(self, "chn")

    @chn.setter
    def chn(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "chn", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Delimiter
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="excludeKeys")
    def exclude_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of excluded fields
        """
        return pulumi.get(self, "exclude_keys")

    @exclude_keys.setter
    def exclude_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_keys", value)

    @_builtins.property
    @pulumi.getter(name="includeKeys")
    def include_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Include field list
        """
        return pulumi.get(self, "include_keys")

    @include_keys.setter
    def include_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_keys", value)


if not MYPY:
    class LogtailConfigOutputDetailArgsDict(TypedDict):
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint of the log project.
        """
        logstore_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the output target logstore.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region
        """
elif False:
    LogtailConfigOutputDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogtailConfigOutputDetailArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logstore_name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The endpoint of the log project.
        :param pulumi.Input[_builtins.str] logstore_name: The name of the output target logstore.
        :param pulumi.Input[_builtins.str] region: Region
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if logstore_name is not None:
            pulumi.set(__self__, "logstore_name", logstore_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint of the log project.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="logstoreName")
    def logstore_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the output target logstore.
        """
        return pulumi.get(self, "logstore_name")

    @logstore_name.setter
    def logstore_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logstore_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class MachineGroupGroupAttributeArgsDict(TypedDict):
        external_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external management system identification on which the machine group depends.
        """
        group_topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log topic of the machine group.
        """
elif False:
    MachineGroupGroupAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineGroupGroupAttributeArgs:
    def __init__(__self__, *,
                 external_name: Optional[pulumi.Input[_builtins.str]] = None,
                 group_topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] external_name: The external management system identification on which the machine group depends.
        :param pulumi.Input[_builtins.str] group_topic: The log topic of the machine group.
        """
        if external_name is not None:
            pulumi.set(__self__, "external_name", external_name)
        if group_topic is not None:
            pulumi.set(__self__, "group_topic", group_topic)

    @_builtins.property
    @pulumi.getter(name="externalName")
    def external_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external management system identification on which the machine group depends.
        """
        return pulumi.get(self, "external_name")

    @external_name.setter
    def external_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_name", value)

    @_builtins.property
    @pulumi.getter(name="groupTopic")
    def group_topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log topic of the machine group.
        """
        return pulumi.get(self, "group_topic")

    @group_topic.setter
    def group_topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_topic", value)


if not MYPY:
    class OssExportSinkConfigurationArgsDict(TypedDict):
        from_time: pulumi.Input[_builtins.int]
        """
        The beginning of the time range to ship data. The value 1 specifies that the data shipping job ships data from the first log in the Logstore. Example value: 1718380800
        """
        logstore: pulumi.Input[_builtins.str]
        """
        The name of the Logstore.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the RAM role that is used to write data to OSS. Example value: acs:ram::xxxxxxx
        """
        sink: pulumi.Input['OssExportSinkConfigurationSinkArgsDict']
        """
        The configurations of the Object Storage Service (OSS) data shipping job. See `sink` below.
        """
        to_time: pulumi.Input[_builtins.int]
        """
        The end of the time range to ship data. The value 0 specifies that the data shipping job continuously ships data until the job is manually stopped. Example value: 1718380800
        """
elif False:
    OssExportSinkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OssExportSinkConfigurationArgs:
    def __init__(__self__, *,
                 from_time: pulumi.Input[_builtins.int],
                 logstore: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 sink: pulumi.Input['OssExportSinkConfigurationSinkArgs'],
                 to_time: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] from_time: The beginning of the time range to ship data. The value 1 specifies that the data shipping job ships data from the first log in the Logstore. Example value: 1718380800
        :param pulumi.Input[_builtins.str] logstore: The name of the Logstore.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the RAM role that is used to write data to OSS. Example value: acs:ram::xxxxxxx
        :param pulumi.Input['OssExportSinkConfigurationSinkArgs'] sink: The configurations of the Object Storage Service (OSS) data shipping job. See `sink` below.
        :param pulumi.Input[_builtins.int] to_time: The end of the time range to ship data. The value 0 specifies that the data shipping job continuously ships data until the job is manually stopped. Example value: 1718380800
        """
        pulumi.set(__self__, "from_time", from_time)
        pulumi.set(__self__, "logstore", logstore)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "sink", sink)
        pulumi.set(__self__, "to_time", to_time)

    @_builtins.property
    @pulumi.getter(name="fromTime")
    def from_time(self) -> pulumi.Input[_builtins.int]:
        """
        The beginning of the time range to ship data. The value 1 specifies that the data shipping job ships data from the first log in the Logstore. Example value: 1718380800
        """
        return pulumi.get(self, "from_time")

    @from_time.setter
    def from_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_time", value)

    @_builtins.property
    @pulumi.getter
    def logstore(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Logstore.
        """
        return pulumi.get(self, "logstore")

    @logstore.setter
    def logstore(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "logstore", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the RAM role that is used to write data to OSS. Example value: acs:ram::xxxxxxx
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def sink(self) -> pulumi.Input['OssExportSinkConfigurationSinkArgs']:
        """
        The configurations of the Object Storage Service (OSS) data shipping job. See `sink` below.
        """
        return pulumi.get(self, "sink")

    @sink.setter
    def sink(self, value: pulumi.Input['OssExportSinkConfigurationSinkArgs']):
        pulumi.set(self, "sink", value)

    @_builtins.property
    @pulumi.getter(name="toTime")
    def to_time(self) -> pulumi.Input[_builtins.int]:
        """
        The end of the time range to ship data. The value 0 specifies that the data shipping job continuously ships data until the job is manually stopped. Example value: 1718380800
        """
        return pulumi.get(self, "to_time")

    @to_time.setter
    def to_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "to_time", value)


if not MYPY:
    class OssExportSinkConfigurationSinkArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The OSS bucket.
        """
        buffer_interval: pulumi.Input[_builtins.str]
        """
        The interval between two data shipping operations. Valid values: 300 to 900. Unit: seconds.
        """
        buffer_size: pulumi.Input[_builtins.str]
        """
        The size of the OSS object to which data is shipped. Valid values: 5 to 256. Unit: MB.
        """
        compression_type: pulumi.Input[_builtins.str]
        """
        Supports four compression types, such as snappy, gzip, zstd, and none.
        """
        content_detail: pulumi.Input[_builtins.str]
        """
        The OSS file content details. Note: the value of this parameter should be updated based on the value of the contentType parameter.

        If the contentType value is JSON, the parameters of the contentDetail value are as follows:

        If the tag is allowed to be posted, the value of the parameter enableTag is true. Example:{"enableTag": true}

        You are not allowed to post tags. The value of the parameter enableTag is false. Example:{"enableTag": false}

        If the contentType value is csv, the parameters of the contentDetail value are as follows:

        The parameter columns is the key of the log in the source logstore.

        The delimiter parameter, which can be ",","|","", or "\\t".

        The header parameter determines whether the OSS file retains the header. The optional value is true or false.

        The lineFeed parameter. Optional values are "\\t", "\\n", or "".

        The invalid field content parameter is null to specify the delivery content when the field name does not exist.

        The escape character parameter "quote". Optional values are "" "," '", or" ".

        Example:{"null": "-", "header": false, "lineFeed": "\\n", "quote": "", "delimiter": ",", "columns": ["a", "B", "c", "d"]}

        When the contentType value is parquet, the parameters of the contentDetail value are as follows:

        The columns parameter is the key of the log in the source Logstore and must carry the data type of the key, for example:{"columns": [{"name": "a", "type": "string"}, {"name": "B", "type": "string"}, {"name": "c", "type": "string": "string"}]}

        When the contentType value is set to orc, the parameters of the contentDetail value are as follows:

        The columns parameter is the key of the log in the source Logstore and must carry the data type of the key, for example:{"columns": [{"name": "a", "type": "string"}, {"name": "B", "type": "string"}, {"name": "c", "type": "string": "string"}]}
        """
        content_type: pulumi.Input[_builtins.str]
        """
        The storage format of the OSS object. Valid values: json, parquet, csv, and orc.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The OSS Endpoint can only be an OSS intranet Endpoint and only supports the same region. Example value: https://oss-cn-hangzhou-internal.aliyuncs.com
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the RAM role that is used to write data to OSS. Example value: acs:ram::xxxxxxx
        """
        time_zone: pulumi.Input[_builtins.str]
        """
        The time zone. Example value: +0800
        """
        delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The latency of data shipping. The value of this parameter cannot exceed the data retention period of the source Logstore.
        """
        path_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The directory is dynamically generated according to the time. The default value is% Y/%m/%d/%H/%M. The corresponding generated directory is, for example, 2017/01/23/12/00. Note that the partition format cannot start and end. Example values:%Y/%m/%d
        """
        path_format_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The partition format type. only support time
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prefix of the OSS object.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The suffix of the OSS object.
        """
elif False:
    OssExportSinkConfigurationSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OssExportSinkConfigurationSinkArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 buffer_interval: pulumi.Input[_builtins.str],
                 buffer_size: pulumi.Input[_builtins.str],
                 compression_type: pulumi.Input[_builtins.str],
                 content_detail: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 time_zone: pulumi.Input[_builtins.str],
                 delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 path_format: Optional[pulumi.Input[_builtins.str]] = None,
                 path_format_type: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The OSS bucket.
        :param pulumi.Input[_builtins.str] buffer_interval: The interval between two data shipping operations. Valid values: 300 to 900. Unit: seconds.
        :param pulumi.Input[_builtins.str] buffer_size: The size of the OSS object to which data is shipped. Valid values: 5 to 256. Unit: MB.
        :param pulumi.Input[_builtins.str] compression_type: Supports four compression types, such as snappy, gzip, zstd, and none.
        :param pulumi.Input[_builtins.str] content_detail: The OSS file content details. Note: the value of this parameter should be updated based on the value of the contentType parameter.
               
               If the contentType value is JSON, the parameters of the contentDetail value are as follows:
               
               If the tag is allowed to be posted, the value of the parameter enableTag is true. Example:{"enableTag": true}
               
               You are not allowed to post tags. The value of the parameter enableTag is false. Example:{"enableTag": false}
               
               If the contentType value is csv, the parameters of the contentDetail value are as follows:
               
               The parameter columns is the key of the log in the source logstore.
               
               The delimiter parameter, which can be ",","|","", or "\\t".
               
               The header parameter determines whether the OSS file retains the header. The optional value is true or false.
               
               The lineFeed parameter. Optional values are "\\t", "\\n", or "".
               
               The invalid field content parameter is null to specify the delivery content when the field name does not exist.
               
               The escape character parameter "quote". Optional values are "" "," '", or" ".
               
               Example:{"null": "-", "header": false, "lineFeed": "\\n", "quote": "", "delimiter": ",", "columns": ["a", "B", "c", "d"]}
               
               When the contentType value is parquet, the parameters of the contentDetail value are as follows:
               
               The columns parameter is the key of the log in the source Logstore and must carry the data type of the key, for example:{"columns": [{"name": "a", "type": "string"}, {"name": "B", "type": "string"}, {"name": "c", "type": "string": "string"}]}
               
               When the contentType value is set to orc, the parameters of the contentDetail value are as follows:
               
               The columns parameter is the key of the log in the source Logstore and must carry the data type of the key, for example:{"columns": [{"name": "a", "type": "string"}, {"name": "B", "type": "string"}, {"name": "c", "type": "string": "string"}]}
        :param pulumi.Input[_builtins.str] content_type: The storage format of the OSS object. Valid values: json, parquet, csv, and orc.
        :param pulumi.Input[_builtins.str] endpoint: The OSS Endpoint can only be an OSS intranet Endpoint and only supports the same region. Example value: https://oss-cn-hangzhou-internal.aliyuncs.com
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the RAM role that is used to write data to OSS. Example value: acs:ram::xxxxxxx
        :param pulumi.Input[_builtins.str] time_zone: The time zone. Example value: +0800
        :param pulumi.Input[_builtins.int] delay_seconds: The latency of data shipping. The value of this parameter cannot exceed the data retention period of the source Logstore.
        :param pulumi.Input[_builtins.str] path_format: The directory is dynamically generated according to the time. The default value is% Y/%m/%d/%H/%M. The corresponding generated directory is, for example, 2017/01/23/12/00. Note that the partition format cannot start and end. Example values:%Y/%m/%d
        :param pulumi.Input[_builtins.str] path_format_type: The partition format type. only support time
        :param pulumi.Input[_builtins.str] prefix: The prefix of the OSS object.
        :param pulumi.Input[_builtins.str] suffix: The suffix of the OSS object.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "buffer_interval", buffer_interval)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "compression_type", compression_type)
        pulumi.set(__self__, "content_detail", content_detail)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "time_zone", time_zone)
        if delay_seconds is not None:
            pulumi.set(__self__, "delay_seconds", delay_seconds)
        if path_format is not None:
            pulumi.set(__self__, "path_format", path_format)
        if path_format_type is not None:
            pulumi.set(__self__, "path_format_type", path_format_type)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The OSS bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="bufferInterval")
    def buffer_interval(self) -> pulumi.Input[_builtins.str]:
        """
        The interval between two data shipping operations. Valid values: 300 to 900. Unit: seconds.
        """
        return pulumi.get(self, "buffer_interval")

    @buffer_interval.setter
    def buffer_interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "buffer_interval", value)

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[_builtins.str]:
        """
        The size of the OSS object to which data is shipped. Valid values: 5 to 256. Unit: MB.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "buffer_size", value)

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> pulumi.Input[_builtins.str]:
        """
        Supports four compression types, such as snappy, gzip, zstd, and none.
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "compression_type", value)

    @_builtins.property
    @pulumi.getter(name="contentDetail")
    def content_detail(self) -> pulumi.Input[_builtins.str]:
        """
        The OSS file content details. Note: the value of this parameter should be updated based on the value of the contentType parameter.

        If the contentType value is JSON, the parameters of the contentDetail value are as follows:

        If the tag is allowed to be posted, the value of the parameter enableTag is true. Example:{"enableTag": true}

        You are not allowed to post tags. The value of the parameter enableTag is false. Example:{"enableTag": false}

        If the contentType value is csv, the parameters of the contentDetail value are as follows:

        The parameter columns is the key of the log in the source logstore.

        The delimiter parameter, which can be ",","|","", or "\\t".

        The header parameter determines whether the OSS file retains the header. The optional value is true or false.

        The lineFeed parameter. Optional values are "\\t", "\\n", or "".

        The invalid field content parameter is null to specify the delivery content when the field name does not exist.

        The escape character parameter "quote". Optional values are "" "," '", or" ".

        Example:{"null": "-", "header": false, "lineFeed": "\\n", "quote": "", "delimiter": ",", "columns": ["a", "B", "c", "d"]}

        When the contentType value is parquet, the parameters of the contentDetail value are as follows:

        The columns parameter is the key of the log in the source Logstore and must carry the data type of the key, for example:{"columns": [{"name": "a", "type": "string"}, {"name": "B", "type": "string"}, {"name": "c", "type": "string": "string"}]}

        When the contentType value is set to orc, the parameters of the contentDetail value are as follows:

        The columns parameter is the key of the log in the source Logstore and must carry the data type of the key, for example:{"columns": [{"name": "a", "type": "string"}, {"name": "B", "type": "string"}, {"name": "c", "type": "string": "string"}]}
        """
        return pulumi.get(self, "content_detail")

    @content_detail.setter
    def content_detail(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_detail", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        The storage format of the OSS object. Valid values: json, parquet, csv, and orc.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The OSS Endpoint can only be an OSS intranet Endpoint and only supports the same region. Example value: https://oss-cn-hangzhou-internal.aliyuncs.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the RAM role that is used to write data to OSS. Example value: acs:ram::xxxxxxx
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[_builtins.str]:
        """
        The time zone. Example value: +0800
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter(name="delaySeconds")
    def delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The latency of data shipping. The value of this parameter cannot exceed the data retention period of the source Logstore.
        """
        return pulumi.get(self, "delay_seconds")

    @delay_seconds.setter
    def delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="pathFormat")
    def path_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The directory is dynamically generated according to the time. The default value is% Y/%m/%d/%H/%M. The corresponding generated directory is, for example, 2017/01/23/12/00. Note that the partition format cannot start and end. Example values:%Y/%m/%d
        """
        return pulumi.get(self, "path_format")

    @path_format.setter
    def path_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_format", value)

    @_builtins.property
    @pulumi.getter(name="pathFormatType")
    def path_format_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The partition format type. only support time
        """
        return pulumi.get(self, "path_format_type")

    @path_format_type.setter
    def path_format_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_format_type", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prefix of the OSS object.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The suffix of the OSS object.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class ScheduledSqlScheduleArgsDict(TypedDict):
        cron_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cron expression, minimum precision is minutes, 24-hour clock. For example, 0 0/1 **indicates that the check is performed every one hour from 00:00. When type is set to Cron, cronExpression must be set.
        """
        delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        Delay time.
        """
        interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time interval, such as 5m, 1H.
        """
        run_immediately: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to execute the OSS import task immediately after it is created.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time Zone.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Check the frequency type. Log Service checks the query and analysis results based on the frequency you configured. The value is as follows: FixedRate: checks the query and analysis results at fixed intervals. Cron: specifies a time interval through a Cron expression, and checks the query and analysis results at the specified time interval. Weekly: Check the query and analysis results at a fixed point in time on the day of the week. Daily: checks the query and analysis results at a fixed time point every day. Hourly: Check query and analysis results every hour.
        """
elif False:
    ScheduledSqlScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledSqlScheduleArgs:
    def __init__(__self__, *,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 delay: Optional[pulumi.Input[_builtins.int]] = None,
                 interval: Optional[pulumi.Input[_builtins.str]] = None,
                 run_immediately: Optional[pulumi.Input[_builtins.bool]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cron_expression: Cron expression, minimum precision is minutes, 24-hour clock. For example, 0 0/1 **indicates that the check is performed every one hour from 00:00. When type is set to Cron, cronExpression must be set.
        :param pulumi.Input[_builtins.int] delay: Delay time.
        :param pulumi.Input[_builtins.str] interval: Time interval, such as 5m, 1H.
        :param pulumi.Input[_builtins.bool] run_immediately: Whether to execute the OSS import task immediately after it is created.
        :param pulumi.Input[_builtins.str] time_zone: Time Zone.
        :param pulumi.Input[_builtins.str] type: Check the frequency type. Log Service checks the query and analysis results based on the frequency you configured. The value is as follows: FixedRate: checks the query and analysis results at fixed intervals. Cron: specifies a time interval through a Cron expression, and checks the query and analysis results at the specified time interval. Weekly: Check the query and analysis results at a fixed point in time on the day of the week. Daily: checks the query and analysis results at a fixed time point every day. Hourly: Check query and analysis results every hour.
        """
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if run_immediately is not None:
            pulumi.set(__self__, "run_immediately", run_immediately)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cron expression, minimum precision is minutes, 24-hour clock. For example, 0 0/1 **indicates that the check is performed every one hour from 00:00. When type is set to Cron, cronExpression must be set.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Delay time.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time interval, such as 5m, 1H.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="runImmediately")
    def run_immediately(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to execute the OSS import task immediately after it is created.
        """
        return pulumi.get(self, "run_immediately")

    @run_immediately.setter
    def run_immediately(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_immediately", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time Zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Check the frequency type. Log Service checks the query and analysis results based on the frequency you configured. The value is as follows: FixedRate: checks the query and analysis results at fixed intervals. Cron: specifies a time interval through a Cron expression, and checks the query and analysis results at the specified time interval. Weekly: Check the query and analysis results at a fixed point in time on the day of the week. Daily: checks the query and analysis results at a fixed time point every day. Hourly: Check query and analysis results every hour.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ScheduledSqlScheduledSqlConfigurationArgsDict(TypedDict):
        data_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Write Mode.
        """
        dest_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target Endpoint.
        """
        dest_logstore: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target Logstore.
        """
        dest_project: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target Project.
        """
        dest_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Write target role ARN.
        """
        from_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Schedule Start Time.
        """
        from_time_expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        SQL time window-start.
        """
        max_retries: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum retries.
        """
        max_run_time_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        SQL timeout.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Parameter configuration.
        """
        resource_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource Pool.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Read role ARN.
        """
        script: NotRequired[pulumi.Input[_builtins.str]]
        """
        SQL statement.
        """
        source_logstore: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source Logstore.
        """
        sql_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        SQL type.
        """
        to_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time at end of schedule.
        """
        to_time_expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        SQL time window-end.
        """
elif False:
    ScheduledSqlScheduledSqlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledSqlScheduledSqlConfigurationArgs:
    def __init__(__self__, *,
                 data_format: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_logstore: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_project: Optional[pulumi.Input[_builtins.str]] = None,
                 dest_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 from_time: Optional[pulumi.Input[_builtins.int]] = None,
                 from_time_expr: Optional[pulumi.Input[_builtins.str]] = None,
                 max_retries: Optional[pulumi.Input[_builtins.int]] = None,
                 max_run_time_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 resource_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 script: Optional[pulumi.Input[_builtins.str]] = None,
                 source_logstore: Optional[pulumi.Input[_builtins.str]] = None,
                 sql_type: Optional[pulumi.Input[_builtins.str]] = None,
                 to_time: Optional[pulumi.Input[_builtins.int]] = None,
                 to_time_expr: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_format: Write Mode.
        :param pulumi.Input[_builtins.str] dest_endpoint: Target Endpoint.
        :param pulumi.Input[_builtins.str] dest_logstore: Target Logstore.
        :param pulumi.Input[_builtins.str] dest_project: Target Project.
        :param pulumi.Input[_builtins.str] dest_role_arn: Write target role ARN.
        :param pulumi.Input[_builtins.int] from_time: Schedule Start Time.
        :param pulumi.Input[_builtins.str] from_time_expr: SQL time window-start.
        :param pulumi.Input[_builtins.int] max_retries: Maximum retries.
        :param pulumi.Input[_builtins.int] max_run_time_in_seconds: SQL timeout.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameters: Parameter configuration.
        :param pulumi.Input[_builtins.str] resource_pool: Resource Pool.
        :param pulumi.Input[_builtins.str] role_arn: Read role ARN.
        :param pulumi.Input[_builtins.str] script: SQL statement.
        :param pulumi.Input[_builtins.str] source_logstore: Source Logstore.
        :param pulumi.Input[_builtins.str] sql_type: SQL type.
        :param pulumi.Input[_builtins.int] to_time: Time at end of schedule.
        :param pulumi.Input[_builtins.str] to_time_expr: SQL time window-end.
        """
        if data_format is not None:
            pulumi.set(__self__, "data_format", data_format)
        if dest_endpoint is not None:
            pulumi.set(__self__, "dest_endpoint", dest_endpoint)
        if dest_logstore is not None:
            pulumi.set(__self__, "dest_logstore", dest_logstore)
        if dest_project is not None:
            pulumi.set(__self__, "dest_project", dest_project)
        if dest_role_arn is not None:
            pulumi.set(__self__, "dest_role_arn", dest_role_arn)
        if from_time is not None:
            pulumi.set(__self__, "from_time", from_time)
        if from_time_expr is not None:
            pulumi.set(__self__, "from_time_expr", from_time_expr)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if max_run_time_in_seconds is not None:
            pulumi.set(__self__, "max_run_time_in_seconds", max_run_time_in_seconds)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if resource_pool is not None:
            pulumi.set(__self__, "resource_pool", resource_pool)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if source_logstore is not None:
            pulumi.set(__self__, "source_logstore", source_logstore)
        if sql_type is not None:
            pulumi.set(__self__, "sql_type", sql_type)
        if to_time is not None:
            pulumi.set(__self__, "to_time", to_time)
        if to_time_expr is not None:
            pulumi.set(__self__, "to_time_expr", to_time_expr)

    @_builtins.property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Write Mode.
        """
        return pulumi.get(self, "data_format")

    @data_format.setter
    def data_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_format", value)

    @_builtins.property
    @pulumi.getter(name="destEndpoint")
    def dest_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target Endpoint.
        """
        return pulumi.get(self, "dest_endpoint")

    @dest_endpoint.setter
    def dest_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="destLogstore")
    def dest_logstore(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target Logstore.
        """
        return pulumi.get(self, "dest_logstore")

    @dest_logstore.setter
    def dest_logstore(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_logstore", value)

    @_builtins.property
    @pulumi.getter(name="destProject")
    def dest_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target Project.
        """
        return pulumi.get(self, "dest_project")

    @dest_project.setter
    def dest_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_project", value)

    @_builtins.property
    @pulumi.getter(name="destRoleArn")
    def dest_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Write target role ARN.
        """
        return pulumi.get(self, "dest_role_arn")

    @dest_role_arn.setter
    def dest_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="fromTime")
    def from_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Schedule Start Time.
        """
        return pulumi.get(self, "from_time")

    @from_time.setter
    def from_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_time", value)

    @_builtins.property
    @pulumi.getter(name="fromTimeExpr")
    def from_time_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SQL time window-start.
        """
        return pulumi.get(self, "from_time_expr")

    @from_time_expr.setter
    def from_time_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_time_expr", value)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum retries.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_retries", value)

    @_builtins.property
    @pulumi.getter(name="maxRunTimeInSeconds")
    def max_run_time_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        SQL timeout.
        """
        return pulumi.get(self, "max_run_time_in_seconds")

    @max_run_time_in_seconds.setter
    def max_run_time_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_run_time_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Parameter configuration.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource Pool.
        """
        return pulumi.get(self, "resource_pool")

    @resource_pool.setter
    def resource_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_pool", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Read role ARN.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SQL statement.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script", value)

    @_builtins.property
    @pulumi.getter(name="sourceLogstore")
    def source_logstore(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source Logstore.
        """
        return pulumi.get(self, "source_logstore")

    @source_logstore.setter
    def source_logstore(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_logstore", value)

    @_builtins.property
    @pulumi.getter(name="sqlType")
    def sql_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SQL type.
        """
        return pulumi.get(self, "sql_type")

    @sql_type.setter
    def sql_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql_type", value)

    @_builtins.property
    @pulumi.getter(name="toTime")
    def to_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time at end of schedule.
        """
        return pulumi.get(self, "to_time")

    @to_time.setter
    def to_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_time", value)

    @_builtins.property
    @pulumi.getter(name="toTimeExpr")
    def to_time_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SQL time window-end.
        """
        return pulumi.get(self, "to_time_expr")

    @to_time_expr.setter
    def to_time_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to_time_expr", value)


