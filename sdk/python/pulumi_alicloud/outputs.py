# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'MilvusInstanceComponent',
    'MilvusInstanceVswitchId',
    'OpenApiExplorerApiMcpServerAdditionalApiDescription',
    'OpenApiExplorerApiMcpServerAdditionalApiDescriptionConstParameter',
    'OpenApiExplorerApiMcpServerApi',
    'OpenApiExplorerApiMcpServerPrompt',
    'OpenApiExplorerApiMcpServerPromptArgument',
    'OpenApiExplorerApiMcpServerTerraformTool',
    'StarRocksInstanceBackendNodeGroup',
    'StarRocksInstanceFrontendNodeGroup',
    'StarRocksInstanceObserverNodeGroup',
    'StarRocksInstanceVswitch',
    'GetMscSubContactsContactResult',
    'GetMscSubSubscriptionsSubscriptionResult',
    'GetMscSubWebhooksWebhookResult',
    'GetRegionsRegionResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class MilvusInstanceComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cuNum":
            suggest = "cu_num"
        elif key == "cuType":
            suggest = "cu_type"
        elif key == "diskSizeType":
            suggest = "disk_size_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MilvusInstanceComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MilvusInstanceComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MilvusInstanceComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cu_num: _builtins.int,
                 replica: _builtins.int,
                 type: _builtins.str,
                 cu_type: Optional[_builtins.str] = None,
                 disk_size_type: Optional[_builtins.str] = None):
        """
        :param _builtins.int cu_num: The number of CU. For example: 4
        :param _builtins.int replica: The number of component replicas. The number of highly available replicas must be greater than or equal to 2.
        :param _builtins.str type: The component type. Different types need to be configured according to different versions.
               - Starter version: Array including standalone
               - Standard Edition: The configuration is different according to the 2.5 version and 2.6 version.
               2.5: proxy ,mix_coordinator,data,query,index
               2.6 need to configure: proxy,mix_coordinator,data,query,streaming
        :param _builtins.str cu_type: The calculation type. The default value is general, and the ram type needs to be opened with a work order.
               - general: Generic
               - ram: Capacity
        :param _builtins.str disk_size_type: Default Normal. The Query Node is configured with the capacity type, performance type, and capacity type Large, and the rest are configured with Normal.
        """
        pulumi.set(__self__, "cu_num", cu_num)
        pulumi.set(__self__, "replica", replica)
        pulumi.set(__self__, "type", type)
        if cu_type is not None:
            pulumi.set(__self__, "cu_type", cu_type)
        if disk_size_type is not None:
            pulumi.set(__self__, "disk_size_type", disk_size_type)

    @_builtins.property
    @pulumi.getter(name="cuNum")
    def cu_num(self) -> _builtins.int:
        """
        The number of CU. For example: 4
        """
        return pulumi.get(self, "cu_num")

    @_builtins.property
    @pulumi.getter
    def replica(self) -> _builtins.int:
        """
        The number of component replicas. The number of highly available replicas must be greater than or equal to 2.
        """
        return pulumi.get(self, "replica")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The component type. Different types need to be configured according to different versions.
        - Starter version: Array including standalone
        - Standard Edition: The configuration is different according to the 2.5 version and 2.6 version.
        2.5: proxy ,mix_coordinator,data,query,index
        2.6 need to configure: proxy,mix_coordinator,data,query,streaming
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="cuType")
    def cu_type(self) -> Optional[_builtins.str]:
        """
        The calculation type. The default value is general, and the ram type needs to be opened with a work order.
        - general: Generic
        - ram: Capacity
        """
        return pulumi.get(self, "cu_type")

    @_builtins.property
    @pulumi.getter(name="diskSizeType")
    def disk_size_type(self) -> Optional[_builtins.str]:
        """
        Default Normal. The Query Node is configured with the capacity type, performance type, and capacity type Large, and the rest are configured with Normal.
        """
        return pulumi.get(self, "disk_size_type")


@pulumi.output_type
class MilvusInstanceVswitchId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vswId":
            suggest = "vsw_id"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MilvusInstanceVswitchId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MilvusInstanceVswitchId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MilvusInstanceVswitchId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vsw_id: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str vsw_id: VSwitch id, which must correspond to the zone id.
        :param _builtins.str zone_id: The availability zone must correspond to the vswId.
        """
        if vsw_id is not None:
            pulumi.set(__self__, "vsw_id", vsw_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="vswId")
    def vsw_id(self) -> Optional[_builtins.str]:
        """
        VSwitch id, which must correspond to the zone id.
        """
        return pulumi.get(self, "vsw_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        The availability zone must correspond to the vswId.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class OpenApiExplorerApiMcpServerAdditionalApiDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiName":
            suggest = "api_name"
        elif key == "apiOverrideJson":
            suggest = "api_override_json"
        elif key == "apiVersion":
            suggest = "api_version"
        elif key == "constParameters":
            suggest = "const_parameters"
        elif key == "enableOutputSchema":
            suggest = "enable_output_schema"
        elif key == "executeCliCommand":
            suggest = "execute_cli_command"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenApiExplorerApiMcpServerAdditionalApiDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenApiExplorerApiMcpServerAdditionalApiDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenApiExplorerApiMcpServerAdditionalApiDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_name: Optional[_builtins.str] = None,
                 api_override_json: Optional[_builtins.str] = None,
                 api_version: Optional[_builtins.str] = None,
                 const_parameters: Optional[Sequence['outputs.OpenApiExplorerApiMcpServerAdditionalApiDescriptionConstParameter']] = None,
                 enable_output_schema: Optional[_builtins.bool] = None,
                 execute_cli_command: Optional[_builtins.bool] = None,
                 product: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_name: The API name, such as ListApiMcpServers.
        :param _builtins.str api_override_json: API structure definition information. You can use this parameter to directly modify the API description and parameter list. You can obtain the API definition information from an API endpoint such as https://api.aliyun.com/meta/v1/products/Ecs/versions/2014-05-26/apis/DescribeInstances/api.json.  
               
               > **NOTE:** Note that required parameters must not be removed; otherwise, calls by the large model will continuously fail due to missing required parameters.>
        :param _builtins.str api_version: API version information, typically in date format, such as 2014-05-26.
        :param Sequence['OpenApiExplorerApiMcpServerAdditionalApiDescriptionConstParameterArgs'] const_parameters: Constant configuration information. When the MCP Server needs to fix certain tool parameters to specific values, you can configure this parameter to enforce those fixed values.  
               Parameters configured as constants will not be returned as tool parameters through the MCP protocol. Large models cannot define these parameters. During execution, the MCP Server merges these constant values into the API call parameters.   See `const_parameters` below.
        :param _builtins.bool enable_output_schema: By default, this feature is disabled, and the MCP Server returns only the structure definition of input parameters. When enabled, the MCP Server returns the output parameter structure definition via the MCP protocol.  
               
               > **NOTE:** The output parameter structure may be complex. Enabling this feature significantly increases the MCP context size. Use this feature with caution.>
        :param _builtins.bool execute_cli_command: Call interception. When this parameter is enabled, the MCP Server returns the complete CLI command name instead of directly executing the API call. Use this option when the API call is long-running or requires interaction with local files. The MCP Server enforces theoretical time limits for single-tool invocations:  
               - SSE protocol: up to 30 minutes
               - Streamable HTTP protocol: up to 1 minute
               
               For tools whose single API execution exceeds 30 minutes, we recommend enabling this parameter. Install the CLI and complete account authentication on the machine initiating the call, then combine it with this tool for optimal results.
               
               > **NOTE:** The identity used to execute the CLI differs from the identity used by the MCP Server. Pay attention to the associated security risks.>
        :param _builtins.str product: The name of the cloud product, such as Ecs.
        """
        if api_name is not None:
            pulumi.set(__self__, "api_name", api_name)
        if api_override_json is not None:
            pulumi.set(__self__, "api_override_json", api_override_json)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if const_parameters is not None:
            pulumi.set(__self__, "const_parameters", const_parameters)
        if enable_output_schema is not None:
            pulumi.set(__self__, "enable_output_schema", enable_output_schema)
        if execute_cli_command is not None:
            pulumi.set(__self__, "execute_cli_command", execute_cli_command)
        if product is not None:
            pulumi.set(__self__, "product", product)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> Optional[_builtins.str]:
        """
        The API name, such as ListApiMcpServers.
        """
        return pulumi.get(self, "api_name")

    @_builtins.property
    @pulumi.getter(name="apiOverrideJson")
    def api_override_json(self) -> Optional[_builtins.str]:
        """
        API structure definition information. You can use this parameter to directly modify the API description and parameter list. You can obtain the API definition information from an API endpoint such as https://api.aliyun.com/meta/v1/products/Ecs/versions/2014-05-26/apis/DescribeInstances/api.json.  

        > **NOTE:** Note that required parameters must not be removed; otherwise, calls by the large model will continuously fail due to missing required parameters.>
        """
        return pulumi.get(self, "api_override_json")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        API version information, typically in date format, such as 2014-05-26.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter(name="constParameters")
    def const_parameters(self) -> Optional[Sequence['outputs.OpenApiExplorerApiMcpServerAdditionalApiDescriptionConstParameter']]:
        """
        Constant configuration information. When the MCP Server needs to fix certain tool parameters to specific values, you can configure this parameter to enforce those fixed values.  
        Parameters configured as constants will not be returned as tool parameters through the MCP protocol. Large models cannot define these parameters. During execution, the MCP Server merges these constant values into the API call parameters.   See `const_parameters` below.
        """
        return pulumi.get(self, "const_parameters")

    @_builtins.property
    @pulumi.getter(name="enableOutputSchema")
    def enable_output_schema(self) -> Optional[_builtins.bool]:
        """
        By default, this feature is disabled, and the MCP Server returns only the structure definition of input parameters. When enabled, the MCP Server returns the output parameter structure definition via the MCP protocol.  

        > **NOTE:** The output parameter structure may be complex. Enabling this feature significantly increases the MCP context size. Use this feature with caution.>
        """
        return pulumi.get(self, "enable_output_schema")

    @_builtins.property
    @pulumi.getter(name="executeCliCommand")
    def execute_cli_command(self) -> Optional[_builtins.bool]:
        """
        Call interception. When this parameter is enabled, the MCP Server returns the complete CLI command name instead of directly executing the API call. Use this option when the API call is long-running or requires interaction with local files. The MCP Server enforces theoretical time limits for single-tool invocations:  
        - SSE protocol: up to 30 minutes
        - Streamable HTTP protocol: up to 1 minute

        For tools whose single API execution exceeds 30 minutes, we recommend enabling this parameter. Install the CLI and complete account authentication on the machine initiating the call, then combine it with this tool for optimal results.

        > **NOTE:** The identity used to execute the CLI differs from the identity used by the MCP Server. Pay attention to the associated security risks.>
        """
        return pulumi.get(self, "execute_cli_command")

    @_builtins.property
    @pulumi.getter
    def product(self) -> Optional[_builtins.str]:
        """
        The name of the cloud product, such as Ecs.
        """
        return pulumi.get(self, "product")


@pulumi.output_type
class OpenApiExplorerApiMcpServerAdditionalApiDescriptionConstParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Parameter location. Currently, except for ROA-style body parameters (which support up to two levels), nested parameter configurations beyond two levels are not supported. If you need to configure a composite data structure, set the Value to a JSON object.  
               
               For RPC-style APIs, examples include:
               - Name: sets the Name parameter to a fixed value.
               
               For ROA-style APIs, examples include:
               - Name: sets a query or path parameter named Name to a fixed value;
               - body.Name: sets the Name field within the request body to a fixed value.
               
               Configurations such as body.Name.Sub are not supported. If you need to set body.Name as a composite structure, specify the Value as a JSON object—for example, {"Sub": "xxx"}.
               
               > **NOTE:** x_mcp_region_id is a built-in MCP parameter used to control the region and can also be configured as a fixed value to invoke services in a specified region.>
        :param _builtins.str value: This property does not have a description in the spec, please add it before generating code.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Parameter location. Currently, except for ROA-style body parameters (which support up to two levels), nested parameter configurations beyond two levels are not supported. If you need to configure a composite data structure, set the Value to a JSON object.  

        For RPC-style APIs, examples include:
        - Name: sets the Name parameter to a fixed value.

        For ROA-style APIs, examples include:
        - Name: sets a query or path parameter named Name to a fixed value;
        - body.Name: sets the Name field within the request body to a fixed value.

        Configurations such as body.Name.Sub are not supported. If you need to set body.Name as a composite structure, specify the Value as a JSON object—for example, {"Sub": "xxx"}.

        > **NOTE:** x_mcp_region_id is a built-in MCP parameter used to control the region and can also be configured as a fixed value to invoke services in a specified region.>
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        This property does not have a description in the spec, please add it before generating code.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OpenApiExplorerApiMcpServerApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenApiExplorerApiMcpServerApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenApiExplorerApiMcpServerApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenApiExplorerApiMcpServerApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: _builtins.str,
                 product: _builtins.str,
                 selectors: Sequence[_builtins.str]):
        """
        :param _builtins.str api_version: API version information, typically in date format—for example, the version for ECS is 2014-05-26.
        :param _builtins.str product: Product code, such as Ecs.
        :param Sequence[_builtins.str] selectors: Selectors in array format, where each item is an API name—for example, GetApiDefinition or ListApiDefinitions. You can obtain the complete list of supported APIs from the Alibaba Cloud Developer Portal.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        API version information, typically in date format—for example, the version for ECS is 2014-05-26.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        Product code, such as Ecs.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Sequence[_builtins.str]:
        """
        Selectors in array format, where each item is an API name—for example, GetApiDefinition or ListApiDefinitions. You can obtain the complete list of supported APIs from the Alibaba Cloud Developer Portal.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class OpenApiExplorerApiMcpServerPrompt(dict):
    def __init__(__self__, *,
                 arguments: Optional[Sequence['outputs.OpenApiExplorerApiMcpServerPromptArgument']] = None,
                 content: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence['OpenApiExplorerApiMcpServerPromptArgumentArgs'] arguments: Parameters for the prompt. See `arguments` below.
        :param _builtins.str content: Full content of the prompt, supporting dynamic parameters. Parameters must be defined in Arguments, using the format {{ARG}}, where ARG supports English characters. Example: My name is: {{name}}.
        :param _builtins.str description: Description of the prompt parameter.
        :param _builtins.str name: Name of the prompt parameter.
        """
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[Sequence['outputs.OpenApiExplorerApiMcpServerPromptArgument']]:
        """
        Parameters for the prompt. See `arguments` below.
        """
        return pulumi.get(self, "arguments")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Full content of the prompt, supporting dynamic parameters. Parameters must be defined in Arguments, using the format {{ARG}}, where ARG supports English characters. Example: My name is: {{name}}.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the prompt parameter.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the prompt parameter.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class OpenApiExplorerApiMcpServerPromptArgument(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None):
        """
        :param _builtins.str description: Description of the API MCP service.
        :param _builtins.str name: Name of the MCP Server. It can contain digits, English letters, and hyphens (-).
        :param _builtins.bool required: Indicates whether the prompt parameter is required.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the API MCP service.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the MCP Server. It can contain digits, English letters, and hyphens (-).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the prompt parameter is required.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class OpenApiExplorerApiMcpServerTerraformTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "async":
            suggest = "async_"
        elif key == "destroyPolicy":
            suggest = "destroy_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenApiExplorerApiMcpServerTerraformTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenApiExplorerApiMcpServerTerraformTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenApiExplorerApiMcpServerTerraformTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 async_: Optional[_builtins.bool] = None,
                 code: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 destroy_policy: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool async_: Specifies whether execution is asynchronous. If enabled, the system immediately proceeds to the next task after initiating a task, without waiting for each resource operation to complete.
        :param _builtins.str destroy_policy: The cleanup policy applied to temporary resources after task completion, based on the task execution status:
               - NEVER: Do not delete any created resources, regardless of whether the task succeeds or fails.
               - ALWAYS: Immediately destroy all related resources upon task completion, regardless of success or failure.
               - ON_FAILURE: Delete related resources only if the task fails; retain them if the task succeeds.
        """
        if async_ is not None:
            pulumi.set(__self__, "async_", async_)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destroy_policy is not None:
            pulumi.set(__self__, "destroy_policy", destroy_policy)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="async")
    def async_(self) -> Optional[_builtins.bool]:
        """
        Specifies whether execution is asynchronous. If enabled, the system immediately proceeds to the next task after initiating a task, without waiting for each resource operation to complete.
        """
        return pulumi.get(self, "async_")

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destroyPolicy")
    def destroy_policy(self) -> Optional[_builtins.str]:
        """
        The cleanup policy applied to temporary resources after task completion, based on the task execution status:
        - NEVER: Do not delete any created resources, regardless of whether the task succeeds or fails.
        - ALWAYS: Immediately destroy all related resources upon task completion, regardless of success or failure.
        - ON_FAILURE: Delete related resources only if the task fails; retain them if the task succeeds.
        """
        return pulumi.get(self, "destroy_policy")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class StarRocksInstanceBackendNodeGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskNumber":
            suggest = "disk_number"
        elif key == "localStorageInstanceType":
            suggest = "local_storage_instance_type"
        elif key == "residentNodeNumber":
            suggest = "resident_node_number"
        elif key == "specType":
            suggest = "spec_type"
        elif key == "storagePerformanceLevel":
            suggest = "storage_performance_level"
        elif key == "storageSize":
            suggest = "storage_size"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StarRocksInstanceBackendNodeGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StarRocksInstanceBackendNodeGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StarRocksInstanceBackendNodeGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cu: Optional[_builtins.int] = None,
                 disk_number: Optional[_builtins.int] = None,
                 local_storage_instance_type: Optional[_builtins.str] = None,
                 resident_node_number: Optional[_builtins.int] = None,
                 spec_type: Optional[_builtins.str] = None,
                 storage_performance_level: Optional[_builtins.str] = None,
                 storage_size: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int cu: Number of CUs. CU (Compute Unit) is the basic measurement unit of the service, where 1 CU = 1 CPU core + 4 GiB memory.
        :param _builtins.int disk_number: The number of disks.
        :param _builtins.str local_storage_instance_type: Local SSD instance specifications.
        :param _builtins.int resident_node_number: Resident node number of node group.
        :param _builtins.str spec_type: Compute group specification types include the following:
               - standard
               - localSSD
               - bigData
               - ramEnhanced
               - networkEnhanced
        :param _builtins.str storage_performance_level: Performance levels of cloud disks include the following values:
               - pl0: Maximum random read/write IOPS per disk is 10,000.
               - pl1: Maximum random read/write IOPS per disk is 50,000.
               - pl2: Maximum random read/write IOPS per disk is 100,000.
               - pl3: Maximum random read/write IOPS per disk is 1,000,000.
        :param _builtins.int storage_size: Storage size, measured in GiB.
        :param _builtins.str zone_id: Zone ID.
        """
        if cu is not None:
            pulumi.set(__self__, "cu", cu)
        if disk_number is not None:
            pulumi.set(__self__, "disk_number", disk_number)
        if local_storage_instance_type is not None:
            pulumi.set(__self__, "local_storage_instance_type", local_storage_instance_type)
        if resident_node_number is not None:
            pulumi.set(__self__, "resident_node_number", resident_node_number)
        if spec_type is not None:
            pulumi.set(__self__, "spec_type", spec_type)
        if storage_performance_level is not None:
            pulumi.set(__self__, "storage_performance_level", storage_performance_level)
        if storage_size is not None:
            pulumi.set(__self__, "storage_size", storage_size)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def cu(self) -> Optional[_builtins.int]:
        """
        Number of CUs. CU (Compute Unit) is the basic measurement unit of the service, where 1 CU = 1 CPU core + 4 GiB memory.
        """
        return pulumi.get(self, "cu")

    @_builtins.property
    @pulumi.getter(name="diskNumber")
    def disk_number(self) -> Optional[_builtins.int]:
        """
        The number of disks.
        """
        return pulumi.get(self, "disk_number")

    @_builtins.property
    @pulumi.getter(name="localStorageInstanceType")
    def local_storage_instance_type(self) -> Optional[_builtins.str]:
        """
        Local SSD instance specifications.
        """
        return pulumi.get(self, "local_storage_instance_type")

    @_builtins.property
    @pulumi.getter(name="residentNodeNumber")
    def resident_node_number(self) -> Optional[_builtins.int]:
        """
        Resident node number of node group.
        """
        return pulumi.get(self, "resident_node_number")

    @_builtins.property
    @pulumi.getter(name="specType")
    def spec_type(self) -> Optional[_builtins.str]:
        """
        Compute group specification types include the following:
        - standard
        - localSSD
        - bigData
        - ramEnhanced
        - networkEnhanced
        """
        return pulumi.get(self, "spec_type")

    @_builtins.property
    @pulumi.getter(name="storagePerformanceLevel")
    def storage_performance_level(self) -> Optional[_builtins.str]:
        """
        Performance levels of cloud disks include the following values:
        - pl0: Maximum random read/write IOPS per disk is 10,000.
        - pl1: Maximum random read/write IOPS per disk is 50,000.
        - pl2: Maximum random read/write IOPS per disk is 100,000.
        - pl3: Maximum random read/write IOPS per disk is 1,000,000.
        """
        return pulumi.get(self, "storage_performance_level")

    @_builtins.property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> Optional[_builtins.int]:
        """
        Storage size, measured in GiB.
        """
        return pulumi.get(self, "storage_size")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Zone ID.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class StarRocksInstanceFrontendNodeGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskNumber":
            suggest = "disk_number"
        elif key == "localStorageInstanceType":
            suggest = "local_storage_instance_type"
        elif key == "residentNodeNumber":
            suggest = "resident_node_number"
        elif key == "specType":
            suggest = "spec_type"
        elif key == "storagePerformanceLevel":
            suggest = "storage_performance_level"
        elif key == "storageSize":
            suggest = "storage_size"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StarRocksInstanceFrontendNodeGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StarRocksInstanceFrontendNodeGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StarRocksInstanceFrontendNodeGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cu: Optional[_builtins.int] = None,
                 disk_number: Optional[_builtins.int] = None,
                 local_storage_instance_type: Optional[_builtins.str] = None,
                 resident_node_number: Optional[_builtins.int] = None,
                 spec_type: Optional[_builtins.str] = None,
                 storage_performance_level: Optional[_builtins.str] = None,
                 storage_size: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int cu: Number of CUs. CU (Compute Unit) is the basic measurement unit of the service, where 1 CU = 1 CPU core + 4 GiB memory.
        :param _builtins.int disk_number: DiskNumber
        :param _builtins.str local_storage_instance_type: Local SSD instance specifications.
        :param _builtins.int resident_node_number: Resident node number of node group.
        :param _builtins.str spec_type: Compute group specification types include the following:
               - standard
               - ramEnhanced
        :param _builtins.str storage_performance_level: Performance levels of cloud disks include the following values:
               - pl0: Maximum random read/write IOPS per disk is 10,000.
               - pl1: Maximum random read/write IOPS per disk is 50,000.
               - pl2: Maximum random read/write IOPS per disk is 100,000.
               - pl3: Maximum random read/write IOPS per disk is 1,000,000.
        :param _builtins.int storage_size: Storage size, measured in GiB.
        :param _builtins.str zone_id: Zone ID.
        """
        if cu is not None:
            pulumi.set(__self__, "cu", cu)
        if disk_number is not None:
            pulumi.set(__self__, "disk_number", disk_number)
        if local_storage_instance_type is not None:
            pulumi.set(__self__, "local_storage_instance_type", local_storage_instance_type)
        if resident_node_number is not None:
            pulumi.set(__self__, "resident_node_number", resident_node_number)
        if spec_type is not None:
            pulumi.set(__self__, "spec_type", spec_type)
        if storage_performance_level is not None:
            pulumi.set(__self__, "storage_performance_level", storage_performance_level)
        if storage_size is not None:
            pulumi.set(__self__, "storage_size", storage_size)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def cu(self) -> Optional[_builtins.int]:
        """
        Number of CUs. CU (Compute Unit) is the basic measurement unit of the service, where 1 CU = 1 CPU core + 4 GiB memory.
        """
        return pulumi.get(self, "cu")

    @_builtins.property
    @pulumi.getter(name="diskNumber")
    def disk_number(self) -> Optional[_builtins.int]:
        """
        DiskNumber
        """
        return pulumi.get(self, "disk_number")

    @_builtins.property
    @pulumi.getter(name="localStorageInstanceType")
    def local_storage_instance_type(self) -> Optional[_builtins.str]:
        """
        Local SSD instance specifications.
        """
        return pulumi.get(self, "local_storage_instance_type")

    @_builtins.property
    @pulumi.getter(name="residentNodeNumber")
    def resident_node_number(self) -> Optional[_builtins.int]:
        """
        Resident node number of node group.
        """
        return pulumi.get(self, "resident_node_number")

    @_builtins.property
    @pulumi.getter(name="specType")
    def spec_type(self) -> Optional[_builtins.str]:
        """
        Compute group specification types include the following:
        - standard
        - ramEnhanced
        """
        return pulumi.get(self, "spec_type")

    @_builtins.property
    @pulumi.getter(name="storagePerformanceLevel")
    def storage_performance_level(self) -> Optional[_builtins.str]:
        """
        Performance levels of cloud disks include the following values:
        - pl0: Maximum random read/write IOPS per disk is 10,000.
        - pl1: Maximum random read/write IOPS per disk is 50,000.
        - pl2: Maximum random read/write IOPS per disk is 100,000.
        - pl3: Maximum random read/write IOPS per disk is 1,000,000.
        """
        return pulumi.get(self, "storage_performance_level")

    @_builtins.property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> Optional[_builtins.int]:
        """
        Storage size, measured in GiB.
        """
        return pulumi.get(self, "storage_size")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Zone ID.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class StarRocksInstanceObserverNodeGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskNumber":
            suggest = "disk_number"
        elif key == "localStorageInstanceType":
            suggest = "local_storage_instance_type"
        elif key == "residentNodeNumber":
            suggest = "resident_node_number"
        elif key == "specType":
            suggest = "spec_type"
        elif key == "storagePerformanceLevel":
            suggest = "storage_performance_level"
        elif key == "storageSize":
            suggest = "storage_size"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StarRocksInstanceObserverNodeGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StarRocksInstanceObserverNodeGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StarRocksInstanceObserverNodeGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cu: Optional[_builtins.int] = None,
                 disk_number: Optional[_builtins.int] = None,
                 local_storage_instance_type: Optional[_builtins.str] = None,
                 resident_node_number: Optional[_builtins.int] = None,
                 spec_type: Optional[_builtins.str] = None,
                 storage_performance_level: Optional[_builtins.str] = None,
                 storage_size: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int cu: Number of CUs. CU (Compute Unit) is the basic measurement unit of the service, where 1 CU = 1 CPU core + 4 GiB memory.
        :param _builtins.int disk_number: DiskNumber
        :param _builtins.str local_storage_instance_type: Local SSD instance specifications.
        :param _builtins.int resident_node_number: Resident node number of node group.
        :param _builtins.str spec_type: Compute group specification types include the following:
               - standard
        :param _builtins.str storage_performance_level: Performance levels of cloud disks include the following values:
               - pl0: Maximum random read/write IOPS per disk is 10,000.
               - pl1: Maximum random read/write IOPS per disk is 50,000.
               - pl2: Maximum random read/write IOPS per disk is 100,000.
               - pl3: Maximum random read/write IOPS per disk is 1,000,000.
        :param _builtins.int storage_size: Storage size, measured in GiB.
        :param _builtins.str zone_id: Zone ID.
        """
        if cu is not None:
            pulumi.set(__self__, "cu", cu)
        if disk_number is not None:
            pulumi.set(__self__, "disk_number", disk_number)
        if local_storage_instance_type is not None:
            pulumi.set(__self__, "local_storage_instance_type", local_storage_instance_type)
        if resident_node_number is not None:
            pulumi.set(__self__, "resident_node_number", resident_node_number)
        if spec_type is not None:
            pulumi.set(__self__, "spec_type", spec_type)
        if storage_performance_level is not None:
            pulumi.set(__self__, "storage_performance_level", storage_performance_level)
        if storage_size is not None:
            pulumi.set(__self__, "storage_size", storage_size)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def cu(self) -> Optional[_builtins.int]:
        """
        Number of CUs. CU (Compute Unit) is the basic measurement unit of the service, where 1 CU = 1 CPU core + 4 GiB memory.
        """
        return pulumi.get(self, "cu")

    @_builtins.property
    @pulumi.getter(name="diskNumber")
    def disk_number(self) -> Optional[_builtins.int]:
        """
        DiskNumber
        """
        return pulumi.get(self, "disk_number")

    @_builtins.property
    @pulumi.getter(name="localStorageInstanceType")
    def local_storage_instance_type(self) -> Optional[_builtins.str]:
        """
        Local SSD instance specifications.
        """
        return pulumi.get(self, "local_storage_instance_type")

    @_builtins.property
    @pulumi.getter(name="residentNodeNumber")
    def resident_node_number(self) -> Optional[_builtins.int]:
        """
        Resident node number of node group.
        """
        return pulumi.get(self, "resident_node_number")

    @_builtins.property
    @pulumi.getter(name="specType")
    def spec_type(self) -> Optional[_builtins.str]:
        """
        Compute group specification types include the following:
        - standard
        """
        return pulumi.get(self, "spec_type")

    @_builtins.property
    @pulumi.getter(name="storagePerformanceLevel")
    def storage_performance_level(self) -> Optional[_builtins.str]:
        """
        Performance levels of cloud disks include the following values:
        - pl0: Maximum random read/write IOPS per disk is 10,000.
        - pl1: Maximum random read/write IOPS per disk is 50,000.
        - pl2: Maximum random read/write IOPS per disk is 100,000.
        - pl3: Maximum random read/write IOPS per disk is 1,000,000.
        """
        return pulumi.get(self, "storage_performance_level")

    @_builtins.property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> Optional[_builtins.int]:
        """
        Storage size, measured in GiB.
        """
        return pulumi.get(self, "storage_size")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Zone ID.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class StarRocksInstanceVswitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vswitchId":
            suggest = "vswitch_id"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StarRocksInstanceVswitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StarRocksInstanceVswitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StarRocksInstanceVswitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vswitch_id: _builtins.str,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str vswitch_id: ID of VSwitch.
        :param _builtins.str zone_id: Zone ID of VSwitch.
        """
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> _builtins.str:
        """
        ID of VSwitch.
        """
        return pulumi.get(self, "vswitch_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Zone ID of VSwitch.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetMscSubContactsContactResult(dict):
    def __init__(__self__, *,
                 account_uid: _builtins.str,
                 contact_id: _builtins.str,
                 contact_name: _builtins.str,
                 email: _builtins.str,
                 id: _builtins.str,
                 is_account: _builtins.bool,
                 is_obsolete: _builtins.bool,
                 is_verified_email: _builtins.bool,
                 is_verified_mobile: _builtins.bool,
                 last_email_verification_time_stamp: _builtins.str,
                 last_mobile_verification_time_stamp: _builtins.str,
                 mobile: _builtins.str,
                 position: _builtins.str):
        """
        :param _builtins.str account_uid: UID.
        :param _builtins.str contact_id: The first ID of the resource.
        :param _builtins.str contact_name: The User's Contact Name. **Note:** The name must be 2 to 12 characters in length, and can contain uppercase and lowercase letters.
        :param _builtins.str email: The User's Contact Email Address.
        :param _builtins.str id: The ID of the Contact.
        :param _builtins.bool is_account: Indicates Whether the BGP Group Is the Account Itself.
        :param _builtins.bool is_obsolete: Whether They Have Expired Or Not.
        :param _builtins.bool is_verified_email: Email Validation for.
        :param _builtins.bool is_verified_mobile: If the Phone Verification.
        :param _builtins.str last_email_verification_time_stamp: Last Verification Email Transmission Time.
        :param _builtins.str last_mobile_verification_time_stamp: The Pieces of Authentication SMS Sending Time.
        :param _builtins.str mobile: The User's Telephone.
        :param _builtins.str position: The User's Position. Valid values: `CEO`, `Technical Director`, `Maintenance Director`, `Project Director`,`Finance Director` and `Other`.
        """
        pulumi.set(__self__, "account_uid", account_uid)
        pulumi.set(__self__, "contact_id", contact_id)
        pulumi.set(__self__, "contact_name", contact_name)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_account", is_account)
        pulumi.set(__self__, "is_obsolete", is_obsolete)
        pulumi.set(__self__, "is_verified_email", is_verified_email)
        pulumi.set(__self__, "is_verified_mobile", is_verified_mobile)
        pulumi.set(__self__, "last_email_verification_time_stamp", last_email_verification_time_stamp)
        pulumi.set(__self__, "last_mobile_verification_time_stamp", last_mobile_verification_time_stamp)
        pulumi.set(__self__, "mobile", mobile)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="accountUid")
    def account_uid(self) -> _builtins.str:
        """
        UID.
        """
        return pulumi.get(self, "account_uid")

    @_builtins.property
    @pulumi.getter(name="contactId")
    def contact_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "contact_id")

    @_builtins.property
    @pulumi.getter(name="contactName")
    def contact_name(self) -> _builtins.str:
        """
        The User's Contact Name. **Note:** The name must be 2 to 12 characters in length, and can contain uppercase and lowercase letters.
        """
        return pulumi.get(self, "contact_name")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The User's Contact Email Address.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Contact.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAccount")
    def is_account(self) -> _builtins.bool:
        """
        Indicates Whether the BGP Group Is the Account Itself.
        """
        return pulumi.get(self, "is_account")

    @_builtins.property
    @pulumi.getter(name="isObsolete")
    def is_obsolete(self) -> _builtins.bool:
        """
        Whether They Have Expired Or Not.
        """
        return pulumi.get(self, "is_obsolete")

    @_builtins.property
    @pulumi.getter(name="isVerifiedEmail")
    def is_verified_email(self) -> _builtins.bool:
        """
        Email Validation for.
        """
        return pulumi.get(self, "is_verified_email")

    @_builtins.property
    @pulumi.getter(name="isVerifiedMobile")
    def is_verified_mobile(self) -> _builtins.bool:
        """
        If the Phone Verification.
        """
        return pulumi.get(self, "is_verified_mobile")

    @_builtins.property
    @pulumi.getter(name="lastEmailVerificationTimeStamp")
    def last_email_verification_time_stamp(self) -> _builtins.str:
        """
        Last Verification Email Transmission Time.
        """
        return pulumi.get(self, "last_email_verification_time_stamp")

    @_builtins.property
    @pulumi.getter(name="lastMobileVerificationTimeStamp")
    def last_mobile_verification_time_stamp(self) -> _builtins.str:
        """
        The Pieces of Authentication SMS Sending Time.
        """
        return pulumi.get(self, "last_mobile_verification_time_stamp")

    @_builtins.property
    @pulumi.getter
    def mobile(self) -> _builtins.str:
        """
        The User's Telephone.
        """
        return pulumi.get(self, "mobile")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        """
        The User's Position. Valid values: `CEO`, `Technical Director`, `Maintenance Director`, `Project Director`,`Finance Director` and `Other`.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class GetMscSubSubscriptionsSubscriptionResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 contact_ids: Sequence[_builtins.int],
                 description: _builtins.str,
                 email_status: _builtins.int,
                 id: _builtins.str,
                 item_id: _builtins.str,
                 item_name: _builtins.str,
                 pmsg_status: _builtins.int,
                 sms_status: _builtins.int,
                 tts_status: _builtins.int,
                 webhook_ids: Sequence[_builtins.int],
                 webhook_status: _builtins.int):
        """
        :param _builtins.str channel: The channel the Subscription.
        :param Sequence[_builtins.int] contact_ids: The ids of subscribed contacts.
        :param _builtins.str description: The description of the Subscription.
        :param _builtins.int email_status: The status of email subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        :param _builtins.str id: The ID of the Subscription.
        :param _builtins.str item_id: The ID of the Subscription.
        :param _builtins.str item_name: The name of the Subscription.
        :param _builtins.int pmsg_status: The status of pmsg subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        :param _builtins.int sms_status: The status of sms subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        :param _builtins.int tts_status: The status of tts subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        :param Sequence[_builtins.int] webhook_ids: The ids of subscribed webhooks.
        :param _builtins.int webhook_status: The status of webhook subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "contact_ids", contact_ids)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "email_status", email_status)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "item_id", item_id)
        pulumi.set(__self__, "item_name", item_name)
        pulumi.set(__self__, "pmsg_status", pmsg_status)
        pulumi.set(__self__, "sms_status", sms_status)
        pulumi.set(__self__, "tts_status", tts_status)
        pulumi.set(__self__, "webhook_ids", webhook_ids)
        pulumi.set(__self__, "webhook_status", webhook_status)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The channel the Subscription.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="contactIds")
    def contact_ids(self) -> Sequence[_builtins.int]:
        """
        The ids of subscribed contacts.
        """
        return pulumi.get(self, "contact_ids")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the Subscription.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emailStatus")
    def email_status(self) -> _builtins.int:
        """
        The status of email subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        """
        return pulumi.get(self, "email_status")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Subscription.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="itemId")
    def item_id(self) -> _builtins.str:
        """
        The ID of the Subscription.
        """
        return pulumi.get(self, "item_id")

    @_builtins.property
    @pulumi.getter(name="itemName")
    def item_name(self) -> _builtins.str:
        """
        The name of the Subscription.
        """
        return pulumi.get(self, "item_name")

    @_builtins.property
    @pulumi.getter(name="pmsgStatus")
    def pmsg_status(self) -> _builtins.int:
        """
        The status of pmsg subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        """
        return pulumi.get(self, "pmsg_status")

    @_builtins.property
    @pulumi.getter(name="smsStatus")
    def sms_status(self) -> _builtins.int:
        """
        The status of sms subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        """
        return pulumi.get(self, "sms_status")

    @_builtins.property
    @pulumi.getter(name="ttsStatus")
    def tts_status(self) -> _builtins.int:
        """
        The status of tts subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        """
        return pulumi.get(self, "tts_status")

    @_builtins.property
    @pulumi.getter(name="webhookIds")
    def webhook_ids(self) -> Sequence[_builtins.int]:
        """
        The ids of subscribed webhooks.
        """
        return pulumi.get(self, "webhook_ids")

    @_builtins.property
    @pulumi.getter(name="webhookStatus")
    def webhook_status(self) -> _builtins.int:
        """
        The status of webhook subscription. Valid values: `-1`, `-2`, `0`, `1`. `-1` means required, `-2` means banned; `1` means subscribed; `0` means not subscribed.
        """
        return pulumi.get(self, "webhook_status")


@pulumi.output_type
class GetMscSubWebhooksWebhookResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 server_url: _builtins.str,
                 webhook_id: _builtins.str,
                 webhook_name: _builtins.str):
        """
        :param _builtins.str id: The ID of the Webhook.
        :param _builtins.str server_url: The serverUrl of the Subscription.
        :param _builtins.str webhook_id: The first ID of the resource.
        :param _builtins.str webhook_name: The name of the Webhook. **Note:** The name must be `2` to `12` characters in length, and can contain uppercase and lowercase letters.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "server_url", server_url)
        pulumi.set(__self__, "webhook_id", webhook_id)
        pulumi.set(__self__, "webhook_name", webhook_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Webhook.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> _builtins.str:
        """
        The serverUrl of the Subscription.
        """
        return pulumi.get(self, "server_url")

    @_builtins.property
    @pulumi.getter(name="webhookId")
    def webhook_id(self) -> _builtins.str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "webhook_id")

    @_builtins.property
    @pulumi.getter(name="webhookName")
    def webhook_name(self) -> _builtins.str:
        """
        The name of the Webhook. **Note:** The name must be `2` to `12` characters in length, and can contain uppercase and lowercase letters.
        """
        return pulumi.get(self, "webhook_name")


@pulumi.output_type
class GetRegionsRegionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 local_name: _builtins.str,
                 region_id: _builtins.str):
        """
        :param _builtins.str id: ID of the region.
        :param _builtins.str local_name: Name of the region in the local language.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "local_name", local_name)
        pulumi.set(__self__, "region_id", region_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the region.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="localName")
    def local_name(self) -> _builtins.str:
        """
        Name of the region in the local language.
        """
        return pulumi.get(self, "local_name")

    @_builtins.property
    @pulumi.getter(name="regionId")
    def region_id(self) -> _builtins.str:
        return pulumi.get(self, "region_id")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 available_disk_categories: Sequence[_builtins.str],
                 available_instance_types: Sequence[_builtins.str],
                 available_resource_creations: Sequence[_builtins.str],
                 id: _builtins.str,
                 local_name: _builtins.str,
                 multi_zone_ids: Sequence[_builtins.str],
                 slb_slave_zone_ids: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] available_disk_categories: Set of supported disk categories.
        :param Sequence[_builtins.str] available_instance_types: Allowed instance types.
        :param Sequence[_builtins.str] available_resource_creations: Filter the results by a specific resource type.
               Valid values: `Instance`, `Disk`, `VSwitch`, `Rds`, `KVStore`, `FunctionCompute`, `Elasticsearch`, `Slb`.
               
               > **NOTE:** From version 1.134.0, the `available_resource_creation` value "Rds" has been deprecated.
               If you want to fetch the available zones for RDS instance, you can use datasource alicloud_db_zones
        :param _builtins.str id: ID of the zone.
        :param _builtins.str local_name: Name of the zone in the local language.
        :param Sequence[_builtins.str] multi_zone_ids: A list of zone ids in which the multi zone.
        :param Sequence[_builtins.str] slb_slave_zone_ids: A list of slb slave zone ids in which the slb master zone.
        """
        pulumi.set(__self__, "available_disk_categories", available_disk_categories)
        pulumi.set(__self__, "available_instance_types", available_instance_types)
        pulumi.set(__self__, "available_resource_creations", available_resource_creations)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "local_name", local_name)
        pulumi.set(__self__, "multi_zone_ids", multi_zone_ids)
        pulumi.set(__self__, "slb_slave_zone_ids", slb_slave_zone_ids)

    @_builtins.property
    @pulumi.getter(name="availableDiskCategories")
    def available_disk_categories(self) -> Sequence[_builtins.str]:
        """
        Set of supported disk categories.
        """
        return pulumi.get(self, "available_disk_categories")

    @_builtins.property
    @pulumi.getter(name="availableInstanceTypes")
    def available_instance_types(self) -> Sequence[_builtins.str]:
        """
        Allowed instance types.
        """
        return pulumi.get(self, "available_instance_types")

    @_builtins.property
    @pulumi.getter(name="availableResourceCreations")
    def available_resource_creations(self) -> Sequence[_builtins.str]:
        """
        Filter the results by a specific resource type.
        Valid values: `Instance`, `Disk`, `VSwitch`, `Rds`, `KVStore`, `FunctionCompute`, `Elasticsearch`, `Slb`.

        > **NOTE:** From version 1.134.0, the `available_resource_creation` value "Rds" has been deprecated.
        If you want to fetch the available zones for RDS instance, you can use datasource alicloud_db_zones
        """
        return pulumi.get(self, "available_resource_creations")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the zone.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="localName")
    def local_name(self) -> _builtins.str:
        """
        Name of the zone in the local language.
        """
        return pulumi.get(self, "local_name")

    @_builtins.property
    @pulumi.getter(name="multiZoneIds")
    def multi_zone_ids(self) -> Sequence[_builtins.str]:
        """
        A list of zone ids in which the multi zone.
        """
        return pulumi.get(self, "multi_zone_ids")

    @_builtins.property
    @pulumi.getter(name="slbSlaveZoneIds")
    def slb_slave_zone_ids(self) -> Sequence[_builtins.str]:
        """
        A list of slb slave zone ids in which the slb master zone.
        """
        return pulumi.get(self, "slb_slave_zone_ids")


