# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ClusterApplicationConfig',
    'ClusterBootstrapScript',
    'ClusterBootstrapScriptNodeSelector',
    'ClusterNodeAttribute',
    'ClusterNodeGroup',
    'ClusterNodeGroupAckConfig',
    'ClusterNodeGroupAckConfigCustomAnnotation',
    'ClusterNodeGroupAckConfigCustomLabel',
    'ClusterNodeGroupAckConfigNodeSelector',
    'ClusterNodeGroupAckConfigPvc',
    'ClusterNodeGroupAckConfigToleration',
    'ClusterNodeGroupAckConfigVolume',
    'ClusterNodeGroupAckConfigVolumeMount',
    'ClusterNodeGroupAutoScalingPolicy',
    'ClusterNodeGroupAutoScalingPolicyConstraints',
    'ClusterNodeGroupAutoScalingPolicyScalingRule',
    'ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger',
    'ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition',
    'ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTag',
    'ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint',
    'ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger',
    'ClusterNodeGroupCostOptimizedConfig',
    'ClusterNodeGroupDataDisk',
    'ClusterNodeGroupSpotBidPrice',
    'ClusterNodeGroupSubscriptionConfig',
    'ClusterNodeGroupSystemDisk',
    'ClusterSubscriptionConfig',
    'GetClustersClusterResult',
    'GetClustersClusterTagResult',
]

@pulumi.output_type
class ClusterApplicationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "configFileName":
            suggest = "config_file_name"
        elif key == "configItemKey":
            suggest = "config_item_key"
        elif key == "configItemValue":
            suggest = "config_item_value"
        elif key == "configDescription":
            suggest = "config_description"
        elif key == "configScope":
            suggest = "config_scope"
        elif key == "nodeGroupId":
            suggest = "node_group_id"
        elif key == "nodeGroupName":
            suggest = "node_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterApplicationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterApplicationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterApplicationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 config_file_name: str,
                 config_item_key: str,
                 config_item_value: str,
                 config_description: Optional[str] = None,
                 config_scope: Optional[str] = None,
                 node_group_id: Optional[str] = None,
                 node_group_name: Optional[str] = None):
        """
        :param str application_name: The application name of EMR cluster which has installed.
        :param str config_file_name: The configuration file name of application installed.
        :param str config_item_key: The configuration item key of application installed.
        :param str config_item_value: The configuration item value of application installed.
        :param str config_description: The configuration description of application installed.
        :param str config_scope: The configuration scope of emr cluster. Supported value: CLUSTER or NODEGROUP.
        :param str node_group_id: The configuration effected which node group id of emr cluster.
        :param str node_group_name: The configuration effected which node group name of emr cluster.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "config_file_name", config_file_name)
        pulumi.set(__self__, "config_item_key", config_item_key)
        pulumi.set(__self__, "config_item_value", config_item_value)
        if config_description is not None:
            pulumi.set(__self__, "config_description", config_description)
        if config_scope is not None:
            pulumi.set(__self__, "config_scope", config_scope)
        if node_group_id is not None:
            pulumi.set(__self__, "node_group_id", node_group_id)
        if node_group_name is not None:
            pulumi.set(__self__, "node_group_name", node_group_name)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        The application name of EMR cluster which has installed.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="configFileName")
    def config_file_name(self) -> str:
        """
        The configuration file name of application installed.
        """
        return pulumi.get(self, "config_file_name")

    @property
    @pulumi.getter(name="configItemKey")
    def config_item_key(self) -> str:
        """
        The configuration item key of application installed.
        """
        return pulumi.get(self, "config_item_key")

    @property
    @pulumi.getter(name="configItemValue")
    def config_item_value(self) -> str:
        """
        The configuration item value of application installed.
        """
        return pulumi.get(self, "config_item_value")

    @property
    @pulumi.getter(name="configDescription")
    def config_description(self) -> Optional[str]:
        """
        The configuration description of application installed.
        """
        return pulumi.get(self, "config_description")

    @property
    @pulumi.getter(name="configScope")
    def config_scope(self) -> Optional[str]:
        """
        The configuration scope of emr cluster. Supported value: CLUSTER or NODEGROUP.
        """
        return pulumi.get(self, "config_scope")

    @property
    @pulumi.getter(name="nodeGroupId")
    def node_group_id(self) -> Optional[str]:
        """
        The configuration effected which node group id of emr cluster.
        """
        return pulumi.get(self, "node_group_id")

    @property
    @pulumi.getter(name="nodeGroupName")
    def node_group_name(self) -> Optional[str]:
        """
        The configuration effected which node group name of emr cluster.
        """
        return pulumi.get(self, "node_group_name")


@pulumi.output_type
class ClusterBootstrapScript(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionFailStrategy":
            suggest = "execution_fail_strategy"
        elif key == "executionMoment":
            suggest = "execution_moment"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "scriptArgs":
            suggest = "script_args"
        elif key == "scriptName":
            suggest = "script_name"
        elif key == "scriptPath":
            suggest = "script_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBootstrapScript. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBootstrapScript.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBootstrapScript.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_fail_strategy: str,
                 execution_moment: str,
                 node_selector: 'outputs.ClusterBootstrapScriptNodeSelector',
                 script_args: str,
                 script_name: str,
                 script_path: str,
                 priority: Optional[int] = None):
        """
        :param str execution_fail_strategy: The bootstrap scripts execution fail strategy, ’FAILED_BLOCK’ or ‘FAILED_CONTINUE’ .
        :param str execution_moment: The bootstrap scripts execution moment, ’BEFORE_INSTALL’ or ‘AFTER_STARTED’ .
        :param 'ClusterBootstrapScriptNodeSelectorArgs' node_selector: The bootstrap scripts execution target. See `node_selector` below.
        :param str script_args: The bootstrap script args, e.g. "--a=b".
        :param str script_name: The bootstrap script name.
        :param str script_path: The bootstrap script path, e.g. "oss://bucket/path".
        :param int priority: The bootstrap scripts priority.
        """
        pulumi.set(__self__, "execution_fail_strategy", execution_fail_strategy)
        pulumi.set(__self__, "execution_moment", execution_moment)
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "script_args", script_args)
        pulumi.set(__self__, "script_name", script_name)
        pulumi.set(__self__, "script_path", script_path)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="executionFailStrategy")
    def execution_fail_strategy(self) -> str:
        """
        The bootstrap scripts execution fail strategy, ’FAILED_BLOCK’ or ‘FAILED_CONTINUE’ .
        """
        return pulumi.get(self, "execution_fail_strategy")

    @property
    @pulumi.getter(name="executionMoment")
    def execution_moment(self) -> str:
        """
        The bootstrap scripts execution moment, ’BEFORE_INSTALL’ or ‘AFTER_STARTED’ .
        """
        return pulumi.get(self, "execution_moment")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> 'outputs.ClusterBootstrapScriptNodeSelector':
        """
        The bootstrap scripts execution target. See `node_selector` below.
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter(name="scriptArgs")
    def script_args(self) -> str:
        """
        The bootstrap script args, e.g. "--a=b".
        """
        return pulumi.get(self, "script_args")

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> str:
        """
        The bootstrap script name.
        """
        return pulumi.get(self, "script_name")

    @property
    @pulumi.getter(name="scriptPath")
    def script_path(self) -> str:
        """
        The bootstrap script path, e.g. "oss://bucket/path".
        """
        return pulumi.get(self, "script_path")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Field 'priority' has been deprecated from provider version 1.227.0.""")
    def priority(self) -> Optional[int]:
        """
        The bootstrap scripts priority.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class ClusterBootstrapScriptNodeSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelectType":
            suggest = "node_select_type"
        elif key == "nodeGroupId":
            suggest = "node_group_id"
        elif key == "nodeGroupIds":
            suggest = "node_group_ids"
        elif key == "nodeGroupName":
            suggest = "node_group_name"
        elif key == "nodeGroupNames":
            suggest = "node_group_names"
        elif key == "nodeGroupTypes":
            suggest = "node_group_types"
        elif key == "nodeNames":
            suggest = "node_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBootstrapScriptNodeSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBootstrapScriptNodeSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBootstrapScriptNodeSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_select_type: str,
                 node_group_id: Optional[str] = None,
                 node_group_ids: Optional[Sequence[str]] = None,
                 node_group_name: Optional[str] = None,
                 node_group_names: Optional[Sequence[str]] = None,
                 node_group_types: Optional[Sequence[str]] = None,
                 node_names: Optional[Sequence[str]] = None):
        """
        :param str node_select_type: The bootstrap scripts execution target node select type. Supported value: NODE, NODEGROUP or CLUSTER.
        :param Sequence[str] node_group_ids: The bootstrap scripts execution target node group ids.
        :param Sequence[str] node_group_names: The bootstrap scripts execution target node group names.
        :param Sequence[str] node_group_types: The bootstrap scripts execution target node group types.
        :param Sequence[str] node_names: The bootstrap scripts execution target node names.
        """
        pulumi.set(__self__, "node_select_type", node_select_type)
        if node_group_id is not None:
            pulumi.set(__self__, "node_group_id", node_group_id)
        if node_group_ids is not None:
            pulumi.set(__self__, "node_group_ids", node_group_ids)
        if node_group_name is not None:
            pulumi.set(__self__, "node_group_name", node_group_name)
        if node_group_names is not None:
            pulumi.set(__self__, "node_group_names", node_group_names)
        if node_group_types is not None:
            pulumi.set(__self__, "node_group_types", node_group_types)
        if node_names is not None:
            pulumi.set(__self__, "node_names", node_names)

    @property
    @pulumi.getter(name="nodeSelectType")
    def node_select_type(self) -> str:
        """
        The bootstrap scripts execution target node select type. Supported value: NODE, NODEGROUP or CLUSTER.
        """
        return pulumi.get(self, "node_select_type")

    @property
    @pulumi.getter(name="nodeGroupId")
    @_utilities.deprecated("""Field 'node_group_id' has been deprecated from provider version 1.227.0. New field 'node_group_ids' replaces it.""")
    def node_group_id(self) -> Optional[str]:
        return pulumi.get(self, "node_group_id")

    @property
    @pulumi.getter(name="nodeGroupIds")
    def node_group_ids(self) -> Optional[Sequence[str]]:
        """
        The bootstrap scripts execution target node group ids.
        """
        return pulumi.get(self, "node_group_ids")

    @property
    @pulumi.getter(name="nodeGroupName")
    @_utilities.deprecated("""Field 'node_group_name' has been deprecated from provider version 1.227.0. New field 'node_group_names' replaces it.""")
    def node_group_name(self) -> Optional[str]:
        return pulumi.get(self, "node_group_name")

    @property
    @pulumi.getter(name="nodeGroupNames")
    def node_group_names(self) -> Optional[Sequence[str]]:
        """
        The bootstrap scripts execution target node group names.
        """
        return pulumi.get(self, "node_group_names")

    @property
    @pulumi.getter(name="nodeGroupTypes")
    def node_group_types(self) -> Optional[Sequence[str]]:
        """
        The bootstrap scripts execution target node group types.
        """
        return pulumi.get(self, "node_group_types")

    @property
    @pulumi.getter(name="nodeNames")
    def node_names(self) -> Optional[Sequence[str]]:
        """
        The bootstrap scripts execution target node names.
        """
        return pulumi.get(self, "node_names")


@pulumi.output_type
class ClusterNodeAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPairName":
            suggest = "key_pair_name"
        elif key == "ramRole":
            suggest = "ram_role"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "dataDiskEncrypted":
            suggest = "data_disk_encrypted"
        elif key == "dataDiskKmsKeyId":
            suggest = "data_disk_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_pair_name: str,
                 ram_role: str,
                 security_group_id: str,
                 vpc_id: str,
                 zone_id: str,
                 data_disk_encrypted: Optional[bool] = None,
                 data_disk_kms_key_id: Optional[str] = None):
        """
        :param str key_pair_name: The name of the key pair.
        :param str ram_role: Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
        :param str security_group_id: Security Group ID for Cluster.
        :param str vpc_id: Used to retrieve instances belong to specified VPC.
        :param str zone_id: Zone ID, e.g. cn-hangzhou-i
        :param bool data_disk_encrypted: Whether to enable data disk encryption.
        :param str data_disk_kms_key_id: The kms key id used to encrypt the data disk. It takes effect when data_disk_encrypted is true.
        """
        pulumi.set(__self__, "key_pair_name", key_pair_name)
        pulumi.set(__self__, "ram_role", ram_role)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if data_disk_encrypted is not None:
            pulumi.set(__self__, "data_disk_encrypted", data_disk_encrypted)
        if data_disk_kms_key_id is not None:
            pulumi.set(__self__, "data_disk_kms_key_id", data_disk_kms_key_id)

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> str:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter(name="ramRole")
    def ram_role(self) -> str:
        """
        Alicloud EMR uses roles to perform actions on your behalf when provisioning cluster resources, running applications, dynamically scaling resources. EMR uses the following roles when interacting with other Alicloud services. Default value is AliyunEmrEcsDefaultRole.
        """
        return pulumi.get(self, "ram_role")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        Security Group ID for Cluster.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Used to retrieve instances belong to specified VPC.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Zone ID, e.g. cn-hangzhou-i
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="dataDiskEncrypted")
    def data_disk_encrypted(self) -> Optional[bool]:
        """
        Whether to enable data disk encryption.
        """
        return pulumi.get(self, "data_disk_encrypted")

    @property
    @pulumi.getter(name="dataDiskKmsKeyId")
    def data_disk_kms_key_id(self) -> Optional[str]:
        """
        The kms key id used to encrypt the data disk. It takes effect when data_disk_encrypted is true.
        """
        return pulumi.get(self, "data_disk_kms_key_id")


@pulumi.output_type
class ClusterNodeGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDisks":
            suggest = "data_disks"
        elif key == "instanceTypes":
            suggest = "instance_types"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeGroupName":
            suggest = "node_group_name"
        elif key == "nodeGroupType":
            suggest = "node_group_type"
        elif key == "systemDisk":
            suggest = "system_disk"
        elif key == "ackConfig":
            suggest = "ack_config"
        elif key == "additionalSecurityGroupIds":
            suggest = "additional_security_group_ids"
        elif key == "autoScalingPolicy":
            suggest = "auto_scaling_policy"
        elif key == "costOptimizedConfig":
            suggest = "cost_optimized_config"
        elif key == "deploymentSetStrategy":
            suggest = "deployment_set_strategy"
        elif key == "gracefulShutdown":
            suggest = "graceful_shutdown"
        elif key == "nodeResizeStrategy":
            suggest = "node_resize_strategy"
        elif key == "paymentType":
            suggest = "payment_type"
        elif key == "spotBidPrices":
            suggest = "spot_bid_prices"
        elif key == "spotInstanceRemedy":
            suggest = "spot_instance_remedy"
        elif key == "spotStrategy":
            suggest = "spot_strategy"
        elif key == "subscriptionConfig":
            suggest = "subscription_config"
        elif key == "vswitchIds":
            suggest = "vswitch_ids"
        elif key == "withPublicIp":
            suggest = "with_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disks: Sequence['outputs.ClusterNodeGroupDataDisk'],
                 instance_types: Sequence[str],
                 node_count: int,
                 node_group_name: str,
                 node_group_type: str,
                 system_disk: 'outputs.ClusterNodeGroupSystemDisk',
                 ack_config: Optional['outputs.ClusterNodeGroupAckConfig'] = None,
                 additional_security_group_ids: Optional[Sequence[str]] = None,
                 auto_scaling_policy: Optional['outputs.ClusterNodeGroupAutoScalingPolicy'] = None,
                 cost_optimized_config: Optional['outputs.ClusterNodeGroupCostOptimizedConfig'] = None,
                 deployment_set_strategy: Optional[str] = None,
                 graceful_shutdown: Optional[bool] = None,
                 node_resize_strategy: Optional[str] = None,
                 payment_type: Optional[str] = None,
                 spot_bid_prices: Optional[Sequence['outputs.ClusterNodeGroupSpotBidPrice']] = None,
                 spot_instance_remedy: Optional[bool] = None,
                 spot_strategy: Optional[str] = None,
                 subscription_config: Optional['outputs.ClusterNodeGroupSubscriptionConfig'] = None,
                 vswitch_ids: Optional[Sequence[str]] = None,
                 with_public_ip: Optional[bool] = None):
        """
        :param Sequence['ClusterNodeGroupDataDiskArgs'] data_disks: Host Ecs data disks information in this node group. See `data_disks` below.
        :param Sequence[str] instance_types: Host Ecs instance types. **NOTE:** From version 1.236.0, `instance_types` can be modified.
        :param int node_count: Host Ecs number in this node group.
        :param str node_group_name: The node group name of emr cluster.
        :param str node_group_type: The node group type of emr cluster, supported value: MASTER, CORE or TASK. Node group type of GATEWAY is available since v1.219.0.
        :param 'ClusterNodeGroupSystemDiskArgs' system_disk: Host Ecs system disk information in this node group. See `system_disk` below.
        :param 'ClusterNodeGroupAckConfigArgs' ack_config: The node group of ack configuration for emr cluster to deploying on kubernetes. See `ack_config` below.
        :param Sequence[str] additional_security_group_ids: Additional security Group IDS for Cluster, you can also specify this key for each node group. **NOTE:** From version 1.236.0, `additional_security_group_ids` can be modified.
        :param 'ClusterNodeGroupAutoScalingPolicyArgs' auto_scaling_policy: The node group auto scaling policy for emr cluster. See `auto_scaling_policy` below.
        :param 'ClusterNodeGroupCostOptimizedConfigArgs' cost_optimized_config: The detail cost optimized configuration of emr cluster. See `cost_optimized_config` below. **NOTE:** From version 1.236.0, `cost_optimized_config` can be modified.
        :param str deployment_set_strategy: Deployment set strategy for this cluster node group. Supported value: NONE, CLUSTER or NODE_GROUP. **NOTE:** From version 1.236.0, `deployment_set_strategy` can be modified.
        :param bool graceful_shutdown: Enable emr cluster of task node graceful decommission, ’true’ or ‘false’ .
        :param str node_resize_strategy: Node resize strategy for this cluster node group. Supported value: PRIORITY, COST_OPTIMIZED.
        :param str payment_type: Payment Type for this cluster. Supported value: PayAsYouGo or Subscription.
        :param Sequence['ClusterNodeGroupSpotBidPriceArgs'] spot_bid_prices: The spot bid prices of a PayAsYouGo instance. See `spot_bid_prices` below.
        :param bool spot_instance_remedy: Whether to replace spot instances with newly created spot/onDemand instance when receive a spot recycling message.
        :param str spot_strategy: The spot strategy configuration of emr cluster. Valid values: `NoSpot`, `SpotWithPriceLimit`, `SpotAsPriceGo`.
        :param 'ClusterNodeGroupSubscriptionConfigArgs' subscription_config: The detail configuration of subscription payment type. See `subscription_config` below.
        :param Sequence[str] vswitch_ids: Global vSwitch ids, you can also specify it in node group. **NOTE:** From version 1.236.0, `vswitch_ids` can be modified.
        :param bool with_public_ip: Whether the node has a public IP address enabled. **NOTE:** From version 1.236.0, `with_public_ip` can be modified.
        """
        pulumi.set(__self__, "data_disks", data_disks)
        pulumi.set(__self__, "instance_types", instance_types)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_group_name", node_group_name)
        pulumi.set(__self__, "node_group_type", node_group_type)
        pulumi.set(__self__, "system_disk", system_disk)
        if ack_config is not None:
            pulumi.set(__self__, "ack_config", ack_config)
        if additional_security_group_ids is not None:
            pulumi.set(__self__, "additional_security_group_ids", additional_security_group_ids)
        if auto_scaling_policy is not None:
            pulumi.set(__self__, "auto_scaling_policy", auto_scaling_policy)
        if cost_optimized_config is not None:
            pulumi.set(__self__, "cost_optimized_config", cost_optimized_config)
        if deployment_set_strategy is not None:
            pulumi.set(__self__, "deployment_set_strategy", deployment_set_strategy)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if node_resize_strategy is not None:
            pulumi.set(__self__, "node_resize_strategy", node_resize_strategy)
        if payment_type is not None:
            pulumi.set(__self__, "payment_type", payment_type)
        if spot_bid_prices is not None:
            pulumi.set(__self__, "spot_bid_prices", spot_bid_prices)
        if spot_instance_remedy is not None:
            pulumi.set(__self__, "spot_instance_remedy", spot_instance_remedy)
        if spot_strategy is not None:
            pulumi.set(__self__, "spot_strategy", spot_strategy)
        if subscription_config is not None:
            pulumi.set(__self__, "subscription_config", subscription_config)
        if vswitch_ids is not None:
            pulumi.set(__self__, "vswitch_ids", vswitch_ids)
        if with_public_ip is not None:
            pulumi.set(__self__, "with_public_ip", with_public_ip)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.ClusterNodeGroupDataDisk']:
        """
        Host Ecs data disks information in this node group. See `data_disks` below.
        """
        return pulumi.get(self, "data_disks")

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Sequence[str]:
        """
        Host Ecs instance types. **NOTE:** From version 1.236.0, `instance_types` can be modified.
        """
        return pulumi.get(self, "instance_types")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Host Ecs number in this node group.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nodeGroupName")
    def node_group_name(self) -> str:
        """
        The node group name of emr cluster.
        """
        return pulumi.get(self, "node_group_name")

    @property
    @pulumi.getter(name="nodeGroupType")
    def node_group_type(self) -> str:
        """
        The node group type of emr cluster, supported value: MASTER, CORE or TASK. Node group type of GATEWAY is available since v1.219.0.
        """
        return pulumi.get(self, "node_group_type")

    @property
    @pulumi.getter(name="systemDisk")
    def system_disk(self) -> 'outputs.ClusterNodeGroupSystemDisk':
        """
        Host Ecs system disk information in this node group. See `system_disk` below.
        """
        return pulumi.get(self, "system_disk")

    @property
    @pulumi.getter(name="ackConfig")
    def ack_config(self) -> Optional['outputs.ClusterNodeGroupAckConfig']:
        """
        The node group of ack configuration for emr cluster to deploying on kubernetes. See `ack_config` below.
        """
        return pulumi.get(self, "ack_config")

    @property
    @pulumi.getter(name="additionalSecurityGroupIds")
    def additional_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Additional security Group IDS for Cluster, you can also specify this key for each node group. **NOTE:** From version 1.236.0, `additional_security_group_ids` can be modified.
        """
        return pulumi.get(self, "additional_security_group_ids")

    @property
    @pulumi.getter(name="autoScalingPolicy")
    def auto_scaling_policy(self) -> Optional['outputs.ClusterNodeGroupAutoScalingPolicy']:
        """
        The node group auto scaling policy for emr cluster. See `auto_scaling_policy` below.
        """
        return pulumi.get(self, "auto_scaling_policy")

    @property
    @pulumi.getter(name="costOptimizedConfig")
    def cost_optimized_config(self) -> Optional['outputs.ClusterNodeGroupCostOptimizedConfig']:
        """
        The detail cost optimized configuration of emr cluster. See `cost_optimized_config` below. **NOTE:** From version 1.236.0, `cost_optimized_config` can be modified.
        """
        return pulumi.get(self, "cost_optimized_config")

    @property
    @pulumi.getter(name="deploymentSetStrategy")
    def deployment_set_strategy(self) -> Optional[str]:
        """
        Deployment set strategy for this cluster node group. Supported value: NONE, CLUSTER or NODE_GROUP. **NOTE:** From version 1.236.0, `deployment_set_strategy` can be modified.
        """
        return pulumi.get(self, "deployment_set_strategy")

    @property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional[bool]:
        """
        Enable emr cluster of task node graceful decommission, ’true’ or ‘false’ .
        """
        return pulumi.get(self, "graceful_shutdown")

    @property
    @pulumi.getter(name="nodeResizeStrategy")
    def node_resize_strategy(self) -> Optional[str]:
        """
        Node resize strategy for this cluster node group. Supported value: PRIORITY, COST_OPTIMIZED.
        """
        return pulumi.get(self, "node_resize_strategy")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> Optional[str]:
        """
        Payment Type for this cluster. Supported value: PayAsYouGo or Subscription.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="spotBidPrices")
    def spot_bid_prices(self) -> Optional[Sequence['outputs.ClusterNodeGroupSpotBidPrice']]:
        """
        The spot bid prices of a PayAsYouGo instance. See `spot_bid_prices` below.
        """
        return pulumi.get(self, "spot_bid_prices")

    @property
    @pulumi.getter(name="spotInstanceRemedy")
    def spot_instance_remedy(self) -> Optional[bool]:
        """
        Whether to replace spot instances with newly created spot/onDemand instance when receive a spot recycling message.
        """
        return pulumi.get(self, "spot_instance_remedy")

    @property
    @pulumi.getter(name="spotStrategy")
    def spot_strategy(self) -> Optional[str]:
        """
        The spot strategy configuration of emr cluster. Valid values: `NoSpot`, `SpotWithPriceLimit`, `SpotAsPriceGo`.
        """
        return pulumi.get(self, "spot_strategy")

    @property
    @pulumi.getter(name="subscriptionConfig")
    def subscription_config(self) -> Optional['outputs.ClusterNodeGroupSubscriptionConfig']:
        """
        The detail configuration of subscription payment type. See `subscription_config` below.
        """
        return pulumi.get(self, "subscription_config")

    @property
    @pulumi.getter(name="vswitchIds")
    def vswitch_ids(self) -> Optional[Sequence[str]]:
        """
        Global vSwitch ids, you can also specify it in node group. **NOTE:** From version 1.236.0, `vswitch_ids` can be modified.
        """
        return pulumi.get(self, "vswitch_ids")

    @property
    @pulumi.getter(name="withPublicIp")
    def with_public_ip(self) -> Optional[bool]:
        """
        Whether the node has a public IP address enabled. **NOTE:** From version 1.236.0, `with_public_ip` can be modified.
        """
        return pulumi.get(self, "with_public_ip")


@pulumi.output_type
class ClusterNodeGroupAckConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackInstanceId":
            suggest = "ack_instance_id"
        elif key == "limitCpu":
            suggest = "limit_cpu"
        elif key == "limitMemory":
            suggest = "limit_memory"
        elif key == "requestCpu":
            suggest = "request_cpu"
        elif key == "requestMemory":
            suggest = "request_memory"
        elif key == "customAnnotations":
            suggest = "custom_annotations"
        elif key == "customLabels":
            suggest = "custom_labels"
        elif key == "nodeAffinity":
            suggest = "node_affinity"
        elif key == "nodeSelectors":
            suggest = "node_selectors"
        elif key == "podAffinity":
            suggest = "pod_affinity"
        elif key == "podAntiAffinity":
            suggest = "pod_anti_affinity"
        elif key == "preStartCommands":
            suggest = "pre_start_commands"
        elif key == "volumeMounts":
            suggest = "volume_mounts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAckConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAckConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAckConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_instance_id: str,
                 limit_cpu: float,
                 limit_memory: float,
                 namespace: str,
                 request_cpu: float,
                 request_memory: float,
                 custom_annotations: Optional[Sequence['outputs.ClusterNodeGroupAckConfigCustomAnnotation']] = None,
                 custom_labels: Optional[Sequence['outputs.ClusterNodeGroupAckConfigCustomLabel']] = None,
                 node_affinity: Optional[str] = None,
                 node_selectors: Optional[Sequence['outputs.ClusterNodeGroupAckConfigNodeSelector']] = None,
                 pod_affinity: Optional[str] = None,
                 pod_anti_affinity: Optional[str] = None,
                 pre_start_commands: Optional[Sequence[str]] = None,
                 pvcs: Optional[Sequence['outputs.ClusterNodeGroupAckConfigPvc']] = None,
                 tolerations: Optional[Sequence['outputs.ClusterNodeGroupAckConfigToleration']] = None,
                 volume_mounts: Optional[Sequence['outputs.ClusterNodeGroupAckConfigVolumeMount']] = None,
                 volumes: Optional[Sequence['outputs.ClusterNodeGroupAckConfigVolume']] = None):
        """
        :param str ack_instance_id: The ack cluster instance id.
        :param float limit_cpu: The job pod resource of limit cpu.
        :param float limit_memory: The job pod resource of limit memory.
        :param str namespace: The ack cluster namespace.
        :param float request_cpu: The job pod resource of request cpu.
        :param float request_memory: The job pod resource of request memory.
        :param Sequence['ClusterNodeGroupAckConfigCustomAnnotationArgs'] custom_annotations: The ack cluster custom annotations. See `custom_annotations` below.
        :param Sequence['ClusterNodeGroupAckConfigCustomLabelArgs'] custom_labels: The ack cluster custom labels. See `custom_labels` below.
        :param str node_affinity: The ack cluster node affinity.
        :param Sequence['ClusterNodeGroupAckConfigNodeSelectorArgs'] node_selectors: The ack cluster node selectors for job pods scheduling. See `node_selectors` below.
        :param str pod_affinity: The job pod affinity.
        :param str pod_anti_affinity: The job pod anti-affinity.
        :param Sequence[str] pre_start_commands: The job pod pre start command.
        :param Sequence['ClusterNodeGroupAckConfigPvcArgs'] pvcs: The ack cluster persistent volume claim. See `pvcs` below.
        :param Sequence['ClusterNodeGroupAckConfigTolerationArgs'] tolerations: The ack cluster tolerations. See `tolerations` below.
        :param Sequence['ClusterNodeGroupAckConfigVolumeMountArgs'] volume_mounts: The ack cluster volume mounts. See `volume_mounts` below.
        :param Sequence['ClusterNodeGroupAckConfigVolumeArgs'] volumes: The ack cluster volumes. See `volumes` below.
        """
        pulumi.set(__self__, "ack_instance_id", ack_instance_id)
        pulumi.set(__self__, "limit_cpu", limit_cpu)
        pulumi.set(__self__, "limit_memory", limit_memory)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "request_cpu", request_cpu)
        pulumi.set(__self__, "request_memory", request_memory)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_labels is not None:
            pulumi.set(__self__, "custom_labels", custom_labels)
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if node_selectors is not None:
            pulumi.set(__self__, "node_selectors", node_selectors)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)
        if pre_start_commands is not None:
            pulumi.set(__self__, "pre_start_commands", pre_start_commands)
        if pvcs is not None:
            pulumi.set(__self__, "pvcs", pvcs)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="ackInstanceId")
    def ack_instance_id(self) -> str:
        """
        The ack cluster instance id.
        """
        return pulumi.get(self, "ack_instance_id")

    @property
    @pulumi.getter(name="limitCpu")
    def limit_cpu(self) -> float:
        """
        The job pod resource of limit cpu.
        """
        return pulumi.get(self, "limit_cpu")

    @property
    @pulumi.getter(name="limitMemory")
    def limit_memory(self) -> float:
        """
        The job pod resource of limit memory.
        """
        return pulumi.get(self, "limit_memory")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The ack cluster namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="requestCpu")
    def request_cpu(self) -> float:
        """
        The job pod resource of request cpu.
        """
        return pulumi.get(self, "request_cpu")

    @property
    @pulumi.getter(name="requestMemory")
    def request_memory(self) -> float:
        """
        The job pod resource of request memory.
        """
        return pulumi.get(self, "request_memory")

    @property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigCustomAnnotation']]:
        """
        The ack cluster custom annotations. See `custom_annotations` below.
        """
        return pulumi.get(self, "custom_annotations")

    @property
    @pulumi.getter(name="customLabels")
    def custom_labels(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigCustomLabel']]:
        """
        The ack cluster custom labels. See `custom_labels` below.
        """
        return pulumi.get(self, "custom_labels")

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[str]:
        """
        The ack cluster node affinity.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="nodeSelectors")
    def node_selectors(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigNodeSelector']]:
        """
        The ack cluster node selectors for job pods scheduling. See `node_selectors` below.
        """
        return pulumi.get(self, "node_selectors")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[str]:
        """
        The job pod affinity.
        """
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[str]:
        """
        The job pod anti-affinity.
        """
        return pulumi.get(self, "pod_anti_affinity")

    @property
    @pulumi.getter(name="preStartCommands")
    def pre_start_commands(self) -> Optional[Sequence[str]]:
        """
        The job pod pre start command.
        """
        return pulumi.get(self, "pre_start_commands")

    @property
    @pulumi.getter
    def pvcs(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigPvc']]:
        """
        The ack cluster persistent volume claim. See `pvcs` below.
        """
        return pulumi.get(self, "pvcs")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigToleration']]:
        """
        The ack cluster tolerations. See `tolerations` below.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigVolumeMount']]:
        """
        The ack cluster volume mounts. See `volume_mounts` below.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.ClusterNodeGroupAckConfigVolume']]:
        """
        The ack cluster volumes. See `volumes` below.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class ClusterNodeGroupAckConfigCustomAnnotation(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: The tag key for this scaling rule specific metrics trigger.
        :param str value: The tag value for this scaling rule specific metrics trigger.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterNodeGroupAckConfigCustomLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: The tag key for this scaling rule specific metrics trigger.
        :param str value: The tag value for this scaling rule specific metrics trigger.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterNodeGroupAckConfigNodeSelector(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: The tag key for this scaling rule specific metrics trigger.
        :param str value: The tag value for this scaling rule specific metrics trigger.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterNodeGroupAckConfigPvc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDiskSize":
            suggest = "data_disk_size"
        elif key == "dataDiskStorageClass":
            suggest = "data_disk_storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAckConfigPvc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAckConfigPvc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAckConfigPvc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk_size: int,
                 data_disk_storage_class: str,
                 name: str,
                 path: str):
        """
        :param int data_disk_size: The ack cluster job pod data disk size of persistent volume claim.
        :param str data_disk_storage_class: The ack cluster job pod data disk storage class of persistent volume claim.
        :param str name: The name of ack cluster job pod volume mounts.
        :param str path: The path of ack cluster job pod volume mounts.
        """
        pulumi.set(__self__, "data_disk_size", data_disk_size)
        pulumi.set(__self__, "data_disk_storage_class", data_disk_storage_class)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dataDiskSize")
    def data_disk_size(self) -> int:
        """
        The ack cluster job pod data disk size of persistent volume claim.
        """
        return pulumi.get(self, "data_disk_size")

    @property
    @pulumi.getter(name="dataDiskStorageClass")
    def data_disk_storage_class(self) -> str:
        """
        The ack cluster job pod data disk storage class of persistent volume claim.
        """
        return pulumi.get(self, "data_disk_storage_class")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of ack cluster job pod volume mounts.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path of ack cluster job pod volume mounts.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ClusterNodeGroupAckConfigToleration(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: The effect of ack cluster tolerations.
        :param str key: The tag key for this scaling rule specific metrics trigger.
        :param str operator: The operator of ack cluster tolerations.
        :param str value: The tag value for this scaling rule specific metrics trigger.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        The effect of ack cluster tolerations.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator of ack cluster tolerations.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterNodeGroupAckConfigVolume(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 type: str):
        """
        :param str name: The name of ack cluster job pod volume mounts.
        :param str path: The path of ack cluster job pod volume mounts.
        :param str type: The ack cluster job pod volumes type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of ack cluster job pod volume mounts.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path of ack cluster job pod volume mounts.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The ack cluster job pod volumes type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterNodeGroupAckConfigVolumeMount(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str):
        """
        :param str name: The name of ack cluster job pod volume mounts.
        :param str path: The path of ack cluster job pod volume mounts.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of ack cluster job pod volume mounts.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path of ack cluster job pod volume mounts.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingRules":
            suggest = "scaling_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constraints: Optional['outputs.ClusterNodeGroupAutoScalingPolicyConstraints'] = None,
                 scaling_rules: Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRule']] = None):
        """
        :param 'ClusterNodeGroupAutoScalingPolicyConstraintsArgs' constraints: The constraints of auto scaling policy. See `constraints` below.
        :param Sequence['ClusterNodeGroupAutoScalingPolicyScalingRuleArgs'] scaling_rules: The scaling rules of auto scaling policy. See `scaling_rules` below.
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)
        if scaling_rules is not None:
            pulumi.set(__self__, "scaling_rules", scaling_rules)

    @property
    @pulumi.getter
    def constraints(self) -> Optional['outputs.ClusterNodeGroupAutoScalingPolicyConstraints']:
        """
        The constraints of auto scaling policy. See `constraints` below.
        """
        return pulumi.get(self, "constraints")

    @property
    @pulumi.getter(name="scalingRules")
    def scaling_rules(self) -> Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRule']]:
        """
        The scaling rules of auto scaling policy. See `scaling_rules` below.
        """
        return pulumi.get(self, "scaling_rules")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicyConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicyConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicyConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: Optional[int] = None,
                 min_capacity: Optional[int] = None):
        """
        :param int max_capacity: The maximum capacity of constraints for emr node group auto scaling policy.
        :param int min_capacity: The minimum capacity of constraints for emr node group auto scaling policy.
        """
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        """
        The maximum capacity of constraints for emr node group auto scaling policy.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[int]:
        """
        The minimum capacity of constraints for emr node group auto scaling policy.
        """
        return pulumi.get(self, "min_capacity")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyScalingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activityType":
            suggest = "activity_type"
        elif key == "adjustmentValue":
            suggest = "adjustment_value"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "triggerType":
            suggest = "trigger_type"
        elif key == "adjustmentType":
            suggest = "adjustment_type"
        elif key == "metricsTrigger":
            suggest = "metrics_trigger"
        elif key == "minAdjustmentValue":
            suggest = "min_adjustment_value"
        elif key == "timeTrigger":
            suggest = "time_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicyScalingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activity_type: str,
                 adjustment_value: int,
                 rule_name: str,
                 trigger_type: str,
                 adjustment_type: Optional[str] = None,
                 metrics_trigger: Optional['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger'] = None,
                 min_adjustment_value: Optional[int] = None,
                 time_trigger: Optional['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger'] = None):
        """
        :param str activity_type: The activity type of auto scaling policy. Valid values: `SCALE_OUT` and `SCALE_IN`.
        :param int adjustment_value: The adjustment value of auto scaling policy. The value should between 1 and 5000.
        :param str rule_name: The rule name of auto scaling policy.
        :param str trigger_type: The trigger type of auto scaling policy. Valid values: `TIME_TRIGGER` and `METRICS_TRIGGER`.
        :param str adjustment_type: The adjustment type of auto scaling policy. Valid values: `CHANGE_IN_CAPACITY` and `EXACT_CAPACITY`.
        :param 'ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerArgs' metrics_trigger: The trigger metrics of scaling rules for emr node group auto scaling policy. See `metrics_trigger` below.
        :param int min_adjustment_value: The minimum adjustment value of auto scaling policy.
        :param 'ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTriggerArgs' time_trigger: The trigger time of scaling rules for emr node group auto scaling policy. See `time_trigger` below.
        """
        pulumi.set(__self__, "activity_type", activity_type)
        pulumi.set(__self__, "adjustment_value", adjustment_value)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "trigger_type", trigger_type)
        if adjustment_type is not None:
            pulumi.set(__self__, "adjustment_type", adjustment_type)
        if metrics_trigger is not None:
            pulumi.set(__self__, "metrics_trigger", metrics_trigger)
        if min_adjustment_value is not None:
            pulumi.set(__self__, "min_adjustment_value", min_adjustment_value)
        if time_trigger is not None:
            pulumi.set(__self__, "time_trigger", time_trigger)

    @property
    @pulumi.getter(name="activityType")
    def activity_type(self) -> str:
        """
        The activity type of auto scaling policy. Valid values: `SCALE_OUT` and `SCALE_IN`.
        """
        return pulumi.get(self, "activity_type")

    @property
    @pulumi.getter(name="adjustmentValue")
    def adjustment_value(self) -> int:
        """
        The adjustment value of auto scaling policy. The value should between 1 and 5000.
        """
        return pulumi.get(self, "adjustment_value")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        The rule name of auto scaling policy.
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> str:
        """
        The trigger type of auto scaling policy. Valid values: `TIME_TRIGGER` and `METRICS_TRIGGER`.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="adjustmentType")
    def adjustment_type(self) -> Optional[str]:
        """
        The adjustment type of auto scaling policy. Valid values: `CHANGE_IN_CAPACITY` and `EXACT_CAPACITY`.
        """
        return pulumi.get(self, "adjustment_type")

    @property
    @pulumi.getter(name="metricsTrigger")
    def metrics_trigger(self) -> Optional['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger']:
        """
        The trigger metrics of scaling rules for emr node group auto scaling policy. See `metrics_trigger` below.
        """
        return pulumi.get(self, "metrics_trigger")

    @property
    @pulumi.getter(name="minAdjustmentValue")
    def min_adjustment_value(self) -> Optional[int]:
        """
        The minimum adjustment value of auto scaling policy.
        """
        return pulumi.get(self, "min_adjustment_value")

    @property
    @pulumi.getter(name="timeTrigger")
    def time_trigger(self) -> Optional['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger']:
        """
        The trigger time of scaling rules for emr node group auto scaling policy. See `time_trigger` below.
        """
        return pulumi.get(self, "time_trigger")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationCount":
            suggest = "evaluation_count"
        elif key == "timeWindow":
            suggest = "time_window"
        elif key == "conditionLogicOperator":
            suggest = "condition_logic_operator"
        elif key == "coolDownInterval":
            suggest = "cool_down_interval"
        elif key == "timeConstraints":
            suggest = "time_constraints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_count: int,
                 time_window: int,
                 condition_logic_operator: Optional[str] = None,
                 conditions: Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition']] = None,
                 cool_down_interval: Optional[int] = None,
                 time_constraints: Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint']] = None):
        """
        :param int evaluation_count: The evaluation count for this scaling rule specific metrics trigger.
        :param int time_window: The time window for this scaling rule specific metrics trigger.
        :param str condition_logic_operator: The condition logic operator for this scaling rule specific metrics trigger. Valid values: `And` and `Or`.
        :param Sequence['ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionArgs'] conditions: The conditions for this scaling rule specific metrics trigger. See `conditions` below.
        :param int cool_down_interval: The time of cool down interval for this scaling rule specific metrics trigger.
        :param Sequence['ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraintArgs'] time_constraints: The time constraints for this scaling rule specific metrics trigger. See `time_constraints` below.
        """
        pulumi.set(__self__, "evaluation_count", evaluation_count)
        pulumi.set(__self__, "time_window", time_window)
        if condition_logic_operator is not None:
            pulumi.set(__self__, "condition_logic_operator", condition_logic_operator)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if cool_down_interval is not None:
            pulumi.set(__self__, "cool_down_interval", cool_down_interval)
        if time_constraints is not None:
            pulumi.set(__self__, "time_constraints", time_constraints)

    @property
    @pulumi.getter(name="evaluationCount")
    def evaluation_count(self) -> int:
        """
        The evaluation count for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "evaluation_count")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> int:
        """
        The time window for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "time_window")

    @property
    @pulumi.getter(name="conditionLogicOperator")
    def condition_logic_operator(self) -> Optional[str]:
        """
        The condition logic operator for this scaling rule specific metrics trigger. Valid values: `And` and `Or`.
        """
        return pulumi.get(self, "condition_logic_operator")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition']]:
        """
        The conditions for this scaling rule specific metrics trigger. See `conditions` below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="coolDownInterval")
    def cool_down_interval(self) -> Optional[int]:
        """
        The time of cool down interval for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "cool_down_interval")

    @property
    @pulumi.getter(name="timeConstraints")
    def time_constraints(self) -> Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint']]:
        """
        The time constraints for this scaling rule specific metrics trigger. See `time_constraints` below.
        """
        return pulumi.get(self, "time_constraints")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 metric_name: str,
                 statistics: str,
                 threshold: float,
                 tags: Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTag']] = None):
        """
        :param str comparison_operator: The comparison operator for this scaling rule specific metrics trigger. Invalid values: `EQ`, `NE`, `GT`, `LT`, `GE`, `LE`.
        :param str metric_name: The metric name for this scaling rule specific metrics trigger.
        :param str statistics: The statistics for this scaling rule specific metrics trigger.
        :param float threshold: The threshold for this scaling rule specific metrics trigger.
        :param Sequence['ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTagArgs'] tags: A mapping of tags to assign to the resource.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "threshold", threshold)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The comparison operator for this scaling rule specific metrics trigger. Invalid values: `EQ`, `NE`, `GT`, `LT`, `GE`, `LE`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The metric name for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def statistics(self) -> str:
        """
        The statistics for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "statistics")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTag']]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: The tag key for this scaling rule specific metrics trigger.
        :param str value: The tag value for this scaling rule specific metrics trigger.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param str end_time: The end time for this scaling rule specific metrics trigger.
        :param str start_time: The start time for this scaling rule specific metrics trigger.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The end time for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        The start time for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTime":
            suggest = "launch_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "launchExpirationTime":
            suggest = "launch_expiration_time"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "recurrenceValue":
            suggest = "recurrence_value"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_time: str,
                 end_time: Optional[str] = None,
                 launch_expiration_time: Optional[int] = None,
                 recurrence_type: Optional[str] = None,
                 recurrence_value: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param str launch_time: The launch time for this scaling rule specific time trigger.
        :param str end_time: The end time for this scaling rule specific metrics trigger.
        :param int launch_expiration_time: The launch expiration time for this scaling rule specific time trigger. The value should between 0 and 3600.
        :param str recurrence_type: The recurrence type for this scaling rule specific time trigger. Valid values: `MINUTELY`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        :param str recurrence_value: The recurrence value for this scaling rule specific time trigger.
        :param str start_time: The start time for this scaling rule specific metrics trigger.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if launch_expiration_time is not None:
            pulumi.set(__self__, "launch_expiration_time", launch_expiration_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> str:
        """
        The launch time for this scaling rule specific time trigger.
        """
        return pulumi.get(self, "launch_time")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The end time for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="launchExpirationTime")
    def launch_expiration_time(self) -> Optional[int]:
        """
        The launch expiration time for this scaling rule specific time trigger. The value should between 0 and 3600.
        """
        return pulumi.get(self, "launch_expiration_time")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[str]:
        """
        The recurrence type for this scaling rule specific time trigger. Valid values: `MINUTELY`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[str]:
        """
        The recurrence value for this scaling rule specific time trigger.
        """
        return pulumi.get(self, "recurrence_value")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        The start time for this scaling rule specific metrics trigger.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ClusterNodeGroupCostOptimizedConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotInstancePools":
            suggest = "spot_instance_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupCostOptimizedConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupCostOptimizedConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupCostOptimizedConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_base_capacity: int,
                 on_demand_percentage_above_base_capacity: int,
                 spot_instance_pools: int):
        """
        :param int on_demand_base_capacity: The cost optimized configuration which on demand based capacity.
        :param int on_demand_percentage_above_base_capacity: The cost optimized configuration which on demand percentage above based capacity.
        :param int spot_instance_pools: The cost optimized configuration with spot instance pools.
        """
        pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> int:
        """
        The cost optimized configuration which on demand based capacity.
        """
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> int:
        """
        The cost optimized configuration which on demand percentage above based capacity.
        """
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> int:
        """
        The cost optimized configuration with spot instance pools.
        """
        return pulumi.get(self, "spot_instance_pools")


@pulumi.output_type
class ClusterNodeGroupDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performanceLevel":
            suggest = "performance_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 size: int,
                 count: Optional[int] = None,
                 performance_level: Optional[str] = None):
        """
        :param str category: The type of the data disk. Valid values: `cloud_efficiency`, `cloud_essd`, `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro`. **NOTE:** Since version v1.230.0, the categories `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro` are available.
        :param int size: The size of a data disk, at least 40. Unit: GiB.
        :param int count: The count of a data disk.
        :param str performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "size", size)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if performance_level is not None:
            pulumi.set(__self__, "performance_level", performance_level)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The type of the data disk. Valid values: `cloud_efficiency`, `cloud_essd`, `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro`. **NOTE:** Since version v1.230.0, the categories `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro` are available.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The count of a data disk.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity.
        """
        return pulumi.get(self, "performance_level")


@pulumi.output_type
class ClusterNodeGroupSpotBidPrice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bidPrice":
            suggest = "bid_price"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupSpotBidPrice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupSpotBidPrice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupSpotBidPrice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bid_price: int,
                 instance_type: str):
        """
        :param int bid_price: The spot bid price of a PayAsYouGo instance.
        :param str instance_type: Host Ecs instance type.
        """
        pulumi.set(__self__, "bid_price", bid_price)
        pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> int:
        """
        The spot bid price of a PayAsYouGo instance.
        """
        return pulumi.get(self, "bid_price")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Host Ecs instance type.
        """
        return pulumi.get(self, "instance_type")


@pulumi.output_type
class ClusterNodeGroupSubscriptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paymentDuration":
            suggest = "payment_duration"
        elif key == "paymentDurationUnit":
            suggest = "payment_duration_unit"
        elif key == "autoPayOrder":
            suggest = "auto_pay_order"
        elif key == "autoRenew":
            suggest = "auto_renew"
        elif key == "autoRenewDuration":
            suggest = "auto_renew_duration"
        elif key == "autoRenewDurationUnit":
            suggest = "auto_renew_duration_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupSubscriptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupSubscriptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupSubscriptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payment_duration: int,
                 payment_duration_unit: str,
                 auto_pay_order: Optional[bool] = None,
                 auto_renew: Optional[bool] = None,
                 auto_renew_duration: Optional[int] = None,
                 auto_renew_duration_unit: Optional[str] = None):
        """
        :param int payment_duration: If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        :param str payment_duration_unit: If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        :param bool auto_pay_order: Auto pay order for payment type of subscription, ’true’ or ‘false’ .  Default value is ’true’.
        :param bool auto_renew: Auto renew for prepaid, ’true’ or ‘false’ . Default value: false.
        :param int auto_renew_duration: If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        :param str auto_renew_duration_unit: If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        """
        pulumi.set(__self__, "payment_duration", payment_duration)
        pulumi.set(__self__, "payment_duration_unit", payment_duration_unit)
        if auto_pay_order is not None:
            pulumi.set(__self__, "auto_pay_order", auto_pay_order)
        if auto_renew is not None:
            pulumi.set(__self__, "auto_renew", auto_renew)
        if auto_renew_duration is not None:
            pulumi.set(__self__, "auto_renew_duration", auto_renew_duration)
        if auto_renew_duration_unit is not None:
            pulumi.set(__self__, "auto_renew_duration_unit", auto_renew_duration_unit)

    @property
    @pulumi.getter(name="paymentDuration")
    def payment_duration(self) -> int:
        """
        If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        """
        return pulumi.get(self, "payment_duration")

    @property
    @pulumi.getter(name="paymentDurationUnit")
    def payment_duration_unit(self) -> str:
        """
        If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        """
        return pulumi.get(self, "payment_duration_unit")

    @property
    @pulumi.getter(name="autoPayOrder")
    def auto_pay_order(self) -> Optional[bool]:
        """
        Auto pay order for payment type of subscription, ’true’ or ‘false’ .  Default value is ’true’.
        """
        return pulumi.get(self, "auto_pay_order")

    @property
    @pulumi.getter(name="autoRenew")
    def auto_renew(self) -> Optional[bool]:
        """
        Auto renew for prepaid, ’true’ or ‘false’ . Default value: false.
        """
        return pulumi.get(self, "auto_renew")

    @property
    @pulumi.getter(name="autoRenewDuration")
    def auto_renew_duration(self) -> Optional[int]:
        """
        If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        """
        return pulumi.get(self, "auto_renew_duration")

    @property
    @pulumi.getter(name="autoRenewDurationUnit")
    def auto_renew_duration_unit(self) -> Optional[str]:
        """
        If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        """
        return pulumi.get(self, "auto_renew_duration_unit")


@pulumi.output_type
class ClusterNodeGroupSystemDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performanceLevel":
            suggest = "performance_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeGroupSystemDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeGroupSystemDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeGroupSystemDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 size: int,
                 count: Optional[int] = None,
                 performance_level: Optional[str] = None):
        """
        :param str category: The type of the data disk. Valid values: `cloud_efficiency`, `cloud_essd`, `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro`. **NOTE:** Since version v1.230.0, the categories `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro` are available.
        :param int size: The size of a data disk, at least 40. Unit: GiB.
        :param int count: The count of a data disk.
        :param str performance_level: Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "size", size)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if performance_level is not None:
            pulumi.set(__self__, "performance_level", performance_level)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The type of the data disk. Valid values: `cloud_efficiency`, `cloud_essd`, `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro`. **NOTE:** Since version v1.230.0, the categories `cloud`, `local_hdd_pro`, `local_disk`, `local_ssd_pro` are available.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of a data disk, at least 40. Unit: GiB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The count of a data disk.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="performanceLevel")
    def performance_level(self) -> Optional[str]:
        """
        Worker node data disk performance level, when `category` values `cloud_essd`, the optional values are `PL0`, `PL1`, `PL2` or `PL3`, but the specific performance level is related to the disk capacity.
        """
        return pulumi.get(self, "performance_level")


@pulumi.output_type
class ClusterSubscriptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paymentDuration":
            suggest = "payment_duration"
        elif key == "paymentDurationUnit":
            suggest = "payment_duration_unit"
        elif key == "autoPayOrder":
            suggest = "auto_pay_order"
        elif key == "autoRenew":
            suggest = "auto_renew"
        elif key == "autoRenewDuration":
            suggest = "auto_renew_duration"
        elif key == "autoRenewDurationUnit":
            suggest = "auto_renew_duration_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSubscriptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSubscriptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSubscriptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payment_duration: int,
                 payment_duration_unit: str,
                 auto_pay_order: Optional[bool] = None,
                 auto_renew: Optional[bool] = None,
                 auto_renew_duration: Optional[int] = None,
                 auto_renew_duration_unit: Optional[str] = None):
        """
        :param int payment_duration: If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        :param str payment_duration_unit: If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        :param bool auto_pay_order: Auto pay order for payment type of subscription, ’true’ or ‘false’ .  Default value is ’true’.
        :param bool auto_renew: Auto renew for prepaid, ’true’ or ‘false’ . Default value: false.
        :param int auto_renew_duration: If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        :param str auto_renew_duration_unit: If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        """
        pulumi.set(__self__, "payment_duration", payment_duration)
        pulumi.set(__self__, "payment_duration_unit", payment_duration_unit)
        if auto_pay_order is not None:
            pulumi.set(__self__, "auto_pay_order", auto_pay_order)
        if auto_renew is not None:
            pulumi.set(__self__, "auto_renew", auto_renew)
        if auto_renew_duration is not None:
            pulumi.set(__self__, "auto_renew_duration", auto_renew_duration)
        if auto_renew_duration_unit is not None:
            pulumi.set(__self__, "auto_renew_duration_unit", auto_renew_duration_unit)

    @property
    @pulumi.getter(name="paymentDuration")
    def payment_duration(self) -> int:
        """
        If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        """
        return pulumi.get(self, "payment_duration")

    @property
    @pulumi.getter(name="paymentDurationUnit")
    def payment_duration_unit(self) -> str:
        """
        If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        """
        return pulumi.get(self, "payment_duration_unit")

    @property
    @pulumi.getter(name="autoPayOrder")
    def auto_pay_order(self) -> Optional[bool]:
        """
        Auto pay order for payment type of subscription, ’true’ or ‘false’ .  Default value is ’true’.
        """
        return pulumi.get(self, "auto_pay_order")

    @property
    @pulumi.getter(name="autoRenew")
    def auto_renew(self) -> Optional[bool]:
        """
        Auto renew for prepaid, ’true’ or ‘false’ . Default value: false.
        """
        return pulumi.get(self, "auto_renew")

    @property
    @pulumi.getter(name="autoRenewDuration")
    def auto_renew_duration(self) -> Optional[int]:
        """
        If paymentType is Subscription, this should be specified. Supported value: 1、2、3、4、5、6、7、8、9、12、24、36、48.
        """
        return pulumi.get(self, "auto_renew_duration")

    @property
    @pulumi.getter(name="autoRenewDurationUnit")
    def auto_renew_duration_unit(self) -> Optional[str]:
        """
        If paymentType is Subscription, this should be specified. Supported value: Month or Year.
        """
        return pulumi.get(self, "auto_renew_duration_unit")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 cluster_state: str,
                 cluster_type: str,
                 create_time: str,
                 emr_default_role: str,
                 end_time: str,
                 expire_time: str,
                 payment_type: str,
                 ready_time: str,
                 release_version: str,
                 resource_group_id: str,
                 state_change_reason: Mapping[str, str],
                 tags: Sequence['outputs.GetClustersClusterTagResult']):
        """
        :param str cluster_id: The first ID of the resource.
        :param str cluster_name: The cluster name.
        :param str cluster_state: The state of the emr cluster.
        :param str cluster_type: The type of the emr cluster.
        :param str create_time: The creation time of the resource.
        :param str emr_default_role: The ecs default role belongs to this emr cluster.
        :param str end_time: The end time of the resource.
        :param str expire_time: The expire time of the resource.
        :param str payment_type: The payment type of the emr cluster.
        :param str ready_time: The ready time of the resource.
        :param str release_version: The release version of the resource.
        :param str resource_group_id: The Resource Group ID.
        :param Mapping[str, str] state_change_reason: The cluster state change reason.
        :param Sequence['GetClustersClusterTagArgs'] tags: A mapping of tags to assign to the resource.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_state", cluster_state)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "emr_default_role", emr_default_role)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "payment_type", payment_type)
        pulumi.set(__self__, "ready_time", ready_time)
        pulumi.set(__self__, "release_version", release_version)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "state_change_reason", state_change_reason)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The cluster name.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterState")
    def cluster_state(self) -> str:
        """
        The state of the emr cluster.
        """
        return pulumi.get(self, "cluster_state")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        The type of the emr cluster.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="emrDefaultRole")
    def emr_default_role(self) -> str:
        """
        The ecs default role belongs to this emr cluster.
        """
        return pulumi.get(self, "emr_default_role")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the resource.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> str:
        """
        The expire time of the resource.
        """
        return pulumi.get(self, "expire_time")

    @property
    @pulumi.getter(name="paymentType")
    def payment_type(self) -> str:
        """
        The payment type of the emr cluster.
        """
        return pulumi.get(self, "payment_type")

    @property
    @pulumi.getter(name="readyTime")
    def ready_time(self) -> str:
        """
        The ready time of the resource.
        """
        return pulumi.get(self, "ready_time")

    @property
    @pulumi.getter(name="releaseVersion")
    def release_version(self) -> str:
        """
        The release version of the resource.
        """
        return pulumi.get(self, "release_version")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The Resource Group ID.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="stateChangeReason")
    def state_change_reason(self) -> Mapping[str, str]:
        """
        The cluster state change reason.
        """
        return pulumi.get(self, "state_change_reason")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClustersClusterTagResult']:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetClustersClusterTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


