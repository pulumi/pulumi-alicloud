// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.amqp.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ExchangeState extends com.pulumi.resources.ResourceArgs {

    public static final ExchangeState Empty = new ExchangeState();

    /**
     * The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
     * 
     */
    @Import(name="alternateExchange")
    private @Nullable Output<String> alternateExchange;

    /**
     * @return The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
     * 
     */
    public Optional<Output<String>> alternateExchange() {
        return Optional.ofNullable(this.alternateExchange);
    }

    /**
     * Specifies whether the Auto Delete attribute is configured. Valid values:
     * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
     * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
     * 
     */
    @Import(name="autoDeleteState")
    private @Nullable Output<Boolean> autoDeleteState;

    /**
     * @return Specifies whether the Auto Delete attribute is configured. Valid values:
     * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
     * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
     * 
     */
    public Optional<Output<Boolean>> autoDeleteState() {
        return Optional.ofNullable(this.autoDeleteState);
    }

    /**
     * The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
     * 
     */
    @Import(name="exchangeName")
    private @Nullable Output<String> exchangeName;

    /**
     * @return The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
     * 
     */
    public Optional<Output<String>> exchangeName() {
        return Optional.ofNullable(this.exchangeName);
    }

    /**
     * The type of the exchange. Valid values:
     * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
     * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
     * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
     * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
     *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
     *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
     *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
     * 
     */
    @Import(name="exchangeType")
    private @Nullable Output<String> exchangeType;

    /**
     * @return The type of the exchange. Valid values:
     * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
     * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
     * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
     * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
     *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
     *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
     *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
     * 
     */
    public Optional<Output<String>> exchangeType() {
        return Optional.ofNullable(this.exchangeType);
    }

    /**
     * The ID of the instance.
     * 
     */
    @Import(name="instanceId")
    private @Nullable Output<String> instanceId;

    /**
     * @return The ID of the instance.
     * 
     */
    public Optional<Output<String>> instanceId() {
        return Optional.ofNullable(this.instanceId);
    }

    /**
     * Specifies whether an exchange is an internal exchange. Valid values:
     * * false: The exchange is not an internal exchange.
     * * true: The exchange is an internal exchange.
     * 
     */
    @Import(name="internal")
    private @Nullable Output<Boolean> internal;

    /**
     * @return Specifies whether an exchange is an internal exchange. Valid values:
     * * false: The exchange is not an internal exchange.
     * * true: The exchange is an internal exchange.
     * 
     */
    public Optional<Output<Boolean>> internal() {
        return Optional.ofNullable(this.internal);
    }

    /**
     * The name of virtual host where an exchange resides.
     * 
     */
    @Import(name="virtualHostName")
    private @Nullable Output<String> virtualHostName;

    /**
     * @return The name of virtual host where an exchange resides.
     * 
     */
    public Optional<Output<String>> virtualHostName() {
        return Optional.ofNullable(this.virtualHostName);
    }

    private ExchangeState() {}

    private ExchangeState(ExchangeState $) {
        this.alternateExchange = $.alternateExchange;
        this.autoDeleteState = $.autoDeleteState;
        this.exchangeName = $.exchangeName;
        this.exchangeType = $.exchangeType;
        this.instanceId = $.instanceId;
        this.internal = $.internal;
        this.virtualHostName = $.virtualHostName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ExchangeState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ExchangeState $;

        public Builder() {
            $ = new ExchangeState();
        }

        public Builder(ExchangeState defaults) {
            $ = new ExchangeState(Objects.requireNonNull(defaults));
        }

        /**
         * @param alternateExchange The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
         * 
         * @return builder
         * 
         */
        public Builder alternateExchange(@Nullable Output<String> alternateExchange) {
            $.alternateExchange = alternateExchange;
            return this;
        }

        /**
         * @param alternateExchange The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
         * 
         * @return builder
         * 
         */
        public Builder alternateExchange(String alternateExchange) {
            return alternateExchange(Output.of(alternateExchange));
        }

        /**
         * @param autoDeleteState Specifies whether the Auto Delete attribute is configured. Valid values:
         * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
         * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
         * 
         * @return builder
         * 
         */
        public Builder autoDeleteState(@Nullable Output<Boolean> autoDeleteState) {
            $.autoDeleteState = autoDeleteState;
            return this;
        }

        /**
         * @param autoDeleteState Specifies whether the Auto Delete attribute is configured. Valid values:
         * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
         * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
         * 
         * @return builder
         * 
         */
        public Builder autoDeleteState(Boolean autoDeleteState) {
            return autoDeleteState(Output.of(autoDeleteState));
        }

        /**
         * @param exchangeName The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
         * 
         * @return builder
         * 
         */
        public Builder exchangeName(@Nullable Output<String> exchangeName) {
            $.exchangeName = exchangeName;
            return this;
        }

        /**
         * @param exchangeName The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
         * 
         * @return builder
         * 
         */
        public Builder exchangeName(String exchangeName) {
            return exchangeName(Output.of(exchangeName));
        }

        /**
         * @param exchangeType The type of the exchange. Valid values:
         * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
         * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
         * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
         * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
         *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
         *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
         *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
         * 
         * @return builder
         * 
         */
        public Builder exchangeType(@Nullable Output<String> exchangeType) {
            $.exchangeType = exchangeType;
            return this;
        }

        /**
         * @param exchangeType The type of the exchange. Valid values:
         * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
         * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
         * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
         * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
         *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
         *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
         *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
         * 
         * @return builder
         * 
         */
        public Builder exchangeType(String exchangeType) {
            return exchangeType(Output.of(exchangeType));
        }

        /**
         * @param instanceId The ID of the instance.
         * 
         * @return builder
         * 
         */
        public Builder instanceId(@Nullable Output<String> instanceId) {
            $.instanceId = instanceId;
            return this;
        }

        /**
         * @param instanceId The ID of the instance.
         * 
         * @return builder
         * 
         */
        public Builder instanceId(String instanceId) {
            return instanceId(Output.of(instanceId));
        }

        /**
         * @param internal Specifies whether an exchange is an internal exchange. Valid values:
         * * false: The exchange is not an internal exchange.
         * * true: The exchange is an internal exchange.
         * 
         * @return builder
         * 
         */
        public Builder internal(@Nullable Output<Boolean> internal) {
            $.internal = internal;
            return this;
        }

        /**
         * @param internal Specifies whether an exchange is an internal exchange. Valid values:
         * * false: The exchange is not an internal exchange.
         * * true: The exchange is an internal exchange.
         * 
         * @return builder
         * 
         */
        public Builder internal(Boolean internal) {
            return internal(Output.of(internal));
        }

        /**
         * @param virtualHostName The name of virtual host where an exchange resides.
         * 
         * @return builder
         * 
         */
        public Builder virtualHostName(@Nullable Output<String> virtualHostName) {
            $.virtualHostName = virtualHostName;
            return this;
        }

        /**
         * @param virtualHostName The name of virtual host where an exchange resides.
         * 
         * @return builder
         * 
         */
        public Builder virtualHostName(String virtualHostName) {
            return virtualHostName(Output.of(virtualHostName));
        }

        public ExchangeState build() {
            return $;
        }
    }

}
