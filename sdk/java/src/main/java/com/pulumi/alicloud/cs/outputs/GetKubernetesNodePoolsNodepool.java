// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.cs.outputs;

import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolDataDisk;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolKubeletConfiguration;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolLabel;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolManagement;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolPrivatePoolOptions;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolScalingConfig;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolSpotPriceLimit;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolTaint;
import com.pulumi.alicloud.cs.outputs.GetKubernetesNodePoolsNodepoolTeeConfig;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetKubernetesNodePoolsNodepool {
    /**
     * @return Whether to enable automatic renewal for nodes in the node pool takes effect only when `instance_charge_type` is set to `PrePaid`. Default value: `false`. Valid values:- `true`: Automatic renewal. - `false`: Do not renew automatically.
     * 
     */
    private Boolean autoRenew;
    /**
     * @return The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When `PeriodUnit = Month`, the value range is {1, 2, 3, 6, 12}. Default value: 1.
     * 
     */
    private Integer autoRenewPeriod;
    /**
     * @return Whether enable worker node to support cis security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. Use `security_hardening_os` instead.
     * 
     */
    private Boolean cisEnabled;
    /**
     * @return Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set `multi_az_policy` to `COST_OPTIMIZED`. Valid values: `true`: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. `false`: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
     * 
     */
    private Boolean compensateWithOnDemand;
    /**
     * @return Node CPU management policies. Default value: `none`. When the cluster version is 1.12.6 or later, the following two policies are supported:- `static`: allows pods with certain resource characteristics on the node to enhance its CPU affinity and exclusivity.- `none`: Enables the existing default CPU affinity scheme.
     * 
     */
    private String cpuPolicy;
    /**
     * @return Configure the data disk of the node in the node pool.
     * 
     */
    private List<GetKubernetesNodePoolsNodepoolDataDisk> dataDisks;
    /**
     * @return The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
     * 
     */
    private String deploymentSetId;
    /**
     * @return Number of expected nodes in the node pool.
     * 
     */
    private String desiredSize;
    /**
     * @return The custom image ID. The system-provided image is used by default.
     * 
     */
    private String imageId;
    /**
     * @return The operating system image type and the `platform` parameter can be selected from the following values:- `AliyunLinux` : Alinux2 image.- `AliyunLinux3` : Alinux3 image.- `AliyunLinux3Arm64` : Alinux3 mirror ARM version.- `AliyunLinuxUEFI` : Alinux2 Image UEFI version.- `CentOS` : CentOS image.- `Windows` : Windows image.- `WindowsCore` : WindowsCore image.- `ContainerOS` : container-optimized image.- `Ubuntu`: Ubuntu image.
     * 
     */
    private String imageType;
    /**
     * @return Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: `false`. Valid values:- `true` : install cloud monitoring on the ECS node.- `false` : does not install cloud monitoring on the ECS node.
     * 
     */
    private Boolean installCloudMonitor;
    /**
     * @return Node payment type. Valid values: `PostPaid`, `PrePaid`, default is `PostPaid`. If value is `PrePaid`, the arguments `period`, `period_unit`, `auto_renew` and `auto_renew_period` are required.
     * 
     */
    private String instanceChargeType;
    /**
     * @return In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
     * 
     */
    private List<String> instanceTypes;
    /**
     * @return The billing method for network usage. Valid values `PayByBandwidth` and `PayByTraffic`. Conflict with `eip_internet_charge_type`, EIP and public network IP can only choose one.
     * 
     */
    private String internetChargeType;
    /**
     * @return The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:\[1,100\]
     * 
     */
    private Integer internetMaxBandwidthOut;
    /**
     * @return The name of the key pair. When the node pool is a managed node pool, only `key_name` is supported.
     * 
     */
    private String keyName;
    /**
     * @return Kubelet configuration parameters for worker nodes. See `kubelet_configuration` below. More information in [Kubelet Configuration](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/).
     * 
     */
    private GetKubernetesNodePoolsNodepoolKubeletConfiguration kubeletConfiguration;
    /**
     * @return A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in [Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).
     * 
     */
    private List<GetKubernetesNodePoolsNodepoolLabel> labels;
    /**
     * @return Whether the ECS instance is logged on as a ecs-user user. Valid value: `true` and `false`.
     * 
     */
    private Boolean loginAsNonRoot;
    /**
     * @return Managed node pool configuration.
     * 
     */
    private GetKubernetesNodePoolsNodepoolManagement management;
    /**
     * @return The scaling policy for ECS instances in a multi-zone scaling group. Valid value: `PRIORITY`, `COST_OPTIMIZED` and `BALANCE`. `PRIORITY`: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. `COST_OPTIMIZED`: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the `CompensateWithOnDemand` parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. `BALANCE`: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API RebalanceInstances to balance resources.
     * 
     */
    private String multiAzPolicy;
    /**
     * @return Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is `customized,,ip,`.- The prefix and suffix can be composed of one or more parts separated by &#39;.&#39;, each part can use lowercase letters, numbers and &#39;-&#39;, and the beginning and end of the node name must be lowercase letters and numbers.- The node IP address is the complete private IP address of the node.- For example, if the string `customized,aliyun,ip,com` is passed in (where &#39;customized&#39; and &#39;ip&#39; are fixed strings, &#39;aliyun&#39; is the prefix, and &#39;com&#39; is the suffix), the name of the node is `aliyun192.168.xxx.xxxcom`.
     * 
     */
    private String nodeNameMode;
    /**
     * @return The first ID of the resource.
     * 
     */
    private String nodePoolId;
    /**
     * @return The name of node pool.
     * 
     */
    private String nodePoolName;
    /**
     * @return The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
     * 
     */
    private String onDemandBaseCapacity;
    /**
     * @return The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.
     * 
     */
    private String onDemandPercentageAboveBaseCapacity;
    /**
     * @return The password of ssh login. You have to specify one of `password` and `key_name` fields. The password rule is 8 to 30 characters and contains at least three items (upper and lower case letters, numbers, and special symbols).
     * 
     */
    private String password;
    /**
     * @return Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
     * 
     */
    private Integer period;
    /**
     * @return Node payment period unit, valid value: `Month`. Default is `Month`.
     * 
     */
    private String periodUnit;
    /**
     * @return Operating system release, using `image_type` instead.
     * 
     */
    private String platform;
    /**
     * @return Node pre custom data, base64-encoded, the script executed before the node is initialized.
     * 
     */
    private String preUserData;
    /**
     * @return Private node pool configuration.
     * 
     */
    private GetKubernetesNodePoolsNodepoolPrivatePoolOptions privatePoolOptions;
    /**
     * @return The name of the Worker RAM role.* If it is empty, the default Worker RAM role created in the cluster will be used.* If the specified RAM role is not empty, the specified RAM role must be a **Common Service role**, and its **trusted service** configuration must be **cloud server**. For more information, see [Create a common service role](https://help.aliyun.com/document_detail/116800.html). If the specified RAM role is not the default Worker RAM role created in the cluster, the role name cannot start with &#39;KubernetesMasterRole-&#39;or &#39;KubernetesWorkerRole.&gt; **NOTE:**  This parameter is only supported for ACK-managed clusters of 1.22 or later versions.
     * 
     */
    private String ramRoleName;
    /**
     * @return The list of RDS instances.
     * 
     */
    private List<String> rdsInstances;
    /**
     * @return The ID of the resource group
     * 
     */
    private String resourceGroupId;
    /**
     * @return The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see [Comparison of Docker, containerd, and Sandboxed-Container](https://www.alibabacloud.com/help/doc-detail/160313.htm).
     * 
     */
    private String runtimeName;
    /**
     * @return The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
     * 
     */
    private String runtimeVersion;
    /**
     * @return Automatic scaling configuration.
     * 
     */
    private GetKubernetesNodePoolsNodepoolScalingConfig scalingConfig;
    /**
     * @return The ID of the scaling group.
     * 
     */
    private String scalingGroupId;
    /**
     * @return Scaling group mode, default value: `release`. Valid values:- `release`: in the standard mode, scaling is performed by creating and releasing ECS instances based on the usage of the application resource value.- `recycle`: in the speed mode, scaling is performed through creation, shutdown, and startup to increase the speed of scaling again (computing resources are not charged during shutdown, only storage fees are charged, except for local disk models).
     * 
     */
    private String scalingPolicy;
    /**
     * @return The security group ID of the node pool. This field has been replaced by `security_group_ids`, please use the `security_group_ids` field instead.
     * 
     */
    private String securityGroupId;
    /**
     * @return Multiple security groups can be configured for a node pool. If both `security_group_ids` and `security_group_id` are configured, `security_group_ids` takes effect. This field cannot be modified.
     * 
     */
    private List<String> securityGroupIds;
    /**
     * @return Alibaba Cloud OS security reinforcement. Default value: `false`. Value:-`true`: enable Alibaba Cloud OS security reinforcement.-`false`: does not enable Alibaba Cloud OS security reinforcement.
     * 
     */
    private Boolean securityHardeningOs;
    /**
     * @return Whether enable worker node to support soc security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. See [SOC Reinforcement](https://help.aliyun.com/document_detail/196148.html).&gt; It is forbidden to set both `security_hardening_os` and `soc_enabled` to `true` at the same time.
     * 
     */
    private Boolean socEnabled;
    /**
     * @return The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
     * 
     */
    private Integer spotInstancePools;
    /**
     * @return Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: `true`: enables the supplementation of preemptible instances. `false`: disables the supplementation of preemptible instances.
     * 
     */
    private Boolean spotInstanceRemedy;
    /**
     * @return The current single preemptible instance type market price range configuration.
     * 
     */
    private List<GetKubernetesNodePoolsNodepoolSpotPriceLimit> spotPriceLimits;
    /**
     * @return The preemptible instance type. Value:- `NoSpot` : Non-preemptible instance.- `SpotWithPriceLimit` : Set the upper limit of the preemptible instance price.- `SpotAsPriceGo` : The system automatically bids, following the actual price of the current market.
     * 
     */
    private String spotStrategy;
    /**
     * @return Specifies whether to enable the burst feature for system disks. Valid values:`true`: enables the burst feature. `false`: disables the burst feature. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    private Boolean systemDiskBurstingEnabled;
    /**
     * @return The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values see `system_disk_category`.
     * 
     */
    private List<String> systemDiskCategories;
    /**
     * @return The category of the system disk for nodes. Default value: `cloud_efficiency`. Valid values:- `cloud`: basic disk.- `cloud_efficiency`: ultra disk.- `cloud_ssd`: standard SSD.- `cloud_essd`: ESSD.- `cloud_auto`: ESSD AutoPL disk.- `cloud_essd_entry`: ESSD Entry disk.
     * 
     */
    private String systemDiskCategory;
    /**
     * @return The encryption algorithm used by the system disk. Value range: aes-256.
     * 
     */
    private String systemDiskEncryptAlgorithm;
    /**
     * @return Whether to encrypt the system disk. Value range: `true`: encryption. `false`: Do not encrypt.
     * 
     */
    private Boolean systemDiskEncrypted;
    /**
     * @return The ID of the KMS key used by the system disk.
     * 
     */
    private String systemDiskKmsKey;
    /**
     * @return The system disk performance of the node takes effect only for the ESSD disk.- `PL0`: maximum random read/write IOPS 10000 for a single disk.- `PL1`: maximum random read/write IOPS 50000 for a single disk.- `PL2`: highest random read/write IOPS 100000 for a single disk.- `PL3`: maximum random read/write IOPS 1 million for a single disk.
     * 
     */
    private String systemDiskPerformanceLevel;
    /**
     * @return The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    private Integer systemDiskProvisionedIops;
    /**
     * @return The size of the system disk. Unit: GiB. The value of this parameter must be at least 1 and greater than or equal to the image size. Default value: 40 or the size of the image, whichever is larger.- Basic disk: 20 to 500.- ESSD (cloud_essd): The valid values vary based on the performance level of the ESSD. PL0 ESSD: 1 to 2048. PL1 ESSD: 20 to 2048. PL2 ESSD: 461 to 2048. PL3 ESSD: 1261 to 2048.- ESSD AutoPL disk (cloud_auto): 1 to 2048.- Other disk categories: 20 to 2048.
     * 
     */
    private Integer systemDiskSize;
    /**
     * @return The ID of the automatic snapshot policy used by the system disk.
     * 
     */
    private String systemDiskSnapshotPolicyId;
    /**
     * @return Add tags only for ECS instances. The maximum length of the tag key is 128 characters. The tag key and value cannot start with aliyun or acs:, or contain https:// or http://.
     * 
     */
    private Map<String,String> tags;
    /**
     * @return A List of Kubernetes taints to assign to the nodes. Detailed below. More information in [Taints and Toleration](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
     * 
     */
    private List<GetKubernetesNodePoolsNodepoolTaint> taints;
    /**
     * @return The configuration about confidential computing for the cluster.
     * 
     */
    private GetKubernetesNodePoolsNodepoolTeeConfig teeConfig;
    /**
     * @return Whether the node after expansion can be scheduled.
     * 
     */
    private Boolean unschedulable;
    /**
     * @return Node custom data, base64-encoded.
     * 
     */
    private String userData;
    /**
     * @return The vswitches used by node pool workers.
     * 
     */
    private List<String> vswitchIds;

    private GetKubernetesNodePoolsNodepool() {}
    /**
     * @return Whether to enable automatic renewal for nodes in the node pool takes effect only when `instance_charge_type` is set to `PrePaid`. Default value: `false`. Valid values:- `true`: Automatic renewal. - `false`: Do not renew automatically.
     * 
     */
    public Boolean autoRenew() {
        return this.autoRenew;
    }
    /**
     * @return The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When `PeriodUnit = Month`, the value range is {1, 2, 3, 6, 12}. Default value: 1.
     * 
     */
    public Integer autoRenewPeriod() {
        return this.autoRenewPeriod;
    }
    /**
     * @return Whether enable worker node to support cis security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. Use `security_hardening_os` instead.
     * 
     */
    public Boolean cisEnabled() {
        return this.cisEnabled;
    }
    /**
     * @return Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set `multi_az_policy` to `COST_OPTIMIZED`. Valid values: `true`: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. `false`: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
     * 
     */
    public Boolean compensateWithOnDemand() {
        return this.compensateWithOnDemand;
    }
    /**
     * @return Node CPU management policies. Default value: `none`. When the cluster version is 1.12.6 or later, the following two policies are supported:- `static`: allows pods with certain resource characteristics on the node to enhance its CPU affinity and exclusivity.- `none`: Enables the existing default CPU affinity scheme.
     * 
     */
    public String cpuPolicy() {
        return this.cpuPolicy;
    }
    /**
     * @return Configure the data disk of the node in the node pool.
     * 
     */
    public List<GetKubernetesNodePoolsNodepoolDataDisk> dataDisks() {
        return this.dataDisks;
    }
    /**
     * @return The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
     * 
     */
    public String deploymentSetId() {
        return this.deploymentSetId;
    }
    /**
     * @return Number of expected nodes in the node pool.
     * 
     */
    public String desiredSize() {
        return this.desiredSize;
    }
    /**
     * @return The custom image ID. The system-provided image is used by default.
     * 
     */
    public String imageId() {
        return this.imageId;
    }
    /**
     * @return The operating system image type and the `platform` parameter can be selected from the following values:- `AliyunLinux` : Alinux2 image.- `AliyunLinux3` : Alinux3 image.- `AliyunLinux3Arm64` : Alinux3 mirror ARM version.- `AliyunLinuxUEFI` : Alinux2 Image UEFI version.- `CentOS` : CentOS image.- `Windows` : Windows image.- `WindowsCore` : WindowsCore image.- `ContainerOS` : container-optimized image.- `Ubuntu`: Ubuntu image.
     * 
     */
    public String imageType() {
        return this.imageType;
    }
    /**
     * @return Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: `false`. Valid values:- `true` : install cloud monitoring on the ECS node.- `false` : does not install cloud monitoring on the ECS node.
     * 
     */
    public Boolean installCloudMonitor() {
        return this.installCloudMonitor;
    }
    /**
     * @return Node payment type. Valid values: `PostPaid`, `PrePaid`, default is `PostPaid`. If value is `PrePaid`, the arguments `period`, `period_unit`, `auto_renew` and `auto_renew_period` are required.
     * 
     */
    public String instanceChargeType() {
        return this.instanceChargeType;
    }
    /**
     * @return In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
     * 
     */
    public List<String> instanceTypes() {
        return this.instanceTypes;
    }
    /**
     * @return The billing method for network usage. Valid values `PayByBandwidth` and `PayByTraffic`. Conflict with `eip_internet_charge_type`, EIP and public network IP can only choose one.
     * 
     */
    public String internetChargeType() {
        return this.internetChargeType;
    }
    /**
     * @return The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:\[1,100\]
     * 
     */
    public Integer internetMaxBandwidthOut() {
        return this.internetMaxBandwidthOut;
    }
    /**
     * @return The name of the key pair. When the node pool is a managed node pool, only `key_name` is supported.
     * 
     */
    public String keyName() {
        return this.keyName;
    }
    /**
     * @return Kubelet configuration parameters for worker nodes. See `kubelet_configuration` below. More information in [Kubelet Configuration](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/).
     * 
     */
    public GetKubernetesNodePoolsNodepoolKubeletConfiguration kubeletConfiguration() {
        return this.kubeletConfiguration;
    }
    /**
     * @return A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in [Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).
     * 
     */
    public List<GetKubernetesNodePoolsNodepoolLabel> labels() {
        return this.labels;
    }
    /**
     * @return Whether the ECS instance is logged on as a ecs-user user. Valid value: `true` and `false`.
     * 
     */
    public Boolean loginAsNonRoot() {
        return this.loginAsNonRoot;
    }
    /**
     * @return Managed node pool configuration.
     * 
     */
    public GetKubernetesNodePoolsNodepoolManagement management() {
        return this.management;
    }
    /**
     * @return The scaling policy for ECS instances in a multi-zone scaling group. Valid value: `PRIORITY`, `COST_OPTIMIZED` and `BALANCE`. `PRIORITY`: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. `COST_OPTIMIZED`: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the `CompensateWithOnDemand` parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. `BALANCE`: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API RebalanceInstances to balance resources.
     * 
     */
    public String multiAzPolicy() {
        return this.multiAzPolicy;
    }
    /**
     * @return Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is `customized,,ip,`.- The prefix and suffix can be composed of one or more parts separated by &#39;.&#39;, each part can use lowercase letters, numbers and &#39;-&#39;, and the beginning and end of the node name must be lowercase letters and numbers.- The node IP address is the complete private IP address of the node.- For example, if the string `customized,aliyun,ip,com` is passed in (where &#39;customized&#39; and &#39;ip&#39; are fixed strings, &#39;aliyun&#39; is the prefix, and &#39;com&#39; is the suffix), the name of the node is `aliyun192.168.xxx.xxxcom`.
     * 
     */
    public String nodeNameMode() {
        return this.nodeNameMode;
    }
    /**
     * @return The first ID of the resource.
     * 
     */
    public String nodePoolId() {
        return this.nodePoolId;
    }
    /**
     * @return The name of node pool.
     * 
     */
    public String nodePoolName() {
        return this.nodePoolName;
    }
    /**
     * @return The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
     * 
     */
    public String onDemandBaseCapacity() {
        return this.onDemandBaseCapacity;
    }
    /**
     * @return The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.
     * 
     */
    public String onDemandPercentageAboveBaseCapacity() {
        return this.onDemandPercentageAboveBaseCapacity;
    }
    /**
     * @return The password of ssh login. You have to specify one of `password` and `key_name` fields. The password rule is 8 to 30 characters and contains at least three items (upper and lower case letters, numbers, and special symbols).
     * 
     */
    public String password() {
        return this.password;
    }
    /**
     * @return Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
     * 
     */
    public Integer period() {
        return this.period;
    }
    /**
     * @return Node payment period unit, valid value: `Month`. Default is `Month`.
     * 
     */
    public String periodUnit() {
        return this.periodUnit;
    }
    /**
     * @return Operating system release, using `image_type` instead.
     * 
     */
    public String platform() {
        return this.platform;
    }
    /**
     * @return Node pre custom data, base64-encoded, the script executed before the node is initialized.
     * 
     */
    public String preUserData() {
        return this.preUserData;
    }
    /**
     * @return Private node pool configuration.
     * 
     */
    public GetKubernetesNodePoolsNodepoolPrivatePoolOptions privatePoolOptions() {
        return this.privatePoolOptions;
    }
    /**
     * @return The name of the Worker RAM role.* If it is empty, the default Worker RAM role created in the cluster will be used.* If the specified RAM role is not empty, the specified RAM role must be a **Common Service role**, and its **trusted service** configuration must be **cloud server**. For more information, see [Create a common service role](https://help.aliyun.com/document_detail/116800.html). If the specified RAM role is not the default Worker RAM role created in the cluster, the role name cannot start with &#39;KubernetesMasterRole-&#39;or &#39;KubernetesWorkerRole.&gt; **NOTE:**  This parameter is only supported for ACK-managed clusters of 1.22 or later versions.
     * 
     */
    public String ramRoleName() {
        return this.ramRoleName;
    }
    /**
     * @return The list of RDS instances.
     * 
     */
    public List<String> rdsInstances() {
        return this.rdsInstances;
    }
    /**
     * @return The ID of the resource group
     * 
     */
    public String resourceGroupId() {
        return this.resourceGroupId;
    }
    /**
     * @return The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see [Comparison of Docker, containerd, and Sandboxed-Container](https://www.alibabacloud.com/help/doc-detail/160313.htm).
     * 
     */
    public String runtimeName() {
        return this.runtimeName;
    }
    /**
     * @return The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
     * 
     */
    public String runtimeVersion() {
        return this.runtimeVersion;
    }
    /**
     * @return Automatic scaling configuration.
     * 
     */
    public GetKubernetesNodePoolsNodepoolScalingConfig scalingConfig() {
        return this.scalingConfig;
    }
    /**
     * @return The ID of the scaling group.
     * 
     */
    public String scalingGroupId() {
        return this.scalingGroupId;
    }
    /**
     * @return Scaling group mode, default value: `release`. Valid values:- `release`: in the standard mode, scaling is performed by creating and releasing ECS instances based on the usage of the application resource value.- `recycle`: in the speed mode, scaling is performed through creation, shutdown, and startup to increase the speed of scaling again (computing resources are not charged during shutdown, only storage fees are charged, except for local disk models).
     * 
     */
    public String scalingPolicy() {
        return this.scalingPolicy;
    }
    /**
     * @return The security group ID of the node pool. This field has been replaced by `security_group_ids`, please use the `security_group_ids` field instead.
     * 
     */
    public String securityGroupId() {
        return this.securityGroupId;
    }
    /**
     * @return Multiple security groups can be configured for a node pool. If both `security_group_ids` and `security_group_id` are configured, `security_group_ids` takes effect. This field cannot be modified.
     * 
     */
    public List<String> securityGroupIds() {
        return this.securityGroupIds;
    }
    /**
     * @return Alibaba Cloud OS security reinforcement. Default value: `false`. Value:-`true`: enable Alibaba Cloud OS security reinforcement.-`false`: does not enable Alibaba Cloud OS security reinforcement.
     * 
     */
    public Boolean securityHardeningOs() {
        return this.securityHardeningOs;
    }
    /**
     * @return Whether enable worker node to support soc security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. See [SOC Reinforcement](https://help.aliyun.com/document_detail/196148.html).&gt; It is forbidden to set both `security_hardening_os` and `soc_enabled` to `true` at the same time.
     * 
     */
    public Boolean socEnabled() {
        return this.socEnabled;
    }
    /**
     * @return The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
     * 
     */
    public Integer spotInstancePools() {
        return this.spotInstancePools;
    }
    /**
     * @return Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: `true`: enables the supplementation of preemptible instances. `false`: disables the supplementation of preemptible instances.
     * 
     */
    public Boolean spotInstanceRemedy() {
        return this.spotInstanceRemedy;
    }
    /**
     * @return The current single preemptible instance type market price range configuration.
     * 
     */
    public List<GetKubernetesNodePoolsNodepoolSpotPriceLimit> spotPriceLimits() {
        return this.spotPriceLimits;
    }
    /**
     * @return The preemptible instance type. Value:- `NoSpot` : Non-preemptible instance.- `SpotWithPriceLimit` : Set the upper limit of the preemptible instance price.- `SpotAsPriceGo` : The system automatically bids, following the actual price of the current market.
     * 
     */
    public String spotStrategy() {
        return this.spotStrategy;
    }
    /**
     * @return Specifies whether to enable the burst feature for system disks. Valid values:`true`: enables the burst feature. `false`: disables the burst feature. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    public Boolean systemDiskBurstingEnabled() {
        return this.systemDiskBurstingEnabled;
    }
    /**
     * @return The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values see `system_disk_category`.
     * 
     */
    public List<String> systemDiskCategories() {
        return this.systemDiskCategories;
    }
    /**
     * @return The category of the system disk for nodes. Default value: `cloud_efficiency`. Valid values:- `cloud`: basic disk.- `cloud_efficiency`: ultra disk.- `cloud_ssd`: standard SSD.- `cloud_essd`: ESSD.- `cloud_auto`: ESSD AutoPL disk.- `cloud_essd_entry`: ESSD Entry disk.
     * 
     */
    public String systemDiskCategory() {
        return this.systemDiskCategory;
    }
    /**
     * @return The encryption algorithm used by the system disk. Value range: aes-256.
     * 
     */
    public String systemDiskEncryptAlgorithm() {
        return this.systemDiskEncryptAlgorithm;
    }
    /**
     * @return Whether to encrypt the system disk. Value range: `true`: encryption. `false`: Do not encrypt.
     * 
     */
    public Boolean systemDiskEncrypted() {
        return this.systemDiskEncrypted;
    }
    /**
     * @return The ID of the KMS key used by the system disk.
     * 
     */
    public String systemDiskKmsKey() {
        return this.systemDiskKmsKey;
    }
    /**
     * @return The system disk performance of the node takes effect only for the ESSD disk.- `PL0`: maximum random read/write IOPS 10000 for a single disk.- `PL1`: maximum random read/write IOPS 50000 for a single disk.- `PL2`: highest random read/write IOPS 100000 for a single disk.- `PL3`: maximum random read/write IOPS 1 million for a single disk.
     * 
     */
    public String systemDiskPerformanceLevel() {
        return this.systemDiskPerformanceLevel;
    }
    /**
     * @return The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    public Integer systemDiskProvisionedIops() {
        return this.systemDiskProvisionedIops;
    }
    /**
     * @return The size of the system disk. Unit: GiB. The value of this parameter must be at least 1 and greater than or equal to the image size. Default value: 40 or the size of the image, whichever is larger.- Basic disk: 20 to 500.- ESSD (cloud_essd): The valid values vary based on the performance level of the ESSD. PL0 ESSD: 1 to 2048. PL1 ESSD: 20 to 2048. PL2 ESSD: 461 to 2048. PL3 ESSD: 1261 to 2048.- ESSD AutoPL disk (cloud_auto): 1 to 2048.- Other disk categories: 20 to 2048.
     * 
     */
    public Integer systemDiskSize() {
        return this.systemDiskSize;
    }
    /**
     * @return The ID of the automatic snapshot policy used by the system disk.
     * 
     */
    public String systemDiskSnapshotPolicyId() {
        return this.systemDiskSnapshotPolicyId;
    }
    /**
     * @return Add tags only for ECS instances. The maximum length of the tag key is 128 characters. The tag key and value cannot start with aliyun or acs:, or contain https:// or http://.
     * 
     */
    public Map<String,String> tags() {
        return this.tags;
    }
    /**
     * @return A List of Kubernetes taints to assign to the nodes. Detailed below. More information in [Taints and Toleration](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/).
     * 
     */
    public List<GetKubernetesNodePoolsNodepoolTaint> taints() {
        return this.taints;
    }
    /**
     * @return The configuration about confidential computing for the cluster.
     * 
     */
    public GetKubernetesNodePoolsNodepoolTeeConfig teeConfig() {
        return this.teeConfig;
    }
    /**
     * @return Whether the node after expansion can be scheduled.
     * 
     */
    public Boolean unschedulable() {
        return this.unschedulable;
    }
    /**
     * @return Node custom data, base64-encoded.
     * 
     */
    public String userData() {
        return this.userData;
    }
    /**
     * @return The vswitches used by node pool workers.
     * 
     */
    public List<String> vswitchIds() {
        return this.vswitchIds;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetKubernetesNodePoolsNodepool defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean autoRenew;
        private Integer autoRenewPeriod;
        private Boolean cisEnabled;
        private Boolean compensateWithOnDemand;
        private String cpuPolicy;
        private List<GetKubernetesNodePoolsNodepoolDataDisk> dataDisks;
        private String deploymentSetId;
        private String desiredSize;
        private String imageId;
        private String imageType;
        private Boolean installCloudMonitor;
        private String instanceChargeType;
        private List<String> instanceTypes;
        private String internetChargeType;
        private Integer internetMaxBandwidthOut;
        private String keyName;
        private GetKubernetesNodePoolsNodepoolKubeletConfiguration kubeletConfiguration;
        private List<GetKubernetesNodePoolsNodepoolLabel> labels;
        private Boolean loginAsNonRoot;
        private GetKubernetesNodePoolsNodepoolManagement management;
        private String multiAzPolicy;
        private String nodeNameMode;
        private String nodePoolId;
        private String nodePoolName;
        private String onDemandBaseCapacity;
        private String onDemandPercentageAboveBaseCapacity;
        private String password;
        private Integer period;
        private String periodUnit;
        private String platform;
        private String preUserData;
        private GetKubernetesNodePoolsNodepoolPrivatePoolOptions privatePoolOptions;
        private String ramRoleName;
        private List<String> rdsInstances;
        private String resourceGroupId;
        private String runtimeName;
        private String runtimeVersion;
        private GetKubernetesNodePoolsNodepoolScalingConfig scalingConfig;
        private String scalingGroupId;
        private String scalingPolicy;
        private String securityGroupId;
        private List<String> securityGroupIds;
        private Boolean securityHardeningOs;
        private Boolean socEnabled;
        private Integer spotInstancePools;
        private Boolean spotInstanceRemedy;
        private List<GetKubernetesNodePoolsNodepoolSpotPriceLimit> spotPriceLimits;
        private String spotStrategy;
        private Boolean systemDiskBurstingEnabled;
        private List<String> systemDiskCategories;
        private String systemDiskCategory;
        private String systemDiskEncryptAlgorithm;
        private Boolean systemDiskEncrypted;
        private String systemDiskKmsKey;
        private String systemDiskPerformanceLevel;
        private Integer systemDiskProvisionedIops;
        private Integer systemDiskSize;
        private String systemDiskSnapshotPolicyId;
        private Map<String,String> tags;
        private List<GetKubernetesNodePoolsNodepoolTaint> taints;
        private GetKubernetesNodePoolsNodepoolTeeConfig teeConfig;
        private Boolean unschedulable;
        private String userData;
        private List<String> vswitchIds;
        public Builder() {}
        public Builder(GetKubernetesNodePoolsNodepool defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoRenew = defaults.autoRenew;
    	      this.autoRenewPeriod = defaults.autoRenewPeriod;
    	      this.cisEnabled = defaults.cisEnabled;
    	      this.compensateWithOnDemand = defaults.compensateWithOnDemand;
    	      this.cpuPolicy = defaults.cpuPolicy;
    	      this.dataDisks = defaults.dataDisks;
    	      this.deploymentSetId = defaults.deploymentSetId;
    	      this.desiredSize = defaults.desiredSize;
    	      this.imageId = defaults.imageId;
    	      this.imageType = defaults.imageType;
    	      this.installCloudMonitor = defaults.installCloudMonitor;
    	      this.instanceChargeType = defaults.instanceChargeType;
    	      this.instanceTypes = defaults.instanceTypes;
    	      this.internetChargeType = defaults.internetChargeType;
    	      this.internetMaxBandwidthOut = defaults.internetMaxBandwidthOut;
    	      this.keyName = defaults.keyName;
    	      this.kubeletConfiguration = defaults.kubeletConfiguration;
    	      this.labels = defaults.labels;
    	      this.loginAsNonRoot = defaults.loginAsNonRoot;
    	      this.management = defaults.management;
    	      this.multiAzPolicy = defaults.multiAzPolicy;
    	      this.nodeNameMode = defaults.nodeNameMode;
    	      this.nodePoolId = defaults.nodePoolId;
    	      this.nodePoolName = defaults.nodePoolName;
    	      this.onDemandBaseCapacity = defaults.onDemandBaseCapacity;
    	      this.onDemandPercentageAboveBaseCapacity = defaults.onDemandPercentageAboveBaseCapacity;
    	      this.password = defaults.password;
    	      this.period = defaults.period;
    	      this.periodUnit = defaults.periodUnit;
    	      this.platform = defaults.platform;
    	      this.preUserData = defaults.preUserData;
    	      this.privatePoolOptions = defaults.privatePoolOptions;
    	      this.ramRoleName = defaults.ramRoleName;
    	      this.rdsInstances = defaults.rdsInstances;
    	      this.resourceGroupId = defaults.resourceGroupId;
    	      this.runtimeName = defaults.runtimeName;
    	      this.runtimeVersion = defaults.runtimeVersion;
    	      this.scalingConfig = defaults.scalingConfig;
    	      this.scalingGroupId = defaults.scalingGroupId;
    	      this.scalingPolicy = defaults.scalingPolicy;
    	      this.securityGroupId = defaults.securityGroupId;
    	      this.securityGroupIds = defaults.securityGroupIds;
    	      this.securityHardeningOs = defaults.securityHardeningOs;
    	      this.socEnabled = defaults.socEnabled;
    	      this.spotInstancePools = defaults.spotInstancePools;
    	      this.spotInstanceRemedy = defaults.spotInstanceRemedy;
    	      this.spotPriceLimits = defaults.spotPriceLimits;
    	      this.spotStrategy = defaults.spotStrategy;
    	      this.systemDiskBurstingEnabled = defaults.systemDiskBurstingEnabled;
    	      this.systemDiskCategories = defaults.systemDiskCategories;
    	      this.systemDiskCategory = defaults.systemDiskCategory;
    	      this.systemDiskEncryptAlgorithm = defaults.systemDiskEncryptAlgorithm;
    	      this.systemDiskEncrypted = defaults.systemDiskEncrypted;
    	      this.systemDiskKmsKey = defaults.systemDiskKmsKey;
    	      this.systemDiskPerformanceLevel = defaults.systemDiskPerformanceLevel;
    	      this.systemDiskProvisionedIops = defaults.systemDiskProvisionedIops;
    	      this.systemDiskSize = defaults.systemDiskSize;
    	      this.systemDiskSnapshotPolicyId = defaults.systemDiskSnapshotPolicyId;
    	      this.tags = defaults.tags;
    	      this.taints = defaults.taints;
    	      this.teeConfig = defaults.teeConfig;
    	      this.unschedulable = defaults.unschedulable;
    	      this.userData = defaults.userData;
    	      this.vswitchIds = defaults.vswitchIds;
        }

        @CustomType.Setter
        public Builder autoRenew(Boolean autoRenew) {
            if (autoRenew == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "autoRenew");
            }
            this.autoRenew = autoRenew;
            return this;
        }
        @CustomType.Setter
        public Builder autoRenewPeriod(Integer autoRenewPeriod) {
            if (autoRenewPeriod == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "autoRenewPeriod");
            }
            this.autoRenewPeriod = autoRenewPeriod;
            return this;
        }
        @CustomType.Setter
        public Builder cisEnabled(Boolean cisEnabled) {
            if (cisEnabled == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "cisEnabled");
            }
            this.cisEnabled = cisEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder compensateWithOnDemand(Boolean compensateWithOnDemand) {
            if (compensateWithOnDemand == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "compensateWithOnDemand");
            }
            this.compensateWithOnDemand = compensateWithOnDemand;
            return this;
        }
        @CustomType.Setter
        public Builder cpuPolicy(String cpuPolicy) {
            if (cpuPolicy == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "cpuPolicy");
            }
            this.cpuPolicy = cpuPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder dataDisks(List<GetKubernetesNodePoolsNodepoolDataDisk> dataDisks) {
            if (dataDisks == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "dataDisks");
            }
            this.dataDisks = dataDisks;
            return this;
        }
        public Builder dataDisks(GetKubernetesNodePoolsNodepoolDataDisk... dataDisks) {
            return dataDisks(List.of(dataDisks));
        }
        @CustomType.Setter
        public Builder deploymentSetId(String deploymentSetId) {
            if (deploymentSetId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "deploymentSetId");
            }
            this.deploymentSetId = deploymentSetId;
            return this;
        }
        @CustomType.Setter
        public Builder desiredSize(String desiredSize) {
            if (desiredSize == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "desiredSize");
            }
            this.desiredSize = desiredSize;
            return this;
        }
        @CustomType.Setter
        public Builder imageId(String imageId) {
            if (imageId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "imageId");
            }
            this.imageId = imageId;
            return this;
        }
        @CustomType.Setter
        public Builder imageType(String imageType) {
            if (imageType == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "imageType");
            }
            this.imageType = imageType;
            return this;
        }
        @CustomType.Setter
        public Builder installCloudMonitor(Boolean installCloudMonitor) {
            if (installCloudMonitor == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "installCloudMonitor");
            }
            this.installCloudMonitor = installCloudMonitor;
            return this;
        }
        @CustomType.Setter
        public Builder instanceChargeType(String instanceChargeType) {
            if (instanceChargeType == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "instanceChargeType");
            }
            this.instanceChargeType = instanceChargeType;
            return this;
        }
        @CustomType.Setter
        public Builder instanceTypes(List<String> instanceTypes) {
            if (instanceTypes == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "instanceTypes");
            }
            this.instanceTypes = instanceTypes;
            return this;
        }
        public Builder instanceTypes(String... instanceTypes) {
            return instanceTypes(List.of(instanceTypes));
        }
        @CustomType.Setter
        public Builder internetChargeType(String internetChargeType) {
            if (internetChargeType == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "internetChargeType");
            }
            this.internetChargeType = internetChargeType;
            return this;
        }
        @CustomType.Setter
        public Builder internetMaxBandwidthOut(Integer internetMaxBandwidthOut) {
            if (internetMaxBandwidthOut == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "internetMaxBandwidthOut");
            }
            this.internetMaxBandwidthOut = internetMaxBandwidthOut;
            return this;
        }
        @CustomType.Setter
        public Builder keyName(String keyName) {
            if (keyName == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "keyName");
            }
            this.keyName = keyName;
            return this;
        }
        @CustomType.Setter
        public Builder kubeletConfiguration(GetKubernetesNodePoolsNodepoolKubeletConfiguration kubeletConfiguration) {
            if (kubeletConfiguration == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "kubeletConfiguration");
            }
            this.kubeletConfiguration = kubeletConfiguration;
            return this;
        }
        @CustomType.Setter
        public Builder labels(List<GetKubernetesNodePoolsNodepoolLabel> labels) {
            if (labels == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "labels");
            }
            this.labels = labels;
            return this;
        }
        public Builder labels(GetKubernetesNodePoolsNodepoolLabel... labels) {
            return labels(List.of(labels));
        }
        @CustomType.Setter
        public Builder loginAsNonRoot(Boolean loginAsNonRoot) {
            if (loginAsNonRoot == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "loginAsNonRoot");
            }
            this.loginAsNonRoot = loginAsNonRoot;
            return this;
        }
        @CustomType.Setter
        public Builder management(GetKubernetesNodePoolsNodepoolManagement management) {
            if (management == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "management");
            }
            this.management = management;
            return this;
        }
        @CustomType.Setter
        public Builder multiAzPolicy(String multiAzPolicy) {
            if (multiAzPolicy == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "multiAzPolicy");
            }
            this.multiAzPolicy = multiAzPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder nodeNameMode(String nodeNameMode) {
            if (nodeNameMode == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "nodeNameMode");
            }
            this.nodeNameMode = nodeNameMode;
            return this;
        }
        @CustomType.Setter
        public Builder nodePoolId(String nodePoolId) {
            if (nodePoolId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "nodePoolId");
            }
            this.nodePoolId = nodePoolId;
            return this;
        }
        @CustomType.Setter
        public Builder nodePoolName(String nodePoolName) {
            if (nodePoolName == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "nodePoolName");
            }
            this.nodePoolName = nodePoolName;
            return this;
        }
        @CustomType.Setter
        public Builder onDemandBaseCapacity(String onDemandBaseCapacity) {
            if (onDemandBaseCapacity == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "onDemandBaseCapacity");
            }
            this.onDemandBaseCapacity = onDemandBaseCapacity;
            return this;
        }
        @CustomType.Setter
        public Builder onDemandPercentageAboveBaseCapacity(String onDemandPercentageAboveBaseCapacity) {
            if (onDemandPercentageAboveBaseCapacity == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "onDemandPercentageAboveBaseCapacity");
            }
            this.onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity;
            return this;
        }
        @CustomType.Setter
        public Builder password(String password) {
            if (password == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "password");
            }
            this.password = password;
            return this;
        }
        @CustomType.Setter
        public Builder period(Integer period) {
            if (period == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "period");
            }
            this.period = period;
            return this;
        }
        @CustomType.Setter
        public Builder periodUnit(String periodUnit) {
            if (periodUnit == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "periodUnit");
            }
            this.periodUnit = periodUnit;
            return this;
        }
        @CustomType.Setter
        public Builder platform(String platform) {
            if (platform == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "platform");
            }
            this.platform = platform;
            return this;
        }
        @CustomType.Setter
        public Builder preUserData(String preUserData) {
            if (preUserData == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "preUserData");
            }
            this.preUserData = preUserData;
            return this;
        }
        @CustomType.Setter
        public Builder privatePoolOptions(GetKubernetesNodePoolsNodepoolPrivatePoolOptions privatePoolOptions) {
            if (privatePoolOptions == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "privatePoolOptions");
            }
            this.privatePoolOptions = privatePoolOptions;
            return this;
        }
        @CustomType.Setter
        public Builder ramRoleName(String ramRoleName) {
            if (ramRoleName == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "ramRoleName");
            }
            this.ramRoleName = ramRoleName;
            return this;
        }
        @CustomType.Setter
        public Builder rdsInstances(List<String> rdsInstances) {
            if (rdsInstances == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "rdsInstances");
            }
            this.rdsInstances = rdsInstances;
            return this;
        }
        public Builder rdsInstances(String... rdsInstances) {
            return rdsInstances(List.of(rdsInstances));
        }
        @CustomType.Setter
        public Builder resourceGroupId(String resourceGroupId) {
            if (resourceGroupId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "resourceGroupId");
            }
            this.resourceGroupId = resourceGroupId;
            return this;
        }
        @CustomType.Setter
        public Builder runtimeName(String runtimeName) {
            if (runtimeName == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "runtimeName");
            }
            this.runtimeName = runtimeName;
            return this;
        }
        @CustomType.Setter
        public Builder runtimeVersion(String runtimeVersion) {
            if (runtimeVersion == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "runtimeVersion");
            }
            this.runtimeVersion = runtimeVersion;
            return this;
        }
        @CustomType.Setter
        public Builder scalingConfig(GetKubernetesNodePoolsNodepoolScalingConfig scalingConfig) {
            if (scalingConfig == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "scalingConfig");
            }
            this.scalingConfig = scalingConfig;
            return this;
        }
        @CustomType.Setter
        public Builder scalingGroupId(String scalingGroupId) {
            if (scalingGroupId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "scalingGroupId");
            }
            this.scalingGroupId = scalingGroupId;
            return this;
        }
        @CustomType.Setter
        public Builder scalingPolicy(String scalingPolicy) {
            if (scalingPolicy == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "scalingPolicy");
            }
            this.scalingPolicy = scalingPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder securityGroupId(String securityGroupId) {
            if (securityGroupId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "securityGroupId");
            }
            this.securityGroupId = securityGroupId;
            return this;
        }
        @CustomType.Setter
        public Builder securityGroupIds(List<String> securityGroupIds) {
            if (securityGroupIds == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "securityGroupIds");
            }
            this.securityGroupIds = securityGroupIds;
            return this;
        }
        public Builder securityGroupIds(String... securityGroupIds) {
            return securityGroupIds(List.of(securityGroupIds));
        }
        @CustomType.Setter
        public Builder securityHardeningOs(Boolean securityHardeningOs) {
            if (securityHardeningOs == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "securityHardeningOs");
            }
            this.securityHardeningOs = securityHardeningOs;
            return this;
        }
        @CustomType.Setter
        public Builder socEnabled(Boolean socEnabled) {
            if (socEnabled == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "socEnabled");
            }
            this.socEnabled = socEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder spotInstancePools(Integer spotInstancePools) {
            if (spotInstancePools == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "spotInstancePools");
            }
            this.spotInstancePools = spotInstancePools;
            return this;
        }
        @CustomType.Setter
        public Builder spotInstanceRemedy(Boolean spotInstanceRemedy) {
            if (spotInstanceRemedy == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "spotInstanceRemedy");
            }
            this.spotInstanceRemedy = spotInstanceRemedy;
            return this;
        }
        @CustomType.Setter
        public Builder spotPriceLimits(List<GetKubernetesNodePoolsNodepoolSpotPriceLimit> spotPriceLimits) {
            if (spotPriceLimits == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "spotPriceLimits");
            }
            this.spotPriceLimits = spotPriceLimits;
            return this;
        }
        public Builder spotPriceLimits(GetKubernetesNodePoolsNodepoolSpotPriceLimit... spotPriceLimits) {
            return spotPriceLimits(List.of(spotPriceLimits));
        }
        @CustomType.Setter
        public Builder spotStrategy(String spotStrategy) {
            if (spotStrategy == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "spotStrategy");
            }
            this.spotStrategy = spotStrategy;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskBurstingEnabled(Boolean systemDiskBurstingEnabled) {
            if (systemDiskBurstingEnabled == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskBurstingEnabled");
            }
            this.systemDiskBurstingEnabled = systemDiskBurstingEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskCategories(List<String> systemDiskCategories) {
            if (systemDiskCategories == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskCategories");
            }
            this.systemDiskCategories = systemDiskCategories;
            return this;
        }
        public Builder systemDiskCategories(String... systemDiskCategories) {
            return systemDiskCategories(List.of(systemDiskCategories));
        }
        @CustomType.Setter
        public Builder systemDiskCategory(String systemDiskCategory) {
            if (systemDiskCategory == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskCategory");
            }
            this.systemDiskCategory = systemDiskCategory;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskEncryptAlgorithm(String systemDiskEncryptAlgorithm) {
            if (systemDiskEncryptAlgorithm == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskEncryptAlgorithm");
            }
            this.systemDiskEncryptAlgorithm = systemDiskEncryptAlgorithm;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskEncrypted(Boolean systemDiskEncrypted) {
            if (systemDiskEncrypted == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskEncrypted");
            }
            this.systemDiskEncrypted = systemDiskEncrypted;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskKmsKey(String systemDiskKmsKey) {
            if (systemDiskKmsKey == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskKmsKey");
            }
            this.systemDiskKmsKey = systemDiskKmsKey;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskPerformanceLevel(String systemDiskPerformanceLevel) {
            if (systemDiskPerformanceLevel == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskPerformanceLevel");
            }
            this.systemDiskPerformanceLevel = systemDiskPerformanceLevel;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskProvisionedIops(Integer systemDiskProvisionedIops) {
            if (systemDiskProvisionedIops == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskProvisionedIops");
            }
            this.systemDiskProvisionedIops = systemDiskProvisionedIops;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskSize(Integer systemDiskSize) {
            if (systemDiskSize == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskSize");
            }
            this.systemDiskSize = systemDiskSize;
            return this;
        }
        @CustomType.Setter
        public Builder systemDiskSnapshotPolicyId(String systemDiskSnapshotPolicyId) {
            if (systemDiskSnapshotPolicyId == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "systemDiskSnapshotPolicyId");
            }
            this.systemDiskSnapshotPolicyId = systemDiskSnapshotPolicyId;
            return this;
        }
        @CustomType.Setter
        public Builder tags(Map<String,String> tags) {
            if (tags == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "tags");
            }
            this.tags = tags;
            return this;
        }
        @CustomType.Setter
        public Builder taints(List<GetKubernetesNodePoolsNodepoolTaint> taints) {
            if (taints == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "taints");
            }
            this.taints = taints;
            return this;
        }
        public Builder taints(GetKubernetesNodePoolsNodepoolTaint... taints) {
            return taints(List.of(taints));
        }
        @CustomType.Setter
        public Builder teeConfig(GetKubernetesNodePoolsNodepoolTeeConfig teeConfig) {
            if (teeConfig == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "teeConfig");
            }
            this.teeConfig = teeConfig;
            return this;
        }
        @CustomType.Setter
        public Builder unschedulable(Boolean unschedulable) {
            if (unschedulable == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "unschedulable");
            }
            this.unschedulable = unschedulable;
            return this;
        }
        @CustomType.Setter
        public Builder userData(String userData) {
            if (userData == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "userData");
            }
            this.userData = userData;
            return this;
        }
        @CustomType.Setter
        public Builder vswitchIds(List<String> vswitchIds) {
            if (vswitchIds == null) {
              throw new MissingRequiredPropertyException("GetKubernetesNodePoolsNodepool", "vswitchIds");
            }
            this.vswitchIds = vswitchIds;
            return this;
        }
        public Builder vswitchIds(String... vswitchIds) {
            return vswitchIds(List.of(vswitchIds));
        }
        public GetKubernetesNodePoolsNodepool build() {
            final var _resultValue = new GetKubernetesNodePoolsNodepool();
            _resultValue.autoRenew = autoRenew;
            _resultValue.autoRenewPeriod = autoRenewPeriod;
            _resultValue.cisEnabled = cisEnabled;
            _resultValue.compensateWithOnDemand = compensateWithOnDemand;
            _resultValue.cpuPolicy = cpuPolicy;
            _resultValue.dataDisks = dataDisks;
            _resultValue.deploymentSetId = deploymentSetId;
            _resultValue.desiredSize = desiredSize;
            _resultValue.imageId = imageId;
            _resultValue.imageType = imageType;
            _resultValue.installCloudMonitor = installCloudMonitor;
            _resultValue.instanceChargeType = instanceChargeType;
            _resultValue.instanceTypes = instanceTypes;
            _resultValue.internetChargeType = internetChargeType;
            _resultValue.internetMaxBandwidthOut = internetMaxBandwidthOut;
            _resultValue.keyName = keyName;
            _resultValue.kubeletConfiguration = kubeletConfiguration;
            _resultValue.labels = labels;
            _resultValue.loginAsNonRoot = loginAsNonRoot;
            _resultValue.management = management;
            _resultValue.multiAzPolicy = multiAzPolicy;
            _resultValue.nodeNameMode = nodeNameMode;
            _resultValue.nodePoolId = nodePoolId;
            _resultValue.nodePoolName = nodePoolName;
            _resultValue.onDemandBaseCapacity = onDemandBaseCapacity;
            _resultValue.onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity;
            _resultValue.password = password;
            _resultValue.period = period;
            _resultValue.periodUnit = periodUnit;
            _resultValue.platform = platform;
            _resultValue.preUserData = preUserData;
            _resultValue.privatePoolOptions = privatePoolOptions;
            _resultValue.ramRoleName = ramRoleName;
            _resultValue.rdsInstances = rdsInstances;
            _resultValue.resourceGroupId = resourceGroupId;
            _resultValue.runtimeName = runtimeName;
            _resultValue.runtimeVersion = runtimeVersion;
            _resultValue.scalingConfig = scalingConfig;
            _resultValue.scalingGroupId = scalingGroupId;
            _resultValue.scalingPolicy = scalingPolicy;
            _resultValue.securityGroupId = securityGroupId;
            _resultValue.securityGroupIds = securityGroupIds;
            _resultValue.securityHardeningOs = securityHardeningOs;
            _resultValue.socEnabled = socEnabled;
            _resultValue.spotInstancePools = spotInstancePools;
            _resultValue.spotInstanceRemedy = spotInstanceRemedy;
            _resultValue.spotPriceLimits = spotPriceLimits;
            _resultValue.spotStrategy = spotStrategy;
            _resultValue.systemDiskBurstingEnabled = systemDiskBurstingEnabled;
            _resultValue.systemDiskCategories = systemDiskCategories;
            _resultValue.systemDiskCategory = systemDiskCategory;
            _resultValue.systemDiskEncryptAlgorithm = systemDiskEncryptAlgorithm;
            _resultValue.systemDiskEncrypted = systemDiskEncrypted;
            _resultValue.systemDiskKmsKey = systemDiskKmsKey;
            _resultValue.systemDiskPerformanceLevel = systemDiskPerformanceLevel;
            _resultValue.systemDiskProvisionedIops = systemDiskProvisionedIops;
            _resultValue.systemDiskSize = systemDiskSize;
            _resultValue.systemDiskSnapshotPolicyId = systemDiskSnapshotPolicyId;
            _resultValue.tags = tags;
            _resultValue.taints = taints;
            _resultValue.teeConfig = teeConfig;
            _resultValue.unschedulable = unschedulable;
            _resultValue.userData = userData;
            _resultValue.vswitchIds = vswitchIds;
            return _resultValue;
        }
    }
}
