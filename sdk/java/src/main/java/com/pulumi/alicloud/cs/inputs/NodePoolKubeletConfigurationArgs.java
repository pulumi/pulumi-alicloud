// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.cs.inputs;

import com.pulumi.alicloud.cs.inputs.NodePoolKubeletConfigurationReservedMemoryArgs;
import com.pulumi.alicloud.cs.inputs.NodePoolKubeletConfigurationTracingArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NodePoolKubeletConfigurationArgs extends com.pulumi.resources.ResourceArgs {

    public static final NodePoolKubeletConfigurationArgs Empty = new NodePoolKubeletConfigurationArgs();

    /**
     * Allowed sysctl mode whitelist.
     * 
     */
    @Import(name="allowedUnsafeSysctls")
    private @Nullable Output<List<String>> allowedUnsafeSysctls;

    /**
     * @return Allowed sysctl mode whitelist.
     * 
     */
    public Optional<Output<List<String>>> allowedUnsafeSysctls() {
        return Optional.ofNullable(this.allowedUnsafeSysctls);
    }

    /**
     * The list of IP addresses of the cluster DNS servers.
     * 
     */
    @Import(name="clusterDns")
    private @Nullable Output<List<String>> clusterDns;

    /**
     * @return The list of IP addresses of the cluster DNS servers.
     * 
     */
    public Optional<Output<List<String>>> clusterDns() {
        return Optional.ofNullable(this.clusterDns);
    }

    /**
     * The maximum number of log files that can exist in each container.
     * 
     */
    @Import(name="containerLogMaxFiles")
    private @Nullable Output<String> containerLogMaxFiles;

    /**
     * @return The maximum number of log files that can exist in each container.
     * 
     */
    public Optional<Output<String>> containerLogMaxFiles() {
        return Optional.ofNullable(this.containerLogMaxFiles);
    }

    /**
     * The maximum size that can be reached before a log file is rotated.
     * 
     */
    @Import(name="containerLogMaxSize")
    private @Nullable Output<String> containerLogMaxSize;

    /**
     * @return The maximum size that can be reached before a log file is rotated.
     * 
     */
    public Optional<Output<String>> containerLogMaxSize() {
        return Optional.ofNullable(this.containerLogMaxSize);
    }

    /**
     * Specifies the maximum number of concurrent workers required to perform log rotation operations.
     * 
     */
    @Import(name="containerLogMaxWorkers")
    private @Nullable Output<String> containerLogMaxWorkers;

    /**
     * @return Specifies the maximum number of concurrent workers required to perform log rotation operations.
     * 
     */
    public Optional<Output<String>> containerLogMaxWorkers() {
        return Optional.ofNullable(this.containerLogMaxWorkers);
    }

    /**
     * Specifies the duration for which container logs are monitored for log rotation.
     * 
     */
    @Import(name="containerLogMonitorInterval")
    private @Nullable Output<String> containerLogMonitorInterval;

    /**
     * @return Specifies the duration for which container logs are monitored for log rotation.
     * 
     */
    public Optional<Output<String>> containerLogMonitorInterval() {
        return Optional.ofNullable(this.containerLogMonitorInterval);
    }

    /**
     * CPU CFS quota constraint switch.
     * 
     */
    @Import(name="cpuCfsQuota")
    private @Nullable Output<String> cpuCfsQuota;

    /**
     * @return CPU CFS quota constraint switch.
     * 
     */
    public Optional<Output<String>> cpuCfsQuota() {
        return Optional.ofNullable(this.cpuCfsQuota);
    }

    /**
     * CPU CFS quota period value.
     * 
     */
    @Import(name="cpuCfsQuotaPeriod")
    private @Nullable Output<String> cpuCfsQuotaPeriod;

    /**
     * @return CPU CFS quota period value.
     * 
     */
    public Optional<Output<String>> cpuCfsQuotaPeriod() {
        return Optional.ofNullable(this.cpuCfsQuotaPeriod);
    }

    /**
     * Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
     * 
     */
    @Import(name="cpuManagerPolicy")
    private @Nullable Output<String> cpuManagerPolicy;

    /**
     * @return Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
     * 
     */
    public Optional<Output<String>> cpuManagerPolicy() {
        return Optional.ofNullable(this.cpuManagerPolicy);
    }

    /**
     * Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
     * 
     */
    @Import(name="eventBurst")
    private @Nullable Output<String> eventBurst;

    /**
     * @return Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
     * 
     */
    public Optional<Output<String>> eventBurst() {
        return Optional.ofNullable(this.eventBurst);
    }

    /**
     * Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
     * 
     */
    @Import(name="eventRecordQps")
    private @Nullable Output<String> eventRecordQps;

    /**
     * @return Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
     * 
     */
    public Optional<Output<String>> eventRecordQps() {
        return Optional.ofNullable(this.eventRecordQps);
    }

    /**
     * Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
     * 
     */
    @Import(name="evictionHard")
    private @Nullable Output<Map<String,String>> evictionHard;

    /**
     * @return Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
     * 
     */
    public Optional<Output<Map<String,String>>> evictionHard() {
        return Optional.ofNullable(this.evictionHard);
    }

    /**
     * Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
     * 
     */
    @Import(name="evictionSoft")
    private @Nullable Output<Map<String,String>> evictionSoft;

    /**
     * @return Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
     * 
     */
    public Optional<Output<Map<String,String>>> evictionSoft() {
        return Optional.ofNullable(this.evictionSoft);
    }

    /**
     * Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{&#34;memory.available&#34; = &#34;30s&#34;}`.
     * 
     */
    @Import(name="evictionSoftGracePeriod")
    private @Nullable Output<Map<String,String>> evictionSoftGracePeriod;

    /**
     * @return Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{&#34;memory.available&#34; = &#34;30s&#34;}`.
     * 
     */
    public Optional<Output<Map<String,String>>> evictionSoftGracePeriod() {
        return Optional.ofNullable(this.evictionSoftGracePeriod);
    }

    /**
     * Feature switch to enable configuration of experimental features.
     * 
     */
    @Import(name="featureGates")
    private @Nullable Output<Map<String,Boolean>> featureGates;

    /**
     * @return Feature switch to enable configuration of experimental features.
     * 
     */
    public Optional<Output<Map<String,Boolean>>> featureGates() {
        return Optional.ofNullable(this.featureGates);
    }

    /**
     * If the image usage exceeds this threshold, image garbage collection will continue.
     * 
     */
    @Import(name="imageGcHighThresholdPercent")
    private @Nullable Output<String> imageGcHighThresholdPercent;

    /**
     * @return If the image usage exceeds this threshold, image garbage collection will continue.
     * 
     */
    public Optional<Output<String>> imageGcHighThresholdPercent() {
        return Optional.ofNullable(this.imageGcHighThresholdPercent);
    }

    /**
     * Image garbage collection is not performed when the image usage is below this threshold.
     * 
     */
    @Import(name="imageGcLowThresholdPercent")
    private @Nullable Output<String> imageGcLowThresholdPercent;

    /**
     * @return Image garbage collection is not performed when the image usage is below this threshold.
     * 
     */
    public Optional<Output<String>> imageGcLowThresholdPercent() {
        return Optional.ofNullable(this.imageGcLowThresholdPercent);
    }

    /**
     * Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
     * 
     */
    @Import(name="kubeApiBurst")
    private @Nullable Output<String> kubeApiBurst;

    /**
     * @return Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
     * 
     */
    public Optional<Output<String>> kubeApiBurst() {
        return Optional.ofNullable(this.kubeApiBurst);
    }

    /**
     * Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
     * 
     */
    @Import(name="kubeApiQps")
    private @Nullable Output<String> kubeApiQps;

    /**
     * @return Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
     * 
     */
    public Optional<Output<String>> kubeApiQps() {
        return Optional.ofNullable(this.kubeApiQps);
    }

    /**
     * Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
     * 
     */
    @Import(name="kubeReserved")
    private @Nullable Output<Map<String,String>> kubeReserved;

    /**
     * @return Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
     * 
     */
    public Optional<Output<Map<String,String>>> kubeReserved() {
        return Optional.ofNullable(this.kubeReserved);
    }

    /**
     * The maximum number of running pods.
     * 
     */
    @Import(name="maxPods")
    private @Nullable Output<String> maxPods;

    /**
     * @return The maximum number of running pods.
     * 
     */
    public Optional<Output<String>> maxPods() {
        return Optional.ofNullable(this.maxPods);
    }

    /**
     * The policy to be used by the memory manager.
     * 
     */
    @Import(name="memoryManagerPolicy")
    private @Nullable Output<String> memoryManagerPolicy;

    /**
     * @return The policy to be used by the memory manager.
     * 
     */
    public Optional<Output<String>> memoryManagerPolicy() {
        return Optional.ofNullable(this.memoryManagerPolicy);
    }

    /**
     * The maximum number of PIDs that can be used in a Pod.
     * 
     */
    @Import(name="podPidsLimit")
    private @Nullable Output<String> podPidsLimit;

    /**
     * @return The maximum number of PIDs that can be used in a Pod.
     * 
     */
    public Optional<Output<String>> podPidsLimit() {
        return Optional.ofNullable(this.podPidsLimit);
    }

    /**
     * Read-only port number.
     * 
     */
    @Import(name="readOnlyPort")
    private @Nullable Output<String> readOnlyPort;

    /**
     * @return Read-only port number.
     * 
     */
    public Optional<Output<String>> readOnlyPort() {
        return Optional.ofNullable(this.readOnlyPort);
    }

    /**
     * Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
     * 
     */
    @Import(name="registryBurst")
    private @Nullable Output<String> registryBurst;

    /**
     * @return Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
     * 
     */
    public Optional<Output<String>> registryBurst() {
        return Optional.ofNullable(this.registryBurst);
    }

    /**
     * Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
     * 
     */
    @Import(name="registryPullQps")
    private @Nullable Output<String> registryPullQps;

    /**
     * @return Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
     * 
     */
    public Optional<Output<String>> registryPullQps() {
        return Optional.ofNullable(this.registryPullQps);
    }

    /**
     * Reserve memory for NUMA nodes. See `reserved_memory` below.
     * 
     */
    @Import(name="reservedMemories")
    private @Nullable Output<List<NodePoolKubeletConfigurationReservedMemoryArgs>> reservedMemories;

    /**
     * @return Reserve memory for NUMA nodes. See `reserved_memory` below.
     * 
     */
    public Optional<Output<List<NodePoolKubeletConfigurationReservedMemoryArgs>>> reservedMemories() {
        return Optional.ofNullable(this.reservedMemories);
    }

    /**
     * Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version &lt; 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
     * 
     */
    @Import(name="serializeImagePulls")
    private @Nullable Output<String> serializeImagePulls;

    /**
     * @return Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version &lt; 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
     * 
     */
    public Optional<Output<String>> serializeImagePulls() {
        return Optional.ofNullable(this.serializeImagePulls);
    }

    /**
     * Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
     * 
     */
    @Import(name="systemReserved")
    private @Nullable Output<Map<String,String>> systemReserved;

    /**
     * @return Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
     * 
     */
    public Optional<Output<Map<String,String>>> systemReserved() {
        return Optional.ofNullable(this.systemReserved);
    }

    /**
     * Name of the Topology Manager policy used.
     * 
     */
    @Import(name="topologyManagerPolicy")
    private @Nullable Output<String> topologyManagerPolicy;

    /**
     * @return Name of the Topology Manager policy used.
     * 
     */
    public Optional<Output<String>> topologyManagerPolicy() {
        return Optional.ofNullable(this.topologyManagerPolicy);
    }

    /**
     * OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
     * 
     */
    @Import(name="tracing")
    private @Nullable Output<NodePoolKubeletConfigurationTracingArgs> tracing;

    /**
     * @return OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
     * 
     */
    public Optional<Output<NodePoolKubeletConfigurationTracingArgs>> tracing() {
        return Optional.ofNullable(this.tracing);
    }

    private NodePoolKubeletConfigurationArgs() {}

    private NodePoolKubeletConfigurationArgs(NodePoolKubeletConfigurationArgs $) {
        this.allowedUnsafeSysctls = $.allowedUnsafeSysctls;
        this.clusterDns = $.clusterDns;
        this.containerLogMaxFiles = $.containerLogMaxFiles;
        this.containerLogMaxSize = $.containerLogMaxSize;
        this.containerLogMaxWorkers = $.containerLogMaxWorkers;
        this.containerLogMonitorInterval = $.containerLogMonitorInterval;
        this.cpuCfsQuota = $.cpuCfsQuota;
        this.cpuCfsQuotaPeriod = $.cpuCfsQuotaPeriod;
        this.cpuManagerPolicy = $.cpuManagerPolicy;
        this.eventBurst = $.eventBurst;
        this.eventRecordQps = $.eventRecordQps;
        this.evictionHard = $.evictionHard;
        this.evictionSoft = $.evictionSoft;
        this.evictionSoftGracePeriod = $.evictionSoftGracePeriod;
        this.featureGates = $.featureGates;
        this.imageGcHighThresholdPercent = $.imageGcHighThresholdPercent;
        this.imageGcLowThresholdPercent = $.imageGcLowThresholdPercent;
        this.kubeApiBurst = $.kubeApiBurst;
        this.kubeApiQps = $.kubeApiQps;
        this.kubeReserved = $.kubeReserved;
        this.maxPods = $.maxPods;
        this.memoryManagerPolicy = $.memoryManagerPolicy;
        this.podPidsLimit = $.podPidsLimit;
        this.readOnlyPort = $.readOnlyPort;
        this.registryBurst = $.registryBurst;
        this.registryPullQps = $.registryPullQps;
        this.reservedMemories = $.reservedMemories;
        this.serializeImagePulls = $.serializeImagePulls;
        this.systemReserved = $.systemReserved;
        this.topologyManagerPolicy = $.topologyManagerPolicy;
        this.tracing = $.tracing;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NodePoolKubeletConfigurationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NodePoolKubeletConfigurationArgs $;

        public Builder() {
            $ = new NodePoolKubeletConfigurationArgs();
        }

        public Builder(NodePoolKubeletConfigurationArgs defaults) {
            $ = new NodePoolKubeletConfigurationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowedUnsafeSysctls Allowed sysctl mode whitelist.
         * 
         * @return builder
         * 
         */
        public Builder allowedUnsafeSysctls(@Nullable Output<List<String>> allowedUnsafeSysctls) {
            $.allowedUnsafeSysctls = allowedUnsafeSysctls;
            return this;
        }

        /**
         * @param allowedUnsafeSysctls Allowed sysctl mode whitelist.
         * 
         * @return builder
         * 
         */
        public Builder allowedUnsafeSysctls(List<String> allowedUnsafeSysctls) {
            return allowedUnsafeSysctls(Output.of(allowedUnsafeSysctls));
        }

        /**
         * @param allowedUnsafeSysctls Allowed sysctl mode whitelist.
         * 
         * @return builder
         * 
         */
        public Builder allowedUnsafeSysctls(String... allowedUnsafeSysctls) {
            return allowedUnsafeSysctls(List.of(allowedUnsafeSysctls));
        }

        /**
         * @param clusterDns The list of IP addresses of the cluster DNS servers.
         * 
         * @return builder
         * 
         */
        public Builder clusterDns(@Nullable Output<List<String>> clusterDns) {
            $.clusterDns = clusterDns;
            return this;
        }

        /**
         * @param clusterDns The list of IP addresses of the cluster DNS servers.
         * 
         * @return builder
         * 
         */
        public Builder clusterDns(List<String> clusterDns) {
            return clusterDns(Output.of(clusterDns));
        }

        /**
         * @param clusterDns The list of IP addresses of the cluster DNS servers.
         * 
         * @return builder
         * 
         */
        public Builder clusterDns(String... clusterDns) {
            return clusterDns(List.of(clusterDns));
        }

        /**
         * @param containerLogMaxFiles The maximum number of log files that can exist in each container.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxFiles(@Nullable Output<String> containerLogMaxFiles) {
            $.containerLogMaxFiles = containerLogMaxFiles;
            return this;
        }

        /**
         * @param containerLogMaxFiles The maximum number of log files that can exist in each container.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxFiles(String containerLogMaxFiles) {
            return containerLogMaxFiles(Output.of(containerLogMaxFiles));
        }

        /**
         * @param containerLogMaxSize The maximum size that can be reached before a log file is rotated.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxSize(@Nullable Output<String> containerLogMaxSize) {
            $.containerLogMaxSize = containerLogMaxSize;
            return this;
        }

        /**
         * @param containerLogMaxSize The maximum size that can be reached before a log file is rotated.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxSize(String containerLogMaxSize) {
            return containerLogMaxSize(Output.of(containerLogMaxSize));
        }

        /**
         * @param containerLogMaxWorkers Specifies the maximum number of concurrent workers required to perform log rotation operations.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxWorkers(@Nullable Output<String> containerLogMaxWorkers) {
            $.containerLogMaxWorkers = containerLogMaxWorkers;
            return this;
        }

        /**
         * @param containerLogMaxWorkers Specifies the maximum number of concurrent workers required to perform log rotation operations.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMaxWorkers(String containerLogMaxWorkers) {
            return containerLogMaxWorkers(Output.of(containerLogMaxWorkers));
        }

        /**
         * @param containerLogMonitorInterval Specifies the duration for which container logs are monitored for log rotation.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMonitorInterval(@Nullable Output<String> containerLogMonitorInterval) {
            $.containerLogMonitorInterval = containerLogMonitorInterval;
            return this;
        }

        /**
         * @param containerLogMonitorInterval Specifies the duration for which container logs are monitored for log rotation.
         * 
         * @return builder
         * 
         */
        public Builder containerLogMonitorInterval(String containerLogMonitorInterval) {
            return containerLogMonitorInterval(Output.of(containerLogMonitorInterval));
        }

        /**
         * @param cpuCfsQuota CPU CFS quota constraint switch.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuota(@Nullable Output<String> cpuCfsQuota) {
            $.cpuCfsQuota = cpuCfsQuota;
            return this;
        }

        /**
         * @param cpuCfsQuota CPU CFS quota constraint switch.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuota(String cpuCfsQuota) {
            return cpuCfsQuota(Output.of(cpuCfsQuota));
        }

        /**
         * @param cpuCfsQuotaPeriod CPU CFS quota period value.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuotaPeriod(@Nullable Output<String> cpuCfsQuotaPeriod) {
            $.cpuCfsQuotaPeriod = cpuCfsQuotaPeriod;
            return this;
        }

        /**
         * @param cpuCfsQuotaPeriod CPU CFS quota period value.
         * 
         * @return builder
         * 
         */
        public Builder cpuCfsQuotaPeriod(String cpuCfsQuotaPeriod) {
            return cpuCfsQuotaPeriod(Output.of(cpuCfsQuotaPeriod));
        }

        /**
         * @param cpuManagerPolicy Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
         * 
         * @return builder
         * 
         */
        public Builder cpuManagerPolicy(@Nullable Output<String> cpuManagerPolicy) {
            $.cpuManagerPolicy = cpuManagerPolicy;
            return this;
        }

        /**
         * @param cpuManagerPolicy Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is `none` or `static`.
         * 
         * @return builder
         * 
         */
        public Builder cpuManagerPolicy(String cpuManagerPolicy) {
            return cpuManagerPolicy(Output.of(cpuManagerPolicy));
        }

        /**
         * @param eventBurst Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
         * 
         * @return builder
         * 
         */
        public Builder eventBurst(@Nullable Output<String> eventBurst) {
            $.eventBurst = eventBurst;
            return this;
        }

        /**
         * @param eventBurst Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding `event_record_qps`. It is only used when `event_record_qps` is greater than 0. Valid value is `[0-100]`.
         * 
         * @return builder
         * 
         */
        public Builder eventBurst(String eventBurst) {
            return eventBurst(Output.of(eventBurst));
        }

        /**
         * @param eventRecordQps Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
         * 
         * @return builder
         * 
         */
        public Builder eventRecordQps(@Nullable Output<String> eventRecordQps) {
            $.eventRecordQps = eventRecordQps;
            return this;
        }

        /**
         * @param eventRecordQps Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is `[0-50]`.
         * 
         * @return builder
         * 
         */
        public Builder eventRecordQps(String eventRecordQps) {
            return eventRecordQps(Output.of(eventRecordQps));
        }

        /**
         * @param evictionHard Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
         * 
         * @return builder
         * 
         */
        public Builder evictionHard(@Nullable Output<Map<String,String>> evictionHard) {
            $.evictionHard = evictionHard;
            return this;
        }

        /**
         * @param evictionHard Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
         * 
         * @return builder
         * 
         */
        public Builder evictionHard(Map<String,String> evictionHard) {
            return evictionHard(Output.of(evictionHard));
        }

        /**
         * @param evictionSoft Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoft(@Nullable Output<Map<String,String>> evictionSoft) {
            $.evictionSoft = evictionSoft;
            return this;
        }

        /**
         * @param evictionSoft Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: `{&#34;memory.available&#34; = &#34;300Mi&#34;}`.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoft(Map<String,String> evictionSoft) {
            return evictionSoft(Output.of(evictionSoft));
        }

        /**
         * @param evictionSoftGracePeriod Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{&#34;memory.available&#34; = &#34;30s&#34;}`.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoftGracePeriod(@Nullable Output<Map<String,String>> evictionSoftGracePeriod) {
            $.evictionSoftGracePeriod = evictionSoftGracePeriod;
            return this;
        }

        /**
         * @param evictionSoftGracePeriod Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: `{&#34;memory.available&#34; = &#34;30s&#34;}`.
         * 
         * @return builder
         * 
         */
        public Builder evictionSoftGracePeriod(Map<String,String> evictionSoftGracePeriod) {
            return evictionSoftGracePeriod(Output.of(evictionSoftGracePeriod));
        }

        /**
         * @param featureGates Feature switch to enable configuration of experimental features.
         * 
         * @return builder
         * 
         */
        public Builder featureGates(@Nullable Output<Map<String,Boolean>> featureGates) {
            $.featureGates = featureGates;
            return this;
        }

        /**
         * @param featureGates Feature switch to enable configuration of experimental features.
         * 
         * @return builder
         * 
         */
        public Builder featureGates(Map<String,Boolean> featureGates) {
            return featureGates(Output.of(featureGates));
        }

        /**
         * @param imageGcHighThresholdPercent If the image usage exceeds this threshold, image garbage collection will continue.
         * 
         * @return builder
         * 
         */
        public Builder imageGcHighThresholdPercent(@Nullable Output<String> imageGcHighThresholdPercent) {
            $.imageGcHighThresholdPercent = imageGcHighThresholdPercent;
            return this;
        }

        /**
         * @param imageGcHighThresholdPercent If the image usage exceeds this threshold, image garbage collection will continue.
         * 
         * @return builder
         * 
         */
        public Builder imageGcHighThresholdPercent(String imageGcHighThresholdPercent) {
            return imageGcHighThresholdPercent(Output.of(imageGcHighThresholdPercent));
        }

        /**
         * @param imageGcLowThresholdPercent Image garbage collection is not performed when the image usage is below this threshold.
         * 
         * @return builder
         * 
         */
        public Builder imageGcLowThresholdPercent(@Nullable Output<String> imageGcLowThresholdPercent) {
            $.imageGcLowThresholdPercent = imageGcLowThresholdPercent;
            return this;
        }

        /**
         * @param imageGcLowThresholdPercent Image garbage collection is not performed when the image usage is below this threshold.
         * 
         * @return builder
         * 
         */
        public Builder imageGcLowThresholdPercent(String imageGcLowThresholdPercent) {
            return imageGcLowThresholdPercent(Output.of(imageGcLowThresholdPercent));
        }

        /**
         * @param kubeApiBurst Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
         * 
         * @return builder
         * 
         */
        public Builder kubeApiBurst(@Nullable Output<String> kubeApiBurst) {
            $.kubeApiBurst = kubeApiBurst;
            return this;
        }

        /**
         * @param kubeApiBurst Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is `[0-100]`.
         * 
         * @return builder
         * 
         */
        public Builder kubeApiBurst(String kubeApiBurst) {
            return kubeApiBurst(Output.of(kubeApiBurst));
        }

        /**
         * @param kubeApiQps Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
         * 
         * @return builder
         * 
         */
        public Builder kubeApiQps(@Nullable Output<String> kubeApiQps) {
            $.kubeApiQps = kubeApiQps;
            return this;
        }

        /**
         * @param kubeApiQps Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is `[0-50]`.
         * 
         * @return builder
         * 
         */
        public Builder kubeApiQps(String kubeApiQps) {
            return kubeApiQps(Output.of(kubeApiQps));
        }

        /**
         * @param kubeReserved Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
         * 
         * @return builder
         * 
         */
        public Builder kubeReserved(@Nullable Output<Map<String,String>> kubeReserved) {
            $.kubeReserved = kubeReserved;
            return this;
        }

        /**
         * @param kubeReserved Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
         * 
         * @return builder
         * 
         */
        public Builder kubeReserved(Map<String,String> kubeReserved) {
            return kubeReserved(Output.of(kubeReserved));
        }

        /**
         * @param maxPods The maximum number of running pods.
         * 
         * @return builder
         * 
         */
        public Builder maxPods(@Nullable Output<String> maxPods) {
            $.maxPods = maxPods;
            return this;
        }

        /**
         * @param maxPods The maximum number of running pods.
         * 
         * @return builder
         * 
         */
        public Builder maxPods(String maxPods) {
            return maxPods(Output.of(maxPods));
        }

        /**
         * @param memoryManagerPolicy The policy to be used by the memory manager.
         * 
         * @return builder
         * 
         */
        public Builder memoryManagerPolicy(@Nullable Output<String> memoryManagerPolicy) {
            $.memoryManagerPolicy = memoryManagerPolicy;
            return this;
        }

        /**
         * @param memoryManagerPolicy The policy to be used by the memory manager.
         * 
         * @return builder
         * 
         */
        public Builder memoryManagerPolicy(String memoryManagerPolicy) {
            return memoryManagerPolicy(Output.of(memoryManagerPolicy));
        }

        /**
         * @param podPidsLimit The maximum number of PIDs that can be used in a Pod.
         * 
         * @return builder
         * 
         */
        public Builder podPidsLimit(@Nullable Output<String> podPidsLimit) {
            $.podPidsLimit = podPidsLimit;
            return this;
        }

        /**
         * @param podPidsLimit The maximum number of PIDs that can be used in a Pod.
         * 
         * @return builder
         * 
         */
        public Builder podPidsLimit(String podPidsLimit) {
            return podPidsLimit(Output.of(podPidsLimit));
        }

        /**
         * @param readOnlyPort Read-only port number.
         * 
         * @return builder
         * 
         */
        public Builder readOnlyPort(@Nullable Output<String> readOnlyPort) {
            $.readOnlyPort = readOnlyPort;
            return this;
        }

        /**
         * @param readOnlyPort Read-only port number.
         * 
         * @return builder
         * 
         */
        public Builder readOnlyPort(String readOnlyPort) {
            return readOnlyPort(Output.of(readOnlyPort));
        }

        /**
         * @param registryBurst Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
         * 
         * @return builder
         * 
         */
        public Builder registryBurst(@Nullable Output<String> registryBurst) {
            $.registryBurst = registryBurst;
            return this;
        }

        /**
         * @param registryBurst Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding `registry_pull_qps`. Only used if `registry_pull_qps` is greater than 0. Valid value is `[0-100]`.
         * 
         * @return builder
         * 
         */
        public Builder registryBurst(String registryBurst) {
            return registryBurst(Output.of(registryBurst));
        }

        /**
         * @param registryPullQps Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
         * 
         * @return builder
         * 
         */
        public Builder registryPullQps(@Nullable Output<String> registryPullQps) {
            $.registryPullQps = registryPullQps;
            return this;
        }

        /**
         * @param registryPullQps Same as registryPullQPS. The limit of registry pulls per second. Setting it to `0` means no limit. Valid value is `[0-50]`.
         * 
         * @return builder
         * 
         */
        public Builder registryPullQps(String registryPullQps) {
            return registryPullQps(Output.of(registryPullQps));
        }

        /**
         * @param reservedMemories Reserve memory for NUMA nodes. See `reserved_memory` below.
         * 
         * @return builder
         * 
         */
        public Builder reservedMemories(@Nullable Output<List<NodePoolKubeletConfigurationReservedMemoryArgs>> reservedMemories) {
            $.reservedMemories = reservedMemories;
            return this;
        }

        /**
         * @param reservedMemories Reserve memory for NUMA nodes. See `reserved_memory` below.
         * 
         * @return builder
         * 
         */
        public Builder reservedMemories(List<NodePoolKubeletConfigurationReservedMemoryArgs> reservedMemories) {
            return reservedMemories(Output.of(reservedMemories));
        }

        /**
         * @param reservedMemories Reserve memory for NUMA nodes. See `reserved_memory` below.
         * 
         * @return builder
         * 
         */
        public Builder reservedMemories(NodePoolKubeletConfigurationReservedMemoryArgs... reservedMemories) {
            return reservedMemories(List.of(reservedMemories));
        }

        /**
         * @param serializeImagePulls Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version &lt; 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
         * 
         * @return builder
         * 
         */
        public Builder serializeImagePulls(@Nullable Output<String> serializeImagePulls) {
            $.serializeImagePulls = serializeImagePulls;
            return this;
        }

        /**
         * @param serializeImagePulls Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version &lt; 1.9 or an Aufs storage backend. Valid value is `true` or `false`.
         * 
         * @return builder
         * 
         */
        public Builder serializeImagePulls(String serializeImagePulls) {
            return serializeImagePulls(Output.of(serializeImagePulls));
        }

        /**
         * @param systemReserved Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
         * 
         * @return builder
         * 
         */
        public Builder systemReserved(@Nullable Output<Map<String,String>> systemReserved) {
            $.systemReserved = systemReserved;
            return this;
        }

        /**
         * @param systemReserved Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See [compute resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) for more details.
         * 
         * @return builder
         * 
         */
        public Builder systemReserved(Map<String,String> systemReserved) {
            return systemReserved(Output.of(systemReserved));
        }

        /**
         * @param topologyManagerPolicy Name of the Topology Manager policy used.
         * 
         * @return builder
         * 
         */
        public Builder topologyManagerPolicy(@Nullable Output<String> topologyManagerPolicy) {
            $.topologyManagerPolicy = topologyManagerPolicy;
            return this;
        }

        /**
         * @param topologyManagerPolicy Name of the Topology Manager policy used.
         * 
         * @return builder
         * 
         */
        public Builder topologyManagerPolicy(String topologyManagerPolicy) {
            return topologyManagerPolicy(Output.of(topologyManagerPolicy));
        }

        /**
         * @param tracing OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
         * 
         * @return builder
         * 
         */
        public Builder tracing(@Nullable Output<NodePoolKubeletConfigurationTracingArgs> tracing) {
            $.tracing = tracing;
            return this;
        }

        /**
         * @param tracing OpenTelemetry tracks the configuration information for client settings versioning. See `tracing` below.
         * 
         * @return builder
         * 
         */
        public Builder tracing(NodePoolKubeletConfigurationTracingArgs tracing) {
            return tracing(Output.of(tracing));
        }

        public NodePoolKubeletConfigurationArgs build() {
            return $;
        }
    }

}
