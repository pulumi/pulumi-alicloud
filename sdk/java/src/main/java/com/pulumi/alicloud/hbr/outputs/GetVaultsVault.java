// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.hbr.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetVaultsVault {
    /**
     * @return The name of the OSS bucket of the Vault.
     * 
     */
    private String bucketName;
    /**
     * @return The amount of backup data. The unit is Byte.
     * 
     */
    private String bytesDone;
    /**
     * @return The creation time of the Vault. UNIX time in seconds.
     * 
     */
    private String createdTime;
    /**
     * @return Whether to enable the deduplication function for the database backup Vault.
     * 
     */
    private Boolean dedup;
    /**
     * @return The description of the vault.
     * 
     */
    private String description;
    /**
     * @return The ID of vault.
     * 
     */
    private String id;
    /**
     * @return Index available.
     * 
     */
    private Boolean indexAvailable;
    /**
     * @return Index level.
     * 
     */
    private String indexLevel;
    /**
     * @return Index update time.
     * 
     */
    private String indexUpdateTime;
    /**
     * @return The time of the last remote backup synchronization.
     * 
     */
    private String latestReplicationTime;
    /**
     * @return Billing model, possible values:
     * 
     */
    private String paymentType;
    /**
     * @return Whether it is a remote backup warehouse. It&#39;s a boolean value.
     * 
     */
    private Boolean replication;
    /**
     * @return The region ID to which the remote backup Vault belongs.
     * 
     */
    private String replicationSourceRegionId;
    /**
     * @return The source vault ID of the remote backup Vault.
     * 
     */
    private String replicationSourceVaultId;
    /**
     * @return Warehouse-level data retention days, only valid for archive libraries.
     * 
     */
    private String retention;
    /**
     * @return Whether to enable the backup search function.
     * 
     */
    private Boolean searchEnabled;
    private List<String> sourceTypes;
    /**
     * @return The status of Vault. Valid values: `CREATED`, `ERROR`, `UNKNOWN`.
     * 
     */
    private String status;
    /**
     * @return Backup vault storage usage. The unit is Byte.
     * 
     */
    private String storageSize;
    /**
     * @return The update time of the Vault. UNIX time in seconds.
     * 
     */
    private String updatedTime;
    /**
     * @return The ID of vault, same as `id`.
     * 
     */
    private String vaultId;
    /**
     * @return The name of vault.
     * 
     */
    private String vaultName;
    /**
     * @return Error status information of Vault. Only valid for remote backup warehouses. Only the remote backup warehouse is valid.
     * 
     */
    private String vaultStatusMessage;
    /**
     * @return The storage class of vault. Valid values: `STANDARD`.
     * 
     */
    private String vaultStorageClass;
    /**
     * @return The type of Vault. Valid values: `STANDARD`,`OTS_BACKUP`.
     * 
     */
    private String vaultType;

    private GetVaultsVault() {}
    /**
     * @return The name of the OSS bucket of the Vault.
     * 
     */
    public String bucketName() {
        return this.bucketName;
    }
    /**
     * @return The amount of backup data. The unit is Byte.
     * 
     */
    public String bytesDone() {
        return this.bytesDone;
    }
    /**
     * @return The creation time of the Vault. UNIX time in seconds.
     * 
     */
    public String createdTime() {
        return this.createdTime;
    }
    /**
     * @return Whether to enable the deduplication function for the database backup Vault.
     * 
     */
    public Boolean dedup() {
        return this.dedup;
    }
    /**
     * @return The description of the vault.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return The ID of vault.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Index available.
     * 
     */
    public Boolean indexAvailable() {
        return this.indexAvailable;
    }
    /**
     * @return Index level.
     * 
     */
    public String indexLevel() {
        return this.indexLevel;
    }
    /**
     * @return Index update time.
     * 
     */
    public String indexUpdateTime() {
        return this.indexUpdateTime;
    }
    /**
     * @return The time of the last remote backup synchronization.
     * 
     */
    public String latestReplicationTime() {
        return this.latestReplicationTime;
    }
    /**
     * @return Billing model, possible values:
     * 
     */
    public String paymentType() {
        return this.paymentType;
    }
    /**
     * @return Whether it is a remote backup warehouse. It&#39;s a boolean value.
     * 
     */
    public Boolean replication() {
        return this.replication;
    }
    /**
     * @return The region ID to which the remote backup Vault belongs.
     * 
     */
    public String replicationSourceRegionId() {
        return this.replicationSourceRegionId;
    }
    /**
     * @return The source vault ID of the remote backup Vault.
     * 
     */
    public String replicationSourceVaultId() {
        return this.replicationSourceVaultId;
    }
    /**
     * @return Warehouse-level data retention days, only valid for archive libraries.
     * 
     */
    public String retention() {
        return this.retention;
    }
    /**
     * @return Whether to enable the backup search function.
     * 
     */
    public Boolean searchEnabled() {
        return this.searchEnabled;
    }
    public List<String> sourceTypes() {
        return this.sourceTypes;
    }
    /**
     * @return The status of Vault. Valid values: `CREATED`, `ERROR`, `UNKNOWN`.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Backup vault storage usage. The unit is Byte.
     * 
     */
    public String storageSize() {
        return this.storageSize;
    }
    /**
     * @return The update time of the Vault. UNIX time in seconds.
     * 
     */
    public String updatedTime() {
        return this.updatedTime;
    }
    /**
     * @return The ID of vault, same as `id`.
     * 
     */
    public String vaultId() {
        return this.vaultId;
    }
    /**
     * @return The name of vault.
     * 
     */
    public String vaultName() {
        return this.vaultName;
    }
    /**
     * @return Error status information of Vault. Only valid for remote backup warehouses. Only the remote backup warehouse is valid.
     * 
     */
    public String vaultStatusMessage() {
        return this.vaultStatusMessage;
    }
    /**
     * @return The storage class of vault. Valid values: `STANDARD`.
     * 
     */
    public String vaultStorageClass() {
        return this.vaultStorageClass;
    }
    /**
     * @return The type of Vault. Valid values: `STANDARD`,`OTS_BACKUP`.
     * 
     */
    public String vaultType() {
        return this.vaultType;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetVaultsVault defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String bucketName;
        private String bytesDone;
        private String createdTime;
        private Boolean dedup;
        private String description;
        private String id;
        private Boolean indexAvailable;
        private String indexLevel;
        private String indexUpdateTime;
        private String latestReplicationTime;
        private String paymentType;
        private Boolean replication;
        private String replicationSourceRegionId;
        private String replicationSourceVaultId;
        private String retention;
        private Boolean searchEnabled;
        private List<String> sourceTypes;
        private String status;
        private String storageSize;
        private String updatedTime;
        private String vaultId;
        private String vaultName;
        private String vaultStatusMessage;
        private String vaultStorageClass;
        private String vaultType;
        public Builder() {}
        public Builder(GetVaultsVault defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.bucketName = defaults.bucketName;
    	      this.bytesDone = defaults.bytesDone;
    	      this.createdTime = defaults.createdTime;
    	      this.dedup = defaults.dedup;
    	      this.description = defaults.description;
    	      this.id = defaults.id;
    	      this.indexAvailable = defaults.indexAvailable;
    	      this.indexLevel = defaults.indexLevel;
    	      this.indexUpdateTime = defaults.indexUpdateTime;
    	      this.latestReplicationTime = defaults.latestReplicationTime;
    	      this.paymentType = defaults.paymentType;
    	      this.replication = defaults.replication;
    	      this.replicationSourceRegionId = defaults.replicationSourceRegionId;
    	      this.replicationSourceVaultId = defaults.replicationSourceVaultId;
    	      this.retention = defaults.retention;
    	      this.searchEnabled = defaults.searchEnabled;
    	      this.sourceTypes = defaults.sourceTypes;
    	      this.status = defaults.status;
    	      this.storageSize = defaults.storageSize;
    	      this.updatedTime = defaults.updatedTime;
    	      this.vaultId = defaults.vaultId;
    	      this.vaultName = defaults.vaultName;
    	      this.vaultStatusMessage = defaults.vaultStatusMessage;
    	      this.vaultStorageClass = defaults.vaultStorageClass;
    	      this.vaultType = defaults.vaultType;
        }

        @CustomType.Setter
        public Builder bucketName(String bucketName) {
            this.bucketName = Objects.requireNonNull(bucketName);
            return this;
        }
        @CustomType.Setter
        public Builder bytesDone(String bytesDone) {
            this.bytesDone = Objects.requireNonNull(bytesDone);
            return this;
        }
        @CustomType.Setter
        public Builder createdTime(String createdTime) {
            this.createdTime = Objects.requireNonNull(createdTime);
            return this;
        }
        @CustomType.Setter
        public Builder dedup(Boolean dedup) {
            this.dedup = Objects.requireNonNull(dedup);
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder indexAvailable(Boolean indexAvailable) {
            this.indexAvailable = Objects.requireNonNull(indexAvailable);
            return this;
        }
        @CustomType.Setter
        public Builder indexLevel(String indexLevel) {
            this.indexLevel = Objects.requireNonNull(indexLevel);
            return this;
        }
        @CustomType.Setter
        public Builder indexUpdateTime(String indexUpdateTime) {
            this.indexUpdateTime = Objects.requireNonNull(indexUpdateTime);
            return this;
        }
        @CustomType.Setter
        public Builder latestReplicationTime(String latestReplicationTime) {
            this.latestReplicationTime = Objects.requireNonNull(latestReplicationTime);
            return this;
        }
        @CustomType.Setter
        public Builder paymentType(String paymentType) {
            this.paymentType = Objects.requireNonNull(paymentType);
            return this;
        }
        @CustomType.Setter
        public Builder replication(Boolean replication) {
            this.replication = Objects.requireNonNull(replication);
            return this;
        }
        @CustomType.Setter
        public Builder replicationSourceRegionId(String replicationSourceRegionId) {
            this.replicationSourceRegionId = Objects.requireNonNull(replicationSourceRegionId);
            return this;
        }
        @CustomType.Setter
        public Builder replicationSourceVaultId(String replicationSourceVaultId) {
            this.replicationSourceVaultId = Objects.requireNonNull(replicationSourceVaultId);
            return this;
        }
        @CustomType.Setter
        public Builder retention(String retention) {
            this.retention = Objects.requireNonNull(retention);
            return this;
        }
        @CustomType.Setter
        public Builder searchEnabled(Boolean searchEnabled) {
            this.searchEnabled = Objects.requireNonNull(searchEnabled);
            return this;
        }
        @CustomType.Setter
        public Builder sourceTypes(List<String> sourceTypes) {
            this.sourceTypes = Objects.requireNonNull(sourceTypes);
            return this;
        }
        public Builder sourceTypes(String... sourceTypes) {
            return sourceTypes(List.of(sourceTypes));
        }
        @CustomType.Setter
        public Builder status(String status) {
            this.status = Objects.requireNonNull(status);
            return this;
        }
        @CustomType.Setter
        public Builder storageSize(String storageSize) {
            this.storageSize = Objects.requireNonNull(storageSize);
            return this;
        }
        @CustomType.Setter
        public Builder updatedTime(String updatedTime) {
            this.updatedTime = Objects.requireNonNull(updatedTime);
            return this;
        }
        @CustomType.Setter
        public Builder vaultId(String vaultId) {
            this.vaultId = Objects.requireNonNull(vaultId);
            return this;
        }
        @CustomType.Setter
        public Builder vaultName(String vaultName) {
            this.vaultName = Objects.requireNonNull(vaultName);
            return this;
        }
        @CustomType.Setter
        public Builder vaultStatusMessage(String vaultStatusMessage) {
            this.vaultStatusMessage = Objects.requireNonNull(vaultStatusMessage);
            return this;
        }
        @CustomType.Setter
        public Builder vaultStorageClass(String vaultStorageClass) {
            this.vaultStorageClass = Objects.requireNonNull(vaultStorageClass);
            return this;
        }
        @CustomType.Setter
        public Builder vaultType(String vaultType) {
            this.vaultType = Objects.requireNonNull(vaultType);
            return this;
        }
        public GetVaultsVault build() {
            final var o = new GetVaultsVault();
            o.bucketName = bucketName;
            o.bytesDone = bytesDone;
            o.createdTime = createdTime;
            o.dedup = dedup;
            o.description = description;
            o.id = id;
            o.indexAvailable = indexAvailable;
            o.indexLevel = indexLevel;
            o.indexUpdateTime = indexUpdateTime;
            o.latestReplicationTime = latestReplicationTime;
            o.paymentType = paymentType;
            o.replication = replication;
            o.replicationSourceRegionId = replicationSourceRegionId;
            o.replicationSourceVaultId = replicationSourceVaultId;
            o.retention = retention;
            o.searchEnabled = searchEnabled;
            o.sourceTypes = sourceTypes;
            o.status = status;
            o.storageSize = storageSize;
            o.updatedTime = updatedTime;
            o.vaultId = vaultId;
            o.vaultName = vaultName;
            o.vaultStatusMessage = vaultStatusMessage;
            o.vaultStorageClass = vaultStorageClass;
            o.vaultType = vaultType;
            return o;
        }
    }
}
