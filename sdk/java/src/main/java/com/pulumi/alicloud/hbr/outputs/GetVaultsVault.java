// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.hbr.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetVaultsVault {
    /**
     * @return The name of the OSS bucket of the Vault.
     * 
     */
    private String bucketName;
    /**
     * @return The amount of backup data. The unit is Byte.
     * 
     */
    private String bytesDone;
    /**
     * @return The creation time of the Vault. UNIX time in seconds.
     * 
     */
    private String createdTime;
    /**
     * @return Whether to enable the deduplication function for the database backup Vault.
     * 
     */
    private Boolean dedup;
    /**
     * @return The description of the vault.
     * 
     */
    private String description;
    /**
     * @return The ID of vault.
     * 
     */
    private String id;
    /**
     * @return Index available.
     * 
     */
    private Boolean indexAvailable;
    /**
     * @return Index level.
     * 
     */
    private String indexLevel;
    /**
     * @return Index update time.
     * 
     */
    private String indexUpdateTime;
    /**
     * @return The time of the last remote backup synchronization.
     * 
     */
    private String latestReplicationTime;
    /**
     * @return Billing model, possible values:
     * * `FREE` is not billed
     * * `V1` common vault billing model, including back-end storage capacity, client licenses and other billing items
     * * `V2` new version of metering mode
     * * `AEGIS` Billing method for cloud security use
     * * `UNI_BACKUP` the backup of deduplication database
     * * `ARCHIVE` archive library.
     * 
     */
    private String paymentType;
    /**
     * @return Whether it is a remote backup warehouse. It&#39;s a boolean value.
     * 
     */
    private Boolean replication;
    /**
     * @return The region ID to which the remote backup Vault belongs.
     * 
     */
    private String replicationSourceRegionId;
    /**
     * @return The source vault ID of the remote backup Vault.
     * 
     */
    private String replicationSourceVaultId;
    /**
     * @return Warehouse-level data retention days, only valid for archive libraries.
     * 
     */
    private String retention;
    /**
     * @return Whether to enable the backup search function.
     * 
     */
    private Boolean searchEnabled;
    private List<String> sourceTypes;
    /**
     * @return The status of Vault. Valid values: `CREATED`, `ERROR`, `UNKNOWN`.
     * 
     */
    private String status;
    /**
     * @return Backup vault storage usage. The unit is Byte.
     * 
     */
    private String storageSize;
    /**
     * @return The update time of the Vault. UNIX time in seconds.
     * 
     */
    private String updatedTime;
    /**
     * @return The ID of vault, same as `id`.
     * 
     */
    private String vaultId;
    /**
     * @return The name of vault.
     * 
     */
    private String vaultName;
    /**
     * @return Error status information of Vault. Only valid for remote backup warehouses. Only the remote backup warehouse is valid.
     * 
     */
    private String vaultStatusMessage;
    /**
     * @return The storage class of vault. Valid values: `STANDARD`.
     * 
     */
    private String vaultStorageClass;
    /**
     * @return The type of Vault. Valid values: `STANDARD`,`OTS_BACKUP`.
     * 
     */
    private String vaultType;

    private GetVaultsVault() {}
    /**
     * @return The name of the OSS bucket of the Vault.
     * 
     */
    public String bucketName() {
        return this.bucketName;
    }
    /**
     * @return The amount of backup data. The unit is Byte.
     * 
     */
    public String bytesDone() {
        return this.bytesDone;
    }
    /**
     * @return The creation time of the Vault. UNIX time in seconds.
     * 
     */
    public String createdTime() {
        return this.createdTime;
    }
    /**
     * @return Whether to enable the deduplication function for the database backup Vault.
     * 
     */
    public Boolean dedup() {
        return this.dedup;
    }
    /**
     * @return The description of the vault.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return The ID of vault.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Index available.
     * 
     */
    public Boolean indexAvailable() {
        return this.indexAvailable;
    }
    /**
     * @return Index level.
     * 
     */
    public String indexLevel() {
        return this.indexLevel;
    }
    /**
     * @return Index update time.
     * 
     */
    public String indexUpdateTime() {
        return this.indexUpdateTime;
    }
    /**
     * @return The time of the last remote backup synchronization.
     * 
     */
    public String latestReplicationTime() {
        return this.latestReplicationTime;
    }
    /**
     * @return Billing model, possible values:
     * * `FREE` is not billed
     * * `V1` common vault billing model, including back-end storage capacity, client licenses and other billing items
     * * `V2` new version of metering mode
     * * `AEGIS` Billing method for cloud security use
     * * `UNI_BACKUP` the backup of deduplication database
     * * `ARCHIVE` archive library.
     * 
     */
    public String paymentType() {
        return this.paymentType;
    }
    /**
     * @return Whether it is a remote backup warehouse. It&#39;s a boolean value.
     * 
     */
    public Boolean replication() {
        return this.replication;
    }
    /**
     * @return The region ID to which the remote backup Vault belongs.
     * 
     */
    public String replicationSourceRegionId() {
        return this.replicationSourceRegionId;
    }
    /**
     * @return The source vault ID of the remote backup Vault.
     * 
     */
    public String replicationSourceVaultId() {
        return this.replicationSourceVaultId;
    }
    /**
     * @return Warehouse-level data retention days, only valid for archive libraries.
     * 
     */
    public String retention() {
        return this.retention;
    }
    /**
     * @return Whether to enable the backup search function.
     * 
     */
    public Boolean searchEnabled() {
        return this.searchEnabled;
    }
    public List<String> sourceTypes() {
        return this.sourceTypes;
    }
    /**
     * @return The status of Vault. Valid values: `CREATED`, `ERROR`, `UNKNOWN`.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Backup vault storage usage. The unit is Byte.
     * 
     */
    public String storageSize() {
        return this.storageSize;
    }
    /**
     * @return The update time of the Vault. UNIX time in seconds.
     * 
     */
    public String updatedTime() {
        return this.updatedTime;
    }
    /**
     * @return The ID of vault, same as `id`.
     * 
     */
    public String vaultId() {
        return this.vaultId;
    }
    /**
     * @return The name of vault.
     * 
     */
    public String vaultName() {
        return this.vaultName;
    }
    /**
     * @return Error status information of Vault. Only valid for remote backup warehouses. Only the remote backup warehouse is valid.
     * 
     */
    public String vaultStatusMessage() {
        return this.vaultStatusMessage;
    }
    /**
     * @return The storage class of vault. Valid values: `STANDARD`.
     * 
     */
    public String vaultStorageClass() {
        return this.vaultStorageClass;
    }
    /**
     * @return The type of Vault. Valid values: `STANDARD`,`OTS_BACKUP`.
     * 
     */
    public String vaultType() {
        return this.vaultType;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetVaultsVault defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String bucketName;
        private String bytesDone;
        private String createdTime;
        private Boolean dedup;
        private String description;
        private String id;
        private Boolean indexAvailable;
        private String indexLevel;
        private String indexUpdateTime;
        private String latestReplicationTime;
        private String paymentType;
        private Boolean replication;
        private String replicationSourceRegionId;
        private String replicationSourceVaultId;
        private String retention;
        private Boolean searchEnabled;
        private List<String> sourceTypes;
        private String status;
        private String storageSize;
        private String updatedTime;
        private String vaultId;
        private String vaultName;
        private String vaultStatusMessage;
        private String vaultStorageClass;
        private String vaultType;
        public Builder() {}
        public Builder(GetVaultsVault defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.bucketName = defaults.bucketName;
    	      this.bytesDone = defaults.bytesDone;
    	      this.createdTime = defaults.createdTime;
    	      this.dedup = defaults.dedup;
    	      this.description = defaults.description;
    	      this.id = defaults.id;
    	      this.indexAvailable = defaults.indexAvailable;
    	      this.indexLevel = defaults.indexLevel;
    	      this.indexUpdateTime = defaults.indexUpdateTime;
    	      this.latestReplicationTime = defaults.latestReplicationTime;
    	      this.paymentType = defaults.paymentType;
    	      this.replication = defaults.replication;
    	      this.replicationSourceRegionId = defaults.replicationSourceRegionId;
    	      this.replicationSourceVaultId = defaults.replicationSourceVaultId;
    	      this.retention = defaults.retention;
    	      this.searchEnabled = defaults.searchEnabled;
    	      this.sourceTypes = defaults.sourceTypes;
    	      this.status = defaults.status;
    	      this.storageSize = defaults.storageSize;
    	      this.updatedTime = defaults.updatedTime;
    	      this.vaultId = defaults.vaultId;
    	      this.vaultName = defaults.vaultName;
    	      this.vaultStatusMessage = defaults.vaultStatusMessage;
    	      this.vaultStorageClass = defaults.vaultStorageClass;
    	      this.vaultType = defaults.vaultType;
        }

        @CustomType.Setter
        public Builder bucketName(String bucketName) {
            if (bucketName == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "bucketName");
            }
            this.bucketName = bucketName;
            return this;
        }
        @CustomType.Setter
        public Builder bytesDone(String bytesDone) {
            if (bytesDone == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "bytesDone");
            }
            this.bytesDone = bytesDone;
            return this;
        }
        @CustomType.Setter
        public Builder createdTime(String createdTime) {
            if (createdTime == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "createdTime");
            }
            this.createdTime = createdTime;
            return this;
        }
        @CustomType.Setter
        public Builder dedup(Boolean dedup) {
            if (dedup == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "dedup");
            }
            this.dedup = dedup;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder indexAvailable(Boolean indexAvailable) {
            if (indexAvailable == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "indexAvailable");
            }
            this.indexAvailable = indexAvailable;
            return this;
        }
        @CustomType.Setter
        public Builder indexLevel(String indexLevel) {
            if (indexLevel == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "indexLevel");
            }
            this.indexLevel = indexLevel;
            return this;
        }
        @CustomType.Setter
        public Builder indexUpdateTime(String indexUpdateTime) {
            if (indexUpdateTime == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "indexUpdateTime");
            }
            this.indexUpdateTime = indexUpdateTime;
            return this;
        }
        @CustomType.Setter
        public Builder latestReplicationTime(String latestReplicationTime) {
            if (latestReplicationTime == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "latestReplicationTime");
            }
            this.latestReplicationTime = latestReplicationTime;
            return this;
        }
        @CustomType.Setter
        public Builder paymentType(String paymentType) {
            if (paymentType == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "paymentType");
            }
            this.paymentType = paymentType;
            return this;
        }
        @CustomType.Setter
        public Builder replication(Boolean replication) {
            if (replication == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "replication");
            }
            this.replication = replication;
            return this;
        }
        @CustomType.Setter
        public Builder replicationSourceRegionId(String replicationSourceRegionId) {
            if (replicationSourceRegionId == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "replicationSourceRegionId");
            }
            this.replicationSourceRegionId = replicationSourceRegionId;
            return this;
        }
        @CustomType.Setter
        public Builder replicationSourceVaultId(String replicationSourceVaultId) {
            if (replicationSourceVaultId == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "replicationSourceVaultId");
            }
            this.replicationSourceVaultId = replicationSourceVaultId;
            return this;
        }
        @CustomType.Setter
        public Builder retention(String retention) {
            if (retention == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "retention");
            }
            this.retention = retention;
            return this;
        }
        @CustomType.Setter
        public Builder searchEnabled(Boolean searchEnabled) {
            if (searchEnabled == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "searchEnabled");
            }
            this.searchEnabled = searchEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder sourceTypes(List<String> sourceTypes) {
            if (sourceTypes == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "sourceTypes");
            }
            this.sourceTypes = sourceTypes;
            return this;
        }
        public Builder sourceTypes(String... sourceTypes) {
            return sourceTypes(List.of(sourceTypes));
        }
        @CustomType.Setter
        public Builder status(String status) {
            if (status == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "status");
            }
            this.status = status;
            return this;
        }
        @CustomType.Setter
        public Builder storageSize(String storageSize) {
            if (storageSize == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "storageSize");
            }
            this.storageSize = storageSize;
            return this;
        }
        @CustomType.Setter
        public Builder updatedTime(String updatedTime) {
            if (updatedTime == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "updatedTime");
            }
            this.updatedTime = updatedTime;
            return this;
        }
        @CustomType.Setter
        public Builder vaultId(String vaultId) {
            if (vaultId == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "vaultId");
            }
            this.vaultId = vaultId;
            return this;
        }
        @CustomType.Setter
        public Builder vaultName(String vaultName) {
            if (vaultName == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "vaultName");
            }
            this.vaultName = vaultName;
            return this;
        }
        @CustomType.Setter
        public Builder vaultStatusMessage(String vaultStatusMessage) {
            if (vaultStatusMessage == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "vaultStatusMessage");
            }
            this.vaultStatusMessage = vaultStatusMessage;
            return this;
        }
        @CustomType.Setter
        public Builder vaultStorageClass(String vaultStorageClass) {
            if (vaultStorageClass == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "vaultStorageClass");
            }
            this.vaultStorageClass = vaultStorageClass;
            return this;
        }
        @CustomType.Setter
        public Builder vaultType(String vaultType) {
            if (vaultType == null) {
              throw new MissingRequiredPropertyException("GetVaultsVault", "vaultType");
            }
            this.vaultType = vaultType;
            return this;
        }
        public GetVaultsVault build() {
            final var _resultValue = new GetVaultsVault();
            _resultValue.bucketName = bucketName;
            _resultValue.bytesDone = bytesDone;
            _resultValue.createdTime = createdTime;
            _resultValue.dedup = dedup;
            _resultValue.description = description;
            _resultValue.id = id;
            _resultValue.indexAvailable = indexAvailable;
            _resultValue.indexLevel = indexLevel;
            _resultValue.indexUpdateTime = indexUpdateTime;
            _resultValue.latestReplicationTime = latestReplicationTime;
            _resultValue.paymentType = paymentType;
            _resultValue.replication = replication;
            _resultValue.replicationSourceRegionId = replicationSourceRegionId;
            _resultValue.replicationSourceVaultId = replicationSourceVaultId;
            _resultValue.retention = retention;
            _resultValue.searchEnabled = searchEnabled;
            _resultValue.sourceTypes = sourceTypes;
            _resultValue.status = status;
            _resultValue.storageSize = storageSize;
            _resultValue.updatedTime = updatedTime;
            _resultValue.vaultId = vaultId;
            _resultValue.vaultName = vaultName;
            _resultValue.vaultStatusMessage = vaultStatusMessage;
            _resultValue.vaultStorageClass = vaultStorageClass;
            _resultValue.vaultType = vaultType;
            return _resultValue;
        }
    }
}
