// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.wafv3.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetDomainsDomainListen {
    /**
     * @return The ID of the certificate to be added. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private String certId;
    /**
     * @return The type of encryption suite to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private Integer cipherSuite;
    /**
     * @return The specific custom encryption suite to add.
     * 
     */
    private List<String> customCiphers;
    /**
     * @return Whether TSL1.3 version is supported. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private Boolean enableTlsv3;
    /**
     * @return Whether to enable exclusive IP address. This parameter is used only when the value of **ipv6_enabled** is **false** (indicating that IPv6 is not enabled) and the value of **protection_resource** is **share** (indicating that a shared cluster is used).
     * 
     */
    private Boolean exclusiveIp;
    /**
     * @return Whether to enable the forced jump of HTTPS. This parameter is used only when the value of `https_ports` is not empty (indicating that the domain name uses HTTPS protocol) and the value of httports is empty (indicating that the domain name does not use HTTP protocol).
     * 
     */
    private Boolean focusHttps;
    /**
     * @return Whether to turn on http2. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private Boolean http2Enabled;
    /**
     * @return The listening port of the HTTP protocol.
     * 
     */
    private List<Integer> httpPorts;
    /**
     * @return The listening port of the HTTPS protocol.
     * 
     */
    private List<Integer> httpsPorts;
    /**
     * @return Whether IPv6 is turned on.
     * 
     */
    private Boolean ipv6Enabled;
    /**
     * @return The type of protection resource to use.
     * 
     */
    private String protectionResource;
    /**
     * @return The version of TLS to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private String tlsVersion;
    /**
     * @return WAF obtains the real IP address of the client.
     * 
     */
    private Integer xffHeaderMode;
    /**
     * @return Set the list of custom fields used to obtain the client IP address.
     * 
     */
    private List<String> xffHeaders;

    private GetDomainsDomainListen() {}
    /**
     * @return The ID of the certificate to be added. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public String certId() {
        return this.certId;
    }
    /**
     * @return The type of encryption suite to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public Integer cipherSuite() {
        return this.cipherSuite;
    }
    /**
     * @return The specific custom encryption suite to add.
     * 
     */
    public List<String> customCiphers() {
        return this.customCiphers;
    }
    /**
     * @return Whether TSL1.3 version is supported. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public Boolean enableTlsv3() {
        return this.enableTlsv3;
    }
    /**
     * @return Whether to enable exclusive IP address. This parameter is used only when the value of **ipv6_enabled** is **false** (indicating that IPv6 is not enabled) and the value of **protection_resource** is **share** (indicating that a shared cluster is used).
     * 
     */
    public Boolean exclusiveIp() {
        return this.exclusiveIp;
    }
    /**
     * @return Whether to enable the forced jump of HTTPS. This parameter is used only when the value of `https_ports` is not empty (indicating that the domain name uses HTTPS protocol) and the value of httports is empty (indicating that the domain name does not use HTTP protocol).
     * 
     */
    public Boolean focusHttps() {
        return this.focusHttps;
    }
    /**
     * @return Whether to turn on http2. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public Boolean http2Enabled() {
        return this.http2Enabled;
    }
    /**
     * @return The listening port of the HTTP protocol.
     * 
     */
    public List<Integer> httpPorts() {
        return this.httpPorts;
    }
    /**
     * @return The listening port of the HTTPS protocol.
     * 
     */
    public List<Integer> httpsPorts() {
        return this.httpsPorts;
    }
    /**
     * @return Whether IPv6 is turned on.
     * 
     */
    public Boolean ipv6Enabled() {
        return this.ipv6Enabled;
    }
    /**
     * @return The type of protection resource to use.
     * 
     */
    public String protectionResource() {
        return this.protectionResource;
    }
    /**
     * @return The version of TLS to add. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public String tlsVersion() {
        return this.tlsVersion;
    }
    /**
     * @return WAF obtains the real IP address of the client.
     * 
     */
    public Integer xffHeaderMode() {
        return this.xffHeaderMode;
    }
    /**
     * @return Set the list of custom fields used to obtain the client IP address.
     * 
     */
    public List<String> xffHeaders() {
        return this.xffHeaders;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDomainsDomainListen defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String certId;
        private Integer cipherSuite;
        private List<String> customCiphers;
        private Boolean enableTlsv3;
        private Boolean exclusiveIp;
        private Boolean focusHttps;
        private Boolean http2Enabled;
        private List<Integer> httpPorts;
        private List<Integer> httpsPorts;
        private Boolean ipv6Enabled;
        private String protectionResource;
        private String tlsVersion;
        private Integer xffHeaderMode;
        private List<String> xffHeaders;
        public Builder() {}
        public Builder(GetDomainsDomainListen defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.certId = defaults.certId;
    	      this.cipherSuite = defaults.cipherSuite;
    	      this.customCiphers = defaults.customCiphers;
    	      this.enableTlsv3 = defaults.enableTlsv3;
    	      this.exclusiveIp = defaults.exclusiveIp;
    	      this.focusHttps = defaults.focusHttps;
    	      this.http2Enabled = defaults.http2Enabled;
    	      this.httpPorts = defaults.httpPorts;
    	      this.httpsPorts = defaults.httpsPorts;
    	      this.ipv6Enabled = defaults.ipv6Enabled;
    	      this.protectionResource = defaults.protectionResource;
    	      this.tlsVersion = defaults.tlsVersion;
    	      this.xffHeaderMode = defaults.xffHeaderMode;
    	      this.xffHeaders = defaults.xffHeaders;
        }

        @CustomType.Setter
        public Builder certId(String certId) {
            if (certId == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "certId");
            }
            this.certId = certId;
            return this;
        }
        @CustomType.Setter
        public Builder cipherSuite(Integer cipherSuite) {
            if (cipherSuite == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "cipherSuite");
            }
            this.cipherSuite = cipherSuite;
            return this;
        }
        @CustomType.Setter
        public Builder customCiphers(List<String> customCiphers) {
            if (customCiphers == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "customCiphers");
            }
            this.customCiphers = customCiphers;
            return this;
        }
        public Builder customCiphers(String... customCiphers) {
            return customCiphers(List.of(customCiphers));
        }
        @CustomType.Setter
        public Builder enableTlsv3(Boolean enableTlsv3) {
            if (enableTlsv3 == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "enableTlsv3");
            }
            this.enableTlsv3 = enableTlsv3;
            return this;
        }
        @CustomType.Setter
        public Builder exclusiveIp(Boolean exclusiveIp) {
            if (exclusiveIp == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "exclusiveIp");
            }
            this.exclusiveIp = exclusiveIp;
            return this;
        }
        @CustomType.Setter
        public Builder focusHttps(Boolean focusHttps) {
            if (focusHttps == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "focusHttps");
            }
            this.focusHttps = focusHttps;
            return this;
        }
        @CustomType.Setter
        public Builder http2Enabled(Boolean http2Enabled) {
            if (http2Enabled == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "http2Enabled");
            }
            this.http2Enabled = http2Enabled;
            return this;
        }
        @CustomType.Setter
        public Builder httpPorts(List<Integer> httpPorts) {
            if (httpPorts == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "httpPorts");
            }
            this.httpPorts = httpPorts;
            return this;
        }
        public Builder httpPorts(Integer... httpPorts) {
            return httpPorts(List.of(httpPorts));
        }
        @CustomType.Setter
        public Builder httpsPorts(List<Integer> httpsPorts) {
            if (httpsPorts == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "httpsPorts");
            }
            this.httpsPorts = httpsPorts;
            return this;
        }
        public Builder httpsPorts(Integer... httpsPorts) {
            return httpsPorts(List.of(httpsPorts));
        }
        @CustomType.Setter
        public Builder ipv6Enabled(Boolean ipv6Enabled) {
            if (ipv6Enabled == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "ipv6Enabled");
            }
            this.ipv6Enabled = ipv6Enabled;
            return this;
        }
        @CustomType.Setter
        public Builder protectionResource(String protectionResource) {
            if (protectionResource == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "protectionResource");
            }
            this.protectionResource = protectionResource;
            return this;
        }
        @CustomType.Setter
        public Builder tlsVersion(String tlsVersion) {
            if (tlsVersion == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "tlsVersion");
            }
            this.tlsVersion = tlsVersion;
            return this;
        }
        @CustomType.Setter
        public Builder xffHeaderMode(Integer xffHeaderMode) {
            if (xffHeaderMode == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "xffHeaderMode");
            }
            this.xffHeaderMode = xffHeaderMode;
            return this;
        }
        @CustomType.Setter
        public Builder xffHeaders(List<String> xffHeaders) {
            if (xffHeaders == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainListen", "xffHeaders");
            }
            this.xffHeaders = xffHeaders;
            return this;
        }
        public Builder xffHeaders(String... xffHeaders) {
            return xffHeaders(List.of(xffHeaders));
        }
        public GetDomainsDomainListen build() {
            final var _resultValue = new GetDomainsDomainListen();
            _resultValue.certId = certId;
            _resultValue.cipherSuite = cipherSuite;
            _resultValue.customCiphers = customCiphers;
            _resultValue.enableTlsv3 = enableTlsv3;
            _resultValue.exclusiveIp = exclusiveIp;
            _resultValue.focusHttps = focusHttps;
            _resultValue.http2Enabled = http2Enabled;
            _resultValue.httpPorts = httpPorts;
            _resultValue.httpsPorts = httpsPorts;
            _resultValue.ipv6Enabled = ipv6Enabled;
            _resultValue.protectionResource = protectionResource;
            _resultValue.tlsVersion = tlsVersion;
            _resultValue.xffHeaderMode = xffHeaderMode;
            _resultValue.xffHeaders = xffHeaders;
            return _resultValue;
        }
    }
}
