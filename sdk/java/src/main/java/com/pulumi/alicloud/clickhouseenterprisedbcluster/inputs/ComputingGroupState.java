// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.clickhouseenterprisedbcluster.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ComputingGroupState extends com.pulumi.resources.ResourceArgs {

    public static final ComputingGroupState Empty = new ComputingGroupState();

    /**
     * Computing group name
     * 
     */
    @Import(name="computingGroupDescription")
    private @Nullable Output<String> computingGroupDescription;

    /**
     * @return Computing group name
     * 
     */
    public Optional<Output<String>> computingGroupDescription() {
        return Optional.ofNullable(this.computingGroupDescription);
    }

    /**
     * A list of computing group endpoint names.
     * 
     */
    @Import(name="computingGroupEndpointNames")
    private @Nullable Output<List<String>> computingGroupEndpointNames;

    /**
     * @return A list of computing group endpoint names.
     * 
     */
    public Optional<Output<List<String>>> computingGroupEndpointNames() {
        return Optional.ofNullable(this.computingGroupEndpointNames);
    }

    /**
     * List of computing group endpoints.
     * 
     */
    @Import(name="computingGroupEndpoints")
    private @Nullable Output<List<String>> computingGroupEndpoints;

    /**
     * @return List of computing group endpoints.
     * 
     */
    public Optional<Output<List<String>>> computingGroupEndpoints() {
        return Optional.ofNullable(this.computingGroupEndpoints);
    }

    /**
     * A resource property field representing the primary resource ID.
     * 
     */
    @Import(name="computingGroupId")
    private @Nullable Output<String> computingGroupId;

    /**
     * @return A resource property field representing the primary resource ID.
     * 
     */
    public Optional<Output<String>> computingGroupId() {
        return Optional.ofNullable(this.computingGroupId);
    }

    /**
     * List of public endpoints for the computing group.
     * 
     */
    @Import(name="computingGroupPublicEndpoints")
    private @Nullable Output<List<String>> computingGroupPublicEndpoints;

    /**
     * @return List of public endpoints for the computing group.
     * 
     */
    public Optional<Output<List<String>>> computingGroupPublicEndpoints() {
        return Optional.ofNullable(this.computingGroupPublicEndpoints);
    }

    /**
     * Computing group status.
     * 
     */
    @Import(name="computingGroupStatus")
    private @Nullable Output<String> computingGroupStatus;

    /**
     * @return Computing group status.
     * 
     */
    public Optional<Output<String>> computingGroupStatus() {
        return Optional.ofNullable(this.computingGroupStatus);
    }

    /**
     * ClickHouse Enterprise Edition instance ID
     * 
     */
    @Import(name="dbInstanceId")
    private @Nullable Output<String> dbInstanceId;

    /**
     * @return ClickHouse Enterprise Edition instance ID
     * 
     */
    public Optional<Output<String>> dbInstanceId() {
        return Optional.ofNullable(this.dbInstanceId);
    }

    /**
     * Computing group read-only
     * 
     */
    @Import(name="isReadonly")
    private @Nullable Output<Boolean> isReadonly;

    /**
     * @return Computing group read-only
     * 
     */
    public Optional<Output<Boolean>> isReadonly() {
        return Optional.ofNullable(this.isReadonly);
    }

    /**
     * Number of computing group nodes
     * 
     */
    @Import(name="nodeCount")
    private @Nullable Output<Integer> nodeCount;

    /**
     * @return Number of computing group nodes
     * 
     */
    public Optional<Output<Integer>> nodeCount() {
        return Optional.ofNullable(this.nodeCount);
    }

    /**
     * Computing group node elasticity upper limit
     * 
     */
    @Import(name="nodeScaleMax")
    private @Nullable Output<Integer> nodeScaleMax;

    /**
     * @return Computing group node elasticity upper limit
     * 
     */
    public Optional<Output<Integer>> nodeScaleMax() {
        return Optional.ofNullable(this.nodeScaleMax);
    }

    /**
     * Lower limit of computing group node elasticity
     * 
     */
    @Import(name="nodeScaleMin")
    private @Nullable Output<Integer> nodeScaleMin;

    /**
     * @return Lower limit of computing group node elasticity
     * 
     */
    public Optional<Output<Integer>> nodeScaleMin() {
        return Optional.ofNullable(this.nodeScaleMin);
    }

    private ComputingGroupState() {}

    private ComputingGroupState(ComputingGroupState $) {
        this.computingGroupDescription = $.computingGroupDescription;
        this.computingGroupEndpointNames = $.computingGroupEndpointNames;
        this.computingGroupEndpoints = $.computingGroupEndpoints;
        this.computingGroupId = $.computingGroupId;
        this.computingGroupPublicEndpoints = $.computingGroupPublicEndpoints;
        this.computingGroupStatus = $.computingGroupStatus;
        this.dbInstanceId = $.dbInstanceId;
        this.isReadonly = $.isReadonly;
        this.nodeCount = $.nodeCount;
        this.nodeScaleMax = $.nodeScaleMax;
        this.nodeScaleMin = $.nodeScaleMin;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ComputingGroupState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ComputingGroupState $;

        public Builder() {
            $ = new ComputingGroupState();
        }

        public Builder(ComputingGroupState defaults) {
            $ = new ComputingGroupState(Objects.requireNonNull(defaults));
        }

        /**
         * @param computingGroupDescription Computing group name
         * 
         * @return builder
         * 
         */
        public Builder computingGroupDescription(@Nullable Output<String> computingGroupDescription) {
            $.computingGroupDescription = computingGroupDescription;
            return this;
        }

        /**
         * @param computingGroupDescription Computing group name
         * 
         * @return builder
         * 
         */
        public Builder computingGroupDescription(String computingGroupDescription) {
            return computingGroupDescription(Output.of(computingGroupDescription));
        }

        /**
         * @param computingGroupEndpointNames A list of computing group endpoint names.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupEndpointNames(@Nullable Output<List<String>> computingGroupEndpointNames) {
            $.computingGroupEndpointNames = computingGroupEndpointNames;
            return this;
        }

        /**
         * @param computingGroupEndpointNames A list of computing group endpoint names.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupEndpointNames(List<String> computingGroupEndpointNames) {
            return computingGroupEndpointNames(Output.of(computingGroupEndpointNames));
        }

        /**
         * @param computingGroupEndpointNames A list of computing group endpoint names.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupEndpointNames(String... computingGroupEndpointNames) {
            return computingGroupEndpointNames(List.of(computingGroupEndpointNames));
        }

        /**
         * @param computingGroupEndpoints List of computing group endpoints.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupEndpoints(@Nullable Output<List<String>> computingGroupEndpoints) {
            $.computingGroupEndpoints = computingGroupEndpoints;
            return this;
        }

        /**
         * @param computingGroupEndpoints List of computing group endpoints.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupEndpoints(List<String> computingGroupEndpoints) {
            return computingGroupEndpoints(Output.of(computingGroupEndpoints));
        }

        /**
         * @param computingGroupEndpoints List of computing group endpoints.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupEndpoints(String... computingGroupEndpoints) {
            return computingGroupEndpoints(List.of(computingGroupEndpoints));
        }

        /**
         * @param computingGroupId A resource property field representing the primary resource ID.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupId(@Nullable Output<String> computingGroupId) {
            $.computingGroupId = computingGroupId;
            return this;
        }

        /**
         * @param computingGroupId A resource property field representing the primary resource ID.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupId(String computingGroupId) {
            return computingGroupId(Output.of(computingGroupId));
        }

        /**
         * @param computingGroupPublicEndpoints List of public endpoints for the computing group.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupPublicEndpoints(@Nullable Output<List<String>> computingGroupPublicEndpoints) {
            $.computingGroupPublicEndpoints = computingGroupPublicEndpoints;
            return this;
        }

        /**
         * @param computingGroupPublicEndpoints List of public endpoints for the computing group.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupPublicEndpoints(List<String> computingGroupPublicEndpoints) {
            return computingGroupPublicEndpoints(Output.of(computingGroupPublicEndpoints));
        }

        /**
         * @param computingGroupPublicEndpoints List of public endpoints for the computing group.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupPublicEndpoints(String... computingGroupPublicEndpoints) {
            return computingGroupPublicEndpoints(List.of(computingGroupPublicEndpoints));
        }

        /**
         * @param computingGroupStatus Computing group status.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupStatus(@Nullable Output<String> computingGroupStatus) {
            $.computingGroupStatus = computingGroupStatus;
            return this;
        }

        /**
         * @param computingGroupStatus Computing group status.
         * 
         * @return builder
         * 
         */
        public Builder computingGroupStatus(String computingGroupStatus) {
            return computingGroupStatus(Output.of(computingGroupStatus));
        }

        /**
         * @param dbInstanceId ClickHouse Enterprise Edition instance ID
         * 
         * @return builder
         * 
         */
        public Builder dbInstanceId(@Nullable Output<String> dbInstanceId) {
            $.dbInstanceId = dbInstanceId;
            return this;
        }

        /**
         * @param dbInstanceId ClickHouse Enterprise Edition instance ID
         * 
         * @return builder
         * 
         */
        public Builder dbInstanceId(String dbInstanceId) {
            return dbInstanceId(Output.of(dbInstanceId));
        }

        /**
         * @param isReadonly Computing group read-only
         * 
         * @return builder
         * 
         */
        public Builder isReadonly(@Nullable Output<Boolean> isReadonly) {
            $.isReadonly = isReadonly;
            return this;
        }

        /**
         * @param isReadonly Computing group read-only
         * 
         * @return builder
         * 
         */
        public Builder isReadonly(Boolean isReadonly) {
            return isReadonly(Output.of(isReadonly));
        }

        /**
         * @param nodeCount Number of computing group nodes
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(@Nullable Output<Integer> nodeCount) {
            $.nodeCount = nodeCount;
            return this;
        }

        /**
         * @param nodeCount Number of computing group nodes
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(Integer nodeCount) {
            return nodeCount(Output.of(nodeCount));
        }

        /**
         * @param nodeScaleMax Computing group node elasticity upper limit
         * 
         * @return builder
         * 
         */
        public Builder nodeScaleMax(@Nullable Output<Integer> nodeScaleMax) {
            $.nodeScaleMax = nodeScaleMax;
            return this;
        }

        /**
         * @param nodeScaleMax Computing group node elasticity upper limit
         * 
         * @return builder
         * 
         */
        public Builder nodeScaleMax(Integer nodeScaleMax) {
            return nodeScaleMax(Output.of(nodeScaleMax));
        }

        /**
         * @param nodeScaleMin Lower limit of computing group node elasticity
         * 
         * @return builder
         * 
         */
        public Builder nodeScaleMin(@Nullable Output<Integer> nodeScaleMin) {
            $.nodeScaleMin = nodeScaleMin;
            return this;
        }

        /**
         * @param nodeScaleMin Lower limit of computing group node elasticity
         * 
         * @return builder
         * 
         */
        public Builder nodeScaleMin(Integer nodeScaleMin) {
            return nodeScaleMin(Output.of(nodeScaleMin));
        }

        public ComputingGroupState build() {
            return $;
        }
    }

}
