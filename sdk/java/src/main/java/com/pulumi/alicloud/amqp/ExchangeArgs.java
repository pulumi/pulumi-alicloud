// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.amqp;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ExchangeArgs extends com.pulumi.resources.ResourceArgs {

    public static final ExchangeArgs Empty = new ExchangeArgs();

    /**
     * The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
     * 
     */
    @Import(name="alternateExchange")
    private @Nullable Output<String> alternateExchange;

    /**
     * @return The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
     * 
     */
    public Optional<Output<String>> alternateExchange() {
        return Optional.ofNullable(this.alternateExchange);
    }

    /**
     * Specifies whether the Auto Delete attribute is configured. Valid values:
     * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
     * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
     * 
     */
    @Import(name="autoDeleteState", required=true)
    private Output<Boolean> autoDeleteState;

    /**
     * @return Specifies whether the Auto Delete attribute is configured. Valid values:
     * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
     * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
     * 
     */
    public Output<Boolean> autoDeleteState() {
        return this.autoDeleteState;
    }

    /**
     * The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
     * 
     */
    @Import(name="exchangeName", required=true)
    private Output<String> exchangeName;

    /**
     * @return The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
     * 
     */
    public Output<String> exchangeName() {
        return this.exchangeName;
    }

    /**
     * The type of the exchange. Valid values:
     * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
     * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
     * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
     * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
     *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
     *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
     *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
     * 
     */
    @Import(name="exchangeType", required=true)
    private Output<String> exchangeType;

    /**
     * @return The type of the exchange. Valid values:
     * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
     * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
     * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
     * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
     *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
     *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
     *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
     * 
     */
    public Output<String> exchangeType() {
        return this.exchangeType;
    }

    /**
     * The ID of the instance.
     * 
     */
    @Import(name="instanceId", required=true)
    private Output<String> instanceId;

    /**
     * @return The ID of the instance.
     * 
     */
    public Output<String> instanceId() {
        return this.instanceId;
    }

    /**
     * Specifies whether an exchange is an internal exchange. Valid values:
     * * false: The exchange is not an internal exchange.
     * * true: The exchange is an internal exchange.
     * 
     */
    @Import(name="internal", required=true)
    private Output<Boolean> internal;

    /**
     * @return Specifies whether an exchange is an internal exchange. Valid values:
     * * false: The exchange is not an internal exchange.
     * * true: The exchange is an internal exchange.
     * 
     */
    public Output<Boolean> internal() {
        return this.internal;
    }

    /**
     * The name of virtual host where an exchange resides.
     * 
     */
    @Import(name="virtualHostName", required=true)
    private Output<String> virtualHostName;

    /**
     * @return The name of virtual host where an exchange resides.
     * 
     */
    public Output<String> virtualHostName() {
        return this.virtualHostName;
    }

    private ExchangeArgs() {}

    private ExchangeArgs(ExchangeArgs $) {
        this.alternateExchange = $.alternateExchange;
        this.autoDeleteState = $.autoDeleteState;
        this.exchangeName = $.exchangeName;
        this.exchangeType = $.exchangeType;
        this.instanceId = $.instanceId;
        this.internal = $.internal;
        this.virtualHostName = $.virtualHostName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ExchangeArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ExchangeArgs $;

        public Builder() {
            $ = new ExchangeArgs();
        }

        public Builder(ExchangeArgs defaults) {
            $ = new ExchangeArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param alternateExchange The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
         * 
         * @return builder
         * 
         */
        public Builder alternateExchange(@Nullable Output<String> alternateExchange) {
            $.alternateExchange = alternateExchange;
            return this;
        }

        /**
         * @param alternateExchange The alternate exchange. An alternate exchange is configured for an existing exchange. It is used to receive messages that fail to be routed to queues from the existing exchange.
         * 
         * @return builder
         * 
         */
        public Builder alternateExchange(String alternateExchange) {
            return alternateExchange(Output.of(alternateExchange));
        }

        /**
         * @param autoDeleteState Specifies whether the Auto Delete attribute is configured. Valid values:
         * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
         * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
         * 
         * @return builder
         * 
         */
        public Builder autoDeleteState(Output<Boolean> autoDeleteState) {
            $.autoDeleteState = autoDeleteState;
            return this;
        }

        /**
         * @param autoDeleteState Specifies whether the Auto Delete attribute is configured. Valid values:
         * * true: The Auto Delete attribute is configured. If the last queue that is bound to an exchange is unbound, the exchange is automatically deleted.
         * * false: The Auto Delete attribute is not configured. If the last queue that is bound to an exchange is unbound, the exchange is not automatically deleted.
         * 
         * @return builder
         * 
         */
        public Builder autoDeleteState(Boolean autoDeleteState) {
            return autoDeleteState(Output.of(autoDeleteState));
        }

        /**
         * @param exchangeName The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
         * 
         * @return builder
         * 
         */
        public Builder exchangeName(Output<String> exchangeName) {
            $.exchangeName = exchangeName;
            return this;
        }

        /**
         * @param exchangeName The name of the exchange. It must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs ({@literal @}).
         * 
         * @return builder
         * 
         */
        public Builder exchangeName(String exchangeName) {
            return exchangeName(Output.of(exchangeName));
        }

        /**
         * @param exchangeType The type of the exchange. Valid values:
         * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
         * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
         * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
         * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
         *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
         *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
         *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
         * 
         * @return builder
         * 
         */
        public Builder exchangeType(Output<String> exchangeType) {
            $.exchangeType = exchangeType;
            return this;
        }

        /**
         * @param exchangeType The type of the exchange. Valid values:
         * * FANOUT: An exchange of this type routes all the received messages to all the queues bound to this exchange. You can use a fanout exchange to broadcast messages.
         * * DIRECT: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
         * * TOPIC: This type is similar to the direct exchange type. An exchange of this type routes a message to one or more queues based on the fuzzy match or multi-condition match result between the routing key of the message and the binding keys of the current exchange.
         * * HEADERS: Headers Exchange uses the Headers property instead of Routing Key for routing matching.
         *   When binding Headers Exchange and Queue, set the key-value pair of the binding property;
         *   when sending a message to the Headers Exchange, set the message&#39;s Headers property key-value pair and use the message Headers
         *   The message is routed to the bound Queue by comparing the attribute key-value pair and the bound attribute key-value pair.
         * 
         * @return builder
         * 
         */
        public Builder exchangeType(String exchangeType) {
            return exchangeType(Output.of(exchangeType));
        }

        /**
         * @param instanceId The ID of the instance.
         * 
         * @return builder
         * 
         */
        public Builder instanceId(Output<String> instanceId) {
            $.instanceId = instanceId;
            return this;
        }

        /**
         * @param instanceId The ID of the instance.
         * 
         * @return builder
         * 
         */
        public Builder instanceId(String instanceId) {
            return instanceId(Output.of(instanceId));
        }

        /**
         * @param internal Specifies whether an exchange is an internal exchange. Valid values:
         * * false: The exchange is not an internal exchange.
         * * true: The exchange is an internal exchange.
         * 
         * @return builder
         * 
         */
        public Builder internal(Output<Boolean> internal) {
            $.internal = internal;
            return this;
        }

        /**
         * @param internal Specifies whether an exchange is an internal exchange. Valid values:
         * * false: The exchange is not an internal exchange.
         * * true: The exchange is an internal exchange.
         * 
         * @return builder
         * 
         */
        public Builder internal(Boolean internal) {
            return internal(Output.of(internal));
        }

        /**
         * @param virtualHostName The name of virtual host where an exchange resides.
         * 
         * @return builder
         * 
         */
        public Builder virtualHostName(Output<String> virtualHostName) {
            $.virtualHostName = virtualHostName;
            return this;
        }

        /**
         * @param virtualHostName The name of virtual host where an exchange resides.
         * 
         * @return builder
         * 
         */
        public Builder virtualHostName(String virtualHostName) {
            return virtualHostName(Output.of(virtualHostName));
        }

        public ExchangeArgs build() {
            if ($.autoDeleteState == null) {
                throw new MissingRequiredPropertyException("ExchangeArgs", "autoDeleteState");
            }
            if ($.exchangeName == null) {
                throw new MissingRequiredPropertyException("ExchangeArgs", "exchangeName");
            }
            if ($.exchangeType == null) {
                throw new MissingRequiredPropertyException("ExchangeArgs", "exchangeType");
            }
            if ($.instanceId == null) {
                throw new MissingRequiredPropertyException("ExchangeArgs", "instanceId");
            }
            if ($.internal == null) {
                throw new MissingRequiredPropertyException("ExchangeArgs", "internal");
            }
            if ($.virtualHostName == null) {
                throw new MissingRequiredPropertyException("ExchangeArgs", "virtualHostName");
            }
            return $;
        }
    }

}
