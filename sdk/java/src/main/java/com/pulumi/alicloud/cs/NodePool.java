// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.cs;

import com.pulumi.alicloud.Utilities;
import com.pulumi.alicloud.cs.NodePoolArgs;
import com.pulumi.alicloud.cs.inputs.NodePoolState;
import com.pulumi.alicloud.cs.outputs.NodePoolDataDisk;
import com.pulumi.alicloud.cs.outputs.NodePoolKubeletConfiguration;
import com.pulumi.alicloud.cs.outputs.NodePoolLabel;
import com.pulumi.alicloud.cs.outputs.NodePoolManagement;
import com.pulumi.alicloud.cs.outputs.NodePoolPrivatePoolOptions;
import com.pulumi.alicloud.cs.outputs.NodePoolRollingPolicy;
import com.pulumi.alicloud.cs.outputs.NodePoolScalingConfig;
import com.pulumi.alicloud.cs.outputs.NodePoolSpotPriceLimit;
import com.pulumi.alicloud.cs.outputs.NodePoolTaint;
import com.pulumi.alicloud.cs.outputs.NodePoolTeeConfig;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * Basic Usage
 * 
 * ## Import
 * 
 * ACK Nodepool can be imported using the id, e.g.
 * 
 * ```sh
 * $ pulumi import alicloud:cs/nodePool:NodePool example &lt;cluster_id&gt;:&lt;node_pool_id&gt;
 * ```
 * 
 */
@ResourceType(type="alicloud:cs/nodePool:NodePool")
public class NodePool extends com.pulumi.resources.CustomResource {
    /**
     * Whether to enable automatic renewal for nodes in the node pool takes effect only when `instance_charge_type` is set to `PrePaid`. Default value: `true`. Valid values:
     * 
     */
    @Export(name="autoRenew", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> autoRenew;

    /**
     * @return Whether to enable automatic renewal for nodes in the node pool takes effect only when `instance_charge_type` is set to `PrePaid`. Default value: `true`. Valid values:
     * 
     */
    public Output<Optional<Boolean>> autoRenew() {
        return Codegen.optional(this.autoRenew);
    }
    /**
     * The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When `PeriodUnit = Month`, the value range is {1, 2, 3, 6, 12}. Default value: 1.
     * 
     */
    @Export(name="autoRenewPeriod", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> autoRenewPeriod;

    /**
     * @return The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When `PeriodUnit = Month`, the value range is {1, 2, 3, 6, 12}. Default value: 1.
     * 
     */
    public Output<Optional<Integer>> autoRenewPeriod() {
        return Codegen.optional(this.autoRenewPeriod);
    }
    /**
     * Whether enable worker node to support cis security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. Use `security_hardening_os` instead.
     * 
     * @deprecated
     * Field &#39;cis_enabled&#39; has been deprecated from provider version 1.223.1. Whether enable worker node to support cis security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. Use `security_hardening_os` instead.
     * 
     */
    @Deprecated /* Field 'cis_enabled' has been deprecated from provider version 1.223.1. Whether enable worker node to support cis security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. Use `security_hardening_os` instead. */
    @Export(name="cisEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> cisEnabled;

    /**
     * @return Whether enable worker node to support cis security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. Use `security_hardening_os` instead.
     * 
     */
    public Output<Optional<Boolean>> cisEnabled() {
        return Codegen.optional(this.cisEnabled);
    }
    /**
     * The id of kubernetes cluster.
     * 
     */
    @Export(name="clusterId", refs={String.class}, tree="[0]")
    private Output<String> clusterId;

    /**
     * @return The id of kubernetes cluster.
     * 
     */
    public Output<String> clusterId() {
        return this.clusterId;
    }
    /**
     * Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set `multi_az_policy` to `COST_OPTIMIZED`. Valid values: `true`: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. `false`: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
     * 
     */
    @Export(name="compensateWithOnDemand", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> compensateWithOnDemand;

    /**
     * @return Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set `multi_az_policy` to `COST_OPTIMIZED`. Valid values: `true`: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. `false`: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
     * 
     */
    public Output<Optional<Boolean>> compensateWithOnDemand() {
        return Codegen.optional(this.compensateWithOnDemand);
    }
    /**
     * Node CPU management policies. Default value: `none`. When the cluster version is 1.12.6 or later, the following two policies are supported:
     * 
     */
    @Export(name="cpuPolicy", refs={String.class}, tree="[0]")
    private Output<String> cpuPolicy;

    /**
     * @return Node CPU management policies. Default value: `none`. When the cluster version is 1.12.6 or later, the following two policies are supported:
     * 
     */
    public Output<String> cpuPolicy() {
        return this.cpuPolicy;
    }
    /**
     * Configure the data disk of the node in the node pool. See `data_disks` below.
     * 
     */
    @Export(name="dataDisks", refs={List.class,NodePoolDataDisk.class}, tree="[0,1]")
    private Output</* @Nullable */ List<NodePoolDataDisk>> dataDisks;

    /**
     * @return Configure the data disk of the node in the node pool. See `data_disks` below.
     * 
     */
    public Output<Optional<List<NodePoolDataDisk>>> dataDisks() {
        return Codegen.optional(this.dataDisks);
    }
    /**
     * The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
     * 
     */
    @Export(name="deploymentSetId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> deploymentSetId;

    /**
     * @return The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
     * 
     */
    public Output<Optional<String>> deploymentSetId() {
        return Codegen.optional(this.deploymentSetId);
    }
    /**
     * Number of expected nodes in the node pool.
     * 
     */
    @Export(name="desiredSize", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> desiredSize;

    /**
     * @return Number of expected nodes in the node pool.
     * 
     */
    public Output<Optional<Integer>> desiredSize() {
        return Codegen.optional(this.desiredSize);
    }
    /**
     * Whether to force deletion.
     * 
     */
    @Export(name="forceDelete", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceDelete;

    /**
     * @return Whether to force deletion.
     * 
     */
    public Output<Optional<Boolean>> forceDelete() {
        return Codegen.optional(this.forceDelete);
    }
    /**
     * After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is `false`.
     * 
     */
    @Export(name="formatDisk", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> formatDisk;

    /**
     * @return After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is `false`.
     * 
     */
    public Output<Boolean> formatDisk() {
        return this.formatDisk;
    }
    /**
     * The custom image ID. The system-provided image is used by default.
     * 
     */
    @Export(name="imageId", refs={String.class}, tree="[0]")
    private Output<String> imageId;

    /**
     * @return The custom image ID. The system-provided image is used by default.
     * 
     */
    public Output<String> imageId() {
        return this.imageId;
    }
    /**
     * The operating system image type and the `platform` parameter can be selected from the following values:
     * 
     */
    @Export(name="imageType", refs={String.class}, tree="[0]")
    private Output<String> imageType;

    /**
     * @return The operating system image type and the `platform` parameter can be selected from the following values:
     * 
     */
    public Output<String> imageType() {
        return this.imageType;
    }
    /**
     * Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: `false`. Valid values:
     * 
     */
    @Export(name="installCloudMonitor", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> installCloudMonitor;

    /**
     * @return Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: `false`. Valid values:
     * 
     */
    public Output<Optional<Boolean>> installCloudMonitor() {
        return Codegen.optional(this.installCloudMonitor);
    }
    /**
     * Node payment type. Valid values: `PostPaid`, `PrePaid`, default is `PostPaid`. If value is `PrePaid`, the arguments `period`, `period_unit`, `auto_renew` and `auto_renew_period` are required.
     * 
     */
    @Export(name="instanceChargeType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> instanceChargeType;

    /**
     * @return Node payment type. Valid values: `PostPaid`, `PrePaid`, default is `PostPaid`. If value is `PrePaid`, the arguments `period`, `period_unit`, `auto_renew` and `auto_renew_period` are required.
     * 
     */
    public Output<Optional<String>> instanceChargeType() {
        return Codegen.optional(this.instanceChargeType);
    }
    /**
     * In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
     * 
     */
    @Export(name="instanceTypes", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> instanceTypes;

    /**
     * @return In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
     * 
     */
    public Output<List<String>> instanceTypes() {
        return this.instanceTypes;
    }
    /**
     * The instance list. Add existing nodes under the same cluster VPC to the node pool.
     * 
     */
    @Export(name="instances", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> instances;

    /**
     * @return The instance list. Add existing nodes under the same cluster VPC to the node pool.
     * 
     */
    public Output<Optional<List<String>>> instances() {
        return Codegen.optional(this.instances);
    }
    /**
     * The billing method for network usage. Valid values `PayByBandwidth` and `PayByTraffic`. Conflict with `eip_internet_charge_type`, EIP and public network IP can only choose one. .
     * 
     */
    @Export(name="internetChargeType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> internetChargeType;

    /**
     * @return The billing method for network usage. Valid values `PayByBandwidth` and `PayByTraffic`. Conflict with `eip_internet_charge_type`, EIP and public network IP can only choose one. .
     * 
     */
    public Output<Optional<String>> internetChargeType() {
        return Codegen.optional(this.internetChargeType);
    }
    /**
     * The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:\[1,100\].
     * 
     */
    @Export(name="internetMaxBandwidthOut", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> internetMaxBandwidthOut;

    /**
     * @return The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:\[1,100\].
     * 
     */
    public Output<Optional<Integer>> internetMaxBandwidthOut() {
        return Codegen.optional(this.internetMaxBandwidthOut);
    }
    /**
     * Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to `true`.
     * 
     */
    @Export(name="keepInstanceName", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> keepInstanceName;

    /**
     * @return Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to `true`.
     * 
     */
    public Output<Boolean> keepInstanceName() {
        return this.keepInstanceName;
    }
    /**
     * The name of the key pair. When the node pool is a managed node pool, only `key_name` is supported.
     * 
     */
    @Export(name="keyName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> keyName;

    /**
     * @return The name of the key pair. When the node pool is a managed node pool, only `key_name` is supported.
     * 
     */
    public Output<Optional<String>> keyName() {
        return Codegen.optional(this.keyName);
    }
    /**
     * An KMS encrypts password used to a cs kubernetes. You have to specify one of `password` `key_name` `kms_encrypted_password` fields.
     * 
     */
    @Export(name="kmsEncryptedPassword", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> kmsEncryptedPassword;

    /**
     * @return An KMS encrypts password used to a cs kubernetes. You have to specify one of `password` `key_name` `kms_encrypted_password` fields.
     * 
     */
    public Output<Optional<String>> kmsEncryptedPassword() {
        return Codegen.optional(this.kmsEncryptedPassword);
    }
    /**
     * An KMS encryption context used to decrypt `kms_encrypted_password` before creating or updating a cs kubernetes with `kms_encrypted_password`. See [Encryption Context](https://www.alibabacloud.com/help/doc-detail/42975.htm). It is valid when `kms_encrypted_password` is set.
     * 
     */
    @Export(name="kmsEncryptionContext", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,Object>> kmsEncryptionContext;

    /**
     * @return An KMS encryption context used to decrypt `kms_encrypted_password` before creating or updating a cs kubernetes with `kms_encrypted_password`. See [Encryption Context](https://www.alibabacloud.com/help/doc-detail/42975.htm). It is valid when `kms_encrypted_password` is set.
     * 
     */
    public Output<Optional<Map<String,Object>>> kmsEncryptionContext() {
        return Codegen.optional(this.kmsEncryptionContext);
    }
    /**
     * Kubelet configuration parameters for worker nodes. See `kubelet_configuration` below. More information in [Kubelet Configuration](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/). See `kubelet_configuration` below.
     * 
     */
    @Export(name="kubeletConfiguration", refs={NodePoolKubeletConfiguration.class}, tree="[0]")
    private Output</* @Nullable */ NodePoolKubeletConfiguration> kubeletConfiguration;

    /**
     * @return Kubelet configuration parameters for worker nodes. See `kubelet_configuration` below. More information in [Kubelet Configuration](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/). See `kubelet_configuration` below.
     * 
     */
    public Output<Optional<NodePoolKubeletConfiguration>> kubeletConfiguration() {
        return Codegen.optional(this.kubeletConfiguration);
    }
    /**
     * A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in [Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/). See `labels` below.
     * 
     */
    @Export(name="labels", refs={List.class,NodePoolLabel.class}, tree="[0,1]")
    private Output</* @Nullable */ List<NodePoolLabel>> labels;

    /**
     * @return A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in [Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/). See `labels` below.
     * 
     */
    public Output<Optional<List<NodePoolLabel>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * Whether the ECS instance is logged on as a ecs-user user. Valid value: `true` and `false`.
     * 
     */
    @Export(name="loginAsNonRoot", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> loginAsNonRoot;

    /**
     * @return Whether the ECS instance is logged on as a ecs-user user. Valid value: `true` and `false`.
     * 
     */
    public Output<Optional<Boolean>> loginAsNonRoot() {
        return Codegen.optional(this.loginAsNonRoot);
    }
    /**
     * Managed node pool configuration. See `management` below.
     * 
     */
    @Export(name="management", refs={NodePoolManagement.class}, tree="[0]")
    private Output<NodePoolManagement> management;

    /**
     * @return Managed node pool configuration. See `management` below.
     * 
     */
    public Output<NodePoolManagement> management() {
        return this.management;
    }
    /**
     * The scaling policy for ECS instances in a multi-zone scaling group. Valid value: `PRIORITY`, `COST_OPTIMIZED` and `BALANCE`. `PRIORITY`: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. `COST_OPTIMIZED`: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the `CompensateWithOnDemand` parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. `BALANCE`: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API RebalanceInstances to balance resources.
     * 
     */
    @Export(name="multiAzPolicy", refs={String.class}, tree="[0]")
    private Output<String> multiAzPolicy;

    /**
     * @return The scaling policy for ECS instances in a multi-zone scaling group. Valid value: `PRIORITY`, `COST_OPTIMIZED` and `BALANCE`. `PRIORITY`: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. `COST_OPTIMIZED`: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the `CompensateWithOnDemand` parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. `BALANCE`: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API RebalanceInstances to balance resources.
     * 
     */
    public Output<String> multiAzPolicy() {
        return this.multiAzPolicy;
    }
    /**
     * . Field &#39;name&#39; has been deprecated from provider version 1.219.0. New field &#39;node_pool_name&#39; instead.
     * 
     * @deprecated
     * Field &#39;name&#39; has been deprecated since provider version 1.219.0. New field &#39;node_pool_name&#39; instead.
     * 
     */
    @Deprecated /* Field 'name' has been deprecated since provider version 1.219.0. New field 'node_pool_name' instead. */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return . Field &#39;name&#39; has been deprecated from provider version 1.219.0. New field &#39;node_pool_name&#39; instead.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The worker node number of the node pool. From version 1.111.0, `node_count` is not required.
     * 
     * @deprecated
     * Field &#39;node_count&#39; has been deprecated from provider version 1.158.0. New field &#39;desired_size&#39; instead.
     * 
     */
    @Deprecated /* Field 'node_count' has been deprecated from provider version 1.158.0. New field 'desired_size' instead. */
    @Export(name="nodeCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> nodeCount;

    /**
     * @return The worker node number of the node pool. From version 1.111.0, `node_count` is not required.
     * 
     */
    public Output<Integer> nodeCount() {
        return this.nodeCount;
    }
    /**
     * Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is `customized,,ip,`.
     * - The prefix and suffix can be composed of one or more parts separated by &#39;.&#39;, each part can use lowercase letters, numbers and &#39;-&#39;, and the beginning and end of the node name must be lowercase letters and numbers.
     * - The node IP address is the complete private IP address of the node.
     * - For example, if the string `customized,aliyun,ip,com` is passed in (where &#39;customized&#39; and &#39;ip&#39; are fixed strings, &#39;aliyun&#39; is the prefix, and &#39;com&#39; is the suffix), the name of the node is `aliyun.192.168.xxx.xxx.com`.
     * 
     */
    @Export(name="nodeNameMode", refs={String.class}, tree="[0]")
    private Output<String> nodeNameMode;

    /**
     * @return Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is `customized,,ip,`.
     * - The prefix and suffix can be composed of one or more parts separated by &#39;.&#39;, each part can use lowercase letters, numbers and &#39;-&#39;, and the beginning and end of the node name must be lowercase letters and numbers.
     * - The node IP address is the complete private IP address of the node.
     * - For example, if the string `customized,aliyun,ip,com` is passed in (where &#39;customized&#39; and &#39;ip&#39; are fixed strings, &#39;aliyun&#39; is the prefix, and &#39;com&#39; is the suffix), the name of the node is `aliyun.192.168.xxx.xxx.com`.
     * 
     */
    public Output<String> nodeNameMode() {
        return this.nodeNameMode;
    }
    /**
     * The first ID of the resource.
     * 
     */
    @Export(name="nodePoolId", refs={String.class}, tree="[0]")
    private Output<String> nodePoolId;

    /**
     * @return The first ID of the resource.
     * 
     */
    public Output<String> nodePoolId() {
        return this.nodePoolId;
    }
    /**
     * The name of node pool.
     * 
     */
    @Export(name="nodePoolName", refs={String.class}, tree="[0]")
    private Output<String> nodePoolName;

    /**
     * @return The name of node pool.
     * 
     */
    public Output<String> nodePoolName() {
        return this.nodePoolName;
    }
    /**
     * The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
     * 
     */
    @Export(name="onDemandBaseCapacity", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> onDemandBaseCapacity;

    /**
     * @return The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
     * 
     */
    public Output<Optional<Integer>> onDemandBaseCapacity() {
        return Codegen.optional(this.onDemandBaseCapacity);
    }
    /**
     * The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.
     * 
     */
    @Export(name="onDemandPercentageAboveBaseCapacity", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> onDemandPercentageAboveBaseCapacity;

    /**
     * @return The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.
     * 
     */
    public Output<Optional<Integer>> onDemandPercentageAboveBaseCapacity() {
        return Codegen.optional(this.onDemandPercentageAboveBaseCapacity);
    }
    /**
     * The password of ssh login. You have to specify one of `password` and `key_name` fields. The password rule is 8 to 30 characters and contains at least three items (upper and lower case letters, numbers, and special symbols).
     * 
     */
    @Export(name="password", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> password;

    /**
     * @return The password of ssh login. You have to specify one of `password` and `key_name` fields. The password rule is 8 to 30 characters and contains at least three items (upper and lower case letters, numbers, and special symbols).
     * 
     */
    public Output<Optional<String>> password() {
        return Codegen.optional(this.password);
    }
    /**
     * Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
     * 
     */
    @Export(name="period", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> period;

    /**
     * @return Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
     * 
     */
    public Output<Optional<Integer>> period() {
        return Codegen.optional(this.period);
    }
    /**
     * Node payment period unit, valid value: `Month`. Default is `Month`.
     * 
     */
    @Export(name="periodUnit", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> periodUnit;

    /**
     * @return Node payment period unit, valid value: `Month`. Default is `Month`.
     * 
     */
    public Output<Optional<String>> periodUnit() {
        return Codegen.optional(this.periodUnit);
    }
    /**
     * Operating system release, using `image_type` instead.
     * 
     * @deprecated
     * Field &#39;platform&#39; has been deprecated from provider version 1.145.0. Operating system release, using `image_type` instead.
     * 
     */
    @Deprecated /* Field 'platform' has been deprecated from provider version 1.145.0. Operating system release, using `image_type` instead. */
    @Export(name="platform", refs={String.class}, tree="[0]")
    private Output<String> platform;

    /**
     * @return Operating system release, using `image_type` instead.
     * 
     */
    public Output<String> platform() {
        return this.platform;
    }
    /**
     * Private node pool configuration. See `private_pool_options` below.
     * 
     */
    @Export(name="privatePoolOptions", refs={NodePoolPrivatePoolOptions.class}, tree="[0]")
    private Output</* @Nullable */ NodePoolPrivatePoolOptions> privatePoolOptions;

    /**
     * @return Private node pool configuration. See `private_pool_options` below.
     * 
     */
    public Output<Optional<NodePoolPrivatePoolOptions>> privatePoolOptions() {
        return Codegen.optional(this.privatePoolOptions);
    }
    /**
     * The list of RDS instances.
     * 
     */
    @Export(name="rdsInstances", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> rdsInstances;

    /**
     * @return The list of RDS instances.
     * 
     */
    public Output<Optional<List<String>>> rdsInstances() {
        return Codegen.optional(this.rdsInstances);
    }
    /**
     * The ID of the resource group.
     * 
     */
    @Export(name="resourceGroupId", refs={String.class}, tree="[0]")
    private Output<String> resourceGroupId;

    /**
     * @return The ID of the resource group.
     * 
     */
    public Output<String> resourceGroupId() {
        return this.resourceGroupId;
    }
    /**
     * Rotary configuration. See `rolling_policy` below.
     * 
     */
    @Export(name="rollingPolicy", refs={NodePoolRollingPolicy.class}, tree="[0]")
    private Output</* @Nullable */ NodePoolRollingPolicy> rollingPolicy;

    /**
     * @return Rotary configuration. See `rolling_policy` below.
     * 
     */
    public Output<Optional<NodePoolRollingPolicy>> rollingPolicy() {
        return Codegen.optional(this.rollingPolicy);
    }
    /**
     * The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see [Comparison of Docker, containerd, and Sandboxed-Container](https://www.alibabacloud.com/help/doc-detail/160313.htm).
     * 
     */
    @Export(name="runtimeName", refs={String.class}, tree="[0]")
    private Output<String> runtimeName;

    /**
     * @return The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see [Comparison of Docker, containerd, and Sandboxed-Container](https://www.alibabacloud.com/help/doc-detail/160313.htm).
     * 
     */
    public Output<String> runtimeName() {
        return this.runtimeName;
    }
    /**
     * The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
     * 
     */
    @Export(name="runtimeVersion", refs={String.class}, tree="[0]")
    private Output<String> runtimeVersion;

    /**
     * @return The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
     * 
     */
    public Output<String> runtimeVersion() {
        return this.runtimeVersion;
    }
    /**
     * Automatic scaling configuration. See `scaling_config` below.
     * 
     */
    @Export(name="scalingConfig", refs={NodePoolScalingConfig.class}, tree="[0]")
    private Output<NodePoolScalingConfig> scalingConfig;

    /**
     * @return Automatic scaling configuration. See `scaling_config` below.
     * 
     */
    public Output<NodePoolScalingConfig> scalingConfig() {
        return this.scalingConfig;
    }
    /**
     * The ID of the scaling group.
     * 
     */
    @Export(name="scalingGroupId", refs={String.class}, tree="[0]")
    private Output<String> scalingGroupId;

    /**
     * @return The ID of the scaling group.
     * 
     */
    public Output<String> scalingGroupId() {
        return this.scalingGroupId;
    }
    /**
     * Scaling group mode, default value: `release`. Valid values:
     * 
     */
    @Export(name="scalingPolicy", refs={String.class}, tree="[0]")
    private Output<String> scalingPolicy;

    /**
     * @return Scaling group mode, default value: `release`. Valid values:
     * 
     */
    public Output<String> scalingPolicy() {
        return this.scalingPolicy;
    }
    /**
     * The security group ID of the node pool. This field has been replaced by `security_group_ids`, please use the `security_group_ids` field instead.
     * 
     * @deprecated
     * Field &#39;security_group_id&#39; has been deprecated from provider version 1.145.0. The security group ID of the node pool. This field has been replaced by `security_group_ids`, please use the `security_group_ids` field instead.
     * 
     */
    @Deprecated /* Field 'security_group_id' has been deprecated from provider version 1.145.0. The security group ID of the node pool. This field has been replaced by `security_group_ids`, please use the `security_group_ids` field instead. */
    @Export(name="securityGroupId", refs={String.class}, tree="[0]")
    private Output<String> securityGroupId;

    /**
     * @return The security group ID of the node pool. This field has been replaced by `security_group_ids`, please use the `security_group_ids` field instead.
     * 
     */
    public Output<String> securityGroupId() {
        return this.securityGroupId;
    }
    /**
     * Multiple security groups can be configured for a node pool. If both `security_group_ids` and `security_group_id` are configured, `security_group_ids` takes effect. This field cannot be modified.
     * 
     */
    @Export(name="securityGroupIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> securityGroupIds;

    /**
     * @return Multiple security groups can be configured for a node pool. If both `security_group_ids` and `security_group_id` are configured, `security_group_ids` takes effect. This field cannot be modified.
     * 
     */
    public Output<List<String>> securityGroupIds() {
        return this.securityGroupIds;
    }
    /**
     * Alibaba Cloud OS security reinforcement. Default value: `false`. Value:
     * 
     */
    @Export(name="securityHardeningOs", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> securityHardeningOs;

    /**
     * @return Alibaba Cloud OS security reinforcement. Default value: `false`. Value:
     * 
     */
    public Output<Optional<Boolean>> securityHardeningOs() {
        return Codegen.optional(this.securityHardeningOs);
    }
    /**
     * Whether enable worker node to support soc security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. See [SOC Reinforcement](https://help.aliyun.com/document_detail/196148.html).
     * &gt; **NOTE:**  It is forbidden to set both `security_hardening_os` and `soc_enabled` to `true` at the same time.
     * 
     */
    @Export(name="socEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> socEnabled;

    /**
     * @return Whether enable worker node to support soc security reinforcement, its valid value `true` or `false`. Default to `false` and apply to AliyunLinux series. See [SOC Reinforcement](https://help.aliyun.com/document_detail/196148.html).
     * &gt; **NOTE:**  It is forbidden to set both `security_hardening_os` and `soc_enabled` to `true` at the same time.
     * 
     */
    public Output<Optional<Boolean>> socEnabled() {
        return Codegen.optional(this.socEnabled);
    }
    /**
     * The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
     * 
     */
    @Export(name="spotInstancePools", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> spotInstancePools;

    /**
     * @return The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
     * 
     */
    public Output<Optional<Integer>> spotInstancePools() {
        return Codegen.optional(this.spotInstancePools);
    }
    /**
     * Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: `true`: enables the supplementation of preemptible instances. `false`: disables the supplementation of preemptible instances.
     * 
     */
    @Export(name="spotInstanceRemedy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> spotInstanceRemedy;

    /**
     * @return Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: `true`: enables the supplementation of preemptible instances. `false`: disables the supplementation of preemptible instances.
     * 
     */
    public Output<Optional<Boolean>> spotInstanceRemedy() {
        return Codegen.optional(this.spotInstanceRemedy);
    }
    /**
     * The current single preemptible instance type market price range configuration. See `spot_price_limit` below.
     * 
     */
    @Export(name="spotPriceLimits", refs={List.class,NodePoolSpotPriceLimit.class}, tree="[0,1]")
    private Output</* @Nullable */ List<NodePoolSpotPriceLimit>> spotPriceLimits;

    /**
     * @return The current single preemptible instance type market price range configuration. See `spot_price_limit` below.
     * 
     */
    public Output<Optional<List<NodePoolSpotPriceLimit>>> spotPriceLimits() {
        return Codegen.optional(this.spotPriceLimits);
    }
    /**
     * The preemptible instance type. Value:
     * 
     */
    @Export(name="spotStrategy", refs={String.class}, tree="[0]")
    private Output<String> spotStrategy;

    /**
     * @return The preemptible instance type. Value:
     * 
     */
    public Output<String> spotStrategy() {
        return this.spotStrategy;
    }
    /**
     * Specifies whether to enable the burst feature for system disks. Valid values:`true`: enables the burst feature. `false`: disables the burst feature. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    @Export(name="systemDiskBurstingEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> systemDiskBurstingEnabled;

    /**
     * @return Specifies whether to enable the burst feature for system disks. Valid values:`true`: enables the burst feature. `false`: disables the burst feature. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    public Output<Optional<Boolean>> systemDiskBurstingEnabled() {
        return Codegen.optional(this.systemDiskBurstingEnabled);
    }
    /**
     * The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values: `cloud`: cloud disk. `cloud_efficiency`: a high-efficiency cloud disk. `cloud_ssd`:SSD cloud disk. `cloud_essd`: ESSD cloud disk.
     * 
     */
    @Export(name="systemDiskCategories", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> systemDiskCategories;

    /**
     * @return The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values: `cloud`: cloud disk. `cloud_efficiency`: a high-efficiency cloud disk. `cloud_ssd`:SSD cloud disk. `cloud_essd`: ESSD cloud disk.
     * 
     */
    public Output<List<String>> systemDiskCategories() {
        return this.systemDiskCategories;
    }
    /**
     * The system disk category of worker node. Its valid value are `cloud_ssd`, `cloud_efficiency`, `cloud_essd` and `cloud_auto`. .
     * 
     */
    @Export(name="systemDiskCategory", refs={String.class}, tree="[0]")
    private Output<String> systemDiskCategory;

    /**
     * @return The system disk category of worker node. Its valid value are `cloud_ssd`, `cloud_efficiency`, `cloud_essd` and `cloud_auto`. .
     * 
     */
    public Output<String> systemDiskCategory() {
        return this.systemDiskCategory;
    }
    /**
     * The encryption algorithm used by the system disk. Value range: aes-256.
     * 
     */
    @Export(name="systemDiskEncryptAlgorithm", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> systemDiskEncryptAlgorithm;

    /**
     * @return The encryption algorithm used by the system disk. Value range: aes-256.
     * 
     */
    public Output<Optional<String>> systemDiskEncryptAlgorithm() {
        return Codegen.optional(this.systemDiskEncryptAlgorithm);
    }
    /**
     * Whether to encrypt the system disk. Value range: `true`: encryption. `false`: Do not encrypt.
     * 
     */
    @Export(name="systemDiskEncrypted", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> systemDiskEncrypted;

    /**
     * @return Whether to encrypt the system disk. Value range: `true`: encryption. `false`: Do not encrypt.
     * 
     */
    public Output<Optional<Boolean>> systemDiskEncrypted() {
        return Codegen.optional(this.systemDiskEncrypted);
    }
    /**
     * The ID of the KMS key used by the system disk.
     * 
     */
    @Export(name="systemDiskKmsKey", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> systemDiskKmsKey;

    /**
     * @return The ID of the KMS key used by the system disk.
     * 
     */
    public Output<Optional<String>> systemDiskKmsKey() {
        return Codegen.optional(this.systemDiskKmsKey);
    }
    /**
     * The system disk performance of the node takes effect only for the ESSD disk.
     * 
     */
    @Export(name="systemDiskPerformanceLevel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> systemDiskPerformanceLevel;

    /**
     * @return The system disk performance of the node takes effect only for the ESSD disk.
     * 
     */
    public Output<Optional<String>> systemDiskPerformanceLevel() {
        return Codegen.optional(this.systemDiskPerformanceLevel);
    }
    /**
     * The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    @Export(name="systemDiskProvisionedIops", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> systemDiskProvisionedIops;

    /**
     * @return The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}. This parameter is supported only when `system_disk_category` is set to `cloud_auto`.
     * 
     */
    public Output<Optional<Integer>> systemDiskProvisionedIops() {
        return Codegen.optional(this.systemDiskProvisionedIops);
    }
    /**
     * The system disk category of worker node. Its valid value range [40~500] in GB. Default to `120`.
     * 
     */
    @Export(name="systemDiskSize", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> systemDiskSize;

    /**
     * @return The system disk category of worker node. Its valid value range [40~500] in GB. Default to `120`.
     * 
     */
    public Output<Optional<Integer>> systemDiskSize() {
        return Codegen.optional(this.systemDiskSize);
    }
    /**
     * The ID of the automatic snapshot policy used by the system disk.
     * 
     */
    @Export(name="systemDiskSnapshotPolicyId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> systemDiskSnapshotPolicyId;

    /**
     * @return The ID of the automatic snapshot policy used by the system disk.
     * 
     */
    public Output<Optional<String>> systemDiskSnapshotPolicyId() {
        return Codegen.optional(this.systemDiskSnapshotPolicyId);
    }
    /**
     * Add tags only for ECS instances.  The maximum length of the tag key is 128 characters. The tag key and value cannot start with aliyun or acs:, or contain https:// or http://&#34;.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,Object>> tags;

    /**
     * @return Add tags only for ECS instances.  The maximum length of the tag key is 128 characters. The tag key and value cannot start with aliyun or acs:, or contain https:// or http://&#34;.
     * 
     */
    public Output<Optional<Map<String,Object>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * A List of Kubernetes taints to assign to the nodes. Detailed below. More information in [Taints and Toleration](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/). See `taints` below.
     * 
     */
    @Export(name="taints", refs={List.class,NodePoolTaint.class}, tree="[0,1]")
    private Output</* @Nullable */ List<NodePoolTaint>> taints;

    /**
     * @return A List of Kubernetes taints to assign to the nodes. Detailed below. More information in [Taints and Toleration](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/). See `taints` below.
     * 
     */
    public Output<Optional<List<NodePoolTaint>>> taints() {
        return Codegen.optional(this.taints);
    }
    /**
     * The configuration about confidential computing for the cluster. See `tee_config` below.
     * 
     */
    @Export(name="teeConfig", refs={NodePoolTeeConfig.class}, tree="[0]")
    private Output<NodePoolTeeConfig> teeConfig;

    /**
     * @return The configuration about confidential computing for the cluster. See `tee_config` below.
     * 
     */
    public Output<NodePoolTeeConfig> teeConfig() {
        return this.teeConfig;
    }
    /**
     * Whether the node after expansion can be scheduled.
     * 
     */
    @Export(name="unschedulable", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> unschedulable;

    /**
     * @return Whether the node after expansion can be scheduled.
     * 
     */
    public Output<Optional<Boolean>> unschedulable() {
        return Codegen.optional(this.unschedulable);
    }
    /**
     * Synchronously update node labels and taints.
     * 
     */
    @Export(name="updateNodes", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> updateNodes;

    /**
     * @return Synchronously update node labels and taints.
     * 
     */
    public Output<Optional<Boolean>> updateNodes() {
        return Codegen.optional(this.updateNodes);
    }
    /**
     * Node custom data.
     * 
     */
    @Export(name="userData", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> userData;

    /**
     * @return Node custom data.
     * 
     */
    public Output<Optional<String>> userData() {
        return Codegen.optional(this.userData);
    }
    /**
     * The vswitches used by node pool workers.
     * 
     */
    @Export(name="vswitchIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> vswitchIds;

    /**
     * @return The vswitches used by node pool workers.
     * 
     */
    public Output<List<String>> vswitchIds() {
        return this.vswitchIds;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public NodePool(String name) {
        this(name, NodePoolArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public NodePool(String name, NodePoolArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public NodePool(String name, NodePoolArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("alicloud:cs/nodePool:NodePool", name, args == null ? NodePoolArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private NodePool(String name, Output<String> id, @Nullable NodePoolState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("alicloud:cs/nodePool:NodePool", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "kmsEncryptedPassword",
                "password"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static NodePool get(String name, Output<String> id, @Nullable NodePoolState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new NodePool(name, id, state, options);
    }
}
