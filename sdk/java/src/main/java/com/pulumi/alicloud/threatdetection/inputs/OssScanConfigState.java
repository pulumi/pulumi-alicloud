// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.threatdetection.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OssScanConfigState extends com.pulumi.resources.ResourceArgs {

    public static final OssScanConfigState Empty = new OssScanConfigState();

    /**
     * Indicates whether the prefixes of all objects are matched.
     * 
     */
    @Import(name="allKeyPrefix")
    private @Nullable Output<Boolean> allKeyPrefix;

    /**
     * @return Indicates whether the prefixes of all objects are matched.
     * 
     */
    public Optional<Output<Boolean>> allKeyPrefix() {
        return Optional.ofNullable(this.allKeyPrefix);
    }

    /**
     * The names of the buckets.
     * 
     */
    @Import(name="bucketNameLists")
    private @Nullable Output<List<String>> bucketNameLists;

    /**
     * @return The names of the buckets.
     * 
     */
    public Optional<Output<List<String>>> bucketNameLists() {
        return Optional.ofNullable(this.bucketNameLists);
    }

    /**
     * The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
     * 
     */
    @Import(name="decompressMaxFileCount")
    private @Nullable Output<Integer> decompressMaxFileCount;

    /**
     * @return The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
     * 
     */
    public Optional<Output<Integer>> decompressMaxFileCount() {
        return Optional.ofNullable(this.decompressMaxFileCount);
    }

    /**
     * The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
     * 
     */
    @Import(name="decompressMaxLayer")
    private @Nullable Output<Integer> decompressMaxLayer;

    /**
     * @return The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
     * 
     */
    public Optional<Output<Integer>> decompressMaxLayer() {
        return Optional.ofNullable(this.decompressMaxLayer);
    }

    /**
     * The decryption methods.
     * 
     */
    @Import(name="decryptionLists")
    private @Nullable Output<List<String>> decryptionLists;

    /**
     * @return The decryption methods.
     * 
     */
    public Optional<Output<List<String>>> decryptionLists() {
        return Optional.ofNullable(this.decryptionLists);
    }

    /**
     * Indicates whether the check policy is enabled. Valid values:
     * 
     */
    @Import(name="enable")
    private @Nullable Output<Integer> enable;

    /**
     * @return Indicates whether the check policy is enabled. Valid values:
     * 
     */
    public Optional<Output<Integer>> enable() {
        return Optional.ofNullable(this.enable);
    }

    /**
     * The end time of the check. The time is in the HH:mm:ss format.
     * 
     */
    @Import(name="endTime")
    private @Nullable Output<String> endTime;

    /**
     * @return The end time of the check. The time is in the HH:mm:ss format.
     * 
     */
    public Optional<Output<String>> endTime() {
        return Optional.ofNullable(this.endTime);
    }

    /**
     * The prefixes of the objects.
     * 
     */
    @Import(name="keyPrefixLists")
    private @Nullable Output<List<String>> keyPrefixLists;

    /**
     * @return The prefixes of the objects.
     * 
     */
    public Optional<Output<List<String>>> keyPrefixLists() {
        return Optional.ofNullable(this.keyPrefixLists);
    }

    /**
     * The suffixes of the objects that are checked.
     * 
     */
    @Import(name="keySuffixLists")
    private @Nullable Output<List<String>> keySuffixLists;

    /**
     * @return The suffixes of the objects that are checked.
     * 
     */
    public Optional<Output<List<String>>> keySuffixLists() {
        return Optional.ofNullable(this.keySuffixLists);
    }

    /**
     * The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.
     * 
     */
    @Import(name="lastModifiedStartTime")
    private @Nullable Output<Integer> lastModifiedStartTime;

    /**
     * @return The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.
     * 
     */
    public Optional<Output<Integer>> lastModifiedStartTime() {
        return Optional.ofNullable(this.lastModifiedStartTime);
    }

    /**
     * The policy name.
     * 
     */
    @Import(name="ossScanConfigName")
    private @Nullable Output<String> ossScanConfigName;

    /**
     * @return The policy name.
     * 
     */
    public Optional<Output<String>> ossScanConfigName() {
        return Optional.ofNullable(this.ossScanConfigName);
    }

    /**
     * The days when the check is performed. The value indicates the days of the week.
     * 
     */
    @Import(name="scanDayLists")
    private @Nullable Output<List<Integer>> scanDayLists;

    /**
     * @return The days when the check is performed. The value indicates the days of the week.
     * 
     */
    public Optional<Output<List<Integer>>> scanDayLists() {
        return Optional.ofNullable(this.scanDayLists);
    }

    /**
     * The start time of the check. The time is in the HH:mm:ss format.
     * 
     */
    @Import(name="startTime")
    private @Nullable Output<String> startTime;

    /**
     * @return The start time of the check. The time is in the HH:mm:ss format.
     * 
     */
    public Optional<Output<String>> startTime() {
        return Optional.ofNullable(this.startTime);
    }

    private OssScanConfigState() {}

    private OssScanConfigState(OssScanConfigState $) {
        this.allKeyPrefix = $.allKeyPrefix;
        this.bucketNameLists = $.bucketNameLists;
        this.decompressMaxFileCount = $.decompressMaxFileCount;
        this.decompressMaxLayer = $.decompressMaxLayer;
        this.decryptionLists = $.decryptionLists;
        this.enable = $.enable;
        this.endTime = $.endTime;
        this.keyPrefixLists = $.keyPrefixLists;
        this.keySuffixLists = $.keySuffixLists;
        this.lastModifiedStartTime = $.lastModifiedStartTime;
        this.ossScanConfigName = $.ossScanConfigName;
        this.scanDayLists = $.scanDayLists;
        this.startTime = $.startTime;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OssScanConfigState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OssScanConfigState $;

        public Builder() {
            $ = new OssScanConfigState();
        }

        public Builder(OssScanConfigState defaults) {
            $ = new OssScanConfigState(Objects.requireNonNull(defaults));
        }

        /**
         * @param allKeyPrefix Indicates whether the prefixes of all objects are matched.
         * 
         * @return builder
         * 
         */
        public Builder allKeyPrefix(@Nullable Output<Boolean> allKeyPrefix) {
            $.allKeyPrefix = allKeyPrefix;
            return this;
        }

        /**
         * @param allKeyPrefix Indicates whether the prefixes of all objects are matched.
         * 
         * @return builder
         * 
         */
        public Builder allKeyPrefix(Boolean allKeyPrefix) {
            return allKeyPrefix(Output.of(allKeyPrefix));
        }

        /**
         * @param bucketNameLists The names of the buckets.
         * 
         * @return builder
         * 
         */
        public Builder bucketNameLists(@Nullable Output<List<String>> bucketNameLists) {
            $.bucketNameLists = bucketNameLists;
            return this;
        }

        /**
         * @param bucketNameLists The names of the buckets.
         * 
         * @return builder
         * 
         */
        public Builder bucketNameLists(List<String> bucketNameLists) {
            return bucketNameLists(Output.of(bucketNameLists));
        }

        /**
         * @param bucketNameLists The names of the buckets.
         * 
         * @return builder
         * 
         */
        public Builder bucketNameLists(String... bucketNameLists) {
            return bucketNameLists(List.of(bucketNameLists));
        }

        /**
         * @param decompressMaxFileCount The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
         * 
         * @return builder
         * 
         */
        public Builder decompressMaxFileCount(@Nullable Output<Integer> decompressMaxFileCount) {
            $.decompressMaxFileCount = decompressMaxFileCount;
            return this;
        }

        /**
         * @param decompressMaxFileCount The maximum number of objects that can be extracted during decompression. Valid values: 1 to 1000. If the maximum number of objects that can be extracted is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
         * 
         * @return builder
         * 
         */
        public Builder decompressMaxFileCount(Integer decompressMaxFileCount) {
            return decompressMaxFileCount(Output.of(decompressMaxFileCount));
        }

        /**
         * @param decompressMaxLayer The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
         * 
         * @return builder
         * 
         */
        public Builder decompressMaxLayer(@Nullable Output<Integer> decompressMaxLayer) {
            $.decompressMaxLayer = decompressMaxLayer;
            return this;
        }

        /**
         * @param decompressMaxLayer The maximum number of decompression levels when multi-level packages are decompressed. Valid values: 1 to 5. If the maximum number of decompression levels is reached, the decompression operation immediately ends and the detection of extracted objects is not affected.
         * 
         * @return builder
         * 
         */
        public Builder decompressMaxLayer(Integer decompressMaxLayer) {
            return decompressMaxLayer(Output.of(decompressMaxLayer));
        }

        /**
         * @param decryptionLists The decryption methods.
         * 
         * @return builder
         * 
         */
        public Builder decryptionLists(@Nullable Output<List<String>> decryptionLists) {
            $.decryptionLists = decryptionLists;
            return this;
        }

        /**
         * @param decryptionLists The decryption methods.
         * 
         * @return builder
         * 
         */
        public Builder decryptionLists(List<String> decryptionLists) {
            return decryptionLists(Output.of(decryptionLists));
        }

        /**
         * @param decryptionLists The decryption methods.
         * 
         * @return builder
         * 
         */
        public Builder decryptionLists(String... decryptionLists) {
            return decryptionLists(List.of(decryptionLists));
        }

        /**
         * @param enable Indicates whether the check policy is enabled. Valid values:
         * 
         * @return builder
         * 
         */
        public Builder enable(@Nullable Output<Integer> enable) {
            $.enable = enable;
            return this;
        }

        /**
         * @param enable Indicates whether the check policy is enabled. Valid values:
         * 
         * @return builder
         * 
         */
        public Builder enable(Integer enable) {
            return enable(Output.of(enable));
        }

        /**
         * @param endTime The end time of the check. The time is in the HH:mm:ss format.
         * 
         * @return builder
         * 
         */
        public Builder endTime(@Nullable Output<String> endTime) {
            $.endTime = endTime;
            return this;
        }

        /**
         * @param endTime The end time of the check. The time is in the HH:mm:ss format.
         * 
         * @return builder
         * 
         */
        public Builder endTime(String endTime) {
            return endTime(Output.of(endTime));
        }

        /**
         * @param keyPrefixLists The prefixes of the objects.
         * 
         * @return builder
         * 
         */
        public Builder keyPrefixLists(@Nullable Output<List<String>> keyPrefixLists) {
            $.keyPrefixLists = keyPrefixLists;
            return this;
        }

        /**
         * @param keyPrefixLists The prefixes of the objects.
         * 
         * @return builder
         * 
         */
        public Builder keyPrefixLists(List<String> keyPrefixLists) {
            return keyPrefixLists(Output.of(keyPrefixLists));
        }

        /**
         * @param keyPrefixLists The prefixes of the objects.
         * 
         * @return builder
         * 
         */
        public Builder keyPrefixLists(String... keyPrefixLists) {
            return keyPrefixLists(List.of(keyPrefixLists));
        }

        /**
         * @param keySuffixLists The suffixes of the objects that are checked.
         * 
         * @return builder
         * 
         */
        public Builder keySuffixLists(@Nullable Output<List<String>> keySuffixLists) {
            $.keySuffixLists = keySuffixLists;
            return this;
        }

        /**
         * @param keySuffixLists The suffixes of the objects that are checked.
         * 
         * @return builder
         * 
         */
        public Builder keySuffixLists(List<String> keySuffixLists) {
            return keySuffixLists(Output.of(keySuffixLists));
        }

        /**
         * @param keySuffixLists The suffixes of the objects that are checked.
         * 
         * @return builder
         * 
         */
        public Builder keySuffixLists(String... keySuffixLists) {
            return keySuffixLists(List.of(keySuffixLists));
        }

        /**
         * @param lastModifiedStartTime The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.
         * 
         * @return builder
         * 
         */
        public Builder lastModifiedStartTime(@Nullable Output<Integer> lastModifiedStartTime) {
            $.lastModifiedStartTime = lastModifiedStartTime;
            return this;
        }

        /**
         * @param lastModifiedStartTime The timestamp when the object was last modified. The time must be later than the timestamp that you specify. Unit: milliseconds.
         * 
         * @return builder
         * 
         */
        public Builder lastModifiedStartTime(Integer lastModifiedStartTime) {
            return lastModifiedStartTime(Output.of(lastModifiedStartTime));
        }

        /**
         * @param ossScanConfigName The policy name.
         * 
         * @return builder
         * 
         */
        public Builder ossScanConfigName(@Nullable Output<String> ossScanConfigName) {
            $.ossScanConfigName = ossScanConfigName;
            return this;
        }

        /**
         * @param ossScanConfigName The policy name.
         * 
         * @return builder
         * 
         */
        public Builder ossScanConfigName(String ossScanConfigName) {
            return ossScanConfigName(Output.of(ossScanConfigName));
        }

        /**
         * @param scanDayLists The days when the check is performed. The value indicates the days of the week.
         * 
         * @return builder
         * 
         */
        public Builder scanDayLists(@Nullable Output<List<Integer>> scanDayLists) {
            $.scanDayLists = scanDayLists;
            return this;
        }

        /**
         * @param scanDayLists The days when the check is performed. The value indicates the days of the week.
         * 
         * @return builder
         * 
         */
        public Builder scanDayLists(List<Integer> scanDayLists) {
            return scanDayLists(Output.of(scanDayLists));
        }

        /**
         * @param scanDayLists The days when the check is performed. The value indicates the days of the week.
         * 
         * @return builder
         * 
         */
        public Builder scanDayLists(Integer... scanDayLists) {
            return scanDayLists(List.of(scanDayLists));
        }

        /**
         * @param startTime The start time of the check. The time is in the HH:mm:ss format.
         * 
         * @return builder
         * 
         */
        public Builder startTime(@Nullable Output<String> startTime) {
            $.startTime = startTime;
            return this;
        }

        /**
         * @param startTime The start time of the check. The time is in the HH:mm:ss format.
         * 
         * @return builder
         * 
         */
        public Builder startTime(String startTime) {
            return startTime(Output.of(startTime));
        }

        public OssScanConfigState build() {
            return $;
        }
    }

}
