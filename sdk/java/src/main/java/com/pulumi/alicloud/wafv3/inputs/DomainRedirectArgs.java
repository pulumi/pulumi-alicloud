// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.wafv3.inputs;

import com.pulumi.alicloud.wafv3.inputs.DomainRedirectRequestHeaderArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DomainRedirectArgs extends com.pulumi.resources.ResourceArgs {

    public static final DomainRedirectArgs Empty = new DomainRedirectArgs();

    /**
     * The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
     * 
     */
    @Import(name="backends")
    private @Nullable Output<List<String>> backends;

    /**
     * @return The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
     * 
     */
    public Optional<Output<List<String>>> backends() {
        return Optional.ofNullable(this.backends);
    }

    /**
     * Connection timeout. Unit: seconds, value range: 5~120.
     * 
     */
    @Import(name="connectTimeout")
    private @Nullable Output<Integer> connectTimeout;

    /**
     * @return Connection timeout. Unit: seconds, value range: 5~120.
     * 
     */
    public Optional<Output<Integer>> connectTimeout() {
        return Optional.ofNullable(this.connectTimeout);
    }

    /**
     * Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
     * - **true**: indicates that forced HTTP back-to-origin is enabled.
     * - **false**: indicates that forced HTTP back-to-origin is not enabled.
     * 
     */
    @Import(name="focusHttpBackend")
    private @Nullable Output<Boolean> focusHttpBackend;

    /**
     * @return Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
     * - **true**: indicates that forced HTTP back-to-origin is enabled.
     * - **false**: indicates that forced HTTP back-to-origin is not enabled.
     * 
     */
    public Optional<Output<Boolean>> focusHttpBackend() {
        return Optional.ofNullable(this.focusHttpBackend);
    }

    /**
     * Open long connection, default true.
     * 
     */
    @Import(name="keepalive")
    private @Nullable Output<Boolean> keepalive;

    /**
     * @return Open long connection, default true.
     * 
     */
    public Optional<Output<Boolean>> keepalive() {
        return Optional.ofNullable(this.keepalive);
    }

    /**
     * Number of long connections,  default: `60`. range :60-1000.
     * 
     */
    @Import(name="keepaliveRequests")
    private @Nullable Output<Integer> keepaliveRequests;

    /**
     * @return Number of long connections,  default: `60`. range :60-1000.
     * 
     */
    public Optional<Output<Integer>> keepaliveRequests() {
        return Optional.ofNullable(this.keepaliveRequests);
    }

    /**
     * Long connection over time, default: `15`. Range: 1-60.
     * 
     */
    @Import(name="keepaliveTimeout")
    private @Nullable Output<Integer> keepaliveTimeout;

    /**
     * @return Long connection over time, default: `15`. Range: 1-60.
     * 
     */
    public Optional<Output<Integer>> keepaliveTimeout() {
        return Optional.ofNullable(this.keepaliveTimeout);
    }

    /**
     * The load balancing algorithm used when returning to the source. Value:
     * - **iphash**: indicates the IPHash algorithm.
     * - **roundRobin**: indicates the polling algorithm.
     * - **leastTime**: indicates the Least Time algorithm.
     * - This value can be selected only if the value of **protection_resource** is **gslb** (indicating that the protected resource type uses shared cluster intelligent load balancing).
     * 
     */
    @Import(name="loadbalance", required=true)
    private Output<String> loadbalance;

    /**
     * @return The load balancing algorithm used when returning to the source. Value:
     * - **iphash**: indicates the IPHash algorithm.
     * - **roundRobin**: indicates the polling algorithm.
     * - **leastTime**: indicates the Least Time algorithm.
     * - This value can be selected only if the value of **protection_resource** is **gslb** (indicating that the protected resource type uses shared cluster intelligent load balancing).
     * 
     */
    public Output<String> loadbalance() {
        return this.loadbalance;
    }

    /**
     * Read timeout duration. **Unit**: seconds, **Value range**: 5~1800.
     * 
     */
    @Import(name="readTimeout")
    private @Nullable Output<Integer> readTimeout;

    /**
     * @return Read timeout duration. **Unit**: seconds, **Value range**: 5~1800.
     * 
     */
    public Optional<Output<Integer>> readTimeout() {
        return Optional.ofNullable(this.readTimeout);
    }

    /**
     * The traffic tag field and value of the domain name which used to mark the traffic processed by WAF.
     * It formats as `[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]`. Where the `k` represents the specified custom request header field,
     * and the `v` represents the value set for this field. By specifying the custom request header field and the corresponding value,
     * when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value
     * to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the
     * custom header field already exists in the request, the system will overwrite the value of the custom field in the
     * request with the set traffic tag value. See `request_headers` below.
     * 
     */
    @Import(name="requestHeaders")
    private @Nullable Output<List<DomainRedirectRequestHeaderArgs>> requestHeaders;

    /**
     * @return The traffic tag field and value of the domain name which used to mark the traffic processed by WAF.
     * It formats as `[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]`. Where the `k` represents the specified custom request header field,
     * and the `v` represents the value set for this field. By specifying the custom request header field and the corresponding value,
     * when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value
     * to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the
     * custom header field already exists in the request, the system will overwrite the value of the custom field in the
     * request with the set traffic tag value. See `request_headers` below.
     * 
     */
    public Optional<Output<List<DomainRedirectRequestHeaderArgs>>> requestHeaders() {
        return Optional.ofNullable(this.requestHeaders);
    }

    /**
     * Back to Source Retry. default: true, retry 3 times by default.
     * 
     */
    @Import(name="retry")
    private @Nullable Output<Boolean> retry;

    /**
     * @return Back to Source Retry. default: true, retry 3 times by default.
     * 
     */
    public Optional<Output<Boolean>> retry() {
        return Optional.ofNullable(this.retry);
    }

    /**
     * Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
     * - **true**: indicates that the back-to-source SNI is enabled.
     * - **false** (default) indicates that the back-to-source SNI is not enabled.
     * 
     */
    @Import(name="sniEnabled")
    private @Nullable Output<Boolean> sniEnabled;

    /**
     * @return Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
     * - **true**: indicates that the back-to-source SNI is enabled.
     * - **false** (default) indicates that the back-to-source SNI is not enabled.
     * 
     */
    public Optional<Output<Boolean>> sniEnabled() {
        return Optional.ofNullable(this.sniEnabled);
    }

    /**
     * Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).&gt; This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
     * 
     */
    @Import(name="sniHost")
    private @Nullable Output<String> sniHost;

    /**
     * @return Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).&gt; This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
     * 
     */
    public Optional<Output<String>> sniHost() {
        return Optional.ofNullable(this.sniHost);
    }

    /**
     * Write timeout duration&gt; **Unit**: seconds, **Value range**: 5~1800.
     * 
     */
    @Import(name="writeTimeout")
    private @Nullable Output<Integer> writeTimeout;

    /**
     * @return Write timeout duration&gt; **Unit**: seconds, **Value range**: 5~1800.
     * 
     */
    public Optional<Output<Integer>> writeTimeout() {
        return Optional.ofNullable(this.writeTimeout);
    }

    private DomainRedirectArgs() {}

    private DomainRedirectArgs(DomainRedirectArgs $) {
        this.backends = $.backends;
        this.connectTimeout = $.connectTimeout;
        this.focusHttpBackend = $.focusHttpBackend;
        this.keepalive = $.keepalive;
        this.keepaliveRequests = $.keepaliveRequests;
        this.keepaliveTimeout = $.keepaliveTimeout;
        this.loadbalance = $.loadbalance;
        this.readTimeout = $.readTimeout;
        this.requestHeaders = $.requestHeaders;
        this.retry = $.retry;
        this.sniEnabled = $.sniEnabled;
        this.sniHost = $.sniHost;
        this.writeTimeout = $.writeTimeout;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DomainRedirectArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DomainRedirectArgs $;

        public Builder() {
            $ = new DomainRedirectArgs();
        }

        public Builder(DomainRedirectArgs defaults) {
            $ = new DomainRedirectArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param backends The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
         * 
         * @return builder
         * 
         */
        public Builder backends(@Nullable Output<List<String>> backends) {
            $.backends = backends;
            return this;
        }

        /**
         * @param backends The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
         * 
         * @return builder
         * 
         */
        public Builder backends(List<String> backends) {
            return backends(Output.of(backends));
        }

        /**
         * @param backends The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
         * 
         * @return builder
         * 
         */
        public Builder backends(String... backends) {
            return backends(List.of(backends));
        }

        /**
         * @param connectTimeout Connection timeout. Unit: seconds, value range: 5~120.
         * 
         * @return builder
         * 
         */
        public Builder connectTimeout(@Nullable Output<Integer> connectTimeout) {
            $.connectTimeout = connectTimeout;
            return this;
        }

        /**
         * @param connectTimeout Connection timeout. Unit: seconds, value range: 5~120.
         * 
         * @return builder
         * 
         */
        public Builder connectTimeout(Integer connectTimeout) {
            return connectTimeout(Output.of(connectTimeout));
        }

        /**
         * @param focusHttpBackend Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that forced HTTP back-to-origin is enabled.
         * - **false**: indicates that forced HTTP back-to-origin is not enabled.
         * 
         * @return builder
         * 
         */
        public Builder focusHttpBackend(@Nullable Output<Boolean> focusHttpBackend) {
            $.focusHttpBackend = focusHttpBackend;
            return this;
        }

        /**
         * @param focusHttpBackend Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that forced HTTP back-to-origin is enabled.
         * - **false**: indicates that forced HTTP back-to-origin is not enabled.
         * 
         * @return builder
         * 
         */
        public Builder focusHttpBackend(Boolean focusHttpBackend) {
            return focusHttpBackend(Output.of(focusHttpBackend));
        }

        /**
         * @param keepalive Open long connection, default true.
         * 
         * @return builder
         * 
         */
        public Builder keepalive(@Nullable Output<Boolean> keepalive) {
            $.keepalive = keepalive;
            return this;
        }

        /**
         * @param keepalive Open long connection, default true.
         * 
         * @return builder
         * 
         */
        public Builder keepalive(Boolean keepalive) {
            return keepalive(Output.of(keepalive));
        }

        /**
         * @param keepaliveRequests Number of long connections,  default: `60`. range :60-1000.
         * 
         * @return builder
         * 
         */
        public Builder keepaliveRequests(@Nullable Output<Integer> keepaliveRequests) {
            $.keepaliveRequests = keepaliveRequests;
            return this;
        }

        /**
         * @param keepaliveRequests Number of long connections,  default: `60`. range :60-1000.
         * 
         * @return builder
         * 
         */
        public Builder keepaliveRequests(Integer keepaliveRequests) {
            return keepaliveRequests(Output.of(keepaliveRequests));
        }

        /**
         * @param keepaliveTimeout Long connection over time, default: `15`. Range: 1-60.
         * 
         * @return builder
         * 
         */
        public Builder keepaliveTimeout(@Nullable Output<Integer> keepaliveTimeout) {
            $.keepaliveTimeout = keepaliveTimeout;
            return this;
        }

        /**
         * @param keepaliveTimeout Long connection over time, default: `15`. Range: 1-60.
         * 
         * @return builder
         * 
         */
        public Builder keepaliveTimeout(Integer keepaliveTimeout) {
            return keepaliveTimeout(Output.of(keepaliveTimeout));
        }

        /**
         * @param loadbalance The load balancing algorithm used when returning to the source. Value:
         * - **iphash**: indicates the IPHash algorithm.
         * - **roundRobin**: indicates the polling algorithm.
         * - **leastTime**: indicates the Least Time algorithm.
         * - This value can be selected only if the value of **protection_resource** is **gslb** (indicating that the protected resource type uses shared cluster intelligent load balancing).
         * 
         * @return builder
         * 
         */
        public Builder loadbalance(Output<String> loadbalance) {
            $.loadbalance = loadbalance;
            return this;
        }

        /**
         * @param loadbalance The load balancing algorithm used when returning to the source. Value:
         * - **iphash**: indicates the IPHash algorithm.
         * - **roundRobin**: indicates the polling algorithm.
         * - **leastTime**: indicates the Least Time algorithm.
         * - This value can be selected only if the value of **protection_resource** is **gslb** (indicating that the protected resource type uses shared cluster intelligent load balancing).
         * 
         * @return builder
         * 
         */
        public Builder loadbalance(String loadbalance) {
            return loadbalance(Output.of(loadbalance));
        }

        /**
         * @param readTimeout Read timeout duration. **Unit**: seconds, **Value range**: 5~1800.
         * 
         * @return builder
         * 
         */
        public Builder readTimeout(@Nullable Output<Integer> readTimeout) {
            $.readTimeout = readTimeout;
            return this;
        }

        /**
         * @param readTimeout Read timeout duration. **Unit**: seconds, **Value range**: 5~1800.
         * 
         * @return builder
         * 
         */
        public Builder readTimeout(Integer readTimeout) {
            return readTimeout(Output.of(readTimeout));
        }

        /**
         * @param requestHeaders The traffic tag field and value of the domain name which used to mark the traffic processed by WAF.
         * It formats as `[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]`. Where the `k` represents the specified custom request header field,
         * and the `v` represents the value set for this field. By specifying the custom request header field and the corresponding value,
         * when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value
         * to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the
         * custom header field already exists in the request, the system will overwrite the value of the custom field in the
         * request with the set traffic tag value. See `request_headers` below.
         * 
         * @return builder
         * 
         */
        public Builder requestHeaders(@Nullable Output<List<DomainRedirectRequestHeaderArgs>> requestHeaders) {
            $.requestHeaders = requestHeaders;
            return this;
        }

        /**
         * @param requestHeaders The traffic tag field and value of the domain name which used to mark the traffic processed by WAF.
         * It formats as `[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]`. Where the `k` represents the specified custom request header field,
         * and the `v` represents the value set for this field. By specifying the custom request header field and the corresponding value,
         * when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value
         * to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the
         * custom header field already exists in the request, the system will overwrite the value of the custom field in the
         * request with the set traffic tag value. See `request_headers` below.
         * 
         * @return builder
         * 
         */
        public Builder requestHeaders(List<DomainRedirectRequestHeaderArgs> requestHeaders) {
            return requestHeaders(Output.of(requestHeaders));
        }

        /**
         * @param requestHeaders The traffic tag field and value of the domain name which used to mark the traffic processed by WAF.
         * It formats as `[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]`. Where the `k` represents the specified custom request header field,
         * and the `v` represents the value set for this field. By specifying the custom request header field and the corresponding value,
         * when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value
         * to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the
         * custom header field already exists in the request, the system will overwrite the value of the custom field in the
         * request with the set traffic tag value. See `request_headers` below.
         * 
         * @return builder
         * 
         */
        public Builder requestHeaders(DomainRedirectRequestHeaderArgs... requestHeaders) {
            return requestHeaders(List.of(requestHeaders));
        }

        /**
         * @param retry Back to Source Retry. default: true, retry 3 times by default.
         * 
         * @return builder
         * 
         */
        public Builder retry(@Nullable Output<Boolean> retry) {
            $.retry = retry;
            return this;
        }

        /**
         * @param retry Back to Source Retry. default: true, retry 3 times by default.
         * 
         * @return builder
         * 
         */
        public Builder retry(Boolean retry) {
            return retry(Output.of(retry));
        }

        /**
         * @param sniEnabled Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that the back-to-source SNI is enabled.
         * - **false** (default) indicates that the back-to-source SNI is not enabled.
         * 
         * @return builder
         * 
         */
        public Builder sniEnabled(@Nullable Output<Boolean> sniEnabled) {
            $.sniEnabled = sniEnabled;
            return this;
        }

        /**
         * @param sniEnabled Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol). Value:
         * - **true**: indicates that the back-to-source SNI is enabled.
         * - **false** (default) indicates that the back-to-source SNI is not enabled.
         * 
         * @return builder
         * 
         */
        public Builder sniEnabled(Boolean sniEnabled) {
            return sniEnabled(Output.of(sniEnabled));
        }

        /**
         * @param sniHost Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).&gt; This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
         * 
         * @return builder
         * 
         */
        public Builder sniHost(@Nullable Output<String> sniHost) {
            $.sniHost = sniHost;
            return this;
        }

        /**
         * @param sniHost Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).&gt; This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
         * 
         * @return builder
         * 
         */
        public Builder sniHost(String sniHost) {
            return sniHost(Output.of(sniHost));
        }

        /**
         * @param writeTimeout Write timeout duration&gt; **Unit**: seconds, **Value range**: 5~1800.
         * 
         * @return builder
         * 
         */
        public Builder writeTimeout(@Nullable Output<Integer> writeTimeout) {
            $.writeTimeout = writeTimeout;
            return this;
        }

        /**
         * @param writeTimeout Write timeout duration&gt; **Unit**: seconds, **Value range**: 5~1800.
         * 
         * @return builder
         * 
         */
        public Builder writeTimeout(Integer writeTimeout) {
            return writeTimeout(Output.of(writeTimeout));
        }

        public DomainRedirectArgs build() {
            $.loadbalance = Objects.requireNonNull($.loadbalance, "expected parameter 'loadbalance' to be non-null");
            return $;
        }
    }

}
