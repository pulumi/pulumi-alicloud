// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.wafv3.outputs;

import com.pulumi.alicloud.wafv3.outputs.GetDomainsDomainRedirectRequestHeader;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetDomainsDomainRedirect {
    /**
     * @return The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
     * 
     */
    private List<String> backends;
    /**
     * @return Connection timeout, Unit: seconds, value range: 5~120.
     * 
     */
    private Integer connectTimeout;
    /**
     * @return Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private Boolean focusHttpBackend;
    /**
     * @return Open long connection, default true.
     * 
     */
    private Boolean keepalive;
    /**
     * @return Number of long connections, default: `60`. range :60-1000.
     * 
     */
    private Integer keepaliveRequests;
    /**
     * @return Long connection over time, default: `15`. Range: 1-60.
     * 
     */
    private Integer keepaliveTimeout;
    /**
     * @return The load balancing algorithm used when returning to the source.
     * 
     */
    private String loadbalance;
    /**
     * @return Read timeout duration. Unit: seconds, Value range: 5~1800.
     * 
     */
    private Integer readTimeout;
    /**
     * @return The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]**. where_key_represents the specified custom request header field, and_value_represents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
     * 
     */
    private List<GetDomainsDomainRedirectRequestHeader> requestHeaders;
    /**
     * @return Back to Source Retry. default `true`, retry 3 times by default.
     * 
     */
    private Boolean retry;
    /**
     * @return Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    private Boolean sniEnabled;
    /**
     * @return Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).&gt; This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
     * 
     */
    private String sniHost;
    /**
     * @return Write timeout duration. **Unit**: seconds, **Value range**:5~1800.
     * 
     */
    private Integer writeTimeout;

    private GetDomainsDomainRedirect() {}
    /**
     * @return The IP address of the origin server corresponding to the domain name or the back-to-origin domain name of the server.
     * 
     */
    public List<String> backends() {
        return this.backends;
    }
    /**
     * @return Connection timeout, Unit: seconds, value range: 5~120.
     * 
     */
    public Integer connectTimeout() {
        return this.connectTimeout;
    }
    /**
     * @return Whether to enable forced HTTP back-to-origin. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public Boolean focusHttpBackend() {
        return this.focusHttpBackend;
    }
    /**
     * @return Open long connection, default true.
     * 
     */
    public Boolean keepalive() {
        return this.keepalive;
    }
    /**
     * @return Number of long connections, default: `60`. range :60-1000.
     * 
     */
    public Integer keepaliveRequests() {
        return this.keepaliveRequests;
    }
    /**
     * @return Long connection over time, default: `15`. Range: 1-60.
     * 
     */
    public Integer keepaliveTimeout() {
        return this.keepaliveTimeout;
    }
    /**
     * @return The load balancing algorithm used when returning to the source.
     * 
     */
    public String loadbalance() {
        return this.loadbalance;
    }
    /**
     * @return Read timeout duration. Unit: seconds, Value range: 5~1800.
     * 
     */
    public Integer readTimeout() {
        return this.readTimeout;
    }
    /**
     * @return The traffic tag field and value of the domain name, which is used to mark the traffic processed by WAF. the format of this parameter value is **[{&#34; k &#34;:&#34;_key_&#34;,&#34; v &#34;:&#34;_value_&#34;}]**. where_key_represents the specified custom request header field, and_value_represents the value set for this field.By specifying the custom request header field and the corresponding value, when the access traffic of the domain name passes through WAF, WAF automatically adds the specified custom field value to the request header as the traffic mark, which is convenient for backend service statistics.Explain that if the custom header field already exists in the request, the system will overwrite the value of the custom field in the request with the set traffic tag value.
     * 
     */
    public List<GetDomainsDomainRedirectRequestHeader> requestHeaders() {
        return this.requestHeaders;
    }
    /**
     * @return Back to Source Retry. default `true`, retry 3 times by default.
     * 
     */
    public Boolean retry() {
        return this.retry;
    }
    /**
     * @return Whether to enable back-to-source SNI. This parameter is used only if the value of **https_ports** is not empty (indicating that the domain name uses the HTTPS protocol).
     * 
     */
    public Boolean sniEnabled() {
        return this.sniEnabled;
    }
    /**
     * @return Sets the value of the custom SNI extension field. If this parameter is not set, the value of the **Host** field in the request header is used as the value of the SNI extension field by default.In general, you do not need to customize SNI unless your business has special configuration requirements. You want WAF to use SNI that is inconsistent with the actual request Host in the back-to-origin request (that is, the custom SNI set here).&gt; This parameter is required only when **sni_enalbed** is set to **true** (indicating that back-to-source SNI is enabled).
     * 
     */
    public String sniHost() {
        return this.sniHost;
    }
    /**
     * @return Write timeout duration. **Unit**: seconds, **Value range**:5~1800.
     * 
     */
    public Integer writeTimeout() {
        return this.writeTimeout;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDomainsDomainRedirect defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<String> backends;
        private Integer connectTimeout;
        private Boolean focusHttpBackend;
        private Boolean keepalive;
        private Integer keepaliveRequests;
        private Integer keepaliveTimeout;
        private String loadbalance;
        private Integer readTimeout;
        private List<GetDomainsDomainRedirectRequestHeader> requestHeaders;
        private Boolean retry;
        private Boolean sniEnabled;
        private String sniHost;
        private Integer writeTimeout;
        public Builder() {}
        public Builder(GetDomainsDomainRedirect defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.backends = defaults.backends;
    	      this.connectTimeout = defaults.connectTimeout;
    	      this.focusHttpBackend = defaults.focusHttpBackend;
    	      this.keepalive = defaults.keepalive;
    	      this.keepaliveRequests = defaults.keepaliveRequests;
    	      this.keepaliveTimeout = defaults.keepaliveTimeout;
    	      this.loadbalance = defaults.loadbalance;
    	      this.readTimeout = defaults.readTimeout;
    	      this.requestHeaders = defaults.requestHeaders;
    	      this.retry = defaults.retry;
    	      this.sniEnabled = defaults.sniEnabled;
    	      this.sniHost = defaults.sniHost;
    	      this.writeTimeout = defaults.writeTimeout;
        }

        @CustomType.Setter
        public Builder backends(List<String> backends) {
            if (backends == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "backends");
            }
            this.backends = backends;
            return this;
        }
        public Builder backends(String... backends) {
            return backends(List.of(backends));
        }
        @CustomType.Setter
        public Builder connectTimeout(Integer connectTimeout) {
            if (connectTimeout == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "connectTimeout");
            }
            this.connectTimeout = connectTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder focusHttpBackend(Boolean focusHttpBackend) {
            if (focusHttpBackend == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "focusHttpBackend");
            }
            this.focusHttpBackend = focusHttpBackend;
            return this;
        }
        @CustomType.Setter
        public Builder keepalive(Boolean keepalive) {
            if (keepalive == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "keepalive");
            }
            this.keepalive = keepalive;
            return this;
        }
        @CustomType.Setter
        public Builder keepaliveRequests(Integer keepaliveRequests) {
            if (keepaliveRequests == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "keepaliveRequests");
            }
            this.keepaliveRequests = keepaliveRequests;
            return this;
        }
        @CustomType.Setter
        public Builder keepaliveTimeout(Integer keepaliveTimeout) {
            if (keepaliveTimeout == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "keepaliveTimeout");
            }
            this.keepaliveTimeout = keepaliveTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder loadbalance(String loadbalance) {
            if (loadbalance == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "loadbalance");
            }
            this.loadbalance = loadbalance;
            return this;
        }
        @CustomType.Setter
        public Builder readTimeout(Integer readTimeout) {
            if (readTimeout == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "readTimeout");
            }
            this.readTimeout = readTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder requestHeaders(List<GetDomainsDomainRedirectRequestHeader> requestHeaders) {
            if (requestHeaders == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "requestHeaders");
            }
            this.requestHeaders = requestHeaders;
            return this;
        }
        public Builder requestHeaders(GetDomainsDomainRedirectRequestHeader... requestHeaders) {
            return requestHeaders(List.of(requestHeaders));
        }
        @CustomType.Setter
        public Builder retry(Boolean retry) {
            if (retry == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "retry");
            }
            this.retry = retry;
            return this;
        }
        @CustomType.Setter
        public Builder sniEnabled(Boolean sniEnabled) {
            if (sniEnabled == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "sniEnabled");
            }
            this.sniEnabled = sniEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder sniHost(String sniHost) {
            if (sniHost == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "sniHost");
            }
            this.sniHost = sniHost;
            return this;
        }
        @CustomType.Setter
        public Builder writeTimeout(Integer writeTimeout) {
            if (writeTimeout == null) {
              throw new MissingRequiredPropertyException("GetDomainsDomainRedirect", "writeTimeout");
            }
            this.writeTimeout = writeTimeout;
            return this;
        }
        public GetDomainsDomainRedirect build() {
            final var _resultValue = new GetDomainsDomainRedirect();
            _resultValue.backends = backends;
            _resultValue.connectTimeout = connectTimeout;
            _resultValue.focusHttpBackend = focusHttpBackend;
            _resultValue.keepalive = keepalive;
            _resultValue.keepaliveRequests = keepaliveRequests;
            _resultValue.keepaliveTimeout = keepaliveTimeout;
            _resultValue.loadbalance = loadbalance;
            _resultValue.readTimeout = readTimeout;
            _resultValue.requestHeaders = requestHeaders;
            _resultValue.retry = retry;
            _resultValue.sniEnabled = sniEnabled;
            _resultValue.sniHost = sniHost;
            _resultValue.writeTimeout = writeTimeout;
            return _resultValue;
        }
    }
}
