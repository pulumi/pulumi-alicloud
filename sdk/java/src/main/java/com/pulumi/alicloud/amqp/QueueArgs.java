// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.amqp;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class QueueArgs extends com.pulumi.resources.ResourceArgs {

    public static final QueueArgs Empty = new QueueArgs();

    /**
     * Specifies whether the Auto Delete attribute is configured. Valid values:
     * * true: The Auto Delete attribute is configured. The queue is automatically deleted after the last subscription from consumers to this queue is canceled.
     * * false: The Auto Delete attribute is not configured.
     * 
     */
    @Import(name="autoDeleteState")
    private @Nullable Output<Boolean> autoDeleteState;

    /**
     * @return Specifies whether the Auto Delete attribute is configured. Valid values:
     * * true: The Auto Delete attribute is configured. The queue is automatically deleted after the last subscription from consumers to this queue is canceled.
     * * false: The Auto Delete attribute is not configured.
     * 
     */
    public Optional<Output<Boolean>> autoDeleteState() {
        return Optional.ofNullable(this.autoDeleteState);
    }

    /**
     * The validity period after which the queue is automatically deleted.
     * If the queue is not accessed within a specified period of time, it is automatically deleted.
     * 
     */
    @Import(name="autoExpireState")
    private @Nullable Output<String> autoExpireState;

    /**
     * @return The validity period after which the queue is automatically deleted.
     * If the queue is not accessed within a specified period of time, it is automatically deleted.
     * 
     */
    public Optional<Output<String>> autoExpireState() {
        return Optional.ofNullable(this.autoExpireState);
    }

    /**
     * The dead-letter exchange. A dead-letter exchange is used to receive rejected messages.
     * If a consumer rejects a message that cannot be retried, this message is routed to a specified dead-letter exchange.
     * Then, the dead-letter exchange routes the message to the queue that is bound to the dead-letter exchange.
     * 
     */
    @Import(name="deadLetterExchange")
    private @Nullable Output<String> deadLetterExchange;

    /**
     * @return The dead-letter exchange. A dead-letter exchange is used to receive rejected messages.
     * If a consumer rejects a message that cannot be retried, this message is routed to a specified dead-letter exchange.
     * Then, the dead-letter exchange routes the message to the queue that is bound to the dead-letter exchange.
     * 
     */
    public Optional<Output<String>> deadLetterExchange() {
        return Optional.ofNullable(this.deadLetterExchange);
    }

    /**
     * The dead letter routing key.
     * 
     */
    @Import(name="deadLetterRoutingKey")
    private @Nullable Output<String> deadLetterRoutingKey;

    /**
     * @return The dead letter routing key.
     * 
     */
    public Optional<Output<String>> deadLetterRoutingKey() {
        return Optional.ofNullable(this.deadLetterRoutingKey);
    }

    /**
     * Specifies whether the queue is an exclusive queue. Valid values:
     * * true: The queue is an exclusive queue. It can be used only for the connection that declares the exclusive queue. After the connection is closed, the exclusive queue is automatically deleted.
     * * false: The queue is not an exclusive queue.
     * 
     */
    @Import(name="exclusiveState")
    private @Nullable Output<Boolean> exclusiveState;

    /**
     * @return Specifies whether the queue is an exclusive queue. Valid values:
     * * true: The queue is an exclusive queue. It can be used only for the connection that declares the exclusive queue. After the connection is closed, the exclusive queue is automatically deleted.
     * * false: The queue is not an exclusive queue.
     * 
     */
    public Optional<Output<Boolean>> exclusiveState() {
        return Optional.ofNullable(this.exclusiveState);
    }

    /**
     * The ID of the instance.
     * 
     */
    @Import(name="instanceId", required=true)
    private Output<String> instanceId;

    /**
     * @return The ID of the instance.
     * 
     */
    public Output<String> instanceId() {
        return this.instanceId;
    }

    /**
     * The maximum number of messages that can be stored in the queue.
     * If this threshold is exceeded, the earliest messages that are routed to the queue are discarded.
     * 
     */
    @Import(name="maxLength")
    private @Nullable Output<String> maxLength;

    /**
     * @return The maximum number of messages that can be stored in the queue.
     * If this threshold is exceeded, the earliest messages that are routed to the queue are discarded.
     * 
     */
    public Optional<Output<String>> maxLength() {
        return Optional.ofNullable(this.maxLength);
    }

    /**
     * The highest priority supported by the queue. This parameter is set to a positive integer.
     * Valid values: 0 to 255. Recommended values: 1 to 10
     * 
     */
    @Import(name="maximumPriority")
    private @Nullable Output<Integer> maximumPriority;

    /**
     * @return The highest priority supported by the queue. This parameter is set to a positive integer.
     * Valid values: 0 to 255. Recommended values: 1 to 10
     * 
     */
    public Optional<Output<Integer>> maximumPriority() {
        return Optional.ofNullable(this.maximumPriority);
    }

    /**
     * The message TTL of the queue.
     * If the retention period of a message in the queue exceeds the message TTL of the queue, the message expires.
     * Message TTL must be set to a non-negative integer, in milliseconds.
     * For example, if the message TTL of the queue is 1000, messages survive for at most 1 second in the queue.
     * 
     */
    @Import(name="messageTtl")
    private @Nullable Output<String> messageTtl;

    /**
     * @return The message TTL of the queue.
     * If the retention period of a message in the queue exceeds the message TTL of the queue, the message expires.
     * Message TTL must be set to a non-negative integer, in milliseconds.
     * For example, if the message TTL of the queue is 1000, messages survive for at most 1 second in the queue.
     * 
     */
    public Optional<Output<String>> messageTtl() {
        return Optional.ofNullable(this.messageTtl);
    }

    /**
     * The name of the queue.
     * The queue name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs (@).
     * 
     */
    @Import(name="queueName", required=true)
    private Output<String> queueName;

    /**
     * @return The name of the queue.
     * The queue name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs (@).
     * 
     */
    public Output<String> queueName() {
        return this.queueName;
    }

    /**
     * The name of the virtual host.
     * 
     */
    @Import(name="virtualHostName", required=true)
    private Output<String> virtualHostName;

    /**
     * @return The name of the virtual host.
     * 
     */
    public Output<String> virtualHostName() {
        return this.virtualHostName;
    }

    private QueueArgs() {}

    private QueueArgs(QueueArgs $) {
        this.autoDeleteState = $.autoDeleteState;
        this.autoExpireState = $.autoExpireState;
        this.deadLetterExchange = $.deadLetterExchange;
        this.deadLetterRoutingKey = $.deadLetterRoutingKey;
        this.exclusiveState = $.exclusiveState;
        this.instanceId = $.instanceId;
        this.maxLength = $.maxLength;
        this.maximumPriority = $.maximumPriority;
        this.messageTtl = $.messageTtl;
        this.queueName = $.queueName;
        this.virtualHostName = $.virtualHostName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(QueueArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private QueueArgs $;

        public Builder() {
            $ = new QueueArgs();
        }

        public Builder(QueueArgs defaults) {
            $ = new QueueArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param autoDeleteState Specifies whether the Auto Delete attribute is configured. Valid values:
         * * true: The Auto Delete attribute is configured. The queue is automatically deleted after the last subscription from consumers to this queue is canceled.
         * * false: The Auto Delete attribute is not configured.
         * 
         * @return builder
         * 
         */
        public Builder autoDeleteState(@Nullable Output<Boolean> autoDeleteState) {
            $.autoDeleteState = autoDeleteState;
            return this;
        }

        /**
         * @param autoDeleteState Specifies whether the Auto Delete attribute is configured. Valid values:
         * * true: The Auto Delete attribute is configured. The queue is automatically deleted after the last subscription from consumers to this queue is canceled.
         * * false: The Auto Delete attribute is not configured.
         * 
         * @return builder
         * 
         */
        public Builder autoDeleteState(Boolean autoDeleteState) {
            return autoDeleteState(Output.of(autoDeleteState));
        }

        /**
         * @param autoExpireState The validity period after which the queue is automatically deleted.
         * If the queue is not accessed within a specified period of time, it is automatically deleted.
         * 
         * @return builder
         * 
         */
        public Builder autoExpireState(@Nullable Output<String> autoExpireState) {
            $.autoExpireState = autoExpireState;
            return this;
        }

        /**
         * @param autoExpireState The validity period after which the queue is automatically deleted.
         * If the queue is not accessed within a specified period of time, it is automatically deleted.
         * 
         * @return builder
         * 
         */
        public Builder autoExpireState(String autoExpireState) {
            return autoExpireState(Output.of(autoExpireState));
        }

        /**
         * @param deadLetterExchange The dead-letter exchange. A dead-letter exchange is used to receive rejected messages.
         * If a consumer rejects a message that cannot be retried, this message is routed to a specified dead-letter exchange.
         * Then, the dead-letter exchange routes the message to the queue that is bound to the dead-letter exchange.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterExchange(@Nullable Output<String> deadLetterExchange) {
            $.deadLetterExchange = deadLetterExchange;
            return this;
        }

        /**
         * @param deadLetterExchange The dead-letter exchange. A dead-letter exchange is used to receive rejected messages.
         * If a consumer rejects a message that cannot be retried, this message is routed to a specified dead-letter exchange.
         * Then, the dead-letter exchange routes the message to the queue that is bound to the dead-letter exchange.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterExchange(String deadLetterExchange) {
            return deadLetterExchange(Output.of(deadLetterExchange));
        }

        /**
         * @param deadLetterRoutingKey The dead letter routing key.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterRoutingKey(@Nullable Output<String> deadLetterRoutingKey) {
            $.deadLetterRoutingKey = deadLetterRoutingKey;
            return this;
        }

        /**
         * @param deadLetterRoutingKey The dead letter routing key.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterRoutingKey(String deadLetterRoutingKey) {
            return deadLetterRoutingKey(Output.of(deadLetterRoutingKey));
        }

        /**
         * @param exclusiveState Specifies whether the queue is an exclusive queue. Valid values:
         * * true: The queue is an exclusive queue. It can be used only for the connection that declares the exclusive queue. After the connection is closed, the exclusive queue is automatically deleted.
         * * false: The queue is not an exclusive queue.
         * 
         * @return builder
         * 
         */
        public Builder exclusiveState(@Nullable Output<Boolean> exclusiveState) {
            $.exclusiveState = exclusiveState;
            return this;
        }

        /**
         * @param exclusiveState Specifies whether the queue is an exclusive queue. Valid values:
         * * true: The queue is an exclusive queue. It can be used only for the connection that declares the exclusive queue. After the connection is closed, the exclusive queue is automatically deleted.
         * * false: The queue is not an exclusive queue.
         * 
         * @return builder
         * 
         */
        public Builder exclusiveState(Boolean exclusiveState) {
            return exclusiveState(Output.of(exclusiveState));
        }

        /**
         * @param instanceId The ID of the instance.
         * 
         * @return builder
         * 
         */
        public Builder instanceId(Output<String> instanceId) {
            $.instanceId = instanceId;
            return this;
        }

        /**
         * @param instanceId The ID of the instance.
         * 
         * @return builder
         * 
         */
        public Builder instanceId(String instanceId) {
            return instanceId(Output.of(instanceId));
        }

        /**
         * @param maxLength The maximum number of messages that can be stored in the queue.
         * If this threshold is exceeded, the earliest messages that are routed to the queue are discarded.
         * 
         * @return builder
         * 
         */
        public Builder maxLength(@Nullable Output<String> maxLength) {
            $.maxLength = maxLength;
            return this;
        }

        /**
         * @param maxLength The maximum number of messages that can be stored in the queue.
         * If this threshold is exceeded, the earliest messages that are routed to the queue are discarded.
         * 
         * @return builder
         * 
         */
        public Builder maxLength(String maxLength) {
            return maxLength(Output.of(maxLength));
        }

        /**
         * @param maximumPriority The highest priority supported by the queue. This parameter is set to a positive integer.
         * Valid values: 0 to 255. Recommended values: 1 to 10
         * 
         * @return builder
         * 
         */
        public Builder maximumPriority(@Nullable Output<Integer> maximumPriority) {
            $.maximumPriority = maximumPriority;
            return this;
        }

        /**
         * @param maximumPriority The highest priority supported by the queue. This parameter is set to a positive integer.
         * Valid values: 0 to 255. Recommended values: 1 to 10
         * 
         * @return builder
         * 
         */
        public Builder maximumPriority(Integer maximumPriority) {
            return maximumPriority(Output.of(maximumPriority));
        }

        /**
         * @param messageTtl The message TTL of the queue.
         * If the retention period of a message in the queue exceeds the message TTL of the queue, the message expires.
         * Message TTL must be set to a non-negative integer, in milliseconds.
         * For example, if the message TTL of the queue is 1000, messages survive for at most 1 second in the queue.
         * 
         * @return builder
         * 
         */
        public Builder messageTtl(@Nullable Output<String> messageTtl) {
            $.messageTtl = messageTtl;
            return this;
        }

        /**
         * @param messageTtl The message TTL of the queue.
         * If the retention period of a message in the queue exceeds the message TTL of the queue, the message expires.
         * Message TTL must be set to a non-negative integer, in milliseconds.
         * For example, if the message TTL of the queue is 1000, messages survive for at most 1 second in the queue.
         * 
         * @return builder
         * 
         */
        public Builder messageTtl(String messageTtl) {
            return messageTtl(Output.of(messageTtl));
        }

        /**
         * @param queueName The name of the queue.
         * The queue name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs (@).
         * 
         * @return builder
         * 
         */
        public Builder queueName(Output<String> queueName) {
            $.queueName = queueName;
            return this;
        }

        /**
         * @param queueName The name of the queue.
         * The queue name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (_), periods (.), and at signs (@).
         * 
         * @return builder
         * 
         */
        public Builder queueName(String queueName) {
            return queueName(Output.of(queueName));
        }

        /**
         * @param virtualHostName The name of the virtual host.
         * 
         * @return builder
         * 
         */
        public Builder virtualHostName(Output<String> virtualHostName) {
            $.virtualHostName = virtualHostName;
            return this;
        }

        /**
         * @param virtualHostName The name of the virtual host.
         * 
         * @return builder
         * 
         */
        public Builder virtualHostName(String virtualHostName) {
            return virtualHostName(Output.of(virtualHostName));
        }

        public QueueArgs build() {
            if ($.instanceId == null) {
                throw new MissingRequiredPropertyException("QueueArgs", "instanceId");
            }
            if ($.queueName == null) {
                throw new MissingRequiredPropertyException("QueueArgs", "queueName");
            }
            if ($.virtualHostName == null) {
                throw new MissingRequiredPropertyException("QueueArgs", "virtualHostName");
            }
            return $;
        }
    }

}
