// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.sae;

import com.pulumi.alicloud.Utilities;
import com.pulumi.alicloud.sae.ApplicationArgs;
import com.pulumi.alicloud.sae.inputs.ApplicationState;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Provides a Serverless App Engine (SAE) Application resource.
 * 
 * For information about Serverless App Engine (SAE) Application and how to use it, see [What is Application](https://www.alibabacloud.com/help/en/sae/latest/createapplication).
 * 
 * &gt; **NOTE:** Available since v1.161.0.
 * 
 * ## Example Usage
 * 
 * Basic Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.alicloud.AlicloudFunctions;
 * import com.pulumi.alicloud.inputs.GetRegionsArgs;
 * import com.pulumi.random.RandomInteger;
 * import com.pulumi.random.RandomIntegerArgs;
 * import com.pulumi.alicloud.inputs.GetZonesArgs;
 * import com.pulumi.alicloud.vpc.Network;
 * import com.pulumi.alicloud.vpc.NetworkArgs;
 * import com.pulumi.alicloud.vpc.Switch;
 * import com.pulumi.alicloud.vpc.SwitchArgs;
 * import com.pulumi.alicloud.ecs.SecurityGroup;
 * import com.pulumi.alicloud.ecs.SecurityGroupArgs;
 * import com.pulumi.alicloud.sae.Namespace;
 * import com.pulumi.alicloud.sae.NamespaceArgs;
 * import com.pulumi.alicloud.sae.Application;
 * import com.pulumi.alicloud.sae.ApplicationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var config = ctx.config();
 *         final var name = config.get(&#34;name&#34;).orElse(&#34;tf-example&#34;);
 *         final var defaultRegions = AlicloudFunctions.getRegions(GetRegionsArgs.builder()
 *             .current(true)
 *             .build());
 * 
 *         var defaultRandomInteger = new RandomInteger(&#34;defaultRandomInteger&#34;, RandomIntegerArgs.builder()        
 *             .max(99999)
 *             .min(10000)
 *             .build());
 * 
 *         final var defaultZones = AlicloudFunctions.getZones(GetZonesArgs.builder()
 *             .availableResourceCreation(&#34;VSwitch&#34;)
 *             .build());
 * 
 *         var defaultNetwork = new Network(&#34;defaultNetwork&#34;, NetworkArgs.builder()        
 *             .vpcName(name)
 *             .cidrBlock(&#34;10.4.0.0/16&#34;)
 *             .build());
 * 
 *         var defaultSwitch = new Switch(&#34;defaultSwitch&#34;, SwitchArgs.builder()        
 *             .vswitchName(name)
 *             .cidrBlock(&#34;10.4.0.0/24&#34;)
 *             .vpcId(defaultNetwork.id())
 *             .zoneId(defaultZones.applyValue(getZonesResult -&gt; getZonesResult.zones()[0].id()))
 *             .build());
 * 
 *         var defaultSecurityGroup = new SecurityGroup(&#34;defaultSecurityGroup&#34;, SecurityGroupArgs.builder()        
 *             .vpcId(defaultNetwork.id())
 *             .build());
 * 
 *         var defaultNamespace = new Namespace(&#34;defaultNamespace&#34;, NamespaceArgs.builder()        
 *             .namespaceId(defaultRandomInteger.result().applyValue(result -&gt; String.format(&#34;%s:example%s&#34;, defaultRegions.applyValue(getRegionsResult -&gt; getRegionsResult.regions()[0].id()),result)))
 *             .namespaceName(name)
 *             .namespaceDescription(name)
 *             .enableMicroRegistration(false)
 *             .build());
 * 
 *         var defaultApplication = new Application(&#34;defaultApplication&#34;, ApplicationArgs.builder()        
 *             .appDescription(name)
 *             .appName(name)
 *             .namespaceId(defaultNamespace.id())
 *             .imageUrl(String.format(&#34;registry-vpc.%s.aliyuncs.com/sae-demo-image/consumer:1.0&#34;, defaultRegions.applyValue(getRegionsResult -&gt; getRegionsResult.regions()[0].id())))
 *             .packageType(&#34;Image&#34;)
 *             .securityGroupId(defaultSecurityGroup.id())
 *             .vpcId(defaultNetwork.id())
 *             .vswitchId(defaultSwitch.id())
 *             .timezone(&#34;Asia/Beijing&#34;)
 *             .replicas(&#34;5&#34;)
 *             .cpu(&#34;500&#34;)
 *             .memory(&#34;2048&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Serverless App Engine (SAE) Application can be imported using the id, e.g.
 * 
 * ```sh
 *  $ pulumi import alicloud:sae/application:Application example &lt;id&gt;
 * ```
 * 
 */
@ResourceType(type="alicloud:sae/application:Application")
public class Application extends com.pulumi.resources.CustomResource {
    /**
     * The ARN of the RAM role required when pulling images across accounts. Only necessary if the image_url is pointing to an ACR EE instance.
     * 
     */
    @Export(name="acrAssumeRoleArn", type=String.class, parameters={})
    private Output</* @Nullable */ String> acrAssumeRoleArn;

    /**
     * @return The ARN of the RAM role required when pulling images across accounts. Only necessary if the image_url is pointing to an ACR EE instance.
     * 
     */
    public Output<Optional<String>> acrAssumeRoleArn() {
        return Codegen.optional(this.acrAssumeRoleArn);
    }
    /**
     * The ID of the ACR EE instance. Only necessary if the image_url is pointing to an ACR EE instance.
     * 
     */
    @Export(name="acrInstanceId", type=String.class, parameters={})
    private Output</* @Nullable */ String> acrInstanceId;

    /**
     * @return The ID of the ACR EE instance. Only necessary if the image_url is pointing to an ACR EE instance.
     * 
     */
    public Output<Optional<String>> acrInstanceId() {
        return Codegen.optional(this.acrInstanceId);
    }
    /**
     * Application description information. No more than 1024 characters.
     * 
     */
    @Export(name="appDescription", type=String.class, parameters={})
    private Output</* @Nullable */ String> appDescription;

    /**
     * @return Application description information. No more than 1024 characters.
     * 
     */
    public Output<Optional<String>> appDescription() {
        return Codegen.optional(this.appDescription);
    }
    /**
     * Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
     * 
     */
    @Export(name="appName", type=String.class, parameters={})
    private Output<String> appName;

    /**
     * @return Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
     * 
     */
    public Output<String> appName() {
        return this.appName;
    }
    /**
     * The auto config. Valid values: `false`, `true`.
     * 
     */
    @Export(name="autoConfig", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> autoConfig;

    /**
     * @return The auto config. Valid values: `false`, `true`.
     * 
     */
    public Output<Optional<Boolean>> autoConfig() {
        return Codegen.optional(this.autoConfig);
    }
    /**
     * The auto enable application scaling rule. Valid values: `false`, `true`.
     * 
     */
    @Export(name="autoEnableApplicationScalingRule", type=Boolean.class, parameters={})
    private Output<Boolean> autoEnableApplicationScalingRule;

    /**
     * @return The auto enable application scaling rule. Valid values: `false`, `true`.
     * 
     */
    public Output<Boolean> autoEnableApplicationScalingRule() {
        return this.autoEnableApplicationScalingRule;
    }
    /**
     * The batch wait time.
     * 
     */
    @Export(name="batchWaitTime", type=Integer.class, parameters={})
    private Output<Integer> batchWaitTime;

    /**
     * @return The batch wait time.
     * 
     */
    public Output<Integer> batchWaitTime() {
        return this.batchWaitTime;
    }
    /**
     * The change order desc.
     * 
     */
    @Export(name="changeOrderDesc", type=String.class, parameters={})
    private Output<String> changeOrderDesc;

    /**
     * @return The change order desc.
     * 
     */
    public Output<String> changeOrderDesc() {
        return this.changeOrderDesc;
    }
    /**
     * Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
     * 
     */
    @Export(name="command", type=String.class, parameters={})
    private Output</* @Nullable */ String> command;

    /**
     * @return Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
     * 
     */
    public Output<Optional<String>> command() {
        return Codegen.optional(this.command);
    }
    /**
     * Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
     * 
     */
    @Export(name="commandArgs", type=String.class, parameters={})
    private Output</* @Nullable */ String> commandArgs;

    /**
     * @return Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
     * 
     */
    public Output<Optional<String>> commandArgs() {
        return Codegen.optional(this.commandArgs);
    }
    /**
     * ConfigMap mount description.
     * 
     */
    @Export(name="configMapMountDesc", type=String.class, parameters={})
    private Output<String> configMapMountDesc;

    /**
     * @return ConfigMap mount description.
     * 
     */
    public Output<String> configMapMountDesc() {
        return this.configMapMountDesc;
    }
    /**
     * The CPU required for each instance, in millicores, cannot be 0. Valid values: `1000`, `16000`, `2000`, `32000`, `4000`, `500`, `8000`.
     * 
     */
    @Export(name="cpu", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> cpu;

    /**
     * @return The CPU required for each instance, in millicores, cannot be 0. Valid values: `1000`, `16000`, `2000`, `32000`, `4000`, `500`, `8000`.
     * 
     */
    public Output<Optional<Integer>> cpu() {
        return Codegen.optional(this.cpu);
    }
    /**
     * Custom host mapping in the container. For example: [{`hostName`:`samplehost`,`ip`:`127.0.0.1`}].
     * 
     */
    @Export(name="customHostAlias", type=String.class, parameters={})
    private Output<String> customHostAlias;

    /**
     * @return Custom host mapping in the container. For example: [{`hostName`:`samplehost`,`ip`:`127.0.0.1`}].
     * 
     */
    public Output<String> customHostAlias() {
        return this.customHostAlias;
    }
    /**
     * The deploy. Valid values: `false`, `true`.
     * 
     */
    @Export(name="deploy", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> deploy;

    /**
     * @return The deploy. Valid values: `false`, `true`.
     * 
     */
    public Output<Optional<Boolean>> deploy() {
        return Codegen.optional(this.deploy);
    }
    /**
     * The operating environment used by the Pandora application.
     * 
     */
    @Export(name="edasContainerVersion", type=String.class, parameters={})
    private Output</* @Nullable */ String> edasContainerVersion;

    /**
     * @return The operating environment used by the Pandora application.
     * 
     */
    public Output<Optional<String>> edasContainerVersion() {
        return Codegen.optional(this.edasContainerVersion);
    }
    /**
     * The enable ahas.
     * 
     */
    @Export(name="enableAhas", type=String.class, parameters={})
    private Output<String> enableAhas;

    /**
     * @return The enable ahas.
     * 
     */
    public Output<String> enableAhas() {
        return this.enableAhas;
    }
    /**
     * The enable grey tag route.
     * 
     */
    @Export(name="enableGreyTagRoute", type=Boolean.class, parameters={})
    private Output<Boolean> enableGreyTagRoute;

    /**
     * @return The enable grey tag route.
     * 
     */
    public Output<Boolean> enableGreyTagRoute() {
        return this.enableGreyTagRoute;
    }
    /**
     * Container environment variable parameters. For example,`	[{&#34;name&#34;:&#34;envtmp&#34;,&#34;value&#34;:&#34;0&#34;}]`. The value description is as follows:
     * 
     */
    @Export(name="envs", type=String.class, parameters={})
    private Output<String> envs;

    /**
     * @return Container environment variable parameters. For example,`	[{&#34;name&#34;:&#34;envtmp&#34;,&#34;value&#34;:&#34;0&#34;}]`. The value description is as follows:
     * 
     */
    public Output<String> envs() {
        return this.envs;
    }
    /**
     * Mirror address. Only Image type applications can configure the mirror address.
     * 
     */
    @Export(name="imageUrl", type=String.class, parameters={})
    private Output</* @Nullable */ String> imageUrl;

    /**
     * @return Mirror address. Only Image type applications can configure the mirror address.
     * 
     */
    public Output<Optional<String>> imageUrl() {
        return Codegen.optional(this.imageUrl);
    }
    /**
     * The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS &#34;$package_path&#34; $JarStartArgs.
     * 
     */
    @Export(name="jarStartArgs", type=String.class, parameters={})
    private Output</* @Nullable */ String> jarStartArgs;

    /**
     * @return The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS &#34;$package_path&#34; $JarStartArgs.
     * 
     */
    public Output<Optional<String>> jarStartArgs() {
        return Codegen.optional(this.jarStartArgs);
    }
    /**
     * The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS &#34;$package_path&#34; $JarStartArgs.
     * 
     */
    @Export(name="jarStartOptions", type=String.class, parameters={})
    private Output</* @Nullable */ String> jarStartOptions;

    /**
     * @return The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS &#34;$package_path&#34; $JarStartArgs.
     * 
     */
    public Output<Optional<String>> jarStartOptions() {
        return Codegen.optional(this.jarStartOptions);
    }
    /**
     * The JDK version that the deployment package depends on. Image type applications are not supported.
     * 
     */
    @Export(name="jdk", type=String.class, parameters={})
    private Output</* @Nullable */ String> jdk;

    /**
     * @return The JDK version that the deployment package depends on. Image type applications are not supported.
     * 
     */
    public Output<Optional<String>> jdk() {
        return Codegen.optional(this.jdk);
    }
    /**
     * Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
     * 
     */
    @Export(name="liveness", type=String.class, parameters={})
    private Output</* @Nullable */ String> liveness;

    /**
     * @return Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
     * 
     */
    public Output<Optional<String>> liveness() {
        return Codegen.optional(this.liveness);
    }
    /**
     * The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU. Valid values: `1024`, `131072`, `16384`, `2048`, `32768`, `4096`, `65536`, `8192`.
     * 
     */
    @Export(name="memory", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> memory;

    /**
     * @return The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU. Valid values: `1024`, `131072`, `16384`, `2048`, `32768`, `4096`, `65536`, `8192`.
     * 
     */
    public Output<Optional<Integer>> memory() {
        return Codegen.optional(this.memory);
    }
    /**
     * Select the Nacos registry. Valid values: `0`, `1`, `2`.
     * 
     */
    @Export(name="microRegistration", type=String.class, parameters={})
    private Output</* @Nullable */ String> microRegistration;

    /**
     * @return Select the Nacos registry. Valid values: `0`, `1`, `2`.
     * 
     */
    public Output<Optional<String>> microRegistration() {
        return Codegen.optional(this.microRegistration);
    }
    /**
     * Minimum Survival Instance Percentage. **NOTE:** When `min_ready_instances` and `min_ready_instance_ratio` are passed at the same time, and the value of `min_ready_instance_ratio` is not -1, the `min_ready_instance_ratio` parameter shall prevail. Assuming that `min_ready_instances` is 5 and `min_ready_instance_ratio` is 50, 50 is used to calculate the minimum number of surviving instances.The value description is as follows:
     * * `-1`: Initialization value, indicating that percentages are not used.
     * * `0~100`: The unit is percentage, rounded up. For example, if it is set to 50%, if there are currently 5 instances, the minimum number of surviving instances is 3.
     * 
     */
    @Export(name="minReadyInstanceRatio", type=Integer.class, parameters={})
    private Output<Integer> minReadyInstanceRatio;

    /**
     * @return Minimum Survival Instance Percentage. **NOTE:** When `min_ready_instances` and `min_ready_instance_ratio` are passed at the same time, and the value of `min_ready_instance_ratio` is not -1, the `min_ready_instance_ratio` parameter shall prevail. Assuming that `min_ready_instances` is 5 and `min_ready_instance_ratio` is 50, 50 is used to calculate the minimum number of surviving instances.The value description is as follows:
     * * `-1`: Initialization value, indicating that percentages are not used.
     * * `0~100`: The unit is percentage, rounded up. For example, if it is set to 50%, if there are currently 5 instances, the minimum number of surviving instances is 3.
     * 
     */
    public Output<Integer> minReadyInstanceRatio() {
        return this.minReadyInstanceRatio;
    }
    /**
     * The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
     * 
     */
    @Export(name="minReadyInstances", type=Integer.class, parameters={})
    private Output<Integer> minReadyInstances;

    /**
     * @return The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
     * 
     */
    public Output<Integer> minReadyInstances() {
        return this.minReadyInstances;
    }
    /**
     * Mount description.
     * 
     */
    @Export(name="mountDesc", type=String.class, parameters={})
    private Output</* @Nullable */ String> mountDesc;

    /**
     * @return Mount description.
     * 
     */
    public Output<Optional<String>> mountDesc() {
        return Codegen.optional(this.mountDesc);
    }
    /**
     * Mount point of NAS in application VPC.
     * 
     */
    @Export(name="mountHost", type=String.class, parameters={})
    private Output</* @Nullable */ String> mountHost;

    /**
     * @return Mount point of NAS in application VPC.
     * 
     */
    public Output<Optional<String>> mountHost() {
        return Codegen.optional(this.mountHost);
    }
    /**
     * SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
     * 
     */
    @Export(name="namespaceId", type=String.class, parameters={})
    private Output</* @Nullable */ String> namespaceId;

    /**
     * @return SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
     * 
     */
    public Output<Optional<String>> namespaceId() {
        return Codegen.optional(this.namespaceId);
    }
    /**
     * ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
     * 
     */
    @Export(name="nasId", type=String.class, parameters={})
    private Output</* @Nullable */ String> nasId;

    /**
     * @return ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
     * 
     */
    public Output<Optional<String>> nasId() {
        return Codegen.optional(this.nasId);
    }
    /**
     * OSS AccessKey ID.
     * 
     */
    @Export(name="ossAkId", type=String.class, parameters={})
    private Output</* @Nullable */ String> ossAkId;

    /**
     * @return OSS AccessKey ID.
     * 
     */
    public Output<Optional<String>> ossAkId() {
        return Codegen.optional(this.ossAkId);
    }
    /**
     * OSS  AccessKey Secret.
     * 
     */
    @Export(name="ossAkSecret", type=String.class, parameters={})
    private Output</* @Nullable */ String> ossAkSecret;

    /**
     * @return OSS  AccessKey Secret.
     * 
     */
    public Output<Optional<String>> ossAkSecret() {
        return Codegen.optional(this.ossAkSecret);
    }
    /**
     * OSS mount description information.
     * 
     */
    @Export(name="ossMountDescs", type=String.class, parameters={})
    private Output</* @Nullable */ String> ossMountDescs;

    /**
     * @return OSS mount description information.
     * 
     */
    public Output<Optional<String>> ossMountDescs() {
        return Codegen.optional(this.ossMountDescs);
    }
    /**
     * Application package type. Support FatJar, War and Image. Valid values: `FatJar`, `Image`, `War`.
     * 
     */
    @Export(name="packageType", type=String.class, parameters={})
    private Output<String> packageType;

    /**
     * @return Application package type. Support FatJar, War and Image. Valid values: `FatJar`, `Image`, `War`.
     * 
     */
    public Output<String> packageType() {
        return this.packageType;
    }
    /**
     * Deployment package address. Only FatJar or War type applications can configure the deployment package address.
     * 
     */
    @Export(name="packageUrl", type=String.class, parameters={})
    private Output</* @Nullable */ String> packageUrl;

    /**
     * @return Deployment package address. Only FatJar or War type applications can configure the deployment package address.
     * 
     */
    public Output<Optional<String>> packageUrl() {
        return Codegen.optional(this.packageUrl);
    }
    /**
     * The version number of the deployment package. Required when the Package Type is War and FatJar.
     * 
     */
    @Export(name="packageVersion", type=String.class, parameters={})
    private Output<String> packageVersion;

    /**
     * @return The version number of the deployment package. Required when the Package Type is War and FatJar.
     * 
     */
    public Output<String> packageVersion() {
        return this.packageVersion;
    }
    /**
     * The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don&#39;t need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
     * 
     */
    @Export(name="phpArmsConfigLocation", type=String.class, parameters={})
    private Output</* @Nullable */ String> phpArmsConfigLocation;

    /**
     * @return The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don&#39;t need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
     * 
     */
    public Output<Optional<String>> phpArmsConfigLocation() {
        return Codegen.optional(this.phpArmsConfigLocation);
    }
    /**
     * PHP configuration file content.
     * 
     */
    @Export(name="phpConfig", type=String.class, parameters={})
    private Output</* @Nullable */ String> phpConfig;

    /**
     * @return PHP configuration file content.
     * 
     */
    public Output<Optional<String>> phpConfig() {
        return Codegen.optional(this.phpConfig);
    }
    /**
     * PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
     * 
     */
    @Export(name="phpConfigLocation", type=String.class, parameters={})
    private Output</* @Nullable */ String> phpConfigLocation;

    /**
     * @return PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
     * 
     */
    public Output<Optional<String>> phpConfigLocation() {
        return Codegen.optional(this.phpConfigLocation);
    }
    /**
     * Execute the script after startup, the format is like: {`exec`:{`command`:[`cat`,&#34;/etc/group&#34;]}}.
     * 
     */
    @Export(name="postStart", type=String.class, parameters={})
    private Output</* @Nullable */ String> postStart;

    /**
     * @return Execute the script after startup, the format is like: {`exec`:{`command`:[`cat`,&#34;/etc/group&#34;]}}.
     * 
     */
    public Output<Optional<String>> postStart() {
        return Codegen.optional(this.postStart);
    }
    /**
     * Execute the script before stopping, the format is like: {`exec`:{`command`:[`cat`,&#34;/etc/group&#34;]}}.
     * 
     */
    @Export(name="preStop", type=String.class, parameters={})
    private Output</* @Nullable */ String> preStop;

    /**
     * @return Execute the script before stopping, the format is like: {`exec`:{`command`:[`cat`,&#34;/etc/group&#34;]}}.
     * 
     */
    public Output<Optional<String>> preStop() {
        return Codegen.optional(this.preStop);
    }
    /**
     * Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {`exec`:{`command`:[`sh`,&#34;-c&#34;,&#34;cat /home/admin/start.sh&#34;]},`initialDelaySeconds`:30,`periodSeconds`:30,&#34;timeoutSeconds &#34;:2}. Valid values: `command`, `initialDelaySeconds`, `periodSeconds`, `timeoutSeconds`.
     * 
     */
    @Export(name="readiness", type=String.class, parameters={})
    private Output</* @Nullable */ String> readiness;

    /**
     * @return Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {`exec`:{`command`:[`sh`,&#34;-c&#34;,&#34;cat /home/admin/start.sh&#34;]},`initialDelaySeconds`:30,`periodSeconds`:30,&#34;timeoutSeconds &#34;:2}. Valid values: `command`, `initialDelaySeconds`, `periodSeconds`, `timeoutSeconds`.
     * 
     */
    public Output<Optional<String>> readiness() {
        return Codegen.optional(this.readiness);
    }
    /**
     * Initial number of instances.
     * 
     */
    @Export(name="replicas", type=Integer.class, parameters={})
    private Output<Integer> replicas;

    /**
     * @return Initial number of instances.
     * 
     */
    public Output<Integer> replicas() {
        return this.replicas;
    }
    /**
     * Security group ID.
     * 
     */
    @Export(name="securityGroupId", type=String.class, parameters={})
    private Output<String> securityGroupId;

    /**
     * @return Security group ID.
     * 
     */
    public Output<String> securityGroupId() {
        return this.securityGroupId;
    }
    /**
     * SLS  configuration.
     * 
     */
    @Export(name="slsConfigs", type=String.class, parameters={})
    private Output</* @Nullable */ String> slsConfigs;

    /**
     * @return SLS  configuration.
     * 
     */
    public Output<Optional<String>> slsConfigs() {
        return Codegen.optional(this.slsConfigs);
    }
    /**
     * The status of the resource. Valid values: `RUNNING`, `STOPPED`.
     * 
     */
    @Export(name="status", type=String.class, parameters={})
    private Output<String> status;

    /**
     * @return The status of the resource. Valid values: `RUNNING`, `STOPPED`.
     * 
     */
    public Output<String> status() {
        return this.status;
    }
    /**
     * A mapping of tags to assign to the resource.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, Object.class})
    private Output</* @Nullable */ Map<String,Object>> tags;

    /**
     * @return A mapping of tags to assign to the resource.
     * 
     */
    public Output<Optional<Map<String,Object>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60. Valid values: [1,60].
     * 
     */
    @Export(name="terminationGracePeriodSeconds", type=Integer.class, parameters={})
    private Output<Integer> terminationGracePeriodSeconds;

    /**
     * @return Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60. Valid values: [1,60].
     * 
     */
    public Output<Integer> terminationGracePeriodSeconds() {
        return this.terminationGracePeriodSeconds;
    }
    /**
     * Time zone, the default value is Asia/Shanghai.
     * 
     */
    @Export(name="timezone", type=String.class, parameters={})
    private Output<String> timezone;

    /**
     * @return Time zone, the default value is Asia/Shanghai.
     * 
     */
    public Output<String> timezone() {
        return this.timezone;
    }
    /**
     * Tomcat file configuration, set to &#34;{}&#34; means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL. Valid values: `contextInputType`, `contextPath`, `httpPort`, `maxThreads`, `uriEncoding`, `useBodyEncoding`, `useDefaultConfig`.
     * 
     */
    @Export(name="tomcatConfig", type=String.class, parameters={})
    private Output</* @Nullable */ String> tomcatConfig;

    /**
     * @return Tomcat file configuration, set to &#34;{}&#34; means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL. Valid values: `contextInputType`, `contextPath`, `httpPort`, `maxThreads`, `uriEncoding`, `useBodyEncoding`, `useDefaultConfig`.
     * 
     */
    public Output<Optional<String>> tomcatConfig() {
        return Codegen.optional(this.tomcatConfig);
    }
    /**
     * The update strategy.
     * 
     */
    @Export(name="updateStrategy", type=String.class, parameters={})
    private Output<String> updateStrategy;

    /**
     * @return The update strategy.
     * 
     */
    public Output<String> updateStrategy() {
        return this.updateStrategy;
    }
    /**
     * Application version id.
     * 
     */
    @Export(name="versionId", type=String.class, parameters={})
    private Output</* @Nullable */ String> versionId;

    /**
     * @return Application version id.
     * 
     */
    public Output<Optional<String>> versionId() {
        return Codegen.optional(this.versionId);
    }
    /**
     * The vpc id.
     * 
     */
    @Export(name="vpcId", type=String.class, parameters={})
    private Output</* @Nullable */ String> vpcId;

    /**
     * @return The vpc id.
     * 
     */
    public Output<Optional<String>> vpcId() {
        return Codegen.optional(this.vpcId);
    }
    /**
     * The vswitch id.
     * 
     */
    @Export(name="vswitchId", type=String.class, parameters={})
    private Output</* @Nullable */ String> vswitchId;

    /**
     * @return The vswitch id.
     * 
     */
    public Output<Optional<String>> vswitchId() {
        return Codegen.optional(this.vswitchId);
    }
    /**
     * WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap &#34;$@&#34; start.
     * 
     */
    @Export(name="warStartOptions", type=String.class, parameters={})
    private Output</* @Nullable */ String> warStartOptions;

    /**
     * @return WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap &#34;$@&#34; start.
     * 
     */
    public Output<Optional<String>> warStartOptions() {
        return Codegen.optional(this.warStartOptions);
    }
    /**
     * The version of tomcat that the deployment package depends on. Image type applications are not supported.
     * 
     */
    @Export(name="webContainer", type=String.class, parameters={})
    private Output</* @Nullable */ String> webContainer;

    /**
     * @return The version of tomcat that the deployment package depends on. Image type applications are not supported.
     * 
     */
    public Output<Optional<String>> webContainer() {
        return Codegen.optional(this.webContainer);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Application(String name) {
        this(name, ApplicationArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Application(String name, ApplicationArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Application(String name, ApplicationArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("alicloud:sae/application:Application", name, args == null ? ApplicationArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Application(String name, Output<String> id, @Nullable ApplicationState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("alicloud:sae/application:Application", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "ossAkId",
                "ossAkSecret"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Application get(String name, Output<String> id, @Nullable ApplicationState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Application(name, id, state, options);
    }
}
