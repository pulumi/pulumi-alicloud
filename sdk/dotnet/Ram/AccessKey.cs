// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AliCloud.Ram
{
    /// <summary>
    /// Provides a RAM Access Key resource.
    /// 
    /// For information about RAM Access Key and how to use it, see [What is Access Key](https://www.alibabacloud.com/help/en/ram/developer-reference/api-ram-2015-05-01-createaccesskey).
    /// 
    /// &gt; **NOTE:** Available since v1.0.0.
    /// 
    /// &gt; **NOTE:**  You should set the `SecretFile` if you want to get the access key.
    /// 
    /// &gt; **NOTE:**  From version 1.98.0, if not set `PgpKey`, the resource will output the access key secret to field `Secret` and please protect your backend state file judiciously
    /// 
    /// ## Example Usage
    /// 
    /// Output the secret to a file.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using AliCloud = Pulumi.AliCloud;
    /// using Random = Pulumi.Random;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Random.Index.Integer("default", new()
    ///     {
    ///         Min = 10000,
    ///         Max = 99999,
    ///     });
    /// 
    ///     // Create a new RAM access key for user.
    ///     var user = new AliCloud.Ram.User("user", new()
    ///     {
    ///         Name = $"terraform-example-{@default.Result}",
    ///         DisplayName = "user_display_name",
    ///         Mobile = "86-18688888888",
    ///         Email = "hello.uuu@aaa.com",
    ///         Comments = "yoyoyo",
    ///         Force = true,
    ///     });
    /// 
    ///     var ak = new AliCloud.Ram.AccessKey("ak", new()
    ///     {
    ///         UserName = user.Name,
    ///         SecretFile = "/xxx/xxx/xxx.txt",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// Using `PgpKey` to encrypt the secret.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using AliCloud = Pulumi.AliCloud;
    /// using Random = Pulumi.Random;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Random.Index.Integer("default", new()
    ///     {
    ///         Min = 10000,
    ///         Max = 99999,
    ///     });
    /// 
    ///     // Create a new RAM access key for user.
    ///     var user = new AliCloud.Ram.User("user", new()
    ///     {
    ///         Name = $"terraform-example-{@default.Result}",
    ///         DisplayName = "user_display_name",
    ///         Mobile = "86-18688888888",
    ///         Email = "hello.uuu@aaa.com",
    ///         Comments = "yoyoyo",
    ///         Force = true,
    ///     });
    /// 
    ///     var encrypt = new AliCloud.Ram.AccessKey("encrypt", new()
    ///     {
    ///         UserName = user.Name,
    ///         PgpKey = @"mQENBFXbjPUBCADjNjCUQwfxKL+RR2GA6pv/1K+zJZ8UWIF9S0lk7cVIEfJiprzzwiMwBS5cD0da
    /// rGin1FHvIWOZxujA7oW0O2TUuatqI3aAYDTfRYurh6iKLC+VS+F7H+/mhfFvKmgr0Y5kDCF1j0T/
    /// 063QZ84IRGucR/X43IY7kAtmxGXH0dYOCzOe5UBX1fTn3mXGe2ImCDWBH7gOViynXmb6XNvXkP0f
    /// sF5St9jhO7mbZU9EFkv9O3t3EaURfHopsCVDOlCkFCw5ArY+DUORHRzoMX0PnkyQb5OzibkChzpg
    /// 8hQssKeVGpuskTdz5Q7PtdW71jXd4fFVzoNH8fYwRpziD2xNvi6HABEBAAG0EFZhdWx0IFRlc3Qg
    /// S2V5IDGJATgEEwECACIFAlXbjPUCGy8GCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEOfLr44B
    /// HbeTo+sH/i7bapIgPnZsJ81hmxPj4W12uvunksGJiC7d4hIHsG7kmJRTJfjECi+AuTGeDwBy84TD
    /// cRaOB6e79fj65Fg6HgSahDUtKJbGxj/lWzmaBuTzlN3CEe8cMwIPqPT2kajJVdOyrvkyuFOdPFOE
    /// A7bdCH0MqgIdM2SdF8t40k/ATfuD2K1ZmumJ508I3gF39jgTnPzD4C8quswrMQ3bzfvKC3klXRlB
    /// C0yoArn+0QA3cf2B9T4zJ2qnvgotVbeK/b1OJRNj6Poeo+SsWNc/A5mw7lGScnDgL3yfwCm1gQXa
    /// QKfOt5x+7GqhWDw10q+bJpJlI10FfzAnhMF9etSqSeURBRW5AQ0EVduM9QEIAL53hJ5bZJ7oEDCn
    /// aY+SCzt9QsAfnFTAnZJQrvkvusJzrTQ088eUQmAjvxkfRqnv981fFwGnh2+I1Ktm698UAZS9Jt8y
    /// jak9wWUICKQO5QUt5k8cHwldQXNXVXFa+TpQWQR5yW1a9okjh5o/3d4cBt1yZPUJJyLKY43Wvptb
    /// 6EuEsScO2DnRkh5wSMDQ7dTooddJCmaq3LTjOleRFQbu9ij386Do6jzK69mJU56TfdcydkxkWF5N
    /// ZLGnED3lq+hQNbe+8UI5tD2oP/3r5tXKgMy1R/XPvR/zbfwvx4FAKFOP01awLq4P3d/2xOkMu4Lu
    /// 9p315E87DOleYwxk+FoTqXEAEQEAAYkCPgQYAQIACQUCVduM9QIbLgEpCRDny6+OAR23k8BdIAQZ
    /// AQIABgUCVduM9QAKCRAID0JGyHtSGmqYB/4m4rJbbWa7dBJ8VqRU7ZKnNRDR9CVhEGipBmpDGRYu
    /// lEimOPzLUX/ZXZmTZzgemeXLBaJJlWnopVUWuAsyjQuZAfdd8nHkGRHG0/DGum0l4sKTta3OPGHN
    /// C1z1dAcQ1RCr9bTD3PxjLBczdGqhzw71trkQRBRdtPiUchltPMIyjUHqVJ0xmg0hPqFic0fICsr0
    /// YwKoz3h9+QEcZHvsjSZjgydKvfLYcm+4DDMCCqcHuJrbXJKUWmJcXR0y/+HQONGrGJ5xWdO+6eJi
    /// oPn2jVMnXCm4EKc7fcLFrz/LKmJ8seXhxjM3EdFtylBGCrx3xdK0f+JDNQaC/rhUb5V2XuX6VwoH
    /// /AtY+XsKVYRfNIupLOUcf/srsm3IXT4SXWVomOc9hjGQiJ3rraIbADsc+6bCAr4XNZS7moViAAcI
    /// PXFv3m3WfUlnG/om78UjQqyVACRZqqAGmuPq+TSkRUCpt9h+A39LQWkojHqyob3cyLgy6z9Q557O
    /// 9uK3lQozbw2gH9zC0RqnePl+rsWIUU/ga16fH6pWc1uJiEBt8UZGypQ/E56/343epmYAe0a87sHx
    /// 8iDV+dNtDVKfPRENiLOOc19MmS+phmUyrbHqI91c0pmysYcJZCD3a502X1gpjFbPZcRtiTmGnUKd
    /// OIu60YPNE4+h7u2CfYyFPu3AlUaGNMBlvy6PEpU=
    /// ",
    ///     });
    /// 
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["encryptedSecret"] = encrypt.EncryptedSecret,
    ///     };
    /// });
    /// ```
    /// </summary>
    [AliCloudResourceType("alicloud:ram/accessKey:AccessKey")]
    public partial class AccessKey : global::Pulumi.CustomResource
    {
        /// <summary>
        /// (Available since v1.246.0) The create time of the AccessKey.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        [Output("encryptedSecret")]
        public Output<string> EncryptedSecret { get; private set; } = null!;

        /// <summary>
        /// (Available since v1.47.0) The fingerprint of the PGP key used to encrypt the secret
        /// </summary>
        [Output("keyFingerprint")]
        public Output<string> KeyFingerprint { get; private set; } = null!;

        /// <summary>
        /// Either a base-64 encoded PGP public key, or a keybase username in the form `keybase:some_person_that_exists`
        /// </summary>
        [Output("pgpKey")]
        public Output<string?> PgpKey { get; private set; } = null!;

        /// <summary>
        /// (Available since v1.98.0) The secret access key. Note that this will be written to the state file. 
        /// If you use this, please protect your backend state file judiciously.
        /// Alternatively, you may supply a `PgpKey` instead, which will prevent the secret from being stored in plaintext,
        /// at the cost of preventing the use of the secret key in automation.
        /// </summary>
        [Output("secret")]
        public Output<string> Secret { get; private set; } = null!;

        /// <summary>
        /// The name of file that can save access key id and access key secret. Strongly suggest you to specified it when you creating access key, otherwise, you wouldn't get its secret ever.
        /// </summary>
        [Output("secretFile")]
        public Output<string?> SecretFile { get; private set; } = null!;

        /// <summary>
        /// The status of the AccessKey. Value:
        /// - Active: Activated.
        /// - Inactive: Disabled.
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// The RAM user name.
        /// </summary>
        [Output("userName")]
        public Output<string?> UserName { get; private set; } = null!;


        /// <summary>
        /// Create a AccessKey resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AccessKey(string name, AccessKeyArgs? args = null, CustomResourceOptions? options = null)
            : base("alicloud:ram/accessKey:AccessKey", name, args ?? new AccessKeyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AccessKey(string name, Input<string> id, AccessKeyState? state = null, CustomResourceOptions? options = null)
            : base("alicloud:ram/accessKey:AccessKey", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "secret",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AccessKey resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AccessKey Get(string name, Input<string> id, AccessKeyState? state = null, CustomResourceOptions? options = null)
        {
            return new AccessKey(name, id, state, options);
        }
    }

    public sealed class AccessKeyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Either a base-64 encoded PGP public key, or a keybase username in the form `keybase:some_person_that_exists`
        /// </summary>
        [Input("pgpKey")]
        public Input<string>? PgpKey { get; set; }

        /// <summary>
        /// The name of file that can save access key id and access key secret. Strongly suggest you to specified it when you creating access key, otherwise, you wouldn't get its secret ever.
        /// </summary>
        [Input("secretFile")]
        public Input<string>? SecretFile { get; set; }

        /// <summary>
        /// The status of the AccessKey. Value:
        /// - Active: Activated.
        /// - Inactive: Disabled.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// The RAM user name.
        /// </summary>
        [Input("userName")]
        public Input<string>? UserName { get; set; }

        public AccessKeyArgs()
        {
        }
        public static new AccessKeyArgs Empty => new AccessKeyArgs();
    }

    public sealed class AccessKeyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Available since v1.246.0) The create time of the AccessKey.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        [Input("encryptedSecret")]
        public Input<string>? EncryptedSecret { get; set; }

        /// <summary>
        /// (Available since v1.47.0) The fingerprint of the PGP key used to encrypt the secret
        /// </summary>
        [Input("keyFingerprint")]
        public Input<string>? KeyFingerprint { get; set; }

        /// <summary>
        /// Either a base-64 encoded PGP public key, or a keybase username in the form `keybase:some_person_that_exists`
        /// </summary>
        [Input("pgpKey")]
        public Input<string>? PgpKey { get; set; }

        [Input("secret")]
        private Input<string>? _secret;

        /// <summary>
        /// (Available since v1.98.0) The secret access key. Note that this will be written to the state file. 
        /// If you use this, please protect your backend state file judiciously.
        /// Alternatively, you may supply a `PgpKey` instead, which will prevent the secret from being stored in plaintext,
        /// at the cost of preventing the use of the secret key in automation.
        /// </summary>
        public Input<string>? Secret
        {
            get => _secret;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secret = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The name of file that can save access key id and access key secret. Strongly suggest you to specified it when you creating access key, otherwise, you wouldn't get its secret ever.
        /// </summary>
        [Input("secretFile")]
        public Input<string>? SecretFile { get; set; }

        /// <summary>
        /// The status of the AccessKey. Value:
        /// - Active: Activated.
        /// - Inactive: Disabled.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// The RAM user name.
        /// </summary>
        [Input("userName")]
        public Input<string>? UserName { get; set; }

        public AccessKeyState()
        {
        }
        public static new AccessKeyState Empty => new AccessKeyState();
    }
}
